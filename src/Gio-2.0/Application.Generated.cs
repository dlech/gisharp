// ATTENTION: This file is automatically generated. Do not edit manually.
#nullable enable
namespace GISharp.Lib.Gio
{
    /// <include file="Application.xmldoc" path="declaration/member[@name='Application']/*" />
    [GISharp.Runtime.SinceAttribute("2.28")]
    [GISharp.Runtime.GTypeAttribute("GApplication", IsProxyForUnmanagedType = true)]
    [GISharp.Runtime.GTypeStructAttribute(typeof(ApplicationClass))]
    public partial class Application : GISharp.Lib.GObject.Object, GISharp.Lib.Gio.IActionGroup, GISharp.Lib.Gio.IActionMap
    {
        static readonly GISharp.Lib.GObject.GType _GType = g_application_get_type();

        /// <summary>
        /// Unmanaged data structure
        /// </summary>
        unsafe protected new struct Struct
        {
#pragma warning disable CS0649
            /// <include file="Application.xmldoc" path="declaration/member[@name='ParentInstance']/*" />
            public GISharp.Lib.GObject.Object.Struct ParentInstance;

            /// <include file="Application.xmldoc" path="declaration/member[@name='Priv']/*" />
            public System.IntPtr Priv;
#pragma warning restore CS0649
        }

        /// <include file="Application.xmldoc" path="declaration/member[@name='ActionGroup']/*" />
        [GISharp.Runtime.GPropertyAttribute("action-group")]
        public GISharp.Lib.Gio.IActionGroup? ActionGroup { set => SetProperty("action-group", value); }

        /// <include file="Application.xmldoc" path="declaration/member[@name='ApplicationId_']/*" />
        [GISharp.Runtime.GPropertyAttribute("application-id", Construct = GISharp.Runtime.GPropertyConstruct.Yes)]
        public GISharp.Lib.GLib.Utf8? ApplicationId_ { get => (GISharp.Lib.GLib.Utf8?)GetProperty("application-id")!; set => SetProperty("application-id", value); }

        /// <include file="Application.xmldoc" path="declaration/member[@name='Flags_']/*" />
        [GISharp.Runtime.GPropertyAttribute("flags")]
        public GISharp.Lib.Gio.ApplicationFlags Flags_ { get => (GISharp.Lib.Gio.ApplicationFlags)GetProperty("flags")!; set => SetProperty("flags", value); }

        /// <include file="Application.xmldoc" path="declaration/member[@name='InactivityTimeout_']/*" />
        [GISharp.Runtime.GPropertyAttribute("inactivity-timeout")]
        public System.UInt32 InactivityTimeout_ { get => (System.UInt32)GetProperty("inactivity-timeout")!; set => SetProperty("inactivity-timeout", value); }

        /// <include file="Application.xmldoc" path="declaration/member[@name='IsBusy_']/*" />
        [GISharp.Runtime.SinceAttribute("2.44")]
        [GISharp.Runtime.GPropertyAttribute("is-busy")]
        public System.Boolean IsBusy_ { get => (System.Boolean)GetProperty("is-busy")!; }

        /// <include file="Application.xmldoc" path="declaration/member[@name='IsRegistered_']/*" />
        [GISharp.Runtime.GPropertyAttribute("is-registered")]
        public System.Boolean IsRegistered_ { get => (System.Boolean)GetProperty("is-registered")!; }

        /// <include file="Application.xmldoc" path="declaration/member[@name='IsRemote_']/*" />
        [GISharp.Runtime.GPropertyAttribute("is-remote")]
        public System.Boolean IsRemote_ { get => (System.Boolean)GetProperty("is-remote")!; }

        /// <include file="Application.xmldoc" path="declaration/member[@name='ResourceBasePath_']/*" />
        [GISharp.Runtime.GPropertyAttribute("resource-base-path")]
        public GISharp.Lib.GLib.Utf8? ResourceBasePath_ { get => (GISharp.Lib.GLib.Utf8?)GetProperty("resource-base-path")!; set => SetProperty("resource-base-path", value); }

        /// <include file="Application.xmldoc" path="declaration/member[@name='Default']/*" />
        [GISharp.Runtime.SinceAttribute("2.32")]
        public static GISharp.Lib.Gio.Application Default { get => GetDefault(); }

        /// <include file="Application.xmldoc" path="declaration/member[@name='ApplicationId']/*" />
        [GISharp.Runtime.SinceAttribute("2.28")]
        public GISharp.Lib.GLib.NullableUnownedUtf8 ApplicationId { get => GetApplicationId(); set => SetApplicationId(value); }

        /// <include file="Application.xmldoc" path="declaration/member[@name='DbusObjectPath']/*" />
        [GISharp.Runtime.SinceAttribute("2.34")]
        public GISharp.Lib.GLib.UnownedUtf8 DbusObjectPath { get => GetDbusObjectPath(); }

        /// <include file="Application.xmldoc" path="declaration/member[@name='Flags']/*" />
        [GISharp.Runtime.SinceAttribute("2.28")]
        public GISharp.Lib.Gio.ApplicationFlags Flags { get => GetFlags(); set => SetFlags(value); }

        /// <include file="Application.xmldoc" path="declaration/member[@name='InactivityTimeout']/*" />
        [GISharp.Runtime.SinceAttribute("2.28")]
        public System.UInt32 InactivityTimeout { get => GetInactivityTimeout(); set => SetInactivityTimeout(value); }

        /// <include file="Application.xmldoc" path="declaration/member[@name='IsBusy']/*" />
        [GISharp.Runtime.SinceAttribute("2.44")]
        public System.Boolean IsBusy { get => GetIsBusy(); }

        /// <include file="Application.xmldoc" path="declaration/member[@name='IsRegistered']/*" />
        [GISharp.Runtime.SinceAttribute("2.28")]
        public System.Boolean IsRegistered { get => GetIsRegistered(); }

        /// <include file="Application.xmldoc" path="declaration/member[@name='IsRemote']/*" />
        [GISharp.Runtime.SinceAttribute("2.28")]
        public System.Boolean IsRemote { get => GetIsRemote(); }

        /// <include file="Application.xmldoc" path="declaration/member[@name='ResourceBasePath']/*" />
        [GISharp.Runtime.SinceAttribute("2.42")]
        public GISharp.Lib.GLib.NullableUnownedUtf8 ResourceBasePath { get => GetResourceBasePath(); set => SetResourceBasePath(value); }

        /// <summary>
        /// For internal runtime use only.
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        public Application(System.IntPtr handle, GISharp.Runtime.Transfer ownership) : base(handle, ownership)
        {
        }

        /// <summary>
        /// Creates a new #GApplication instance.
        /// </summary>
        /// <remarks>
        /// If non-%NULL, the application id must be valid.  See
        /// g_application_id_is_valid().
        /// 
        /// If no application ID is given then some features of #GApplication
        /// (most notably application uniqueness) will be disabled.
        /// </remarks>
        /// <param name="applicationId">
        /// the application id
        /// </param>
        /// <param name="flags">
        /// the application flags
        /// </param>
        /// <returns>
        /// a new #GApplication instance
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Application" type="GApplication*" managed-name="Application" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        static extern unsafe System.IntPtr g_application_new(
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr applicationId,
        /* <type name="ApplicationFlags" type="GApplicationFlags" managed-name="ApplicationFlags" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.ApplicationFlags flags);

        static unsafe System.IntPtr New(GISharp.Lib.GLib.NullableUnownedUtf8 applicationId, GISharp.Lib.Gio.ApplicationFlags flags)
        {
            var applicationId_ = applicationId.Handle;
            var flags_ = (GISharp.Lib.Gio.ApplicationFlags)flags;
            var ret_ = g_application_new(applicationId_,flags_);
            return ret_;
        }

        /// <include file="Application.xmldoc" path="declaration/member[@name='Application(GISharp.Lib.GLib.NullableUnownedUtf8,GISharp.Lib.Gio.ApplicationFlags)']/*" />
        public Application(GISharp.Lib.GLib.NullableUnownedUtf8 applicationId, GISharp.Lib.Gio.ApplicationFlags flags) : this(New(applicationId, flags), GISharp.Runtime.Transfer.Full)
        {
        }

        static unsafe System.IntPtr New(System.String? applicationId, GISharp.Lib.Gio.ApplicationFlags flags)
        {
            using var applicationIdUtf8 = applicationId == null ? null : new GISharp.Lib.GLib.Utf8(applicationId);
            return New((GISharp.Lib.GLib.NullableUnownedUtf8)applicationIdUtf8, flags);
        }

        /// <include file="Application.xmldoc" path="declaration/member[@name='Application(System.String?,GISharp.Lib.Gio.ApplicationFlags)']/*" />
        public Application(System.String? applicationId, GISharp.Lib.Gio.ApplicationFlags flags) : this(New(applicationId, flags), GISharp.Runtime.Transfer.Full)
        {
        }

        /// <include file="Application.xmldoc" path="declaration/member[@name='ActivatedEventArgs']/*" />
        public sealed class ActivatedEventArgs : GISharp.Runtime.GSignalEventArgs
        {
            readonly System.Object[] args;

            /// <summary>
            /// Creates a new instance.
            /// </summary>
            public ActivatedEventArgs(params System.Object[] args)
            {
                this.args = args ?? throw new System.ArgumentNullException(nameof(args));
            }
        }

        readonly GISharp.Runtime.GSignalManager<ActivatedEventArgs> activatedSignalManager = new GISharp.Runtime.GSignalManager<ActivatedEventArgs>("activate", _GType);

        /// <include file="Application.xmldoc" path="declaration/member[@name='Activated']/*" />
        [GISharp.Runtime.GSignalAttribute("activate", When = GISharp.Runtime.EmissionStage.Last)]
        public event System.EventHandler<ActivatedEventArgs> Activated { add => activatedSignalManager.Add(this, value); remove => activatedSignalManager.Remove(value); }

        /// <include file="Application.xmldoc" path="declaration/member[@name='CommandLinedEventArgs']/*" />
        public sealed class CommandLinedEventArgs : GISharp.Runtime.GSignalEventArgs
        {
            readonly System.Object[] args;

            /// <include file="Application.xmldoc" path="declaration/member[@name='CommandLine']/*" />
            public GISharp.Lib.Gio.ApplicationCommandLine CommandLine => (GISharp.Lib.Gio.ApplicationCommandLine)args[1];

            /// <include file="Application.xmldoc" path="declaration/member[@name='ReturnValue']/*" />
            public System.Int32 ReturnValue { get; set; }

            /// <summary>
            /// Creates a new instance.
            /// </summary>
            public CommandLinedEventArgs(params System.Object[] args)
            {
                this.args = args ?? throw new System.ArgumentNullException(nameof(args));
            }
        }

        readonly GISharp.Runtime.GSignalManager<CommandLinedEventArgs> commandLinedSignalManager = new GISharp.Runtime.GSignalManager<CommandLinedEventArgs>("command-line", _GType);

        /// <include file="Application.xmldoc" path="declaration/member[@name='CommandLined']/*" />
        [GISharp.Runtime.GSignalAttribute("command-line", When = GISharp.Runtime.EmissionStage.Last)]
        public event System.EventHandler<CommandLinedEventArgs> CommandLined { add => commandLinedSignalManager.Add(this, value); remove => commandLinedSignalManager.Remove(value); }

        /// <include file="Application.xmldoc" path="declaration/member[@name='HandledLocalOptionsEventArgs']/*" />
        public sealed class HandledLocalOptionsEventArgs : GISharp.Runtime.GSignalEventArgs
        {
            readonly System.Object[] args;

            /// <include file="Application.xmldoc" path="declaration/member[@name='Options']/*" />
            public GISharp.Lib.GLib.VariantDict Options => (GISharp.Lib.GLib.VariantDict)args[1];

            /// <include file="Application.xmldoc" path="declaration/member[@name='ReturnValue']/*" />
            public System.Int32 ReturnValue { get; set; }

            /// <summary>
            /// Creates a new instance.
            /// </summary>
            public HandledLocalOptionsEventArgs(params System.Object[] args)
            {
                this.args = args ?? throw new System.ArgumentNullException(nameof(args));
            }
        }

        readonly GISharp.Runtime.GSignalManager<HandledLocalOptionsEventArgs> handledLocalOptionsSignalManager = new GISharp.Runtime.GSignalManager<HandledLocalOptionsEventArgs>("handle-local-options", _GType);

        /// <include file="Application.xmldoc" path="declaration/member[@name='HandledLocalOptions']/*" />
        [GISharp.Runtime.SinceAttribute("2.40")]
        [GISharp.Runtime.GSignalAttribute("handle-local-options", When = GISharp.Runtime.EmissionStage.Last)]
        public event System.EventHandler<HandledLocalOptionsEventArgs> HandledLocalOptions { add => handledLocalOptionsSignalManager.Add(this, value); remove => handledLocalOptionsSignalManager.Remove(value); }

        /// <include file="Application.xmldoc" path="declaration/member[@name='NameLostEventArgs']/*" />
        public sealed class NameLostEventArgs : GISharp.Runtime.GSignalEventArgs
        {
            readonly System.Object[] args;

            /// <include file="Application.xmldoc" path="declaration/member[@name='ReturnValue']/*" />
            public System.Boolean ReturnValue { get; set; }

            /// <summary>
            /// Creates a new instance.
            /// </summary>
            public NameLostEventArgs(params System.Object[] args)
            {
                this.args = args ?? throw new System.ArgumentNullException(nameof(args));
            }
        }

        readonly GISharp.Runtime.GSignalManager<NameLostEventArgs> nameLostSignalManager = new GISharp.Runtime.GSignalManager<NameLostEventArgs>("name-lost", _GType);

        /// <include file="Application.xmldoc" path="declaration/member[@name='NameLost']/*" />
        [GISharp.Runtime.SinceAttribute("2.60")]
        [GISharp.Runtime.GSignalAttribute("name-lost", When = GISharp.Runtime.EmissionStage.Last)]
        public event System.EventHandler<NameLostEventArgs> NameLost { add => nameLostSignalManager.Add(this, value); remove => nameLostSignalManager.Remove(value); }

        /// <include file="Application.xmldoc" path="declaration/member[@name='OpenedEventArgs']/*" />
        public sealed class OpenedEventArgs : GISharp.Runtime.GSignalEventArgs
        {
            readonly System.Object[] args;

            /// <include file="Application.xmldoc" path="declaration/member[@name='Files']/*" />
            public GISharp.Runtime.CPtrArray<GISharp.Lib.Gio.IFile> Files => (GISharp.Runtime.CPtrArray<GISharp.Lib.Gio.IFile>)args[1];

            /// <include file="Application.xmldoc" path="declaration/member[@name='Hint']/*" />
            public GISharp.Lib.GLib.Utf8 Hint => (GISharp.Lib.GLib.Utf8)args[2];

            /// <summary>
            /// Creates a new instance.
            /// </summary>
            public OpenedEventArgs(params System.Object[] args)
            {
                this.args = args ?? throw new System.ArgumentNullException(nameof(args));
            }
        }

        readonly GISharp.Runtime.GSignalManager<OpenedEventArgs> openedSignalManager = new GISharp.Runtime.GSignalManager<OpenedEventArgs>("open", _GType);

        /// <include file="Application.xmldoc" path="declaration/member[@name='Opened']/*" />
        [GISharp.Runtime.GSignalAttribute("open", When = GISharp.Runtime.EmissionStage.Last)]
        public event System.EventHandler<OpenedEventArgs> Opened { add => openedSignalManager.Add(this, value); remove => openedSignalManager.Remove(value); }

        /// <include file="Application.xmldoc" path="declaration/member[@name='ShutdownedEventArgs']/*" />
        public sealed class ShutdownedEventArgs : GISharp.Runtime.GSignalEventArgs
        {
            readonly System.Object[] args;

            /// <summary>
            /// Creates a new instance.
            /// </summary>
            public ShutdownedEventArgs(params System.Object[] args)
            {
                this.args = args ?? throw new System.ArgumentNullException(nameof(args));
            }
        }

        readonly GISharp.Runtime.GSignalManager<ShutdownedEventArgs> shutdownedSignalManager = new GISharp.Runtime.GSignalManager<ShutdownedEventArgs>("shutdown", _GType);

        /// <include file="Application.xmldoc" path="declaration/member[@name='Shutdowned']/*" />
        [GISharp.Runtime.GSignalAttribute("shutdown", When = GISharp.Runtime.EmissionStage.Last)]
        public event System.EventHandler<ShutdownedEventArgs> Shutdowned { add => shutdownedSignalManager.Add(this, value); remove => shutdownedSignalManager.Remove(value); }

        /// <include file="Application.xmldoc" path="declaration/member[@name='StartupedEventArgs']/*" />
        public sealed class StartupedEventArgs : GISharp.Runtime.GSignalEventArgs
        {
            readonly System.Object[] args;

            /// <summary>
            /// Creates a new instance.
            /// </summary>
            public StartupedEventArgs(params System.Object[] args)
            {
                this.args = args ?? throw new System.ArgumentNullException(nameof(args));
            }
        }

        readonly GISharp.Runtime.GSignalManager<StartupedEventArgs> startupedSignalManager = new GISharp.Runtime.GSignalManager<StartupedEventArgs>("startup", _GType);

        /// <include file="Application.xmldoc" path="declaration/member[@name='Startuped']/*" />
        [GISharp.Runtime.GSignalAttribute("startup", When = GISharp.Runtime.EmissionStage.First)]
        public event System.EventHandler<StartupedEventArgs> Startuped { add => startupedSignalManager.Add(this, value); remove => startupedSignalManager.Remove(value); }

        readonly GISharp.Runtime.GSignalManager<GISharp.Lib.Gio.ActionGroup.ActionAddedEventArgs> actionAddedSignalManager = new GISharp.Runtime.GSignalManager<GISharp.Lib.Gio.ActionGroup.ActionAddedEventArgs>("action-added", _GType);

        /// <inheritdoc />
        public event System.EventHandler<GISharp.Lib.Gio.ActionGroup.ActionAddedEventArgs> ActionAdded { add => actionAddedSignalManager.Add(this, value); remove => actionAddedSignalManager.Remove(value); }

        readonly GISharp.Runtime.GSignalManager<GISharp.Lib.Gio.ActionGroup.ActionEnabledChangedEventArgs> actionEnabledChangedSignalManager = new GISharp.Runtime.GSignalManager<GISharp.Lib.Gio.ActionGroup.ActionEnabledChangedEventArgs>("action-enabled-changed", _GType);

        /// <inheritdoc />
        public event System.EventHandler<GISharp.Lib.Gio.ActionGroup.ActionEnabledChangedEventArgs> ActionEnabledChanged { add => actionEnabledChangedSignalManager.Add(this, value); remove => actionEnabledChangedSignalManager.Remove(value); }

        readonly GISharp.Runtime.GSignalManager<GISharp.Lib.Gio.ActionGroup.ActionRemovedEventArgs> actionRemovedSignalManager = new GISharp.Runtime.GSignalManager<GISharp.Lib.Gio.ActionGroup.ActionRemovedEventArgs>("action-removed", _GType);

        /// <inheritdoc />
        public event System.EventHandler<GISharp.Lib.Gio.ActionGroup.ActionRemovedEventArgs> ActionRemoved { add => actionRemovedSignalManager.Add(this, value); remove => actionRemovedSignalManager.Remove(value); }

        readonly GISharp.Runtime.GSignalManager<GISharp.Lib.Gio.ActionGroup.ActionStateChangedEventArgs> actionStateChangedSignalManager = new GISharp.Runtime.GSignalManager<GISharp.Lib.Gio.ActionGroup.ActionStateChangedEventArgs>("action-state-changed", _GType);

        /// <inheritdoc />
        public event System.EventHandler<GISharp.Lib.Gio.ActionGroup.ActionStateChangedEventArgs> ActionStateChanged { add => actionStateChangedSignalManager.Add(this, value); remove => actionStateChangedSignalManager.Remove(value); }

        /// <summary>
        /// Returns the default #GApplication instance for this process.
        /// </summary>
        /// <remarks>
        /// Normally there is only one #GApplication per process and it becomes
        /// the default when it is created.  You can exercise more control over
        /// this by using g_application_set_default().
        /// 
        /// If there is no default application then %NULL is returned.
        /// </remarks>
        /// <returns>
        /// the default application for this process, or %NULL
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.32")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Application" type="GApplication*" managed-name="Application" is-pointer="1" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe System.IntPtr g_application_get_default();

        [GISharp.Runtime.SinceAttribute("2.32")]
        private static unsafe GISharp.Lib.Gio.Application GetDefault()
        {
            var ret_ = g_application_get_default();
            var ret = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Application>(ret_, GISharp.Runtime.Transfer.None)!;
            return ret;
        }

        /// <summary>
        /// Checks if @application_id is a valid application identifier.
        /// </summary>
        /// <remarks>
        /// A valid ID is required for calls to g_application_new() and
        /// g_application_set_application_id().
        /// 
        /// Application identifiers follow the same format as
        /// [D-Bus well-known bus names](https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-names-bus).
        /// For convenience, the restrictions on application identifiers are
        /// reproduced here:
        /// 
        /// - Application identifiers are composed of 1 or more elements separated by a
        ///   period (`.`) character. All elements must contain at least one character.
        /// 
        /// - Each element must only contain the ASCII characters `[A-Z][a-z][0-9]_-`,
        ///   with `-` discouraged in new application identifiers. Each element must not
        ///   begin with a digit.
        /// 
        /// - Application identifiers must contain at least one `.` (period) character
        ///   (and thus at least two elements).
        /// 
        /// - Application identifiers must not begin with a `.` (period) character.
        /// 
        /// - Application identifiers must not exceed 255 characters.
        /// 
        /// Note that the hyphen (`-`) character is allowed in application identifiers,
        /// but is problematic or not allowed in various specifications and APIs that
        /// refer to D-Bus, such as
        /// [Flatpak application IDs](http://docs.flatpak.org/en/latest/introduction.html#identifiers),
        /// the
        /// [`DBusActivatable` interface in the Desktop Entry Specification](https://specifications.freedesktop.org/desktop-entry-spec/desktop-entry-spec-latest.html#dbus),
        /// and the convention that an application's "main" interface and object path
        /// resemble its application identifier and bus name. To avoid situations that
        /// require special-case handling, it is recommended that new application
        /// identifiers consistently replace hyphens with underscores.
        /// 
        /// Like D-Bus interface names, application identifiers should start with the
        /// reversed DNS domain name of the author of the interface (in lower-case), and
        /// it is conventional for the rest of the application identifier to consist of
        /// words run together, with initial capital letters.
        /// 
        /// As with D-Bus interface names, if the author's DNS domain name contains
        /// hyphen/minus characters they should be replaced by underscores, and if it
        /// contains leading digits they should be escaped by prepending an underscore.
        /// For example, if the owner of 7-zip.org used an application identifier for an
        /// archiving application, it might be named `org._7_zip.Archiver`.
        /// </remarks>
        /// <param name="applicationId">
        /// a potential application identifier
        /// </param>
        /// <returns>
        /// %TRUE if @application_id is valid
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe GISharp.Runtime.Boolean g_application_id_is_valid(
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr applicationId);

        /// <include file="Application.xmldoc" path="declaration/member[@name='IdIsValid(GISharp.Lib.GLib.UnownedUtf8)']/*" />
        public static unsafe System.Boolean IdIsValid(GISharp.Lib.GLib.UnownedUtf8 applicationId)
        {
            var applicationId_ = applicationId.Handle;
            var ret_ = g_application_id_is_valid(applicationId_);
            var ret = (System.Boolean)ret_;
            return ret;
        }

        /// <include file="Application.xmldoc" path="declaration/member[@name='IdIsValid(System.String)']/*" />
        public static unsafe System.Boolean IdIsValid(System.String applicationId)
        {
            using var applicationIdUtf8 = new GISharp.Lib.GLib.Utf8(applicationId);
            return IdIsValid((GISharp.Lib.GLib.UnownedUtf8)applicationIdUtf8);
        }

        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="GType" type="GType" managed-name="GISharp.Lib.GObject.GType" /> */
        /* transfer-ownership:full direction:out */
        static extern unsafe GISharp.Lib.GObject.GType g_application_get_type();

        /// <summary>
        /// Activates the application.
        /// </summary>
        /// <remarks>
        /// In essence, this results in the #GApplication::activate signal being
        /// emitted in the primary instance.
        /// 
        /// The application must be registered before calling this function.
        /// </remarks>
        /// <param name="application">
        /// a #GApplication
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.28")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe void g_application_activate(
        /* <type name="Application" type="GApplication*" managed-name="Application" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr application);

        /// <include file="Application.xmldoc" path="declaration/member[@name='Activate()']/*" />
        [GISharp.Runtime.SinceAttribute("2.28")]
        public unsafe void Activate()
        {
            var application_ = Handle;
            g_application_activate(application_);
        }

        /// <summary>
        /// Add an option to be handled by @application.
        /// </summary>
        /// <remarks>
        /// Calling this function is the equivalent of calling
        /// g_application_add_main_option_entries() with a single #GOptionEntry
        /// that has its arg_data member set to %NULL.
        /// 
        /// The parsed arguments will be packed into a #GVariantDict which
        /// is passed to #GApplication::handle-local-options. If
        /// %G_APPLICATION_HANDLES_COMMAND_LINE is set, then it will also
        /// be sent to the primary instance. See
        /// g_application_add_main_option_entries() for more details.
        /// 
        /// See #GOptionEntry for more documentation of the arguments.
        /// </remarks>
        /// <param name="application">
        /// the #GApplication
        /// </param>
        /// <param name="longName">
        /// the long name of an option used to specify it in a commandline
        /// </param>
        /// <param name="shortName">
        /// the short name of an option
        /// </param>
        /// <param name="flags">
        /// flags from #GOptionFlags
        /// </param>
        /// <param name="arg">
        /// the type of the option, as a #GOptionArg
        /// </param>
        /// <param name="description">
        /// the description for the option in `--help` output
        /// </param>
        /// <param name="argDescription">
        /// the placeholder to use for the extra argument
        ///    parsed by the option in `--help` output
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.42")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe void g_application_add_main_option(
        /* <type name="Application" type="GApplication*" managed-name="Application" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr application,
        /* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr longName,
        /* <type name="gchar" type="char" managed-name="System.SByte" /> */
        /* transfer-ownership:none direction:in */
        System.SByte shortName,
        /* <type name="GLib.OptionFlags" type="GOptionFlags" managed-name="GISharp.Lib.GLib.OptionFlags" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.OptionFlags flags,
        /* <type name="GLib.OptionArg" type="GOptionArg" managed-name="GISharp.Lib.GLib.OptionArg" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.OptionArg arg,
        /* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr description,
        /* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr argDescription);

        /// <include file="Application.xmldoc" path="declaration/member[@name='AddMainOption(GISharp.Lib.GLib.UnownedUtf8,System.SByte,GISharp.Lib.GLib.OptionFlags,GISharp.Lib.GLib.OptionArg,GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.GLib.NullableUnownedUtf8)']/*" />
        [GISharp.Runtime.SinceAttribute("2.42")]
        public unsafe void AddMainOption(GISharp.Lib.GLib.UnownedUtf8 longName, System.SByte shortName, GISharp.Lib.GLib.OptionFlags flags, GISharp.Lib.GLib.OptionArg arg, GISharp.Lib.GLib.UnownedUtf8 description, GISharp.Lib.GLib.NullableUnownedUtf8 argDescription)
        {
            var application_ = Handle;
            var longName_ = longName.Handle;
            var shortName_ = (System.SByte)shortName;
            var flags_ = (GISharp.Lib.GLib.OptionFlags)flags;
            var arg_ = (GISharp.Lib.GLib.OptionArg)arg;
            var description_ = description.Handle;
            var argDescription_ = argDescription.Handle;
            g_application_add_main_option(application_, longName_, shortName_, flags_, arg_, description_, argDescription_);
        }

        /// <include file="Application.xmldoc" path="declaration/member[@name='AddMainOption(System.String,System.SByte,GISharp.Lib.GLib.OptionFlags,GISharp.Lib.GLib.OptionArg,System.String,System.String?)']/*" />
        [GISharp.Runtime.SinceAttribute("2.42")]
        public unsafe void AddMainOption(System.String longName, System.SByte shortName, GISharp.Lib.GLib.OptionFlags flags, GISharp.Lib.GLib.OptionArg arg, System.String description, System.String? argDescription)
        {
            using var longNameUtf8 = new GISharp.Lib.GLib.Utf8(longName);
            using var descriptionUtf8 = new GISharp.Lib.GLib.Utf8(description);
            using var argDescriptionUtf8 = argDescription == null ? null : new GISharp.Lib.GLib.Utf8(argDescription);
            AddMainOption((GISharp.Lib.GLib.UnownedUtf8)longNameUtf8, shortName, flags, arg, (GISharp.Lib.GLib.UnownedUtf8)descriptionUtf8, (GISharp.Lib.GLib.NullableUnownedUtf8)argDescriptionUtf8);
        }

        /// <summary>
        /// Adds main option entries to be handled by @application.
        /// </summary>
        /// <remarks>
        /// This function is comparable to g_option_context_add_main_entries().
        /// 
        /// After the commandline arguments are parsed, the
        /// #GApplication::handle-local-options signal will be emitted.  At this
        /// point, the application can inspect the values pointed to by @arg_data
        /// in the given #GOptionEntrys.
        /// 
        /// Unlike #GOptionContext, #GApplication supports giving a %NULL
        /// @arg_data for a non-callback #GOptionEntry.  This results in the
        /// argument in question being packed into a #GVariantDict which is also
        /// passed to #GApplication::handle-local-options, where it can be
        /// inspected and modified.  If %G_APPLICATION_HANDLES_COMMAND_LINE is
        /// set, then the resulting dictionary is sent to the primary instance,
        /// where g_application_command_line_get_options_dict() will return it.
        /// This "packing" is done according to the type of the argument --
        /// booleans for normal flags, strings for strings, bytestrings for
        /// filenames, etc.  The packing only occurs if the flag is given (ie: we
        /// do not pack a "false" #GVariant in the case that a flag is missing).
        /// 
        /// In general, it is recommended that all commandline arguments are
        /// parsed locally.  The options dictionary should then be used to
        /// transmit the result of the parsing to the primary instance, where
        /// g_variant_dict_lookup() can be used.  For local options, it is
        /// possible to either use @arg_data in the usual way, or to consult (and
        /// potentially remove) the option from the options dictionary.
        /// 
        /// This function is new in GLib 2.40.  Before then, the only real choice
        /// was to send all of the commandline arguments (options and all) to the
        /// primary instance for handling.  #GApplication ignored them completely
        /// on the local side.  Calling this function "opts in" to the new
        /// behaviour, and in particular, means that unrecognised options will be
        /// treated as errors.  Unrecognised options have never been ignored when
        /// %G_APPLICATION_HANDLES_COMMAND_LINE is unset.
        /// 
        /// If #GApplication::handle-local-options needs to see the list of
        /// filenames, then the use of %G_OPTION_REMAINING is recommended.  If
        /// @arg_data is %NULL then %G_OPTION_REMAINING can be used as a key into
        /// the options dictionary.  If you do use %G_OPTION_REMAINING then you
        /// need to handle these arguments for yourself because once they are
        /// consumed, they will no longer be visible to the default handling
        /// (which treats them as filenames to be opened).
        /// 
        /// It is important to use the proper GVariant format when retrieving
        /// the options with g_variant_dict_lookup():
        /// - for %G_OPTION_ARG_NONE, use b
        /// - for %G_OPTION_ARG_STRING, use &amp;s
        /// - for %G_OPTION_ARG_INT, use i
        /// - for %G_OPTION_ARG_INT64, use x
        /// - for %G_OPTION_ARG_DOUBLE, use d
        /// - for %G_OPTION_ARG_FILENAME, use ^ay
        /// - for %G_OPTION_ARG_STRING_ARRAY, use &amp;as
        /// - for %G_OPTION_ARG_FILENAME_ARRAY, use ^aay
        /// </remarks>
        /// <param name="application">
        /// a #GApplication
        /// </param>
        /// <param name="entries">
        /// a
        ///           %NULL-terminated list of #GOptionEntrys
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.40")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe void g_application_add_main_option_entries(
        /* <type name="Application" type="GApplication*" managed-name="Application" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr application,
        /* <array type="const GOptionEntry*" zero-terminated="1" managed-name="GISharp.Runtime.CArray" is-pointer="1">
*   <type name="GLib.OptionEntry" managed-name="GISharp.Lib.GLib.OptionEntry" />
* </array> */
        /* transfer-ownership:none direction:in */
        in GISharp.Lib.GLib.OptionEntry entries);

        /// <include file="Application.xmldoc" path="declaration/member[@name='AddMainOptionEntries(System.ReadOnlySpan&lt;GISharp.Lib.GLib.OptionEntry&gt;)']/*" />
        [GISharp.Runtime.SinceAttribute("2.40")]
        public unsafe void AddMainOptionEntries(System.ReadOnlySpan<GISharp.Lib.GLib.OptionEntry> entries)
        {
            var application_ = Handle;ref readonly var entries_ = ref System.Runtime.InteropServices.MemoryMarshal.GetReference(entries);
            g_application_add_main_option_entries(application_, entries_);
        }

        /// <summary>
        /// Adds a #GOptionGroup to the commandline handling of @application.
        /// </summary>
        /// <remarks>
        /// This function is comparable to g_option_context_add_group().
        /// 
        /// Unlike g_application_add_main_option_entries(), this function does
        /// not deal with %NULL @arg_data and never transmits options to the
        /// primary instance.
        /// 
        /// The reason for that is because, by the time the options arrive at the
        /// primary instance, it is typically too late to do anything with them.
        /// Taking the GTK option group as an example: GTK will already have been
        /// initialised by the time the #GApplication::command-line handler runs.
        /// In the case that this is not the first-running instance of the
        /// application, the existing instance may already have been running for
        /// a very long time.
        /// 
        /// This means that the options from #GOptionGroup are only really usable
        /// in the case that the instance of the application being run is the
        /// first instance.  Passing options like `--display=` or `--gdk-debug=`
        /// on future runs will have no effect on the existing primary instance.
        /// 
        /// Calling this function will cause the options in the supplied option
        /// group to be parsed, but it does not cause you to be "opted in" to the
        /// new functionality whereby unrecognised options are rejected even if
        /// %G_APPLICATION_HANDLES_COMMAND_LINE was given.
        /// </remarks>
        /// <param name="application">
        /// the #GApplication
        /// </param>
        /// <param name="group">
        /// a #GOptionGroup
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.40")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe void g_application_add_option_group(
        /* <type name="Application" type="GApplication*" managed-name="Application" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr application,
        /* <type name="GLib.OptionGroup" type="GOptionGroup*" managed-name="GISharp.Lib.GLib.OptionGroup" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        System.IntPtr group);

        /// <include file="Application.xmldoc" path="declaration/member[@name='AddOptionGroup(GISharp.Lib.GLib.OptionGroup)']/*" />
        [GISharp.Runtime.SinceAttribute("2.40")]
        public unsafe void AddOptionGroup(GISharp.Lib.GLib.OptionGroup group)
        {
            var application_ = Handle;
            var group_ = group.Take();
            g_application_add_option_group(application_, group_);
        }

        /// <summary>
        /// Marks @application as busy (see g_application_mark_busy()) while
        /// @property on @object is %TRUE.
        /// </summary>
        /// <remarks>
        /// The binding holds a reference to @application while it is active, but
        /// not to @object. Instead, the binding is destroyed when @object is
        /// finalized.
        /// </remarks>
        /// <param name="application">
        /// a #GApplication
        /// </param>
        /// <param name="object">
        /// a #GObject
        /// </param>
        /// <param name="property">
        /// the name of a boolean property of @object
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.44")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe void g_application_bind_busy_property(
        /* <type name="Application" type="GApplication*" managed-name="Application" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr application,
        /* <type name="GObject.Object" type="gpointer" managed-name="GISharp.Lib.GObject.Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr @object,
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr property);

        /// <include file="Application.xmldoc" path="declaration/member[@name='BindBusyProperty(GISharp.Lib.GObject.Object,GISharp.Lib.GLib.UnownedUtf8)']/*" />
        [GISharp.Runtime.SinceAttribute("2.44")]
        public unsafe void BindBusyProperty(GISharp.Lib.GObject.Object @object, GISharp.Lib.GLib.UnownedUtf8 property)
        {
            var application_ = Handle;
            var @object_ = @object.Handle;
            var property_ = property.Handle;
            g_application_bind_busy_property(application_, @object_, property_);
        }

        /// <include file="Application.xmldoc" path="declaration/member[@name='BindBusyProperty(GISharp.Lib.GObject.Object,System.String)']/*" />
        [GISharp.Runtime.SinceAttribute("2.44")]
        public unsafe void BindBusyProperty(GISharp.Lib.GObject.Object @object, System.String property)
        {
            using var propertyUtf8 = new GISharp.Lib.GLib.Utf8(property);
            BindBusyProperty(@object, (GISharp.Lib.GLib.UnownedUtf8)propertyUtf8);
        }

        /// <summary>
        /// Gets the unique identifier for @application.
        /// </summary>
        /// <param name="application">
        /// a #GApplication
        /// </param>
        /// <returns>
        /// the identifier for @application, owned by @application
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.28")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 direction:out */
        static extern unsafe System.IntPtr g_application_get_application_id(
        /* <type name="Application" type="GApplication*" managed-name="Application" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr application);

        [GISharp.Runtime.SinceAttribute("2.28")]
        private unsafe GISharp.Lib.GLib.NullableUnownedUtf8 GetApplicationId()
        {
            var application_ = Handle;
            var ret_ = g_application_get_application_id(application_);
            var ret = new GISharp.Lib.GLib.NullableUnownedUtf8(ret_, -1);
            return ret;
        }

        /// <summary>
        /// Gets the D-Bus object path being used by the application, or %NULL.
        /// </summary>
        /// <remarks>
        /// If #GApplication is using its D-Bus backend then this function will
        /// return the D-Bus object path that #GApplication is using.  If the
        /// application is the primary instance then there is an object published
        /// at this path.  If the application is not the primary instance then
        /// the result of this function is undefined.
        /// 
        /// If #GApplication is not using D-Bus then this function will return
        /// %NULL.  This includes the situation where the D-Bus backend would
        /// normally be in use but we were unable to connect to the bus.
        /// 
        /// This function must not be called before the application has been
        /// registered.  See g_application_get_is_registered().
        /// </remarks>
        /// <param name="application">
        /// a #GApplication
        /// </param>
        /// <returns>
        /// the object path, or %NULL
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.34")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe System.IntPtr g_application_get_dbus_object_path(
        /* <type name="Application" type="GApplication*" managed-name="Application" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr application);

        [GISharp.Runtime.SinceAttribute("2.34")]
        private unsafe GISharp.Lib.GLib.UnownedUtf8 GetDbusObjectPath()
        {
            var application_ = Handle;
            var ret_ = g_application_get_dbus_object_path(application_);
            var ret = new GISharp.Lib.GLib.UnownedUtf8(ret_, -1);
            return ret;
        }

        /// <summary>
        /// Gets the flags for @application.
        /// </summary>
        /// <remarks>
        /// See #GApplicationFlags.
        /// </remarks>
        /// <param name="application">
        /// a #GApplication
        /// </param>
        /// <returns>
        /// the flags for @application
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.28")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="ApplicationFlags" type="GApplicationFlags" managed-name="ApplicationFlags" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe GISharp.Lib.Gio.ApplicationFlags g_application_get_flags(
        /* <type name="Application" type="GApplication*" managed-name="Application" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr application);

        [GISharp.Runtime.SinceAttribute("2.28")]
        private unsafe GISharp.Lib.Gio.ApplicationFlags GetFlags()
        {
            var application_ = Handle;
            var ret_ = g_application_get_flags(application_);
            var ret = (GISharp.Lib.Gio.ApplicationFlags)ret_;
            return ret;
        }

        /// <summary>
        /// Gets the current inactivity timeout for the application.
        /// </summary>
        /// <remarks>
        /// This is the amount of time (in milliseconds) after the last call to
        /// g_application_release() before the application stops running.
        /// </remarks>
        /// <param name="application">
        /// a #GApplication
        /// </param>
        /// <returns>
        /// the timeout, in milliseconds
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.28")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe System.UInt32 g_application_get_inactivity_timeout(
        /* <type name="Application" type="GApplication*" managed-name="Application" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr application);

        [GISharp.Runtime.SinceAttribute("2.28")]
        private unsafe System.UInt32 GetInactivityTimeout()
        {
            var application_ = Handle;
            var ret_ = g_application_get_inactivity_timeout(application_);
            var ret = (System.UInt32)ret_;
            return ret;
        }

        /// <summary>
        /// Gets the application's current busy state, as set through
        /// g_application_mark_busy() or g_application_bind_busy_property().
        /// </summary>
        /// <param name="application">
        /// a #GApplication
        /// </param>
        /// <returns>
        /// %TRUE if @application is currenty marked as busy
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.44")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe GISharp.Runtime.Boolean g_application_get_is_busy(
        /* <type name="Application" type="GApplication*" managed-name="Application" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr application);

        [GISharp.Runtime.SinceAttribute("2.44")]
        private unsafe System.Boolean GetIsBusy()
        {
            var application_ = Handle;
            var ret_ = g_application_get_is_busy(application_);
            var ret = (System.Boolean)ret_;
            return ret;
        }

        /// <summary>
        /// Checks if @application is registered.
        /// </summary>
        /// <remarks>
        /// An application is registered if g_application_register() has been
        /// successfully called.
        /// </remarks>
        /// <param name="application">
        /// a #GApplication
        /// </param>
        /// <returns>
        /// %TRUE if @application is registered
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.28")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe GISharp.Runtime.Boolean g_application_get_is_registered(
        /* <type name="Application" type="GApplication*" managed-name="Application" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr application);

        [GISharp.Runtime.SinceAttribute("2.28")]
        private unsafe System.Boolean GetIsRegistered()
        {
            var application_ = Handle;
            var ret_ = g_application_get_is_registered(application_);
            var ret = (System.Boolean)ret_;
            return ret;
        }

        /// <summary>
        /// Checks if @application is remote.
        /// </summary>
        /// <remarks>
        /// If @application is remote then it means that another instance of
        /// application already exists (the 'primary' instance).  Calls to
        /// perform actions on @application will result in the actions being
        /// performed by the primary instance.
        /// 
        /// The value of this property cannot be accessed before
        /// g_application_register() has been called.  See
        /// g_application_get_is_registered().
        /// </remarks>
        /// <param name="application">
        /// a #GApplication
        /// </param>
        /// <returns>
        /// %TRUE if @application is remote
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.28")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe GISharp.Runtime.Boolean g_application_get_is_remote(
        /* <type name="Application" type="GApplication*" managed-name="Application" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr application);

        [GISharp.Runtime.SinceAttribute("2.28")]
        private unsafe System.Boolean GetIsRemote()
        {
            var application_ = Handle;
            var ret_ = g_application_get_is_remote(application_);
            var ret = (System.Boolean)ret_;
            return ret;
        }

        /// <summary>
        /// Gets the resource base path of @application.
        /// </summary>
        /// <remarks>
        /// See g_application_set_resource_base_path() for more information.
        /// </remarks>
        /// <param name="application">
        /// a #GApplication
        /// </param>
        /// <returns>
        /// the base resource path, if one is set
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.42")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 direction:out */
        static extern unsafe System.IntPtr g_application_get_resource_base_path(
        /* <type name="Application" type="GApplication*" managed-name="Application" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr application);

        [GISharp.Runtime.SinceAttribute("2.42")]
        private unsafe GISharp.Lib.GLib.NullableUnownedUtf8 GetResourceBasePath()
        {
            var application_ = Handle;
            var ret_ = g_application_get_resource_base_path(application_);
            var ret = new GISharp.Lib.GLib.NullableUnownedUtf8(ret_, -1);
            return ret;
        }

        /// <summary>
        /// Increases the use count of @application.
        /// </summary>
        /// <remarks>
        /// Use this function to indicate that the application has a reason to
        /// continue to run.  For example, g_application_hold() is called by GTK+
        /// when a toplevel window is on the screen.
        /// 
        /// To cancel the hold, call g_application_release().
        /// </remarks>
        /// <param name="application">
        /// a #GApplication
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe void g_application_hold(
        /* <type name="Application" type="GApplication*" managed-name="Application" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr application);

        /// <include file="Application.xmldoc" path="declaration/member[@name='Hold()']/*" />
        public unsafe void Hold()
        {
            var application_ = Handle;
            g_application_hold(application_);
        }

        /// <summary>
        /// Increases the busy count of @application.
        /// </summary>
        /// <remarks>
        /// Use this function to indicate that the application is busy, for instance
        /// while a long running operation is pending.
        /// 
        /// The busy state will be exposed to other processes, so a session shell will
        /// use that information to indicate the state to the user (e.g. with a
        /// spinner).
        /// 
        /// To cancel the busy indication, use g_application_unmark_busy().
        /// </remarks>
        /// <param name="application">
        /// a #GApplication
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.38")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe void g_application_mark_busy(
        /* <type name="Application" type="GApplication*" managed-name="Application" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr application);

        /// <include file="Application.xmldoc" path="declaration/member[@name='MarkBusy()']/*" />
        [GISharp.Runtime.SinceAttribute("2.38")]
        public unsafe void MarkBusy()
        {
            var application_ = Handle;
            g_application_mark_busy(application_);
        }

        /// <summary>
        /// Opens the given files.
        /// </summary>
        /// <remarks>
        /// In essence, this results in the #GApplication::open signal being emitted
        /// in the primary instance.
        /// 
        /// @n_files must be greater than zero.
        /// 
        /// @hint is simply passed through to the ::open signal.  It is
        /// intended to be used by applications that have multiple modes for
        /// opening files (eg: "view" vs "edit", etc).  Unless you have a need
        /// for this functionality, you should use "".
        /// 
        /// The application must be registered before calling this function
        /// and it must have the %G_APPLICATION_HANDLES_OPEN flag set.
        /// </remarks>
        /// <param name="application">
        /// a #GApplication
        /// </param>
        /// <param name="files">
        /// an array of #GFiles to open
        /// </param>
        /// <param name="nFiles">
        /// the length of the @files array
        /// </param>
        /// <param name="hint">
        /// a hint (or ""), but never %NULL
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.28")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe void g_application_open(
        /* <type name="Application" type="GApplication*" managed-name="Application" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr application,
        /* <array length="1" zero-terminated="0" type="GFile**" managed-name="GISharp.Runtime.CArray" is-pointer="1">
*   <type name="File" type="GFile*" managed-name="File" />
* </array> */
        /* transfer-ownership:none direction:in */
        in System.IntPtr files,
        /* <type name="gint" type="gint" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        System.Int32 nFiles,
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr hint);

        /// <include file="Application.xmldoc" path="declaration/member[@name='Open(GISharp.Runtime.UnownedCPtrArray&lt;GISharp.Lib.Gio.IFile&gt;,GISharp.Lib.GLib.UnownedUtf8)']/*" />
        [GISharp.Runtime.SinceAttribute("2.28")]
        public unsafe void Open(GISharp.Runtime.UnownedCPtrArray<GISharp.Lib.Gio.IFile> files, GISharp.Lib.GLib.UnownedUtf8 hint)
        {
            var application_ = Handle;ref readonly var files_ = ref files.GetPinnableReference();
            var nFiles_ = (System.Int32)files.Length;
            var hint_ = hint.Handle;
            g_application_open(application_, files_, nFiles_, hint_);
        }

        /// <include file="Application.xmldoc" path="declaration/member[@name='Open(GISharp.Runtime.UnownedCPtrArray&lt;GISharp.Lib.Gio.IFile&gt;,System.String)']/*" />
        [GISharp.Runtime.SinceAttribute("2.28")]
        public unsafe void Open(GISharp.Runtime.UnownedCPtrArray<GISharp.Lib.Gio.IFile> files, System.String hint)
        {
            using var hintUtf8 = new GISharp.Lib.GLib.Utf8(hint);
            Open(files, (GISharp.Lib.GLib.UnownedUtf8)hintUtf8);
        }

        /// <summary>
        /// Immediately quits the application.
        /// </summary>
        /// <remarks>
        /// Upon return to the mainloop, g_application_run() will return,
        /// calling only the 'shutdown' function before doing so.
        /// 
        /// The hold count is ignored.
        /// Take care if your code has called g_application_hold() on the application and
        /// is therefore still expecting it to exist.
        /// (Note that you may have called g_application_hold() indirectly, for example
        /// through gtk_application_add_window().)
        /// 
        /// The result of calling g_application_run() again after it returns is
        /// unspecified.
        /// </remarks>
        /// <param name="application">
        /// a #GApplication
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.32")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe void g_application_quit(
        /* <type name="Application" type="GApplication*" managed-name="Application" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr application);

        /// <include file="Application.xmldoc" path="declaration/member[@name='Quit()']/*" />
        [GISharp.Runtime.SinceAttribute("2.32")]
        public unsafe void Quit()
        {
            var application_ = Handle;
            g_application_quit(application_);
        }

        /// <summary>
        /// Attempts registration of the application.
        /// </summary>
        /// <remarks>
        /// This is the point at which the application discovers if it is the
        /// primary instance or merely acting as a remote for an already-existing
        /// primary instance.  This is implemented by attempting to acquire the
        /// application identifier as a unique bus name on the session bus using
        /// GDBus.
        /// 
        /// If there is no application ID or if %G_APPLICATION_NON_UNIQUE was
        /// given, then this process will always become the primary instance.
        /// 
        /// Due to the internal architecture of GDBus, method calls can be
        /// dispatched at any time (even if a main loop is not running).  For
        /// this reason, you must ensure that any object paths that you wish to
        /// register are registered before calling this function.
        /// 
        /// If the application has already been registered then %TRUE is
        /// returned with no work performed.
        /// 
        /// The #GApplication::startup signal is emitted if registration succeeds
        /// and @application is the primary instance (including the non-unique
        /// case).
        /// 
        /// In the event of an error (such as @cancellable being cancelled, or a
        /// failure to connect to the session bus), %FALSE is returned and @error
        /// is set appropriately.
        /// 
        /// Note: the return value of this function is not an indicator that this
        /// instance is or is not the primary instance of the application.  See
        /// g_application_get_is_remote() for that.
        /// </remarks>
        /// <param name="application">
        /// a #GApplication
        /// </param>
        /// <param name="cancellable">
        /// a #GCancellable, or %NULL
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// %TRUE if registration succeeded
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.28")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:out */
        static extern unsafe GISharp.Runtime.Boolean g_application_register(
        /* <type name="Application" type="GApplication*" managed-name="Application" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr application,
        /* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr cancellable,
        /* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        ref System.IntPtr error);

        /// <include file="Application.xmldoc" path="declaration/member[@name='Register(GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.SinceAttribute("2.28")]
        public unsafe void Register(GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            var application_ = Handle;
            var cancellable_ = cancellable?.Handle ?? System.IntPtr.Zero;
            var error_ = System.IntPtr.Zero;
            g_application_register(application_, cancellable_,ref error_);
            if (error_ != System.IntPtr.Zero)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>(error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Runtime.GErrorException(error);
            }
        }

        /// <summary>
        /// Decrease the use count of @application.
        /// </summary>
        /// <remarks>
        /// When the use count reaches zero, the application will stop running.
        /// 
        /// Never call this function except to cancel the effect of a previous
        /// call to g_application_hold().
        /// </remarks>
        /// <param name="application">
        /// a #GApplication
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe void g_application_release(
        /* <type name="Application" type="GApplication*" managed-name="Application" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr application);

        /// <include file="Application.xmldoc" path="declaration/member[@name='Release()']/*" />
        public unsafe void Release()
        {
            var application_ = Handle;
            g_application_release(application_);
        }

        /// <summary>
        /// Runs the application.
        /// </summary>
        /// <remarks>
        /// This function is intended to be run from main() and its return value
        /// is intended to be returned by main(). Although you are expected to pass
        /// the @argc, @argv parameters from main() to this function, it is possible
        /// to pass %NULL if @argv is not available or commandline handling is not
        /// required.  Note that on Windows, @argc and @argv are ignored, and
        /// g_win32_get_command_line() is called internally (for proper support
        /// of Unicode commandline arguments).
        /// 
        /// #GApplication will attempt to parse the commandline arguments.  You
        /// can add commandline flags to the list of recognised options by way of
        /// g_application_add_main_option_entries().  After this, the
        /// #GApplication::handle-local-options signal is emitted, from which the
        /// application can inspect the values of its #GOptionEntrys.
        /// 
        /// #GApplication::handle-local-options is a good place to handle options
        /// such as `--version`, where an immediate reply from the local process is
        /// desired (instead of communicating with an already-running instance).
        /// A #GApplication::handle-local-options handler can stop further processing
        /// by returning a non-negative value, which then becomes the exit status of
        /// the process.
        /// 
        /// What happens next depends on the flags: if
        /// %G_APPLICATION_HANDLES_COMMAND_LINE was specified then the remaining
        /// commandline arguments are sent to the primary instance, where a
        /// #GApplication::command-line signal is emitted.  Otherwise, the
        /// remaining commandline arguments are assumed to be a list of files.
        /// If there are no files listed, the application is activated via the
        /// #GApplication::activate signal.  If there are one or more files, and
        /// %G_APPLICATION_HANDLES_OPEN was specified then the files are opened
        /// via the #GApplication::open signal.
        /// 
        /// If you are interested in doing more complicated local handling of the
        /// commandline then you should implement your own #GApplication subclass
        /// and override local_command_line(). In this case, you most likely want
        /// to return %TRUE from your local_command_line() implementation to
        /// suppress the default handling. See
        /// [gapplication-example-cmdline2.c][gapplication-example-cmdline2]
        /// for an example.
        /// 
        /// If, after the above is done, the use count of the application is zero
        /// then the exit status is returned immediately.  If the use count is
        /// non-zero then the default main context is iterated until the use count
        /// falls to zero, at which point 0 is returned.
        /// 
        /// If the %G_APPLICATION_IS_SERVICE flag is set, then the service will
        /// run for as much as 10 seconds with a use count of zero while waiting
        /// for the message that caused the activation to arrive.  After that,
        /// if the use count falls to zero the application will exit immediately,
        /// except in the case that g_application_set_inactivity_timeout() is in
        /// use.
        /// 
        /// This function sets the prgname (g_set_prgname()), if not already set,
        /// to the basename of argv[0].
        /// 
        /// Much like g_main_loop_run(), this function will acquire the main context
        /// for the duration that the application is running.
        /// 
        /// Since 2.40, applications that are not explicitly flagged as services
        /// or launchers (ie: neither %G_APPLICATION_IS_SERVICE or
        /// %G_APPLICATION_IS_LAUNCHER are given as flags) will check (from the
        /// default handler for local_command_line) if "--gapplication-service"
        /// was given in the command line.  If this flag is present then normal
        /// commandline processing is interrupted and the
        /// %G_APPLICATION_IS_SERVICE flag is set.  This provides a "compromise"
        /// solution whereby running an application directly from the commandline
        /// will invoke it in the normal way (which can be useful for debugging)
        /// while still allowing applications to be D-Bus activated in service
        /// mode.  The D-Bus service file should invoke the executable with
        /// "--gapplication-service" as the sole commandline argument.  This
        /// approach is suitable for use by most graphical applications but
        /// should not be used from applications like editors that need precise
        /// control over when processes invoked via the commandline will exit and
        /// what their exit status will be.
        /// </remarks>
        /// <param name="application">
        /// a #GApplication
        /// </param>
        /// <param name="argc">
        /// the argc from main() (or 0 if @argv is %NULL)
        /// </param>
        /// <param name="argv">
        /// 
        ///     the argv from main(), or %NULL
        /// </param>
        /// <returns>
        /// the exit status
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.28")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gint" type="int" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe System.Int32 g_application_run(
        /* <type name="Application" type="GApplication*" managed-name="Application" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr application,
        /* <type name="gint" type="int" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        System.Int32 argc,
        /* <array length="0" zero-terminated="0" type="char**" managed-name="GISharp.Runtime.CArray" is-pointer="1">
*   <type name="filename" managed-name="GISharp.Lib.GLib.Filename" />
* </array> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        in System.IntPtr argv);

        /// <include file="Application.xmldoc" path="declaration/member[@name='Run(GISharp.Runtime.UnownedCPtrArray&lt;GISharp.Lib.GLib.Filename&gt;)']/*" />
        [GISharp.Runtime.SinceAttribute("2.28")]
        public unsafe System.Int32 Run(GISharp.Runtime.UnownedCPtrArray<GISharp.Lib.GLib.Filename> argv)
        {
            var application_ = Handle;ref readonly var argv_ = ref argv.GetPinnableReference();
            var argc_ = (System.Int32)argv.Length;
            var ret_ = g_application_run(application_,argc_,argv_);
            var ret = (System.Int32)ret_;
            return ret;
        }

        /// <summary>
        /// This used to be how actions were associated with a #GApplication.
        /// Now there is #GActionMap for that.
        /// </summary>
        /// <param name="application">
        /// a #GApplication
        /// </param>
        /// <param name="actionGroup">
        /// a #GActionGroup, or %NULL
        /// </param>
        [System.ObsoleteAttribute("Use the #GActionMap interface instead.  Never ever\nmix use of this API with use of #GActionMap on the same @application\nor things will go very badly wrong.  This function is known to\nintroduce buggy behaviour (ie: signals not emitted on changes to the\naction group), so you should really use #GActionMap instead.")]
        [GISharp.Runtime.DeprecatedSinceAttribute("2.32")]
        [GISharp.Runtime.SinceAttribute("2.28")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe void g_application_set_action_group(
        /* <type name="Application" type="GApplication*" managed-name="Application" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr application,
        /* <type name="ActionGroup" type="GActionGroup*" managed-name="ActionGroup" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr actionGroup);

        /// <include file="Application.xmldoc" path="declaration/member[@name='SetActionGroup(GISharp.Lib.Gio.IActionGroup?)']/*" />
        [System.ObsoleteAttribute("Use the #GActionMap interface instead.  Never ever\nmix use of this API with use of #GActionMap on the same @application\nor things will go very badly wrong.  This function is known to\nintroduce buggy behaviour (ie: signals not emitted on changes to the\naction group), so you should really use #GActionMap instead.")]
        [GISharp.Runtime.DeprecatedSinceAttribute("2.32")]
        [GISharp.Runtime.SinceAttribute("2.28")]
        public unsafe void SetActionGroup(GISharp.Lib.Gio.IActionGroup? actionGroup)
        {
            var application_ = Handle;
            var actionGroup_ = actionGroup?.Handle ?? System.IntPtr.Zero;
            g_application_set_action_group(application_, actionGroup_);
        }

        /// <summary>
        /// Sets the unique identifier for @application.
        /// </summary>
        /// <remarks>
        /// The application id can only be modified if @application has not yet
        /// been registered.
        /// 
        /// If non-%NULL, the application id must be valid.  See
        /// g_application_id_is_valid().
        /// </remarks>
        /// <param name="application">
        /// a #GApplication
        /// </param>
        /// <param name="applicationId">
        /// the identifier for @application
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.28")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe void g_application_set_application_id(
        /* <type name="Application" type="GApplication*" managed-name="Application" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr application,
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr applicationId);

        [GISharp.Runtime.SinceAttribute("2.28")]
        private unsafe void SetApplicationId(GISharp.Lib.GLib.NullableUnownedUtf8 applicationId)
        {
            var application_ = Handle;
            var applicationId_ = applicationId.Handle;
            g_application_set_application_id(application_, applicationId_);
        }

        [GISharp.Runtime.SinceAttribute("2.28")]
        private unsafe void SetApplicationId(System.String? applicationId)
        {
            using var applicationIdUtf8 = applicationId == null ? null : new GISharp.Lib.GLib.Utf8(applicationId);
            SetApplicationId((GISharp.Lib.GLib.NullableUnownedUtf8)applicationIdUtf8);
        }

        /// <summary>
        /// Sets or unsets the default application for the process, as returned
        /// by g_application_get_default().
        /// </summary>
        /// <remarks>
        /// This function does not take its own reference on @application.  If
        /// @application is destroyed then the default application will revert
        /// back to %NULL.
        /// </remarks>
        /// <param name="application">
        /// the application to set as default, or %NULL
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.32")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe void g_application_set_default(
        /* <type name="Application" type="GApplication*" managed-name="Application" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr application);

        /// <include file="Application.xmldoc" path="declaration/member[@name='SetDefault()']/*" />
        [GISharp.Runtime.SinceAttribute("2.32")]
        public unsafe void SetDefault()
        {
            var application_ = Handle;
            g_application_set_default(application_);
        }

        /// <summary>
        /// Sets the flags for @application.
        /// </summary>
        /// <remarks>
        /// The flags can only be modified if @application has not yet been
        /// registered.
        /// 
        /// See #GApplicationFlags.
        /// </remarks>
        /// <param name="application">
        /// a #GApplication
        /// </param>
        /// <param name="flags">
        /// the flags for @application
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.28")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe void g_application_set_flags(
        /* <type name="Application" type="GApplication*" managed-name="Application" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr application,
        /* <type name="ApplicationFlags" type="GApplicationFlags" managed-name="ApplicationFlags" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.ApplicationFlags flags);

        [GISharp.Runtime.SinceAttribute("2.28")]
        private unsafe void SetFlags(GISharp.Lib.Gio.ApplicationFlags flags)
        {
            var application_ = Handle;
            var flags_ = (GISharp.Lib.Gio.ApplicationFlags)flags;
            g_application_set_flags(application_, flags_);
        }

        /// <summary>
        /// Sets the current inactivity timeout for the application.
        /// </summary>
        /// <remarks>
        /// This is the amount of time (in milliseconds) after the last call to
        /// g_application_release() before the application stops running.
        /// 
        /// This call has no side effects of its own.  The value set here is only
        /// used for next time g_application_release() drops the use count to
        /// zero.  Any timeouts currently in progress are not impacted.
        /// </remarks>
        /// <param name="application">
        /// a #GApplication
        /// </param>
        /// <param name="inactivityTimeout">
        /// the timeout, in milliseconds
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.28")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe void g_application_set_inactivity_timeout(
        /* <type name="Application" type="GApplication*" managed-name="Application" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr application,
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        System.UInt32 inactivityTimeout);

        [GISharp.Runtime.SinceAttribute("2.28")]
        private unsafe void SetInactivityTimeout(System.UInt32 inactivityTimeout)
        {
            var application_ = Handle;
            var inactivityTimeout_ = (System.UInt32)inactivityTimeout;
            g_application_set_inactivity_timeout(application_, inactivityTimeout_);
        }

        /// <summary>
        /// Adds a description to the @application option context.
        /// </summary>
        /// <remarks>
        /// See g_option_context_set_description() for more information.
        /// </remarks>
        /// <param name="application">
        /// the #GApplication
        /// </param>
        /// <param name="description">
        /// a string to be shown in `--help` output
        ///  after the list of options, or %NULL
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.56")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe void g_application_set_option_context_description(
        /* <type name="Application" type="GApplication*" managed-name="Application" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr application,
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr description);

        /// <include file="Application.xmldoc" path="declaration/member[@name='SetOptionContextDescription(GISharp.Lib.GLib.NullableUnownedUtf8)']/*" />
        [GISharp.Runtime.SinceAttribute("2.56")]
        public unsafe void SetOptionContextDescription(GISharp.Lib.GLib.NullableUnownedUtf8 description)
        {
            var application_ = Handle;
            var description_ = description.Handle;
            g_application_set_option_context_description(application_, description_);
        }

        /// <include file="Application.xmldoc" path="declaration/member[@name='SetOptionContextDescription(System.String?)']/*" />
        [GISharp.Runtime.SinceAttribute("2.56")]
        public unsafe void SetOptionContextDescription(System.String? description)
        {
            using var descriptionUtf8 = description == null ? null : new GISharp.Lib.GLib.Utf8(description);
            SetOptionContextDescription((GISharp.Lib.GLib.NullableUnownedUtf8)descriptionUtf8);
        }

        /// <summary>
        /// Sets the parameter string to be used by the commandline handling of @application.
        /// </summary>
        /// <remarks>
        /// This function registers the argument to be passed to g_option_context_new()
        /// when the internal #GOptionContext of @application is created.
        /// 
        /// See g_option_context_new() for more information about @parameter_string.
        /// </remarks>
        /// <param name="application">
        /// the #GApplication
        /// </param>
        /// <param name="parameterString">
        /// a string which is displayed
        ///   in the first line of `--help` output, after the usage summary `programname [OPTION...]`.
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.56")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe void g_application_set_option_context_parameter_string(
        /* <type name="Application" type="GApplication*" managed-name="Application" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr application,
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr parameterString);

        /// <include file="Application.xmldoc" path="declaration/member[@name='SetOptionContextParameterString(GISharp.Lib.GLib.NullableUnownedUtf8)']/*" />
        [GISharp.Runtime.SinceAttribute("2.56")]
        public unsafe void SetOptionContextParameterString(GISharp.Lib.GLib.NullableUnownedUtf8 parameterString)
        {
            var application_ = Handle;
            var parameterString_ = parameterString.Handle;
            g_application_set_option_context_parameter_string(application_, parameterString_);
        }

        /// <include file="Application.xmldoc" path="declaration/member[@name='SetOptionContextParameterString(System.String?)']/*" />
        [GISharp.Runtime.SinceAttribute("2.56")]
        public unsafe void SetOptionContextParameterString(System.String? parameterString)
        {
            using var parameterStringUtf8 = parameterString == null ? null : new GISharp.Lib.GLib.Utf8(parameterString);
            SetOptionContextParameterString((GISharp.Lib.GLib.NullableUnownedUtf8)parameterStringUtf8);
        }

        /// <summary>
        /// Adds a summary to the @application option context.
        /// </summary>
        /// <remarks>
        /// See g_option_context_set_summary() for more information.
        /// </remarks>
        /// <param name="application">
        /// the #GApplication
        /// </param>
        /// <param name="summary">
        /// a string to be shown in `--help` output
        ///  before the list of options, or %NULL
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.56")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe void g_application_set_option_context_summary(
        /* <type name="Application" type="GApplication*" managed-name="Application" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr application,
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr summary);

        /// <include file="Application.xmldoc" path="declaration/member[@name='SetOptionContextSummary(GISharp.Lib.GLib.NullableUnownedUtf8)']/*" />
        [GISharp.Runtime.SinceAttribute("2.56")]
        public unsafe void SetOptionContextSummary(GISharp.Lib.GLib.NullableUnownedUtf8 summary)
        {
            var application_ = Handle;
            var summary_ = summary.Handle;
            g_application_set_option_context_summary(application_, summary_);
        }

        /// <include file="Application.xmldoc" path="declaration/member[@name='SetOptionContextSummary(System.String?)']/*" />
        [GISharp.Runtime.SinceAttribute("2.56")]
        public unsafe void SetOptionContextSummary(System.String? summary)
        {
            using var summaryUtf8 = summary == null ? null : new GISharp.Lib.GLib.Utf8(summary);
            SetOptionContextSummary((GISharp.Lib.GLib.NullableUnownedUtf8)summaryUtf8);
        }

        /// <summary>
        /// Sets (or unsets) the base resource path of @application.
        /// </summary>
        /// <remarks>
        /// The path is used to automatically load various [application
        /// resources][gresource] such as menu layouts and action descriptions.
        /// The various types of resources will be found at fixed names relative
        /// to the given base path.
        /// 
        /// By default, the resource base path is determined from the application
        /// ID by prefixing '/' and replacing each '.' with '/'.  This is done at
        /// the time that the #GApplication object is constructed.  Changes to
        /// the application ID after that point will not have an impact on the
        /// resource base path.
        /// 
        /// As an example, if the application has an ID of "org.example.app" then
        /// the default resource base path will be "/org/example/app".  If this
        /// is a #GtkApplication (and you have not manually changed the path)
        /// then Gtk will then search for the menus of the application at
        /// "/org/example/app/gtk/menus.ui".
        /// 
        /// See #GResource for more information about adding resources to your
        /// application.
        /// 
        /// You can disable automatic resource loading functionality by setting
        /// the path to %NULL.
        /// 
        /// Changing the resource base path once the application is running is
        /// not recommended.  The point at which the resource path is consulted
        /// for forming paths for various purposes is unspecified.  When writing
        /// a sub-class of #GApplication you should either set the
        /// #GApplication:resource-base-path property at construction time, or call
        /// this function during the instance initialization. Alternatively, you
        /// can call this function in the #GApplicationClass.startup virtual function,
        /// before chaining up to the parent implementation.
        /// </remarks>
        /// <param name="application">
        /// a #GApplication
        /// </param>
        /// <param name="resourcePath">
        /// the resource path to use
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.42")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe void g_application_set_resource_base_path(
        /* <type name="Application" type="GApplication*" managed-name="Application" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr application,
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr resourcePath);

        [GISharp.Runtime.SinceAttribute("2.42")]
        private unsafe void SetResourceBasePath(GISharp.Lib.GLib.NullableUnownedUtf8 resourcePath)
        {
            var application_ = Handle;
            var resourcePath_ = resourcePath.Handle;
            g_application_set_resource_base_path(application_, resourcePath_);
        }

        [GISharp.Runtime.SinceAttribute("2.42")]
        private unsafe void SetResourceBasePath(System.String? resourcePath)
        {
            using var resourcePathUtf8 = resourcePath == null ? null : new GISharp.Lib.GLib.Utf8(resourcePath);
            SetResourceBasePath((GISharp.Lib.GLib.NullableUnownedUtf8)resourcePathUtf8);
        }

        /// <summary>
        /// Destroys a binding between @property and the busy state of
        /// @application that was previously created with
        /// g_application_bind_busy_property().
        /// </summary>
        /// <param name="application">
        /// a #GApplication
        /// </param>
        /// <param name="object">
        /// a #GObject
        /// </param>
        /// <param name="property">
        /// the name of a boolean property of @object
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.44")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe void g_application_unbind_busy_property(
        /* <type name="Application" type="GApplication*" managed-name="Application" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr application,
        /* <type name="GObject.Object" type="gpointer" managed-name="GISharp.Lib.GObject.Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr @object,
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr property);

        /// <include file="Application.xmldoc" path="declaration/member[@name='UnbindBusyProperty(GISharp.Lib.GObject.Object,GISharp.Lib.GLib.UnownedUtf8)']/*" />
        [GISharp.Runtime.SinceAttribute("2.44")]
        public unsafe void UnbindBusyProperty(GISharp.Lib.GObject.Object @object, GISharp.Lib.GLib.UnownedUtf8 property)
        {
            var application_ = Handle;
            var @object_ = @object.Handle;
            var property_ = property.Handle;
            g_application_unbind_busy_property(application_, @object_, property_);
        }

        /// <include file="Application.xmldoc" path="declaration/member[@name='UnbindBusyProperty(GISharp.Lib.GObject.Object,System.String)']/*" />
        [GISharp.Runtime.SinceAttribute("2.44")]
        public unsafe void UnbindBusyProperty(GISharp.Lib.GObject.Object @object, System.String property)
        {
            using var propertyUtf8 = new GISharp.Lib.GLib.Utf8(property);
            UnbindBusyProperty(@object, (GISharp.Lib.GLib.UnownedUtf8)propertyUtf8);
        }

        /// <summary>
        /// Decreases the busy count of @application.
        /// </summary>
        /// <remarks>
        /// When the busy count reaches zero, the new state will be propagated
        /// to other processes.
        /// 
        /// This function must only be called to cancel the effect of a previous
        /// call to g_application_mark_busy().
        /// </remarks>
        /// <param name="application">
        /// a #GApplication
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.38")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe void g_application_unmark_busy(
        /* <type name="Application" type="GApplication*" managed-name="Application" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr application);

        /// <include file="Application.xmldoc" path="declaration/member[@name='UnmarkBusy()']/*" />
        [GISharp.Runtime.SinceAttribute("2.38")]
        public unsafe void UnmarkBusy()
        {
            var application_ = Handle;
            g_application_unmark_busy(application_);
        }

        /// <summary>
        /// Withdraws a notification that was sent with
        /// g_application_send_notification().
        /// </summary>
        /// <remarks>
        /// This call does nothing if a notification with @id doesn't exist or
        /// the notification was never sent.
        /// 
        /// This function works even for notifications sent in previous
        /// executions of this application, as long @id is the same as it was for
        /// the sent notification.
        /// 
        /// Note that notifications are dismissed when the user clicks on one
        /// of the buttons in a notification or triggers its default action, so
        /// there is no need to explicitly withdraw the notification in that case.
        /// </remarks>
        /// <param name="application">
        /// a #GApplication
        /// </param>
        /// <param name="id">
        /// id of a previously sent notification
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.40")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe void g_application_withdraw_notification(
        /* <type name="Application" type="GApplication*" managed-name="Application" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr application,
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr id);

        /// <include file="Application.xmldoc" path="declaration/member[@name='WithdrawNotification(GISharp.Lib.GLib.UnownedUtf8)']/*" />
        [GISharp.Runtime.SinceAttribute("2.40")]
        public unsafe void WithdrawNotification(GISharp.Lib.GLib.UnownedUtf8 id)
        {
            var application_ = Handle;
            var id_ = id.Handle;
            g_application_withdraw_notification(application_, id_);
        }

        /// <include file="Application.xmldoc" path="declaration/member[@name='WithdrawNotification(System.String)']/*" />
        [GISharp.Runtime.SinceAttribute("2.40")]
        public unsafe void WithdrawNotification(System.String id)
        {
            using var idUtf8 = new GISharp.Lib.GLib.Utf8(id);
            WithdrawNotification((GISharp.Lib.GLib.UnownedUtf8)idUtf8);
        }

        /// <include file="Application.xmldoc" path="declaration/member[@name='DoActivate()']/*" />
        [GISharp.Runtime.SinceAttribute("2.28")]
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(ApplicationClass.UnmanagedActivate))]
        protected virtual unsafe void DoActivate()
        {
            var application_ = Handle;
            GISharp.Lib.GObject.TypeClass.GetUnmanagedVirtualMethod<ApplicationClass.UnmanagedActivate>(_GType)!(application_);
        }

        /// <include file="Application.xmldoc" path="declaration/member[@name='DoAddPlatformData(GISharp.Lib.GLib.VariantBuilder)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(ApplicationClass.UnmanagedAddPlatformData))]
        protected virtual unsafe void DoAddPlatformData(GISharp.Lib.GLib.VariantBuilder builder)
        {
            var application_ = Handle;
            var builder_ = builder.Handle;
            GISharp.Lib.GObject.TypeClass.GetUnmanagedVirtualMethod<ApplicationClass.UnmanagedAddPlatformData>(_GType)!(application_, builder_);
        }

        /// <include file="Application.xmldoc" path="declaration/member[@name='DoAfterEmit(GISharp.Lib.GLib.Variant)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(ApplicationClass.UnmanagedAfterEmit))]
        protected virtual unsafe void DoAfterEmit(GISharp.Lib.GLib.Variant platformData)
        {
            var application_ = Handle;
            var platformData_ = platformData.Handle;
            GISharp.Lib.GObject.TypeClass.GetUnmanagedVirtualMethod<ApplicationClass.UnmanagedAfterEmit>(_GType)!(application_, platformData_);
        }

        /// <include file="Application.xmldoc" path="declaration/member[@name='DoBeforeEmit(GISharp.Lib.GLib.Variant)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(ApplicationClass.UnmanagedBeforeEmit))]
        protected virtual unsafe void DoBeforeEmit(GISharp.Lib.GLib.Variant platformData)
        {
            var application_ = Handle;
            var platformData_ = platformData.Handle;
            GISharp.Lib.GObject.TypeClass.GetUnmanagedVirtualMethod<ApplicationClass.UnmanagedBeforeEmit>(_GType)!(application_, platformData_);
        }

        /// <include file="Application.xmldoc" path="declaration/member[@name='DoCommandLine(GISharp.Lib.Gio.ApplicationCommandLine)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(ApplicationClass.UnmanagedCommandLine))]
        protected virtual unsafe System.Int32 DoCommandLine(GISharp.Lib.Gio.ApplicationCommandLine commandLine)
        {
            var application_ = Handle;
            var commandLine_ = commandLine.Handle;
            var ret_ = GISharp.Lib.GObject.TypeClass.GetUnmanagedVirtualMethod<ApplicationClass.UnmanagedCommandLine>(_GType)!(application_,commandLine_);
            var ret = (System.Int32)ret_;
            return ret;
        }

        /// <include file="Application.xmldoc" path="declaration/member[@name='DoHandleLocalOptions(GISharp.Lib.GLib.VariantDict)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(ApplicationClass.UnmanagedHandleLocalOptions))]
        protected virtual unsafe System.Int32 DoHandleLocalOptions(GISharp.Lib.GLib.VariantDict options)
        {
            var application_ = Handle;
            var options_ = options.Handle;
            var ret_ = GISharp.Lib.GObject.TypeClass.GetUnmanagedVirtualMethod<ApplicationClass.UnmanagedHandleLocalOptions>(_GType)!(application_,options_);
            var ret = (System.Int32)ret_;
            return ret;
        }

        /// <include file="Application.xmldoc" path="declaration/member[@name='DoTryLocalCommandLine(GISharp.Lib.GLib.Strv,System.Int32)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(ApplicationClass.UnmanagedTryLocalCommandLine))]
        protected virtual unsafe System.Boolean DoTryLocalCommandLine(ref GISharp.Lib.GLib.Strv arguments, out System.Int32 exitStatus)
        {
            var application_ = Handle;
            var arguments_ = arguments.Take();
            var ret_ = GISharp.Lib.GObject.TypeClass.GetUnmanagedVirtualMethod<ApplicationClass.UnmanagedTryLocalCommandLine>(_GType)!(application_,ref arguments_,out var exitStatus_);
            arguments = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Strv>(arguments_, GISharp.Runtime.Transfer.Full)!;
            exitStatus = (System.Int32)exitStatus_;
            var ret = (System.Boolean)ret_;
            return ret;
        }

        /// <include file="Application.xmldoc" path="declaration/member[@name='DoNameLost()']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(ApplicationClass.UnmanagedNameLost))]
        protected virtual unsafe System.Boolean DoNameLost()
        {
            var application_ = Handle;
            var ret_ = GISharp.Lib.GObject.TypeClass.GetUnmanagedVirtualMethod<ApplicationClass.UnmanagedNameLost>(_GType)!(application_);
            var ret = (System.Boolean)ret_;
            return ret;
        }

        /// <include file="Application.xmldoc" path="declaration/member[@name='DoOpen(GISharp.Runtime.UnownedCPtrArray&lt;GISharp.Lib.Gio.IFile&gt;,GISharp.Lib.GLib.UnownedUtf8)']/*" />
        [GISharp.Runtime.SinceAttribute("2.28")]
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(ApplicationClass.UnmanagedOpen))]
        protected virtual unsafe void DoOpen(GISharp.Runtime.UnownedCPtrArray<GISharp.Lib.Gio.IFile> files, GISharp.Lib.GLib.UnownedUtf8 hint)
        {
            var application_ = Handle;ref readonly var files_ = ref files.GetPinnableReference();
            var nFiles_ = (System.Int32)files.Length;
            var hint_ = hint.Handle;
            GISharp.Lib.GObject.TypeClass.GetUnmanagedVirtualMethod<ApplicationClass.UnmanagedOpen>(_GType)!(application_, files_, nFiles_, hint_);
        }

        /// <include file="Application.xmldoc" path="declaration/member[@name='DoQuitMainloop()']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(ApplicationClass.UnmanagedQuitMainloop))]
        protected virtual unsafe void DoQuitMainloop()
        {
            var application_ = Handle;
            GISharp.Lib.GObject.TypeClass.GetUnmanagedVirtualMethod<ApplicationClass.UnmanagedQuitMainloop>(_GType)!(application_);
        }

        /// <include file="Application.xmldoc" path="declaration/member[@name='DoRunMainloop()']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(ApplicationClass.UnmanagedRunMainloop))]
        protected virtual unsafe void DoRunMainloop()
        {
            var application_ = Handle;
            GISharp.Lib.GObject.TypeClass.GetUnmanagedVirtualMethod<ApplicationClass.UnmanagedRunMainloop>(_GType)!(application_);
        }

        /// <include file="Application.xmldoc" path="declaration/member[@name='DoShutdown()']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(ApplicationClass.UnmanagedShutdown))]
        protected virtual unsafe void DoShutdown()
        {
            var application_ = Handle;
            GISharp.Lib.GObject.TypeClass.GetUnmanagedVirtualMethod<ApplicationClass.UnmanagedShutdown>(_GType)!(application_);
        }

        /// <include file="Application.xmldoc" path="declaration/member[@name='DoStartup()']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(ApplicationClass.UnmanagedStartup))]
        protected virtual unsafe void DoStartup()
        {
            var application_ = Handle;
            GISharp.Lib.GObject.TypeClass.GetUnmanagedVirtualMethod<ApplicationClass.UnmanagedStartup>(_GType)!(application_);
        }

        void GISharp.Lib.Gio.IActionGroup.DoActionAdded(GISharp.Lib.GLib.UnownedUtf8 actionName)
        {
            throw new System.NotImplementedException();
        }

        void GISharp.Lib.Gio.IActionGroup.DoActionEnabledChanged(GISharp.Lib.GLib.UnownedUtf8 actionName, System.Boolean enabled)
        {
            throw new System.NotImplementedException();
        }

        void GISharp.Lib.Gio.IActionGroup.DoActionRemoved(GISharp.Lib.GLib.UnownedUtf8 actionName)
        {
            throw new System.NotImplementedException();
        }

        void GISharp.Lib.Gio.IActionGroup.DoActionStateChanged(GISharp.Lib.GLib.UnownedUtf8 actionName, GISharp.Lib.GLib.Variant state)
        {
            throw new System.NotImplementedException();
        }

        void GISharp.Lib.Gio.IActionGroup.DoActivateAction(GISharp.Lib.GLib.UnownedUtf8 actionName, GISharp.Lib.GLib.Variant? parameter)
        {
            throw new System.NotImplementedException();
        }

        void GISharp.Lib.Gio.IActionGroup.DoChangeActionState(GISharp.Lib.GLib.UnownedUtf8 actionName, GISharp.Lib.GLib.Variant value)
        {
            throw new System.NotImplementedException();
        }

        System.Boolean GISharp.Lib.Gio.IActionGroup.DoGetActionEnabled(GISharp.Lib.GLib.UnownedUtf8 actionName)
        {
            throw new System.NotImplementedException();
        }

        GISharp.Lib.GLib.VariantType? GISharp.Lib.Gio.IActionGroup.DoGetActionParameterType(GISharp.Lib.GLib.UnownedUtf8 actionName)
        {
            throw new System.NotImplementedException();
        }

        GISharp.Lib.GLib.Variant? GISharp.Lib.Gio.IActionGroup.DoGetActionState(GISharp.Lib.GLib.UnownedUtf8 actionName)
        {
            throw new System.NotImplementedException();
        }

        GISharp.Lib.GLib.Variant? GISharp.Lib.Gio.IActionGroup.DoGetActionStateHint(GISharp.Lib.GLib.UnownedUtf8 actionName)
        {
            throw new System.NotImplementedException();
        }

        GISharp.Lib.GLib.VariantType? GISharp.Lib.Gio.IActionGroup.DoGetActionStateType(GISharp.Lib.GLib.UnownedUtf8 actionName)
        {
            throw new System.NotImplementedException();
        }

        System.Boolean GISharp.Lib.Gio.IActionGroup.DoHasAction(GISharp.Lib.GLib.UnownedUtf8 actionName)
        {
            throw new System.NotImplementedException();
        }

        GISharp.Lib.GLib.Strv GISharp.Lib.Gio.IActionGroup.DoListActions()
        {
            throw new System.NotImplementedException();
        }

        void GISharp.Lib.Gio.IActionMap.DoAddAction(GISharp.Lib.Gio.IAction action)
        {
            throw new System.NotImplementedException();
        }

        GISharp.Lib.Gio.IAction GISharp.Lib.Gio.IActionMap.DoLookupAction(GISharp.Lib.GLib.UnownedUtf8 actionName)
        {
            throw new System.NotImplementedException();
        }

        void GISharp.Lib.Gio.IActionMap.DoRemoveAction(GISharp.Lib.GLib.UnownedUtf8 actionName)
        {
            throw new System.NotImplementedException();
        }
    }
}