<declaration>

<member name='IFile.NewForCommandlineArg(GISharp.Lib.GLib.Filename)'>
<summary>
Creates a <see cref="IFile"/> with the given argument from the command line.
The value of <paramref name="arg"/> can be either a URI, an absolute path or a
relative path resolved relative to the current working directory.
This operation never fails, but the returned object might not
support any I/O operation if <paramref name="arg"/> points to a malformed path.
</summary>
<remarks>
Note that on Windows, this function expects its argument to be in
UTF-8 -- not the system code page.  This means that you
should not use this function with string from argv as it is passed
to main().  g_win32_get_command_line() will return a UTF-8 version of
the commandline.  <see cref="Application"/> also uses UTF-8 but
<see cref="ApplicationCommandLine.CreateFileForArg(GISharp.Lib.GLib.Filename)"/> may be more useful
for you there.  It is also always possible to use this function with
#GOptionContext arguments of type %G_OPTION_ARG_FILENAME.
</remarks>
<param name="arg">
a command line string
</param>
<returns>
a new <see cref="IFile"/>.
   Free the returned object with g_object_unref().
</returns>
</member>

<member name='IFile.NewForCommandlineArgAndCwd(GISharp.Lib.GLib.Filename,GISharp.Lib.GLib.Filename)'>
<summary>
Creates a <see cref="IFile"/> with the given argument from the command line.
</summary>
<remarks>
This function is similar to <see cref="IFile.NewForCommandlineArg(GISharp.Lib.GLib.Filename)"/> except
that it allows for passing the current working directory as an
argument instead of using the current working directory of the
process.

This is useful if the commandline argument was given in a context
other than the invocation of the current process.

See also <see cref="ApplicationCommandLine.CreateFileForArg(GISharp.Lib.GLib.Filename)"/>.
</remarks>
<param name="arg">
a command line string
</param>
<param name="cwd">
the current working directory of the commandline
</param>
<returns>
a new <see cref="IFile"/>
</returns>
</member>

<member name='IFile.NewForPath(GISharp.Lib.GLib.Filename)'>
<summary>
Constructs a <see cref="IFile"/> for a given path. This operation never
fails, but the returned object might not support any I/O
operation if <paramref name="path"/> is malformed.
</summary>
<param name="path">
a string containing a relative or absolute path.
    The string must be encoded in the glib filename encoding.
</param>
<returns>
a new <see cref="IFile"/> for the given <paramref name="path"/>.
  Free the returned object with g_object_unref().
</returns>
</member>

<member name='IFile.NewForUri(GISharp.Lib.GLib.UnownedUtf8)'>
<summary>
Constructs a <see cref="IFile"/> for a given URI. This operation never
fails, but the returned object might not support any I/O
operation if <paramref name="uri"/> is malformed or if the uri type is
not supported.
</summary>
<param name="uri">
a UTF-8 string containing a URI
</param>
<returns>
a new <see cref="IFile"/> for the given <paramref name="uri"/>.
    Free the returned object with g_object_unref().
</returns>
</member>

<member name='IFile.NewTmp(GISharp.Lib.GLib.Filename?,GISharp.Lib.Gio.FileIOStream)'>
<summary>
Opens a file in the preferred directory for temporary files (as
returned by g_get_tmp_dir()) and returns a <see cref="IFile"/> and
<see cref="FileIOStream"/> pointing to it.
</summary>
<remarks>
<paramref name="tmpl"/> should be a string in the GLib file name encoding
containing a sequence of six 'X' characters, and containing no
directory components. If it is <c>null</c>, a default template is used.

Unlike the other <see cref="IFile"/> constructors, this will return <c>null</c> if
a temporary file could not be created.
</remarks>
<param name="tmpl">
Template for the file
  name, as in g_file_open_tmp(), or <c>null</c> for a default template
</param>
<param name="iostream">
on return, a <see cref="FileIOStream"/> for the created file
</param>
<returns>
a new <see cref="IFile"/>.
    Free the returned object with g_object_unref().
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='IFile.ParseName(GISharp.Lib.GLib.UnownedUtf8)'>
<summary>
Constructs a <see cref="IFile"/> with the given <paramref name="parseName"/> (i.e. something
given by <see cref="File.GetParseName(GISharp.Lib.Gio.IFile)"/>). This operation never fails,
but the returned object might not support any I/O operation if
the <paramref name="parseName"/> cannot be parsed.
</summary>
<param name="parseName">
a file name or path to be parsed
</param>
<returns>
a new <see cref="IFile"/>.
</returns>
</member>

<member name='IFile.DoAppendTo(GISharp.Lib.Gio.FileCreateFlags,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Gets an output stream for appending data to the file.
If the file doesn't already exist it is created.
</summary>
<remarks>
By default files created are generally readable by everyone,
but if you pass <see cref="FileCreateFlags.Private"/> in <paramref name="flags"/> the file
will be made readable only to the current user, to the level that
is supported on the target filesystem.

If <paramref name="cancellable"/> is not <c>null</c>, then the operation can be cancelled
by triggering the cancellable object from another thread. If the
operation was cancelled, the error <see cref="IOErrorEnum.Cancelled"/> will be
returned.

Some file systems don't allow all file names, and may return an
<see cref="IOErrorEnum.InvalidFilename"/> error. If the file is a directory the
<see cref="IOErrorEnum.IsDirectory"/> error will be returned. Other errors are
possible too, and depend on what kind of filesystem the file is on.
</remarks>
<param name="flags">
a set of <see cref="FileCreateFlags"/>
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
<returns>
a <see cref="FileOutputStream"/>, or <c>null</c> on error.
    Free the returned object with g_object_unref().
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='IFile.DoAppendToAsync(GISharp.Lib.Gio.FileCreateFlags,System.Int32,GISharp.Lib.Gio.AsyncReadyCallback?,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Asynchronously opens this instance for appending.
</summary>
<remarks>
For more details, see <see cref="File.AppendTo(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.FileCreateFlags,GISharp.Lib.Gio.Cancellable)"/> which is
the synchronous version of this call.
</remarks>
<param name="flags">
a set of <see cref="FileCreateFlags"/>
</param>
<param name="ioPriority">
the [I/O priority][io-priority] of the request
</param>
<param name="callback">
a <see cref="AsyncReadyCallback"/> to call
    when the request is satisfied
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
</member>

<member name='IFile.DoAppendToFinish(GISharp.Lib.Gio.IAsyncResult)'>
<summary>
Finishes an asynchronous file append operation started with
<see cref="File.AppendToAsync(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.FileCreateFlags,System.Int32,GISharp.Lib.Gio.Cancellable)"/>.
</summary>
<param name="res">
<see cref="IAsyncResult"/>
</param>
<returns>
a valid <see cref="FileOutputStream"/>
    or <c>null</c> on error.
    Free the returned object with g_object_unref().
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='IFile.DoCopy(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.FileCopyFlags,GISharp.Lib.Gio.FileProgressCallback?,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Copies the file this instance to the location specified by <paramref name="destination"/>.
Can not handle recursive copies of directories.
</summary>
<remarks>
If the flag <see cref="FileCopyFlags.Overwrite"/> is specified an already
existing <paramref name="destination"/> file is overwritten.

If the flag <see cref="FileCopyFlags.NoFollowSymlinks"/> is specified then symlinks
will be copied as symlinks, otherwise the target of the
this instance symlink will be copied.

If the flag <see cref="FileCopyFlags.AllMetadata"/> is specified then all the metadata
that is possible to copy is copied, not just the default subset (which,
for instance, does not include the owner, see <see cref="FileInfo"/>).

If <paramref name="cancellable"/> is not <c>null</c>, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error <see cref="IOErrorEnum.Cancelled"/> will be returned.

If <paramref name="progressCallback"/> is not <c>null</c>, then the operation can be monitored
by setting this to a <see cref="FileProgressCallback"/> function.
It is guaranteed
that this callback will be called after all data has been transferred with
the total number of bytes copied during the operation.

If the this instance file does not exist, then the <see cref="IOErrorEnum.NotFound"/> error
is returned, independent on the status of the <paramref name="destination"/>.

If <see cref="FileCopyFlags.Overwrite"/> is not specified and the target exists, then
the error <see cref="IOErrorEnum.Exists"/> is returned.

If trying to overwrite a file over a directory, the <see cref="IOErrorEnum.IsDirectory"/>
error is returned. If trying to overwrite a directory with a directory the
<see cref="IOErrorEnum.WouldMerge"/> error is returned.

If the source is a directory and the target does not exist, or
<see cref="FileCopyFlags.Overwrite"/> is specified and the target is a file, then the
<see cref="IOErrorEnum.WouldRecurse"/> error is returned.

If you are interested in copying the <see cref="IFile"/> object itself (not the on-disk
file), see <see cref="File.Dup(GISharp.Lib.Gio.IFile)"/>.
</remarks>
<param name="destination">
destination <see cref="IFile"/>
</param>
<param name="flags">
set of <see cref="FileCopyFlags"/>
</param>
<param name="progressCallback">
function to callback with
    progress information, or <c>null</c> if progress information is not needed
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
<returns>
<c>true</c> on success, <c>false</c> otherwise.
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='IFile.DoCopyAsync(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.FileCopyFlags,System.Int32,GISharp.Lib.Gio.FileProgressCallback?,GISharp.Lib.Gio.AsyncReadyCallback?,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Copies the file this instance to the location specified by <paramref name="destination"/>
asynchronously. For details of the behaviour, see <see cref="File.Copy(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.FileCopyFlags,GISharp.Lib.Gio.FileProgressCallback,GISharp.Lib.Gio.Cancellable)"/>.
</summary>
<remarks>
If <paramref name="progressCallback"/> is not <c>null</c>, then that function that will be called
just like in <see cref="File.Copy(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.FileCopyFlags,GISharp.Lib.Gio.FileProgressCallback,GISharp.Lib.Gio.Cancellable)"/>. The callback will run in the default main context
of the thread calling <see cref="File.CopyAsync(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.FileCopyFlags,System.Int32,GISharp.Lib.Gio.Cancellable,GISharp.Lib.Gio.FileProgressCallback)"/> — the same context as <paramref name="callback"/> is
run in.
</remarks>
<param name="destination">
destination <see cref="IFile"/>
</param>
<param name="flags">
set of <see cref="FileCopyFlags"/>
</param>
<param name="ioPriority">
the [I/O priority][io-priority] of the request
</param>
<param name="progressCallback">
function to callback with progress
    information, or <c>null</c> if progress information is not needed
</param>
<param name="callback">
a <see cref="AsyncReadyCallback"/> to call when the request is satisfied
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
</member>

<member name='IFile.DoCopyFinish(GISharp.Lib.Gio.IAsyncResult)'>
<summary>
Finishes copying the file started with <see cref="IFile.DoCopyAsync(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.FileCopyFlags,System.Int32,GISharp.Lib.Gio.FileProgressCallback,GISharp.Lib.Gio.AsyncReadyCallback,GISharp.Lib.Gio.Cancellable)"/>.
</summary>
<param name="res">
a <see cref="IAsyncResult"/>
</param>
<returns>
a <c>true</c> on success, <c>false</c> on error.
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='IFile.DoCreate(GISharp.Lib.Gio.FileCreateFlags,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Creates a new file and returns an output stream for writing to it.
The file must not already exist.
</summary>
<remarks>
By default files created are generally readable by everyone,
but if you pass <see cref="FileCreateFlags.Private"/> in <paramref name="flags"/> the file
will be made readable only to the current user, to the level
that is supported on the target filesystem.

If <paramref name="cancellable"/> is not <c>null</c>, then the operation can be cancelled
by triggering the cancellable object from another thread. If the
operation was cancelled, the error <see cref="IOErrorEnum.Cancelled"/> will be
returned.

If a file or directory with this name already exists the
<see cref="IOErrorEnum.Exists"/> error will be returned. Some file systems don't
allow all file names, and may return an <see cref="IOErrorEnum.InvalidFilename"/>
error, and if the name is to long <see cref="IOErrorEnum.FilenameTooLong"/> will
be returned. Other errors are possible too, and depend on what kind
of filesystem the file is on.
</remarks>
<param name="flags">
a set of <see cref="FileCreateFlags"/>
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
<returns>
a <see cref="FileOutputStream"/> for the newly created
    file, or <c>null</c> on error.
    Free the returned object with g_object_unref().
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='IFile.DoCreateAsync(GISharp.Lib.Gio.FileCreateFlags,System.Int32,GISharp.Lib.Gio.AsyncReadyCallback?,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Asynchronously creates a new file and returns an output stream
for writing to it. The file must not already exist.
</summary>
<remarks>
For more details, see <see cref="File.Create(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.FileCreateFlags,GISharp.Lib.Gio.Cancellable)"/> which is
the synchronous version of this call.
</remarks>
<param name="flags">
a set of <see cref="FileCreateFlags"/>
</param>
<param name="ioPriority">
the [I/O priority][io-priority] of the request
</param>
<param name="callback">
a <see cref="AsyncReadyCallback"/> to call
    when the request is satisfied
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
</member>

<member name='IFile.DoCreateFinish(GISharp.Lib.Gio.IAsyncResult)'>
<summary>
Finishes an asynchronous file create operation started with
<see cref="File.CreateAsync(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.FileCreateFlags,System.Int32,GISharp.Lib.Gio.Cancellable)"/>.
</summary>
<param name="res">
a <see cref="IAsyncResult"/>
</param>
<returns>
a <see cref="FileOutputStream"/> or <c>null</c> on error.
    Free the returned object with g_object_unref().
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='IFile.DoCreateReadwrite(GISharp.Lib.Gio.FileCreateFlags,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Creates a new file and returns a stream for reading and
writing to it. The file must not already exist.
</summary>
<remarks>
By default files created are generally readable by everyone,
but if you pass <see cref="FileCreateFlags.Private"/> in <paramref name="flags"/> the file
will be made readable only to the current user, to the level
that is supported on the target filesystem.

If <paramref name="cancellable"/> is not <c>null</c>, then the operation can be cancelled
by triggering the cancellable object from another thread. If the
operation was cancelled, the error <see cref="IOErrorEnum.Cancelled"/> will be
returned.

If a file or directory with this name already exists, the
<see cref="IOErrorEnum.Exists"/> error will be returned. Some file systems don't
allow all file names, and may return an <see cref="IOErrorEnum.InvalidFilename"/>
error, and if the name is too long, <see cref="IOErrorEnum.FilenameTooLong"/>
will be returned. Other errors are possible too, and depend on what
kind of filesystem the file is on.

Note that in many non-local file cases read and write streams are
not supported, so make sure you really need to do read and write
streaming, rather than just opening for reading or writing.
</remarks>
<param name="flags">
a set of <see cref="FileCreateFlags"/>
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
<returns>
a <see cref="FileIOStream"/> for the newly created
    file, or <c>null</c> on error.
    Free the returned object with g_object_unref().
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='IFile.DoCreateReadwriteAsync(GISharp.Lib.Gio.FileCreateFlags,System.Int32,GISharp.Lib.Gio.AsyncReadyCallback?,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Asynchronously creates a new file and returns a stream
for reading and writing to it. The file must not already exist.
</summary>
<remarks>
For more details, see <see cref="File.CreateReadwrite(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.FileCreateFlags,GISharp.Lib.Gio.Cancellable)"/> which is
the synchronous version of this call.
</remarks>
<param name="flags">
a set of <see cref="FileCreateFlags"/>
</param>
<param name="ioPriority">
the [I/O priority][io-priority] of the request
</param>
<param name="callback">
a <see cref="AsyncReadyCallback"/> to call
    when the request is satisfied
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
</member>

<member name='IFile.DoCreateReadwriteFinish(GISharp.Lib.Gio.IAsyncResult)'>
<summary>
Finishes an asynchronous file create operation started with
<see cref="File.CreateReadwriteAsync(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.FileCreateFlags,System.Int32,GISharp.Lib.Gio.Cancellable)"/>.
</summary>
<param name="res">
a <see cref="IAsyncResult"/>
</param>
<returns>
a <see cref="FileIOStream"/> or <c>null</c> on error.
    Free the returned object with g_object_unref().
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='IFile.DoDeleteFile(GISharp.Lib.Gio.Cancellable?)'>
<summary>
Deletes a file. If the this instance is a directory, it will only be
deleted if it is empty. This has the same semantics as g_unlink().
</summary>
<remarks>
If this instance doesn’t exist, <see cref="IOErrorEnum.NotFound"/> will be returned. This allows
for deletion to be implemented avoiding
[time-of-check to time-of-use races](https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use):
|[
g_autoptr(GError) local_error = NULL;
if (!g_file_delete (my_file, my_cancellable, &amp;local_error) &amp;&amp;
    !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))
  {
    // deletion failed for some reason other than the file not existing:
    // so report the error
    g_warning ("Failed to delete %s: %s",
               g_file_peek_path (my_file), local_error-&gt;message);
  }
]|

If <paramref name="cancellable"/> is not <c>null</c>, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error <see cref="IOErrorEnum.Cancelled"/> will be returned.
</remarks>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
<returns>
<c>true</c> if the file was deleted. <c>false</c> otherwise.
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='IFile.DoDeleteFileAsync(System.Int32,GISharp.Lib.Gio.AsyncReadyCallback?,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Asynchronously delete a file. If the this instance is a directory, it will
only be deleted if it is empty.  This has the same semantics as
g_unlink().
</summary>
<param name="ioPriority">
the [I/O priority][io-priority] of the request
</param>
<param name="callback">
a <see cref="AsyncReadyCallback"/> to call
    when the request is satisfied
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
</member>

<member name='IFile.DoDeleteFileFinish(GISharp.Lib.Gio.IAsyncResult)'>
<summary>
Finishes deleting a file started with <see cref="IFile.DoDeleteFileAsync(System.Int32,GISharp.Lib.Gio.AsyncReadyCallback,GISharp.Lib.Gio.Cancellable)"/>.
</summary>
<param name="result">
a <see cref="IAsyncResult"/>
</param>
<returns>
<c>true</c> if the file was deleted. <c>false</c> otherwise.
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='IFile.DoDup()'>
<summary>
Duplicates a <see cref="IFile"/> handle. This operation does not duplicate
the actual file or directory represented by the <see cref="IFile"/>; see
<see cref="File.Copy(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.FileCopyFlags,GISharp.Lib.Gio.FileProgressCallback,GISharp.Lib.Gio.Cancellable)"/> if attempting to copy a file.
</summary>
<remarks>
<see cref="File.Dup(GISharp.Lib.Gio.IFile)"/> is useful when a second handle is needed to the same underlying
file, for use in a separate thread (<see cref="IFile"/> is not thread-safe). For use
within the same thread, use g_object_ref() to increment the existing object’s
reference count.

This call does no blocking I/O.
</remarks>
<returns>
a new <see cref="IFile"/> that is a duplicate
    of the given <see cref="IFile"/>.
</returns>
</member>

<member name='IFile.DoEjectMountableFinish(GISharp.Lib.Gio.IAsyncResult)'>
<summary>
Finishes an asynchronous eject operation started by
g_file_eject_mountable().
</summary>
<param name="result">
a <see cref="IAsyncResult"/>
</param>
<returns>
<c>true</c> if the this instance was ejected successfully.
    <c>false</c> otherwise.
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='IFile.DoEjectMountableWithOperationFinish(GISharp.Lib.Gio.IAsyncResult)'>
<summary>
Finishes an asynchronous eject operation started by
g_file_eject_mountable_with_operation().
</summary>
<param name="result">
a <see cref="IAsyncResult"/>
</param>
<returns>
<c>true</c> if the this instance was ejected successfully.
    <c>false</c> otherwise.
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='IFile.DoEnumerateChildrenAsync(GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.Gio.FileQueryInfoFlags,System.Int32,GISharp.Lib.Gio.AsyncReadyCallback?,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Asynchronously gets the requested information about the files
in a directory. The result is a #GFileEnumerator object that will
give out <see cref="FileInfo"/> objects for all the files in the directory.
</summary>
<remarks>
For more details, see g_file_enumerate_children() which is
the synchronous version of this call.
</remarks>
<param name="attributes">
an attribute query string
</param>
<param name="flags">
a set of <see cref="FileQueryInfoFlags"/>
</param>
<param name="ioPriority">
the [I/O priority][io-priority] of the request
</param>
<param name="callback">
a <see cref="AsyncReadyCallback"/> to call when the
    request is satisfied
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
</member>

<member name='IFile.DoEqual(GISharp.Lib.Gio.IFile)'>
<summary>
Checks if the two given #GFiles refer to the same file.
</summary>
<remarks>
Note that two #GFiles that differ can still refer to the same
file on the filesystem due to various forms of filename
aliasing.

This call does no blocking I/O.
</remarks>
<param name="file2">
the second <see cref="IFile"/>
</param>
<returns>
<c>true</c> if this instance and <paramref name="file2"/> are equal.
</returns>
</member>

<member name='IFile.DoGetBasename()'>
</member>

<member name='IFile.DoGetChildForDisplayName(GISharp.Lib.GLib.UnownedUtf8)'>
<summary>
Gets the child of this instance for a given <paramref name="displayName"/> (i.e. a UTF-8
version of the name). If this function fails, it returns <c>null</c>
and <see cref="GISharp.Runtime.GErrorException"/> will be set. This is very useful when constructing a
<see cref="IFile"/> for a new file and the user entered the filename in the
user interface, for instance when you select a directory and
type a filename in the file selector.
</summary>
<remarks>
This call does no blocking I/O.
</remarks>
<param name="displayName">
string to a possible child
</param>
<returns>
a <see cref="IFile"/> to the specified child, or
    <c>null</c> if the display name couldn't be converted.
    Free the returned object with g_object_unref().
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='IFile.DoGetParent()'>
<summary>
Gets the parent directory for the this instance.
If the this instance represents the root directory of the
file system, then <c>null</c> will be returned.
</summary>
<remarks>
This call does no blocking I/O.
</remarks>
<returns>
a <see cref="IFile"/> structure to the
    parent of the given <see cref="IFile"/> or <c>null</c> if there is no parent. Free
    the returned object with g_object_unref().
</returns>
</member>

<member name='IFile.DoGetParseName()'>
<summary>
Gets the parse name of the this instance.
A parse name is a UTF-8 string that describes the
file such that one can get the <see cref="IFile"/> back using
<see cref="IFile.ParseName(GISharp.Lib.GLib.UnownedUtf8)"/>.
</summary>
<remarks>
This is generally used to show the <see cref="IFile"/> as a nice
full-pathname kind of string in a user interface,
like in a location entry.

For local files with names that can safely be converted
to UTF-8 the pathname is used, otherwise the IRI is used
(a form of URI that allows UTF-8 characters unescaped).

This call does no blocking I/O.
</remarks>
<returns>
a string containing the <see cref="IFile"/>'s parse name.
    The returned string should be freed with g_free()
    when no longer needed.
</returns>
</member>

<member name='IFile.DoGetPath()'>
</member>

<member name='IFile.DoGetRelativePath(GISharp.Lib.Gio.IFile)'>
</member>

<member name='IFile.DoGetUri()'>
<summary>
Gets the URI for the this instance.
</summary>
<remarks>
This call does no blocking I/O.
</remarks>
<returns>
a string containing the <see cref="IFile"/>'s URI.
    The returned string should be freed with g_free()
    when no longer needed.
</returns>
</member>

<member name='IFile.DoGetUriScheme()'>
<summary>
Gets the URI scheme for a <see cref="IFile"/>.
RFC 3986 decodes the scheme as:
|[
URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
]|
Common schemes include "file", "http", "ftp", etc.
</summary>
<remarks>
This call does no blocking I/O.
</remarks>
<returns>
a string containing the URI scheme for the given
    <see cref="IFile"/>. The returned string should be freed with g_free()
    when no longer needed.
</returns>
</member>

<member name='IFile.DoHasUriScheme(GISharp.Lib.GLib.UnownedUtf8)'>
<summary>
Checks to see if a <see cref="IFile"/> has a given URI scheme.
</summary>
<remarks>
This call does no blocking I/O.
</remarks>
<param name="uriScheme">
a string containing a URI scheme
</param>
<returns>
<c>true</c> if <see cref="IFile"/>'s backend supports the
    given URI scheme, <c>false</c> if URI scheme is <c>null</c>,
    not supported, or <see cref="IFile"/> is invalid.
</returns>
</member>

<member name='IFile.DoHash()'>
<summary>
Creates a hash value for a <see cref="IFile"/>.
</summary>
<remarks>
This call does no blocking I/O.
</remarks>
<returns>
0 if this instance is not a valid <see cref="IFile"/>, otherwise an
    integer that can be used as hash value for the <see cref="IFile"/>.
    This function is intended for easily hashing a <see cref="IFile"/> to
    add to a #GHashTable or similar data structure.
</returns>
</member>

<member name='IFile.DoIsNative()'>
<summary>
Checks to see if a file is native to the platform.
</summary>
<remarks>
A native file is one expressed in the platform-native filename format,
e.g. "C:\Windows" or "/usr/bin/". This does not mean the file is local,
as it might be on a locally mounted remote filesystem.

On some systems non-native files may be available using the native
filesystem via a userspace filesystem (FUSE), in these cases this call
will return <c>false</c>, but <see cref="File.GetPath(GISharp.Lib.Gio.IFile)"/> will still return a native path.

This call does no blocking I/O.
</remarks>
<returns>
<c>true</c> if this instance is native
</returns>
</member>

<member name='IFile.DoMakeDirectory(GISharp.Lib.Gio.Cancellable?)'>
<summary>
Creates a directory. Note that this will only create a child directory
of the immediate parent directory of the path or URI given by the <see cref="IFile"/>.
To recursively create directories, see <see cref="File.MakeDirectoryWithParents(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.Cancellable)"/>.
This function will fail if the parent directory does not exist, setting
<see cref="GISharp.Runtime.GErrorException"/> to <see cref="IOErrorEnum.NotFound"/>. If the file system doesn't support
creating directories, this function will fail, setting <see cref="GISharp.Runtime.GErrorException"/> to
<see cref="IOErrorEnum.NotSupported"/>.
</summary>
<remarks>
For a local <see cref="IFile"/> the newly created directory will have the default
(current) ownership and permissions of the current process.

If <paramref name="cancellable"/> is not <c>null</c>, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error <see cref="IOErrorEnum.Cancelled"/> will be returned.
</remarks>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
<returns>
<c>true</c> on successful creation, <c>false</c> otherwise.
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='IFile.DoMakeDirectoryAsync(System.Int32,GISharp.Lib.Gio.AsyncReadyCallback?,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Asynchronously creates a directory.
</summary>
<param name="ioPriority">
the [I/O priority][io-priority] of the request
</param>
<param name="callback">
a <see cref="AsyncReadyCallback"/> to call
    when the request is satisfied
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
</member>

<member name='IFile.DoMakeDirectoryFinish(GISharp.Lib.Gio.IAsyncResult)'>
<summary>
Finishes an asynchronous directory creation, started with
<see cref="File.MakeDirectoryAsync(GISharp.Lib.Gio.IFile,System.Int32,GISharp.Lib.Gio.Cancellable)"/>.
</summary>
<param name="result">
a <see cref="IAsyncResult"/>
</param>
<returns>
<c>true</c> on successful directory creation, <c>false</c> otherwise.
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='IFile.DoMakeSymbolicLink(GISharp.Lib.GLib.Filename,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Creates a symbolic link named this instance which contains the string
<paramref name="symlinkValue"/>.
</summary>
<remarks>
If <paramref name="cancellable"/> is not <c>null</c>, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error <see cref="IOErrorEnum.Cancelled"/> will be returned.
</remarks>
<param name="symlinkValue">
a string with the path for the target
    of the new symlink
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
<returns>
<c>true</c> on the creation of a new symlink, <c>false</c> otherwise.
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='IFile.DoMeasureDiskUsageFinish(GISharp.Lib.Gio.IAsyncResult,System.UInt64,System.UInt64,System.UInt64)'>
<summary>
Collects the results from an earlier call to
g_file_measure_disk_usage_async().  See g_file_measure_disk_usage() for
more information.
</summary>
<param name="result">
the <see cref="IAsyncResult"/> passed to your <see cref="AsyncReadyCallback"/>
</param>
<param name="diskUsage">
the number of bytes of disk space used
</param>
<param name="numDirs">
the number of directories encountered
</param>
<param name="numFiles">
the number of non-directories encountered
</param>
<returns>
<c>true</c> if successful, with the out parameters set.
         <c>false</c> otherwise, with <see cref="GISharp.Runtime.GErrorException"/> set.
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='IFile.DoMountEnclosingVolumeFinish(GISharp.Lib.Gio.IAsyncResult)'>
<summary>
Finishes a mount operation started by g_file_mount_enclosing_volume().
</summary>
<param name="result">
a <see cref="IAsyncResult"/>
</param>
<returns>
<c>true</c> if successful. If an error has occurred,
    this function will return <c>false</c> and set <see cref="GISharp.Runtime.GErrorException"/>
    appropriately if present.
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='IFile.DoMountMountableFinish(GISharp.Lib.Gio.IAsyncResult)'>
<summary>
Finishes a mount operation. See g_file_mount_mountable() for details.
</summary>
<remarks>
Finish an asynchronous mount operation that was started
with g_file_mount_mountable().
</remarks>
<param name="result">
a <see cref="IAsyncResult"/>
</param>
<returns>
a <see cref="IFile"/> or <c>null</c> on error.
    Free the returned object with g_object_unref().
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='IFile.DoMove(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.FileCopyFlags,GISharp.Lib.Gio.FileProgressCallback?,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Tries to move the file or directory this instance to the location specified
by <paramref name="destination"/>. If native move operations are supported then this is
used, otherwise a copy + delete fallback is used. The native
implementation may support moving directories (for instance on moves
inside the same filesystem), but the fallback code does not.
</summary>
<remarks>
If the flag <see cref="FileCopyFlags.Overwrite"/> is specified an already
existing <paramref name="destination"/> file is overwritten.

If <paramref name="cancellable"/> is not <c>null</c>, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error <see cref="IOErrorEnum.Cancelled"/> will be returned.

If <paramref name="progressCallback"/> is not <c>null</c>, then the operation can be monitored
by setting this to a <see cref="FileProgressCallback"/> function.
It is
guaranteed that this callback will be called after all data has been
transferred with the total number of bytes copied during the operation.

If the this instance file does not exist, then the <see cref="IOErrorEnum.NotFound"/>
error is returned, independent on the status of the <paramref name="destination"/>.

If <see cref="FileCopyFlags.Overwrite"/> is not specified and the target exists,
then the error <see cref="IOErrorEnum.Exists"/> is returned.

If trying to overwrite a file over a directory, the <see cref="IOErrorEnum.IsDirectory"/>
error is returned. If trying to overwrite a directory with a directory the
<see cref="IOErrorEnum.WouldMerge"/> error is returned.

If the source is a directory and the target does not exist, or
<see cref="FileCopyFlags.Overwrite"/> is specified and the target is a file, then
the <see cref="IOErrorEnum.WouldRecurse"/> error may be returned (if the native
move operation isn't available).
</remarks>
<param name="destination">
<see cref="IFile"/> pointing to the destination location
</param>
<param name="flags">
set of <see cref="FileCopyFlags"/>
</param>
<param name="progressCallback">
<see cref="FileProgressCallback"/>
    function for updates
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
<returns>
<c>true</c> on successful move, <c>false</c> otherwise.
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='IFile.DoOpenReadwrite(GISharp.Lib.Gio.Cancellable?)'>
<summary>
Opens an existing file for reading and writing. The result is
a <see cref="FileIOStream"/> that can be used to read and write the contents
of the file.
</summary>
<remarks>
If <paramref name="cancellable"/> is not <c>null</c>, then the operation can be cancelled
by triggering the cancellable object from another thread. If the
operation was cancelled, the error <see cref="IOErrorEnum.Cancelled"/> will be
returned.

If the file does not exist, the <see cref="IOErrorEnum.NotFound"/> error will
be returned. If the file is a directory, the <see cref="IOErrorEnum.IsDirectory"/>
error will be returned. Other errors are possible too, and depend on
what kind of filesystem the file is on. Note that in many non-local
file cases read and write streams are not supported, so make sure you
really need to do read and write streaming, rather than just opening
for reading or writing.
</remarks>
<param name="cancellable">
a <see cref="Cancellable"/>
</param>
<returns>
<see cref="FileIOStream"/> or <c>null</c> on error.
    Free the returned object with g_object_unref().
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='IFile.DoOpenReadwriteAsync(System.Int32,GISharp.Lib.Gio.AsyncReadyCallback?,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Asynchronously opens this instance for reading and writing.
</summary>
<remarks>
For more details, see <see cref="File.OpenReadwrite(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.Cancellable)"/> which is
the synchronous version of this call.
</remarks>
<param name="ioPriority">
the [I/O priority][io-priority] of the request
</param>
<param name="callback">
a <see cref="AsyncReadyCallback"/> to call
    when the request is satisfied
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
</member>

<member name='IFile.DoOpenReadwriteFinish(GISharp.Lib.Gio.IAsyncResult)'>
<summary>
Finishes an asynchronous file read operation started with
<see cref="File.OpenReadwriteAsync(GISharp.Lib.Gio.IFile,System.Int32,GISharp.Lib.Gio.Cancellable)"/>.
</summary>
<param name="res">
a <see cref="IAsyncResult"/>
</param>
<returns>
a <see cref="FileIOStream"/> or <c>null</c> on error.
    Free the returned object with g_object_unref().
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='IFile.DoPollMountable(GISharp.Lib.Gio.AsyncReadyCallback?,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Polls a file of type <see cref="FileType.Mountable"/>.
</summary>
<remarks>
If <paramref name="cancellable"/> is not <c>null</c>, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error <see cref="IOErrorEnum.Cancelled"/> will be returned.
</remarks>
<param name="callback">
a <see cref="AsyncReadyCallback"/> to call
    when the request is satisfied, or <c>null</c>
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object, <c>null</c> to ignore
</param>
</member>

<member name='IFile.DoPollMountableFinish(GISharp.Lib.Gio.IAsyncResult)'>
<summary>
Finishes a poll operation. See <see cref="File.PollMountable(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.AsyncReadyCallback,GISharp.Lib.Gio.Cancellable)"/> for details.
</summary>
<remarks>
Finish an asynchronous poll operation that was polled
with <see cref="File.PollMountable(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.AsyncReadyCallback,GISharp.Lib.Gio.Cancellable)"/>.
</remarks>
<param name="result">
a <see cref="IAsyncResult"/>
</param>
<returns>
<c>true</c> if the operation finished successfully. <c>false</c>
otherwise.
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='IFile.DoPrefixMatches(GISharp.Lib.Gio.IFile)'>
<summary>
Checks whether <paramref name="file"/> has the prefix specified by this instance.
</summary>
<remarks>
In other words, if the names of initial elements of <paramref name="file"/>'s
pathname match this instance. Only full pathname elements are matched,
so a path like /foo is not considered a prefix of /foobar, only
of /foo/bar.

A <see cref="IFile"/> is not a prefix of itself. If you want to check for
equality, use <see cref="File.Equals(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.IFile)"/>.

This call does no I/O, as it works purely on names. As such it can
sometimes return <c>false</c> even if <paramref name="file"/> is inside a this instance (from a
filesystem point of view), because the prefix of <paramref name="file"/> is an alias
of this instance.
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<returns>
<c>true</c> if the <paramref name="file"/>'s parent, grandparent, etc is this instance,
    <c>false</c> otherwise.
</returns>
</member>

<member name='IFile.DoQueryFilesystemInfo(GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Similar to <see cref="File.QueryInfo(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.Gio.FileQueryInfoFlags,GISharp.Lib.Gio.Cancellable)"/>, but obtains information
about the filesystem the this instance is on, rather than the file itself.
For instance the amount of space available and the type of
the filesystem.
</summary>
<remarks>
The <paramref name="attributes"/> value is a string that specifies the attributes
that should be gathered. It is not an error if it's not possible
to read a particular requested attribute from a file - it just
won't be set. <paramref name="attributes"/> should be a comma-separated list of
attributes or attribute wildcards. The wildcard "*" means all
attributes, and a wildcard like "filesystem::*" means all attributes
in the filesystem namespace. The standard namespace for filesystem
attributes is "filesystem". Common attributes of interest are
<see cref="FileAttribute.FilesystemSize"/> (the total size of the filesystem
in bytes), <see cref="FileAttribute.FilesystemFree"/> (number of bytes available),
and <see cref="FileAttribute.FilesystemType"/> (type of the filesystem).

If <paramref name="cancellable"/> is not <c>null</c>, then the operation can be cancelled
by triggering the cancellable object from another thread. If the
operation was cancelled, the error <see cref="IOErrorEnum.Cancelled"/> will be
returned.

If the file does not exist, the <see cref="IOErrorEnum.NotFound"/> error will
be returned. Other errors are possible too, and depend on what
kind of filesystem the file is on.
</remarks>
<param name="attributes">
an attribute query string
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
<returns>
a <see cref="FileInfo"/> or <c>null</c> if there was an error.
    Free the returned object with g_object_unref().
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='IFile.DoQueryFilesystemInfoAsync(GISharp.Lib.GLib.UnownedUtf8,System.Int32,GISharp.Lib.Gio.AsyncReadyCallback?,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Asynchronously gets the requested information about the filesystem
that the specified this instance is on. The result is a <see cref="FileInfo"/> object
that contains key-value attributes (such as type or size for the
file).
</summary>
<remarks>
For more details, see <see cref="File.QueryFilesystemInfo(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.Gio.Cancellable)"/> which is the
synchronous version of this call.
</remarks>
<param name="attributes">
an attribute query string
</param>
<param name="ioPriority">
the [I/O priority][io-priority] of the request
</param>
<param name="callback">
a <see cref="AsyncReadyCallback"/> to call
    when the request is satisfied
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
</member>

<member name='IFile.DoQueryFilesystemInfoFinish(GISharp.Lib.Gio.IAsyncResult)'>
<summary>
Finishes an asynchronous filesystem info query.
See <see cref="File.QueryFilesystemInfoAsync(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.UnownedUtf8,System.Int32,GISharp.Lib.Gio.Cancellable)"/>.
</summary>
<param name="res">
a <see cref="IAsyncResult"/>
</param>
<returns>
<see cref="FileInfo"/> for given this instance
    or <c>null</c> on error.
    Free the returned object with g_object_unref().
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='IFile.DoQueryInfo(GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.Gio.FileQueryInfoFlags,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Gets the requested information about specified this instance.
The result is a <see cref="FileInfo"/> object that contains key-value
attributes (such as the type or size of the file).
</summary>
<remarks>
The <paramref name="attributes"/> value is a string that specifies the file
attributes that should be gathered. It is not an error if
it's not possible to read a particular requested attribute
from a file - it just won't be set. <paramref name="attributes"/> should be a
comma-separated list of attributes or attribute wildcards.
The wildcard "*" means all attributes, and a wildcard like
"standard::*" means all attributes in the standard namespace.
An example attribute query be "standard::*,owner::user".
The standard attributes are available as defines, like
<see cref="FileAttribute.StandardName"/>.

If <paramref name="cancellable"/> is not <c>null</c>, then the operation can be cancelled
by triggering the cancellable object from another thread. If the
operation was cancelled, the error <see cref="IOErrorEnum.Cancelled"/> will be
returned.

For symlinks, normally the information about the target of the
symlink is returned, rather than information about the symlink
itself. However if you pass <see cref="FileQueryInfoFlags.NoFollowSymlinks"/>
in <paramref name="flags"/> the information about the symlink itself will be returned.
Also, for symlinks that point to non-existing files the information
about the symlink itself will be returned.

If the file does not exist, the <see cref="IOErrorEnum.NotFound"/> error will be
returned. Other errors are possible too, and depend on what kind of
filesystem the file is on.
</remarks>
<param name="attributes">
an attribute query string
</param>
<param name="flags">
a set of <see cref="FileQueryInfoFlags"/>
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
<returns>
a <see cref="FileInfo"/> for the given this instance, or <c>null</c>
    on error. Free the returned object with g_object_unref().
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='IFile.DoQueryInfoAsync(GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.Gio.FileQueryInfoFlags,System.Int32,GISharp.Lib.Gio.AsyncReadyCallback?,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Asynchronously gets the requested information about specified this instance.
The result is a <see cref="FileInfo"/> object that contains key-value attributes
(such as type or size for the file).
</summary>
<remarks>
For more details, see <see cref="File.QueryInfo(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.Gio.FileQueryInfoFlags,GISharp.Lib.Gio.Cancellable)"/> which is the synchronous
version of this call.
</remarks>
<param name="attributes">
an attribute query string
</param>
<param name="flags">
a set of <see cref="FileQueryInfoFlags"/>
</param>
<param name="ioPriority">
the [I/O priority][io-priority] of the request
</param>
<param name="callback">
a <see cref="AsyncReadyCallback"/> to call when the
    request is satisfied
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
</member>

<member name='IFile.DoQueryInfoFinish(GISharp.Lib.Gio.IAsyncResult)'>
<summary>
Finishes an asynchronous file info query.
See <see cref="File.QueryInfoAsync(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.Gio.FileQueryInfoFlags,System.Int32,GISharp.Lib.Gio.Cancellable)"/>.
</summary>
<param name="res">
a <see cref="IAsyncResult"/>
</param>
<returns>
<see cref="FileInfo"/> for given this instance
    or <c>null</c> on error. Free the returned object with
    g_object_unref().
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='IFile.DoQuerySettableAttributes(GISharp.Lib.Gio.Cancellable?)'>
<summary>
Obtain the list of settable attributes for the file.
</summary>
<remarks>
Returns the type and full attribute name of all the attributes
that can be set on this file. This doesn't mean setting it will
always succeed though, you might get an access failure, or some
specific file may not support a specific attribute.

If <paramref name="cancellable"/> is not <c>null</c>, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error <see cref="IOErrorEnum.Cancelled"/> will be returned.
</remarks>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
<returns>
a <see cref="FileAttributeInfoList"/> describing the settable attributes.
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='IFile.DoQueryWritableNamespaces(GISharp.Lib.Gio.Cancellable?)'>
<summary>
Obtain the list of attribute namespaces where new attributes
can be created by a user. An example of this is extended
attributes (in the "xattr" namespace).
</summary>
<remarks>
If <paramref name="cancellable"/> is not <c>null</c>, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error <see cref="IOErrorEnum.Cancelled"/> will be returned.
</remarks>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
<returns>
a <see cref="FileAttributeInfoList"/> describing the writable namespaces.
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='IFile.DoReadAsync(System.Int32,GISharp.Lib.Gio.AsyncReadyCallback?,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Asynchronously opens this instance for reading.
</summary>
<remarks>
For more details, see <see cref="File.Read(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.Cancellable)"/> which is
the synchronous version of this call.
</remarks>
<param name="ioPriority">
the [I/O priority][io-priority] of the request
</param>
<param name="callback">
a <see cref="AsyncReadyCallback"/> to call
    when the request is satisfied
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
</member>

<member name='IFile.DoReadFinish(GISharp.Lib.Gio.IAsyncResult)'>
<summary>
Finishes an asynchronous file read operation started with
<see cref="File.ReadAsync(GISharp.Lib.Gio.IFile,System.Int32,GISharp.Lib.Gio.Cancellable)"/>.
</summary>
<param name="res">
a <see cref="IAsyncResult"/>
</param>
<returns>
a <see cref="FileInputStream"/> or <c>null</c> on error.
    Free the returned object with g_object_unref().
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='IFile.DoReadFn(GISharp.Lib.Gio.Cancellable?)'>
<summary>
Opens a file for reading. The result is a <see cref="FileInputStream"/> that
can be used to read the contents of the file.
</summary>
<remarks>
If <paramref name="cancellable"/> is not <c>null</c>, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error <see cref="IOErrorEnum.Cancelled"/> will be returned.

If the file does not exist, the <see cref="IOErrorEnum.NotFound"/> error will be
returned. If the file is a directory, the <see cref="IOErrorEnum.IsDirectory"/>
error will be returned. Other errors are possible too, and depend
on what kind of filesystem the file is on.
</remarks>
<param name="cancellable">
a <see cref="Cancellable"/>
</param>
<returns>
<see cref="FileInputStream"/> or <c>null</c> on error.
    Free the returned object with g_object_unref().
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='IFile.DoReplace(GISharp.Lib.GLib.NullableUnownedUtf8,System.Boolean,GISharp.Lib.Gio.FileCreateFlags,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Returns an output stream for overwriting the file, possibly
creating a backup copy of the file first. If the file doesn't exist,
it will be created.
</summary>
<remarks>
This will try to replace the file in the safest way possible so
that any errors during the writing will not affect an already
existing copy of the file. For instance, for local files it
may write to a temporary file and then atomically rename over
the destination when the stream is closed.

By default files created are generally readable by everyone,
but if you pass <see cref="FileCreateFlags.Private"/> in <paramref name="flags"/> the file
will be made readable only to the current user, to the level that
is supported on the target filesystem.

If <paramref name="cancellable"/> is not <c>null</c>, then the operation can be cancelled
by triggering the cancellable object from another thread. If the
operation was cancelled, the error <see cref="IOErrorEnum.Cancelled"/> will be
returned.

If you pass in a non-<c>null</c> <paramref name="etag"/> value and this instance already exists, then
this value is compared to the current entity tag of the file, and if
they differ an <see cref="IOErrorEnum.WrongEtag"/> error is returned. This
generally means that the file has been changed since you last read
it. You can get the new etag from <see cref="FileOutputStream.GetEtag()"/>
after you've finished writing and closed the <see cref="FileOutputStream"/>. When
you load a new file you can use <see cref="FileInputStream.QueryInfo(GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.Gio.Cancellable)"/> to
get the etag of the file.

If <paramref name="makeBackup"/> is <c>true</c>, this function will attempt to make a
backup of the current file before overwriting it. If this fails
a <see cref="IOErrorEnum.CantCreateBackup"/> error will be returned. If you
want to replace anyway, try again with <paramref name="makeBackup"/> set to <c>false</c>.

If the file is a directory the <see cref="IOErrorEnum.IsDirectory"/> error will
be returned, and if the file is some other form of non-regular file
then a <see cref="IOErrorEnum.NotRegularFile"/> error will be returned. Some
file systems don't allow all file names, and may return an
<see cref="IOErrorEnum.InvalidFilename"/> error, and if the name is to long
<see cref="IOErrorEnum.FilenameTooLong"/> will be returned. Other errors are
possible too, and depend on what kind of filesystem the file is on.
</remarks>
<param name="etag">
an optional [entity tag][gfile-etag]
    for the current <see cref="IFile"/>, or #NULL to ignore
</param>
<param name="makeBackup">
<c>true</c> if a backup should be created
</param>
<param name="flags">
a set of <see cref="FileCreateFlags"/>
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
<returns>
a <see cref="FileOutputStream"/> or <c>null</c> on error.
    Free the returned object with g_object_unref().
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='IFile.DoReplaceAsync(GISharp.Lib.GLib.NullableUnownedUtf8,System.Boolean,GISharp.Lib.Gio.FileCreateFlags,System.Int32,GISharp.Lib.Gio.AsyncReadyCallback?,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Asynchronously overwrites the file, replacing the contents,
possibly creating a backup copy of the file first.
</summary>
<remarks>
For more details, see <see cref="File.Replace(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.NullableUnownedUtf8,System.Boolean,GISharp.Lib.Gio.FileCreateFlags,GISharp.Lib.Gio.Cancellable)"/> which is
the synchronous version of this call.
</remarks>
<param name="etag">
an [entity tag][gfile-etag] for the current <see cref="IFile"/>,
    or <c>null</c> to ignore
</param>
<param name="makeBackup">
<c>true</c> if a backup should be created
</param>
<param name="flags">
a set of <see cref="FileCreateFlags"/>
</param>
<param name="ioPriority">
the [I/O priority][io-priority] of the request
</param>
<param name="callback">
a <see cref="AsyncReadyCallback"/> to call
    when the request is satisfied
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
</member>

<member name='IFile.DoReplaceFinish(GISharp.Lib.Gio.IAsyncResult)'>
<summary>
Finishes an asynchronous file replace operation started with
<see cref="File.ReplaceAsync(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.NullableUnownedUtf8,System.Boolean,GISharp.Lib.Gio.FileCreateFlags,System.Int32,GISharp.Lib.Gio.Cancellable)"/>.
</summary>
<param name="res">
a <see cref="IAsyncResult"/>
</param>
<returns>
a <see cref="FileOutputStream"/>, or <c>null</c> on error.
    Free the returned object with g_object_unref().
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='IFile.DoReplaceReadwrite(GISharp.Lib.GLib.NullableUnownedUtf8,System.Boolean,GISharp.Lib.Gio.FileCreateFlags,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Returns an output stream for overwriting the file in readwrite mode,
possibly creating a backup copy of the file first. If the file doesn't
exist, it will be created.
</summary>
<remarks>
For details about the behaviour, see <see cref="File.Replace(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.NullableUnownedUtf8,System.Boolean,GISharp.Lib.Gio.FileCreateFlags,GISharp.Lib.Gio.Cancellable)"/> which does the
same thing but returns an output stream only.

Note that in many non-local file cases read and write streams are not
supported, so make sure you really need to do read and write streaming,
rather than just opening for reading or writing.
</remarks>
<param name="etag">
an optional [entity tag][gfile-etag]
    for the current <see cref="IFile"/>, or #NULL to ignore
</param>
<param name="makeBackup">
<c>true</c> if a backup should be created
</param>
<param name="flags">
a set of <see cref="FileCreateFlags"/>
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
<returns>
a <see cref="FileIOStream"/> or <c>null</c> on error.
    Free the returned object with g_object_unref().
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='IFile.DoReplaceReadwriteAsync(GISharp.Lib.GLib.NullableUnownedUtf8,System.Boolean,GISharp.Lib.Gio.FileCreateFlags,System.Int32,GISharp.Lib.Gio.AsyncReadyCallback?,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Asynchronously overwrites the file in read-write mode,
replacing the contents, possibly creating a backup copy
of the file first.
</summary>
<remarks>
For more details, see <see cref="File.ReplaceReadwrite(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.NullableUnownedUtf8,System.Boolean,GISharp.Lib.Gio.FileCreateFlags,GISharp.Lib.Gio.Cancellable)"/> which is
the synchronous version of this call.
</remarks>
<param name="etag">
an [entity tag][gfile-etag] for the current <see cref="IFile"/>,
    or <c>null</c> to ignore
</param>
<param name="makeBackup">
<c>true</c> if a backup should be created
</param>
<param name="flags">
a set of <see cref="FileCreateFlags"/>
</param>
<param name="ioPriority">
the [I/O priority][io-priority] of the request
</param>
<param name="callback">
a <see cref="AsyncReadyCallback"/> to call
    when the request is satisfied
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
</member>

<member name='IFile.DoReplaceReadwriteFinish(GISharp.Lib.Gio.IAsyncResult)'>
<summary>
Finishes an asynchronous file replace operation started with
<see cref="File.ReplaceReadwriteAsync(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.NullableUnownedUtf8,System.Boolean,GISharp.Lib.Gio.FileCreateFlags,System.Int32,GISharp.Lib.Gio.Cancellable)"/>.
</summary>
<param name="res">
a <see cref="IAsyncResult"/>
</param>
<returns>
a <see cref="FileIOStream"/>, or <c>null</c> on error.
    Free the returned object with g_object_unref().
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='IFile.DoResolveRelativePath(GISharp.Lib.GLib.Filename)'>
<summary>
Resolves a relative path for this instance to an absolute path.
</summary>
<remarks>
This call does no blocking I/O.
</remarks>
<param name="relativePath">
a given relative path string
</param>
<returns>
<see cref="IFile"/> to the resolved path.
    <c>null</c> if <paramref name="relativePath"/> is <c>null</c> or if this instance is invalid.
    Free the returned object with g_object_unref().
</returns>
</member>

<member name='IFile.DoSetAttribute(GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.Gio.FileAttributeType,System.IntPtr,GISharp.Lib.Gio.FileQueryInfoFlags,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Sets an attribute in the file with attribute name <paramref name="attribute"/> to <paramref name="valueP"/>.
</summary>
<remarks>
Some attributes can be unset by setting <paramref name="type"/> to
<see cref="FileAttributeType.Invalid"/> and <paramref name="valueP"/> to <c>null</c>.

If <paramref name="cancellable"/> is not <c>null</c>, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error <see cref="IOErrorEnum.Cancelled"/> will be returned.
</remarks>
<param name="attribute">
a string containing the attribute's name
</param>
<param name="type">
The type of the attribute
</param>
<param name="valueP">
a pointer to the value (or the pointer
    itself if the type is a pointer type)
</param>
<param name="flags">
a set of <see cref="FileQueryInfoFlags"/>
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
<returns>
<c>true</c> if the attribute was set, <c>false</c> otherwise.
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='IFile.DoSetAttributesAsync(GISharp.Lib.Gio.FileInfo,GISharp.Lib.Gio.FileQueryInfoFlags,System.Int32,GISharp.Lib.Gio.AsyncReadyCallback?,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Asynchronously sets the attributes of this instance with <paramref name="info"/>.
</summary>
<remarks>
For more details, see <see cref="File.SetAttributesFromInfo(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.FileInfo,GISharp.Lib.Gio.FileQueryInfoFlags,GISharp.Lib.Gio.Cancellable)"/>,
which is the synchronous version of this call.
</remarks>
<param name="info">
a <see cref="FileInfo"/>
</param>
<param name="flags">
a <see cref="FileQueryInfoFlags"/>
</param>
<param name="ioPriority">
the [I/O priority][io-priority] of the request
</param>
<param name="callback">
a <see cref="AsyncReadyCallback"/>
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
</member>

<member name='IFile.DoSetAttributesFinish(GISharp.Lib.Gio.IAsyncResult,GISharp.Lib.Gio.FileInfo)'>
<summary>
Finishes setting an attribute started in <see cref="File.SetAttributesAsync(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.FileInfo,GISharp.Lib.Gio.FileQueryInfoFlags,System.Int32,GISharp.Lib.Gio.Cancellable)"/>.
</summary>
<param name="result">
a <see cref="IAsyncResult"/>
</param>
<param name="info">
a <see cref="FileInfo"/>
</param>
<returns>
<c>true</c> if the attributes were set correctly, <c>false</c> otherwise.
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='IFile.DoSetAttributesFromInfo(GISharp.Lib.Gio.FileInfo,GISharp.Lib.Gio.FileQueryInfoFlags,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Tries to set all attributes in the <see cref="FileInfo"/> on the target
values, not stopping on the first error.
</summary>
<remarks>
If there is any error during this operation then <see cref="GISharp.Runtime.GErrorException"/> will
be set to the first error. Error on particular fields are flagged
by setting the "status" field in the attribute value to
<see cref="FileAttributeStatus.ErrorSetting"/>, which means you can
also detect further errors.

If <paramref name="cancellable"/> is not <c>null</c>, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error <see cref="IOErrorEnum.Cancelled"/> will be returned.
</remarks>
<param name="info">
a <see cref="FileInfo"/>
</param>
<param name="flags">
<see cref="FileQueryInfoFlags"/>
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
<returns>
<c>false</c> if there was any error, <c>true</c> otherwise.
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='IFile.DoSetDisplayName(GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Renames this instance to the specified display name.
</summary>
<remarks>
The display name is converted from UTF-8 to the correct encoding
for the target filesystem if possible and the this instance is renamed to this.

If you want to implement a rename operation in the user interface the
edit name (<see cref="FileAttribute.StandardEditName"/>) should be used as the
initial value in the rename widget, and then the result after editing
should be passed to <see cref="File.SetDisplayName(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.Gio.Cancellable)"/>.

On success the resulting converted filename is returned.

If <paramref name="cancellable"/> is not <c>null</c>, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error <see cref="IOErrorEnum.Cancelled"/> will be returned.
</remarks>
<param name="displayName">
a string
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
<returns>
a <see cref="IFile"/> specifying what this instance was renamed to,
    or <c>null</c> if there was an error.
    Free the returned object with g_object_unref().
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='IFile.DoSetDisplayNameAsync(GISharp.Lib.GLib.UnownedUtf8,System.Int32,GISharp.Lib.Gio.AsyncReadyCallback?,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Asynchronously sets the display name for a given <see cref="IFile"/>.
</summary>
<remarks>
For more details, see <see cref="File.SetDisplayName(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.Gio.Cancellable)"/> which is
the synchronous version of this call.
</remarks>
<param name="displayName">
a string
</param>
<param name="ioPriority">
the [I/O priority][io-priority] of the request
</param>
<param name="callback">
a <see cref="AsyncReadyCallback"/> to call
    when the request is satisfied
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
</member>

<member name='IFile.DoSetDisplayNameFinish(GISharp.Lib.Gio.IAsyncResult)'>
<summary>
Finishes setting a display name started with
<see cref="File.SetDisplayNameAsync(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.UnownedUtf8,System.Int32,GISharp.Lib.Gio.Cancellable)"/>.
</summary>
<param name="res">
a <see cref="IAsyncResult"/>
</param>
<returns>
a <see cref="IFile"/> or <c>null</c> on error.
    Free the returned object with g_object_unref().
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='IFile.DoStartMountableFinish(GISharp.Lib.Gio.IAsyncResult)'>
<summary>
Finishes a start operation. See g_file_start_mountable() for details.
</summary>
<remarks>
Finish an asynchronous start operation that was started
with g_file_start_mountable().
</remarks>
<param name="result">
a <see cref="IAsyncResult"/>
</param>
<returns>
<c>true</c> if the operation finished successfully. <c>false</c>
otherwise.
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='IFile.DoStopMountableFinish(GISharp.Lib.Gio.IAsyncResult)'>
<summary>
Finishes a stop operation, see g_file_stop_mountable() for details.
</summary>
<remarks>
Finish an asynchronous stop operation that was started
with g_file_stop_mountable().
</remarks>
<param name="result">
a <see cref="IAsyncResult"/>
</param>
<returns>
<c>true</c> if the operation finished successfully.
    <c>false</c> otherwise.
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='IFile.DoTrash(GISharp.Lib.Gio.Cancellable?)'>
<summary>
Sends this instance to the "Trashcan", if possible. This is similar to
deleting it, but the user can recover it before emptying the trashcan.
Not all file systems support trashing, so this call can return the
<see cref="IOErrorEnum.NotSupported"/> error. Since GLib 2.66, the `x-gvfs-notrash` unix
mount option can be used to disable <see cref="File.Trash(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.Cancellable)"/> support for certain
mounts, the <see cref="IOErrorEnum.NotSupported"/> error will be returned in that case.
</summary>
<remarks>
If <paramref name="cancellable"/> is not <c>null</c>, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error <see cref="IOErrorEnum.Cancelled"/> will be returned.
</remarks>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
<returns>
<c>true</c> on successful trash, <c>false</c> otherwise.
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='IFile.DoTrashAsync(System.Int32,GISharp.Lib.Gio.AsyncReadyCallback?,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Asynchronously sends this instance to the Trash location, if possible.
</summary>
<param name="ioPriority">
the [I/O priority][io-priority] of the request
</param>
<param name="callback">
a <see cref="AsyncReadyCallback"/> to call
    when the request is satisfied
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
</member>

<member name='IFile.DoTrashFinish(GISharp.Lib.Gio.IAsyncResult)'>
<summary>
Finishes an asynchronous file trashing operation, started with
<see cref="File.TrashAsync(GISharp.Lib.Gio.IFile,System.Int32,GISharp.Lib.Gio.Cancellable)"/>.
</summary>
<param name="result">
a <see cref="IAsyncResult"/>
</param>
<returns>
<c>true</c> on successful trash, <c>false</c> otherwise.
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='IFile.DoUnmountMountableFinish(GISharp.Lib.Gio.IAsyncResult)'>
<summary>
Finishes an unmount operation, see g_file_unmount_mountable() for details.
</summary>
<remarks>
Finish an asynchronous unmount operation that was started
with g_file_unmount_mountable().
</remarks>
<param name="result">
a <see cref="IAsyncResult"/>
</param>
<returns>
<c>true</c> if the operation finished successfully.
    <c>false</c> otherwise.
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='IFile.DoUnmountMountableWithOperationFinish(GISharp.Lib.Gio.IAsyncResult)'>
<summary>
Finishes an unmount operation,
see g_file_unmount_mountable_with_operation() for details.
</summary>
<remarks>
Finish an asynchronous unmount operation that was started
with g_file_unmount_mountable_with_operation().
</remarks>
<param name="result">
a <see cref="IAsyncResult"/>
</param>
<returns>
<c>true</c> if the operation finished successfully.
    <c>false</c> otherwise.
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='IFile'>
<summary>
<see cref="IFile"/> is a high level abstraction for manipulating files on a
virtual file system. <see cref="IFile"/>s are lightweight, immutable objects
that do no I/O upon creation. It is necessary to understand that
<see cref="IFile"/> objects do not represent files, merely an identifier for a
file. All file content I/O is implemented as streaming operations
(see <see cref="InputStream"/> and <see cref="OutputStream"/>).
</summary>
<remarks>
To construct a <see cref="IFile"/>, you can use:
- <see cref="IFile.NewForPath(GISharp.Lib.GLib.Filename)"/> if you have a path.
- <see cref="IFile.NewForUri(GISharp.Lib.GLib.UnownedUtf8)"/> if you have a URI.
- <see cref="IFile.NewForCommandlineArg(GISharp.Lib.GLib.Filename)"/> for a command line argument.
- <see cref="IFile.NewTmp(GISharp.Lib.GLib.Filename,out GISharp.Lib.Gio.FileIOStream)"/> to create a temporary file from a template.
- <see cref="IFile.ParseName(GISharp.Lib.GLib.UnownedUtf8)"/> from a UTF-8 string gotten from <see cref="File.GetParseName(GISharp.Lib.Gio.IFile)"/>.
- g_file_new_build_filename() to create a file from path elements.

One way to think of a <see cref="IFile"/> is as an abstraction of a pathname. For
normal files the system pathname is what is stored internally, but as
<see cref="IFile"/>s are extensible it could also be something else that corresponds
to a pathname in a userspace implementation of a filesystem.

<see cref="IFile"/>s make up hierarchies of directories and files that correspond to
the files on a filesystem. You can move through the file system with
<see cref="IFile"/> using <see cref="File.GetParent(GISharp.Lib.Gio.IFile)"/> to get an identifier for the parent
directory, <see cref="File.GetChild(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.Filename)"/> to get a child within a directory,
<see cref="File.ResolveRelativePath(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.Filename)"/> to resolve a relative path between two
<see cref="IFile"/>s. There can be multiple hierarchies, so you may not end up at
the same root if you repeatedly call <see cref="File.GetParent(GISharp.Lib.Gio.IFile)"/> on two different
files.

All <see cref="IFile"/>s have a basename (get with <see cref="File.GetBasename(GISharp.Lib.Gio.IFile)"/>). These names
are byte strings that are used to identify the file on the filesystem
(relative to its parent directory) and there is no guarantees that they
have any particular charset encoding or even make any sense at all. If
you want to use filenames in a user interface you should use the display
name that you can get by requesting the
<see cref="FileAttribute.StandardDisplayName"/> attribute with
<see cref="File.QueryInfo(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.Gio.FileQueryInfoFlags,GISharp.Lib.Gio.Cancellable)"/>.
This is guaranteed to be in UTF-8 and can be used in a user interface.
But always store the real basename or the <see cref="IFile"/> to use to actually
access the file, because there is no way to go from a display name to
the actual name.

Using <see cref="IFile"/> as an identifier has the same weaknesses as using a path
in that there may be multiple aliases for the same file. For instance,
hard or soft links may cause two different <see cref="IFile"/>s to refer to the same
file. Other possible causes for aliases are: case insensitive filesystems,
short and long names on FAT/NTFS, or bind mounts in Linux. If you want to
check if two <see cref="IFile"/>s point to the same file you can query for the
%G_FILE_ATTRIBUTE_ID_FILE attribute. Note that <see cref="IFile"/> does some trivial
canonicalization of pathnames passed in, so that trivial differences in
the path string used at creation (duplicated slashes, slash at end of
path, "." or ".." path segments, etc) does not create different <see cref="IFile"/>s.

Many <see cref="IFile"/> operations have both synchronous and asynchronous versions
to suit your application. Asynchronous versions of synchronous functions
simply have _async() appended to their function names. The asynchronous
I/O functions call a <see cref="AsyncReadyCallback"/> which is then used to finalize
the operation, producing a GAsyncResult which is then passed to the
function's matching _finish() operation.

It is highly recommended to use asynchronous calls when running within a
shared main loop, such as in the main thread of an application. This avoids
I/O operations blocking other sources on the main loop from being dispatched.
Synchronous I/O operations should be performed from worker threads. See the
[introduction to asynchronous programming section][async-programming] for
more.

Some <see cref="IFile"/> operations almost always take a noticeable amount of time, and
so do not have synchronous analogs. Notable cases include:
- g_file_mount_mountable() to mount a mountable file.
- g_file_unmount_mountable_with_operation() to unmount a mountable file.
- g_file_eject_mountable_with_operation() to eject a mountable file.

## Entity Tags # {#gfile-etag}

One notable feature of <see cref="IFile"/>s are entity tags, or "etags" for
short. Entity tags are somewhat like a more abstract version of the
traditional mtime, and can be used to quickly determine if the file
has been modified from the version on the file system. See the
HTTP 1.1
[specification](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html)
for HTTP Etag headers, which are a very similar concept.
</remarks>
</member>

<member name='File.AppendTo(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.FileCreateFlags,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Gets an output stream for appending data to the file.
If the file doesn't already exist it is created.
</summary>
<remarks>
By default files created are generally readable by everyone,
but if you pass <see cref="FileCreateFlags.Private"/> in <paramref name="flags"/> the file
will be made readable only to the current user, to the level that
is supported on the target filesystem.

If <paramref name="cancellable"/> is not <c>null</c>, then the operation can be cancelled
by triggering the cancellable object from another thread. If the
operation was cancelled, the error <see cref="IOErrorEnum.Cancelled"/> will be
returned.

Some file systems don't allow all file names, and may return an
<see cref="IOErrorEnum.InvalidFilename"/> error. If the file is a directory the
<see cref="IOErrorEnum.IsDirectory"/> error will be returned. Other errors are
possible too, and depend on what kind of filesystem the file is on.
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="flags">
a set of <see cref="FileCreateFlags"/>
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
<returns>
a <see cref="FileOutputStream"/>, or <c>null</c> on error.
    Free the returned object with g_object_unref().
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='File.AppendToAsync(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.FileCreateFlags,System.Int32,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Asynchronously opens <paramref name="file"/> for appending.
</summary>
<remarks>
For more details, see <see cref="File.AppendTo(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.FileCreateFlags,GISharp.Lib.Gio.Cancellable)"/> which is
the synchronous version of this call.
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="flags">
a set of <see cref="FileCreateFlags"/>
</param>
<param name="ioPriority">
the [I/O priority][io-priority] of the request
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
</member>

<member name='File.Copy(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.FileCopyFlags,GISharp.Lib.Gio.FileProgressCallback?,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Copies the file <paramref name="source"/> to the location specified by <paramref name="destination"/>.
Can not handle recursive copies of directories.
</summary>
<remarks>
If the flag <see cref="FileCopyFlags.Overwrite"/> is specified an already
existing <paramref name="destination"/> file is overwritten.

If the flag <see cref="FileCopyFlags.NoFollowSymlinks"/> is specified then symlinks
will be copied as symlinks, otherwise the target of the
<paramref name="source"/> symlink will be copied.

If the flag <see cref="FileCopyFlags.AllMetadata"/> is specified then all the metadata
that is possible to copy is copied, not just the default subset (which,
for instance, does not include the owner, see <see cref="FileInfo"/>).

If <paramref name="cancellable"/> is not <c>null</c>, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error <see cref="IOErrorEnum.Cancelled"/> will be returned.

If <paramref name="progressCallback"/> is not <c>null</c>, then the operation can be monitored
by setting this to a <see cref="FileProgressCallback"/> function.
It is guaranteed
that this callback will be called after all data has been transferred with
the total number of bytes copied during the operation.

If the <paramref name="source"/> file does not exist, then the <see cref="IOErrorEnum.NotFound"/> error
is returned, independent on the status of the <paramref name="destination"/>.

If <see cref="FileCopyFlags.Overwrite"/> is not specified and the target exists, then
the error <see cref="IOErrorEnum.Exists"/> is returned.

If trying to overwrite a file over a directory, the <see cref="IOErrorEnum.IsDirectory"/>
error is returned. If trying to overwrite a directory with a directory the
<see cref="IOErrorEnum.WouldMerge"/> error is returned.

If the source is a directory and the target does not exist, or
<see cref="FileCopyFlags.Overwrite"/> is specified and the target is a file, then the
<see cref="IOErrorEnum.WouldRecurse"/> error is returned.

If you are interested in copying the <see cref="IFile"/> object itself (not the on-disk
file), see <see cref="File.Dup(GISharp.Lib.Gio.IFile)"/>.
</remarks>
<param name="source">
input <see cref="IFile"/>
</param>
<param name="destination">
destination <see cref="IFile"/>
</param>
<param name="flags">
set of <see cref="FileCopyFlags"/>
</param>
<param name="progressCallback">
function to callback with
    progress information, or <c>null</c> if progress information is not needed
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='File.CopyAttributes(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.FileCopyFlags,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Copies the file attributes from <paramref name="source"/> to <paramref name="destination"/>.
</summary>
<remarks>
Normally only a subset of the file attributes are copied,
those that are copies in a normal file copy operation
(which for instance does not include e.g. owner). However
if <see cref="FileCopyFlags.AllMetadata"/> is specified in <paramref name="flags"/>, then
all the metadata that is possible to copy is copied. This
is useful when implementing move by copy + delete source.
</remarks>
<param name="source">
a <see cref="IFile"/> with attributes
</param>
<param name="destination">
a <see cref="IFile"/> to copy attributes to
</param>
<param name="flags">
a set of <see cref="FileCopyFlags"/>
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='File.Create(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.FileCreateFlags,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Creates a new file and returns an output stream for writing to it.
The file must not already exist.
</summary>
<remarks>
By default files created are generally readable by everyone,
but if you pass <see cref="FileCreateFlags.Private"/> in <paramref name="flags"/> the file
will be made readable only to the current user, to the level
that is supported on the target filesystem.

If <paramref name="cancellable"/> is not <c>null</c>, then the operation can be cancelled
by triggering the cancellable object from another thread. If the
operation was cancelled, the error <see cref="IOErrorEnum.Cancelled"/> will be
returned.

If a file or directory with this name already exists the
<see cref="IOErrorEnum.Exists"/> error will be returned. Some file systems don't
allow all file names, and may return an <see cref="IOErrorEnum.InvalidFilename"/>
error, and if the name is to long <see cref="IOErrorEnum.FilenameTooLong"/> will
be returned. Other errors are possible too, and depend on what kind
of filesystem the file is on.
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="flags">
a set of <see cref="FileCreateFlags"/>
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
<returns>
a <see cref="FileOutputStream"/> for the newly created
    file, or <c>null</c> on error.
    Free the returned object with g_object_unref().
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='File.CreateAsync(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.FileCreateFlags,System.Int32,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Asynchronously creates a new file and returns an output stream
for writing to it. The file must not already exist.
</summary>
<remarks>
For more details, see <see cref="File.Create(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.FileCreateFlags,GISharp.Lib.Gio.Cancellable)"/> which is
the synchronous version of this call.
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="flags">
a set of <see cref="FileCreateFlags"/>
</param>
<param name="ioPriority">
the [I/O priority][io-priority] of the request
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
</member>

<member name='File.CreateReadwrite(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.FileCreateFlags,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Creates a new file and returns a stream for reading and
writing to it. The file must not already exist.
</summary>
<remarks>
By default files created are generally readable by everyone,
but if you pass <see cref="FileCreateFlags.Private"/> in <paramref name="flags"/> the file
will be made readable only to the current user, to the level
that is supported on the target filesystem.

If <paramref name="cancellable"/> is not <c>null</c>, then the operation can be cancelled
by triggering the cancellable object from another thread. If the
operation was cancelled, the error <see cref="IOErrorEnum.Cancelled"/> will be
returned.

If a file or directory with this name already exists, the
<see cref="IOErrorEnum.Exists"/> error will be returned. Some file systems don't
allow all file names, and may return an <see cref="IOErrorEnum.InvalidFilename"/>
error, and if the name is too long, <see cref="IOErrorEnum.FilenameTooLong"/>
will be returned. Other errors are possible too, and depend on what
kind of filesystem the file is on.

Note that in many non-local file cases read and write streams are
not supported, so make sure you really need to do read and write
streaming, rather than just opening for reading or writing.
</remarks>
<param name="file">
a <see cref="IFile"/>
</param>
<param name="flags">
a set of <see cref="FileCreateFlags"/>
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
<returns>
a <see cref="FileIOStream"/> for the newly created
    file, or <c>null</c> on error.
    Free the returned object with g_object_unref().
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='File.CreateReadwriteAsync(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.FileCreateFlags,System.Int32,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Asynchronously creates a new file and returns a stream
for reading and writing to it. The file must not already exist.
</summary>
<remarks>
For more details, see <see cref="File.CreateReadwrite(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.FileCreateFlags,GISharp.Lib.Gio.Cancellable)"/> which is
the synchronous version of this call.
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="flags">
a set of <see cref="FileCreateFlags"/>
</param>
<param name="ioPriority">
the [I/O priority][io-priority] of the request
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
</member>

<member name='File.Delete(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Deletes a file. If the <paramref name="file"/> is a directory, it will only be
deleted if it is empty. This has the same semantics as g_unlink().
</summary>
<remarks>
If <paramref name="file"/> doesn’t exist, <see cref="IOErrorEnum.NotFound"/> will be returned. This allows
for deletion to be implemented avoiding
[time-of-check to time-of-use races](https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use):
|[
g_autoptr(GError) local_error = NULL;
if (!g_file_delete (my_file, my_cancellable, &amp;local_error) &amp;&amp;
    !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))
  {
    // deletion failed for some reason other than the file not existing:
    // so report the error
    g_warning ("Failed to delete %s: %s",
               g_file_peek_path (my_file), local_error-&gt;message);
  }
]|

If <paramref name="cancellable"/> is not <c>null</c>, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error <see cref="IOErrorEnum.Cancelled"/> will be returned.
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='File.DeleteAsync(GISharp.Lib.Gio.IFile,System.Int32,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Asynchronously delete a file. If the <paramref name="file"/> is a directory, it will
only be deleted if it is empty.  This has the same semantics as
g_unlink().
</summary>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="ioPriority">
the [I/O priority][io-priority] of the request
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
</member>

<member name='File.Dup(GISharp.Lib.Gio.IFile)'>
<summary>
Duplicates a <see cref="IFile"/> handle. This operation does not duplicate
the actual file or directory represented by the <see cref="IFile"/>; see
<see cref="File.Copy(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.FileCopyFlags,GISharp.Lib.Gio.FileProgressCallback,GISharp.Lib.Gio.Cancellable)"/> if attempting to copy a file.
</summary>
<remarks>
<see cref="File.Dup(GISharp.Lib.Gio.IFile)"/> is useful when a second handle is needed to the same underlying
file, for use in a separate thread (<see cref="IFile"/> is not thread-safe). For use
within the same thread, use g_object_ref() to increment the existing object’s
reference count.

This call does no blocking I/O.
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<returns>
a new <see cref="IFile"/> that is a duplicate
    of the given <see cref="IFile"/>.
</returns>
</member>

<member name='File.EjectMountableFinish(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.IAsyncResult)'>
<summary>
Finishes an asynchronous eject operation started by
g_file_eject_mountable().
</summary>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="result">
a <see cref="IAsyncResult"/>
</param>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='File.EjectMountableWithOperationFinish(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.IAsyncResult)'>
<summary>
Finishes an asynchronous eject operation started by
g_file_eject_mountable_with_operation().
</summary>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="result">
a <see cref="IAsyncResult"/>
</param>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='File.Equals(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.IFile)'>
<summary>
Checks if the two given #GFiles refer to the same file.
</summary>
<remarks>
Note that two #GFiles that differ can still refer to the same
file on the filesystem due to various forms of filename
aliasing.

This call does no blocking I/O.
</remarks>
<param name="file1">
the first <see cref="IFile"/>
</param>
<param name="file2">
the second <see cref="IFile"/>
</param>
<returns>
<c>true</c> if <paramref name="file1"/> and <paramref name="file2"/> are equal.
</returns>
</member>

<member name='File.GetBasename(GISharp.Lib.Gio.IFile)'>
<summary>
Gets the base name (the last component of the path) for a given <see cref="IFile"/>.
</summary>
<remarks>
If called for the top level of a system (such as the filesystem root
or a uri like sftp://host/) it will return a single directory separator
(and on Windows, possibly a drive letter).

The base name is a byte string (not UTF-8). It has no defined encoding
or rules other than it may not contain zero bytes.  If you want to use
filenames in a user interface you should use the display name that you
can get by requesting the <see cref="FileAttribute.StandardDisplayName"/>
attribute with <see cref="File.QueryInfo(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.Gio.FileQueryInfoFlags,GISharp.Lib.Gio.Cancellable)"/>.

This call does no blocking I/O.
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<returns>
string containing the <see cref="IFile"/>'s
    base name, or <c>null</c> if given <see cref="IFile"/> is invalid. The returned string
    should be freed with g_free() when no longer needed.
</returns>
</member>

<member name='File.GetChild(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.Filename)'>
<summary>
Gets a child of <paramref name="file"/> with basename equal to <paramref name="name"/>.
</summary>
<remarks>
Note that the file with that specific name might not exist, but
you can still have a <see cref="IFile"/> that points to it. You can use this
for instance to create that file.

This call does no blocking I/O.
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="name">
string containing the child's basename
</param>
<returns>
a <see cref="IFile"/> to a child specified by <paramref name="name"/>.
    Free the returned object with g_object_unref().
</returns>
</member>

<member name='File.GetChildForDisplayName(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.UnownedUtf8)'>
<summary>
Gets the child of <paramref name="file"/> for a given <paramref name="displayName"/> (i.e. a UTF-8
version of the name). If this function fails, it returns <c>null</c>
and <see cref="GISharp.Runtime.GErrorException"/> will be set. This is very useful when constructing a
<see cref="IFile"/> for a new file and the user entered the filename in the
user interface, for instance when you select a directory and
type a filename in the file selector.
</summary>
<remarks>
This call does no blocking I/O.
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="displayName">
string to a possible child
</param>
<returns>
a <see cref="IFile"/> to the specified child, or
    <c>null</c> if the display name couldn't be converted.
    Free the returned object with g_object_unref().
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='File.GetParent(GISharp.Lib.Gio.IFile)'>
<summary>
Gets the parent directory for the <paramref name="file"/>.
If the <paramref name="file"/> represents the root directory of the
file system, then <c>null</c> will be returned.
</summary>
<remarks>
This call does no blocking I/O.
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<returns>
a <see cref="IFile"/> structure to the
    parent of the given <see cref="IFile"/> or <c>null</c> if there is no parent. Free
    the returned object with g_object_unref().
</returns>
</member>

<member name='File.GetParseName(GISharp.Lib.Gio.IFile)'>
<summary>
Gets the parse name of the <paramref name="file"/>.
A parse name is a UTF-8 string that describes the
file such that one can get the <see cref="IFile"/> back using
<see cref="IFile.ParseName(GISharp.Lib.GLib.UnownedUtf8)"/>.
</summary>
<remarks>
This is generally used to show the <see cref="IFile"/> as a nice
full-pathname kind of string in a user interface,
like in a location entry.

For local files with names that can safely be converted
to UTF-8 the pathname is used, otherwise the IRI is used
(a form of URI that allows UTF-8 characters unescaped).

This call does no blocking I/O.
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<returns>
a string containing the <see cref="IFile"/>'s parse name.
    The returned string should be freed with g_free()
    when no longer needed.
</returns>
</member>

<member name='File.GetPath(GISharp.Lib.Gio.IFile)'>
<summary>
Gets the local pathname for <see cref="IFile"/>, if one exists. If non-<c>null</c>, this is
guaranteed to be an absolute, canonical path. It might contain symlinks.
</summary>
<remarks>
This call does no blocking I/O.
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<returns>
string containing the <see cref="IFile"/>'s path,
    or <c>null</c> if no such path exists. The returned string should be freed
    with g_free() when no longer needed.
</returns>
</member>

<member name='File.GetRelativePath(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.IFile)'>
<summary>
Gets the path for <paramref name="descendant"/> relative to <paramref name="parent"/>.
</summary>
<remarks>
This call does no blocking I/O.
</remarks>
<param name="parent">
input <see cref="IFile"/>
</param>
<param name="descendant">
input <see cref="IFile"/>
</param>
<returns>
string with the relative path from
    <paramref name="descendant"/> to <paramref name="parent"/>, or <c>null</c> if <paramref name="descendant"/> doesn't have <paramref name="parent"/> as
    prefix. The returned string should be freed with g_free() when
    no longer needed.
</returns>
</member>

<member name='File.GetUri(GISharp.Lib.Gio.IFile)'>
<summary>
Gets the URI for the <paramref name="file"/>.
</summary>
<remarks>
This call does no blocking I/O.
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<returns>
a string containing the <see cref="IFile"/>'s URI.
    The returned string should be freed with g_free()
    when no longer needed.
</returns>
</member>

<member name='File.GetUriScheme(GISharp.Lib.Gio.IFile)'>
<summary>
Gets the URI scheme for a <see cref="IFile"/>.
RFC 3986 decodes the scheme as:
|[
URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
]|
Common schemes include "file", "http", "ftp", etc.
</summary>
<remarks>
This call does no blocking I/O.
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<returns>
a string containing the URI scheme for the given
    <see cref="IFile"/>. The returned string should be freed with g_free()
    when no longer needed.
</returns>
</member>

<member name='File.HasParent(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.IFile?)'>
<summary>
Checks if <paramref name="file"/> has a parent, and optionally, if it is <paramref name="parent"/>.
</summary>
<remarks>
If <paramref name="parent"/> is <c>null</c> then this function returns <c>true</c> if <paramref name="file"/> has any
parent at all.  If <paramref name="parent"/> is non-<c>null</c> then <c>true</c> is only returned
if <paramref name="file"/> is an immediate child of <paramref name="parent"/>.
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="parent">
the parent to check for, or <c>null</c>
</param>
<returns>
<c>true</c> if <paramref name="file"/> is an immediate child of <paramref name="parent"/> (or any parent in
         the case that <paramref name="parent"/> is <c>null</c>).
</returns>
</member>

<member name='File.HasPrefix(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.IFile)'>
<summary>
Checks whether <paramref name="file"/> has the prefix specified by <paramref name="prefix"/>.
</summary>
<remarks>
In other words, if the names of initial elements of <paramref name="file"/>'s
pathname match <paramref name="prefix"/>. Only full pathname elements are matched,
so a path like /foo is not considered a prefix of /foobar, only
of /foo/bar.

A <see cref="IFile"/> is not a prefix of itself. If you want to check for
equality, use <see cref="File.Equals(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.IFile)"/>.

This call does no I/O, as it works purely on names. As such it can
sometimes return <c>false</c> even if <paramref name="file"/> is inside a <paramref name="prefix"/> (from a
filesystem point of view), because the prefix of <paramref name="file"/> is an alias
of <paramref name="prefix"/>.
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="prefix">
input <see cref="IFile"/>
</param>
<returns>
<c>true</c> if the <paramref name="file"/>'s parent, grandparent, etc is <paramref name="prefix"/>,
    <c>false</c> otherwise.
</returns>
</member>

<member name='File.HasUriScheme(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.UnownedUtf8)'>
<summary>
Checks to see if a <see cref="IFile"/> has a given URI scheme.
</summary>
<remarks>
This call does no blocking I/O.
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="uriScheme">
a string containing a URI scheme
</param>
<returns>
<c>true</c> if <see cref="IFile"/>'s backend supports the
    given URI scheme, <c>false</c> if URI scheme is <c>null</c>,
    not supported, or <see cref="IFile"/> is invalid.
</returns>
</member>

<member name='File.GetHashCode(GISharp.Lib.Gio.IFile)'>
<summary>
Creates a hash value for a <see cref="IFile"/>.
</summary>
<remarks>
This call does no blocking I/O.
</remarks>
<param name="file">
#gconstpointer to a <see cref="IFile"/>
</param>
<returns>
0 if <paramref name="file"/> is not a valid <see cref="IFile"/>, otherwise an
    integer that can be used as hash value for the <see cref="IFile"/>.
    This function is intended for easily hashing a <see cref="IFile"/> to
    add to a #GHashTable or similar data structure.
</returns>
</member>

<member name='File.IsNative(GISharp.Lib.Gio.IFile)'>
<summary>
Checks to see if a file is native to the platform.
</summary>
<remarks>
A native file is one expressed in the platform-native filename format,
e.g. "C:\Windows" or "/usr/bin/". This does not mean the file is local,
as it might be on a locally mounted remote filesystem.

On some systems non-native files may be available using the native
filesystem via a userspace filesystem (FUSE), in these cases this call
will return <c>false</c>, but <see cref="File.GetPath(GISharp.Lib.Gio.IFile)"/> will still return a native path.

This call does no blocking I/O.
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<returns>
<c>true</c> if <paramref name="file"/> is native
</returns>
</member>

<member name='File.LoadBytes(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.Utf8?,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Loads the contents of <paramref name="file"/> and returns it as <see cref="GLib.Bytes"/>.
</summary>
<remarks>
If <paramref name="file"/> is a resource:// based URI, the resulting bytes will reference the
embedded resource instead of a copy. Otherwise, this is equivalent to calling
<see cref="File.LoadContents(GISharp.Lib.Gio.IFile,out GISharp.Runtime.CArray{System.Byte},out GISharp.Lib.GLib.Utf8,GISharp.Lib.Gio.Cancellable)"/> and g_bytes_new_take().

For resources, <paramref name="etagOut"/> will be set to <c>null</c>.

The data contained in the resulting <see cref="GLib.Bytes"/> is always zero-terminated, but
this is not included in the <see cref="GLib.Bytes"/> length. The resulting <see cref="GLib.Bytes"/> should be
freed with g_bytes_unref() when no longer in use.
</remarks>
<param name="file">
a <see cref="IFile"/>
</param>
<param name="etagOut">
a location to place the current
    entity tag for the file, or <c>null</c> if the entity tag is not needed
</param>
<param name="cancellable">
a <see cref="Cancellable"/> or <c>null</c>
</param>
<returns>
a <see cref="GLib.Bytes"/> or <c>null</c> and <see cref="GISharp.Runtime.GErrorException"/> is set
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='File.LoadBytesAsync(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Asynchronously loads the contents of <paramref name="file"/> as <see cref="GLib.Bytes"/>.
</summary>
<remarks>
If <paramref name="file"/> is a resource:// based URI, the resulting bytes will reference the
embedded resource instead of a copy. Otherwise, this is equivalent to calling
<see cref="File.LoadContentsAsync(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.Cancellable)"/> and g_bytes_new_take().

See <see cref="File.LoadBytes(GISharp.Lib.Gio.IFile,out GISharp.Lib.GLib.Utf8,GISharp.Lib.Gio.Cancellable)"/> for more information.
</remarks>
<param name="file">
a <see cref="IFile"/>
</param>
<param name="cancellable">
a <see cref="Cancellable"/> or <c>null</c>
</param>
</member>

<member name='File.LoadContents(GISharp.Lib.Gio.IFile,GISharp.Runtime.CArray&lt;System.Byte&gt;,GISharp.Lib.GLib.Utf8,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Loads the content of the file into memory. The data is always
zero-terminated, but this is not included in the resultant length.
</summary>
<remarks>
If <paramref name="cancellable"/> is not <c>null</c>, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error <see cref="IOErrorEnum.Cancelled"/> will be returned.
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="contents">
a location to place the contents of the file
</param>
<param name="etagOut">
a location to place the current entity tag for the file,
   or <c>null</c> if the entity tag is not needed
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object, <c>null</c> to ignore
</param>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='File.LoadContentsAsync(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Starts an asynchronous load of the <paramref name="file"/>'s contents.
</summary>
<remarks>
For more details, see <see cref="File.LoadContents(GISharp.Lib.Gio.IFile,out GISharp.Runtime.CArray{System.Byte},out GISharp.Lib.GLib.Utf8,GISharp.Lib.Gio.Cancellable)"/> which is
the synchronous version of this call.

If <paramref name="cancellable"/> is not <c>null</c>, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error <see cref="IOErrorEnum.Cancelled"/> will be returned.
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object, <c>null</c> to ignore
</param>
</member>

<member name='File.LoadPartialContentsFinish(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.IAsyncResult,GISharp.Runtime.CArray&lt;System.Byte&gt;,GISharp.Lib.GLib.Utf8)'>
<summary>
Finishes an asynchronous partial load operation that was started
with g_file_load_partial_contents_async(). The data is always
zero-terminated, but this is not included in the resultant length.
</summary>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="res">
a <see cref="IAsyncResult"/>
</param>
<param name="contents">
a location to place the contents of the file
</param>
<param name="etagOut">
a location to place the current entity tag for the file,
    or <c>null</c> if the entity tag is not needed
</param>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='File.MakeDirectory(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Creates a directory. Note that this will only create a child directory
of the immediate parent directory of the path or URI given by the <see cref="IFile"/>.
To recursively create directories, see <see cref="File.MakeDirectoryWithParents(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.Cancellable)"/>.
This function will fail if the parent directory does not exist, setting
<see cref="GISharp.Runtime.GErrorException"/> to <see cref="IOErrorEnum.NotFound"/>. If the file system doesn't support
creating directories, this function will fail, setting <see cref="GISharp.Runtime.GErrorException"/> to
<see cref="IOErrorEnum.NotSupported"/>.
</summary>
<remarks>
For a local <see cref="IFile"/> the newly created directory will have the default
(current) ownership and permissions of the current process.

If <paramref name="cancellable"/> is not <c>null</c>, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error <see cref="IOErrorEnum.Cancelled"/> will be returned.
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='File.MakeDirectoryAsync(GISharp.Lib.Gio.IFile,System.Int32,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Asynchronously creates a directory.
</summary>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="ioPriority">
the [I/O priority][io-priority] of the request
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
</member>

<member name='File.MakeDirectoryWithParents(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Creates a directory and any parent directories that may not
exist similar to 'mkdir -p'. If the file system does not support
creating directories, this function will fail, setting <see cref="GISharp.Runtime.GErrorException"/> to
<see cref="IOErrorEnum.NotSupported"/>. If the directory itself already exists,
this function will fail setting <see cref="GISharp.Runtime.GErrorException"/> to <see cref="IOErrorEnum.Exists"/>, unlike
the similar g_mkdir_with_parents().
</summary>
<remarks>
For a local <see cref="IFile"/> the newly created directories will have the default
(current) ownership and permissions of the current process.

If <paramref name="cancellable"/> is not <c>null</c>, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error <see cref="IOErrorEnum.Cancelled"/> will be returned.
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='File.MakeSymbolicLink(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.Filename,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Creates a symbolic link named <paramref name="file"/> which contains the string
<paramref name="symlinkValue"/>.
</summary>
<remarks>
If <paramref name="cancellable"/> is not <c>null</c>, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error <see cref="IOErrorEnum.Cancelled"/> will be returned.
</remarks>
<param name="file">
a <see cref="IFile"/> with the name of the symlink to create
</param>
<param name="symlinkValue">
a string with the path for the target
    of the new symlink
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='File.MeasureDiskUsageFinish(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.IAsyncResult,System.UInt64,System.UInt64,System.UInt64)'>
<summary>
Collects the results from an earlier call to
g_file_measure_disk_usage_async().  See g_file_measure_disk_usage() for
more information.
</summary>
<param name="file">
a <see cref="IFile"/>
</param>
<param name="result">
the <see cref="IAsyncResult"/> passed to your <see cref="AsyncReadyCallback"/>
</param>
<param name="diskUsage">
the number of bytes of disk space used
</param>
<param name="numDirs">
the number of directories encountered
</param>
<param name="numFiles">
the number of non-directories encountered
</param>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='File.MountEnclosingVolumeFinish(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.IAsyncResult)'>
<summary>
Finishes a mount operation started by g_file_mount_enclosing_volume().
</summary>
<param name="location">
input <see cref="IFile"/>
</param>
<param name="result">
a <see cref="IAsyncResult"/>
</param>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='File.MountMountableFinish(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.IAsyncResult)'>
<summary>
Finishes a mount operation. See g_file_mount_mountable() for details.
</summary>
<remarks>
Finish an asynchronous mount operation that was started
with g_file_mount_mountable().
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="result">
a <see cref="IAsyncResult"/>
</param>
<returns>
a <see cref="IFile"/> or <c>null</c> on error.
    Free the returned object with g_object_unref().
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='File.Move(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.FileCopyFlags,GISharp.Lib.Gio.FileProgressCallback?,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Tries to move the file or directory <paramref name="source"/> to the location specified
by <paramref name="destination"/>. If native move operations are supported then this is
used, otherwise a copy + delete fallback is used. The native
implementation may support moving directories (for instance on moves
inside the same filesystem), but the fallback code does not.
</summary>
<remarks>
If the flag <see cref="FileCopyFlags.Overwrite"/> is specified an already
existing <paramref name="destination"/> file is overwritten.

If <paramref name="cancellable"/> is not <c>null</c>, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error <see cref="IOErrorEnum.Cancelled"/> will be returned.

If <paramref name="progressCallback"/> is not <c>null</c>, then the operation can be monitored
by setting this to a <see cref="FileProgressCallback"/> function.
It is
guaranteed that this callback will be called after all data has been
transferred with the total number of bytes copied during the operation.

If the <paramref name="source"/> file does not exist, then the <see cref="IOErrorEnum.NotFound"/>
error is returned, independent on the status of the <paramref name="destination"/>.

If <see cref="FileCopyFlags.Overwrite"/> is not specified and the target exists,
then the error <see cref="IOErrorEnum.Exists"/> is returned.

If trying to overwrite a file over a directory, the <see cref="IOErrorEnum.IsDirectory"/>
error is returned. If trying to overwrite a directory with a directory the
<see cref="IOErrorEnum.WouldMerge"/> error is returned.

If the source is a directory and the target does not exist, or
<see cref="FileCopyFlags.Overwrite"/> is specified and the target is a file, then
the <see cref="IOErrorEnum.WouldRecurse"/> error may be returned (if the native
move operation isn't available).
</remarks>
<param name="source">
<see cref="IFile"/> pointing to the source location
</param>
<param name="destination">
<see cref="IFile"/> pointing to the destination location
</param>
<param name="flags">
set of <see cref="FileCopyFlags"/>
</param>
<param name="progressCallback">
<see cref="FileProgressCallback"/>
    function for updates
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='File.OpenReadwrite(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Opens an existing file for reading and writing. The result is
a <see cref="FileIOStream"/> that can be used to read and write the contents
of the file.
</summary>
<remarks>
If <paramref name="cancellable"/> is not <c>null</c>, then the operation can be cancelled
by triggering the cancellable object from another thread. If the
operation was cancelled, the error <see cref="IOErrorEnum.Cancelled"/> will be
returned.

If the file does not exist, the <see cref="IOErrorEnum.NotFound"/> error will
be returned. If the file is a directory, the <see cref="IOErrorEnum.IsDirectory"/>
error will be returned. Other errors are possible too, and depend on
what kind of filesystem the file is on. Note that in many non-local
file cases read and write streams are not supported, so make sure you
really need to do read and write streaming, rather than just opening
for reading or writing.
</remarks>
<param name="file">
<see cref="IFile"/> to open
</param>
<param name="cancellable">
a <see cref="Cancellable"/>
</param>
<returns>
<see cref="FileIOStream"/> or <c>null</c> on error.
    Free the returned object with g_object_unref().
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='File.OpenReadwriteAsync(GISharp.Lib.Gio.IFile,System.Int32,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Asynchronously opens <paramref name="file"/> for reading and writing.
</summary>
<remarks>
For more details, see <see cref="File.OpenReadwrite(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.Cancellable)"/> which is
the synchronous version of this call.
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="ioPriority">
the [I/O priority][io-priority] of the request
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
</member>

<member name='File.PeekPath(GISharp.Lib.Gio.IFile)'>
<summary>
Exactly like <see cref="File.GetPath(GISharp.Lib.Gio.IFile)"/>, but caches the result via
g_object_set_qdata_full().  This is useful for example in C
applications which mix `g_file_*` APIs with native ones.  It
also avoids an extra duplicated string when possible, so will be
generally more efficient.
</summary>
<remarks>
This call does no blocking I/O.
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<returns>
string containing the <see cref="IFile"/>'s path,
    or <c>null</c> if no such path exists. The returned string is owned by <paramref name="file"/>.
</returns>
</member>

<member name='File.PollMountable(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.AsyncReadyCallback?,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Polls a file of type <see cref="FileType.Mountable"/>.
</summary>
<remarks>
If <paramref name="cancellable"/> is not <c>null</c>, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error <see cref="IOErrorEnum.Cancelled"/> will be returned.
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="callback">
a <see cref="AsyncReadyCallback"/> to call
    when the request is satisfied, or <c>null</c>
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object, <c>null</c> to ignore
</param>
</member>

<member name='File.PollMountableFinish(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.IAsyncResult)'>
<summary>
Finishes a poll operation. See <see cref="File.PollMountable(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.AsyncReadyCallback,GISharp.Lib.Gio.Cancellable)"/> for details.
</summary>
<remarks>
Finish an asynchronous poll operation that was polled
with <see cref="File.PollMountable(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.AsyncReadyCallback,GISharp.Lib.Gio.Cancellable)"/>.
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="result">
a <see cref="IAsyncResult"/>
</param>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='File.QueryExists(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Utility function to check if a particular file exists. This is
implemented using <see cref="File.QueryInfo(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.Gio.FileQueryInfoFlags,GISharp.Lib.Gio.Cancellable)"/> and as such does blocking I/O.
</summary>
<remarks>
Note that in many cases it is [racy to first check for file existence](https://en.wikipedia.org/wiki/Time_of_check_to_time_of_use)
and then execute something based on the outcome of that, because the
file might have been created or removed in between the operations. The
general approach to handling that is to not check, but just do the
operation and handle the errors as they come.

As an example of race-free checking, take the case of reading a file,
and if it doesn't exist, creating it. There are two racy versions: read
it, and on error create it; and: check if it exists, if not create it.
These can both result in two processes creating the file (with perhaps
a partially written file as the result). The correct approach is to
always try to create the file with <see cref="File.Create(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.FileCreateFlags,GISharp.Lib.Gio.Cancellable)"/> which will either
atomically create the file or fail with a <see cref="IOErrorEnum.Exists"/> error.

However, in many cases an existence check is useful in a user interface,
for instance to make a menu item sensitive/insensitive, so that you don't
have to fool users that something is possible and then just show an error
dialog. If you do this, you should make sure to also handle the errors
that can happen due to races when you execute the operation.
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
<returns>
<c>true</c> if the file exists (and can be detected without error),
    <c>false</c> otherwise (or if cancelled).
</returns>
</member>

<member name='File.QueryFileType(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.FileQueryInfoFlags,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Utility function to inspect the <see cref="FileType"/> of a file. This is
implemented using <see cref="File.QueryInfo(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.Gio.FileQueryInfoFlags,GISharp.Lib.Gio.Cancellable)"/> and as such does blocking I/O.
</summary>
<remarks>
The primary use case of this method is to check if a file is
a regular file, directory, or symlink.
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="flags">
a set of <see cref="FileQueryInfoFlags"/> passed to <see cref="File.QueryInfo(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.Gio.FileQueryInfoFlags,GISharp.Lib.Gio.Cancellable)"/>
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
<returns>
The <see cref="FileType"/> of the file and <see cref="FileType.Unknown"/>
    if the file does not exist
</returns>
</member>

<member name='File.QueryFilesystemInfo(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Similar to <see cref="File.QueryInfo(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.Gio.FileQueryInfoFlags,GISharp.Lib.Gio.Cancellable)"/>, but obtains information
about the filesystem the <paramref name="file"/> is on, rather than the file itself.
For instance the amount of space available and the type of
the filesystem.
</summary>
<remarks>
The <paramref name="attributes"/> value is a string that specifies the attributes
that should be gathered. It is not an error if it's not possible
to read a particular requested attribute from a file - it just
won't be set. <paramref name="attributes"/> should be a comma-separated list of
attributes or attribute wildcards. The wildcard "*" means all
attributes, and a wildcard like "filesystem::*" means all attributes
in the filesystem namespace. The standard namespace for filesystem
attributes is "filesystem". Common attributes of interest are
<see cref="FileAttribute.FilesystemSize"/> (the total size of the filesystem
in bytes), <see cref="FileAttribute.FilesystemFree"/> (number of bytes available),
and <see cref="FileAttribute.FilesystemType"/> (type of the filesystem).

If <paramref name="cancellable"/> is not <c>null</c>, then the operation can be cancelled
by triggering the cancellable object from another thread. If the
operation was cancelled, the error <see cref="IOErrorEnum.Cancelled"/> will be
returned.

If the file does not exist, the <see cref="IOErrorEnum.NotFound"/> error will
be returned. Other errors are possible too, and depend on what
kind of filesystem the file is on.
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="attributes">
an attribute query string
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
<returns>
a <see cref="FileInfo"/> or <c>null</c> if there was an error.
    Free the returned object with g_object_unref().
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='File.QueryFilesystemInfoAsync(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.UnownedUtf8,System.Int32,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Asynchronously gets the requested information about the filesystem
that the specified <paramref name="file"/> is on. The result is a <see cref="FileInfo"/> object
that contains key-value attributes (such as type or size for the
file).
</summary>
<remarks>
For more details, see <see cref="File.QueryFilesystemInfo(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.Gio.Cancellable)"/> which is the
synchronous version of this call.
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="attributes">
an attribute query string
</param>
<param name="ioPriority">
the [I/O priority][io-priority] of the request
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
</member>

<member name='File.QueryInfo(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.Gio.FileQueryInfoFlags,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Gets the requested information about specified <paramref name="file"/>.
The result is a <see cref="FileInfo"/> object that contains key-value
attributes (such as the type or size of the file).
</summary>
<remarks>
The <paramref name="attributes"/> value is a string that specifies the file
attributes that should be gathered. It is not an error if
it's not possible to read a particular requested attribute
from a file - it just won't be set. <paramref name="attributes"/> should be a
comma-separated list of attributes or attribute wildcards.
The wildcard "*" means all attributes, and a wildcard like
"standard::*" means all attributes in the standard namespace.
An example attribute query be "standard::*,owner::user".
The standard attributes are available as defines, like
<see cref="FileAttribute.StandardName"/>.

If <paramref name="cancellable"/> is not <c>null</c>, then the operation can be cancelled
by triggering the cancellable object from another thread. If the
operation was cancelled, the error <see cref="IOErrorEnum.Cancelled"/> will be
returned.

For symlinks, normally the information about the target of the
symlink is returned, rather than information about the symlink
itself. However if you pass <see cref="FileQueryInfoFlags.NoFollowSymlinks"/>
in <paramref name="flags"/> the information about the symlink itself will be returned.
Also, for symlinks that point to non-existing files the information
about the symlink itself will be returned.

If the file does not exist, the <see cref="IOErrorEnum.NotFound"/> error will be
returned. Other errors are possible too, and depend on what kind of
filesystem the file is on.
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="attributes">
an attribute query string
</param>
<param name="flags">
a set of <see cref="FileQueryInfoFlags"/>
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
<returns>
a <see cref="FileInfo"/> for the given <paramref name="file"/>, or <c>null</c>
    on error. Free the returned object with g_object_unref().
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='File.QueryInfoAsync(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.Gio.FileQueryInfoFlags,System.Int32,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Asynchronously gets the requested information about specified <paramref name="file"/>.
The result is a <see cref="FileInfo"/> object that contains key-value attributes
(such as type or size for the file).
</summary>
<remarks>
For more details, see <see cref="File.QueryInfo(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.Gio.FileQueryInfoFlags,GISharp.Lib.Gio.Cancellable)"/> which is the synchronous
version of this call.
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="attributes">
an attribute query string
</param>
<param name="flags">
a set of <see cref="FileQueryInfoFlags"/>
</param>
<param name="ioPriority">
the [I/O priority][io-priority] of the request
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
</member>

<member name='File.QuerySettableAttributes(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Obtain the list of settable attributes for the file.
</summary>
<remarks>
Returns the type and full attribute name of all the attributes
that can be set on this file. This doesn't mean setting it will
always succeed though, you might get an access failure, or some
specific file may not support a specific attribute.

If <paramref name="cancellable"/> is not <c>null</c>, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error <see cref="IOErrorEnum.Cancelled"/> will be returned.
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
<returns>
a <see cref="FileAttributeInfoList"/> describing the settable attributes.
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='File.QueryWritableNamespaces(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Obtain the list of attribute namespaces where new attributes
can be created by a user. An example of this is extended
attributes (in the "xattr" namespace).
</summary>
<remarks>
If <paramref name="cancellable"/> is not <c>null</c>, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error <see cref="IOErrorEnum.Cancelled"/> will be returned.
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
<returns>
a <see cref="FileAttributeInfoList"/> describing the writable namespaces.
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='File.Read(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Opens a file for reading. The result is a <see cref="FileInputStream"/> that
can be used to read the contents of the file.
</summary>
<remarks>
If <paramref name="cancellable"/> is not <c>null</c>, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error <see cref="IOErrorEnum.Cancelled"/> will be returned.

If the file does not exist, the <see cref="IOErrorEnum.NotFound"/> error will be
returned. If the file is a directory, the <see cref="IOErrorEnum.IsDirectory"/>
error will be returned. Other errors are possible too, and depend
on what kind of filesystem the file is on.
</remarks>
<param name="file">
<see cref="IFile"/> to read
</param>
<param name="cancellable">
a <see cref="Cancellable"/>
</param>
<returns>
<see cref="FileInputStream"/> or <c>null</c> on error.
    Free the returned object with g_object_unref().
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='File.ReadAsync(GISharp.Lib.Gio.IFile,System.Int32,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Asynchronously opens <paramref name="file"/> for reading.
</summary>
<remarks>
For more details, see <see cref="File.Read(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.Cancellable)"/> which is
the synchronous version of this call.
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="ioPriority">
the [I/O priority][io-priority] of the request
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
</member>

<member name='File.Replace(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.NullableUnownedUtf8,System.Boolean,GISharp.Lib.Gio.FileCreateFlags,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Returns an output stream for overwriting the file, possibly
creating a backup copy of the file first. If the file doesn't exist,
it will be created.
</summary>
<remarks>
This will try to replace the file in the safest way possible so
that any errors during the writing will not affect an already
existing copy of the file. For instance, for local files it
may write to a temporary file and then atomically rename over
the destination when the stream is closed.

By default files created are generally readable by everyone,
but if you pass <see cref="FileCreateFlags.Private"/> in <paramref name="flags"/> the file
will be made readable only to the current user, to the level that
is supported on the target filesystem.

If <paramref name="cancellable"/> is not <c>null</c>, then the operation can be cancelled
by triggering the cancellable object from another thread. If the
operation was cancelled, the error <see cref="IOErrorEnum.Cancelled"/> will be
returned.

If you pass in a non-<c>null</c> <paramref name="etag"/> value and <paramref name="file"/> already exists, then
this value is compared to the current entity tag of the file, and if
they differ an <see cref="IOErrorEnum.WrongEtag"/> error is returned. This
generally means that the file has been changed since you last read
it. You can get the new etag from <see cref="FileOutputStream.GetEtag()"/>
after you've finished writing and closed the <see cref="FileOutputStream"/>. When
you load a new file you can use <see cref="FileInputStream.QueryInfo(GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.Gio.Cancellable)"/> to
get the etag of the file.

If <paramref name="makeBackup"/> is <c>true</c>, this function will attempt to make a
backup of the current file before overwriting it. If this fails
a <see cref="IOErrorEnum.CantCreateBackup"/> error will be returned. If you
want to replace anyway, try again with <paramref name="makeBackup"/> set to <c>false</c>.

If the file is a directory the <see cref="IOErrorEnum.IsDirectory"/> error will
be returned, and if the file is some other form of non-regular file
then a <see cref="IOErrorEnum.NotRegularFile"/> error will be returned. Some
file systems don't allow all file names, and may return an
<see cref="IOErrorEnum.InvalidFilename"/> error, and if the name is to long
<see cref="IOErrorEnum.FilenameTooLong"/> will be returned. Other errors are
possible too, and depend on what kind of filesystem the file is on.
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="etag">
an optional [entity tag][gfile-etag]
    for the current <see cref="IFile"/>, or #NULL to ignore
</param>
<param name="makeBackup">
<c>true</c> if a backup should be created
</param>
<param name="flags">
a set of <see cref="FileCreateFlags"/>
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
<returns>
a <see cref="FileOutputStream"/> or <c>null</c> on error.
    Free the returned object with g_object_unref().
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='File.ReplaceAsync(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.NullableUnownedUtf8,System.Boolean,GISharp.Lib.Gio.FileCreateFlags,System.Int32,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Asynchronously overwrites the file, replacing the contents,
possibly creating a backup copy of the file first.
</summary>
<remarks>
For more details, see <see cref="File.Replace(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.NullableUnownedUtf8,System.Boolean,GISharp.Lib.Gio.FileCreateFlags,GISharp.Lib.Gio.Cancellable)"/> which is
the synchronous version of this call.
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="etag">
an [entity tag][gfile-etag] for the current <see cref="IFile"/>,
    or <c>null</c> to ignore
</param>
<param name="makeBackup">
<c>true</c> if a backup should be created
</param>
<param name="flags">
a set of <see cref="FileCreateFlags"/>
</param>
<param name="ioPriority">
the [I/O priority][io-priority] of the request
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
</member>

<member name='File.ReplaceContents(GISharp.Lib.Gio.IFile,System.ReadOnlySpan&lt;System.Byte&gt;,GISharp.Lib.GLib.NullableUnownedUtf8,System.Boolean,GISharp.Lib.Gio.FileCreateFlags,GISharp.Lib.GLib.Utf8,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Replaces the contents of <paramref name="file"/> with <paramref name="contents"/>.
</summary>
<remarks>
If <paramref name="etag"/> is specified (not <c>null</c>), any existing file must have that etag,
or the error <see cref="IOErrorEnum.WrongEtag"/> will be returned.

If <paramref name="makeBackup"/> is <c>true</c>, this function will attempt to make a backup
of <paramref name="file"/>. Internally, it uses <see cref="File.Replace(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.NullableUnownedUtf8,System.Boolean,GISharp.Lib.Gio.FileCreateFlags,GISharp.Lib.Gio.Cancellable)"/>, so will try to replace the
file contents in the safest way possible. For example, atomic renames are
used when replacing local files’ contents.

If <paramref name="cancellable"/> is not <c>null</c>, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error <see cref="IOErrorEnum.Cancelled"/> will be returned.

The returned <paramref name="newEtag"/> can be used to verify that the file hasn't
changed the next time it is saved over.
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="contents">
a string containing the new contents for <paramref name="file"/>
</param>
<param name="etag">
the old [entity-tag][gfile-etag] for the document,
    or <c>null</c>
</param>
<param name="makeBackup">
<c>true</c> if a backup should be created
</param>
<param name="flags">
a set of <see cref="FileCreateFlags"/>
</param>
<param name="newEtag">
a location to a new [entity tag][gfile-etag]
     for the document. This should be freed with g_free() when no longer
     needed, or <c>null</c>
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object, <c>null</c> to ignore
</param>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='File.ReplaceContentsAsync(GISharp.Lib.Gio.IFile,System.ReadOnlySpan&lt;System.Byte&gt;,GISharp.Lib.GLib.NullableUnownedUtf8,System.Boolean,GISharp.Lib.Gio.FileCreateFlags,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Starts an asynchronous replacement of <paramref name="file"/> with the given
<paramref name="contents"/>. <paramref name="etag"/> will replace the document's
current entity tag.
</summary>
<remarks>
If <paramref name="cancellable"/> is not <c>null</c>, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error <see cref="IOErrorEnum.Cancelled"/> will be returned.

If <paramref name="makeBackup"/> is <c>true</c>, this function will attempt to
make a backup of <paramref name="file"/>.

Note that no copy of <paramref name="contents"/> will be made, so it must stay valid
until the async task is completed. See <see cref="File.ReplaceContentsAsync(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.Bytes,GISharp.Lib.GLib.NullableUnownedUtf8,System.Boolean,GISharp.Lib.Gio.FileCreateFlags,GISharp.Lib.Gio.Cancellable)"/>
for a <see cref="GLib.Bytes"/> version that will automatically hold a reference to the
contents (without copying) for the duration of the call.
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="contents">
string of contents to replace the file with
</param>
<param name="etag">
a new [entity tag][gfile-etag] for the <paramref name="file"/>, or <c>null</c>
</param>
<param name="makeBackup">
<c>true</c> if a backup should be created
</param>
<param name="flags">
a set of <see cref="FileCreateFlags"/>
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object, <c>null</c> to ignore
</param>
</member>

<member name='File.ReplaceContentsAsync(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.Bytes,GISharp.Lib.GLib.NullableUnownedUtf8,System.Boolean,GISharp.Lib.Gio.FileCreateFlags,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Same as <see cref="File.ReplaceContentsAsync(GISharp.Lib.Gio.IFile,System.ReadOnlySpan{System.Byte},GISharp.Lib.GLib.NullableUnownedUtf8,System.Boolean,GISharp.Lib.Gio.FileCreateFlags,GISharp.Lib.Gio.Cancellable)"/> but takes a #GBytes input instead.
This function will keep a ref on <paramref name="contents"/> until the operation is done.
Unlike <see cref="File.ReplaceContentsAsync(GISharp.Lib.Gio.IFile,System.ReadOnlySpan{System.Byte},GISharp.Lib.GLib.NullableUnownedUtf8,System.Boolean,GISharp.Lib.Gio.FileCreateFlags,GISharp.Lib.Gio.Cancellable)"/> this allows forgetting about the
content without waiting for the callback.
</summary>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="contents">
a #GBytes
</param>
<param name="etag">
a new [entity tag][gfile-etag] for the <paramref name="file"/>, or <c>null</c>
</param>
<param name="makeBackup">
<c>true</c> if a backup should be created
</param>
<param name="flags">
a set of <see cref="FileCreateFlags"/>
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object, <c>null</c> to ignore
</param>
</member>

<member name='File.ReplaceReadwrite(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.NullableUnownedUtf8,System.Boolean,GISharp.Lib.Gio.FileCreateFlags,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Returns an output stream for overwriting the file in readwrite mode,
possibly creating a backup copy of the file first. If the file doesn't
exist, it will be created.
</summary>
<remarks>
For details about the behaviour, see <see cref="File.Replace(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.NullableUnownedUtf8,System.Boolean,GISharp.Lib.Gio.FileCreateFlags,GISharp.Lib.Gio.Cancellable)"/> which does the
same thing but returns an output stream only.

Note that in many non-local file cases read and write streams are not
supported, so make sure you really need to do read and write streaming,
rather than just opening for reading or writing.
</remarks>
<param name="file">
a <see cref="IFile"/>
</param>
<param name="etag">
an optional [entity tag][gfile-etag]
    for the current <see cref="IFile"/>, or #NULL to ignore
</param>
<param name="makeBackup">
<c>true</c> if a backup should be created
</param>
<param name="flags">
a set of <see cref="FileCreateFlags"/>
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
<returns>
a <see cref="FileIOStream"/> or <c>null</c> on error.
    Free the returned object with g_object_unref().
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='File.ReplaceReadwriteAsync(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.NullableUnownedUtf8,System.Boolean,GISharp.Lib.Gio.FileCreateFlags,System.Int32,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Asynchronously overwrites the file in read-write mode,
replacing the contents, possibly creating a backup copy
of the file first.
</summary>
<remarks>
For more details, see <see cref="File.ReplaceReadwrite(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.NullableUnownedUtf8,System.Boolean,GISharp.Lib.Gio.FileCreateFlags,GISharp.Lib.Gio.Cancellable)"/> which is
the synchronous version of this call.
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="etag">
an [entity tag][gfile-etag] for the current <see cref="IFile"/>,
    or <c>null</c> to ignore
</param>
<param name="makeBackup">
<c>true</c> if a backup should be created
</param>
<param name="flags">
a set of <see cref="FileCreateFlags"/>
</param>
<param name="ioPriority">
the [I/O priority][io-priority] of the request
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
</member>

<member name='File.ResolveRelativePath(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.Filename)'>
<summary>
Resolves a relative path for <paramref name="file"/> to an absolute path.
</summary>
<remarks>
This call does no blocking I/O.
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="relativePath">
a given relative path string
</param>
<returns>
<see cref="IFile"/> to the resolved path.
    <c>null</c> if <paramref name="relativePath"/> is <c>null</c> or if <paramref name="file"/> is invalid.
    Free the returned object with g_object_unref().
</returns>
</member>

<member name='File.SetAttribute(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.Gio.FileAttributeType,System.IntPtr,GISharp.Lib.Gio.FileQueryInfoFlags,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Sets an attribute in the file with attribute name <paramref name="attribute"/> to <paramref name="valueP"/>.
</summary>
<remarks>
Some attributes can be unset by setting <paramref name="type"/> to
<see cref="FileAttributeType.Invalid"/> and <paramref name="valueP"/> to <c>null</c>.

If <paramref name="cancellable"/> is not <c>null</c>, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error <see cref="IOErrorEnum.Cancelled"/> will be returned.
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="attribute">
a string containing the attribute's name
</param>
<param name="type">
The type of the attribute
</param>
<param name="valueP">
a pointer to the value (or the pointer
    itself if the type is a pointer type)
</param>
<param name="flags">
a set of <see cref="FileQueryInfoFlags"/>
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='File.SetAttributeByteString(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.Gio.FileQueryInfoFlags,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Sets <paramref name="attribute"/> of type <see cref="FileAttributeType.ByteString"/> to <paramref name="value"/>.
If <paramref name="attribute"/> is of a different type, this operation will fail,
returning <c>false</c>.
</summary>
<remarks>
If <paramref name="cancellable"/> is not <c>null</c>, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error <see cref="IOErrorEnum.Cancelled"/> will be returned.
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="attribute">
a string containing the attribute's name
</param>
<param name="value">
a string containing the attribute's new value
</param>
<param name="flags">
a <see cref="FileQueryInfoFlags"/>
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='File.SetAttributeInt32(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.UnownedUtf8,System.Int32,GISharp.Lib.Gio.FileQueryInfoFlags,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Sets <paramref name="attribute"/> of type <see cref="FileAttributeType.Int32"/> to <paramref name="value"/>.
If <paramref name="attribute"/> is of a different type, this operation will fail.
</summary>
<remarks>
If <paramref name="cancellable"/> is not <c>null</c>, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error <see cref="IOErrorEnum.Cancelled"/> will be returned.
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="attribute">
a string containing the attribute's name
</param>
<param name="value">
a #gint32 containing the attribute's new value
</param>
<param name="flags">
a <see cref="FileQueryInfoFlags"/>
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='File.SetAttributeInt64(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.UnownedUtf8,System.Int64,GISharp.Lib.Gio.FileQueryInfoFlags,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Sets <paramref name="attribute"/> of type <see cref="FileAttributeType.Int64"/> to <paramref name="value"/>.
If <paramref name="attribute"/> is of a different type, this operation will fail.
</summary>
<remarks>
If <paramref name="cancellable"/> is not <c>null</c>, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error <see cref="IOErrorEnum.Cancelled"/> will be returned.
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="attribute">
a string containing the attribute's name
</param>
<param name="value">
a #guint64 containing the attribute's new value
</param>
<param name="flags">
a <see cref="FileQueryInfoFlags"/>
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='File.SetAttributeString(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.Gio.FileQueryInfoFlags,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Sets <paramref name="attribute"/> of type <see cref="FileAttributeType.String"/> to <paramref name="value"/>.
If <paramref name="attribute"/> is of a different type, this operation will fail.
</summary>
<remarks>
If <paramref name="cancellable"/> is not <c>null</c>, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error <see cref="IOErrorEnum.Cancelled"/> will be returned.
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="attribute">
a string containing the attribute's name
</param>
<param name="value">
a string containing the attribute's value
</param>
<param name="flags">
<see cref="FileQueryInfoFlags"/>
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='File.SetAttributeUint32(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.UnownedUtf8,System.UInt32,GISharp.Lib.Gio.FileQueryInfoFlags,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Sets <paramref name="attribute"/> of type <see cref="FileAttributeType.Uint32"/> to <paramref name="value"/>.
If <paramref name="attribute"/> is of a different type, this operation will fail.
</summary>
<remarks>
If <paramref name="cancellable"/> is not <c>null</c>, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error <see cref="IOErrorEnum.Cancelled"/> will be returned.
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="attribute">
a string containing the attribute's name
</param>
<param name="value">
a #guint32 containing the attribute's new value
</param>
<param name="flags">
a <see cref="FileQueryInfoFlags"/>
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='File.SetAttributeUint64(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.UnownedUtf8,System.UInt64,GISharp.Lib.Gio.FileQueryInfoFlags,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Sets <paramref name="attribute"/> of type <see cref="FileAttributeType.Uint64"/> to <paramref name="value"/>.
If <paramref name="attribute"/> is of a different type, this operation will fail.
</summary>
<remarks>
If <paramref name="cancellable"/> is not <c>null</c>, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error <see cref="IOErrorEnum.Cancelled"/> will be returned.
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="attribute">
a string containing the attribute's name
</param>
<param name="value">
a #guint64 containing the attribute's new value
</param>
<param name="flags">
a <see cref="FileQueryInfoFlags"/>
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='File.SetAttributesAsync(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.FileInfo,GISharp.Lib.Gio.FileQueryInfoFlags,System.Int32,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Asynchronously sets the attributes of <paramref name="file"/> with <paramref name="info"/>.
</summary>
<remarks>
For more details, see <see cref="File.SetAttributesFromInfo(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.FileInfo,GISharp.Lib.Gio.FileQueryInfoFlags,GISharp.Lib.Gio.Cancellable)"/>,
which is the synchronous version of this call.
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="info">
a <see cref="FileInfo"/>
</param>
<param name="flags">
a <see cref="FileQueryInfoFlags"/>
</param>
<param name="ioPriority">
the [I/O priority][io-priority] of the request
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
</member>

<member name='File.SetAttributesFromInfo(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.FileInfo,GISharp.Lib.Gio.FileQueryInfoFlags,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Tries to set all attributes in the <see cref="FileInfo"/> on the target
values, not stopping on the first error.
</summary>
<remarks>
If there is any error during this operation then <see cref="GISharp.Runtime.GErrorException"/> will
be set to the first error. Error on particular fields are flagged
by setting the "status" field in the attribute value to
<see cref="FileAttributeStatus.ErrorSetting"/>, which means you can
also detect further errors.

If <paramref name="cancellable"/> is not <c>null</c>, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error <see cref="IOErrorEnum.Cancelled"/> will be returned.
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="info">
a <see cref="FileInfo"/>
</param>
<param name="flags">
<see cref="FileQueryInfoFlags"/>
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='File.SetDisplayName(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Renames <paramref name="file"/> to the specified display name.
</summary>
<remarks>
The display name is converted from UTF-8 to the correct encoding
for the target filesystem if possible and the <paramref name="file"/> is renamed to this.

If you want to implement a rename operation in the user interface the
edit name (<see cref="FileAttribute.StandardEditName"/>) should be used as the
initial value in the rename widget, and then the result after editing
should be passed to <see cref="File.SetDisplayName(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.Gio.Cancellable)"/>.

On success the resulting converted filename is returned.

If <paramref name="cancellable"/> is not <c>null</c>, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error <see cref="IOErrorEnum.Cancelled"/> will be returned.
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="displayName">
a string
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
<returns>
a <see cref="IFile"/> specifying what <paramref name="file"/> was renamed to,
    or <c>null</c> if there was an error.
    Free the returned object with g_object_unref().
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='File.SetDisplayNameAsync(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.UnownedUtf8,System.Int32,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Asynchronously sets the display name for a given <see cref="IFile"/>.
</summary>
<remarks>
For more details, see <see cref="File.SetDisplayName(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.Gio.Cancellable)"/> which is
the synchronous version of this call.
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="displayName">
a string
</param>
<param name="ioPriority">
the [I/O priority][io-priority] of the request
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
</member>

<member name='File.StartMountableFinish(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.IAsyncResult)'>
<summary>
Finishes a start operation. See g_file_start_mountable() for details.
</summary>
<remarks>
Finish an asynchronous start operation that was started
with g_file_start_mountable().
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="result">
a <see cref="IAsyncResult"/>
</param>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='File.StopMountableFinish(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.IAsyncResult)'>
<summary>
Finishes a stop operation, see g_file_stop_mountable() for details.
</summary>
<remarks>
Finish an asynchronous stop operation that was started
with g_file_stop_mountable().
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="result">
a <see cref="IAsyncResult"/>
</param>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='File.SupportsThreadContexts(GISharp.Lib.Gio.IFile)'>
<summary>
Checks if <paramref name="file"/> supports
[thread-default contexts][g-main-context-push-thread-default-context].
If this returns <c>false</c>, you cannot perform asynchronous operations on
<paramref name="file"/> in a thread that has a thread-default context.
</summary>
<param name="file">
a <see cref="IFile"/>
</param>
<returns>
Whether or not <paramref name="file"/> supports thread-default contexts.
</returns>
</member>

<member name='File.Trash(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Sends <paramref name="file"/> to the "Trashcan", if possible. This is similar to
deleting it, but the user can recover it before emptying the trashcan.
Not all file systems support trashing, so this call can return the
<see cref="IOErrorEnum.NotSupported"/> error. Since GLib 2.66, the `x-gvfs-notrash` unix
mount option can be used to disable <see cref="File.Trash(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.Cancellable)"/> support for certain
mounts, the <see cref="IOErrorEnum.NotSupported"/> error will be returned in that case.
</summary>
<remarks>
If <paramref name="cancellable"/> is not <c>null</c>, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error <see cref="IOErrorEnum.Cancelled"/> will be returned.
</remarks>
<param name="file">
<see cref="IFile"/> to send to trash
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='File.TrashAsync(GISharp.Lib.Gio.IFile,System.Int32,GISharp.Lib.Gio.Cancellable?)'>
<summary>
Asynchronously sends <paramref name="file"/> to the Trash location, if possible.
</summary>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="ioPriority">
the [I/O priority][io-priority] of the request
</param>
<param name="cancellable">
optional <see cref="Cancellable"/> object,
    <c>null</c> to ignore
</param>
</member>

<member name='File.UnmountMountableFinish(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.IAsyncResult)'>
<summary>
Finishes an unmount operation, see g_file_unmount_mountable() for details.
</summary>
<remarks>
Finish an asynchronous unmount operation that was started
with g_file_unmount_mountable().
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="result">
a <see cref="IAsyncResult"/>
</param>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='File.UnmountMountableWithOperationFinish(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.IAsyncResult)'>
<summary>
Finishes an unmount operation,
see g_file_unmount_mountable_with_operation() for details.
</summary>
<remarks>
Finish an asynchronous unmount operation that was started
with g_file_unmount_mountable_with_operation().
</remarks>
<param name="file">
input <see cref="IFile"/>
</param>
<param name="result">
a <see cref="IAsyncResult"/>
</param>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

</declaration>
