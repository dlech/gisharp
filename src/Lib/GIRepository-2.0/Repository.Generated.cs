// SPDX-License-Identifier: MIT
// ATTENTION: This file is automatically generated. Do not edit manually.
#nullable enable
namespace GISharp.Lib.GIRepository
{
    /// <include file="Repository.xmldoc" path="declaration/member[@name='Repository']/*" />
    [GISharp.Runtime.GTypeAttribute("GIRepository", IsProxyForUnmanagedType = true)]
    [GISharp.Runtime.GTypeStructAttribute(typeof(RepositoryClass))]
    public unsafe partial class Repository : GISharp.Lib.GObject.Object
    {
        private static readonly GISharp.Runtime.GType _GType = g_irepository_get_type();

        /// <summary>
        /// The unmanaged data structure.
        /// </summary>
        public new struct UnmanagedStruct
        {
#pragma warning disable CS0169, CS0414, CS0649
            /// <include file="Repository.xmldoc" path="declaration/member[@name='UnmanagedStruct.Parent']/*" />
            internal readonly GISharp.Lib.GObject.Object.UnmanagedStruct Parent;

            /// <include file="Repository.xmldoc" path="declaration/member[@name='UnmanagedStruct.Priv']/*" />
            internal readonly System.IntPtr Priv;
#pragma warning restore CS0169, CS0414, CS0649
        }

        /// <include file="Repository.xmldoc" path="declaration/member[@name='Repository.Default']/*" />
        public static GISharp.Lib.GIRepository.Repository Default { get => GetDefault(); }

        /// <include file="Repository.xmldoc" path="declaration/member[@name='Repository.SearchPath']/*" />
        public static GISharp.Lib.GLib.UnownedSList<GISharp.Lib.GLib.Filename> SearchPath { get => GetSearchPath(); }

        /// <include file="Repository.xmldoc" path="declaration/member[@name='Repository.LoadedNamespaces']/*" />
        public GISharp.Lib.GLib.Strv<GISharp.Lib.GLib.Utf8> LoadedNamespaces { get => GetLoadedNamespaces(); }

        /// <summary>
        /// For internal runtime use only.
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        public Repository(System.IntPtr handle, GISharp.Runtime.Transfer ownership) : base(handle, ownership)
        {
        }

        /// <summary>
        /// </summary>
        /// <remarks>
        /// <para>
        /// Argument specified is a comma-separated pair of filenames; i.e. of the form "input.txt,output.xml". The input file should be a UTF-8 Unix-line-ending text file, with each line containing either "get-type:" followed by the name of a #GType _get_type function, or "error-quark:" followed by the name of an error quark function. No extra whitespace is allowed.
        /// </para>
        /// <para>
        /// The output file should already exist, but be empty. This function will overwrite its contents.
        /// </para>
        /// </remarks>
        /// <param name="arg">
        /// 
        /// Comma-separated pair of input and output filenames
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        private static extern GISharp.Runtime.Boolean g_irepository_dump(
        /* <type name="utf8" type="const char*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* arg,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        static partial void CheckDumpArgs(GISharp.Lib.GLib.UnownedUtf8 arg);

        /// <include file="Repository.xmldoc" path="declaration/member[@name='Repository.Dump(GISharp.Lib.GLib.UnownedUtf8)']/*" />
        public static void Dump(GISharp.Lib.GLib.UnownedUtf8 arg)
        {
            CheckDumpArgs(arg);
            var arg_ = (byte*)arg.UnsafeHandle;
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            g_irepository_dump(arg_, &error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Lib.GLib.Error.Exception(error);
            }
        }

        /// <summary>
        /// Returns the singleton process-global default #GIRepository. It is
        /// not currently supported to have multiple repositories in a
        /// particular process, but this function is provided in the unlikely
        /// eventuality that it would become possible, and as a convenience for
        /// higher level language bindings to conform to the GObject method
        /// call conventions.
        /// </summary>
        /// <remarks>
        /// <para>
        /// All methods on #GIRepository also accept %NULL as an instance
        /// parameter to mean this default repository, which is usually more
        /// convenient for C.
        /// </para>
        /// </remarks>
        /// <returns>
        /// The global singleton #GIRepository
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Repository" type="GIRepository*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GIRepository.Repository.UnmanagedStruct* g_irepository_get_default();
        static partial void CheckGetDefaultArgs();

        private static GISharp.Lib.GIRepository.Repository GetDefault()
        {
            CheckGetDefaultArgs();
            var ret_ = g_irepository_get_default();
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Lib.GIRepository.Repository.GetInstance<GISharp.Lib.GIRepository.Repository>((System.IntPtr)ret_, GISharp.Runtime.Transfer.None)!;
            return ret;
        }

        /// <summary>
        /// Returns the current search path #GIRepository will use when loading
        /// typelib files. The list is internal to #GIRepository and should not
        /// be freed, nor should its string elements.
        /// </summary>
        /// <returns>
        /// #GSList of strings
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="GLib.SList" type="GSList*" is-pointer="1">
*   <type name="filename" is-pointer="1" />
* </type> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GLib.SList.UnmanagedStruct* g_irepository_get_search_path();
        static partial void CheckGetSearchPathArgs();

        private static GISharp.Lib.GLib.UnownedSList<GISharp.Lib.GLib.Filename> GetSearchPath()
        {
            CheckGetSearchPathArgs();
            var ret_ = g_irepository_get_search_path();
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = new GISharp.Lib.GLib.UnownedSList<GISharp.Lib.GLib.Filename>(ret_);
            return ret;
        }

        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_irepository_prepend_library_path(
/* <type name="utf8" type="const char*" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
byte* directory);
        static partial void CheckPrependLibraryPathArgs(GISharp.Lib.GLib.UnownedUtf8 directory);

        /// <include file="Repository.xmldoc" path="declaration/member[@name='Repository.PrependLibraryPath(GISharp.Lib.GLib.UnownedUtf8)']/*" />
        public static void PrependLibraryPath(GISharp.Lib.GLib.UnownedUtf8 directory)
        {
            CheckPrependLibraryPathArgs(directory);
            var directory_ = (byte*)directory.UnsafeHandle;
            g_irepository_prepend_library_path(directory_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
        }

        /// <summary>
        /// Prepends @directory to the typelib search path.
        /// </summary>
        /// <remarks>
        /// <para>
        /// See also: g_irepository_get_search_path().
        /// </para>
        /// </remarks>
        /// <param name="directory">
        /// directory name to prepend to the typelib
        ///   search path
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_irepository_prepend_search_path(
        /* <type name="filename" type="const char*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* directory);
        static partial void CheckPrependSearchPathArgs(GISharp.Lib.GLib.Filename directory);

        /// <include file="Repository.xmldoc" path="declaration/member[@name='Repository.PrependSearchPath(GISharp.Lib.GLib.Filename)']/*" />
        public static void PrependSearchPath(GISharp.Lib.GLib.Filename directory)
        {
            CheckPrependSearchPathArgs(directory);
            var directory_ = (byte*)directory.UnsafeHandle;
            g_irepository_prepend_search_path(directory_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
        }

        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="GType" type="GType" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Runtime.GType g_irepository_get_type();

        /// <summary>
        /// Obtain an unordered list of versions (either currently loaded or
        /// available) for @namespace_ in this @repository.
        /// </summary>
        /// <param name="repository">
        /// A #GIRepository or %NULL for the singleton
        ///   process-global default #GIRepository
        /// </param>
        /// <param name="namespace">
        /// GI namespace, e.g. "Gtk"
        /// </param>
        /// <returns>
        /// the array of versions.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="GLib.List" type="GList*" is-pointer="1">
*   <type name="utf8" is-pointer="1" />
* </type> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GLib.List.UnmanagedStruct* g_irepository_enumerate_versions(
        /* <type name="Repository" type="GIRepository*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.GIRepository.Repository.UnmanagedStruct* repository,
        /* <type name="utf8" type="const gchar*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* @namespace);
        partial void CheckEnumerateVersionsArgs(GISharp.Lib.GLib.UnownedUtf8 @namespace);

        /// <include file="Repository.xmldoc" path="declaration/member[@name='Repository.EnumerateVersions(GISharp.Lib.GLib.UnownedUtf8)']/*" />
        public GISharp.Lib.GLib.List<GISharp.Lib.GLib.Utf8> EnumerateVersions(GISharp.Lib.GLib.UnownedUtf8 @namespace)
        {
            CheckEnumerateVersionsArgs(@namespace);
            var repository_ = (GISharp.Lib.GIRepository.Repository.UnmanagedStruct*)UnsafeHandle;
            var @namespace_ = (byte*)@namespace.UnsafeHandle;
            var ret_ = g_irepository_enumerate_versions(repository_,@namespace_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Lib.GLib.List<GISharp.Lib.GLib.Utf8>.GetInstance<GISharp.Lib.GLib.List<GISharp.Lib.GLib.Utf8>>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Searches for the enum type corresponding to the given #GError
        /// domain. Before calling this function for a particular namespace,
        /// you must call g_irepository_require() once to load the namespace, or
        /// otherwise ensure the namespace has already been loaded.
        /// </summary>
        /// <param name="repository">
        /// A #GIRepository or %NULL for the singleton
        ///   process-global default #GIRepository
        /// </param>
        /// <param name="domain">
        /// a #GError domain
        /// </param>
        /// <returns>
        /// #GIEnumInfo representing metadata about @domain's
        /// enum type, or %NULL
        /// </returns>
        [GISharp.Runtime.SinceAttribute("1.30")]
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="EnumInfo" type="GIEnumInfo*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GIRepository.EnumInfo.UnmanagedStruct* g_irepository_find_by_error_domain(
        /* <type name="Repository" type="GIRepository*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.GIRepository.Repository.UnmanagedStruct* repository,
        /* <type name="GLib.Quark" type="GQuark" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Quark domain);
        partial void CheckFindByErrorDomainArgs(GISharp.Lib.GLib.Quark domain);

        /// <include file="Repository.xmldoc" path="declaration/member[@name='Repository.FindByErrorDomain(GISharp.Lib.GLib.Quark)']/*" />
        [GISharp.Runtime.SinceAttribute("1.30")]
        public GISharp.Lib.GIRepository.EnumInfo FindByErrorDomain(GISharp.Lib.GLib.Quark domain)
        {
            CheckFindByErrorDomainArgs(domain);
            var repository_ = (GISharp.Lib.GIRepository.Repository.UnmanagedStruct*)UnsafeHandle;
            var domain_ = (GISharp.Lib.GLib.Quark)domain;
            var ret_ = g_irepository_find_by_error_domain(repository_,domain_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Lib.GIRepository.EnumInfo.GetInstance<GISharp.Lib.GIRepository.EnumInfo>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Searches all loaded namespaces for a particular #GType.  Note that
        /// in order to locate the metadata, the namespace corresponding to
        /// the type must first have been loaded.  There is currently no
        /// mechanism for determining the namespace which corresponds to an
        /// arbitrary GType - thus, this function will operate most reliably
        /// when you know the GType to originate from be from a loaded namespace.
        /// </summary>
        /// <param name="repository">
        /// A #GIRepository or %NULL for the singleton
        ///   process-global default #GIRepository
        /// </param>
        /// <param name="gtype">
        /// GType to search for
        /// </param>
        /// <returns>
        /// #GIBaseInfo representing metadata about @type, or %NULL
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="BaseInfo" type="GIBaseInfo*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GIRepository.BaseInfo.UnmanagedStruct* g_irepository_find_by_gtype(
        /* <type name="Repository" type="GIRepository*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.GIRepository.Repository.UnmanagedStruct* repository,
        /* <type name="GType" type="GType" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.GType gtype);
        partial void CheckFindByGtypeArgs(GISharp.Runtime.GType gtype);

        /// <include file="Repository.xmldoc" path="declaration/member[@name='Repository.FindByGtype(GISharp.Runtime.GType)']/*" />
        public GISharp.Lib.GIRepository.BaseInfo FindByGtype(GISharp.Runtime.GType gtype)
        {
            CheckFindByGtypeArgs(gtype);
            var repository_ = (GISharp.Lib.GIRepository.Repository.UnmanagedStruct*)UnsafeHandle;
            var gtype_ = (GISharp.Runtime.GType)gtype;
            var ret_ = g_irepository_find_by_gtype(repository_,gtype_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Lib.GIRepository.BaseInfo.GetInstance<GISharp.Lib.GIRepository.BaseInfo>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Searches for a particular entry in a namespace.  Before calling
        /// this function for a particular namespace, you must call
        /// g_irepository_require() once to load the namespace, or otherwise
        /// ensure the namespace has already been loaded.
        /// </summary>
        /// <param name="repository">
        /// A #GIRepository or %NULL for the singleton
        ///   process-global default #GIRepository
        /// </param>
        /// <param name="namespace">
        /// Namespace which will be searched
        /// </param>
        /// <param name="name">
        /// Entry name to find
        /// </param>
        /// <returns>
        /// #GIBaseInfo representing metadata about @name, or %NULL
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="BaseInfo" type="GIBaseInfo*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GIRepository.BaseInfo.UnmanagedStruct* g_irepository_find_by_name(
        /* <type name="Repository" type="GIRepository*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.GIRepository.Repository.UnmanagedStruct* repository,
        /* <type name="utf8" type="const gchar*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* @namespace,
        /* <type name="utf8" type="const gchar*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* name);
        partial void CheckFindByNameArgs(GISharp.Lib.GLib.UnownedUtf8 @namespace, GISharp.Lib.GLib.UnownedUtf8 name);

        /// <include file="Repository.xmldoc" path="declaration/member[@name='Repository.FindByName(GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.GLib.UnownedUtf8)']/*" />
        public GISharp.Lib.GIRepository.BaseInfo FindByName(GISharp.Lib.GLib.UnownedUtf8 @namespace, GISharp.Lib.GLib.UnownedUtf8 name)
        {
            CheckFindByNameArgs(@namespace, name);
            var repository_ = (GISharp.Lib.GIRepository.Repository.UnmanagedStruct*)UnsafeHandle;
            var @namespace_ = (byte*)@namespace.UnsafeHandle;
            var name_ = (byte*)name.UnsafeHandle;
            var ret_ = g_irepository_find_by_name(repository_,@namespace_,name_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Lib.GIRepository.BaseInfo.GetInstance<GISharp.Lib.GIRepository.BaseInfo>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// This function returns the "C prefix", or the C level namespace
        /// associated with the given introspection namespace.  Each C symbol
        /// starts with this prefix, as well each #GType in the library.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Note: The namespace must have already been loaded using a function
        /// such as g_irepository_require() before calling this function.
        /// </para>
        /// </remarks>
        /// <param name="repository">
        /// A #GIRepository or %NULL for the singleton
        ///   process-global default #GIRepository
        /// </param>
        /// <param name="namespace">
        /// Namespace to inspect
        /// </param>
        /// <returns>
        /// C namespace prefix, or %NULL if none associated
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="const gchar*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern byte* g_irepository_get_c_prefix(
        /* <type name="Repository" type="GIRepository*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.GIRepository.Repository.UnmanagedStruct* repository,
        /* <type name="utf8" type="const gchar*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* @namespace);
        partial void CheckGetCPrefixArgs(GISharp.Lib.GLib.UnownedUtf8 @namespace);

        /// <include file="Repository.xmldoc" path="declaration/member[@name='Repository.GetCPrefix(GISharp.Lib.GLib.UnownedUtf8)']/*" />
        public GISharp.Lib.GLib.UnownedUtf8 GetCPrefix(GISharp.Lib.GLib.UnownedUtf8 @namespace)
        {
            CheckGetCPrefixArgs(@namespace);
            var repository_ = (GISharp.Lib.GIRepository.Repository.UnmanagedStruct*)UnsafeHandle;
            var @namespace_ = (byte*)@namespace.UnsafeHandle;
            var ret_ = g_irepository_get_c_prefix(repository_,@namespace_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = new GISharp.Lib.GLib.UnownedUtf8(ret_);
            return ret;
        }

        /// <summary>
        /// Return an array of all (transitive) versioned dependencies for
        /// @namespace_. Returned strings are of the form
        /// &lt;code&gt;namespace-version&lt;/code&gt;.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Note: @namespace_ must have already been loaded using a function
        /// such as g_irepository_require() before calling this function.
        /// </para>
        /// <para>
        /// To get only the immediate dependencies for @namespace_, use
        /// g_irepository_get_immediate_dependencies().
        /// </para>
        /// </remarks>
        /// <param name="repository">
        /// A #GIRepository or %NULL for the singleton
        ///   process-global default #GIRepository
        /// </param>
        /// <param name="namespace">
        /// Namespace of interest
        /// </param>
        /// <returns>
        /// Zero-terminated string array of all versioned
        ///   dependencies
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <array type="gchar**" zero-terminated="1" is-pointer="1">
*   <type name="utf8" is-pointer="1" />
* </array> */
        /* transfer-ownership:full direction:in */
        private static extern byte** g_irepository_get_dependencies(
        /* <type name="Repository" type="GIRepository*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.GIRepository.Repository.UnmanagedStruct* repository,
        /* <type name="utf8" type="const gchar*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* @namespace);
        partial void CheckGetDependenciesArgs(GISharp.Lib.GLib.UnownedUtf8 @namespace);

        /// <include file="Repository.xmldoc" path="declaration/member[@name='Repository.GetDependencies(GISharp.Lib.GLib.UnownedUtf8)']/*" />
        public GISharp.Lib.GLib.Strv<GISharp.Lib.GLib.Utf8> GetDependencies(GISharp.Lib.GLib.UnownedUtf8 @namespace)
        {
            CheckGetDependenciesArgs(@namespace);
            var repository_ = (GISharp.Lib.GIRepository.Repository.UnmanagedStruct*)UnsafeHandle;
            var @namespace_ = (byte*)@namespace.UnsafeHandle;
            var ret_ = g_irepository_get_dependencies(repository_,@namespace_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = new GISharp.Lib.GLib.Strv<GISharp.Lib.GLib.Utf8>((System.IntPtr)ret_, -1, GISharp.Runtime.Transfer.Full);
            return ret;
        }

        /// <summary>
        /// Return an array of the immediate versioned dependencies for @namespace_.
        /// Returned strings are of the form &lt;code&gt;namespace-version&lt;/code&gt;.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Note: @namespace_ must have already been loaded using a function
        /// such as g_irepository_require() before calling this function.
        /// </para>
        /// <para>
        /// To get the transitive closure of dependencies for @namespace_, use
        /// g_irepository_get_dependencies().
        /// </para>
        /// </remarks>
        /// <param name="repository">
        /// A #GIRepository or %NULL for the singleton
        ///   process-global default #GIRepository
        /// </param>
        /// <param name="namespace">
        /// Namespace of interest
        /// </param>
        /// <returns>
        /// Zero-terminated string array of immediate versioned
        ///   dependencies
        /// </returns>
        [GISharp.Runtime.SinceAttribute("1.44")]
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <array type="gchar**" zero-terminated="1" is-pointer="1">
*   <type name="utf8" is-pointer="1" />
* </array> */
        /* transfer-ownership:full direction:in */
        private static extern byte** g_irepository_get_immediate_dependencies(
        /* <type name="Repository" type="GIRepository*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.GIRepository.Repository.UnmanagedStruct* repository,
        /* <type name="utf8" type="const gchar*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* @namespace);
        partial void CheckGetImmediateDependenciesArgs(GISharp.Lib.GLib.UnownedUtf8 @namespace);

        /// <include file="Repository.xmldoc" path="declaration/member[@name='Repository.GetImmediateDependencies(GISharp.Lib.GLib.UnownedUtf8)']/*" />
        [GISharp.Runtime.SinceAttribute("1.44")]
        public GISharp.Lib.GLib.Strv<GISharp.Lib.GLib.Utf8> GetImmediateDependencies(GISharp.Lib.GLib.UnownedUtf8 @namespace)
        {
            CheckGetImmediateDependenciesArgs(@namespace);
            var repository_ = (GISharp.Lib.GIRepository.Repository.UnmanagedStruct*)UnsafeHandle;
            var @namespace_ = (byte*)@namespace.UnsafeHandle;
            var ret_ = g_irepository_get_immediate_dependencies(repository_,@namespace_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = new GISharp.Lib.GLib.Strv<GISharp.Lib.GLib.Utf8>((System.IntPtr)ret_, -1, GISharp.Runtime.Transfer.Full);
            return ret;
        }

        /// <summary>
        /// This function returns a particular metadata entry in the
        /// given namespace @namespace_.  The namespace must have
        /// already been loaded before calling this function.
        /// See g_irepository_get_n_infos() to find the maximum number of
        /// entries.
        /// </summary>
        /// <param name="repository">
        /// A #GIRepository or %NULL for the singleton
        ///   process-global default #GIRepository
        /// </param>
        /// <param name="namespace">
        /// Namespace to inspect
        /// </param>
        /// <param name="index">
        /// 0-based offset into namespace metadata for entry
        /// </param>
        /// <returns>
        /// #GIBaseInfo containing metadata
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="BaseInfo" type="GIBaseInfo*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GIRepository.BaseInfo.UnmanagedStruct* g_irepository_get_info(
        /* <type name="Repository" type="GIRepository*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.GIRepository.Repository.UnmanagedStruct* repository,
        /* <type name="utf8" type="const gchar*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* @namespace,
        /* <type name="gint" type="gint" /> */
        /* transfer-ownership:none direction:in */
        int index);
        partial void CheckGetInfoArgs(GISharp.Lib.GLib.UnownedUtf8 @namespace, int index);

        private GISharp.Lib.GIRepository.BaseInfo GetInfo(GISharp.Lib.GLib.UnownedUtf8 @namespace, int index)
        {
            CheckGetInfoArgs(@namespace, index);
            var repository_ = (GISharp.Lib.GIRepository.Repository.UnmanagedStruct*)UnsafeHandle;
            var @namespace_ = (byte*)@namespace.UnsafeHandle;
            var index_ = (int)index;
            var ret_ = g_irepository_get_info(repository_,@namespace_,index_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Lib.GIRepository.BaseInfo.GetInstance<GISharp.Lib.GIRepository.BaseInfo>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Return the list of currently loaded namespaces.
        /// </summary>
        /// <param name="repository">
        /// A #GIRepository or %NULL for the singleton
        ///   process-global default #GIRepository
        /// </param>
        /// <returns>
        /// List of namespaces
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <array type="gchar**" zero-terminated="1" is-pointer="1">
*   <type name="utf8" is-pointer="1" />
* </array> */
        /* transfer-ownership:full direction:in */
        private static extern byte** g_irepository_get_loaded_namespaces(
        /* <type name="Repository" type="GIRepository*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.GIRepository.Repository.UnmanagedStruct* repository);
        partial void CheckGetLoadedNamespacesArgs();

        private GISharp.Lib.GLib.Strv<GISharp.Lib.GLib.Utf8> GetLoadedNamespaces()
        {
            CheckGetLoadedNamespacesArgs();
            var repository_ = (GISharp.Lib.GIRepository.Repository.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_irepository_get_loaded_namespaces(repository_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = new GISharp.Lib.GLib.Strv<GISharp.Lib.GLib.Utf8>((System.IntPtr)ret_, -1, GISharp.Runtime.Transfer.Full);
            return ret;
        }

        /// <summary>
        /// This function returns the number of metadata entries in
        /// given namespace @namespace_.  The namespace must have
        /// already been loaded before calling this function.
        /// </summary>
        /// <param name="repository">
        /// A #GIRepository or %NULL for the singleton
        ///   process-global default #GIRepository
        /// </param>
        /// <param name="namespace">
        /// Namespace to inspect
        /// </param>
        /// <returns>
        /// number of metadata entries
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gint" type="gint" /> */
        /* transfer-ownership:none direction:in */
        private static extern int g_irepository_get_n_infos(
        /* <type name="Repository" type="GIRepository*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.GIRepository.Repository.UnmanagedStruct* repository,
        /* <type name="utf8" type="const gchar*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* @namespace);
        partial void CheckGetNInfosArgs(GISharp.Lib.GLib.UnownedUtf8 @namespace);

        private int GetNInfos(GISharp.Lib.GLib.UnownedUtf8 @namespace)
        {
            CheckGetNInfosArgs(@namespace);
            var repository_ = (GISharp.Lib.GIRepository.Repository.UnmanagedStruct*)UnsafeHandle;
            var @namespace_ = (byte*)@namespace.UnsafeHandle;
            var ret_ = g_irepository_get_n_infos(repository_,@namespace_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = (int)ret_;
            return ret;
        }

        /// <summary>
        /// Look up the implemented interfaces for @gtype.  This function
        /// cannot fail per se; but for a totally "unknown" #GType, it may
        /// return 0 implemented interfaces.
        /// </summary>
        /// <remarks>
        /// <para>
        /// The semantics of this function are designed for a dynamic binding,
        /// where in certain cases (such as a function which returns an
        /// interface which may have "hidden" implementation classes), not all
        /// data may be statically known, and will have to be determined from
        /// the #GType of the object.  An example is g_file_new_for_path()
        /// returning a concrete class of #GLocalFile, which is a #GType we
        /// see at runtime, but not statically.
        /// </para>
        /// </remarks>
        /// <param name="repository">
        /// a #GIRepository, or %NULL for the default repository
        /// </param>
        /// <param name="gtype">
        /// a #GType whose fundamental type is G_TYPE_OBJECT
        /// </param>
        /// <param name="nInterfacesOut">
        /// Number of interfaces
        /// </param>
        /// <param name="interfacesOut">
        /// Interfaces for @gtype
        /// </param>
        [GISharp.Runtime.SinceAttribute("1.62")]
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_irepository_get_object_gtype_interfaces(
        /* <type name="Repository" type="GIRepository*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.GIRepository.Repository.UnmanagedStruct* repository,
        /* <type name="GType" type="GType" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.GType gtype,
        /* <type name="guint" type="guint*" /> */
        /* direction:out caller-allocates:0 transfer-ownership:full */
        uint* nInterfacesOut,
        /* <array length="1" zero-terminated="0" type="GIInterfaceInfo***" is-pointer="1">
*   <type name="InterfaceInfo" type="GIInterfaceInfo**" is-pointer="1" />
* </array> */
        /* direction:out caller-allocates:0 transfer-ownership:none */
        GISharp.Lib.GIRepository.InterfaceInfo.UnmanagedStruct*** interfacesOut);
        partial void CheckGetObjectGTypeInterfacesArgs(GISharp.Runtime.GType gtype);

        /// <include file="Repository.xmldoc" path="declaration/member[@name='Repository.GetObjectGTypeInterfaces(GISharp.Runtime.GType,GISharp.Runtime.UnownedCPtrArray&lt;GISharp.Lib.GIRepository.InterfaceInfo&gt;)']/*" />
        [GISharp.Runtime.SinceAttribute("1.62")]
        public void GetObjectGTypeInterfaces(GISharp.Runtime.GType gtype, out GISharp.Runtime.UnownedCPtrArray<GISharp.Lib.GIRepository.InterfaceInfo> interfacesOut)
        {
            CheckGetObjectGTypeInterfacesArgs(gtype);
            var repository_ = (GISharp.Lib.GIRepository.Repository.UnmanagedStruct*)UnsafeHandle;
            var gtype_ = (GISharp.Runtime.GType)gtype;
            uint nInterfacesOut_;
            GISharp.Lib.GIRepository.InterfaceInfo.UnmanagedStruct** interfacesOut_;
            g_irepository_get_object_gtype_interfaces(repository_, gtype_, &nInterfacesOut_, &interfacesOut_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            interfacesOut = new GISharp.Runtime.UnownedCPtrArray<GISharp.Lib.GIRepository.InterfaceInfo>(interfacesOut_, (int)nInterfacesOut_);
        }

        /// <summary>
        /// This function returns a comma-separated list of paths to the
        /// shared C libraries associated with the given namespace @namespace_.
        /// There may be no shared library path associated, in which case this
        /// function will return %NULL.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Note: The namespace must have already been loaded using a function
        /// such as g_irepository_require() before calling this function.
        /// </para>
        /// </remarks>
        /// <param name="repository">
        /// A #GIRepository or %NULL for the singleton
        ///   process-global default #GIRepository
        /// </param>
        /// <param name="namespace">
        /// Namespace to inspect
        /// </param>
        /// <returns>
        /// Comma-separated list of paths to shared libraries,
        ///   or %NULL if none are associated
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="const gchar*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 direction:in */
        private static extern byte* g_irepository_get_shared_library(
        /* <type name="Repository" type="GIRepository*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.GIRepository.Repository.UnmanagedStruct* repository,
        /* <type name="utf8" type="const gchar*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* @namespace);
        partial void CheckGetSharedLibraryArgs(GISharp.Lib.GLib.UnownedUtf8 @namespace);

        /// <include file="Repository.xmldoc" path="declaration/member[@name='Repository.GetSharedLibrary(GISharp.Lib.GLib.UnownedUtf8)']/*" />
        public GISharp.Lib.GLib.NullableUnownedUtf8 GetSharedLibrary(GISharp.Lib.GLib.UnownedUtf8 @namespace)
        {
            CheckGetSharedLibraryArgs(@namespace);
            var repository_ = (GISharp.Lib.GIRepository.Repository.UnmanagedStruct*)UnsafeHandle;
            var @namespace_ = (byte*)@namespace.UnsafeHandle;
            var ret_ = g_irepository_get_shared_library(repository_,@namespace_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = new GISharp.Lib.GLib.NullableUnownedUtf8(ret_);
            return ret;
        }

        /// <summary>
        /// If namespace @namespace_ is loaded, return the full path to the
        /// .typelib file it was loaded from.  If the typelib for
        /// namespace @namespace_ was included in a shared library, return
        /// the special string "&amp;lt;builtin&amp;gt;".
        /// </summary>
        /// <param name="repository">
        /// A #GIRepository or %NULL for the singleton
        ///   process-global default #GIRepository
        /// </param>
        /// <param name="namespace">
        /// GI namespace to use, e.g. "Gtk"
        /// </param>
        /// <returns>
        /// Filesystem path (or $lt;builtin$gt;) if successful, %NULL if namespace is not loaded
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="const gchar*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern byte* g_irepository_get_typelib_path(
        /* <type name="Repository" type="GIRepository*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.GIRepository.Repository.UnmanagedStruct* repository,
        /* <type name="utf8" type="const gchar*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* @namespace);
        partial void CheckGetTypelibPathArgs(GISharp.Lib.GLib.UnownedUtf8 @namespace);

        /// <include file="Repository.xmldoc" path="declaration/member[@name='Repository.GetTypelibPath(GISharp.Lib.GLib.UnownedUtf8)']/*" />
        public GISharp.Lib.GLib.UnownedUtf8 GetTypelibPath(GISharp.Lib.GLib.UnownedUtf8 @namespace)
        {
            CheckGetTypelibPathArgs(@namespace);
            var repository_ = (GISharp.Lib.GIRepository.Repository.UnmanagedStruct*)UnsafeHandle;
            var @namespace_ = (byte*)@namespace.UnsafeHandle;
            var ret_ = g_irepository_get_typelib_path(repository_,@namespace_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = new GISharp.Lib.GLib.UnownedUtf8(ret_);
            return ret;
        }

        /// <summary>
        /// This function returns the loaded version associated with the given
        /// namespace @namespace_.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Note: The namespace must have already been loaded using a function
        /// such as g_irepository_require() before calling this function.
        /// </para>
        /// </remarks>
        /// <param name="repository">
        /// A #GIRepository or %NULL for the singleton
        ///   process-global default #GIRepository
        /// </param>
        /// <param name="namespace">
        /// Namespace to inspect
        /// </param>
        /// <returns>
        /// Loaded version
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="const gchar*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern byte* g_irepository_get_version(
        /* <type name="Repository" type="GIRepository*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.GIRepository.Repository.UnmanagedStruct* repository,
        /* <type name="utf8" type="const gchar*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* @namespace);
        partial void CheckGetVersionArgs(GISharp.Lib.GLib.UnownedUtf8 @namespace);

        /// <include file="Repository.xmldoc" path="declaration/member[@name='Repository.GetVersion(GISharp.Lib.GLib.UnownedUtf8)']/*" />
        public GISharp.Lib.GLib.UnownedUtf8 GetVersion(GISharp.Lib.GLib.UnownedUtf8 @namespace)
        {
            CheckGetVersionArgs(@namespace);
            var repository_ = (GISharp.Lib.GIRepository.Repository.UnmanagedStruct*)UnsafeHandle;
            var @namespace_ = (byte*)@namespace.UnsafeHandle;
            var ret_ = g_irepository_get_version(repository_,@namespace_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = new GISharp.Lib.GLib.UnownedUtf8(ret_);
            return ret;
        }

        /// <summary>
        /// Check whether a particular namespace (and optionally, a specific
        /// version thereof) is currently loaded.  This function is likely to
        /// only be useful in unusual circumstances; in order to act upon
        /// metadata in the namespace, you should call g_irepository_require()
        /// instead which will ensure the namespace is loaded, and return as
        /// quickly as this function will if it has already been loaded.
        /// </summary>
        /// <param name="repository">
        /// A #GIRepository or %NULL for the singleton
        ///   process-global default #GIRepository
        /// </param>
        /// <param name="namespace">
        /// Namespace of interest
        /// </param>
        /// <param name="version">
        /// Required version, may be %NULL for latest
        /// </param>
        /// <returns>
        /// %TRUE if namespace-version is loaded, %FALSE otherwise
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_irepository_is_registered(
        /* <type name="Repository" type="GIRepository*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.GIRepository.Repository.UnmanagedStruct* repository,
        /* <type name="utf8" type="const gchar*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* @namespace,
        /* <type name="utf8" type="const gchar*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        byte* version);
        partial void CheckIsRegisteredArgs(GISharp.Lib.GLib.UnownedUtf8 @namespace, GISharp.Lib.GLib.NullableUnownedUtf8 version);

        /// <include file="Repository.xmldoc" path="declaration/member[@name='Repository.IsRegistered(GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.GLib.NullableUnownedUtf8)']/*" />
        public bool IsRegistered(GISharp.Lib.GLib.UnownedUtf8 @namespace, GISharp.Lib.GLib.NullableUnownedUtf8 version)
        {
            CheckIsRegisteredArgs(@namespace, version);
            var repository_ = (GISharp.Lib.GIRepository.Repository.UnmanagedStruct*)UnsafeHandle;
            var @namespace_ = (byte*)@namespace.UnsafeHandle;
            var version_ = (byte*)version.UnsafeHandle;
            var ret_ = g_irepository_is_registered(repository_,@namespace_,version_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// TODO
        /// </summary>
        /// <param name="repository">
        /// A #GIRepository or %NULL for the singleton
        ///   process-global default #GIRepository
        /// </param>
        /// <param name="typelib">
        /// TODO
        /// </param>
        /// <param name="flags">
        /// TODO
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="const char*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern byte* g_irepository_load_typelib(
        /* <type name="Repository" type="GIRepository*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.GIRepository.Repository.UnmanagedStruct* repository,
        /* <type name="Typelib" type="GITypelib*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.Typelib.UnmanagedStruct* typelib,
        /* <type name="RepositoryLoadFlags" type="GIRepositoryLoadFlags" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.RepositoryLoadFlags flags,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        partial void CheckLoadTypelibArgs(GISharp.Lib.GIRepository.Typelib typelib, GISharp.Lib.GIRepository.RepositoryLoadFlags flags);

        /// <include file="Repository.xmldoc" path="declaration/member[@name='Repository.LoadTypelib(GISharp.Lib.GIRepository.Typelib,GISharp.Lib.GIRepository.RepositoryLoadFlags)']/*" />
        public GISharp.Lib.GLib.UnownedUtf8 LoadTypelib(GISharp.Lib.GIRepository.Typelib typelib, GISharp.Lib.GIRepository.RepositoryLoadFlags flags)
        {
            CheckLoadTypelibArgs(typelib, flags);
            var repository_ = (GISharp.Lib.GIRepository.Repository.UnmanagedStruct*)UnsafeHandle;
            var typelib_ = (GISharp.Lib.GIRepository.Typelib.UnmanagedStruct*)typelib.UnsafeHandle;
            var flags_ = (GISharp.Lib.GIRepository.RepositoryLoadFlags)flags;
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            var ret_ = g_irepository_load_typelib(repository_,typelib_,flags_,&error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Lib.GLib.Error.Exception(error);
            }

            var ret = new GISharp.Lib.GLib.UnownedUtf8(ret_);
            return ret;
        }

        /// <summary>
        /// Force the namespace @namespace_ to be loaded if it isn't already.
        /// If @namespace_ is not loaded, this function will search for a
        /// ".typelib" file using the repository search path.  In addition, a
        /// version @version of namespace may be specified.  If @version is
        /// not specified, the latest will be used.
        /// </summary>
        /// <param name="repository">
        /// A #GIRepository or %NULL for the singleton
        ///   process-global default #GIRepository
        /// </param>
        /// <param name="namespace">
        /// GI namespace to use, e.g. "Gtk"
        /// </param>
        /// <param name="version">
        /// Version of namespace, may be %NULL for latest
        /// </param>
        /// <param name="flags">
        /// Set of %GIRepositoryLoadFlags, may be 0
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// a pointer to the #GITypelib if successful, %NULL otherwise
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Typelib" type="GITypelib*" is-pointer="1" /> */
        /* transfer-ownership:none skip:1 direction:in */
        private static extern GISharp.Lib.GIRepository.Typelib.UnmanagedStruct* g_irepository_require(
        /* <type name="Repository" type="GIRepository*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.GIRepository.Repository.UnmanagedStruct* repository,
        /* <type name="utf8" type="const gchar*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* @namespace,
        /* <type name="utf8" type="const gchar*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        byte* version,
        /* <type name="RepositoryLoadFlags" type="GIRepositoryLoadFlags" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.RepositoryLoadFlags flags,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        partial void CheckRequireArgs(GISharp.Lib.GLib.UnownedUtf8 @namespace, GISharp.Lib.GLib.NullableUnownedUtf8 version, GISharp.Lib.GIRepository.RepositoryLoadFlags flags = default);

        /// <include file="Repository.xmldoc" path="declaration/member[@name='Repository.Require(GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.GLib.NullableUnownedUtf8,GISharp.Lib.GIRepository.RepositoryLoadFlags)']/*" />
        public void Require(GISharp.Lib.GLib.UnownedUtf8 @namespace, GISharp.Lib.GLib.NullableUnownedUtf8 version, GISharp.Lib.GIRepository.RepositoryLoadFlags flags = default)
        {
            CheckRequireArgs(@namespace, version, flags);
            var repository_ = (GISharp.Lib.GIRepository.Repository.UnmanagedStruct*)UnsafeHandle;
            var @namespace_ = (byte*)@namespace.UnsafeHandle;
            var version_ = (byte*)version.UnsafeHandle;
            var flags_ = (GISharp.Lib.GIRepository.RepositoryLoadFlags)flags;
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            g_irepository_require(repository_, @namespace_, version_, flags_, &error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Lib.GLib.Error.Exception(error);
            }
        }

        /// <summary>
        /// Force the namespace @namespace_ to be loaded if it isn't already.
        /// If @namespace_ is not loaded, this function will search for a
        /// ".typelib" file within the private directory only. In addition, a
        /// version @version of namespace should be specified.  If @version is
        /// not specified, the latest will be used.
        /// </summary>
        /// <param name="repository">
        /// A #GIRepository or %NULL for the singleton
        ///   process-global default #GIRepository
        /// </param>
        /// <param name="typelibDir">
        /// Private directory where to find the requested typelib
        /// </param>
        /// <param name="namespace">
        /// GI namespace to use, e.g. "Gtk"
        /// </param>
        /// <param name="version">
        /// Version of namespace, may be %NULL for latest
        /// </param>
        /// <param name="flags">
        /// Set of %GIRepositoryLoadFlags, may be 0
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// a pointer to the #GITypelib if successful, %NULL otherwise
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Typelib" type="GITypelib*" is-pointer="1" /> */
        /* transfer-ownership:none skip:1 direction:in */
        private static extern GISharp.Lib.GIRepository.Typelib.UnmanagedStruct* g_irepository_require_private(
        /* <type name="Repository" type="GIRepository*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.GIRepository.Repository.UnmanagedStruct* repository,
        /* <type name="utf8" type="const gchar*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* typelibDir,
        /* <type name="utf8" type="const gchar*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* @namespace,
        /* <type name="utf8" type="const gchar*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        byte* version,
        /* <type name="RepositoryLoadFlags" type="GIRepositoryLoadFlags" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.RepositoryLoadFlags flags,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        partial void CheckRequirePrivateArgs(GISharp.Lib.GLib.UnownedUtf8 typelibDir, GISharp.Lib.GLib.UnownedUtf8 @namespace, GISharp.Lib.GLib.NullableUnownedUtf8 version, GISharp.Lib.GIRepository.RepositoryLoadFlags flags = default);

        /// <include file="Repository.xmldoc" path="declaration/member[@name='Repository.RequirePrivate(GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.GLib.NullableUnownedUtf8,GISharp.Lib.GIRepository.RepositoryLoadFlags)']/*" />
        public void RequirePrivate(GISharp.Lib.GLib.UnownedUtf8 typelibDir, GISharp.Lib.GLib.UnownedUtf8 @namespace, GISharp.Lib.GLib.NullableUnownedUtf8 version, GISharp.Lib.GIRepository.RepositoryLoadFlags flags = default)
        {
            CheckRequirePrivateArgs(typelibDir, @namespace, version, flags);
            var repository_ = (GISharp.Lib.GIRepository.Repository.UnmanagedStruct*)UnsafeHandle;
            var typelibDir_ = (byte*)typelibDir.UnsafeHandle;
            var @namespace_ = (byte*)@namespace.UnsafeHandle;
            var version_ = (byte*)version.UnsafeHandle;
            var flags_ = (GISharp.Lib.GIRepository.RepositoryLoadFlags)flags;
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            g_irepository_require_private(repository_, typelibDir_, @namespace_, version_, flags_, &error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Lib.GLib.Error.Exception(error);
            }
        }
    }
}