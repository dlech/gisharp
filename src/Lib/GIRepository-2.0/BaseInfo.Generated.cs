// SPDX-License-Identifier: MIT
// ATTENTION: This file is automatically generated. Do not edit manually.
#nullable enable
namespace GISharp.Lib.GIRepository
{
    /// <include file="BaseInfo.xmldoc" path="declaration/member[@name='BaseInfo']/*" />
    [GISharp.Runtime.GTypeAttribute("GIBaseInfo", IsProxyForUnmanagedType = true)]
    public abstract unsafe partial class BaseInfo : GISharp.Runtime.Boxed, System.IEquatable<BaseInfo>
    {
        private static readonly GISharp.Lib.GObject.GType _GType = g_base_info_gtype_get_type();

        /// <summary>
        /// The unmanaged data structure.
        /// </summary>
        public struct UnmanagedStruct
        {
#pragma warning disable CS0169, CS0649
            /// <include file="BaseInfo.xmldoc" path="declaration/member[@name='UnmanagedStruct.Dummy1']/*" />
            private readonly int Dummy1;

            /// <include file="BaseInfo.xmldoc" path="declaration/member[@name='UnmanagedStruct.Dummy2']/*" />
            private readonly int Dummy2;

            /// <include file="BaseInfo.xmldoc" path="declaration/member[@name='UnmanagedStruct.Dummy3']/*" />
            private readonly System.IntPtr Dummy3;

            /// <include file="BaseInfo.xmldoc" path="declaration/member[@name='UnmanagedStruct.Dummy4']/*" />
            private readonly System.IntPtr Dummy4;

            /// <include file="BaseInfo.xmldoc" path="declaration/member[@name='UnmanagedStruct.Dummy5']/*" />
            private readonly System.IntPtr Dummy5;

            /// <include file="BaseInfo.xmldoc" path="declaration/member[@name='UnmanagedStruct.Dummy6']/*" />
            private readonly uint Dummy6;

            /// <include file="BaseInfo.xmldoc" path="declaration/member[@name='UnmanagedStruct.Dummy7']/*" />
            private readonly uint Dummy7;

            /// <include file="BaseInfo.xmldoc" path="declaration/member[@name='UnmanagedStruct.Padding']/*" />
            private fixed long Padding[4];
#pragma warning restore CS0169, CS0649
        }

        /// <include file="BaseInfo.xmldoc" path="declaration/member[@name='BaseInfo.Container']/*" />
        public GISharp.Lib.GIRepository.BaseInfo Container { get => GetContainer(); }

        /// <include file="BaseInfo.xmldoc" path="declaration/member[@name='BaseInfo.Name']/*" />
        public GISharp.Lib.GLib.UnownedUtf8 Name { get => GetName(); }

        /// <include file="BaseInfo.xmldoc" path="declaration/member[@name='BaseInfo.Namespace']/*" />
        public GISharp.Lib.GLib.UnownedUtf8 Namespace { get => GetNamespace(); }

        /// <include file="BaseInfo.xmldoc" path="declaration/member[@name='BaseInfo.InfoType']/*" />
        public GISharp.Lib.GIRepository.InfoType InfoType { get => GetInfoType(); }

        /// <include file="BaseInfo.xmldoc" path="declaration/member[@name='BaseInfo.Typelib']/*" />
        public GISharp.Lib.GIRepository.Typelib Typelib { get => GetTypelib(); }

        /// <include file="BaseInfo.xmldoc" path="declaration/member[@name='BaseInfo.IsDeprecated']/*" />
        public bool IsDeprecated { get => GetIsDeprecated(); }

        /// <summary>
        /// For internal runtime use only.
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        public BaseInfo(System.IntPtr handle, GISharp.Runtime.Transfer ownership) : base(handle)
        {
            if (ownership == GISharp.Runtime.Transfer.None)
            {
                this.handle = (System.IntPtr)g_base_info_ref((UnmanagedStruct*)handle);
            }
        }

        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="GType" type="GType" managed-name="GISharp.Lib.GObject.GType" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GObject.GType g_base_info_gtype_get_type();

        /// <summary>
        /// Compare two #GIBaseInfo.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Using pointer comparison is not practical since many functions return
        /// different instances of #GIBaseInfo that refers to the same part of the
        /// TypeLib; use this function instead to do #GIBaseInfo comparisons.
        /// </para>
        /// </remarks>
        /// <param name="info1">
        /// a #GIBaseInfo
        /// </param>
        /// <param name="info2">
        /// a #GIBaseInfo
        /// </param>
        /// <returns>
        /// %TRUE if and only if @info1 equals @info2.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_base_info_equal(
        /* <type name="BaseInfo" type="GIBaseInfo*" managed-name="BaseInfo" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.BaseInfo.UnmanagedStruct* info1,
        /* <type name="BaseInfo" type="GIBaseInfo*" managed-name="BaseInfo" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.BaseInfo.UnmanagedStruct* info2);
        partial void CheckEqualsArgs(GISharp.Lib.GIRepository.BaseInfo info2);

        /// <include file="BaseInfo.xmldoc" path="declaration/member[@name='BaseInfo.Equals(GISharp.Lib.GIRepository.BaseInfo?)']/*" />
        public bool Equals(GISharp.Lib.GIRepository.BaseInfo? info2)
        {
            if (info2 is null)
            {
                return false;
            }

            CheckEqualsArgs(info2);
            var info1_ = (GISharp.Lib.GIRepository.BaseInfo.UnmanagedStruct*)UnsafeHandle;
            var info2_ = (GISharp.Lib.GIRepository.BaseInfo.UnmanagedStruct*)info2.UnsafeHandle;
            var ret_ = g_base_info_equal(info1_,info2_);
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <inheritdoc/>
        public override bool Equals(object? other)
        {
            if (other is GISharp.Lib.GIRepository.BaseInfo baseInfo)
            {
                return Equals(baseInfo);
            }

            return base.Equals(other);
        }

        /// <inheritdoc/>
        public static bool operator ==(GISharp.Lib.GIRepository.BaseInfo a, GISharp.Lib.GIRepository.BaseInfo b)
        {
            return a.Equals(b);
        }

        /// <inheritdoc/>
        public static System.Boolean operator !=(GISharp.Lib.GIRepository.BaseInfo a, GISharp.Lib.GIRepository.BaseInfo b)
        {
            return !a.Equals(b);
        }

        /// <summary>
        /// Retrieve an arbitrary attribute associated with this node.
        /// </summary>
        /// <param name="info">
        /// a #GIBaseInfo
        /// </param>
        /// <param name="name">
        /// a freeform string naming an attribute
        /// </param>
        /// <returns>
        /// The value of the attribute, or %NULL if no such attribute exists
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern byte* g_base_info_get_attribute(
        /* <type name="BaseInfo" type="GIBaseInfo*" managed-name="BaseInfo" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.BaseInfo.UnmanagedStruct* info,
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* name);
        partial void CheckGetAttributeArgs(GISharp.Lib.GLib.UnownedUtf8 name);

        /// <include file="BaseInfo.xmldoc" path="declaration/member[@name='BaseInfo.GetAttribute(GISharp.Lib.GLib.UnownedUtf8)']/*" />
        public GISharp.Lib.GLib.UnownedUtf8 GetAttribute(GISharp.Lib.GLib.UnownedUtf8 name)
        {
            CheckGetAttributeArgs(name);
            var info_ = (GISharp.Lib.GIRepository.BaseInfo.UnmanagedStruct*)UnsafeHandle;
            var name_ = (byte*)name.UnsafeHandle;
            var ret_ = g_base_info_get_attribute(info_,name_);
            var ret = new GISharp.Lib.GLib.UnownedUtf8(ret_);
            return ret;
        }

        /// <summary>
        /// Obtain the container of the @info. The container is the parent
        /// GIBaseInfo. For instance, the parent of a #GIFunctionInfo is an
        /// #GIObjectInfo or #GIInterfaceInfo.
        /// </summary>
        /// <param name="info">
        /// a #GIBaseInfo
        /// </param>
        /// <returns>
        /// the container
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="BaseInfo" type="GIBaseInfo*" managed-name="BaseInfo" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GIRepository.BaseInfo.UnmanagedStruct* g_base_info_get_container(
        /* <type name="BaseInfo" type="GIBaseInfo*" managed-name="BaseInfo" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.BaseInfo.UnmanagedStruct* info);
        partial void CheckGetContainerArgs();

        private GISharp.Lib.GIRepository.BaseInfo GetContainer()
        {
            CheckGetContainerArgs();
            var info_ = (GISharp.Lib.GIRepository.BaseInfo.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_base_info_get_container(info_);
            var ret = GISharp.Lib.GIRepository.BaseInfo.GetInstance<GISharp.Lib.GIRepository.BaseInfo>((System.IntPtr)ret_, GISharp.Runtime.Transfer.None)!;
            return ret;
        }

        /// <summary>
        /// Obtain the name of the @info. What the name represents depends on
        /// the #GIInfoType of the @info. For instance for #GIFunctionInfo it is
        /// the name of the function.
        /// </summary>
        /// <param name="info">
        /// a #GIBaseInfo
        /// </param>
        /// <returns>
        /// the name of @info or %NULL if it lacks a name.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern byte* g_base_info_get_name(
        /* <type name="BaseInfo" type="GIBaseInfo*" managed-name="BaseInfo" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.BaseInfo.UnmanagedStruct* info);
        partial void CheckGetNameArgs();

        private GISharp.Lib.GLib.UnownedUtf8 GetName()
        {
            CheckGetNameArgs();
            var info_ = (GISharp.Lib.GIRepository.BaseInfo.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_base_info_get_name(info_);
            var ret = new GISharp.Lib.GLib.UnownedUtf8(ret_);
            return ret;
        }

        /// <summary>
        /// Obtain the namespace of @info.
        /// </summary>
        /// <param name="info">
        /// a #GIBaseInfo
        /// </param>
        /// <returns>
        /// the namespace
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern byte* g_base_info_get_namespace(
        /* <type name="BaseInfo" type="GIBaseInfo*" managed-name="BaseInfo" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.BaseInfo.UnmanagedStruct* info);
        partial void CheckGetNamespaceArgs();

        private GISharp.Lib.GLib.UnownedUtf8 GetNamespace()
        {
            CheckGetNamespaceArgs();
            var info_ = (GISharp.Lib.GIRepository.BaseInfo.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_base_info_get_namespace(info_);
            var ret = new GISharp.Lib.GLib.UnownedUtf8(ret_);
            return ret;
        }

        /// <summary>
        /// Obtain the info type of the GIBaseInfo.
        /// </summary>
        /// <param name="info">
        /// a #GIBaseInfo
        /// </param>
        /// <returns>
        /// the info type of @info
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="InfoType" type="GIInfoType" managed-name="InfoType" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GIRepository.InfoType g_base_info_get_type(
        /* <type name="BaseInfo" type="GIBaseInfo*" managed-name="BaseInfo" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.BaseInfo.UnmanagedStruct* info);
        partial void CheckGetInfoTypeArgs();

        private GISharp.Lib.GIRepository.InfoType GetInfoType()
        {
            CheckGetInfoTypeArgs();
            var info_ = (GISharp.Lib.GIRepository.BaseInfo.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_base_info_get_type(info_);
            var ret = (GISharp.Lib.GIRepository.InfoType)ret_;
            return ret;
        }

        /// <summary>
        /// Obtain the typelib this @info belongs to
        /// </summary>
        /// <param name="info">
        /// a #GIBaseInfo
        /// </param>
        /// <returns>
        /// the typelib.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Typelib" type="GITypelib*" managed-name="Typelib" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GIRepository.Typelib.UnmanagedStruct* g_base_info_get_typelib(
        /* <type name="BaseInfo" type="GIBaseInfo*" managed-name="BaseInfo" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.BaseInfo.UnmanagedStruct* info);
        partial void CheckGetTypelibArgs();

        private GISharp.Lib.GIRepository.Typelib GetTypelib()
        {
            CheckGetTypelibArgs();
            var info_ = (GISharp.Lib.GIRepository.BaseInfo.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_base_info_get_typelib(info_);
            var ret = GISharp.Lib.GIRepository.Typelib.GetInstance<GISharp.Lib.GIRepository.Typelib>((System.IntPtr)ret_, GISharp.Runtime.Transfer.None)!;
            return ret;
        }

        /// <summary>
        /// Obtain whether the @info is represents a metadata which is
        /// deprecated or not.
        /// </summary>
        /// <param name="info">
        /// a #GIBaseInfo
        /// </param>
        /// <returns>
        /// %TRUE if deprecated
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_base_info_is_deprecated(
        /* <type name="BaseInfo" type="GIBaseInfo*" managed-name="BaseInfo" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.BaseInfo.UnmanagedStruct* info);
        partial void CheckGetIsDeprecatedArgs();

        private bool GetIsDeprecated()
        {
            CheckGetIsDeprecatedArgs();
            var info_ = (GISharp.Lib.GIRepository.BaseInfo.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_base_info_is_deprecated(info_);
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Iterate over all attributes associated with this node.  The iterator
        /// structure is typically stack allocated, and must have its first
        /// member initialized to %NULL.  Attributes are arbitrary namespaced keyâ€“value
        /// pairs which can be attached to almost any item.  They are intended for use
        /// by software higher in the toolchain than bindings, and are distinct from
        /// normal GIR annotations.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Both the @name and @value should be treated as constants
        /// and must not be freed.
        /// </para>
        /// <para>
        /// &lt;example&gt;
        /// &lt;title&gt;Iterating over attributes&lt;/title&gt;
        /// &lt;programlisting&gt;
        /// void
        /// print_attributes (GIBaseInfo *info)
        /// {
        ///   GIAttributeIter iter = { 0, };
        ///   char *name;
        ///   char *value;
        ///   while (g_base_info_iterate_attributes (info, &amp;iter, &amp;name, &amp;value))
        ///     {
        ///       g_print ("attribute name: %s value: %s", name, value);
        ///     }
        /// }
        /// &lt;/programlisting&gt;
        /// &lt;/example&gt;
        /// </para>
        /// </remarks>
        /// <param name="info">
        /// a #GIBaseInfo
        /// </param>
        /// <param name="iterator">
        /// a #GIAttributeIter structure, must be initialized; see below
        /// </param>
        /// <param name="name">
        /// Returned name, must not be freed
        /// </param>
        /// <param name="value">
        /// Returned name, must not be freed
        /// </param>
        /// <returns>
        /// %TRUE if there are more attributes
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_base_info_iterate_attributes(
        /* <type name="BaseInfo" type="GIBaseInfo*" managed-name="BaseInfo" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.BaseInfo.UnmanagedStruct* info,
        /* <type name="AttributeIter" type="GIAttributeIter*" managed-name="AttributeIter" /> */
        /* direction:inout caller-allocates:0 transfer-ownership:full */
        GISharp.Lib.GIRepository.AttributeIter* iterator,
        /* <type name="utf8" type="char**" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* direction:out caller-allocates:0 transfer-ownership:none */
        byte** name,
        /* <type name="utf8" type="char**" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* direction:out caller-allocates:0 transfer-ownership:none */
        byte** value);
        partial void CheckTryIterateAttributesArgs(ref GISharp.Lib.GIRepository.AttributeIter iterator);

        private bool TryIterateAttributes(ref GISharp.Lib.GIRepository.AttributeIter iterator, out GISharp.Lib.GLib.UnownedUtf8 name, out GISharp.Lib.GLib.UnownedUtf8 value)
        {
            CheckTryIterateAttributesArgs(ref iterator);
            var info_ = (GISharp.Lib.GIRepository.BaseInfo.UnmanagedStruct*)UnsafeHandle;
            var iterator_ = (GISharp.Lib.GIRepository.AttributeIter)iterator;
            byte* name_;
            byte* value_;
            var ret_ = g_base_info_iterate_attributes(info_,&iterator_,&name_,&value_);
            iterator = (GISharp.Lib.GIRepository.AttributeIter)iterator_;
            name = new GISharp.Lib.GLib.UnownedUtf8(name_);
            value = new GISharp.Lib.GLib.UnownedUtf8(value_);
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Increases the reference count of @info.
        /// </summary>
        /// <param name="info">
        /// a #GIBaseInfo
        /// </param>
        /// <returns>
        /// the same @info.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="BaseInfo" type="GIBaseInfo*" managed-name="BaseInfo" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GIRepository.BaseInfo.UnmanagedStruct* g_base_info_ref(
        /* <type name="BaseInfo" type="GIBaseInfo*" managed-name="BaseInfo" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.BaseInfo.UnmanagedStruct* info);

        /// <summary>
        /// Takes ownership of the unmanaged pointer without freeing it.
        /// The managed object can no longer be used (will throw disposed exception).
        /// </summary>
        public override System.IntPtr Take() => (System.IntPtr)g_base_info_ref((GISharp.Lib.GIRepository.BaseInfo.UnmanagedStruct*)UnsafeHandle);

        /// <summary>
        /// Decreases the reference count of @info. When its reference count
        /// drops to 0, the info is freed.
        /// </summary>
        /// <param name="info">
        /// a #GIBaseInfo
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_base_info_unref(
        /* <type name="BaseInfo" type="GIBaseInfo*" managed-name="BaseInfo" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.BaseInfo.UnmanagedStruct* info);

        /// <inheritdoc/>
        protected override void Dispose(bool disposing)
        {
            if (handle != System.IntPtr.Zero)
            {
                g_base_info_unref((UnmanagedStruct*)handle);
            }

            base.Dispose(disposing);
        }
    }
}