// SPDX-License-Identifier: MIT
// ATTENTION: This file is automatically generated. Do not edit manually.
#nullable enable
namespace GISharp.Lib.GIRepository
{
    /// <include file="ObjectInfo.xmldoc" path="declaration/member[@name='ObjectInfo']/*" />
    public sealed unsafe partial class ObjectInfo : GISharp.Lib.GIRepository.RegisteredTypeInfo
    {
        /// <summary>
        /// The unmanaged data structure.
        /// </summary>
        public new struct UnmanagedStruct
        {
        }

        /// <include file="ObjectInfo.xmldoc" path="declaration/member[@name='ObjectInfo.Abstract']/*" />
        public bool Abstract { get => GetAbstract(); }

        /// <include file="ObjectInfo.xmldoc" path="declaration/member[@name='ObjectInfo.ClassStruct']/*" />
        public GISharp.Lib.GIRepository.StructInfo? ClassStruct { get => GetClassStruct(); }

        /// <include file="ObjectInfo.xmldoc" path="declaration/member[@name='ObjectInfo.Fundamental']/*" />
        public bool Fundamental { get => GetFundamental(); }

        /// <include file="ObjectInfo.xmldoc" path="declaration/member[@name='ObjectInfo.GetValueFunction']/*" />
        public GISharp.Lib.GLib.NullableUnownedUtf8 GetValueFunction { get => GetGetValueFunction(); }

        /// <include file="ObjectInfo.xmldoc" path="declaration/member[@name='ObjectInfo.NConstants']/*" />
        private int NConstants { get => GetNConstants(); }

        /// <include file="ObjectInfo.xmldoc" path="declaration/member[@name='ObjectInfo.NFields']/*" />
        private int NFields { get => GetNFields(); }

        /// <include file="ObjectInfo.xmldoc" path="declaration/member[@name='ObjectInfo.NInterfaces']/*" />
        private int NInterfaces { get => GetNInterfaces(); }

        /// <include file="ObjectInfo.xmldoc" path="declaration/member[@name='ObjectInfo.NMethods']/*" />
        private int NMethods { get => GetNMethods(); }

        /// <include file="ObjectInfo.xmldoc" path="declaration/member[@name='ObjectInfo.NProperties']/*" />
        private int NProperties { get => GetNProperties(); }

        /// <include file="ObjectInfo.xmldoc" path="declaration/member[@name='ObjectInfo.NSignals']/*" />
        private int NSignals { get => GetNSignals(); }

        /// <include file="ObjectInfo.xmldoc" path="declaration/member[@name='ObjectInfo.NVFuncs']/*" />
        private int NVFuncs { get => GetNVFuncs(); }

        /// <include file="ObjectInfo.xmldoc" path="declaration/member[@name='ObjectInfo.Parent']/*" />
        public GISharp.Lib.GIRepository.ObjectInfo? Parent { get => GetParent(); }

        /// <include file="ObjectInfo.xmldoc" path="declaration/member[@name='ObjectInfo.RefFunction']/*" />
        public GISharp.Lib.GLib.NullableUnownedUtf8 RefFunction { get => GetRefFunction(); }

        /// <include file="ObjectInfo.xmldoc" path="declaration/member[@name='ObjectInfo.SetValueFunction']/*" />
        public GISharp.Lib.GLib.NullableUnownedUtf8 SetValueFunction { get => GetSetValueFunction(); }

        /// <include file="ObjectInfo.xmldoc" path="declaration/member[@name='ObjectInfo.TypeInit']/*" />
        public new GISharp.Lib.GLib.UnownedUtf8 TypeInit { get => GetTypeInit(); }

        /// <include file="ObjectInfo.xmldoc" path="declaration/member[@name='ObjectInfo.TypeName']/*" />
        public new GISharp.Lib.GLib.UnownedUtf8 TypeName { get => GetTypeName(); }

        /// <include file="ObjectInfo.xmldoc" path="declaration/member[@name='ObjectInfo.UnrefFunction']/*" />
        public GISharp.Lib.GLib.NullableUnownedUtf8 UnrefFunction { get => GetUnrefFunction(); }

        /// <summary>
        /// For internal runtime use only.
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        public ObjectInfo(System.IntPtr handle, GISharp.Runtime.Transfer ownership) : base(handle, ownership)
        {
        }

        /// <summary>
        /// Obtain a method of the object type given a @name. %NULL will be
        /// returned if there's no method available with that name.
        /// </summary>
        /// <param name="info">
        /// a #GIObjectInfo
        /// </param>
        /// <param name="name">
        /// name of method to obtain
        /// </param>
        /// <returns>
        /// the #GIFunctionInfo. Free the struct by calling
        /// g_base_info_unref() when done.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FunctionInfo" type="GIFunctionInfo*" is-pointer="1" /> */
        /* transfer-ownership:full nullable:1 direction:in */
        private static extern GISharp.Lib.GIRepository.FunctionInfo.UnmanagedStruct* g_object_info_find_method(
        /* <type name="ObjectInfo" type="GIObjectInfo*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct* info,
        /* <type name="utf8" type="const gchar*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* name);
        partial void CheckFindMethodArgs(GISharp.Lib.GLib.UnownedUtf8 name);

        /// <include file="ObjectInfo.xmldoc" path="declaration/member[@name='ObjectInfo.FindMethod(GISharp.Lib.GLib.UnownedUtf8)']/*" />
        public GISharp.Lib.GIRepository.FunctionInfo? FindMethod(GISharp.Lib.GLib.UnownedUtf8 name)
        {
            CheckFindMethodArgs(name);
            var info_ = (GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct*)UnsafeHandle;
            var name_ = (byte*)name.UnsafeHandle;
            var ret_ = g_object_info_find_method(info_,name_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Lib.GIRepository.FunctionInfo.GetInstance<GISharp.Lib.GIRepository.FunctionInfo>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full);
            return ret;
        }

        /// <summary>
        /// Obtain a method of the object given a @name, searching both the
        /// object @info and any interfaces it implements.  %NULL will be
        /// returned if there's no method available with that name.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Note that this function does *not* search parent classes; you will have
        /// to chain up if that's desired.
        /// </para>
        /// </remarks>
        /// <param name="info">
        /// a #GIObjectInfo
        /// </param>
        /// <param name="name">
        /// name of method to obtain
        /// </param>
        /// <param name="implementor">
        /// The implementor of the interface
        /// </param>
        /// <returns>
        /// the #GIFunctionInfo. Free the struct by calling
        /// g_base_info_unref() when done.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FunctionInfo" type="GIFunctionInfo*" is-pointer="1" /> */
        /* transfer-ownership:full nullable:1 direction:in */
        private static extern GISharp.Lib.GIRepository.FunctionInfo.UnmanagedStruct* g_object_info_find_method_using_interfaces(
        /* <type name="ObjectInfo" type="GIObjectInfo*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct* info,
        /* <type name="utf8" type="const gchar*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* name,
        /* <type name="ObjectInfo" type="GIObjectInfo**" is-pointer="1" /> */
        /* direction:out caller-allocates:0 transfer-ownership:full */
        GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct** implementor);
        partial void CheckFindMethodUsingInterfacesArgs(GISharp.Lib.GLib.UnownedUtf8 name);

        /// <include file="ObjectInfo.xmldoc" path="declaration/member[@name='ObjectInfo.FindMethodUsingInterfaces(GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.GIRepository.ObjectInfo)']/*" />
        public GISharp.Lib.GIRepository.FunctionInfo? FindMethodUsingInterfaces(GISharp.Lib.GLib.UnownedUtf8 name, out GISharp.Lib.GIRepository.ObjectInfo implementor)
        {
            CheckFindMethodUsingInterfacesArgs(name);
            var info_ = (GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct*)UnsafeHandle;
            var name_ = (byte*)name.UnsafeHandle;
            GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct* implementor_;
            var ret_ = g_object_info_find_method_using_interfaces(info_,name_,&implementor_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            implementor = GISharp.Lib.GIRepository.ObjectInfo.GetInstance<GISharp.Lib.GIRepository.ObjectInfo>((System.IntPtr)implementor_, GISharp.Runtime.Transfer.Full)!;
            var ret = GISharp.Lib.GIRepository.FunctionInfo.GetInstance<GISharp.Lib.GIRepository.FunctionInfo>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full);
            return ret;
        }

        /// <summary>
        /// TODO
        /// </summary>
        /// <param name="info">
        /// a #GIObjectInfo
        /// </param>
        /// <param name="name">
        /// Name of signal
        /// </param>
        /// <returns>
        /// Info for the signal with name @name in @info, or %NULL on failure.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="SignalInfo" type="GISignalInfo*" is-pointer="1" /> */
        /* transfer-ownership:full nullable:1 direction:in */
        private static extern GISharp.Lib.GIRepository.SignalInfo.UnmanagedStruct* g_object_info_find_signal(
        /* <type name="ObjectInfo" type="GIObjectInfo*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct* info,
        /* <type name="utf8" type="const gchar*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* name);
        partial void CheckFindSignalArgs(GISharp.Lib.GLib.UnownedUtf8 name);

        /// <include file="ObjectInfo.xmldoc" path="declaration/member[@name='ObjectInfo.FindSignal(GISharp.Lib.GLib.UnownedUtf8)']/*" />
        public GISharp.Lib.GIRepository.SignalInfo? FindSignal(GISharp.Lib.GLib.UnownedUtf8 name)
        {
            CheckFindSignalArgs(name);
            var info_ = (GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct*)UnsafeHandle;
            var name_ = (byte*)name.UnsafeHandle;
            var ret_ = g_object_info_find_signal(info_,name_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Lib.GIRepository.SignalInfo.GetInstance<GISharp.Lib.GIRepository.SignalInfo>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full);
            return ret;
        }

        /// <summary>
        /// Locate a virtual function slot with name @name. Note that the namespace
        /// for virtuals is distinct from that of methods; there may or may not be
        /// a concrete method associated for a virtual. If there is one, it may
        /// be retrieved using g_vfunc_info_get_invoker(), otherwise %NULL will be
        /// returned.
        /// See the documentation for g_vfunc_info_get_invoker() for more
        /// information on invoking virtuals.
        /// </summary>
        /// <param name="info">
        /// a #GIObjectInfo
        /// </param>
        /// <param name="name">
        /// The name of a virtual function to find.
        /// </param>
        /// <returns>
        /// the #GIVFuncInfo, or %NULL. Free it with
        /// g_base_info_unref() when done.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="VFuncInfo" type="GIVFuncInfo*" is-pointer="1" /> */
        /* transfer-ownership:full nullable:1 direction:in */
        private static extern GISharp.Lib.GIRepository.VFuncInfo.UnmanagedStruct* g_object_info_find_vfunc(
        /* <type name="ObjectInfo" type="GIObjectInfo*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct* info,
        /* <type name="utf8" type="const gchar*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* name);
        partial void CheckFindVFuncArgs(GISharp.Lib.GLib.UnownedUtf8 name);

        /// <include file="ObjectInfo.xmldoc" path="declaration/member[@name='ObjectInfo.FindVFunc(GISharp.Lib.GLib.UnownedUtf8)']/*" />
        public GISharp.Lib.GIRepository.VFuncInfo? FindVFunc(GISharp.Lib.GLib.UnownedUtf8 name)
        {
            CheckFindVFuncArgs(name);
            var info_ = (GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct*)UnsafeHandle;
            var name_ = (byte*)name.UnsafeHandle;
            var ret_ = g_object_info_find_vfunc(info_,name_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Lib.GIRepository.VFuncInfo.GetInstance<GISharp.Lib.GIRepository.VFuncInfo>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full);
            return ret;
        }

        /// <summary>
        /// Locate a virtual function slot with name @name, searching both the object
        /// @info and any interfaces it implements.  Note that the namespace for
        /// virtuals is distinct from that of methods; there may or may not be a
        /// concrete method associated for a virtual. If there is one, it may be
        /// retrieved using g_vfunc_info_get_invoker(), otherwise %NULL will be
        /// returned.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Note that this function does *not* search parent classes; you will have
        /// to chain up if that's desired.
        /// </para>
        /// </remarks>
        /// <param name="info">
        /// a #GIObjectInfo
        /// </param>
        /// <param name="name">
        /// name of vfunc to obtain
        /// </param>
        /// <param name="implementor">
        /// The implementor of the interface
        /// </param>
        /// <returns>
        /// the #GIVFuncInfo. Free the struct by calling
        /// g_base_info_unref() when done.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="VFuncInfo" type="GIVFuncInfo*" is-pointer="1" /> */
        /* transfer-ownership:full nullable:1 direction:in */
        private static extern GISharp.Lib.GIRepository.VFuncInfo.UnmanagedStruct* g_object_info_find_vfunc_using_interfaces(
        /* <type name="ObjectInfo" type="GIObjectInfo*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct* info,
        /* <type name="utf8" type="const gchar*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* name,
        /* <type name="ObjectInfo" type="GIObjectInfo**" is-pointer="1" /> */
        /* direction:out caller-allocates:0 transfer-ownership:full */
        GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct** implementor);
        partial void CheckFindVFuncUsingInterfacesArgs(GISharp.Lib.GLib.UnownedUtf8 name);

        /// <include file="ObjectInfo.xmldoc" path="declaration/member[@name='ObjectInfo.FindVFuncUsingInterfaces(GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.GIRepository.ObjectInfo)']/*" />
        public GISharp.Lib.GIRepository.VFuncInfo? FindVFuncUsingInterfaces(GISharp.Lib.GLib.UnownedUtf8 name, out GISharp.Lib.GIRepository.ObjectInfo implementor)
        {
            CheckFindVFuncUsingInterfacesArgs(name);
            var info_ = (GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct*)UnsafeHandle;
            var name_ = (byte*)name.UnsafeHandle;
            GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct* implementor_;
            var ret_ = g_object_info_find_vfunc_using_interfaces(info_,name_,&implementor_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            implementor = GISharp.Lib.GIRepository.ObjectInfo.GetInstance<GISharp.Lib.GIRepository.ObjectInfo>((System.IntPtr)implementor_, GISharp.Runtime.Transfer.Full)!;
            var ret = GISharp.Lib.GIRepository.VFuncInfo.GetInstance<GISharp.Lib.GIRepository.VFuncInfo>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full);
            return ret;
        }

        /// <summary>
        /// Obtain if the object type is an abstract type, eg if it cannot be
        /// instantiated
        /// </summary>
        /// <param name="info">
        /// a #GIObjectInfo
        /// </param>
        /// <returns>
        /// %TRUE if the object type is abstract
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_object_info_get_abstract(
        /* <type name="ObjectInfo" type="GIObjectInfo*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct* info);
        partial void CheckGetAbstractArgs();

        private bool GetAbstract()
        {
            CheckGetAbstractArgs();
            var info_ = (GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_object_info_get_abstract(info_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Every #GObject has two structures; an instance structure and a class
        /// structure.  This function returns the metadata for the class structure.
        /// </summary>
        /// <param name="info">
        /// a #GIObjectInfo
        /// </param>
        /// <returns>
        /// the #GIStructInfo or %NULL. Free with
        /// g_base_info_unref() when done.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="StructInfo" type="GIStructInfo*" is-pointer="1" /> */
        /* transfer-ownership:full nullable:1 direction:in */
        private static extern GISharp.Lib.GIRepository.StructInfo.UnmanagedStruct* g_object_info_get_class_struct(
        /* <type name="ObjectInfo" type="GIObjectInfo*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct* info);
        partial void CheckGetClassStructArgs();

        private GISharp.Lib.GIRepository.StructInfo? GetClassStruct()
        {
            CheckGetClassStructArgs();
            var info_ = (GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_object_info_get_class_struct(info_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Lib.GIRepository.StructInfo.GetInstance<GISharp.Lib.GIRepository.StructInfo>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full);
            return ret;
        }

        /// <summary>
        /// Obtain an object type constant at index @n.
        /// </summary>
        /// <param name="info">
        /// a #GIObjectInfo
        /// </param>
        /// <param name="n">
        /// index of constant to get
        /// </param>
        /// <returns>
        /// the #GIConstantInfo. Free the struct by calling
        /// g_base_info_unref() when done.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="ConstantInfo" type="GIConstantInfo*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GIRepository.ConstantInfo.UnmanagedStruct* g_object_info_get_constant(
        /* <type name="ObjectInfo" type="GIObjectInfo*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct* info,
        /* <type name="gint" type="gint" /> */
        /* transfer-ownership:none direction:in */
        int n);
        partial void CheckGetConstantArgs(int n);

        private GISharp.Lib.GIRepository.ConstantInfo GetConstant(int n)
        {
            CheckGetConstantArgs(n);
            var info_ = (GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct*)UnsafeHandle;
            var n_ = (int)n;
            var ret_ = g_object_info_get_constant(info_,n_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Lib.GIRepository.ConstantInfo.GetInstance<GISharp.Lib.GIRepository.ConstantInfo>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Obtain an object type field at index @n.
        /// </summary>
        /// <param name="info">
        /// a #GIObjectInfo
        /// </param>
        /// <param name="n">
        /// index of field to get
        /// </param>
        /// <returns>
        /// the #GIFieldInfo. Free the struct by calling
        /// g_base_info_unref() when done.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FieldInfo" type="GIFieldInfo*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GIRepository.FieldInfo.UnmanagedStruct* g_object_info_get_field(
        /* <type name="ObjectInfo" type="GIObjectInfo*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct* info,
        /* <type name="gint" type="gint" /> */
        /* transfer-ownership:none direction:in */
        int n);
        partial void CheckGetFieldArgs(int n);

        private GISharp.Lib.GIRepository.FieldInfo GetField(int n)
        {
            CheckGetFieldArgs(n);
            var info_ = (GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct*)UnsafeHandle;
            var n_ = (int)n;
            var ret_ = g_object_info_get_field(info_,n_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Lib.GIRepository.FieldInfo.GetInstance<GISharp.Lib.GIRepository.FieldInfo>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Obtain if the object type is of a fundamental type which is not
        /// G_TYPE_OBJECT. This is mostly for supporting GstMiniObject.
        /// </summary>
        /// <param name="info">
        /// a #GIObjectInfo
        /// </param>
        /// <returns>
        /// %TRUE if the object type is a fundamental type
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_object_info_get_fundamental(
        /* <type name="ObjectInfo" type="GIObjectInfo*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct* info);
        partial void CheckGetFundamentalArgs();

        private bool GetFundamental()
        {
            CheckGetFundamentalArgs();
            var info_ = (GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_object_info_get_fundamental(info_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Obtain the symbol name of the function that should be called to convert
        /// an object instance pointer of this object type to a GValue.
        /// I's mainly used fundamental types. The type signature for the symbol
        /// is %GIObjectInfoGetValueFunction, to fetch the function pointer
        /// see g_object_info_get_get_value_function().
        /// </summary>
        /// <param name="info">
        /// a #GIObjectInfo
        /// </param>
        /// <returns>
        /// the symbol or %NULL
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="const char*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 direction:in */
        private static extern byte* g_object_info_get_get_value_function(
        /* <type name="ObjectInfo" type="GIObjectInfo*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct* info);
        partial void CheckGetGetValueFunctionArgs();

        private GISharp.Lib.GLib.NullableUnownedUtf8 GetGetValueFunction()
        {
            CheckGetGetValueFunctionArgs();
            var info_ = (GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_object_info_get_get_value_function(info_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = new GISharp.Lib.GLib.NullableUnownedUtf8(ret_);
            return ret;
        }

        /// <summary>
        /// Obtain an object type interface at index @n.
        /// </summary>
        /// <param name="info">
        /// a #GIObjectInfo
        /// </param>
        /// <param name="n">
        /// index of interface to get
        /// </param>
        /// <returns>
        /// the #GIInterfaceInfo. Free the struct by calling
        /// g_base_info_unref() when done.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="InterfaceInfo" type="GIInterfaceInfo*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GIRepository.InterfaceInfo.UnmanagedStruct* g_object_info_get_interface(
        /* <type name="ObjectInfo" type="GIObjectInfo*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct* info,
        /* <type name="gint" type="gint" /> */
        /* transfer-ownership:none direction:in */
        int n);
        partial void CheckGetInterfaceArgs(int n);

        private GISharp.Lib.GIRepository.InterfaceInfo GetInterface(int n)
        {
            CheckGetInterfaceArgs(n);
            var info_ = (GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct*)UnsafeHandle;
            var n_ = (int)n;
            var ret_ = g_object_info_get_interface(info_,n_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Lib.GIRepository.InterfaceInfo.GetInstance<GISharp.Lib.GIRepository.InterfaceInfo>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Obtain an object type method at index @n.
        /// </summary>
        /// <param name="info">
        /// a #GIObjectInfo
        /// </param>
        /// <param name="n">
        /// index of method to get
        /// </param>
        /// <returns>
        /// the #GIFunctionInfo. Free the struct by calling
        /// g_base_info_unref() when done.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FunctionInfo" type="GIFunctionInfo*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GIRepository.FunctionInfo.UnmanagedStruct* g_object_info_get_method(
        /* <type name="ObjectInfo" type="GIObjectInfo*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct* info,
        /* <type name="gint" type="gint" /> */
        /* transfer-ownership:none direction:in */
        int n);
        partial void CheckGetMethodArgs(int n);

        private GISharp.Lib.GIRepository.FunctionInfo GetMethod(int n)
        {
            CheckGetMethodArgs(n);
            var info_ = (GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct*)UnsafeHandle;
            var n_ = (int)n;
            var ret_ = g_object_info_get_method(info_,n_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Lib.GIRepository.FunctionInfo.GetInstance<GISharp.Lib.GIRepository.FunctionInfo>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Obtain the number of constants that this object type has.
        /// </summary>
        /// <param name="info">
        /// a #GIObjectInfo
        /// </param>
        /// <returns>
        /// number of constants
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gint" type="gint" /> */
        /* transfer-ownership:none direction:in */
        private static extern int g_object_info_get_n_constants(
        /* <type name="ObjectInfo" type="GIObjectInfo*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct* info);
        partial void CheckGetNConstantsArgs();

        private int GetNConstants()
        {
            CheckGetNConstantsArgs();
            var info_ = (GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_object_info_get_n_constants(info_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = (int)ret_;
            return ret;
        }

        /// <summary>
        /// Obtain the number of fields that this object type has.
        /// </summary>
        /// <param name="info">
        /// a #GIObjectInfo
        /// </param>
        /// <returns>
        /// number of fields
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gint" type="gint" /> */
        /* transfer-ownership:none direction:in */
        private static extern int g_object_info_get_n_fields(
        /* <type name="ObjectInfo" type="GIObjectInfo*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct* info);
        partial void CheckGetNFieldsArgs();

        private int GetNFields()
        {
            CheckGetNFieldsArgs();
            var info_ = (GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_object_info_get_n_fields(info_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = (int)ret_;
            return ret;
        }

        /// <summary>
        /// Obtain the number of interfaces that this object type has.
        /// </summary>
        /// <param name="info">
        /// a #GIObjectInfo
        /// </param>
        /// <returns>
        /// number of interfaces
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gint" type="gint" /> */
        /* transfer-ownership:none direction:in */
        private static extern int g_object_info_get_n_interfaces(
        /* <type name="ObjectInfo" type="GIObjectInfo*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct* info);
        partial void CheckGetNInterfacesArgs();

        private int GetNInterfaces()
        {
            CheckGetNInterfacesArgs();
            var info_ = (GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_object_info_get_n_interfaces(info_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = (int)ret_;
            return ret;
        }

        /// <summary>
        /// Obtain the number of methods that this object type has.
        /// </summary>
        /// <param name="info">
        /// a #GIObjectInfo
        /// </param>
        /// <returns>
        /// number of methods
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gint" type="gint" /> */
        /* transfer-ownership:none direction:in */
        private static extern int g_object_info_get_n_methods(
        /* <type name="ObjectInfo" type="GIObjectInfo*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct* info);
        partial void CheckGetNMethodsArgs();

        private int GetNMethods()
        {
            CheckGetNMethodsArgs();
            var info_ = (GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_object_info_get_n_methods(info_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = (int)ret_;
            return ret;
        }

        /// <summary>
        /// Obtain the number of properties that this object type has.
        /// </summary>
        /// <param name="info">
        /// a #GIObjectInfo
        /// </param>
        /// <returns>
        /// number of properties
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gint" type="gint" /> */
        /* transfer-ownership:none direction:in */
        private static extern int g_object_info_get_n_properties(
        /* <type name="ObjectInfo" type="GIObjectInfo*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct* info);
        partial void CheckGetNPropertiesArgs();

        private int GetNProperties()
        {
            CheckGetNPropertiesArgs();
            var info_ = (GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_object_info_get_n_properties(info_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = (int)ret_;
            return ret;
        }

        /// <summary>
        /// Obtain the number of signals that this object type has.
        /// </summary>
        /// <param name="info">
        /// a #GIObjectInfo
        /// </param>
        /// <returns>
        /// number of signals
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gint" type="gint" /> */
        /* transfer-ownership:none direction:in */
        private static extern int g_object_info_get_n_signals(
        /* <type name="ObjectInfo" type="GIObjectInfo*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct* info);
        partial void CheckGetNSignalsArgs();

        private int GetNSignals()
        {
            CheckGetNSignalsArgs();
            var info_ = (GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_object_info_get_n_signals(info_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = (int)ret_;
            return ret;
        }

        /// <summary>
        /// Obtain the number of virtual functions that this object type has.
        /// </summary>
        /// <param name="info">
        /// a #GIObjectInfo
        /// </param>
        /// <returns>
        /// number of virtual functions
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gint" type="gint" /> */
        /* transfer-ownership:none direction:in */
        private static extern int g_object_info_get_n_vfuncs(
        /* <type name="ObjectInfo" type="GIObjectInfo*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct* info);
        partial void CheckGetNVFuncsArgs();

        private int GetNVFuncs()
        {
            CheckGetNVFuncsArgs();
            var info_ = (GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_object_info_get_n_vfuncs(info_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = (int)ret_;
            return ret;
        }

        /// <summary>
        /// Obtain the parent of the object type.
        /// </summary>
        /// <param name="info">
        /// a #GIObjectInfo
        /// </param>
        /// <returns>
        /// the #GIObjectInfo. Free the struct by calling
        /// g_base_info_unref() when done.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="ObjectInfo" type="GIObjectInfo*" is-pointer="1" /> */
        /* transfer-ownership:full nullable:1 direction:in */
        private static extern GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct* g_object_info_get_parent(
        /* <type name="ObjectInfo" type="GIObjectInfo*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct* info);
        partial void CheckGetParentArgs();

        private GISharp.Lib.GIRepository.ObjectInfo? GetParent()
        {
            CheckGetParentArgs();
            var info_ = (GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_object_info_get_parent(info_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Lib.GIRepository.ObjectInfo.GetInstance<GISharp.Lib.GIRepository.ObjectInfo>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full);
            return ret;
        }

        /// <summary>
        /// Obtain an object type property at index @n.
        /// </summary>
        /// <param name="info">
        /// a #GIObjectInfo
        /// </param>
        /// <param name="n">
        /// index of property to get
        /// </param>
        /// <returns>
        /// the #GIPropertyInfo. Free the struct by calling
        /// g_base_info_unref() when done.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="PropertyInfo" type="GIPropertyInfo*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GIRepository.PropertyInfo.UnmanagedStruct* g_object_info_get_property(
        /* <type name="ObjectInfo" type="GIObjectInfo*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct* info,
        /* <type name="gint" type="gint" /> */
        /* transfer-ownership:none direction:in */
        int n);
        partial void CheckGetPropertyArgs(int n);

        private GISharp.Lib.GIRepository.PropertyInfo GetProperty(int n)
        {
            CheckGetPropertyArgs(n);
            var info_ = (GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct*)UnsafeHandle;
            var n_ = (int)n;
            var ret_ = g_object_info_get_property(info_,n_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Lib.GIRepository.PropertyInfo.GetInstance<GISharp.Lib.GIRepository.PropertyInfo>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Obtain the symbol name of the function that should be called to ref this
        /// object type. It's mainly used fundamental types. The type signature for
        /// the symbol is %GIObjectInfoRefFunction, to fetch the function pointer
        /// see g_object_info_get_ref_function().
        /// </summary>
        /// <param name="info">
        /// a #GIObjectInfo
        /// </param>
        /// <returns>
        /// the symbol or %NULL
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="const char*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 direction:in */
        private static extern byte* g_object_info_get_ref_function(
        /* <type name="ObjectInfo" type="GIObjectInfo*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct* info);
        partial void CheckGetRefFunctionArgs();

        private GISharp.Lib.GLib.NullableUnownedUtf8 GetRefFunction()
        {
            CheckGetRefFunctionArgs();
            var info_ = (GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_object_info_get_ref_function(info_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = new GISharp.Lib.GLib.NullableUnownedUtf8(ret_);
            return ret;
        }

        /// <summary>
        /// Obtain the symbol name of the function that should be called to convert
        /// set a GValue giving an object instance pointer of this object type.
        /// I's mainly used fundamental types. The type signature for the symbol
        /// is %GIObjectInfoSetValueFunction, to fetch the function pointer
        /// see g_object_info_get_set_value_function().
        /// </summary>
        /// <param name="info">
        /// a #GIObjectInfo
        /// </param>
        /// <returns>
        /// the symbol or %NULL
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="const char*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 direction:in */
        private static extern byte* g_object_info_get_set_value_function(
        /* <type name="ObjectInfo" type="GIObjectInfo*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct* info);
        partial void CheckGetSetValueFunctionArgs();

        private GISharp.Lib.GLib.NullableUnownedUtf8 GetSetValueFunction()
        {
            CheckGetSetValueFunctionArgs();
            var info_ = (GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_object_info_get_set_value_function(info_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = new GISharp.Lib.GLib.NullableUnownedUtf8(ret_);
            return ret;
        }

        /// <summary>
        /// Obtain an object type signal at index @n.
        /// </summary>
        /// <param name="info">
        /// a #GIObjectInfo
        /// </param>
        /// <param name="n">
        /// index of signal to get
        /// </param>
        /// <returns>
        /// the #GISignalInfo. Free the struct by calling
        /// g_base_info_unref() when done.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="SignalInfo" type="GISignalInfo*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GIRepository.SignalInfo.UnmanagedStruct* g_object_info_get_signal(
        /* <type name="ObjectInfo" type="GIObjectInfo*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct* info,
        /* <type name="gint" type="gint" /> */
        /* transfer-ownership:none direction:in */
        int n);
        partial void CheckGetSignalArgs(int n);

        private GISharp.Lib.GIRepository.SignalInfo GetSignal(int n)
        {
            CheckGetSignalArgs(n);
            var info_ = (GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct*)UnsafeHandle;
            var n_ = (int)n;
            var ret_ = g_object_info_get_signal(info_,n_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Lib.GIRepository.SignalInfo.GetInstance<GISharp.Lib.GIRepository.SignalInfo>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Obtain the function which when called will return the GType
        /// function for which this object type is registered.
        /// </summary>
        /// <param name="info">
        /// a #GIObjectInfo
        /// </param>
        /// <returns>
        /// the type init function
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="const gchar*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern byte* g_object_info_get_type_init(
        /* <type name="ObjectInfo" type="GIObjectInfo*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct* info);
        partial void CheckGetTypeInitArgs();

        private GISharp.Lib.GLib.UnownedUtf8 GetTypeInit()
        {
            CheckGetTypeInitArgs();
            var info_ = (GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_object_info_get_type_init(info_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = new GISharp.Lib.GLib.UnownedUtf8(ret_);
            return ret;
        }

        /// <summary>
        /// Obtain the name of the objects class/type.
        /// </summary>
        /// <param name="info">
        /// a #GIObjectInfo
        /// </param>
        /// <returns>
        /// name of the objects type
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="const gchar*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern byte* g_object_info_get_type_name(
        /* <type name="ObjectInfo" type="GIObjectInfo*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct* info);
        partial void CheckGetTypeNameArgs();

        private GISharp.Lib.GLib.UnownedUtf8 GetTypeName()
        {
            CheckGetTypeNameArgs();
            var info_ = (GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_object_info_get_type_name(info_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = new GISharp.Lib.GLib.UnownedUtf8(ret_);
            return ret;
        }

        /// <summary>
        /// Obtain the symbol name of the function that should be called to unref this
        /// object type. It's mainly used fundamental types. The type signature for
        /// the symbol is %GIObjectInfoUnrefFunction, to fetch the function pointer
        /// see g_object_info_get_unref_function().
        /// </summary>
        /// <param name="info">
        /// a #GIObjectInfo
        /// </param>
        /// <returns>
        /// the symbol or %NULL
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="const char*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 direction:in */
        private static extern byte* g_object_info_get_unref_function(
        /* <type name="ObjectInfo" type="GIObjectInfo*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct* info);
        partial void CheckGetUnrefFunctionArgs();

        private GISharp.Lib.GLib.NullableUnownedUtf8 GetUnrefFunction()
        {
            CheckGetUnrefFunctionArgs();
            var info_ = (GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_object_info_get_unref_function(info_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = new GISharp.Lib.GLib.NullableUnownedUtf8(ret_);
            return ret;
        }

        /// <summary>
        /// Obtain an object type virtual function at index @n.
        /// </summary>
        /// <param name="info">
        /// a #GIObjectInfo
        /// </param>
        /// <param name="n">
        /// index of virtual function to get
        /// </param>
        /// <returns>
        /// the #GIVFuncInfo. Free the struct by calling
        /// g_base_info_unref() when done.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="VFuncInfo" type="GIVFuncInfo*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GIRepository.VFuncInfo.UnmanagedStruct* g_object_info_get_vfunc(
        /* <type name="ObjectInfo" type="GIObjectInfo*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct* info,
        /* <type name="gint" type="gint" /> */
        /* transfer-ownership:none direction:in */
        int n);
        partial void CheckGetVFuncArgs(int n);

        private GISharp.Lib.GIRepository.VFuncInfo GetVFunc(int n)
        {
            CheckGetVFuncArgs(n);
            var info_ = (GISharp.Lib.GIRepository.ObjectInfo.UnmanagedStruct*)UnsafeHandle;
            var n_ = (int)n;
            var ret_ = g_object_info_get_vfunc(info_,n_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Lib.GIRepository.VFuncInfo.GetInstance<GISharp.Lib.GIRepository.VFuncInfo>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }
    }
}