// SPDX-License-Identifier: MIT
// ATTENTION: This file is automatically generated. Do not edit manually.
#nullable enable
namespace GISharp.Lib.GObject
{
    /// <include file="Enum.xmldoc" path="declaration/member[@name='Enum']/*" />
    public static unsafe partial class Enum
    {
        /// <summary>
        /// This function is meant to be called from the `complete_type_info`
        /// function of a #GTypePlugin implementation, as in the following
        /// example:
        /// </summary>
        /// <remarks>
        /// <para>
        /// |[&lt;!-- language="C" --&gt;
        /// static void
        /// my_enum_complete_type_info (GTypePlugin     *plugin,
        ///                             GType            g_type,
        ///                             GTypeInfo       *info,
        ///                             GTypeValueTable *value_table)
        /// {
        ///   static const GEnumValue values[] = {
        ///     { MY_ENUM_FOO, "MY_ENUM_FOO", "foo" },
        ///     { MY_ENUM_BAR, "MY_ENUM_BAR", "bar" },
        ///     { 0, NULL, NULL }
        ///   };
        /// </para>
        /// <para>
        ///   g_enum_complete_type_info (type, info, values);
        /// }
        /// ]|
        /// </para>
        /// </remarks>
        /// <param name="gEnumType">
        /// the type identifier of the type being completed
        /// </param>
        /// <param name="info">
        /// the #GTypeInfo struct to be filled in
        /// </param>
        /// <param name="constValues">
        /// An array of #GEnumValue structs for the possible
        ///  enumeration values. The array is terminated by a struct with all
        ///  members being 0.
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_enum_complete_type_info(
        /* <type name="GType" type="GType" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.GType gEnumType,
        /* <type name="TypeInfo" type="GTypeInfo*" /> */
        /* direction:out caller-allocates:0 transfer-ownership:full */
        GISharp.Lib.GObject.TypeInfo* info,
        /* <array zero-terminated="1" type="const GEnumValue*" is-pointer="1">
*   <type name="EnumValue" type="const GEnumValue" />
* </array> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.EnumValue* constValues);
        static partial void CheckCompleteTypeInfoArgs(GISharp.Runtime.GType gEnumType, GISharp.Runtime.UnownedZeroTerminatedCArray<GISharp.Lib.GObject.EnumValue> constValues);

        /// <include file="Enum.xmldoc" path="declaration/member[@name='Enum.CompleteTypeInfo(GISharp.Runtime.GType,GISharp.Lib.GObject.TypeInfo,GISharp.Runtime.UnownedZeroTerminatedCArray&lt;GISharp.Lib.GObject.EnumValue&gt;)']/*" />
        public static void CompleteTypeInfo(GISharp.Runtime.GType gEnumType, out GISharp.Lib.GObject.TypeInfo info, GISharp.Runtime.UnownedZeroTerminatedCArray<GISharp.Lib.GObject.EnumValue> constValues)
        {
            fixed (GISharp.Lib.GObject.EnumValue* constValuesData_ = constValues)
            {
                CheckCompleteTypeInfoArgs(gEnumType, constValues);
                var gEnumType_ = (GISharp.Runtime.GType)gEnumType;
                var constValues_ = (GISharp.Lib.GObject.EnumValue*)constValuesData_;
                GISharp.Lib.GObject.TypeInfo info_;
                g_enum_complete_type_info(gEnumType_, &info_, constValues_);
                GISharp.Runtime.GMarshal.PopUnhandledException();
                info = (GISharp.Lib.GObject.TypeInfo)info_;
            }
        }

        /// <summary>
        /// Returns the #GEnumValue for a value.
        /// </summary>
        /// <param name="enumClass">
        /// a #GEnumClass
        /// </param>
        /// <param name="value">
        /// the value to look up
        /// </param>
        /// <returns>
        /// the #GEnumValue for @value, or %NULL
        ///          if @value is not a member of the enumeration
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="EnumValue" type="GEnumValue*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 direction:in */
        private static extern GISharp.Lib.GObject.EnumValue* g_enum_get_value(
        /* <type name="EnumClass" type="GEnumClass*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.EnumClass.UnmanagedStruct* enumClass,
        /* <type name="gint" type="gint" /> */
        /* transfer-ownership:none direction:in */
        int value);
        static partial void CheckGetValueArgs(GISharp.Lib.GObject.EnumClass enumClass, int value);

        /// <include file="Enum.xmldoc" path="declaration/member[@name='Enum.GetValue(GISharp.Lib.GObject.EnumClass,int)']/*" />
        public static ref readonly GISharp.Lib.GObject.EnumValue GetValue(GISharp.Lib.GObject.EnumClass enumClass, int value)
        {
            CheckGetValueArgs(enumClass, value);
            var enumClass_ = (GISharp.Lib.GObject.EnumClass.UnmanagedStruct*)enumClass.UnsafeHandle;
            var value_ = (int)value;
            var ret_ = g_enum_get_value(enumClass_,value_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            ref var ret = ref System.Runtime.CompilerServices.Unsafe.AsRef<GISharp.Lib.GObject.EnumValue>(ret_);
            return ref ret;
        }

        /// <summary>
        /// Looks up a #GEnumValue by name.
        /// </summary>
        /// <param name="enumClass">
        /// a #GEnumClass
        /// </param>
        /// <param name="name">
        /// the name to look up
        /// </param>
        /// <returns>
        /// the #GEnumValue with name @name,
        ///          or %NULL if the enumeration doesn't have a member
        ///          with that name
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="EnumValue" type="GEnumValue*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 direction:in */
        private static extern GISharp.Lib.GObject.EnumValue* g_enum_get_value_by_name(
        /* <type name="EnumClass" type="GEnumClass*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.EnumClass.UnmanagedStruct* enumClass,
        /* <type name="utf8" type="const gchar*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* name);
        static partial void CheckGetValueByNameArgs(GISharp.Lib.GObject.EnumClass enumClass, GISharp.Runtime.UnownedUtf8 name);

        /// <include file="Enum.xmldoc" path="declaration/member[@name='Enum.GetValueByName(GISharp.Lib.GObject.EnumClass,GISharp.Runtime.UnownedUtf8)']/*" />
        public static ref readonly GISharp.Lib.GObject.EnumValue GetValueByName(GISharp.Lib.GObject.EnumClass enumClass, GISharp.Runtime.UnownedUtf8 name)
        {
            CheckGetValueByNameArgs(enumClass, name);
            var enumClass_ = (GISharp.Lib.GObject.EnumClass.UnmanagedStruct*)enumClass.UnsafeHandle;
            var name_ = (byte*)name.UnsafeHandle;
            var ret_ = g_enum_get_value_by_name(enumClass_,name_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            ref var ret = ref System.Runtime.CompilerServices.Unsafe.AsRef<GISharp.Lib.GObject.EnumValue>(ret_);
            return ref ret;
        }

        /// <summary>
        /// Looks up a #GEnumValue by nickname.
        /// </summary>
        /// <param name="enumClass">
        /// a #GEnumClass
        /// </param>
        /// <param name="nick">
        /// the nickname to look up
        /// </param>
        /// <returns>
        /// the #GEnumValue with nickname @nick,
        ///          or %NULL if the enumeration doesn't have a member
        ///          with that nickname
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="EnumValue" type="GEnumValue*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 direction:in */
        private static extern GISharp.Lib.GObject.EnumValue* g_enum_get_value_by_nick(
        /* <type name="EnumClass" type="GEnumClass*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.EnumClass.UnmanagedStruct* enumClass,
        /* <type name="utf8" type="const gchar*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* nick);
        static partial void CheckGetValueByNickArgs(GISharp.Lib.GObject.EnumClass enumClass, GISharp.Runtime.UnownedUtf8 nick);

        /// <include file="Enum.xmldoc" path="declaration/member[@name='Enum.GetValueByNick(GISharp.Lib.GObject.EnumClass,GISharp.Runtime.UnownedUtf8)']/*" />
        public static ref readonly GISharp.Lib.GObject.EnumValue GetValueByNick(GISharp.Lib.GObject.EnumClass enumClass, GISharp.Runtime.UnownedUtf8 nick)
        {
            CheckGetValueByNickArgs(enumClass, nick);
            var enumClass_ = (GISharp.Lib.GObject.EnumClass.UnmanagedStruct*)enumClass.UnsafeHandle;
            var nick_ = (byte*)nick.UnsafeHandle;
            var ret_ = g_enum_get_value_by_nick(enumClass_,nick_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            ref var ret = ref System.Runtime.CompilerServices.Unsafe.AsRef<GISharp.Lib.GObject.EnumValue>(ret_);
            return ref ret;
        }

        /// <summary>
        /// Registers a new static enumeration type with the name @name.
        /// </summary>
        /// <remarks>
        /// <para>
        /// It is normally more convenient to let [glib-mkenums][glib-mkenums],
        /// generate a my_enum_get_type() function from a usual C enumeration
        /// definition  than to write one yourself using g_enum_register_static().
        /// </para>
        /// </remarks>
        /// <param name="name">
        /// A nul-terminated string used as the name of the new type.
        /// </param>
        /// <param name="constStaticValues">
        /// An array of #GEnumValue structs for the possible
        ///  enumeration values. The array is terminated by a struct with all
        ///  members being 0. GObject keeps a reference to the data, so it cannot
        ///  be stack-allocated.
        /// </param>
        /// <returns>
        /// The new type identifier.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="GType" type="GType" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.GType g_enum_register_static(
        /* <type name="utf8" type="const gchar*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* name,
        /* <array zero-terminated="1" type="const GEnumValue*" is-pointer="1">
*   <type name="EnumValue" type="const GEnumValue" />
* </array> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.EnumValue* constStaticValues);
        static partial void CheckRegisterStaticArgs(GISharp.Runtime.UnownedUtf8 name, GISharp.Runtime.UnownedZeroTerminatedCArray<GISharp.Lib.GObject.EnumValue> constStaticValues);

        /// <include file="Enum.xmldoc" path="declaration/member[@name='Enum.RegisterStatic(GISharp.Runtime.UnownedUtf8,GISharp.Runtime.UnownedZeroTerminatedCArray&lt;GISharp.Lib.GObject.EnumValue&gt;)']/*" />
        public static GISharp.Runtime.GType RegisterStatic(GISharp.Runtime.UnownedUtf8 name, GISharp.Runtime.UnownedZeroTerminatedCArray<GISharp.Lib.GObject.EnumValue> constStaticValues)
        {
            fixed (GISharp.Lib.GObject.EnumValue* constStaticValuesData_ = constStaticValues)
            {
                CheckRegisterStaticArgs(name, constStaticValues);
                var name_ = (byte*)name.UnsafeHandle;
                var constStaticValues_ = (GISharp.Lib.GObject.EnumValue*)constStaticValuesData_;
                var ret_ = g_enum_register_static(name_,constStaticValues_);
                GISharp.Runtime.GMarshal.PopUnhandledException();
                var ret = (GISharp.Runtime.GType)ret_;
                return ret;
            }
        }

        /// <summary>
        /// Pretty-prints @value in the form of the enumâ€™s name.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This is intended to be used for debugging purposes. The format of the output
        /// may change in the future.
        /// </para>
        /// </remarks>
        /// <param name="gEnumType">
        /// the type identifier of a #GEnumClass type
        /// </param>
        /// <param name="value">
        /// the value
        /// </param>
        /// <returns>
        /// a newly-allocated text string
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.54")]
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="gchar*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern byte* g_enum_to_string(
        /* <type name="GType" type="GType" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.GType gEnumType,
        /* <type name="gint" type="gint" /> */
        /* transfer-ownership:none direction:in */
        int value);
        static partial void CheckToStringArgs(GISharp.Runtime.GType gEnumType, int value);

        /// <include file="Enum.xmldoc" path="declaration/member[@name='Enum.ToString(GISharp.Runtime.GType,int)']/*" />
        [GISharp.Runtime.SinceAttribute("2.54")]
        public static GISharp.Runtime.Utf8 ToString(GISharp.Runtime.GType gEnumType, int value)
        {
            CheckToStringArgs(gEnumType, value);
            var gEnumType_ = (GISharp.Runtime.GType)gEnumType;
            var value_ = (int)value;
            var ret_ = g_enum_to_string(gEnumType_,value_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Runtime.Utf8.GetInstance<GISharp.Runtime.Utf8>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }
    }
}