// SPDX-License-Identifier: MIT
// ATTENTION: This file is automatically generated. Do not edit manually.
#nullable enable
namespace GISharp.Lib.GObject
{
    /// <include file="Object.xmldoc" path="declaration/member[@name='Object']/*" />
    [GISharp.Runtime.GTypeAttribute("GObject", IsProxyForUnmanagedType = true)]
    [GISharp.Runtime.GTypeStructAttribute(typeof(ObjectClass))]
    public unsafe partial class Object : GISharp.Lib.GObject.TypeInstance
    {
        private static readonly GISharp.Lib.GObject.GType _GType = g_object_get_type();

        /// <summary>
        /// The unmanaged data structure.
        /// </summary>
        public new struct UnmanagedStruct
        {
#pragma warning disable CS0169, CS0649
            /// <include file="Object.xmldoc" path="declaration/member[@name='UnmanagedStruct.GTypeInstance']/*" />
            public readonly GISharp.Lib.GObject.TypeInstance GTypeInstance;

            /// <include file="Object.xmldoc" path="declaration/member[@name='UnmanagedStruct.RefCount']/*" />
            private readonly uint RefCount;

            /// <include file="Object.xmldoc" path="declaration/member[@name='UnmanagedStruct.Qdata']/*" />
            private readonly GISharp.Lib.GLib.Data.UnmanagedStruct* Qdata;
#pragma warning restore CS0169, CS0649
        }

        /// <include file="Object.xmldoc" path="declaration/member[@name='Object.IsFloating']/*" />
        [GISharp.Runtime.SinceAttribute("2.10")]
        public System.Boolean IsFloating { get => GetIsFloating(); }

        /// <summary>
        /// For internal runtime use only.
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        public Object(System.IntPtr handle, GISharp.Runtime.Transfer ownership) : base(handle)
        {
            if (ownership == GISharp.Runtime.Transfer.None)
            {
                this.handle = (System.IntPtr)g_object_ref((UnmanagedStruct*)handle);
            }
        }

        /// <summary>
        /// Creates a new instance of a #GObject subtype and sets its properties.
        /// </summary>
        /// <remarks>
        /// Construction parameters (see #G_PARAM_CONSTRUCT, #G_PARAM_CONSTRUCT_ONLY)
        /// which are not explicitly specified are set to their default values.
        /// </remarks>
        /// <param name="objectType">
        /// the type id of the #GObject subtype to instantiate
        /// </param>
        /// <param name="nParameters">
        /// the length of the @parameters array
        /// </param>
        /// <param name="parameters">
        /// an array of #GParameter
        /// </param>
        /// <returns>
        /// a new instance of
        /// @object_type
        /// </returns>
        [System.ObsoleteAttribute("Use g_object_new_with_properties() instead.\ndeprecated. See #GParameter for more information.")]
        [GISharp.Runtime.DeprecatedSinceAttribute("2.54")]
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Object" type="gpointer" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GObject.Object.UnmanagedStruct* g_object_newv(
        /* <type name="GType" type="GType" managed-name="GISharp.Lib.GObject.GType" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.GType objectType,
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        uint nParameters,
        /* <array length="1" zero-terminated="0" type="GParameter*" managed-name="GISharp.Runtime.CArray" is-pointer="1">
*   <type name="Parameter" type="GParameter" managed-name="Parameter" />
* </array> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Parameter* parameters);
        static partial void CheckNewvArgs(GISharp.Lib.GObject.GType objectType, System.ReadOnlySpan<GISharp.Lib.GObject.Parameter> parameters);

        [System.ObsoleteAttribute("Use g_object_new_with_properties() instead.\ndeprecated. See #GParameter for more information.")]
        [GISharp.Runtime.DeprecatedSinceAttribute("2.54")]
        static GISharp.Lib.GObject.Object.UnmanagedStruct* Newv(GISharp.Lib.GObject.GType objectType, System.ReadOnlySpan<GISharp.Lib.GObject.Parameter> parameters)
        {
            fixed (GISharp.Lib.GObject.Parameter* parametersData_ = parameters)
            {
                CheckNewvArgs(objectType, parameters);
                var objectType_ = (GISharp.Lib.GObject.GType)objectType;
                var parameters_ = (GISharp.Lib.GObject.Parameter*)parametersData_;
                var nParameters_ = (uint)parameters.Length;
                var ret_ = g_object_newv(objectType_,nParameters_,parameters_);
                return ret_;
            }
        }

        /// <include file="Object.xmldoc" path="declaration/member[@name='Object.Object(GISharp.Lib.GObject.GType,System.ReadOnlySpan&lt;GISharp.Lib.GObject.Parameter&gt;)']/*" />
        [System.ObsoleteAttribute("Use g_object_new_with_properties() instead.\ndeprecated. See #GParameter for more information.")]
        [GISharp.Runtime.DeprecatedSinceAttribute("2.54")]
        public Object(GISharp.Lib.GObject.GType objectType, System.ReadOnlySpan<GISharp.Lib.GObject.Parameter> parameters) : this((System.IntPtr)Newv(objectType, parameters), GISharp.Runtime.Transfer.Full)
        {
        }

        readonly GISharp.Runtime.GSignalManager<NotifySignalHandler> notifySignalSignalManager = new GISharp.Runtime.GSignalManager<NotifySignalHandler>("notify", _GType);

        /// <include file="Object.xmldoc" path="declaration/member[@name='NotifySignalHandler']/*" />
        public delegate void NotifySignalHandler(GISharp.Lib.GObject.Object @object, GISharp.Lib.GObject.ParamSpec pspec);

        /// <include file="Object.xmldoc" path="declaration/member[@name='Object.NotifySignal']/*" />
        [GISharp.Runtime.GSignalAttribute("notify", When = GISharp.Runtime.EmissionStage.First, IsNoRecurse = true, IsDetailed = true, IsAction = true, IsNoHooks = true)]
        public event NotifySignalHandler NotifySignal { add => notifySignalSignalManager.Add(this, value); remove => notifySignalSignalManager.Remove(value); }

        [System.Runtime.InteropServices.UnmanagedCallersOnlyAttribute(CallConvs = new[] { typeof(System.Runtime.CompilerServices.CallConvCdecl) })]
        private static void ManagedNotifySignalHandler(GISharp.Lib.GObject.Object.UnmanagedStruct* @object_, GISharp.Lib.GObject.ParamSpec.UnmanagedStruct* pspec_, System.IntPtr userData_)
        {
            try
            {
                var @object = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GObject.Object>((System.IntPtr)@object_, GISharp.Runtime.Transfer.None)!;
                var pspec = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GObject.ParamSpec>((System.IntPtr)pspec_, GISharp.Runtime.Transfer.None)!;
                var gcHandle = (System.Runtime.InteropServices.GCHandle)userData_;
                var userData = (GISharp.Runtime.CClosureData)gcHandle.Target!;
                ((NotifySignalHandler)userData.Callback)(@object, pspec);
            }
            catch (System.Exception ex)
            {
                GISharp.Lib.GLib.Log.LogUnhandledException(ex);
            }
        }

        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gsize" type="gsize" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        private static extern nuint g_object_compat_control(
/* <type name="gsize" type="gsize" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
nuint what,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr data);
        static partial void CheckCompatControlArgs(int what, System.IntPtr data);

        /// <include file="Object.xmldoc" path="declaration/member[@name='Object.CompatControl(int,System.IntPtr)']/*" />
        public static int CompatControl(int what, System.IntPtr data)
        {
            CheckCompatControlArgs(what, data);
            var what_ = (nuint)what;
            var data_ = (System.IntPtr)data;
            var ret_ = g_object_compat_control(what_,data_);
            var ret = (int)ret_;
            return ret;
        }

        /// <summary>
        /// Find the #GParamSpec with the given name for an
        /// interface. Generally, the interface vtable passed in as @g_iface
        /// will be the default vtable from g_type_default_interface_ref(), or,
        /// if you know the interface has already been loaded,
        /// g_type_default_interface_peek().
        /// </summary>
        /// <param name="gIface">
        /// any interface vtable for the
        ///  interface, or the default vtable for the interface
        /// </param>
        /// <param name="propertyName">
        /// name of a property to look up.
        /// </param>
        /// <returns>
        /// the #GParamSpec for the property of the
        ///          interface with the name @property_name, or %NULL if no
        ///          such property exists.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.4")]
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="ParamSpec" type="GParamSpec*" managed-name="ParamSpec" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GObject.ParamSpec.UnmanagedStruct* g_object_interface_find_property(
        /* <type name="TypeInterface" type="gpointer" managed-name="TypeInterface" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.TypeInterface.UnmanagedStruct* gIface,
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* propertyName);
        static partial void CheckInterfaceFindPropertyArgs(GISharp.Lib.GObject.TypeInterface gIface, GISharp.Lib.GLib.UnownedUtf8 propertyName);

        /// <include file="Object.xmldoc" path="declaration/member[@name='Object.InterfaceFindProperty(GISharp.Lib.GObject.TypeInterface,GISharp.Lib.GLib.UnownedUtf8)']/*" />
        [GISharp.Runtime.SinceAttribute("2.4")]
        public static GISharp.Lib.GObject.ParamSpec InterfaceFindProperty(GISharp.Lib.GObject.TypeInterface gIface, GISharp.Lib.GLib.UnownedUtf8 propertyName)
        {
            CheckInterfaceFindPropertyArgs(gIface, propertyName);
            var gIface_ = (GISharp.Lib.GObject.TypeInterface.UnmanagedStruct*)gIface.UnsafeHandle;
            var propertyName_ = (byte*)propertyName.UnsafeHandle;
            var ret_ = g_object_interface_find_property(gIface_,propertyName_);
            var ret = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GObject.ParamSpec>((System.IntPtr)ret_, GISharp.Runtime.Transfer.None)!;
            return ret;
        }

        /// <summary>
        /// Add a property to an interface; this is only useful for interfaces
        /// that are added to GObject-derived types. Adding a property to an
        /// interface forces all objects classes with that interface to have a
        /// compatible property. The compatible property could be a newly
        /// created #GParamSpec, but normally
        /// g_object_class_override_property() will be used so that the object
        /// class only needs to provide an implementation and inherits the
        /// property description, default value, bounds, and so forth from the
        /// interface property.
        /// </summary>
        /// <remarks>
        /// This function is meant to be called from the interface's default
        /// vtable initialization function (the @class_init member of
        /// #GTypeInfo.) It must not be called after after @class_init has
        /// been called for any object types implementing this interface.
        /// 
        /// If @pspec is a floating reference, it will be consumed.
        /// </remarks>
        /// <param name="gIface">
        /// any interface vtable for the
        ///    interface, or the default
        ///  vtable for the interface.
        /// </param>
        /// <param name="pspec">
        /// the #GParamSpec for the new property
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.4")]
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_object_interface_install_property(
        /* <type name="TypeInterface" type="gpointer" managed-name="TypeInterface" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.TypeInterface.UnmanagedStruct* gIface,
        /* <type name="ParamSpec" type="GParamSpec*" managed-name="ParamSpec" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.ParamSpec.UnmanagedStruct* pspec);
        static partial void CheckInterfaceInstallPropertyArgs(GISharp.Lib.GObject.TypeInterface gIface, GISharp.Lib.GObject.ParamSpec pspec);

        /// <include file="Object.xmldoc" path="declaration/member[@name='Object.InterfaceInstallProperty(GISharp.Lib.GObject.TypeInterface,GISharp.Lib.GObject.ParamSpec)']/*" />
        [GISharp.Runtime.SinceAttribute("2.4")]
        public static void InterfaceInstallProperty(GISharp.Lib.GObject.TypeInterface gIface, GISharp.Lib.GObject.ParamSpec pspec)
        {
            CheckInterfaceInstallPropertyArgs(gIface, pspec);
            var gIface_ = (GISharp.Lib.GObject.TypeInterface.UnmanagedStruct*)gIface.UnsafeHandle;
            var pspec_ = (GISharp.Lib.GObject.ParamSpec.UnmanagedStruct*)pspec.UnsafeHandle;
            g_object_interface_install_property(gIface_, pspec_);
        }

        /// <summary>
        /// Lists the properties of an interface.Generally, the interface
        /// vtable passed in as @g_iface will be the default vtable from
        /// g_type_default_interface_ref(), or, if you know the interface has
        /// already been loaded, g_type_default_interface_peek().
        /// </summary>
        /// <param name="gIface">
        /// any interface vtable for the
        ///  interface, or the default vtable for the interface
        /// </param>
        /// <param name="nPropertiesP">
        /// location to store number of properties returned.
        /// </param>
        /// <returns>
        /// a
        ///          pointer to an array of pointers to #GParamSpec
        ///          structures. The paramspecs are owned by GLib, but the
        ///          array should be freed with g_free() when you are done with
        ///          it.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.4")]
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <array length="1" zero-terminated="0" type="GParamSpec**" managed-name="GISharp.Runtime.CArray" is-pointer="1">
*   <type name="ParamSpec" type="GParamSpec*" managed-name="ParamSpec" is-pointer="1" />
* </array> */
        /* transfer-ownership:container direction:in */
        private static extern GISharp.Lib.GObject.ParamSpec.UnmanagedStruct** g_object_interface_list_properties(
        /* <type name="TypeInterface" type="gpointer" managed-name="TypeInterface" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.TypeInterface.UnmanagedStruct* gIface,
        /* <type name="guint" type="guint*" managed-name="System.UInt32" /> */
        /* direction:out caller-allocates:0 transfer-ownership:full */
        uint* nPropertiesP);
        static partial void CheckInterfaceListPropertiesArgs(GISharp.Lib.GObject.TypeInterface gIface);

        /// <include file="Object.xmldoc" path="declaration/member[@name='Object.InterfaceListProperties(GISharp.Lib.GObject.TypeInterface)']/*" />
        [GISharp.Runtime.SinceAttribute("2.4")]
        public static GISharp.Runtime.CPtrArray<GISharp.Lib.GObject.ParamSpec> InterfaceListProperties(GISharp.Lib.GObject.TypeInterface gIface)
        {
            CheckInterfaceListPropertiesArgs(gIface);
            var gIface_ = (GISharp.Lib.GObject.TypeInterface.UnmanagedStruct*)gIface.UnsafeHandle;
            uint nPropertiesP_;
            var ret_ = g_object_interface_list_properties(gIface_,&nPropertiesP_);
            var ret = new GISharp.Runtime.CPtrArray<GISharp.Lib.GObject.ParamSpec>((System.IntPtr)ret_, (int)nPropertiesP_, GISharp.Runtime.Transfer.Container);
            return ret;
        }

        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="GType" type="GType" managed-name="GISharp.Lib.GObject.GType" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GObject.GType g_object_get_type();

        /// <summary>
        /// Creates a binding between @source_property on @source and @target_property
        /// on @target. Whenever the @source_property is changed the @target_property is
        /// updated using the same value. For instance:
        /// </summary>
        /// <remarks>
        /// |[
        ///   g_object_bind_property (action, "active", widget, "sensitive", 0);
        /// ]|
        /// 
        /// Will result in the "sensitive" property of the widget #GObject instance to be
        /// updated with the same value of the "active" property of the action #GObject
        /// instance.
        /// 
        /// If @flags contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
        /// if @target_property on @target changes then the @source_property on @source
        /// will be updated as well.
        /// 
        /// The binding will automatically be removed when either the @source or the
        /// @target instances are finalized. To remove the binding without affecting the
        /// @source and the @target you can just call g_object_unref() on the returned
        /// #GBinding instance.
        /// 
        /// A #GObject can have multiple bindings.
        /// </remarks>
        /// <param name="source">
        /// the source #GObject
        /// </param>
        /// <param name="sourceProperty">
        /// the property on @source to bind
        /// </param>
        /// <param name="target">
        /// the target #GObject
        /// </param>
        /// <param name="targetProperty">
        /// the property on @target to bind
        /// </param>
        /// <param name="flags">
        /// flags to pass to #GBinding
        /// </param>
        /// <returns>
        /// the #GBinding instance representing the
        ///     binding between the two #GObject instances. The binding is released
        ///     whenever the #GBinding reference count reaches zero.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.26")]
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Binding" type="GBinding*" managed-name="Binding" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GObject.Binding.UnmanagedStruct* g_object_bind_property(
        /* <type name="Object" type="gpointer" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* source,
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* sourceProperty,
        /* <type name="Object" type="gpointer" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* target,
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* targetProperty,
        /* <type name="BindingFlags" type="GBindingFlags" managed-name="BindingFlags" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.BindingFlags flags);
        partial void CheckBindPropertyArgs(GISharp.Lib.GLib.UnownedUtf8 sourceProperty, GISharp.Lib.GObject.Object target, GISharp.Lib.GLib.UnownedUtf8 targetProperty, GISharp.Lib.GObject.BindingFlags flags);

        /// <include file="Object.xmldoc" path="declaration/member[@name='Object.BindProperty(GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.GObject.Object,GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.GObject.BindingFlags)']/*" />
        [GISharp.Runtime.SinceAttribute("2.26")]
        public GISharp.Lib.GObject.Binding BindProperty(GISharp.Lib.GLib.UnownedUtf8 sourceProperty, GISharp.Lib.GObject.Object target, GISharp.Lib.GLib.UnownedUtf8 targetProperty, GISharp.Lib.GObject.BindingFlags flags)
        {
            CheckBindPropertyArgs(sourceProperty, target, targetProperty, flags);
            var source_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)UnsafeHandle;
            var sourceProperty_ = (byte*)sourceProperty.UnsafeHandle;
            var target_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)target.UnsafeHandle;
            var targetProperty_ = (byte*)targetProperty.UnsafeHandle;
            var flags_ = (GISharp.Lib.GObject.BindingFlags)flags;
            var ret_ = g_object_bind_property(source_,sourceProperty_,target_,targetProperty_,flags_);
            var ret = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GObject.Binding>((System.IntPtr)ret_, GISharp.Runtime.Transfer.None)!;
            return ret;
        }

        /// <summary>
        /// Creates a binding between @source_property on @source and @target_property
        /// on @target, allowing you to set the transformation functions to be used by
        /// the binding.
        /// </summary>
        /// <remarks>
        /// This function is the language bindings friendly version of
        /// g_object_bind_property_full(), using #GClosures instead of
        /// function pointers.
        /// </remarks>
        /// <param name="source">
        /// the source #GObject
        /// </param>
        /// <param name="sourceProperty">
        /// the property on @source to bind
        /// </param>
        /// <param name="target">
        /// the target #GObject
        /// </param>
        /// <param name="targetProperty">
        /// the property on @target to bind
        /// </param>
        /// <param name="flags">
        /// flags to pass to #GBinding
        /// </param>
        /// <param name="transformTo">
        /// a #GClosure wrapping the transformation function
        ///     from the @source to the @target, or %NULL to use the default
        /// </param>
        /// <param name="transformFrom">
        /// a #GClosure wrapping the transformation function
        ///     from the @target to the @source, or %NULL to use the default
        /// </param>
        /// <returns>
        /// the #GBinding instance representing the
        ///     binding between the two #GObject instances. The binding is released
        ///     whenever the #GBinding reference count reaches zero.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.26")]
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Binding" type="GBinding*" managed-name="Binding" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GObject.Binding.UnmanagedStruct* g_object_bind_property_with_closures(
        /* <type name="Object" type="gpointer" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* source,
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* sourceProperty,
        /* <type name="Object" type="gpointer" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* target,
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* targetProperty,
        /* <type name="BindingFlags" type="GBindingFlags" managed-name="BindingFlags" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.BindingFlags flags,
        /* <type name="Closure" type="GClosure*" managed-name="Closure" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Closure.UnmanagedStruct* transformTo,
        /* <type name="Closure" type="GClosure*" managed-name="Closure" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Closure.UnmanagedStruct* transformFrom);
        partial void CheckBindPropertyFullArgs(GISharp.Lib.GLib.UnownedUtf8 sourceProperty, GISharp.Lib.GObject.Object target, GISharp.Lib.GLib.UnownedUtf8 targetProperty, GISharp.Lib.GObject.BindingFlags flags, GISharp.Lib.GObject.Closure transformTo, GISharp.Lib.GObject.Closure transformFrom);

        /// <include file="Object.xmldoc" path="declaration/member[@name='Object.BindPropertyFull(GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.GObject.Object,GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.GObject.BindingFlags,GISharp.Lib.GObject.Closure,GISharp.Lib.GObject.Closure)']/*" />
        [GISharp.Runtime.SinceAttribute("2.26")]
        public GISharp.Lib.GObject.Binding BindPropertyFull(GISharp.Lib.GLib.UnownedUtf8 sourceProperty, GISharp.Lib.GObject.Object target, GISharp.Lib.GLib.UnownedUtf8 targetProperty, GISharp.Lib.GObject.BindingFlags flags, GISharp.Lib.GObject.Closure transformTo, GISharp.Lib.GObject.Closure transformFrom)
        {
            CheckBindPropertyFullArgs(sourceProperty, target, targetProperty, flags, transformTo, transformFrom);
            var source_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)UnsafeHandle;
            var sourceProperty_ = (byte*)sourceProperty.UnsafeHandle;
            var target_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)target.UnsafeHandle;
            var targetProperty_ = (byte*)targetProperty.UnsafeHandle;
            var flags_ = (GISharp.Lib.GObject.BindingFlags)flags;
            var transformTo_ = (GISharp.Lib.GObject.Closure.UnmanagedStruct*)transformTo.UnsafeHandle;
            var transformFrom_ = (GISharp.Lib.GObject.Closure.UnmanagedStruct*)transformFrom.UnsafeHandle;
            var ret_ = g_object_bind_property_with_closures(source_,sourceProperty_,target_,targetProperty_,flags_,transformTo_,transformFrom_);
            var ret = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GObject.Binding>((System.IntPtr)ret_, GISharp.Runtime.Transfer.None)!;
            return ret;
        }

        /// <summary>
        /// This function is intended for #GObject implementations to re-enforce
        /// a [floating][floating-ref] object reference. Doing this is seldom
        /// required: all #GInitiallyUnowneds are created with a floating reference
        /// which usually just needs to be sunken by calling g_object_ref_sink().
        /// </summary>
        /// <param name="object">
        /// a #GObject
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.10")]
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_object_force_floating(
        /* <type name="Object" type="GObject*" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* @object);
        partial void CheckForceFloatingArgs();

        /// <include file="Object.xmldoc" path="declaration/member[@name='Object.ForceFloating()']/*" />
        [GISharp.Runtime.SinceAttribute("2.10")]
        public void ForceFloating()
        {
            CheckForceFloatingArgs();
            var @object_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)UnsafeHandle;
            g_object_force_floating(@object_);
        }

        /// <summary>
        /// Increases the freeze count on @object. If the freeze count is
        /// non-zero, the emission of "notify" signals on @object is
        /// stopped. The signals are queued until the freeze count is decreased
        /// to zero. Duplicate notifications are squashed so that at most one
        /// #GObject::notify signal is emitted for each property modified while the
        /// object is frozen.
        /// </summary>
        /// <remarks>
        /// This is necessary for accessors that modify multiple properties to prevent
        /// premature notification while the object is still being modified.
        /// </remarks>
        /// <param name="object">
        /// a #GObject
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_object_freeze_notify(
        /* <type name="Object" type="GObject*" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* @object);
        partial void CheckFreezeNotifyArgs();

        /// <include file="Object.xmldoc" path="declaration/member[@name='Object.FreezeNotify()']/*" />
        public void FreezeNotify()
        {
            CheckFreezeNotifyArgs();
            var @object_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)UnsafeHandle;
            g_object_freeze_notify(@object_);
        }

        /// <summary>
        /// Gets a named field from the objects table of associations (see g_object_set_data()).
        /// </summary>
        /// <param name="object">
        /// #GObject containing the associations
        /// </param>
        /// <param name="key">
        /// name of the key for that association
        /// </param>
        /// <returns>
        /// the data if found,
        ///          or %NULL if no such data exists.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 direction:in */
        private static extern System.IntPtr g_object_get_data(
        /* <type name="Object" type="GObject*" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* @object,
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* key);
        partial void CheckGetDataArgs(GISharp.Lib.GLib.UnownedUtf8 key);

        /// <include file="Object.xmldoc" path="declaration/member[@name='Object.GetData(GISharp.Lib.GLib.UnownedUtf8)']/*" />
        public System.IntPtr GetData(GISharp.Lib.GLib.UnownedUtf8 key)
        {
            CheckGetDataArgs(key);
            var @object_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)UnsafeHandle;
            var key_ = (byte*)key.UnsafeHandle;
            var ret_ = g_object_get_data(@object_,key_);
            var ret = (System.IntPtr)ret_;
            return ret;
        }

        /// <summary>
        /// Gets a property of an object.
        /// </summary>
        /// <remarks>
        /// The @value can be:
        /// 
        ///  - an empty #GValue initialized by %G_VALUE_INIT, which will be
        ///    automatically initialized with the expected type of the property
        ///    (since GLib 2.60)
        ///  - a #GValue initialized with the expected type of the property
        ///  - a #GValue initialized with a type to which the expected type
        ///    of the property can be transformed
        /// 
        /// In general, a copy is made of the property contents and the caller is
        /// responsible for freeing the memory by calling g_value_unset().
        /// 
        /// Note that g_object_get_property() is really intended for language
        /// bindings, g_object_get() is much more convenient for C programming.
        /// </remarks>
        /// <param name="object">
        /// a #GObject
        /// </param>
        /// <param name="propertyName">
        /// the name of the property to get
        /// </param>
        /// <param name="value">
        /// return location for the property value
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_object_get_property(
        /* <type name="Object" type="GObject*" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* @object,
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* propertyName,
        /* <type name="Value" type="GValue*" managed-name="Value" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Value* value);
        partial void CheckGetPropertyArgs(GISharp.Lib.GLib.UnownedUtf8 propertyName, GISharp.Lib.GObject.Value value);

        /// <include file="Object.xmldoc" path="declaration/member[@name='Object.GetProperty(GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.GObject.Value)']/*" />
        public void GetProperty(GISharp.Lib.GLib.UnownedUtf8 propertyName, GISharp.Lib.GObject.Value value)
        {
            CheckGetPropertyArgs(propertyName, value);
            var @object_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)UnsafeHandle;
            var propertyName_ = (byte*)propertyName.UnsafeHandle;
            var value_ = &value;
            g_object_get_property(@object_, propertyName_, value_);
        }

        /// <summary>
        /// This function gets back user data pointers stored via
        /// g_object_set_qdata().
        /// </summary>
        /// <param name="object">
        /// The GObject to get a stored user data pointer from
        /// </param>
        /// <param name="quark">
        /// A #GQuark, naming the user data pointer
        /// </param>
        /// <returns>
        /// The user data pointer set, or %NULL
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 direction:in */
        private static extern System.IntPtr g_object_get_qdata(
        /* <type name="Object" type="GObject*" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* @object,
        /* <type name="GLib.Quark" type="GQuark" managed-name="GISharp.Lib.GLib.Quark" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Quark quark);
        partial void CheckGetQdataArgs(GISharp.Lib.GLib.Quark quark);

        /// <include file="Object.xmldoc" path="declaration/member[@name='Object.GetQdata(GISharp.Lib.GLib.Quark)']/*" />
        public System.IntPtr GetQdata(GISharp.Lib.GLib.Quark quark)
        {
            CheckGetQdataArgs(quark);
            var @object_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)UnsafeHandle;
            var quark_ = (GISharp.Lib.GLib.Quark)quark;
            var ret_ = g_object_get_qdata(@object_,quark_);
            var ret = (System.IntPtr)ret_;
            return ret;
        }

        /// <summary>
        /// Gets @n_properties properties for an @object.
        /// Obtained properties will be set to @values. All properties must be valid.
        /// Warnings will be emitted and undefined behaviour may result if invalid
        /// properties are passed in.
        /// </summary>
        /// <param name="object">
        /// a #GObject
        /// </param>
        /// <param name="nProperties">
        /// the number of properties
        /// </param>
        /// <param name="names">
        /// the names of each property to get
        /// </param>
        /// <param name="values">
        /// the values of each property to get
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.54")]
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_object_getv(
        /* <type name="Object" type="GObject*" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* @object,
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        uint nProperties,
        /* <array length="0" zero-terminated="0" type="const gchar**" managed-name="GISharp.Runtime.CArray" is-pointer="1">
*   <type name="utf8" type="gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" />
* </array> */
        /* transfer-ownership:none direction:in */
        byte** names,
        /* <array length="0" zero-terminated="0" type="GValue*" managed-name="GISharp.Runtime.CArray" is-pointer="1">
*   <type name="Value" type="GValue" managed-name="Value" />
* </array> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Value* values);
        partial void CheckGetvArgs(GISharp.Runtime.UnownedCPtrArray<GISharp.Lib.GLib.Utf8> names, System.ReadOnlySpan<GISharp.Lib.GObject.Value> values);

        /// <include file="Object.xmldoc" path="declaration/member[@name='Object.Getv(GISharp.Runtime.UnownedCPtrArray&lt;GISharp.Lib.GLib.Utf8&gt;,System.ReadOnlySpan&lt;GISharp.Lib.GObject.Value&gt;)']/*" />
        [GISharp.Runtime.SinceAttribute("2.54")]
        public void Getv(GISharp.Runtime.UnownedCPtrArray<GISharp.Lib.GLib.Utf8> names, System.ReadOnlySpan<GISharp.Lib.GObject.Value> values)
        {
            fixed (GISharp.Lib.GObject.Value* valuesData_ = values)
            {
                fixed (System.IntPtr* namesData_ = names)
                {
                    CheckGetvArgs(names, values);
                    var @object_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)UnsafeHandle;
                    var names_ = (byte**)namesData_;
                    var nProperties_ = (uint)names.Length;
                    var values_ = (GISharp.Lib.GObject.Value*)valuesData_;
                    var nProperties_ = (uint)values.Length;
                    g_object_getv(@object_, nProperties_, names_, values_);
                }
            }
        }

        /// <summary>
        /// Checks whether @object has a [floating][floating-ref] reference.
        /// </summary>
        /// <param name="object">
        /// a #GObject
        /// </param>
        /// <returns>
        /// %TRUE if @object has a floating reference
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.10")]
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_object_is_floating(
        /* <type name="Object" type="gpointer" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* @object);
        partial void CheckGetIsFloatingArgs();

        [GISharp.Runtime.SinceAttribute("2.10")]
        private System.Boolean GetIsFloating()
        {
            CheckGetIsFloatingArgs();
            var @object_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_object_is_floating(@object_);
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Emits a "notify" signal for the property @property_name on @object.
        /// </summary>
        /// <remarks>
        /// When possible, eg. when signaling a property change from within the class
        /// that registered the property, you should use g_object_notify_by_pspec()
        /// instead.
        /// 
        /// Note that emission of the notify signal may be blocked with
        /// g_object_freeze_notify(). In this case, the signal emissions are queued
        /// and will be emitted (in reverse order) when g_object_thaw_notify() is
        /// called.
        /// </remarks>
        /// <param name="object">
        /// a #GObject
        /// </param>
        /// <param name="propertyName">
        /// the name of a property installed on the class of @object.
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_object_notify(
        /* <type name="Object" type="GObject*" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* @object,
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* propertyName);
        partial void CheckNotifyArgs(GISharp.Lib.GLib.UnownedUtf8 propertyName);

        /// <include file="Object.xmldoc" path="declaration/member[@name='Object.Notify(GISharp.Lib.GLib.UnownedUtf8)']/*" />
        public void Notify(GISharp.Lib.GLib.UnownedUtf8 propertyName)
        {
            CheckNotifyArgs(propertyName);
            var @object_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)UnsafeHandle;
            var propertyName_ = (byte*)propertyName.UnsafeHandle;
            g_object_notify(@object_, propertyName_);
        }

        /// <summary>
        /// Emits a "notify" signal for the property specified by @pspec on @object.
        /// </summary>
        /// <remarks>
        /// This function omits the property name lookup, hence it is faster than
        /// g_object_notify().
        /// 
        /// One way to avoid using g_object_notify() from within the
        /// class that registered the properties, and using g_object_notify_by_pspec()
        /// instead, is to store the GParamSpec used with
        /// g_object_class_install_property() inside a static array, e.g.:
        /// 
        /// |[&lt;!-- language="C" --&gt;
        ///   enum
        ///   {
        ///     PROP_0,
        ///     PROP_FOO,
        ///     PROP_LAST
        ///   };
        /// 
        ///   static GParamSpec *properties[PROP_LAST];
        /// 
        ///   static void
        ///   my_object_class_init (MyObjectClass *klass)
        ///   {
        ///     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
        ///                                              0, 100,
        ///                                              50,
        ///                                              G_PARAM_READWRITE);
        ///     g_object_class_install_property (gobject_class,
        ///                                      PROP_FOO,
        ///                                      properties[PROP_FOO]);
        ///   }
        /// ]|
        /// 
        /// and then notify a change on the "foo" property with:
        /// 
        /// |[&lt;!-- language="C" --&gt;
        ///   g_object_notify_by_pspec (self, properties[PROP_FOO]);
        /// ]|
        /// </remarks>
        /// <param name="object">
        /// a #GObject
        /// </param>
        /// <param name="pspec">
        /// the #GParamSpec of a property installed on the class of @object.
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.26")]
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_object_notify_by_pspec(
        /* <type name="Object" type="GObject*" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* @object,
        /* <type name="ParamSpec" type="GParamSpec*" managed-name="ParamSpec" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.ParamSpec.UnmanagedStruct* pspec);
        partial void CheckNotifyByPspecArgs(GISharp.Lib.GObject.ParamSpec pspec);

        /// <include file="Object.xmldoc" path="declaration/member[@name='Object.NotifyByPspec(GISharp.Lib.GObject.ParamSpec)']/*" />
        [GISharp.Runtime.SinceAttribute("2.26")]
        public void NotifyByPspec(GISharp.Lib.GObject.ParamSpec pspec)
        {
            CheckNotifyByPspecArgs(pspec);
            var @object_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)UnsafeHandle;
            var pspec_ = (GISharp.Lib.GObject.ParamSpec.UnmanagedStruct*)pspec.UnsafeHandle;
            g_object_notify_by_pspec(@object_, pspec_);
        }

        /// <summary>
        /// Increases the reference count of @object.
        /// </summary>
        /// <remarks>
        /// Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
        /// of @object will be propagated to the return type (using the GCC typeof()
        /// extension), so any casting the caller needs to do on the return type must be
        /// explicit.
        /// </remarks>
        /// <param name="object">
        /// a #GObject
        /// </param>
        /// <returns>
        /// the same @object
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Object" type="gpointer" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GObject.Object.UnmanagedStruct* g_object_ref(
        /* <type name="Object" type="gpointer" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* @object);

        /// <summary>
        /// Takes ownership of the unmanaged pointer without freeing it.
        /// The managed object can no longer be used (will throw disposed exception).
        /// </summary>
        public override System.IntPtr Take() => (System.IntPtr)g_object_ref((GISharp.Lib.GObject.Object.UnmanagedStruct*)UnsafeHandle);

        /// <summary>
        /// Increase the reference count of @object, and possibly remove the
        /// [floating][floating-ref] reference, if @object has a floating reference.
        /// </summary>
        /// <remarks>
        /// In other words, if the object is floating, then this call "assumes
        /// ownership" of the floating reference, converting it to a normal
        /// reference by clearing the floating flag while leaving the reference
        /// count unchanged.  If the object is not floating, then this call
        /// adds a new normal reference increasing the reference count by one.
        /// 
        /// Since GLib 2.56, the type of @object will be propagated to the return type
        /// under the same conditions as for g_object_ref().
        /// </remarks>
        /// <param name="object">
        /// a #GObject
        /// </param>
        /// <returns>
        /// @object
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.10")]
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Object" type="gpointer" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GObject.Object.UnmanagedStruct* g_object_ref_sink(
        /* <type name="Object" type="gpointer" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* @object);
        partial void CheckRefSinkArgs();

        /// <include file="Object.xmldoc" path="declaration/member[@name='Object.RefSink()']/*" />
        [GISharp.Runtime.SinceAttribute("2.10")]
        public GISharp.Lib.GObject.Object RefSink()
        {
            CheckRefSinkArgs();
            var @object_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_object_ref_sink(@object_);
            var ret = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GObject.Object>((System.IntPtr)ret_, GISharp.Runtime.Transfer.None)!;
            return ret;
        }

        /// <summary>
        /// Releases all references to other objects. This can be used to break
        /// reference cycles.
        /// </summary>
        /// <remarks>
        /// This function should only be called from object system implementations.
        /// </remarks>
        /// <param name="object">
        /// a #GObject
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_object_run_dispose(
        /* <type name="Object" type="GObject*" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* @object);
        partial void CheckRunDisposeArgs();

        /// <include file="Object.xmldoc" path="declaration/member[@name='Object.RunDispose()']/*" />
        public void RunDispose()
        {
            CheckRunDisposeArgs();
            var @object_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)UnsafeHandle;
            g_object_run_dispose(@object_);
        }

        /// <summary>
        /// Each object carries around a table of associations from
        /// strings to pointers.  This function lets you set an association.
        /// </summary>
        /// <remarks>
        /// If the object already had an association with that name,
        /// the old association will be destroyed.
        /// 
        /// Internally, the @key is converted to a #GQuark using g_quark_from_string().
        /// This means a copy of @key is kept permanently (even after @object has been
        /// finalized) — so it is recommended to only use a small, bounded set of values
        /// for @key in your program, to avoid the #GQuark storage growing unbounded.
        /// </remarks>
        /// <param name="object">
        /// #GObject containing the associations.
        /// </param>
        /// <param name="key">
        /// name of the key
        /// </param>
        /// <param name="data">
        /// data to associate with that key
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_object_set_data(
        /* <type name="Object" type="GObject*" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* @object,
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* key,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr data);
        partial void CheckSetDataArgs(GISharp.Lib.GLib.UnownedUtf8 key, System.IntPtr data);

        /// <include file="Object.xmldoc" path="declaration/member[@name='Object.SetData(GISharp.Lib.GLib.UnownedUtf8,System.IntPtr)']/*" />
        public void SetData(GISharp.Lib.GLib.UnownedUtf8 key, System.IntPtr data)
        {
            CheckSetDataArgs(key, data);
            var @object_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)UnsafeHandle;
            var key_ = (byte*)key.UnsafeHandle;
            var data_ = (System.IntPtr)data;
            g_object_set_data(@object_, key_, data_);
        }

        /// <summary>
        /// Sets a property on an object.
        /// </summary>
        /// <param name="object">
        /// a #GObject
        /// </param>
        /// <param name="propertyName">
        /// the name of the property to set
        /// </param>
        /// <param name="value">
        /// the value
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_object_set_property(
        /* <type name="Object" type="GObject*" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* @object,
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* propertyName,
        /* <type name="Value" type="const GValue*" managed-name="Value" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Value* value);
        partial void CheckSetPropertyArgs(GISharp.Lib.GLib.UnownedUtf8 propertyName, GISharp.Lib.GObject.Value value);

        /// <include file="Object.xmldoc" path="declaration/member[@name='Object.SetProperty(GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.GObject.Value)']/*" />
        public void SetProperty(GISharp.Lib.GLib.UnownedUtf8 propertyName, GISharp.Lib.GObject.Value value)
        {
            CheckSetPropertyArgs(propertyName, value);
            var @object_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)UnsafeHandle;
            var propertyName_ = (byte*)propertyName.UnsafeHandle;
            var value_ = &value;
            g_object_set_property(@object_, propertyName_, value_);
        }

        /// <summary>
        /// Remove a specified datum from the object's data associations,
        /// without invoking the association's destroy handler.
        /// </summary>
        /// <param name="object">
        /// #GObject containing the associations
        /// </param>
        /// <param name="key">
        /// name of the key
        /// </param>
        /// <returns>
        /// the data if found, or %NULL
        ///          if no such data exists.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:full nullable:1 direction:in */
        private static extern System.IntPtr g_object_steal_data(
        /* <type name="Object" type="GObject*" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* @object,
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* key);
        partial void CheckStealDataArgs(GISharp.Lib.GLib.UnownedUtf8 key);

        /// <include file="Object.xmldoc" path="declaration/member[@name='Object.StealData(GISharp.Lib.GLib.UnownedUtf8)']/*" />
        public System.IntPtr StealData(GISharp.Lib.GLib.UnownedUtf8 key)
        {
            CheckStealDataArgs(key);
            var @object_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)UnsafeHandle;
            var key_ = (byte*)key.UnsafeHandle;
            var ret_ = g_object_steal_data(@object_,key_);
            var ret = (System.IntPtr)ret_;
            return ret;
        }

        /// <summary>
        /// This function gets back user data pointers stored via
        /// g_object_set_qdata() and removes the @data from object
        /// without invoking its destroy() function (if any was
        /// set).
        /// Usually, calling this function is only required to update
        /// user data pointers with a destroy notifier, for example:
        /// |[&lt;!-- language="C" --&gt;
        /// void
        /// object_add_to_user_list (GObject     *object,
        ///                          const gchar *new_string)
        /// {
        ///   // the quark, naming the object data
        ///   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
        ///   // retrieve the old string list
        ///   GList *list = g_object_steal_qdata (object, quark_string_list);
        /// </summary>
        /// <remarks>
        ///   // prepend new string
        ///   list = g_list_prepend (list, g_strdup (new_string));
        ///   // this changed 'list', so we need to set it again
        ///   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
        /// }
        /// static void
        /// free_string_list (gpointer data)
        /// {
        ///   GList *node, *list = data;
        /// 
        ///   for (node = list; node; node = node-&gt;next)
        ///     g_free (node-&gt;data);
        ///   g_list_free (list);
        /// }
        /// ]|
        /// Using g_object_get_qdata() in the above example, instead of
        /// g_object_steal_qdata() would have left the destroy function set,
        /// and thus the partial string list would have been freed upon
        /// g_object_set_qdata_full().
        /// </remarks>
        /// <param name="object">
        /// The GObject to get a stored user data pointer from
        /// </param>
        /// <param name="quark">
        /// A #GQuark, naming the user data pointer
        /// </param>
        /// <returns>
        /// The user data pointer set, or %NULL
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:full nullable:1 direction:in */
        private static extern System.IntPtr g_object_steal_qdata(
        /* <type name="Object" type="GObject*" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* @object,
        /* <type name="GLib.Quark" type="GQuark" managed-name="GISharp.Lib.GLib.Quark" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Quark quark);
        partial void CheckStealQdataArgs(GISharp.Lib.GLib.Quark quark);

        /// <include file="Object.xmldoc" path="declaration/member[@name='Object.StealQdata(GISharp.Lib.GLib.Quark)']/*" />
        public System.IntPtr StealQdata(GISharp.Lib.GLib.Quark quark)
        {
            CheckStealQdataArgs(quark);
            var @object_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)UnsafeHandle;
            var quark_ = (GISharp.Lib.GLib.Quark)quark;
            var ret_ = g_object_steal_qdata(@object_,quark_);
            var ret = (System.IntPtr)ret_;
            return ret;
        }

        /// <summary>
        /// Reverts the effect of a previous call to
        /// g_object_freeze_notify(). The freeze count is decreased on @object
        /// and when it reaches zero, queued "notify" signals are emitted.
        /// </summary>
        /// <remarks>
        /// Duplicate notifications for each property are squashed so that at most one
        /// #GObject::notify signal is emitted for each property, in the reverse order
        /// in which they have been queued.
        /// 
        /// It is an error to call this function when the freeze count is zero.
        /// </remarks>
        /// <param name="object">
        /// a #GObject
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_object_thaw_notify(
        /* <type name="Object" type="GObject*" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* @object);
        partial void CheckThawNotifyArgs();

        /// <include file="Object.xmldoc" path="declaration/member[@name='Object.ThawNotify()']/*" />
        public void ThawNotify()
        {
            CheckThawNotifyArgs();
            var @object_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)UnsafeHandle;
            g_object_thaw_notify(@object_);
        }

        /// <summary>
        /// Decreases the reference count of @object. When its reference count
        /// drops to 0, the object is finalized (i.e. its memory is freed).
        /// </summary>
        /// <remarks>
        /// If the pointer to the #GObject may be reused in future (for example, if it is
        /// an instance variable of another object), it is recommended to clear the
        /// pointer to %NULL rather than retain a dangling pointer to a potentially
        /// invalid #GObject instance. Use g_clear_object() for this.
        /// </remarks>
        /// <param name="object">
        /// a #GObject
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_object_unref(
        /* <type name="Object" type="gpointer" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* @object);

        /// <inheritdoc/>
        protected override void Dispose(bool disposing)
        {
            if (handle != System.IntPtr.Zero)
            {
                g_object_unref((UnmanagedStruct*)handle);
            }

            base.Dispose(disposing);
        }

        /// <summary>
        /// This function essentially limits the life time of the @closure to
        /// the life time of the object. That is, when the object is finalized,
        /// the @closure is invalidated by calling g_closure_invalidate() on
        /// it, in order to prevent invocations of the closure with a finalized
        /// (nonexisting) object. Also, g_object_ref() and g_object_unref() are
        /// added as marshal guards to the @closure, to ensure that an extra
        /// reference count is held on @object during invocation of the
        /// @closure.  Usually, this function will be called on closures that
        /// use this @object as closure data.
        /// </summary>
        /// <param name="object">
        /// #GObject restricting lifetime of @closure
        /// </param>
        /// <param name="closure">
        /// #GClosure to watch
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_object_watch_closure(
        /* <type name="Object" type="GObject*" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* @object,
        /* <type name="Closure" type="GClosure*" managed-name="Closure" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Closure.UnmanagedStruct* closure);
        partial void CheckWatchClosureArgs(GISharp.Lib.GObject.Closure closure);

        /// <include file="Object.xmldoc" path="declaration/member[@name='Object.WatchClosure(GISharp.Lib.GObject.Closure)']/*" />
        public void WatchClosure(GISharp.Lib.GObject.Closure closure)
        {
            CheckWatchClosureArgs(closure);
            var @object_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)UnsafeHandle;
            var closure_ = (GISharp.Lib.GObject.Closure.UnmanagedStruct*)closure.UnsafeHandle;
            g_object_watch_closure(@object_, closure_);
        }

        /// <include file="Object.xmldoc" path="declaration/member[@name='Object.DoConstructed()']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(ObjectClass.UnmanagedConstructed))]
        protected virtual void DoConstructed()
        {
            var @object_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)UnsafeHandle;
            GISharp.Lib.GObject.TypeClass.GetUnmanagedVirtualMethod<ObjectClass.UnmanagedConstructed>(_GType)!(@object_);
        }

        /// <include file="Object.xmldoc" path="declaration/member[@name='Object.DoDispatchPropertiesChanged(uint,GISharp.Lib.GObject.ParamSpec)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(ObjectClass.UnmanagedDispatchPropertiesChanged))]
        protected virtual void DoDispatchPropertiesChanged(uint nPspecs, GISharp.Lib.GObject.ParamSpec pspecs)
        {
            var @object_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)UnsafeHandle;
            var nPspecs_ = (uint)nPspecs;
            var pspecs_ = (GISharp.Lib.GObject.ParamSpec.UnmanagedStruct*)pspecs.UnsafeHandle;
            GISharp.Lib.GObject.TypeClass.GetUnmanagedVirtualMethod<ObjectClass.UnmanagedDispatchPropertiesChanged>(_GType)!(@object_, nPspecs_, pspecs_);
        }

        /// <include file="Object.xmldoc" path="declaration/member[@name='Object.DoDispose()']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(ObjectClass.UnmanagedDispose))]
        protected virtual void DoDispose()
        {
            var @object_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)UnsafeHandle;
            GISharp.Lib.GObject.TypeClass.GetUnmanagedVirtualMethod<ObjectClass.UnmanagedDispose>(_GType)!(@object_);
        }

        /// <include file="Object.xmldoc" path="declaration/member[@name='Object.DoFinalize()']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(ObjectClass.UnmanagedFinalize))]
        protected virtual void DoFinalize()
        {
            var @object_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)UnsafeHandle;
            GISharp.Lib.GObject.TypeClass.GetUnmanagedVirtualMethod<ObjectClass.UnmanagedFinalize>(_GType)!(@object_);
        }

        /// <include file="Object.xmldoc" path="declaration/member[@name='Object.DoGetProperty(uint,GISharp.Lib.GObject.Value,GISharp.Lib.GObject.ParamSpec)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(ObjectClass.UnmanagedGetProperty))]
        protected virtual void DoGetProperty(uint propertyId, GISharp.Lib.GObject.Value value, GISharp.Lib.GObject.ParamSpec pspec)
        {
            var @object_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)UnsafeHandle;
            var propertyId_ = (uint)propertyId;
            var value_ = &value;
            var pspec_ = (GISharp.Lib.GObject.ParamSpec.UnmanagedStruct*)pspec.UnsafeHandle;
            GISharp.Lib.GObject.TypeClass.GetUnmanagedVirtualMethod<ObjectClass.UnmanagedGetProperty>(_GType)!(@object_, propertyId_, value_, pspec_);
        }

        /// <include file="Object.xmldoc" path="declaration/member[@name='Object.DoNotify(GISharp.Lib.GObject.ParamSpec)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(ObjectClass.UnmanagedNotify))]
        protected virtual void DoNotify(GISharp.Lib.GObject.ParamSpec pspec)
        {
            var @object_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)UnsafeHandle;
            var pspec_ = (GISharp.Lib.GObject.ParamSpec.UnmanagedStruct*)pspec.UnsafeHandle;
            GISharp.Lib.GObject.TypeClass.GetUnmanagedVirtualMethod<ObjectClass.UnmanagedNotify>(_GType)!(@object_, pspec_);
        }

        /// <include file="Object.xmldoc" path="declaration/member[@name='Object.DoSetProperty(uint,GISharp.Lib.GObject.Value,GISharp.Lib.GObject.ParamSpec)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(ObjectClass.UnmanagedSetProperty))]
        protected virtual void DoSetProperty(uint propertyId, GISharp.Lib.GObject.Value value, GISharp.Lib.GObject.ParamSpec pspec)
        {
            var @object_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)UnsafeHandle;
            var propertyId_ = (uint)propertyId;
            var value_ = &value;
            var pspec_ = (GISharp.Lib.GObject.ParamSpec.UnmanagedStruct*)pspec.UnsafeHandle;
            GISharp.Lib.GObject.TypeClass.GetUnmanagedVirtualMethod<ObjectClass.UnmanagedSetProperty>(_GType)!(@object_, propertyId_, value_, pspec_);
        }
    }
}