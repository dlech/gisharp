// SPDX-License-Identifier: MIT
// ATTENTION: This file is automatically generated. Do not edit manually.
#nullable enable
namespace GISharp.Lib.GObject
{
    /// <include file="Object.xmldoc" path="declaration/member[@name='Object']/*" />
    [GISharp.Runtime.GTypeAttribute("GObject", IsProxyForUnmanagedType = true)]
    [GISharp.Runtime.GTypeStructAttribute(typeof(ObjectClass))]
    public unsafe partial class Object : GISharp.Lib.GObject.TypeInstance
    {
        private static readonly GISharp.Runtime.GType _GType = g_object_get_type();

        /// <summary>
        /// The unmanaged data structure.
        /// </summary>
        public new struct UnmanagedStruct
        {
#pragma warning disable CS0169, CS0414, CS0649
            /// <include file="Object.xmldoc" path="declaration/member[@name='UnmanagedStruct.GTypeInstance']/*" />
            public readonly GISharp.Lib.GObject.TypeInstance.UnmanagedStruct GTypeInstance;

            /// <include file="Object.xmldoc" path="declaration/member[@name='UnmanagedStruct.RefCount']/*" />
            internal readonly uint RefCount;

            /// <include file="Object.xmldoc" path="declaration/member[@name='UnmanagedStruct.Qdata']/*" />
            internal readonly GISharp.Lib.GLib.Data.UnmanagedStruct* Qdata;
#pragma warning restore CS0169, CS0414, CS0649
        }

        /// <include file="Object.xmldoc" path="declaration/member[@name='Object.IsFloating']/*" />
        [GISharp.Runtime.SinceAttribute("2.10")]
        public bool IsFloating { get => GetIsFloating(); }

        /// <summary>
        /// Creates a new instance of a #GObject subtype and sets its properties.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Construction parameters (see #G_PARAM_CONSTRUCT, #G_PARAM_CONSTRUCT_ONLY)
        /// which are not explicitly specified are set to their default values.
        /// </para>
        /// </remarks>
        /// <param name="objectType">
        /// the type id of the #GObject subtype to instantiate
        /// </param>
        /// <param name="nParameters">
        /// the length of the @parameters array
        /// </param>
        /// <param name="parameters">
        /// an array of #GParameter
        /// </param>
        /// <returns>
        /// a new instance of
        /// @object_type
        /// </returns>
        [System.ObsoleteAttribute("Use g_object_new_with_properties() instead.\ndeprecated. See #GParameter for more information.")]
        [GISharp.Runtime.DeprecatedSinceAttribute("2.54")]
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Object" type="gpointer" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GObject.Object.UnmanagedStruct* g_object_newv(
        /* <type name="GType" type="GType" managed-name="GISharp.Runtime.GType" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.GType objectType,
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        uint nParameters,
        /* <array length="1" zero-terminated="0" type="GParameter*" managed-name="GISharp.Runtime.CArray" is-pointer="1">
*   <type name="Parameter" type="GParameter" managed-name="Parameter" />
* </array> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Parameter* parameters);
        static partial void CheckNewvArgs(GISharp.Runtime.GType objectType, System.ReadOnlySpan<GISharp.Lib.GObject.Parameter> parameters);

        [System.ObsoleteAttribute("Use g_object_new_with_properties() instead.\ndeprecated. See #GParameter for more information.")]
        [GISharp.Runtime.DeprecatedSinceAttribute("2.54")]
        static GISharp.Lib.GObject.Object.UnmanagedStruct* Newv(GISharp.Runtime.GType objectType, System.ReadOnlySpan<GISharp.Lib.GObject.Parameter> parameters)
        {
            fixed (GISharp.Lib.GObject.Parameter* parametersData_ = parameters)
            {
                CheckNewvArgs(objectType, parameters);
                var objectType_ = (GISharp.Runtime.GType)objectType;
                var parameters_ = (GISharp.Lib.GObject.Parameter*)parametersData_;
                var nParameters_ = (uint)parameters.Length;
                var ret_ = g_object_newv(objectType_,nParameters_,parameters_);
                return ret_;
            }
        }

        /// <include file="Object.xmldoc" path="declaration/member[@name='Object.Object(GISharp.Runtime.GType,System.ReadOnlySpan&lt;GISharp.Lib.GObject.Parameter&gt;)']/*" />
        [System.ObsoleteAttribute("Use g_object_new_with_properties() instead.\ndeprecated. See #GParameter for more information.")]
        [GISharp.Runtime.DeprecatedSinceAttribute("2.54")]
        public Object(GISharp.Runtime.GType objectType, System.ReadOnlySpan<GISharp.Lib.GObject.Parameter> parameters) : this((System.IntPtr)Newv(objectType, parameters), GISharp.Runtime.Transfer.Full)
        {
        }

        /// <include file="Object.xmldoc" path="declaration/member[@name='NotifySignalHandler']/*" />
        public delegate void NotifySignalHandler(GISharp.Lib.GObject.Object @object, GISharp.Lib.GObject.ParamSpec pspec);

        /// <include file="Object.xmldoc" path="declaration/member[@name='Object.NotifySignal']/*" />
        [GISharp.Runtime.GSignalAttribute("notify", When = GISharp.Runtime.EmissionStage.First, IsNoRecurse = true, IsDetailed = true, IsAction = true, IsNoHooks = true)]
        public event NotifySignalHandler NotifySignal { add => AddEventSignalHandler("notify", value); remove => RemoveEventSignalHandler("notify", value); }

        [System.Runtime.InteropServices.UnmanagedCallersOnlyAttribute(CallConvs = new[] { typeof(System.Runtime.CompilerServices.CallConvCdecl) })]
        private static void ManagedNotifySignalHandler(GISharp.Lib.GObject.Object.UnmanagedStruct* @object_, GISharp.Lib.GObject.ParamSpec.UnmanagedStruct* pspec_, System.IntPtr userData_)
        {
            try
            {
                var @object = GISharp.Lib.GObject.Object.GetInstance<GISharp.Lib.GObject.Object>((System.IntPtr)@object_, GISharp.Runtime.Transfer.None)!;
                var pspec = GISharp.Lib.GObject.ParamSpec.GetInstance<GISharp.Lib.GObject.ParamSpec>((System.IntPtr)pspec_, GISharp.Runtime.Transfer.None)!;
                var gcHandle = (System.Runtime.InteropServices.GCHandle)userData_;
                var userData = (GISharp.Runtime.CClosureData)gcHandle.Target!;
                ((NotifySignalHandler)userData.Callback)(@object, pspec);
            }
            catch (System.Exception ex)
            {
                GISharp.Runtime.GMarshal.LogUnhandledException(ex);
            }
        }

        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gsize" type="gsize" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        private static extern nuint g_object_compat_control(
/* <type name="gsize" type="gsize" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
nuint what,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr data);
        static partial void CheckCompatControlArgs(int what, System.IntPtr data);

        /// <include file="Object.xmldoc" path="declaration/member[@name='Object.CompatControl(int,System.IntPtr)']/*" />
        public static int CompatControl(int what, System.IntPtr data)
        {
            CheckCompatControlArgs(what, data);
            var what_ = (nuint)what;
            var data_ = (System.IntPtr)data;
            var ret_ = g_object_compat_control(what_,data_);
            var ret = (int)ret_;
            return ret;
        }

        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="GType" type="GType" managed-name="GISharp.Runtime.GType" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Runtime.GType g_object_get_type();

        /// <summary>
        /// Increases the reference count of the object by one and sets a
        /// callback to be called when all other references to the object are
        /// dropped, or when this is already the last reference to the object
        /// and another reference is established.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This functionality is intended for binding @object to a proxy
        /// object managed by another memory manager. This is done with two
        /// paired references: the strong reference added by
        /// g_object_add_toggle_ref() and a reverse reference to the proxy
        /// object which is either a strong reference or weak reference.
        /// </para>
        /// <para>
        /// The setup is that when there are no other references to @object,
        /// only a weak reference is held in the reverse direction from @object
        /// to the proxy object, but when there are other references held to
        /// @object, a strong reference is held. The @notify callback is called
        /// when the reference from @object to the proxy object should be
        /// "toggled" from strong to weak (@is_last_ref true) or weak to strong
        /// (@is_last_ref false).
        /// </para>
        /// <para>
        /// Since a (normal) reference must be held to the object before
        /// calling g_object_add_toggle_ref(), the initial state of the reverse
        /// link is always strong.
        /// </para>
        /// <para>
        /// Multiple toggle references may be added to the same gobject,
        /// however if there are multiple toggle references to an object, none
        /// of them will ever be notified until all but one are removed.  For
        /// this reason, you should only ever use a toggle reference if there
        /// is important state in the proxy object.
        /// </para>
        /// </remarks>
        /// <param name="object">
        /// a #GObject
        /// </param>
        /// <param name="notify">
        /// a function to call when this reference is the
        ///  last reference to the object, or is no longer
        ///  the last reference.
        /// </param>
        /// <param name="data">
        /// data to pass to @notify
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.8")]
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_object_add_toggle_ref(
        /* <type name="Object" type="GObject*" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* @object,
        /* <type name="ToggleNotify" type="GToggleNotify" managed-name="ToggleNotify" /> */
        /* transfer-ownership:none closure:1 direction:in */
        delegate* unmanaged[Cdecl]<System.IntPtr, GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Runtime.Boolean, void> notify,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr data);

        /// <summary>
        /// Creates a binding between @source_property on @source and @target_property
        /// on @target. Whenever the @source_property is changed the @target_property is
        /// updated using the same value. For instance:
        /// </summary>
        /// <remarks>
        /// <para>
        /// |[
        ///   g_object_bind_property (action, "active", widget, "sensitive", 0);
        /// ]|
        /// </para>
        /// <para>
        /// Will result in the "sensitive" property of the widget #GObject instance to be
        /// updated with the same value of the "active" property of the action #GObject
        /// instance.
        /// </para>
        /// <para>
        /// If @flags contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
        /// if @target_property on @target changes then the @source_property on @source
        /// will be updated as well.
        /// </para>
        /// <para>
        /// The binding will automatically be removed when either the @source or the
        /// @target instances are finalized. To remove the binding without affecting the
        /// @source and the @target you can just call g_object_unref() on the returned
        /// #GBinding instance.
        /// </para>
        /// <para>
        /// A #GObject can have multiple bindings.
        /// </para>
        /// </remarks>
        /// <param name="source">
        /// the source #GObject
        /// </param>
        /// <param name="sourceProperty">
        /// the property on @source to bind
        /// </param>
        /// <param name="target">
        /// the target #GObject
        /// </param>
        /// <param name="targetProperty">
        /// the property on @target to bind
        /// </param>
        /// <param name="flags">
        /// flags to pass to #GBinding
        /// </param>
        /// <returns>
        /// the #GBinding instance representing the
        ///     binding between the two #GObject instances. The binding is released
        ///     whenever the #GBinding reference count reaches zero.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.26")]
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Binding" type="GBinding*" managed-name="Binding" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GObject.Binding.UnmanagedStruct* g_object_bind_property(
        /* <type name="Object" type="gpointer" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* source,
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* sourceProperty,
        /* <type name="Object" type="gpointer" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* target,
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* targetProperty,
        /* <type name="BindingFlags" type="GBindingFlags" managed-name="BindingFlags" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.BindingFlags flags);
        partial void CheckBindPropertyArgs(GISharp.Lib.GLib.UnownedUtf8 sourceProperty, GISharp.Lib.GObject.Object target, GISharp.Lib.GLib.UnownedUtf8 targetProperty, GISharp.Lib.GObject.BindingFlags flags);

        /// <include file="Object.xmldoc" path="declaration/member[@name='Object.BindProperty(GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.GObject.Object,GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.GObject.BindingFlags)']/*" />
        [GISharp.Runtime.SinceAttribute("2.26")]
        public GISharp.Lib.GObject.Binding BindProperty(GISharp.Lib.GLib.UnownedUtf8 sourceProperty, GISharp.Lib.GObject.Object target, GISharp.Lib.GLib.UnownedUtf8 targetProperty, GISharp.Lib.GObject.BindingFlags flags)
        {
            CheckBindPropertyArgs(sourceProperty, target, targetProperty, flags);
            var source_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)UnsafeHandle;
            var sourceProperty_ = (byte*)sourceProperty.UnsafeHandle;
            var target_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)target.UnsafeHandle;
            var targetProperty_ = (byte*)targetProperty.UnsafeHandle;
            var flags_ = (GISharp.Lib.GObject.BindingFlags)flags;
            var ret_ = g_object_bind_property(source_,sourceProperty_,target_,targetProperty_,flags_);
            var ret = GISharp.Lib.GObject.Binding.GetInstance<GISharp.Lib.GObject.Binding>((System.IntPtr)ret_, GISharp.Runtime.Transfer.None)!;
            return ret;
        }

        /// <summary>
        /// Complete version of g_object_bind_property().
        /// </summary>
        /// <remarks>
        /// <para>
        /// Creates a binding between @source_property on @source and @target_property
        /// on @target, allowing you to set the transformation functions to be used by
        /// the binding.
        /// </para>
        /// <para>
        /// If @flags contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
        /// if @target_property on @target changes then the @source_property on @source
        /// will be updated as well. The @transform_from function is only used in case
        /// of bidirectional bindings, otherwise it will be ignored
        /// </para>
        /// <para>
        /// The binding will automatically be removed when either the @source or the
        /// @target instances are finalized. This will release the reference that is
        /// being held on the #GBinding instance; if you want to hold on to the
        /// #GBinding instance, you will need to hold a reference to it.
        /// </para>
        /// <para>
        /// To remove the binding, call g_binding_unbind().
        /// </para>
        /// <para>
        /// A #GObject can have multiple bindings.
        /// </para>
        /// <para>
        /// The same @user_data parameter will be used for both @transform_to
        /// and @transform_from transformation functions; the @notify function will
        /// be called once, when the binding is removed. If you need different data
        /// for each transformation function, please use
        /// g_object_bind_property_with_closures() instead.
        /// </para>
        /// </remarks>
        /// <param name="source">
        /// the source #GObject
        /// </param>
        /// <param name="sourceProperty">
        /// the property on @source to bind
        /// </param>
        /// <param name="target">
        /// the target #GObject
        /// </param>
        /// <param name="targetProperty">
        /// the property on @target to bind
        /// </param>
        /// <param name="flags">
        /// flags to pass to #GBinding
        /// </param>
        /// <param name="transformTo">
        /// the transformation function
        ///     from the @source to the @target, or %NULL to use the default
        /// </param>
        /// <param name="transformFrom">
        /// the transformation function
        ///     from the @target to the @source, or %NULL to use the default
        /// </param>
        /// <param name="userData">
        /// custom data to be passed to the transformation functions,
        ///     or %NULL
        /// </param>
        /// <param name="notify">
        /// a function to call when disposing the binding, to free
        ///     resources used by the transformation functions, or %NULL if not required
        /// </param>
        /// <returns>
        /// the #GBinding instance representing the
        ///     binding between the two #GObject instances. The binding is released
        ///     whenever the #GBinding reference count reaches zero.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.26")]
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Binding" type="GBinding*" managed-name="Binding" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GObject.Binding.UnmanagedStruct* g_object_bind_property_full(
        /* <type name="Object" type="gpointer" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* source,
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* sourceProperty,
        /* <type name="Object" type="gpointer" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* target,
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* targetProperty,
        /* <type name="BindingFlags" type="GBindingFlags" managed-name="BindingFlags" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.BindingFlags flags,
        /* <type name="BindingTransformFunc" type="GBindingTransformFunc" managed-name="BindingTransformFunc" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:notified direction:in */
        delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Binding.UnmanagedStruct*, GISharp.Lib.GObject.Value*, GISharp.Lib.GObject.Value*, System.IntPtr, GISharp.Runtime.Boolean> transformTo,
        /* <type name="BindingTransformFunc" type="GBindingTransformFunc" managed-name="BindingTransformFunc" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:notified closure:6 destroy:7 direction:in */
        delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Binding.UnmanagedStruct*, GISharp.Lib.GObject.Value*, GISharp.Lib.GObject.Value*, System.IntPtr, GISharp.Runtime.Boolean> transformFrom,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr userData,
        /* <type name="GLib.DestroyNotify" type="GDestroyNotify" managed-name="GISharp.Lib.GLib.DestroyNotify" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:async direction:in */
        delegate* unmanaged[Cdecl]<System.IntPtr, void> notify);

        /// <summary>
        /// Creates a binding between @source_property on @source and @target_property
        /// on @target, allowing you to set the transformation functions to be used by
        /// the binding.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This function is the language bindings friendly version of
        /// g_object_bind_property_full(), using #GClosures instead of
        /// function pointers.
        /// </para>
        /// </remarks>
        /// <param name="source">
        /// the source #GObject
        /// </param>
        /// <param name="sourceProperty">
        /// the property on @source to bind
        /// </param>
        /// <param name="target">
        /// the target #GObject
        /// </param>
        /// <param name="targetProperty">
        /// the property on @target to bind
        /// </param>
        /// <param name="flags">
        /// flags to pass to #GBinding
        /// </param>
        /// <param name="transformTo">
        /// a #GClosure wrapping the transformation function
        ///     from the @source to the @target, or %NULL to use the default
        /// </param>
        /// <param name="transformFrom">
        /// a #GClosure wrapping the transformation function
        ///     from the @target to the @source, or %NULL to use the default
        /// </param>
        /// <returns>
        /// the #GBinding instance representing the
        ///     binding between the two #GObject instances. The binding is released
        ///     whenever the #GBinding reference count reaches zero.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.26")]
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Binding" type="GBinding*" managed-name="Binding" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GObject.Binding.UnmanagedStruct* g_object_bind_property_with_closures(
        /* <type name="Object" type="gpointer" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* source,
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* sourceProperty,
        /* <type name="Object" type="gpointer" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* target,
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* targetProperty,
        /* <type name="BindingFlags" type="GBindingFlags" managed-name="BindingFlags" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.BindingFlags flags,
        /* <type name="Closure" type="GClosure*" managed-name="Closure" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Closure.UnmanagedStruct* transformTo,
        /* <type name="Closure" type="GClosure*" managed-name="Closure" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Closure.UnmanagedStruct* transformFrom);
        partial void CheckBindPropertyArgs(GISharp.Lib.GLib.UnownedUtf8 sourceProperty, GISharp.Lib.GObject.Object target, GISharp.Lib.GLib.UnownedUtf8 targetProperty, GISharp.Lib.GObject.BindingFlags flags, GISharp.Lib.GObject.Closure transformTo, GISharp.Lib.GObject.Closure transformFrom);

        /// <include file="Object.xmldoc" path="declaration/member[@name='Object.BindProperty(GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.GObject.Object,GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.GObject.BindingFlags,GISharp.Lib.GObject.Closure,GISharp.Lib.GObject.Closure)']/*" />
        [GISharp.Runtime.SinceAttribute("2.26")]
        public GISharp.Lib.GObject.Binding BindProperty(GISharp.Lib.GLib.UnownedUtf8 sourceProperty, GISharp.Lib.GObject.Object target, GISharp.Lib.GLib.UnownedUtf8 targetProperty, GISharp.Lib.GObject.BindingFlags flags, GISharp.Lib.GObject.Closure transformTo, GISharp.Lib.GObject.Closure transformFrom)
        {
            CheckBindPropertyArgs(sourceProperty, target, targetProperty, flags, transformTo, transformFrom);
            var source_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)UnsafeHandle;
            var sourceProperty_ = (byte*)sourceProperty.UnsafeHandle;
            var target_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)target.UnsafeHandle;
            var targetProperty_ = (byte*)targetProperty.UnsafeHandle;
            var flags_ = (GISharp.Lib.GObject.BindingFlags)flags;
            var transformTo_ = (GISharp.Lib.GObject.Closure.UnmanagedStruct*)transformTo.UnsafeHandle;
            var transformFrom_ = (GISharp.Lib.GObject.Closure.UnmanagedStruct*)transformFrom.UnsafeHandle;
            var ret_ = g_object_bind_property_with_closures(source_,sourceProperty_,target_,targetProperty_,flags_,transformTo_,transformFrom_);
            var ret = GISharp.Lib.GObject.Binding.GetInstance<GISharp.Lib.GObject.Binding>((System.IntPtr)ret_, GISharp.Runtime.Transfer.None)!;
            return ret;
        }

        /// <summary>
        /// This is a variant of g_object_get_data() which returns
        /// a 'duplicate' of the value. @dup_func defines the
        /// meaning of 'duplicate' in this context, it could e.g.
        /// take a reference on a ref-counted object.
        /// </summary>
        /// <remarks>
        /// <para>
        /// If the @key is not set on the object then @dup_func
        /// will be called with a %NULL argument.
        /// </para>
        /// <para>
        /// Note that @dup_func is called while user data of @object
        /// is locked.
        /// </para>
        /// <para>
        /// This function can be useful to avoid races when multiple
        /// threads are using object data on the same key on the same
        /// object.
        /// </para>
        /// </remarks>
        /// <param name="object">
        /// the #GObject to store user data on
        /// </param>
        /// <param name="key">
        /// a string, naming the user data pointer
        /// </param>
        /// <param name="dupFunc">
        /// function to dup the value
        /// </param>
        /// <param name="userData">
        /// passed as user_data to @dup_func
        /// </param>
        /// <returns>
        /// the result of calling @dup_func on the value
        ///     associated with @key on @object, or %NULL if not set.
        ///     If @dup_func is %NULL, the value is returned
        ///     unmodified.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.34")]
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 direction:in */
        private static extern System.IntPtr g_object_dup_data(
        /* <type name="Object" type="GObject*" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* @object,
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* key,
        /* <type name="GLib.DuplicateFunc" type="GDuplicateFunc" managed-name="GISharp.Lib.GLib.DuplicateFunc" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 closure:2 direction:in */
        delegate* unmanaged[Cdecl]<System.IntPtr, System.IntPtr, System.IntPtr> dupFunc,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr userData);

        /// <summary>
        /// This is a variant of g_object_get_qdata() which returns
        /// a 'duplicate' of the value. @dup_func defines the
        /// meaning of 'duplicate' in this context, it could e.g.
        /// take a reference on a ref-counted object.
        /// </summary>
        /// <remarks>
        /// <para>
        /// If the @quark is not set on the object then @dup_func
        /// will be called with a %NULL argument.
        /// </para>
        /// <para>
        /// Note that @dup_func is called while user data of @object
        /// is locked.
        /// </para>
        /// <para>
        /// This function can be useful to avoid races when multiple
        /// threads are using object data on the same key on the same
        /// object.
        /// </para>
        /// </remarks>
        /// <param name="object">
        /// the #GObject to store user data on
        /// </param>
        /// <param name="quark">
        /// a #GQuark, naming the user data pointer
        /// </param>
        /// <param name="dupFunc">
        /// function to dup the value
        /// </param>
        /// <param name="userData">
        /// passed as user_data to @dup_func
        /// </param>
        /// <returns>
        /// the result of calling @dup_func on the value
        ///     associated with @quark on @object, or %NULL if not set.
        ///     If @dup_func is %NULL, the value is returned
        ///     unmodified.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.34")]
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 direction:in */
        private static extern System.IntPtr g_object_dup_qdata(
        /* <type name="Object" type="GObject*" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* @object,
        /* <type name="GLib.Quark" type="GQuark" managed-name="GISharp.Lib.GLib.Quark" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Quark quark,
        /* <type name="GLib.DuplicateFunc" type="GDuplicateFunc" managed-name="GISharp.Lib.GLib.DuplicateFunc" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 closure:2 direction:in */
        delegate* unmanaged[Cdecl]<System.IntPtr, System.IntPtr, System.IntPtr> dupFunc,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr userData);

        /// <summary>
        /// This function is intended for #GObject implementations to re-enforce
        /// a [floating][floating-ref] object reference. Doing this is seldom
        /// required: all #GInitiallyUnowneds are created with a floating reference
        /// which usually just needs to be sunken by calling g_object_ref_sink().
        /// </summary>
        /// <param name="object">
        /// a #GObject
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.10")]
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_object_force_floating(
        /* <type name="Object" type="GObject*" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* @object);

        /// <summary>
        /// Increases the freeze count on @object. If the freeze count is
        /// non-zero, the emission of "notify" signals on @object is
        /// stopped. The signals are queued until the freeze count is decreased
        /// to zero. Duplicate notifications are squashed so that at most one
        /// #GObject::notify signal is emitted for each property modified while the
        /// object is frozen.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This is necessary for accessors that modify multiple properties to prevent
        /// premature notification while the object is still being modified.
        /// </para>
        /// </remarks>
        /// <param name="object">
        /// a #GObject
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_object_freeze_notify(
        /* <type name="Object" type="GObject*" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* @object);
        partial void CheckFreezeNotifyArgs();

        /// <include file="Object.xmldoc" path="declaration/member[@name='Object.FreezeNotify()']/*" />
        public void FreezeNotify()
        {
            CheckFreezeNotifyArgs();
            var @object_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)UnsafeHandle;
            g_object_freeze_notify(@object_);
        }

        /// <summary>
        /// Gets a named field from the objects table of associations (see g_object_set_data()).
        /// </summary>
        /// <param name="object">
        /// #GObject containing the associations
        /// </param>
        /// <param name="key">
        /// name of the key for that association
        /// </param>
        /// <returns>
        /// the data if found,
        ///          or %NULL if no such data exists.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 direction:in */
        private static extern System.IntPtr g_object_get_data(
        /* <type name="Object" type="GObject*" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* @object,
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* key);

        /// <summary>
        /// Gets a property of an object.
        /// </summary>
        /// <remarks>
        /// <para>
        /// The @value can be:
        /// </para>
        /// <para>
        ///  - an empty #GValue initialized by %G_VALUE_INIT, which will be
        ///    automatically initialized with the expected type of the property
        ///    (since GLib 2.60)
        ///  - a #GValue initialized with the expected type of the property
        ///  - a #GValue initialized with a type to which the expected type
        ///    of the property can be transformed
        /// </para>
        /// <para>
        /// In general, a copy is made of the property contents and the caller is
        /// responsible for freeing the memory by calling g_value_unset().
        /// </para>
        /// <para>
        /// Note that g_object_get_property() is really intended for language
        /// bindings, g_object_get() is much more convenient for C programming.
        /// </para>
        /// </remarks>
        /// <param name="object">
        /// a #GObject
        /// </param>
        /// <param name="propertyName">
        /// the name of the property to get
        /// </param>
        /// <param name="value">
        /// return location for the property value
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_object_get_property(
        /* <type name="Object" type="GObject*" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* @object,
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* propertyName,
        /* <type name="Value" type="GValue*" managed-name="Value" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Value* value);
        partial void CheckGetPropertyArgs(GISharp.Lib.GLib.UnownedUtf8 propertyName, ref GISharp.Lib.GObject.Value value);

        /// <include file="Object.xmldoc" path="declaration/member[@name='Object.GetProperty(GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.GObject.Value)']/*" />
        public void GetProperty(GISharp.Lib.GLib.UnownedUtf8 propertyName, ref GISharp.Lib.GObject.Value value)
        {
            fixed (GISharp.Lib.GObject.Value* value_ = &value)
            {
                CheckGetPropertyArgs(propertyName, ref value);
                var @object_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)UnsafeHandle;
                var propertyName_ = (byte*)propertyName.UnsafeHandle;
                g_object_get_property(@object_, propertyName_, value_);
            }
        }

        /// <summary>
        /// This function gets back user data pointers stored via
        /// g_object_set_qdata().
        /// </summary>
        /// <param name="object">
        /// The GObject to get a stored user data pointer from
        /// </param>
        /// <param name="quark">
        /// A #GQuark, naming the user data pointer
        /// </param>
        /// <returns>
        /// The user data pointer set, or %NULL
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 direction:in */
        private static extern System.IntPtr g_object_get_qdata(
        /* <type name="Object" type="GObject*" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* @object,
        /* <type name="GLib.Quark" type="GQuark" managed-name="GISharp.Lib.GLib.Quark" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Quark quark);

        /// <summary>
        /// Gets @n_properties properties for an @object.
        /// Obtained properties will be set to @values. All properties must be valid.
        /// Warnings will be emitted and undefined behaviour may result if invalid
        /// properties are passed in.
        /// </summary>
        /// <param name="object">
        /// a #GObject
        /// </param>
        /// <param name="nProperties">
        /// the number of properties
        /// </param>
        /// <param name="names">
        /// the names of each property to get
        /// </param>
        /// <param name="values">
        /// the values of each property to get
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.54")]
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_object_getv(
        /* <type name="Object" type="GObject*" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* @object,
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        uint nProperties,
        /* <array length="0" zero-terminated="0" type="const gchar**" managed-name="GISharp.Runtime.CArray" is-pointer="1">
*   <type name="utf8" type="gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" />
* </array> */
        /* transfer-ownership:none direction:in */
        byte** names,
        /* <array length="0" zero-terminated="0" type="GValue*" managed-name="GISharp.Runtime.CArray" is-pointer="1">
*   <type name="Value" type="GValue" managed-name="Value" />
* </array> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Value* values);
        partial void CheckGetPropertiesArgs(GISharp.Runtime.UnownedCPtrArray<GISharp.Lib.GLib.Utf8> names, System.ReadOnlySpan<GISharp.Lib.GObject.Value> values);

        /// <include file="Object.xmldoc" path="declaration/member[@name='Object.GetProperties(GISharp.Runtime.UnownedCPtrArray&lt;GISharp.Lib.GLib.Utf8&gt;,System.ReadOnlySpan&lt;GISharp.Lib.GObject.Value&gt;)']/*" />
        [GISharp.Runtime.SinceAttribute("2.54")]
        public void GetProperties(GISharp.Runtime.UnownedCPtrArray<GISharp.Lib.GLib.Utf8> names, System.ReadOnlySpan<GISharp.Lib.GObject.Value> values)
        {
            fixed (GISharp.Lib.GObject.Value* valuesData_ = values)
            {
                fixed (System.IntPtr* namesData_ = names)
                {
                    CheckGetPropertiesArgs(names, values);
                    var @object_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)UnsafeHandle;
                    var names_ = (byte**)namesData_;
                    var nProperties_ = (uint)names.Length;
                    var values_ = (GISharp.Lib.GObject.Value*)valuesData_;
                    nProperties_ = nProperties_ == (uint)values.Length ? nProperties_ : throw new System.ArgumentException("Length length of values must be the same as names", nameof(values));
                    g_object_getv(@object_, nProperties_, names_, values_);
                }
            }
        }

        /// <summary>
        /// Checks whether @object has a [floating][floating-ref] reference.
        /// </summary>
        /// <param name="object">
        /// a #GObject
        /// </param>
        /// <returns>
        /// %TRUE if @object has a floating reference
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.10")]
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_object_is_floating(
        /* <type name="Object" type="gpointer" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* @object);
        partial void CheckGetIsFloatingArgs();

        [GISharp.Runtime.SinceAttribute("2.10")]
        private bool GetIsFloating()
        {
            CheckGetIsFloatingArgs();
            var @object_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_object_is_floating(@object_);
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Emits a "notify" signal for the property @property_name on @object.
        /// </summary>
        /// <remarks>
        /// <para>
        /// When possible, eg. when signaling a property change from within the class
        /// that registered the property, you should use g_object_notify_by_pspec()
        /// instead.
        /// </para>
        /// <para>
        /// Note that emission of the notify signal may be blocked with
        /// g_object_freeze_notify(). In this case, the signal emissions are queued
        /// and will be emitted (in reverse order) when g_object_thaw_notify() is
        /// called.
        /// </para>
        /// </remarks>
        /// <param name="object">
        /// a #GObject
        /// </param>
        /// <param name="propertyName">
        /// the name of a property installed on the class of @object.
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_object_notify(
        /* <type name="Object" type="GObject*" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* @object,
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* propertyName);
        partial void CheckNotifyArgs(GISharp.Lib.GLib.UnownedUtf8 propertyName);

        /// <include file="Object.xmldoc" path="declaration/member[@name='Object.Notify(GISharp.Lib.GLib.UnownedUtf8)']/*" />
        public void Notify(GISharp.Lib.GLib.UnownedUtf8 propertyName)
        {
            CheckNotifyArgs(propertyName);
            var @object_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)UnsafeHandle;
            var propertyName_ = (byte*)propertyName.UnsafeHandle;
            g_object_notify(@object_, propertyName_);
        }

        /// <summary>
        /// Emits a "notify" signal for the property specified by @pspec on @object.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This function omits the property name lookup, hence it is faster than
        /// g_object_notify().
        /// </para>
        /// <para>
        /// One way to avoid using g_object_notify() from within the
        /// class that registered the properties, and using g_object_notify_by_pspec()
        /// instead, is to store the GParamSpec used with
        /// g_object_class_install_property() inside a static array, e.g.:
        /// </para>
        /// <para>
        /// |[&lt;!-- language="C" --&gt;
        ///   enum
        ///   {
        ///     PROP_0,
        ///     PROP_FOO,
        ///     PROP_LAST
        ///   };
        /// </para>
        /// <para>
        ///   static GParamSpec *properties[PROP_LAST];
        /// </para>
        /// <para>
        ///   static void
        ///   my_object_class_init (MyObjectClass *klass)
        ///   {
        ///     properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
        ///                                              0, 100,
        ///                                              50,
        ///                                              G_PARAM_READWRITE);
        ///     g_object_class_install_property (gobject_class,
        ///                                      PROP_FOO,
        ///                                      properties[PROP_FOO]);
        ///   }
        /// ]|
        /// </para>
        /// <para>
        /// and then notify a change on the "foo" property with:
        /// </para>
        /// <para>
        /// |[&lt;!-- language="C" --&gt;
        ///   g_object_notify_by_pspec (self, properties[PROP_FOO]);
        /// ]|
        /// </para>
        /// </remarks>
        /// <param name="object">
        /// a #GObject
        /// </param>
        /// <param name="pspec">
        /// the #GParamSpec of a property installed on the class of @object.
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.26")]
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_object_notify_by_pspec(
        /* <type name="Object" type="GObject*" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* @object,
        /* <type name="ParamSpec" type="GParamSpec*" managed-name="ParamSpec" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.ParamSpec.UnmanagedStruct* pspec);
        partial void CheckNotifyArgs(GISharp.Lib.GObject.ParamSpec pspec);

        /// <include file="Object.xmldoc" path="declaration/member[@name='Object.Notify(GISharp.Lib.GObject.ParamSpec)']/*" />
        [GISharp.Runtime.SinceAttribute("2.26")]
        public void Notify(GISharp.Lib.GObject.ParamSpec pspec)
        {
            CheckNotifyArgs(pspec);
            var @object_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)UnsafeHandle;
            var pspec_ = (GISharp.Lib.GObject.ParamSpec.UnmanagedStruct*)pspec.UnsafeHandle;
            g_object_notify_by_pspec(@object_, pspec_);
        }

        /// <summary>
        /// Increases the reference count of @object.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
        /// of @object will be propagated to the return type (using the GCC typeof()
        /// extension), so any casting the caller needs to do on the return type must be
        /// explicit.
        /// </para>
        /// </remarks>
        /// <param name="object">
        /// a #GObject
        /// </param>
        /// <returns>
        /// the same @object
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Object" type="gpointer" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GObject.Object.UnmanagedStruct* g_object_ref(
        /* <type name="Object" type="gpointer" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* @object);

        /// <summary>
        /// Takes ownership of the unmanaged pointer without freeing it.
        /// The managed object can no longer be used (will throw disposed exception).
        /// </summary>
        public override System.IntPtr Take() => (System.IntPtr)g_object_ref((GISharp.Lib.GObject.Object.UnmanagedStruct*)UnsafeHandle);

        /// <summary>
        /// Increase the reference count of @object, and possibly remove the
        /// [floating][floating-ref] reference, if @object has a floating reference.
        /// </summary>
        /// <remarks>
        /// <para>
        /// In other words, if the object is floating, then this call "assumes
        /// ownership" of the floating reference, converting it to a normal
        /// reference by clearing the floating flag while leaving the reference
        /// count unchanged.  If the object is not floating, then this call
        /// adds a new normal reference increasing the reference count by one.
        /// </para>
        /// <para>
        /// Since GLib 2.56, the type of @object will be propagated to the return type
        /// under the same conditions as for g_object_ref().
        /// </para>
        /// </remarks>
        /// <param name="object">
        /// a #GObject
        /// </param>
        /// <returns>
        /// @object
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.10")]
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Object" type="gpointer" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GObject.Object.UnmanagedStruct* g_object_ref_sink(
        /* <type name="Object" type="gpointer" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* @object);

        /// <summary>
        /// Removes a reference added with g_object_add_toggle_ref(). The
        /// reference count of the object is decreased by one.
        /// </summary>
        /// <param name="object">
        /// a #GObject
        /// </param>
        /// <param name="notify">
        /// a function to call when this reference is the
        ///  last reference to the object, or is no longer
        ///  the last reference.
        /// </param>
        /// <param name="data">
        /// data to pass to @notify
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.8")]
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_object_remove_toggle_ref(
        /* <type name="Object" type="GObject*" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* @object,
        /* <type name="ToggleNotify" type="GToggleNotify" managed-name="ToggleNotify" /> */
        /* transfer-ownership:none closure:1 direction:in */
        delegate* unmanaged[Cdecl]<System.IntPtr, GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Runtime.Boolean, void> notify,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr data);

        /// <summary>
        /// Compares the user data for the key @key on @object with
        /// @oldval, and if they are the same, replaces @oldval with
        /// @newval.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This is like a typical atomic compare-and-exchange
        /// operation, for user data on an object.
        /// </para>
        /// <para>
        /// If the previous value was replaced then ownership of the
        /// old value (@oldval) is passed to the caller, including
        /// the registered destroy notify for it (passed out in @old_destroy).
        /// Its up to the caller to free this as needed, which may
        /// or may not include using @old_destroy as sometimes replacement
        /// should not destroy the object in the normal way.
        /// </para>
        /// <para>
        /// See g_object_set_data() for guidance on using a small, bounded set of values
        /// for @key.
        /// </para>
        /// </remarks>
        /// <param name="object">
        /// the #GObject to store user data on
        /// </param>
        /// <param name="key">
        /// a string, naming the user data pointer
        /// </param>
        /// <param name="oldval">
        /// the old value to compare against
        /// </param>
        /// <param name="newval">
        /// the new value
        /// </param>
        /// <param name="destroy">
        /// a destroy notify for the new value
        /// </param>
        /// <param name="oldDestroy">
        /// destroy notify for the existing value
        /// </param>
        /// <returns>
        /// %TRUE if the existing value for @key was replaced
        ///  by @newval, %FALSE otherwise.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.34")]
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_object_replace_data(
        /* <type name="Object" type="GObject*" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* @object,
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* key,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr oldval,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr newval,
        /* <type name="GLib.DestroyNotify" type="GDestroyNotify" managed-name="GISharp.Lib.GLib.DestroyNotify" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:async direction:in */
        delegate* unmanaged[Cdecl]<System.IntPtr, void> destroy,
        /* <type name="GLib.DestroyNotify" type="GDestroyNotify*" managed-name="GISharp.Lib.GLib.DestroyNotify" /> */
        /* direction:out caller-allocates:0 transfer-ownership:none optional:1 allow-none:1 scope:async */
        delegate* unmanaged[Cdecl]<System.IntPtr, void>* oldDestroy);

        /// <summary>
        /// Compares the user data for the key @quark on @object with
        /// @oldval, and if they are the same, replaces @oldval with
        /// @newval.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This is like a typical atomic compare-and-exchange
        /// operation, for user data on an object.
        /// </para>
        /// <para>
        /// If the previous value was replaced then ownership of the
        /// old value (@oldval) is passed to the caller, including
        /// the registered destroy notify for it (passed out in @old_destroy).
        /// Its up to the caller to free this as needed, which may
        /// or may not include using @old_destroy as sometimes replacement
        /// should not destroy the object in the normal way.
        /// </para>
        /// </remarks>
        /// <param name="object">
        /// the #GObject to store user data on
        /// </param>
        /// <param name="quark">
        /// a #GQuark, naming the user data pointer
        /// </param>
        /// <param name="oldval">
        /// the old value to compare against
        /// </param>
        /// <param name="newval">
        /// the new value
        /// </param>
        /// <param name="destroy">
        /// a destroy notify for the new value
        /// </param>
        /// <param name="oldDestroy">
        /// destroy notify for the existing value
        /// </param>
        /// <returns>
        /// %TRUE if the existing value for @quark was replaced
        ///  by @newval, %FALSE otherwise.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.34")]
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_object_replace_qdata(
        /* <type name="Object" type="GObject*" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* @object,
        /* <type name="GLib.Quark" type="GQuark" managed-name="GISharp.Lib.GLib.Quark" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Quark quark,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr oldval,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr newval,
        /* <type name="GLib.DestroyNotify" type="GDestroyNotify" managed-name="GISharp.Lib.GLib.DestroyNotify" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:async direction:in */
        delegate* unmanaged[Cdecl]<System.IntPtr, void> destroy,
        /* <type name="GLib.DestroyNotify" type="GDestroyNotify*" managed-name="GISharp.Lib.GLib.DestroyNotify" /> */
        /* direction:out caller-allocates:0 transfer-ownership:none optional:1 allow-none:1 scope:async */
        delegate* unmanaged[Cdecl]<System.IntPtr, void>* oldDestroy);

        /// <summary>
        /// Releases all references to other objects. This can be used to break
        /// reference cycles.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This function should only be called from object system implementations.
        /// </para>
        /// </remarks>
        /// <param name="object">
        /// a #GObject
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_object_run_dispose(
        /* <type name="Object" type="GObject*" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* @object);
        partial void CheckRunDisposeArgs();

        /// <include file="Object.xmldoc" path="declaration/member[@name='Object.RunDispose()']/*" />
        public void RunDispose()
        {
            CheckRunDisposeArgs();
            var @object_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)UnsafeHandle;
            g_object_run_dispose(@object_);
        }

        /// <summary>
        /// Each object carries around a table of associations from
        /// strings to pointers.  This function lets you set an association.
        /// </summary>
        /// <remarks>
        /// <para>
        /// If the object already had an association with that name,
        /// the old association will be destroyed.
        /// </para>
        /// <para>
        /// Internally, the @key is converted to a #GQuark using g_quark_from_string().
        /// This means a copy of @key is kept permanently (even after @object has been
        /// finalized)  so it is recommended to only use a small, bounded set of values
        /// for @key in your program, to avoid the #GQuark storage growing unbounded.
        /// </para>
        /// </remarks>
        /// <param name="object">
        /// #GObject containing the associations.
        /// </param>
        /// <param name="key">
        /// name of the key
        /// </param>
        /// <param name="data">
        /// data to associate with that key
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_object_set_data(
        /* <type name="Object" type="GObject*" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* @object,
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* key,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr data);

        /// <summary>
        /// Like g_object_set_data() except it adds notification
        /// for when the association is destroyed, either by setting it
        /// to a different value or when the object is destroyed.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Note that the @destroy callback is not called if @data is %NULL.
        /// </para>
        /// </remarks>
        /// <param name="object">
        /// #GObject containing the associations
        /// </param>
        /// <param name="key">
        /// name of the key
        /// </param>
        /// <param name="data">
        /// data to associate with that key
        /// </param>
        /// <param name="destroy">
        /// function to call when the association is destroyed
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_object_set_data_full(
        /* <type name="Object" type="GObject*" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* @object,
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* key,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr data,
        /* <type name="GLib.DestroyNotify" type="GDestroyNotify" managed-name="GISharp.Lib.GLib.DestroyNotify" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:async direction:in */
        delegate* unmanaged[Cdecl]<System.IntPtr, void> destroy);

        /// <summary>
        /// Sets a property on an object.
        /// </summary>
        /// <param name="object">
        /// a #GObject
        /// </param>
        /// <param name="propertyName">
        /// the name of the property to set
        /// </param>
        /// <param name="value">
        /// the value
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_object_set_property(
        /* <type name="Object" type="GObject*" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* @object,
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* propertyName,
        /* <type name="Value" type="const GValue*" managed-name="Value" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Value* value);
        partial void CheckSetPropertyArgs(GISharp.Lib.GLib.UnownedUtf8 propertyName, in GISharp.Lib.GObject.Value value);

        /// <include file="Object.xmldoc" path="declaration/member[@name='Object.SetProperty(GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.GObject.Value)']/*" />
        public void SetProperty(GISharp.Lib.GLib.UnownedUtf8 propertyName, in GISharp.Lib.GObject.Value value)
        {
            fixed (GISharp.Lib.GObject.Value* value_ = &value)
            {
                CheckSetPropertyArgs(propertyName, value);
                var @object_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)UnsafeHandle;
                var propertyName_ = (byte*)propertyName.UnsafeHandle;
                g_object_set_property(@object_, propertyName_, value_);
            }
        }

        /// <summary>
        /// This sets an opaque, named pointer on an object.
        /// The name is specified through a #GQuark (retrieved e.g. via
        /// g_quark_from_static_string()), and the pointer
        /// can be gotten back from the @object with g_object_get_qdata()
        /// until the @object is finalized.
        /// Setting a previously set user data pointer, overrides (frees)
        /// the old pointer set, using #NULL as pointer essentially
        /// removes the data stored.
        /// </summary>
        /// <param name="object">
        /// The GObject to set store a user data pointer
        /// </param>
        /// <param name="quark">
        /// A #GQuark, naming the user data pointer
        /// </param>
        /// <param name="data">
        /// An opaque user data pointer
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_object_set_qdata(
        /* <type name="Object" type="GObject*" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* @object,
        /* <type name="GLib.Quark" type="GQuark" managed-name="GISharp.Lib.GLib.Quark" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Quark quark,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr data);

        /// <summary>
        /// This function works like g_object_set_qdata(), but in addition,
        /// a void (*destroy) (gpointer) function may be specified which is
        /// called with @data as argument when the @object is finalized, or
        /// the data is being overwritten by a call to g_object_set_qdata()
        /// with the same @quark.
        /// </summary>
        /// <param name="object">
        /// The GObject to set store a user data pointer
        /// </param>
        /// <param name="quark">
        /// A #GQuark, naming the user data pointer
        /// </param>
        /// <param name="data">
        /// An opaque user data pointer
        /// </param>
        /// <param name="destroy">
        /// Function to invoke with @data as argument, when @data
        ///           needs to be freed
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_object_set_qdata_full(
        /* <type name="Object" type="GObject*" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* @object,
        /* <type name="GLib.Quark" type="GQuark" managed-name="GISharp.Lib.GLib.Quark" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Quark quark,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr data,
        /* <type name="GLib.DestroyNotify" type="GDestroyNotify" managed-name="GISharp.Lib.GLib.DestroyNotify" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:async direction:in */
        delegate* unmanaged[Cdecl]<System.IntPtr, void> destroy);

        /// <summary>
        /// Remove a specified datum from the object's data associations,
        /// without invoking the association's destroy handler.
        /// </summary>
        /// <param name="object">
        /// #GObject containing the associations
        /// </param>
        /// <param name="key">
        /// name of the key
        /// </param>
        /// <returns>
        /// the data if found, or %NULL
        ///          if no such data exists.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:full nullable:1 direction:in */
        private static extern System.IntPtr g_object_steal_data(
        /* <type name="Object" type="GObject*" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* @object,
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* key);

        /// <summary>
        /// This function gets back user data pointers stored via
        /// g_object_set_qdata() and removes the @data from object
        /// without invoking its destroy() function (if any was
        /// set).
        /// Usually, calling this function is only required to update
        /// user data pointers with a destroy notifier, for example:
        /// |[&lt;!-- language="C" --&gt;
        /// void
        /// object_add_to_user_list (GObject     *object,
        ///                          const gchar *new_string)
        /// {
        ///   // the quark, naming the object data
        ///   GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
        ///   // retrieve the old string list
        ///   GList *list = g_object_steal_qdata (object, quark_string_list);
        /// </summary>
        /// <remarks>
        /// <para>
        ///   // prepend new string
        ///   list = g_list_prepend (list, g_strdup (new_string));
        ///   // this changed 'list', so we need to set it again
        ///   g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
        /// }
        /// static void
        /// free_string_list (gpointer data)
        /// {
        ///   GList *node, *list = data;
        /// </para>
        /// <para>
        ///   for (node = list; node; node = node-&gt;next)
        ///     g_free (node-&gt;data);
        ///   g_list_free (list);
        /// }
        /// ]|
        /// Using g_object_get_qdata() in the above example, instead of
        /// g_object_steal_qdata() would have left the destroy function set,
        /// and thus the partial string list would have been freed upon
        /// g_object_set_qdata_full().
        /// </para>
        /// </remarks>
        /// <param name="object">
        /// The GObject to get a stored user data pointer from
        /// </param>
        /// <param name="quark">
        /// A #GQuark, naming the user data pointer
        /// </param>
        /// <returns>
        /// The user data pointer set, or %NULL
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:full nullable:1 direction:in */
        private static extern System.IntPtr g_object_steal_qdata(
        /* <type name="Object" type="GObject*" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* @object,
        /* <type name="GLib.Quark" type="GQuark" managed-name="GISharp.Lib.GLib.Quark" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Quark quark);

        /// <summary>
        /// Reverts the effect of a previous call to
        /// g_object_freeze_notify(). The freeze count is decreased on @object
        /// and when it reaches zero, queued "notify" signals are emitted.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Duplicate notifications for each property are squashed so that at most one
        /// #GObject::notify signal is emitted for each property, in the reverse order
        /// in which they have been queued.
        /// </para>
        /// <para>
        /// It is an error to call this function when the freeze count is zero.
        /// </para>
        /// </remarks>
        /// <param name="object">
        /// a #GObject
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_object_thaw_notify(
        /* <type name="Object" type="GObject*" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* @object);
        partial void CheckThawNotifyArgs();

        /// <include file="Object.xmldoc" path="declaration/member[@name='Object.ThawNotify()']/*" />
        public void ThawNotify()
        {
            CheckThawNotifyArgs();
            var @object_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)UnsafeHandle;
            g_object_thaw_notify(@object_);
        }

        /// <summary>
        /// Decreases the reference count of @object. When its reference count
        /// drops to 0, the object is finalized (i.e. its memory is freed).
        /// </summary>
        /// <remarks>
        /// <para>
        /// If the pointer to the #GObject may be reused in future (for example, if it is
        /// an instance variable of another object), it is recommended to clear the
        /// pointer to %NULL rather than retain a dangling pointer to a potentially
        /// invalid #GObject instance. Use g_clear_object() for this.
        /// </para>
        /// </remarks>
        /// <param name="object">
        /// a #GObject
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_object_unref(
        /* <type name="Object" type="gpointer" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* @object);

        /// <summary>
        /// This function essentially limits the life time of the @closure to
        /// the life time of the object. That is, when the object is finalized,
        /// the @closure is invalidated by calling g_closure_invalidate() on
        /// it, in order to prevent invocations of the closure with a finalized
        /// (nonexisting) object. Also, g_object_ref() and g_object_unref() are
        /// added as marshal guards to the @closure, to ensure that an extra
        /// reference count is held on @object during invocation of the
        /// @closure.  Usually, this function will be called on closures that
        /// use this @object as closure data.
        /// </summary>
        /// <param name="object">
        /// #GObject restricting lifetime of @closure
        /// </param>
        /// <param name="closure">
        /// #GClosure to watch
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_object_watch_closure(
        /* <type name="Object" type="GObject*" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* @object,
        /* <type name="Closure" type="GClosure*" managed-name="Closure" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Closure.UnmanagedStruct* closure);
        partial void CheckWatchClosureArgs(GISharp.Lib.GObject.Closure closure);

        /// <include file="Object.xmldoc" path="declaration/member[@name='Object.WatchClosure(GISharp.Lib.GObject.Closure)']/*" />
        public void WatchClosure(GISharp.Lib.GObject.Closure closure)
        {
            CheckWatchClosureArgs(closure);
            var @object_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)UnsafeHandle;
            var closure_ = (GISharp.Lib.GObject.Closure.UnmanagedStruct*)closure.UnsafeHandle;
            g_object_watch_closure(@object_, closure_);
        }

        /// <include file="Object.xmldoc" path="declaration/member[@name='Object.DoConstructed()']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(ObjectClass.UnmanagedConstructed))]
        protected virtual void DoConstructed()
        {
            var @object_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)UnsafeHandle;
            GISharp.Lib.GObject.TypeClass.GetUnmanagedVirtualMethod<ObjectClass.UnmanagedConstructed>(_GType)!(@object_);
        }

        /// <include file="Object.xmldoc" path="declaration/member[@name='Object.DoDispatchPropertiesChanged(uint,GISharp.Lib.GObject.ParamSpec)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(ObjectClass.UnmanagedDispatchPropertiesChanged))]
        protected virtual void DoDispatchPropertiesChanged(uint nPspecs, GISharp.Lib.GObject.ParamSpec pspecs)
        {
            var @object_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)UnsafeHandle;
            var nPspecs_ = (uint)nPspecs;
            var pspecs_ = (GISharp.Lib.GObject.ParamSpec.UnmanagedStruct*)pspecs.UnsafeHandle;
            GISharp.Lib.GObject.TypeClass.GetUnmanagedVirtualMethod<ObjectClass.UnmanagedDispatchPropertiesChanged>(_GType)!(@object_, nPspecs_, pspecs_);
        }

        /// <include file="Object.xmldoc" path="declaration/member[@name='Object.DoDispose()']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(ObjectClass.UnmanagedDispose))]
        protected virtual void DoDispose()
        {
            var @object_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)UnsafeHandle;
            GISharp.Lib.GObject.TypeClass.GetUnmanagedVirtualMethod<ObjectClass.UnmanagedDispose>(_GType)!(@object_);
        }

        /// <include file="Object.xmldoc" path="declaration/member[@name='Object.DoFinalize()']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(ObjectClass.UnmanagedFinalize))]
        protected virtual void DoFinalize()
        {
            var @object_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)UnsafeHandle;
            GISharp.Lib.GObject.TypeClass.GetUnmanagedVirtualMethod<ObjectClass.UnmanagedFinalize>(_GType)!(@object_);
        }

        /// <include file="Object.xmldoc" path="declaration/member[@name='Object.DoGetProperty(uint,GISharp.Lib.GObject.Value,GISharp.Lib.GObject.ParamSpec)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(ObjectClass.UnmanagedGetProperty))]
        protected virtual void DoGetProperty(uint propertyId, ref GISharp.Lib.GObject.Value value, GISharp.Lib.GObject.ParamSpec pspec)
        {
            fixed (GISharp.Lib.GObject.Value* value_ = &value)
            {
                var @object_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)UnsafeHandle;
                var propertyId_ = (uint)propertyId;
                var pspec_ = (GISharp.Lib.GObject.ParamSpec.UnmanagedStruct*)pspec.UnsafeHandle;
                GISharp.Lib.GObject.TypeClass.GetUnmanagedVirtualMethod<ObjectClass.UnmanagedGetProperty>(_GType)!(@object_, propertyId_, value_, pspec_);
            }
        }

        /// <include file="Object.xmldoc" path="declaration/member[@name='Object.DoNotify(GISharp.Lib.GObject.ParamSpec)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(ObjectClass.UnmanagedNotify))]
        protected virtual void DoNotify(GISharp.Lib.GObject.ParamSpec pspec)
        {
            var @object_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)UnsafeHandle;
            var pspec_ = (GISharp.Lib.GObject.ParamSpec.UnmanagedStruct*)pspec.UnsafeHandle;
            GISharp.Lib.GObject.TypeClass.GetUnmanagedVirtualMethod<ObjectClass.UnmanagedNotify>(_GType)!(@object_, pspec_);
        }

        /// <include file="Object.xmldoc" path="declaration/member[@name='Object.DoSetProperty(uint,GISharp.Lib.GObject.Value,GISharp.Lib.GObject.ParamSpec)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(ObjectClass.UnmanagedSetProperty))]
        protected virtual void DoSetProperty(uint propertyId, in GISharp.Lib.GObject.Value value, GISharp.Lib.GObject.ParamSpec pspec)
        {
            fixed (GISharp.Lib.GObject.Value* value_ = &value)
            {
                var @object_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)UnsafeHandle;
                var propertyId_ = (uint)propertyId;
                var pspec_ = (GISharp.Lib.GObject.ParamSpec.UnmanagedStruct*)pspec.UnsafeHandle;
                GISharp.Lib.GObject.TypeClass.GetUnmanagedVirtualMethod<ObjectClass.UnmanagedSetProperty>(_GType)!(@object_, propertyId_, value_, pspec_);
            }
        }
    }
}