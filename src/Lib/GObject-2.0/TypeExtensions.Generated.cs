// SPDX-License-Identifier: MIT
// ATTENTION: This file is automatically generated. Do not edit manually.
#nullable enable
namespace GISharp.Lib.GObject
{
    /// <include file="TypeExtensions.xmldoc" path="declaration/member[@name='TypeExtensions']/*" />
    public static unsafe partial class TypeExtensions
    {
        /// <include file="TypeExtensions.xmldoc" path="declaration/member[@name='TypeExtensions.flagReservedIdBit']/*" />
        private const System.Int32 flagReservedIdBit = 1;

        /// <include file="TypeExtensions.xmldoc" path="declaration/member[@name='TypeExtensions.fundamentalMax']/*" />
        private const System.Int32 fundamentalMax = 255;

        /// <include file="TypeExtensions.xmldoc" path="declaration/member[@name='TypeExtensions.fundamentalShift']/*" />
        private const System.Int32 fundamentalShift = 2;

        /// <include file="TypeExtensions.xmldoc" path="declaration/member[@name='TypeExtensions.reservedBseFirst']/*" />
        private const System.Int32 reservedBseFirst = 32;

        /// <include file="TypeExtensions.xmldoc" path="declaration/member[@name='TypeExtensions.reservedBseLast']/*" />
        private const System.Int32 reservedBseLast = 48;

        /// <include file="TypeExtensions.xmldoc" path="declaration/member[@name='TypeExtensions.reservedGlibFirst']/*" />
        private const System.Int32 reservedGlibFirst = 22;

        /// <include file="TypeExtensions.xmldoc" path="declaration/member[@name='TypeExtensions.reservedGlibLast']/*" />
        private const System.Int32 reservedGlibLast = 31;

        /// <include file="TypeExtensions.xmldoc" path="declaration/member[@name='TypeExtensions.reservedUserFirst']/*" />
        private const System.Int32 reservedUserFirst = 49;

        /// <include file="TypeExtensions.xmldoc" path="declaration/member[@name='TypeExtensions.TypeRegistrationSerial']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        public static uint TypeRegistrationSerial { get => GetTypeRegistrationSerial(); }

        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_type_check_class_is_a(
/* <type name="TypeClass" type="GTypeClass*" managed-name="TypeClass" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.GObject.TypeClass.UnmanagedStruct* gClass,
/* <type name="GType" type="GType" managed-name="GISharp.Runtime.GType" /> */
/* transfer-ownership:none direction:in */
GISharp.Runtime.GType isAType);
        static partial void CheckCheckClassIsAArgs(GISharp.Lib.GObject.TypeClass gClass, GISharp.Runtime.GType isAType);

        /// <include file="TypeExtensions.xmldoc" path="declaration/member[@name='TypeExtensions.CheckClassIsA(GISharp.Lib.GObject.TypeClass,GISharp.Runtime.GType)']/*" />
        public static bool CheckClassIsA(GISharp.Lib.GObject.TypeClass gClass, GISharp.Runtime.GType isAType)
        {
            CheckCheckClassIsAArgs(gClass, isAType);
            var gClass_ = (GISharp.Lib.GObject.TypeClass.UnmanagedStruct*)gClass.UnsafeHandle;
            var isAType_ = (GISharp.Runtime.GType)isAType;
            var ret_ = g_type_check_class_is_a(gClass_,isAType_);
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Private helper function to aid implementation of the
        /// G_TYPE_CHECK_INSTANCE() macro.
        /// </summary>
        /// <param name="instance">
        /// a valid #GTypeInstance structure
        /// </param>
        /// <returns>
        /// %TRUE if @instance is valid, %FALSE otherwise
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_type_check_instance(
        /* <type name="TypeInstance" type="GTypeInstance*" managed-name="TypeInstance" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.TypeInstance.UnmanagedStruct* instance);
        static partial void CheckCheckInstanceArgs(GISharp.Lib.GObject.TypeInstance instance);

        /// <include file="TypeExtensions.xmldoc" path="declaration/member[@name='TypeExtensions.CheckInstance(GISharp.Lib.GObject.TypeInstance)']/*" />
        public static bool CheckInstance(GISharp.Lib.GObject.TypeInstance instance)
        {
            CheckCheckInstanceArgs(instance);
            var instance_ = (GISharp.Lib.GObject.TypeInstance.UnmanagedStruct*)instance.UnsafeHandle;
            var ret_ = g_type_check_instance(instance_);
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_type_check_instance_is_a(
/* <type name="TypeInstance" type="GTypeInstance*" managed-name="TypeInstance" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.GObject.TypeInstance.UnmanagedStruct* instance,
/* <type name="GType" type="GType" managed-name="GISharp.Runtime.GType" /> */
/* transfer-ownership:none direction:in */
GISharp.Runtime.GType ifaceType);
        static partial void CheckCheckInstanceIsAArgs(GISharp.Lib.GObject.TypeInstance instance, GISharp.Runtime.GType ifaceType);

        /// <include file="TypeExtensions.xmldoc" path="declaration/member[@name='TypeExtensions.CheckInstanceIsA(GISharp.Lib.GObject.TypeInstance,GISharp.Runtime.GType)']/*" />
        public static bool CheckInstanceIsA(GISharp.Lib.GObject.TypeInstance instance, GISharp.Runtime.GType ifaceType)
        {
            CheckCheckInstanceIsAArgs(instance, ifaceType);
            var instance_ = (GISharp.Lib.GObject.TypeInstance.UnmanagedStruct*)instance.UnsafeHandle;
            var ifaceType_ = (GISharp.Runtime.GType)ifaceType;
            var ret_ = g_type_check_instance_is_a(instance_,ifaceType_);
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_type_check_instance_is_fundamentally_a(
/* <type name="TypeInstance" type="GTypeInstance*" managed-name="TypeInstance" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.GObject.TypeInstance.UnmanagedStruct* instance,
/* <type name="GType" type="GType" managed-name="GISharp.Runtime.GType" /> */
/* transfer-ownership:none direction:in */
GISharp.Runtime.GType fundamentalType);
        static partial void CheckCheckInstanceIsFundamentallyAArgs(GISharp.Lib.GObject.TypeInstance instance, GISharp.Runtime.GType fundamentalType);

        /// <include file="TypeExtensions.xmldoc" path="declaration/member[@name='TypeExtensions.CheckInstanceIsFundamentallyA(GISharp.Lib.GObject.TypeInstance,GISharp.Runtime.GType)']/*" />
        public static bool CheckInstanceIsFundamentallyA(GISharp.Lib.GObject.TypeInstance instance, GISharp.Runtime.GType fundamentalType)
        {
            CheckCheckInstanceIsFundamentallyAArgs(instance, fundamentalType);
            var instance_ = (GISharp.Lib.GObject.TypeInstance.UnmanagedStruct*)instance.UnsafeHandle;
            var fundamentalType_ = (GISharp.Runtime.GType)fundamentalType;
            var ret_ = g_type_check_instance_is_fundamentally_a(instance_,fundamentalType_);
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_type_check_value(
/* <type name="Value" type="const GValue*" managed-name="Value" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.GObject.Value* value);
        static partial void CheckCheckValueArgs(in GISharp.Lib.GObject.Value value);

        /// <include file="TypeExtensions.xmldoc" path="declaration/member[@name='TypeExtensions.CheckValue(GISharp.Lib.GObject.Value)']/*" />
        public static bool CheckValue(in GISharp.Lib.GObject.Value value)
        {
            fixed (GISharp.Lib.GObject.Value* value_ = &value)
            {
                CheckCheckValueArgs(value);
                var ret_ = g_type_check_value(value_);
                var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
                return ret;
            }
        }

        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_type_check_value_holds(
/* <type name="Value" type="const GValue*" managed-name="Value" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.GObject.Value* value,
/* <type name="GType" type="GType" managed-name="GISharp.Runtime.GType" /> */
/* transfer-ownership:none direction:in */
GISharp.Runtime.GType type);
        static partial void CheckCheckValueHoldsArgs(in GISharp.Lib.GObject.Value value, GISharp.Runtime.GType type);

        /// <include file="TypeExtensions.xmldoc" path="declaration/member[@name='TypeExtensions.CheckValueHolds(GISharp.Lib.GObject.Value,GISharp.Runtime.GType)']/*" />
        public static bool CheckValueHolds(in GISharp.Lib.GObject.Value value, GISharp.Runtime.GType type)
        {
            fixed (GISharp.Lib.GObject.Value* value_ = &value)
            {
                CheckCheckValueHoldsArgs(value, type);
                var type_ = (GISharp.Runtime.GType)type;
                var ret_ = g_type_check_value_holds(value_,type_);
                var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
                return ret;
            }
        }

        /// <summary>
        /// Frees an instance of a type, returning it to the instance pool for
        /// the type, if there is one.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Like g_type_create_instance(), this function is reserved for
        /// implementors of fundamental types.
        /// </para>
        /// </remarks>
        /// <param name="instance">
        /// an instance of a type
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_type_free_instance(
        /* <type name="TypeInstance" type="GTypeInstance*" managed-name="TypeInstance" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.TypeInstance.UnmanagedStruct* instance);
        static partial void CheckFreeInstanceArgs(GISharp.Lib.GObject.TypeInstance instance);

        /// <include file="TypeExtensions.xmldoc" path="declaration/member[@name='TypeExtensions.FreeInstance(GISharp.Lib.GObject.TypeInstance)']/*" />
        public static void FreeInstance(GISharp.Lib.GObject.TypeInstance instance)
        {
            CheckFreeInstanceArgs(instance);
            var instance_ = (GISharp.Lib.GObject.TypeInstance.UnmanagedStruct*)instance.UnsafeHandle;
            g_type_free_instance(instance_);
        }

        /// <summary>
        /// Returns the next free fundamental type id which can be used to
        /// register a new fundamental type with g_type_register_fundamental().
        /// The returned type ID represents the highest currently registered
        /// fundamental type identifier.
        /// </summary>
        /// <returns>
        /// the next available fundamental type ID to be registered,
        ///     or 0 if the type system ran out of fundamental type IDs
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="GType" type="GType" managed-name="GISharp.Runtime.GType" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.GType g_type_fundamental_next();
        static partial void CheckFundamentalNextArgs();

        /// <include file="TypeExtensions.xmldoc" path="declaration/member[@name='TypeExtensions.FundamentalNext()']/*" />
        public static GISharp.Runtime.GType FundamentalNext()
        {
            CheckFundamentalNextArgs();
            var ret_ = g_type_fundamental_next();
            var ret = (GISharp.Runtime.GType)ret_;
            return ret;
        }

        /// <summary>
        /// Returns an opaque serial number that represents the state of the set
        /// of registered types. Any time a type is registered this serial changes,
        /// which means you can cache information based on type lookups (such as
        /// g_type_from_name()) and know if the cache is still valid at a later
        /// time by comparing the current serial with the one at the type lookup.
        /// </summary>
        /// <returns>
        /// An unsigned int, representing the state of type registrations
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        private static extern uint g_type_get_type_registration_serial();
        static partial void CheckGetTypeRegistrationSerialArgs();

        [GISharp.Runtime.SinceAttribute("2.36")]
        private static uint GetTypeRegistrationSerial()
        {
            CheckGetTypeRegistrationSerialArgs();
            var ret_ = g_type_get_type_registration_serial();
            var ret = (uint)ret_;
            return ret;
        }

        /// <summary>
        /// This function used to initialise the type system.  Since GLib 2.36,
        /// the type system is initialised automatically and this function does
        /// nothing.
        /// </summary>
        [System.ObsoleteAttribute("the type system is now initialised automatically")]
        [GISharp.Runtime.DeprecatedSinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_type_init();
        static partial void CheckInitArgs();

        /// <include file="TypeExtensions.xmldoc" path="declaration/member[@name='TypeExtensions.Init()']/*" />
        [System.ObsoleteAttribute("the type system is now initialised automatically")]
        [GISharp.Runtime.DeprecatedSinceAttribute("2.36")]
        public static void Init()
        {
            CheckInitArgs();
            g_type_init();
        }

        /// <summary>
        /// This function used to initialise the type system with debugging
        /// flags.  Since GLib 2.36, the type system is initialised automatically
        /// and this function does nothing.
        /// </summary>
        /// <remarks>
        /// <para>
        /// If you need to enable debugging features, use the GOBJECT_DEBUG
        /// environment variable.
        /// </para>
        /// </remarks>
        /// <param name="debugFlags">
        /// bitwise combination of #GTypeDebugFlags values for
        ///     debugging purposes
        /// </param>
        [System.ObsoleteAttribute("the type system is now initialised automatically")]
        [GISharp.Runtime.DeprecatedSinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_type_init_with_debug_flags(
        /* <type name="TypeDebugFlags" type="GTypeDebugFlags" managed-name="TypeDebugFlags" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.TypeDebugFlags debugFlags);
        static partial void CheckInitWithDebugFlagsArgs(GISharp.Lib.GObject.TypeDebugFlags debugFlags);

        /// <include file="TypeExtensions.xmldoc" path="declaration/member[@name='TypeExtensions.InitWithDebugFlags(GISharp.Lib.GObject.TypeDebugFlags)']/*" />
        [System.ObsoleteAttribute("the type system is now initialised automatically")]
        [GISharp.Runtime.DeprecatedSinceAttribute("2.36")]
        public static void InitWithDebugFlags(GISharp.Lib.GObject.TypeDebugFlags debugFlags)
        {
            CheckInitWithDebugFlagsArgs(debugFlags);
            var debugFlags_ = (GISharp.Lib.GObject.TypeDebugFlags)debugFlags;
            g_type_init_with_debug_flags(debugFlags_);
        }

        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern byte* g_type_name_from_class(
/* <type name="TypeClass" type="GTypeClass*" managed-name="TypeClass" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.GObject.TypeClass.UnmanagedStruct* gClass);
        static partial void CheckNameFromClassArgs(GISharp.Lib.GObject.TypeClass gClass);

        /// <include file="TypeExtensions.xmldoc" path="declaration/member[@name='TypeExtensions.NameFromClass(GISharp.Lib.GObject.TypeClass)']/*" />
        public static GISharp.Lib.GLib.UnownedUtf8 NameFromClass(GISharp.Lib.GObject.TypeClass gClass)
        {
            CheckNameFromClassArgs(gClass);
            var gClass_ = (GISharp.Lib.GObject.TypeClass.UnmanagedStruct*)gClass.UnsafeHandle;
            var ret_ = g_type_name_from_class(gClass_);
            var ret = new GISharp.Lib.GLib.UnownedUtf8(ret_);
            return ret;
        }

        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern byte* g_type_name_from_instance(
/* <type name="TypeInstance" type="GTypeInstance*" managed-name="TypeInstance" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.GObject.TypeInstance.UnmanagedStruct* instance);
        static partial void CheckNameFromInstanceArgs(GISharp.Lib.GObject.TypeInstance instance);

        /// <include file="TypeExtensions.xmldoc" path="declaration/member[@name='TypeExtensions.NameFromInstance(GISharp.Lib.GObject.TypeInstance)']/*" />
        public static GISharp.Lib.GLib.UnownedUtf8 NameFromInstance(GISharp.Lib.GObject.TypeInstance instance)
        {
            CheckNameFromInstanceArgs(instance);
            var instance_ = (GISharp.Lib.GObject.TypeInstance.UnmanagedStruct*)instance.UnsafeHandle;
            var ret_ = g_type_name_from_instance(instance_);
            var ret = new GISharp.Lib.GLib.UnownedUtf8(ret_);
            return ret;
        }

        /// <summary>
        /// Registers a private class structure for a classed type;
        /// when the class is allocated, the private structures for
        /// the class and all of its parent types are allocated
        /// sequentially in the same memory block as the public
        /// structures, and are zero-filled.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This function should be called in the
        /// type's get_type() function after the type is registered.
        /// The private structure can be retrieved using the
        /// G_TYPE_CLASS_GET_PRIVATE() macro.
        /// </para>
        /// </remarks>
        /// <param name="classType">
        /// GType of a classed type
        /// </param>
        /// <param name="privateSize">
        /// size of private structure
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_type_add_class_private(
        /* <type name="GType" type="GType" managed-name="GISharp.Runtime.GType" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.GType classType,
        /* <type name="gsize" type="gsize" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        nuint privateSize);
        static partial void CheckAddClassPrivateArgs(this GISharp.Runtime.GType classType, int privateSize);

        /// <include file="TypeExtensions.xmldoc" path="declaration/member[@name='TypeExtensions.AddClassPrivate(GISharp.Runtime.GType,int)']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public static void AddClassPrivate(this GISharp.Runtime.GType classType, int privateSize)
        {
            CheckAddClassPrivateArgs(classType, privateSize);
            var classType_ = (GISharp.Runtime.GType)classType;
            var privateSize_ = (nuint)privateSize;
            g_type_add_class_private(classType_, privateSize_);
        }

        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gint" type="gint" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        private static extern int g_type_add_instance_private(
/* <type name="GType" type="GType" managed-name="GISharp.Runtime.GType" /> */
/* transfer-ownership:none direction:in */
GISharp.Runtime.GType classType,
/* <type name="gsize" type="gsize" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
nuint privateSize);
        static partial void CheckAddInstancePrivateArgs(this GISharp.Runtime.GType classType, int privateSize);

        /// <include file="TypeExtensions.xmldoc" path="declaration/member[@name='TypeExtensions.AddInstancePrivate(GISharp.Runtime.GType,int)']/*" />
        public static int AddInstancePrivate(this GISharp.Runtime.GType classType, int privateSize)
        {
            CheckAddInstancePrivateArgs(classType, privateSize);
            var classType_ = (GISharp.Runtime.GType)classType;
            var privateSize_ = (nuint)privateSize;
            var ret_ = g_type_add_instance_private(classType_,privateSize_);
            var ret = (int)ret_;
            return ret;
        }

        /// <summary>
        /// Adds @interface_type to the static @instantiable_type.
        /// The information contained in the #GInterfaceInfo structure
        /// pointed to by @info is used to manage the relationship.
        /// </summary>
        /// <param name="instanceType">
        /// #GType value of an instantiable type
        /// </param>
        /// <param name="interfaceType">
        /// #GType value of an interface type
        /// </param>
        /// <param name="info">
        /// #GInterfaceInfo structure for this
        ///        (@instance_type, @interface_type) combination
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_type_add_interface_static(
        /* <type name="GType" type="GType" managed-name="GISharp.Runtime.GType" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.GType instanceType,
        /* <type name="GType" type="GType" managed-name="GISharp.Runtime.GType" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.GType interfaceType,
        /* <type name="InterfaceInfo" type="const GInterfaceInfo*" managed-name="InterfaceInfo" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.InterfaceInfo* info);

        /// <summary>
        /// Returns the length of the ancestry of the passed in type. This
        /// includes the type itself, so that e.g. a fundamental type has depth 1.
        /// </summary>
        /// <param name="type">
        /// a #GType
        /// </param>
        /// <returns>
        /// the depth of @type
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        private static extern uint g_type_depth(
        /* <type name="GType" type="GType" managed-name="GISharp.Runtime.GType" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.GType type);
        static partial void CheckDepthArgs(this GISharp.Runtime.GType type);

        /// <include file="TypeExtensions.xmldoc" path="declaration/member[@name='TypeExtensions.Depth(GISharp.Runtime.GType)']/*" />
        public static uint Depth(this GISharp.Runtime.GType type)
        {
            CheckDepthArgs(type);
            var type_ = (GISharp.Runtime.GType)type;
            var ret_ = g_type_depth(type_);
            var ret = (uint)ret_;
            return ret;
        }

        /// <summary>
        /// Ensures that the indicated @type has been registered with the
        /// type system, and its _class_init() method has been run.
        /// </summary>
        /// <remarks>
        /// <para>
        /// In theory, simply calling the type's _get_type() method (or using
        /// the corresponding macro) is supposed take care of this. However,
        /// _get_type() methods are often marked %G_GNUC_CONST for performance
        /// reasons, even though this is technically incorrect (since
        /// %G_GNUC_CONST requires that the function not have side effects,
        /// which _get_type() methods do on the first call). As a result, if
        /// you write a bare call to a _get_type() macro, it may get optimized
        /// out by the compiler. Using g_type_ensure() guarantees that the
        /// type's _get_type() method is called.
        /// </para>
        /// </remarks>
        /// <param name="type">
        /// a #GType
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.34")]
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_type_ensure(
        /* <type name="GType" type="GType" managed-name="GISharp.Runtime.GType" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.GType type);
        static partial void CheckEnsureArgs(this GISharp.Runtime.GType type);

        /// <include file="TypeExtensions.xmldoc" path="declaration/member[@name='TypeExtensions.Ensure(GISharp.Runtime.GType)']/*" />
        [GISharp.Runtime.SinceAttribute("2.34")]
        public static void Ensure(this GISharp.Runtime.GType type)
        {
            CheckEnsureArgs(type);
            var type_ = (GISharp.Runtime.GType)type;
            g_type_ensure(type_);
        }

        /// <summary>
        /// Returns the number of instances allocated of the particular type;
        /// this is only available if GLib is built with debugging support and
        /// the instance_count debug flag is set (by setting the GOBJECT_DEBUG
        /// variable to include instance-count).
        /// </summary>
        /// <param name="type">
        /// a #GType
        /// </param>
        /// <returns>
        /// the number of instances allocated of the given type;
        ///   if instance counts are not available, returns 0.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.44")]
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gint" type="int" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        private static extern int g_type_get_instance_count(
        /* <type name="GType" type="GType" managed-name="GISharp.Runtime.GType" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.GType type);
        static partial void CheckGetInstanceCountArgs(this GISharp.Runtime.GType type);

        /// <include file="TypeExtensions.xmldoc" path="declaration/member[@name='TypeExtensions.GetInstanceCount(GISharp.Runtime.GType)']/*" />
        [GISharp.Runtime.SinceAttribute("2.44")]
        public static int GetInstanceCount(this GISharp.Runtime.GType type)
        {
            CheckGetInstanceCountArgs(type);
            var type_ = (GISharp.Runtime.GType)type;
            var ret_ = g_type_get_instance_count(type_);
            var ret = (int)ret_;
            return ret;
        }

        /// <summary>
        /// Obtains data which has previously been attached to @type
        /// with g_type_set_qdata().
        /// </summary>
        /// <remarks>
        /// <para>
        /// Note that this does not take subtyping into account; data
        /// attached to one type with g_type_set_qdata() cannot
        /// be retrieved from a subtype using g_type_get_qdata().
        /// </para>
        /// </remarks>
        /// <param name="type">
        /// a #GType
        /// </param>
        /// <param name="quark">
        /// a #GQuark id to identify the data
        /// </param>
        /// <returns>
        /// the data, or %NULL if no data was found
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 direction:in */
        private static extern System.IntPtr g_type_get_qdata(
        /* <type name="GType" type="GType" managed-name="GISharp.Runtime.GType" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.GType type,
        /* <type name="GLib.Quark" type="GQuark" managed-name="GISharp.Lib.GLib.Quark" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Quark quark);
        static partial void CheckGetQDataArgs(this GISharp.Runtime.GType type, GISharp.Lib.GLib.Quark quark);

        /// <include file="TypeExtensions.xmldoc" path="declaration/member[@name='TypeExtensions.GetQData(GISharp.Runtime.GType,GISharp.Lib.GLib.Quark)']/*" />
        public static System.IntPtr GetQData(this GISharp.Runtime.GType type, GISharp.Lib.GLib.Quark quark)
        {
            CheckGetQDataArgs(type, quark);
            var type_ = (GISharp.Runtime.GType)type;
            var quark_ = (GISharp.Lib.GLib.Quark)quark;
            var ret_ = g_type_get_qdata(type_,quark_);
            var ret = (System.IntPtr)ret_;
            return ret;
        }

        /// <summary>
        /// Return a newly allocated and 0-terminated array of type IDs, listing
        /// the interface types that @type conforms to.
        /// </summary>
        /// <param name="type">
        /// the type to list interface types for
        /// </param>
        /// <param name="nInterfaces">
        /// location to store the length of
        ///     the returned array, or %NULL
        /// </param>
        /// <returns>
        /// Newly allocated
        ///     and 0-terminated array of interface types, free with g_free()
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <array length="0" zero-terminated="0" type="GType*" managed-name="GISharp.Runtime.CArray" is-pointer="1">
*   <type name="GType" type="GType" managed-name="GISharp.Runtime.GType" />
* </array> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Runtime.GType* g_type_interfaces(
        /* <type name="GType" type="GType" managed-name="GISharp.Runtime.GType" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.GType type,
        /* <type name="guint" type="guint*" managed-name="System.UInt32" /> */
        /* direction:out caller-allocates:0 transfer-ownership:full optional:1 allow-none:1 */
        uint* nInterfaces);
        static partial void CheckInterfacesArgs(this GISharp.Runtime.GType type);

        /// <include file="TypeExtensions.xmldoc" path="declaration/member[@name='TypeExtensions.Interfaces(GISharp.Runtime.GType)']/*" />
        public static GISharp.Runtime.CArray<GISharp.Runtime.GType> Interfaces(this GISharp.Runtime.GType type)
        {
            CheckInterfacesArgs(type);
            var type_ = (GISharp.Runtime.GType)type;
            uint nInterfaces_;
            var ret_ = g_type_interfaces(type_,&nInterfaces_);
            var ret = new GISharp.Runtime.CArray<GISharp.Runtime.GType>((System.IntPtr)ret_, (int)nInterfaces_, GISharp.Runtime.Transfer.Full);
            return ret;
        }

        /// <summary>
        /// Given a @leaf_type and a @root_type which is contained in its
        /// anchestry, return the type that @root_type is the immediate parent
        /// of. In other words, this function determines the type that is
        /// derived directly from @root_type which is also a base class of
        /// @leaf_type.  Given a root type and a leaf type, this function can
        /// be used to determine the types and order in which the leaf type is
        /// descended from the root type.
        /// </summary>
        /// <param name="leafType">
        /// descendant of @root_type and the type to be returned
        /// </param>
        /// <param name="rootType">
        /// immediate parent of the returned type
        /// </param>
        /// <returns>
        /// immediate child of @root_type and anchestor of @leaf_type
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="GType" type="GType" managed-name="GISharp.Runtime.GType" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.GType g_type_next_base(
        /* <type name="GType" type="GType" managed-name="GISharp.Runtime.GType" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.GType leafType,
        /* <type name="GType" type="GType" managed-name="GISharp.Runtime.GType" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.GType rootType);
        static partial void CheckNextBaseArgs(this GISharp.Runtime.GType leafType, GISharp.Runtime.GType rootType);

        /// <include file="TypeExtensions.xmldoc" path="declaration/member[@name='TypeExtensions.NextBase(GISharp.Runtime.GType,GISharp.Runtime.GType)']/*" />
        public static GISharp.Runtime.GType NextBase(this GISharp.Runtime.GType leafType, GISharp.Runtime.GType rootType)
        {
            CheckNextBaseArgs(leafType, rootType);
            var leafType_ = (GISharp.Runtime.GType)leafType;
            var rootType_ = (GISharp.Runtime.GType)rootType;
            var ret_ = g_type_next_base(leafType_,rootType_);
            var ret = (GISharp.Runtime.GType)ret_;
            return ret;
        }

        /// <summary>
        /// Get the corresponding quark of the type IDs name.
        /// </summary>
        /// <param name="type">
        /// type to return quark of type name for
        /// </param>
        /// <returns>
        /// the type names quark or 0
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="GLib.Quark" type="GQuark" managed-name="GISharp.Lib.GLib.Quark" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GLib.Quark g_type_qname(
        /* <type name="GType" type="GType" managed-name="GISharp.Runtime.GType" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.GType type);
        static partial void CheckQNameArgs(this GISharp.Runtime.GType type);

        /// <include file="TypeExtensions.xmldoc" path="declaration/member[@name='TypeExtensions.QName(GISharp.Runtime.GType)']/*" />
        public static GISharp.Lib.GLib.Quark QName(this GISharp.Runtime.GType type)
        {
            CheckQNameArgs(type);
            var type_ = (GISharp.Runtime.GType)type;
            var ret_ = g_type_qname(type_);
            var ret = (GISharp.Lib.GLib.Quark)ret_;
            return ret;
        }

        /// <summary>
        /// Queries the type system for information about a specific type.
        /// This function will fill in a user-provided structure to hold
        /// type-specific information. If an invalid #GType is passed in, the
        /// @type member of the #GTypeQuery is 0. All members filled into the
        /// #GTypeQuery structure should be considered constant and have to be
        /// left untouched.
        /// </summary>
        /// <param name="type">
        /// #GType of a static, classed type
        /// </param>
        /// <param name="query">
        /// a user provided structure that is
        ///     filled in with constant values upon success
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_type_query(
        /* <type name="GType" type="GType" managed-name="GISharp.Runtime.GType" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.GType type,
        /* <type name="TypeQuery" type="GTypeQuery*" managed-name="TypeQuery" /> */
        /* direction:out caller-allocates:1 transfer-ownership:none */
        GISharp.Lib.GObject.TypeQuery* query);
        static partial void CheckQueryArgs(this GISharp.Runtime.GType type);

        /// <include file="TypeExtensions.xmldoc" path="declaration/member[@name='TypeExtensions.Query(GISharp.Runtime.GType,GISharp.Lib.GObject.TypeQuery)']/*" />
        public static void Query(this GISharp.Runtime.GType type, out GISharp.Lib.GObject.TypeQuery query)
        {
            fixed (GISharp.Lib.GObject.TypeQuery* query_ = &query)
            {
                CheckQueryArgs(type);
                var type_ = (GISharp.Runtime.GType)type;
                g_type_query(type_, query_);
            }
        }

        /// <summary>
        /// Registers @type_id as the predefined identifier and @type_name as the
        /// name of a fundamental type. If @type_id is already registered, or a
        /// type named @type_name is already registered, the behaviour is undefined.
        /// The type system uses the information contained in the #GTypeInfo structure
        /// pointed to by @info and the #GTypeFundamentalInfo structure pointed to by
        /// @finfo to manage the type and its instances. The value of @flags determines
        /// additional characteristics of the fundamental type.
        /// </summary>
        /// <param name="typeId">
        /// a predefined type identifier
        /// </param>
        /// <param name="typeName">
        /// 0-terminated string used as the name of the new type
        /// </param>
        /// <param name="info">
        /// #GTypeInfo structure for this type
        /// </param>
        /// <param name="finfo">
        /// #GTypeFundamentalInfo structure for this type
        /// </param>
        /// <param name="flags">
        /// bitwise combination of #GTypeFlags values
        /// </param>
        /// <returns>
        /// the predefined type identifier
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="GType" type="GType" managed-name="GISharp.Runtime.GType" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.GType g_type_register_fundamental(
        /* <type name="GType" type="GType" managed-name="GISharp.Runtime.GType" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.GType typeId,
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* typeName,
        /* <type name="TypeInfo" type="const GTypeInfo*" managed-name="TypeInfo" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.TypeInfo* info,
        /* <type name="TypeFundamentalInfo" type="const GTypeFundamentalInfo*" managed-name="TypeFundamentalInfo" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.TypeFundamentalInfo* finfo,
        /* <type name="TypeFlags" type="GTypeFlags" managed-name="TypeFlags" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.TypeFlags flags);
        static partial void CheckRegisterFundamentalArgs(this GISharp.Runtime.GType typeId, GISharp.Lib.GLib.UnownedUtf8 typeName, in GISharp.Lib.GObject.TypeInfo info, in GISharp.Lib.GObject.TypeFundamentalInfo finfo, GISharp.Lib.GObject.TypeFlags flags);

        /// <include file="TypeExtensions.xmldoc" path="declaration/member[@name='TypeExtensions.RegisterFundamental(GISharp.Runtime.GType,GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.GObject.TypeInfo,GISharp.Lib.GObject.TypeFundamentalInfo,GISharp.Lib.GObject.TypeFlags)']/*" />
        public static GISharp.Runtime.GType RegisterFundamental(this GISharp.Runtime.GType typeId, GISharp.Lib.GLib.UnownedUtf8 typeName, in GISharp.Lib.GObject.TypeInfo info, in GISharp.Lib.GObject.TypeFundamentalInfo finfo, GISharp.Lib.GObject.TypeFlags flags)
        {
            fixed (GISharp.Lib.GObject.TypeFundamentalInfo* finfo_ = &finfo)
            {
                fixed (GISharp.Lib.GObject.TypeInfo* info_ = &info)
                {
                    CheckRegisterFundamentalArgs(typeId, typeName, info, finfo, flags);
                    var typeId_ = (GISharp.Runtime.GType)typeId;
                    var typeName_ = (byte*)typeName.UnsafeHandle;
                    var flags_ = (GISharp.Lib.GObject.TypeFlags)flags;
                    var ret_ = g_type_register_fundamental(typeId_,typeName_,info_,finfo_,flags_);
                    var ret = (GISharp.Runtime.GType)ret_;
                    return ret;
                }
            }
        }

        /// <summary>
        /// Registers @type_name as the name of a new static type derived from
        /// @parent_type. The type system uses the information contained in the
        /// #GTypeInfo structure pointed to by @info to manage the type and its
        /// instances (if not abstract). The value of @flags determines the nature
        /// (e.g. abstract or not) of the type.
        /// </summary>
        /// <param name="parentType">
        /// type from which this type will be derived
        /// </param>
        /// <param name="typeName">
        /// 0-terminated string used as the name of the new type
        /// </param>
        /// <param name="info">
        /// #GTypeInfo structure for this type
        /// </param>
        /// <param name="flags">
        /// bitwise combination of #GTypeFlags values
        /// </param>
        /// <returns>
        /// the new type identifier
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="GType" type="GType" managed-name="GISharp.Runtime.GType" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.GType g_type_register_static(
        /* <type name="GType" type="GType" managed-name="GISharp.Runtime.GType" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.GType parentType,
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* typeName,
        /* <type name="TypeInfo" type="const GTypeInfo*" managed-name="TypeInfo" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.TypeInfo* info,
        /* <type name="TypeFlags" type="GTypeFlags" managed-name="TypeFlags" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.TypeFlags flags);

        /// <summary>
        /// Attaches arbitrary data to a type.
        /// </summary>
        /// <param name="type">
        /// a #GType
        /// </param>
        /// <param name="quark">
        /// a #GQuark id to identify the data
        /// </param>
        /// <param name="data">
        /// the data
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_type_set_qdata(
        /* <type name="GType" type="GType" managed-name="GISharp.Runtime.GType" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.GType type,
        /* <type name="GLib.Quark" type="GQuark" managed-name="GISharp.Lib.GLib.Quark" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Quark quark,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr data);
        static partial void CheckSetQDataArgs(this GISharp.Runtime.GType type, GISharp.Lib.GLib.Quark quark, System.IntPtr data);

        /// <include file="TypeExtensions.xmldoc" path="declaration/member[@name='TypeExtensions.SetQData(GISharp.Runtime.GType,GISharp.Lib.GLib.Quark,System.IntPtr)']/*" />
        public static void SetQData(this GISharp.Runtime.GType type, GISharp.Lib.GLib.Quark quark, System.IntPtr data)
        {
            CheckSetQDataArgs(type, quark, data);
            var type_ = (GISharp.Runtime.GType)type;
            var quark_ = (GISharp.Lib.GLib.Quark)quark;
            var data_ = (System.IntPtr)data;
            g_type_set_qdata(type_, quark_, data_);
        }
    }
}