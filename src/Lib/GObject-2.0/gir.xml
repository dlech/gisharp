<?xml version="1.0" encoding="utf-8"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2" xmlns="http://www.gtk.org/introspection/core/1.0" xmlns:c="http://www.gtk.org/introspection/c/1.0" xmlns:glib="http://www.gtk.org/introspection/glib/1.0" xmlns:gs="http://gisharp.org/introspection/gisharp/1.0">
  <include name="GLib" version="2.0" gs:managed-name="GLib" />
  <package name="gobject-2.0" gs:managed-name="Gobject2.0" />
  <c:include name="glib-object.h" gs:managed-name="GlibObject.h" />
  <namespace name="GObject" version="2.0" shared-library="/usr/local/opt/glib/lib/libgobject-2.0.0.dylib" c:identifier-prefixes="G" c:symbol-prefixes="g" gs:managed-name="GObject">
    <alias name="SignalCMarshaller" c:type="GSignalCMarshaller" gs:managed-name="SignalCMarshaller">
      <doc xml:space="preserve" filename="gsignal.h" line="34">This is the signature of marshaller functions, required to marshall
arrays of parameter values to signal emissions into C language callback
invocations. It is merely an alias to #GClosureMarshal since the #GClosure
mechanism takes over responsibility of actual function invocation for the
signal system.</doc>
      <source-position filename="gsignal.h" line="43" />
      <type name="ClosureMarshal" c:type="GClosureMarshal" />
    </alias>
    <callback name="BaseFinalizeFunc" c:type="GBaseFinalizeFunc" gs:dll-name="gobject-2.0" gs:managed-name="BaseFinalizeFunc">
      <doc xml:space="preserve" filename="gtype.h" line="773">A callback function used by the type system to finalize those portions
of a derived types class structure that were setup from the corresponding
GBaseInitFunc() function. Class finalization basically works the inverse
way in which class initialization is performed.
See GClassInitFunc() for a discussion of the class initialization process.</doc>
      <source-position filename="gtype.h" line="783" />
      <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
        <type name="none" c:type="void" />
      </return-value>
      <parameters>
        <parameter name="g_class" transfer-ownership="none" gs:managed-name="gClass" direction="in">
          <doc xml:space="preserve" filename="gtype.h" line="775">The #GTypeClass structure to finalize</doc>
          <type name="TypeClass" c:type="gpointer" gs:is-pointer="1" />
        </parameter>
      </parameters>
      <gs:managed-parameters>
        <parameter name="g_class" transfer-ownership="none" gs:managed-name="gClass" direction="in">
          <doc xml:space="preserve" filename="gtype.h" line="775">The #GTypeClass structure to finalize</doc>
          <type name="TypeClass" c:type="gpointer" gs:is-pointer="1" />
        </parameter>
      </gs:managed-parameters>
    </callback>
    <callback name="BaseInitFunc" c:type="GBaseInitFunc" gs:dll-name="gobject-2.0" gs:managed-name="BaseInitFunc">
      <doc xml:space="preserve" filename="gtype.h" line="759">A callback function used by the type system to do base initialization
of the class structures of derived types. It is called as part of the
initialization process of all derived classes and should reallocate
or reset all dynamic class members copied over from the parent class.
For example, class members (such as strings) that are not sufficiently
handled by a plain memory copy of the parent class into the derived class
have to be altered. See GClassInitFunc() for a discussion of the class
initialization process.</doc>
      <source-position filename="gtype.h" line="772" />
      <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
        <type name="none" c:type="void" />
      </return-value>
      <parameters>
        <parameter name="g_class" transfer-ownership="none" gs:managed-name="gClass" direction="in">
          <doc xml:space="preserve" filename="gtype.h" line="761">The #GTypeClass structure to initialize</doc>
          <type name="TypeClass" c:type="gpointer" gs:is-pointer="1" />
        </parameter>
      </parameters>
      <gs:managed-parameters>
        <parameter name="g_class" transfer-ownership="none" gs:managed-name="gClass" direction="in">
          <doc xml:space="preserve" filename="gtype.h" line="761">The #GTypeClass structure to initialize</doc>
          <type name="TypeClass" c:type="gpointer" gs:is-pointer="1" />
        </parameter>
      </gs:managed-parameters>
    </callback>
    <class name="Binding" c:symbol-prefix="binding" c:type="GBinding" version="2.26" parent="Object" glib:type-name="GBinding" glib:get-type="g_binding_get_type" gs:managed-name="Binding">
      <doc xml:space="preserve" filename="gobject-2.0.c" line="162">#GBinding is the representation of a binding between a property on a
#GObject instance (or source) and another property on another #GObject
instance (or target). Whenever the source property changes, the same
value is applied to the target property; for instance, the following
binding:

|[&lt;!-- language="C" --&gt;
  g_object_bind_property (object1, "property-a",
                          object2, "property-b",
                          G_BINDING_DEFAULT);
]|

will cause the property named "property-b" of @object2 to be updated
every time g_object_set() or the specific accessor changes the value of
the property "property-a" of @object1.

It is possible to create a bidirectional binding between two properties
of two #GObject instances, so that if either property changes, the
other is updated as well, for instance:

|[&lt;!-- language="C" --&gt;
  g_object_bind_property (object1, "property-a",
                          object2, "property-b",
                          G_BINDING_BIDIRECTIONAL);
]|

will keep the two properties in sync.

It is also possible to set a custom transformation function (in both
directions, in case of a bidirectional binding) to apply a custom
transformation from the source value to the target value before
applying it; for instance, the following binding:

|[&lt;!-- language="C" --&gt;
  g_object_bind_property_full (adjustment1, "value",
                               adjustment2, "value",
                               G_BINDING_BIDIRECTIONAL,
                               celsius_to_fahrenheit,
                               fahrenheit_to_celsius,
                               NULL, NULL);
]|

will keep the "value" property of the two adjustments in sync; the
@celsius_to_fahrenheit function will be called whenever the "value"
property of @adjustment1 changes and will transform the current value
of the property before applying it to the "value" property of @adjustment2.

Vice versa, the @fahrenheit_to_celsius function will be called whenever
the "value" property of @adjustment2 changes, and will transform the
current value of the property before applying it to the "value" property
of @adjustment1.

Note that #GBinding does not resolve cycles by itself; a cycle like

|[
  object1:propertyA -&gt; object2:propertyB
  object2:propertyB -&gt; object3:propertyC
  object3:propertyC -&gt; object1:propertyA
]|

might lead to an infinite loop. The loop, in this particular case,
can be avoided if the objects emit the #GObject::notify signal only
if the value has effectively been changed. A binding is implemented
using the #GObject::notify signal, so it is susceptible to all the
various ways of blocking a signal emission, like g_signal_stop_emission()
or g_signal_handler_block().

A binding will be severed, and the resources it allocates freed, whenever
either one of the #GObject instances it refers to are finalized, or when
the #GBinding instance loses its last reference.

Bindings for languages with garbage collection can use
g_binding_unbind() to explicitly release a binding between the source
and target properties, instead of relying on the last reference on the
binding, source, and target instances to drop.

#GBinding is available since GObject 2.26</doc>
      <gs:managed-property name="get_flags" version="2.26" gs:dll-name="gobject-2.0" gs:managed-name="Flags">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="845">Retrieves the flags passed when constructing the #GBinding.</doc>
        <source-position filename="gbinding.h" line="110" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="851">the #GBindingFlags used by the #GBinding</doc>
          <type name="BindingFlags" c:type="GBindingFlags" />
        </return-value>
        <parameters>
          <instance-parameter name="binding" transfer-ownership="none" gs:managed-name="binding" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="847">a #GBinding</doc>
            <type name="Binding" c:type="GBinding*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_flags" c:identifier="g_binding_get_flags" version="2.26" gs:dll-name="gobject-2.0" gs:managed-name="GetFlags" gs:property-getter-for="Flags" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="845">Retrieves the flags passed when constructing the #GBinding.</doc>
        <source-position filename="gbinding.h" line="110" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="851">the #GBindingFlags used by the #GBinding</doc>
          <type name="BindingFlags" c:type="GBindingFlags" />
        </return-value>
        <parameters>
          <instance-parameter name="binding" transfer-ownership="none" gs:managed-name="binding" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="847">a #GBinding</doc>
            <type name="Binding" c:type="GBinding*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_source" version="2.26" deprecated="1" deprecated-version="2.68" gs:dll-name="gobject-2.0" gs:managed-name="Source">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="856">Retrieves the #GObject instance used as the source of the binding.

A #GBinding can outlive the source #GObject as the binding does not hold a
strong reference to the source. If the source is destroyed before the
binding then this function will return %NULL.

Use g_binding_dup_source() if the source or binding are used from different
threads as otherwise the pointer returned from this function might become
invalid if the source is finalized from another thread in the meantime.</doc>
        <doc-deprecated xml:space="preserve">Use g_binding_dup_source() for a safer version of this
function.</doc-deprecated>
        <source-position filename="gbinding.h" line="112" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="870">the source #GObject, or %NULL if the
    source does not exist any more.</doc>
          <type name="Object" c:type="GObject*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="binding" transfer-ownership="none" gs:managed-name="binding" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="858">a #GBinding</doc>
            <type name="Binding" c:type="GBinding*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_source" c:identifier="g_binding_get_source" version="2.26" deprecated="1" deprecated-version="2.68" gs:dll-name="gobject-2.0" gs:managed-name="GetSource" gs:property-getter-for="Source" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="856">Retrieves the #GObject instance used as the source of the binding.

A #GBinding can outlive the source #GObject as the binding does not hold a
strong reference to the source. If the source is destroyed before the
binding then this function will return %NULL.

Use g_binding_dup_source() if the source or binding are used from different
threads as otherwise the pointer returned from this function might become
invalid if the source is finalized from another thread in the meantime.</doc>
        <doc-deprecated xml:space="preserve">Use g_binding_dup_source() for a safer version of this
function.</doc-deprecated>
        <source-position filename="gbinding.h" line="112" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="870">the source #GObject, or %NULL if the
    source does not exist any more.</doc>
          <type name="Object" c:type="GObject*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="binding" transfer-ownership="none" gs:managed-name="binding" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="858">a #GBinding</doc>
            <type name="Binding" c:type="GBinding*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_source_property" version="2.26" gs:dll-name="gobject-2.0" gs:managed-name="SourceProperty">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="878">Retrieves the name of the property of #GBinding:source used as the source
of the binding.</doc>
        <source-position filename="gbinding.h" line="116" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="885">the name of the source property</doc>
          <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="binding" transfer-ownership="none" gs:managed-name="binding" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="880">a #GBinding</doc>
            <type name="Binding" c:type="GBinding*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_source_property" c:identifier="g_binding_get_source_property" version="2.26" gs:dll-name="gobject-2.0" gs:managed-name="GetSourceProperty" gs:property-getter-for="SourceProperty" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="878">Retrieves the name of the property of #GBinding:source used as the source
of the binding.</doc>
        <source-position filename="gbinding.h" line="116" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="885">the name of the source property</doc>
          <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="binding" transfer-ownership="none" gs:managed-name="binding" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="880">a #GBinding</doc>
            <type name="Binding" c:type="GBinding*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_target" version="2.26" deprecated="1" deprecated-version="2.68" gs:dll-name="gobject-2.0" gs:managed-name="Target">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="890">Retrieves the #GObject instance used as the target of the binding.

A #GBinding can outlive the target #GObject as the binding does not hold a
strong reference to the target. If the target is destroyed before the
binding then this function will return %NULL.

Use g_binding_dup_target() if the target or binding are used from different
threads as otherwise the pointer returned from this function might become
invalid if the target is finalized from another thread in the meantime.</doc>
        <doc-deprecated xml:space="preserve">Use g_binding_dup_target() for a safer version of this
function.</doc-deprecated>
        <source-position filename="gbinding.h" line="114" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="904">the target #GObject, or %NULL if the
    target does not exist any more.</doc>
          <type name="Object" c:type="GObject*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="binding" transfer-ownership="none" gs:managed-name="binding" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="892">a #GBinding</doc>
            <type name="Binding" c:type="GBinding*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_target" c:identifier="g_binding_get_target" version="2.26" deprecated="1" deprecated-version="2.68" gs:dll-name="gobject-2.0" gs:managed-name="GetTarget" gs:property-getter-for="Target" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="890">Retrieves the #GObject instance used as the target of the binding.

A #GBinding can outlive the target #GObject as the binding does not hold a
strong reference to the target. If the target is destroyed before the
binding then this function will return %NULL.

Use g_binding_dup_target() if the target or binding are used from different
threads as otherwise the pointer returned from this function might become
invalid if the target is finalized from another thread in the meantime.</doc>
        <doc-deprecated xml:space="preserve">Use g_binding_dup_target() for a safer version of this
function.</doc-deprecated>
        <source-position filename="gbinding.h" line="114" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="904">the target #GObject, or %NULL if the
    target does not exist any more.</doc>
          <type name="Object" c:type="GObject*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="binding" transfer-ownership="none" gs:managed-name="binding" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="892">a #GBinding</doc>
            <type name="Binding" c:type="GBinding*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_target_property" version="2.26" gs:dll-name="gobject-2.0" gs:managed-name="TargetProperty">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="912">Retrieves the name of the property of #GBinding:target used as the target
of the binding.</doc>
        <source-position filename="gbinding.h" line="118" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="919">the name of the target property</doc>
          <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="binding" transfer-ownership="none" gs:managed-name="binding" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="914">a #GBinding</doc>
            <type name="Binding" c:type="GBinding*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_target_property" c:identifier="g_binding_get_target_property" version="2.26" gs:dll-name="gobject-2.0" gs:managed-name="GetTargetProperty" gs:property-getter-for="TargetProperty" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="912">Retrieves the name of the property of #GBinding:target used as the target
of the binding.</doc>
        <source-position filename="gbinding.h" line="118" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="919">the name of the target property</doc>
          <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="binding" transfer-ownership="none" gs:managed-name="binding" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="914">a #GBinding</doc>
            <type name="Binding" c:type="GBinding*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="unbind" c:identifier="g_binding_unbind" version="2.38" gs:pinvoke-only="1" gs:dll-name="gobject-2.0" gs:managed-name="Unbind">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="924">Explicitly releases the binding between the source and the target
property expressed by @binding.

This function will release the reference that is being held on
the @binding instance if the binding is still bound; if you want to hold on
to the #GBinding instance after calling g_binding_unbind(), you will need
to hold a reference to it.

Note however that this function does not take ownership of @binding, it
only unrefs the reference that was initially created by
g_object_bind_property() and is owned by the binding.</doc>
        <source-position filename="gbinding.h" line="120" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="binding" transfer-ownership="none" gs:managed-name="binding" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="926">a #GBinding</doc>
            <type name="Binding" c:type="GBinding*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <property name="flags" version="2.26" writable="1" construct-only="1" transfer-ownership="none" gs:managed-name="Flags_">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="5">Flags to be used to control the #GBinding</doc>
        <type name="BindingFlags" />
      </property>
      <property name="source" version="2.26" writable="1" construct-only="1" transfer-ownership="none" gs:managed-name="Source_">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="14">The #GObject that should be used as the source of the binding</doc>
        <type name="Object" />
      </property>
      <property name="source-property" version="2.26" writable="1" construct-only="1" transfer-ownership="none" gs:managed-name="SourceProperty_">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="23">The name of the property of #GBinding:source that should be used
as the source of the binding.

This should be in [canonical form][canonical-parameter-names] to get the
best performance.</doc>
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </property>
      <property name="target" version="2.26" writable="1" construct-only="1" transfer-ownership="none" gs:managed-name="Target_">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="36">The #GObject that should be used as the target of the binding</doc>
        <type name="Object" />
      </property>
      <property name="target-property" version="2.26" writable="1" construct-only="1" transfer-ownership="none" gs:managed-name="TargetProperty_">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="45">The name of the property of #GBinding:target that should be used
as the target of the binding.

This should be in [canonical form][canonical-parameter-names] to get the
best performance.</doc>
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </property>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_binding_get_type" gs:access-modifiers="private" gs:dll-name="gobject-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </class>
    <bitfield name="BindingFlags" version="2.26" glib:type-name="GBindingFlags" glib:get-type="g_binding_flags_get_type" c:type="GBindingFlags" gs:managed-name="BindingFlags">
      <doc xml:space="preserve" filename="gbinding.h" line="73">Flags to be passed to g_object_bind_property() or
g_object_bind_property_full().

This enumeration can be extended at later date.</doc>
      <member name="default" value="0" c:identifier="G_BINDING_DEFAULT" glib:nick="default" gs:managed-name="Default">
        <doc xml:space="preserve" filename="gbinding.h" line="75">The default binding; if the source property
  changes, the target property is updated with its value.</doc>
      </member>
      <member name="bidirectional" value="1" c:identifier="G_BINDING_BIDIRECTIONAL" glib:nick="bidirectional" gs:managed-name="Bidirectional">
        <doc xml:space="preserve" filename="gbinding.h" line="77">Bidirectional binding; if either the
  property of the source or the property of the target changes,
  the other is updated.</doc>
      </member>
      <member name="sync_create" value="2" c:identifier="G_BINDING_SYNC_CREATE" glib:nick="sync-create" gs:managed-name="SyncCreate">
        <doc xml:space="preserve" filename="gbinding.h" line="80">Synchronize the values of the source and
  target properties when creating the binding; the direction of
  the synchronization is always from the source to the target.</doc>
      </member>
      <member name="invert_boolean" value="4" c:identifier="G_BINDING_INVERT_BOOLEAN" glib:nick="invert-boolean" gs:managed-name="InvertBoolean">
        <doc xml:space="preserve" filename="gbinding.h" line="83">If the two properties being bound are
  booleans, setting one to %TRUE will result in the other being
  set to %FALSE and vice versa. This flag will only work for
  boolean properties, and cannot be used when passing custom
  transformation functions to g_object_bind_property_full().</doc>
      </member>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_binding_flags_get_type" gs:access-modifiers="private" gs:dll-name="gobject-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </bitfield>
    <callback name="BindingTransformFunc" c:type="GBindingTransformFunc" version="2.26" gs:dll-name="gobject-2.0" gs:managed-name="BindingTransformFunc">
      <doc xml:space="preserve" filename="gbinding.h" line="49">A function to be called to transform @from_value to @to_value. If
this is the @transform_to function of a binding, then @from_value
is the @source_property on the @source object, and @to_value is the
@target_property on the @target object. If this is the
@transform_from function of a %G_BINDING_BIDIRECTIONAL binding,
then those roles are reversed.</doc>
      <source-position filename="gbinding.h" line="68" />
      <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
        <doc xml:space="preserve" filename="gbinding.h" line="63">%TRUE if the transformation was successful, and %FALSE
  otherwise</doc>
        <type name="gboolean" c:type="gboolean" />
      </return-value>
      <parameters>
        <parameter name="binding" transfer-ownership="none" gs:managed-name="binding" direction="in">
          <doc xml:space="preserve" filename="gbinding.h" line="51">a #GBinding</doc>
          <type name="Binding" c:type="GBinding*" gs:is-pointer="1" />
        </parameter>
        <parameter name="from_value" transfer-ownership="none" gs:managed-name="fromValue" direction="in">
          <doc xml:space="preserve" filename="gbinding.h" line="52">the #GValue containing the value to transform</doc>
          <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
        </parameter>
        <parameter name="to_value" transfer-ownership="none" gs:managed-name="toValue" direction="in">
          <doc xml:space="preserve" filename="gbinding.h" line="53">the #GValue in which to store the transformed value</doc>
          <type name="Value" c:type="GValue*" gs:is-pointer="1" />
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3" gs:managed-name="userData" direction="in">
          <doc xml:space="preserve" filename="gbinding.h" line="54">data passed to the transform function</doc>
          <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
        </parameter>
      </parameters>
      <gs:managed-parameters>
        <parameter name="binding" transfer-ownership="none" gs:managed-name="binding" direction="in">
          <doc xml:space="preserve" filename="gbinding.h" line="51">a #GBinding</doc>
          <type name="Binding" c:type="GBinding*" gs:is-pointer="1" />
        </parameter>
        <parameter name="from_value" transfer-ownership="none" gs:managed-name="fromValue" direction="in">
          <doc xml:space="preserve" filename="gbinding.h" line="52">the #GValue containing the value to transform</doc>
          <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
        </parameter>
        <parameter name="to_value" transfer-ownership="none" gs:managed-name="toValue" direction="in">
          <doc xml:space="preserve" filename="gbinding.h" line="53">the #GValue in which to store the transformed value</doc>
          <type name="Value" c:type="GValue*" gs:is-pointer="1" />
        </parameter>
      </gs:managed-parameters>
    </callback>
    <record name="CClosure" c:type="GCClosure" disguised="1" gs:has-parent="1" gs:managed-name="CClosure">
      <doc xml:space="preserve" filename="gclosure.h" line="150">A #GCClosure is a specialization of #GClosure for C function callbacks.</doc>
      <source-position filename="gclosure.h" line="220" />
      <field name="closure" writable="1" gs:managed-name="Closure">
        <doc xml:space="preserve" filename="gclosure.h" line="152">the #GClosure</doc>
        <type name="Closure" c:type="GClosure" />
      </field>
      <field name="callback" writable="1" gs:managed-name="Callback">
        <doc xml:space="preserve" filename="gclosure.h" line="153">the callback function</doc>
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <constructor name="new" c:identifier="g_cclosure_new" introspectable="1" gs:pinvoke-only="1" gs:dll-name="gobject-2.0" gs:managed-name="New">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="1807">Creates a new closure which invokes @callback_func with @user_data as
the last parameter.

@destroy_data will be called as a finalize notifier on the #GClosure.</doc>
        <source-position filename="gclosure.h" line="225" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="1818">a floating reference to a new #GCClosure</doc>
          <type name="Closure" c:type="GClosure*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="callback_func" transfer-ownership="none" nullable="1" allow-none="1" closure="1" gs:managed-name="callbackFunc" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1809">the function to invoke</doc>
            <type name="Callback" c:type="GCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="0" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1810">user data to pass to @callback_func</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="destroy_data" transfer-ownership="none" gs:managed-name="destroyData" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1811">destroy notify to be called when @user_data is no longer used</doc>
            <type name="ClosureNotify" c:type="GClosureNotify" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="callback_func" transfer-ownership="none" nullable="1" allow-none="1" closure="1" gs:managed-name="callbackFunc" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1809">the function to invoke</doc>
            <type name="Callback" c:type="GCallback" />
          </parameter>
          <parameter name="destroy_data" transfer-ownership="none" gs:managed-name="destroyData" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1811">destroy notify to be called when @user_data is no longer used</doc>
            <type name="ClosureNotify" c:type="GClosureNotify" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <constructor name="new_object" c:identifier="g_cclosure_new_object" introspectable="1" gs:pinvoke-only="1" gs:dll-name="gobject-2.0" gs:managed-name="NewObject">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="1822">A variant of g_cclosure_new() which uses @object as @user_data and
calls g_object_watch_closure() on @object and the created
closure. This function is useful when you have a callback closely
associated with a #GObject, and want the callback to no longer run
after the object is is freed.</doc>
        <source-position filename="gobject.h" line="610" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="1833">a new #GCClosure</doc>
          <type name="Closure" c:type="GClosure*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="callback_func" transfer-ownership="none" gs:managed-name="callbackFunc" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1824">the function to invoke</doc>
            <type name="Callback" c:type="GCallback" />
          </parameter>
          <parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1825">a #GObject pointer to pass to @callback_func</doc>
            <type name="Object" c:type="GObject*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="callback_func" transfer-ownership="none" gs:managed-name="callbackFunc" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1824">the function to invoke</doc>
            <type name="Callback" c:type="GCallback" />
          </parameter>
          <parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1825">a #GObject pointer to pass to @callback_func</doc>
            <type name="Object" c:type="GObject*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <constructor name="new_object_swap" c:identifier="g_cclosure_new_object_swap" introspectable="1" gs:pinvoke-only="1" gs:dll-name="gobject-2.0" gs:managed-name="NewObjectSwap">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="1837">A variant of g_cclosure_new_swap() which uses @object as @user_data
and calls g_object_watch_closure() on @object and the created
closure. This function is useful when you have a callback closely
associated with a #GObject, and want the callback to no longer run
after the object is is freed.</doc>
        <source-position filename="gobject.h" line="613" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="1848">a new #GCClosure</doc>
          <type name="Closure" c:type="GClosure*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="callback_func" transfer-ownership="none" gs:managed-name="callbackFunc" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1839">the function to invoke</doc>
            <type name="Callback" c:type="GCallback" />
          </parameter>
          <parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1840">a #GObject pointer to pass to @callback_func</doc>
            <type name="Object" c:type="GObject*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="callback_func" transfer-ownership="none" gs:managed-name="callbackFunc" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1839">the function to invoke</doc>
            <type name="Callback" c:type="GCallback" />
          </parameter>
          <parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1840">a #GObject pointer to pass to @callback_func</doc>
            <type name="Object" c:type="GObject*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <constructor name="new_swap" c:identifier="g_cclosure_new_swap" introspectable="1" gs:pinvoke-only="1" gs:dll-name="gobject-2.0" gs:managed-name="NewSwap">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="1852">Creates a new closure which invokes @callback_func with @user_data as
the first parameter.

@destroy_data will be called as a finalize notifier on the #GClosure.</doc>
        <source-position filename="gclosure.h" line="229" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="1863">a floating reference to a new #GCClosure</doc>
          <type name="Closure" c:type="GClosure*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="callback_func" transfer-ownership="none" nullable="1" allow-none="1" closure="1" gs:managed-name="callbackFunc" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1854">the function to invoke</doc>
            <type name="Callback" c:type="GCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="0" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1855">user data to pass to @callback_func</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="destroy_data" transfer-ownership="none" gs:managed-name="destroyData" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1856">destroy notify to be called when @user_data is no longer used</doc>
            <type name="ClosureNotify" c:type="GClosureNotify" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="callback_func" transfer-ownership="none" nullable="1" allow-none="1" closure="1" gs:managed-name="callbackFunc" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1854">the function to invoke</doc>
            <type name="Callback" c:type="GCallback" />
          </parameter>
          <parameter name="destroy_data" transfer-ownership="none" gs:managed-name="destroyData" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1856">destroy notify to be called when @user_data is no longer used</doc>
            <type name="ClosureNotify" c:type="GClosureNotify" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
    </record>
    <callback name="Callback" c:type="GCallback" gs:dll-name="gobject-2.0" gs:managed-name="Callback">
      <doc xml:space="preserve" filename="gclosure.h" line="77">The type used for callback functions in structure definitions and function
signatures. This doesn't mean that all callback functions must take no
parameters and return void. The required signature of a callback function
is determined by the context in which is used (e.g. the signal to which it
is connected). Use G_CALLBACK() to cast the callback function to a #GCallback.</doc>
      <source-position filename="gclosure.h" line="86" />
      <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
        <type name="none" c:type="void" />
      </return-value>
      <parameters />
      <gs:managed-parameters />
    </callback>
    <callback name="ClassFinalizeFunc" c:type="GClassFinalizeFunc" gs:dll-name="gobject-2.0" gs:managed-name="ClassFinalizeFunc">
      <doc xml:space="preserve" filename="gtype.h" line="887">A callback function used by the type system to finalize a class.
This function is rarely needed, as dynamically allocated class resources
should be handled by GBaseInitFunc() and GBaseFinalizeFunc().
Also, specification of a GClassFinalizeFunc() in the #GTypeInfo
structure of a static type is invalid, because classes of static types
will never be finalized (they are artificially kept alive when their
reference count drops to zero).</doc>
      <source-position filename="gtype.h" line="900" />
      <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
        <type name="none" c:type="void" />
      </return-value>
      <parameters>
        <parameter name="g_class" transfer-ownership="none" gs:managed-name="gClass" direction="in">
          <doc xml:space="preserve" filename="gtype.h" line="889">The #GTypeClass structure to finalize</doc>
          <type name="TypeClass" c:type="gpointer" gs:is-pointer="1" />
        </parameter>
        <parameter name="class_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="classData" direction="in">
          <doc xml:space="preserve" filename="gtype.h" line="890">The @class_data member supplied via the #GTypeInfo structure</doc>
          <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
        </parameter>
      </parameters>
      <gs:managed-parameters>
        <parameter name="g_class" transfer-ownership="none" gs:managed-name="gClass" direction="in">
          <doc xml:space="preserve" filename="gtype.h" line="889">The #GTypeClass structure to finalize</doc>
          <type name="TypeClass" c:type="gpointer" gs:is-pointer="1" />
        </parameter>
        <parameter name="class_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="classData" direction="in">
          <doc xml:space="preserve" filename="gtype.h" line="890">The @class_data member supplied via the #GTypeInfo structure</doc>
          <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
        </parameter>
      </gs:managed-parameters>
    </callback>
    <callback name="ClassInitFunc" c:type="GClassInitFunc" gs:dll-name="gobject-2.0" gs:managed-name="ClassInitFunc">
      <doc xml:space="preserve" filename="gtype.h" line="784">A callback function used by the type system to initialize the class
of a specific type. This function should initialize all static class
members.

The initialization process of a class involves:

- Copying common members from the parent class over to the
  derived class structure.
- Zero initialization of the remaining members not copied
  over from the parent class.
- Invocation of the GBaseInitFunc() initializers of all parent
  types and the class' type.
- Invocation of the class' GClassInitFunc() initializer.

Since derived classes are partially initialized through a memory copy
of the parent class, the general rule is that GBaseInitFunc() and
GBaseFinalizeFunc() should take care of necessary reinitialization
and release of those class members that were introduced by the type
that specified these GBaseInitFunc()/GBaseFinalizeFunc().
GClassInitFunc() should only care about initializing static
class members, while dynamic class members (such as allocated strings
or reference counted resources) are better handled by a GBaseInitFunc()
for this type, so proper initialization of the dynamic class members
is performed for class initialization of derived types as well.

An example may help to correspond the intend of the different class
initializers:

|[&lt;!-- language="C" --&gt;
typedef struct {
  GObjectClass parent_class;
  gint         static_integer;
  gchar       *dynamic_string;
} TypeAClass;
static void
type_a_base_class_init (TypeAClass *class)
{
  class-&gt;dynamic_string = g_strdup ("some string");
}
static void
type_a_base_class_finalize (TypeAClass *class)
{
  g_free (class-&gt;dynamic_string);
}
static void
type_a_class_init (TypeAClass *class)
{
  class-&gt;static_integer = 42;
}

typedef struct {
  TypeAClass   parent_class;
  gfloat       static_float;
  GString     *dynamic_gstring;
} TypeBClass;
static void
type_b_base_class_init (TypeBClass *class)
{
  class-&gt;dynamic_gstring = g_string_new ("some other string");
}
static void
type_b_base_class_finalize (TypeBClass *class)
{
  g_string_free (class-&gt;dynamic_gstring);
}
static void
type_b_class_init (TypeBClass *class)
{
  class-&gt;static_float = 3.14159265358979323846;
}
]|
Initialization of TypeBClass will first cause initialization of
TypeAClass (derived classes reference their parent classes, see
g_type_class_ref() on this).

Initialization of TypeAClass roughly involves zero-initializing its fields,
then calling its GBaseInitFunc() type_a_base_class_init() to allocate
its dynamic members (dynamic_string), and finally calling its GClassInitFunc()
type_a_class_init() to initialize its static members (static_integer).
The first step in the initialization process of TypeBClass is then
a plain memory copy of the contents of TypeAClass into TypeBClass and
zero-initialization of the remaining fields in TypeBClass.
The dynamic members of TypeAClass within TypeBClass now need
reinitialization which is performed by calling type_a_base_class_init()
with an argument of TypeBClass.

After that, the GBaseInitFunc() of TypeBClass, type_b_base_class_init()
is called to allocate the dynamic members of TypeBClass (dynamic_gstring),
and finally the GClassInitFunc() of TypeBClass, type_b_class_init(),
is called to complete the initialization process with the static members
(static_float).

Corresponding finalization counter parts to the GBaseInitFunc() functions
have to be provided to release allocated resources at class finalization
time.</doc>
      <source-position filename="gtype.h" line="885" />
      <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
        <type name="none" c:type="void" />
      </return-value>
      <parameters>
        <parameter name="g_class" transfer-ownership="none" gs:managed-name="gClass" direction="in">
          <doc xml:space="preserve" filename="gtype.h" line="786">The #GTypeClass structure to initialize.</doc>
          <type name="TypeClass" c:type="gpointer" gs:is-pointer="1" />
        </parameter>
        <parameter name="class_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="classData" direction="in">
          <doc xml:space="preserve" filename="gtype.h" line="787">The @class_data member supplied via the #GTypeInfo structure.</doc>
          <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
        </parameter>
      </parameters>
      <gs:managed-parameters>
        <parameter name="g_class" transfer-ownership="none" gs:managed-name="gClass" direction="in">
          <doc xml:space="preserve" filename="gtype.h" line="786">The #GTypeClass structure to initialize.</doc>
          <type name="TypeClass" c:type="gpointer" gs:is-pointer="1" />
        </parameter>
        <parameter name="class_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="classData" direction="in">
          <doc xml:space="preserve" filename="gtype.h" line="787">The @class_data member supplied via the #GTypeInfo structure.</doc>
          <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
        </parameter>
      </gs:managed-parameters>
    </callback>
    <glib:boxed name="Closure" c:type="GClosure" glib:type-name="GClosure" glib:get-type="g_closure_get_type" c:symbol-prefix="closure" gs:inheritance-modifiers="" gs:custom-default-constructor="1" gs:managed-name="Closure">
      <doc xml:space="preserve" filename="gobject-2.0.c" line="275">A #GClosure represents a callback supplied by the programmer. It
will generally comprise a function of some kind and a marshaller
used to call it. It is the responsibility of the marshaller to
convert the arguments for the invocation from #GValues into
a suitable form, perform the callback on the converted arguments,
and transform the return value back into a #GValue.

In the case of C programs, a closure usually just holds a pointer
to a function and maybe a data argument, and the marshaller
converts between #GValue and native C types. The GObject
library provides the #GCClosure type for this purpose. Bindings for
other languages need marshallers which convert between #GValues
and suitable representations in the runtime of the language in
order to use functions written in that language as callbacks. Use
g_closure_set_marshal() to set the marshaller on such a custom
closure implementation.

Within GObject, closures play an important role in the
implementation of signals. When a signal is registered, the
@c_marshaller argument to g_signal_new() specifies the default C
marshaller for any closure which is connected to this
signal. GObject provides a number of C marshallers for this
purpose, see the g_cclosure_marshal_*() functions. Additional C
marshallers can be generated with the [glib-genmarshal][glib-genmarshal]
utility.  Closures can be explicitly connected to signals with
g_signal_connect_closure(), but it usually more convenient to let
GObject create a closure automatically by using one of the
g_signal_connect_*() functions which take a callback function/user
data pair.

Using closures has a number of important advantages over a simple
callback function/data pointer combination:

- Closures allow the callee to get the types of the callback parameters,
  which means that language bindings don't have to write individual glue
  for each callback type.

- The reference counting of #GClosure makes it easy to handle reentrancy
  right; if a callback is removed while it is being invoked, the closure
  and its parameters won't be freed until the invocation finishes.

- g_closure_invalidate() and invalidation notifiers allow callbacks to be
  automatically removed when the objects they point to go away.</doc>
      <source-position filename="gclosure.h" line="213" />
      <field name="bits0" gs:managed-name="Bits0">
        <type name="guint" c:type="volatile guint" />
        <gs:bits name="ref_count" readable="0" bits="15" private="1" gs:managed-name="RefCount">
          <type name="guint" c:type="volatile guint" />
        </gs:bits>
        <gs:bits name="meta_marshal_nouse" readable="0" bits="1" private="1" gs:managed-name="MetaMarshalNouse">
          <type name="guint" c:type="volatile guint" />
        </gs:bits>
        <gs:bits name="n_guards" readable="0" bits="1" private="1" gs:managed-name="NGuards">
          <type name="guint" c:type="volatile guint" />
        </gs:bits>
        <gs:bits name="n_fnotifiers" readable="0" bits="2" private="1" gs:managed-name="NFnotifiers">
          <type name="guint" c:type="volatile guint" />
        </gs:bits>
        <gs:bits name="n_inotifiers" readable="0" bits="8" private="1" gs:managed-name="NInotifiers">
          <type name="guint" c:type="volatile guint" />
        </gs:bits>
        <gs:bits name="in_inotify" readable="0" bits="1" private="1" gs:managed-name="InInotify">
          <type name="guint" c:type="volatile guint" />
        </gs:bits>
        <gs:bits name="floating" readable="0" bits="1" private="1" gs:managed-name="Floating">
          <type name="guint" c:type="volatile guint" />
        </gs:bits>
        <gs:bits name="derivative_flag" readable="0" bits="1" private="1" gs:managed-name="DerivativeFlag">
          <type name="guint" c:type="volatile guint" />
        </gs:bits>
        <gs:bits name="in_marshal" writable="1" bits="1" gs:managed-name="InMarshal">
          <doc xml:space="preserve" filename="gclosure.h" line="168">Indicates whether the closure is currently being invoked with
 g_closure_invoke()</doc>
          <type name="guint" c:type="volatile guint" />
        </gs:bits>
        <gs:bits name="is_invalid" writable="1" bits="1" gs:managed-name="IsInvalid">
          <doc xml:space="preserve" filename="gclosure.h" line="170">Indicates whether the closure has been invalidated by
 g_closure_invalidate()</doc>
          <type name="guint" c:type="volatile guint" />
        </gs:bits>
      </field>
      <field name="marshal" gs:managed-name="Marshal">
        <callback name="marshal" gs:dll-name="gobject-2.0" gs:managed-name="Marshal">
          <source-position filename="gclosure.h" line="193" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="closure" transfer-ownership="none" gs:managed-name="closure" direction="in">
              <type name="Closure" c:type="GClosure*" gs:is-pointer="1" />
            </parameter>
            <parameter name="return_value" transfer-ownership="none" gs:managed-name="returnValue" direction="in">
              <type name="Value" c:type="GValue*" gs:is-pointer="1" />
            </parameter>
            <parameter name="n_param_values" transfer-ownership="none" gs:managed-name="nParamValues" direction="in">
              <type name="guint" c:type="guint" />
            </parameter>
            <parameter name="param_values" transfer-ownership="none" gs:managed-name="paramValues" direction="in">
              <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
            </parameter>
            <parameter name="invocation_hint" transfer-ownership="none" gs:managed-name="invocationHint" direction="in">
              <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
            </parameter>
            <parameter name="marshal_data" transfer-ownership="none" gs:managed-name="marshalData" direction="in">
              <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="closure" transfer-ownership="none" gs:managed-name="closure" direction="in">
              <type name="Closure" c:type="GClosure*" gs:is-pointer="1" />
            </parameter>
            <parameter name="return_value" transfer-ownership="none" gs:managed-name="returnValue" direction="in">
              <type name="Value" c:type="GValue*" gs:is-pointer="1" />
            </parameter>
            <parameter name="n_param_values" transfer-ownership="none" gs:managed-name="nParamValues" direction="in">
              <type name="guint" c:type="guint" />
            </parameter>
            <parameter name="param_values" transfer-ownership="none" gs:managed-name="paramValues" direction="in">
              <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
            </parameter>
            <parameter name="invocation_hint" transfer-ownership="none" gs:managed-name="invocationHint" direction="in">
              <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
            </parameter>
            <parameter name="marshal_data" transfer-ownership="none" gs:managed-name="marshalData" direction="in">
              <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="data" readable="0" private="1" gs:managed-name="Data">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="notifiers" readable="0" private="1" gs:managed-name="Notifiers">
        <type name="ClosureNotifyData" c:type="GClosureNotifyData*" gs:is-pointer="1" />
      </field>
      <constructor name="new_object" c:identifier="g_closure_new_object" gs:custom-constructor="1" gs:dll-name="gobject-2.0" gs:managed-name="NewObject">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="1986">A variant of g_closure_new_simple() which stores @object in the
@data field of the closure and calls g_object_watch_closure() on
@object and the created closure. This function is mainly useful
when implementing new types of closures.</doc>
        <source-position filename="gobject.h" line="616" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="1998">a newly allocated #GClosure</doc>
          <type name="Closure" c:type="GClosure*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="sizeof_closure" transfer-ownership="none" gs:managed-name="sizeofClosure" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1988">the size of the structure to allocate, must be at least
 `sizeof (GClosure)`</doc>
            <type name="guint" c:type="guint" />
          </parameter>
          <parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1990">a #GObject pointer to store in the @data field of the newly
 allocated #GClosure</doc>
            <type name="Object" c:type="GObject*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="sizeof_closure" transfer-ownership="none" gs:managed-name="sizeofClosure" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1988">the size of the structure to allocate, must be at least
 `sizeof (GClosure)`</doc>
            <type name="guint" c:type="guint" />
          </parameter>
          <parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1990">a #GObject pointer to store in the @data field of the newly
 allocated #GClosure</doc>
            <type name="Object" c:type="GObject*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <constructor name="new_simple" c:identifier="g_closure_new_simple" gs:custom-constructor="1" gs:dll-name="gobject-2.0" gs:managed-name="NewSimple">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2002">Allocates a struct of the given size and initializes the initial
part as a #GClosure. This function is mainly useful when
implementing new types of closures.

|[&lt;!-- language="C" --&gt;
typedef struct _MyClosure MyClosure;
struct _MyClosure
{
  GClosure closure;
  // extra data goes here
};

static void
my_closure_finalize (gpointer  notify_data,
                     GClosure *closure)
{
  MyClosure *my_closure = (MyClosure *)closure;

  // free extra data here
}

MyClosure *my_closure_new (gpointer data)
{
  GClosure *closure;
  MyClosure *my_closure;

  closure = g_closure_new_simple (sizeof (MyClosure), data);
  my_closure = (MyClosure *) closure;

  // initialize extra data here

  g_closure_add_finalize_notifier (closure, notify_data,
                                   my_closure_finalize);
  return my_closure;
}
]|</doc>
        <source-position filename="gclosure.h" line="246" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="2045">a floating reference to a new #GClosure</doc>
          <type name="Closure" c:type="GClosure*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="sizeof_closure" transfer-ownership="none" gs:managed-name="sizeofClosure" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2004">the size of the structure to allocate, must be at least
                 `sizeof (GClosure)`</doc>
            <type name="guint" c:type="guint" />
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2006">data to store in the @data field of the newly allocated #GClosure</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="sizeof_closure" transfer-ownership="none" gs:managed-name="sizeofClosure" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2004">the size of the structure to allocate, must be at least
                 `sizeof (GClosure)`</doc>
            <type name="guint" c:type="guint" />
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2006">data to store in the @data field of the newly allocated #GClosure</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <method name="add_finalize_notifier" c:identifier="g_closure_add_finalize_notifier" introspectable="1" gs:pinvoke-only="1" gs:pinvoke-access-modifiers="private protected" gs:dll-name="gobject-2.0" gs:managed-name="AddFinalizeNotifier">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="1905">Registers a finalization notifier which will be called when the
reference count of @closure goes down to 0. Multiple finalization
notifiers on a single closure are invoked in unspecified order. If
a single call to g_closure_unref() results in the closure being
both invalidated and finalized, then the invalidate notifiers will
be run before the finalize notifiers.</doc>
        <source-position filename="gclosure.h" line="249" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="closure" transfer-ownership="none" gs:managed-name="closure" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1907">a #GClosure</doc>
            <type name="Closure" c:type="GClosure*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="notify_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="notifyData" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1908">data to pass to @notify_func</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="notify_func" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="notifyFunc" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1909">the callback function to register</doc>
            <type name="ClosureNotify" c:type="GClosureNotify" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="notify_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="notifyData" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1908">data to pass to @notify_func</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="notify_func" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="notifyFunc" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1909">the callback function to register</doc>
            <type name="ClosureNotify" c:type="GClosureNotify" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="add_invalidate_notifier" c:identifier="g_closure_add_invalidate_notifier" introspectable="1" gs:pinvoke-only="1" gs:pinvoke-access-modifiers="private protected" gs:dll-name="gobject-2.0" gs:managed-name="AddInvalidateNotifier">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="1920">Registers an invalidation notifier which will be called when the
@closure is invalidated with g_closure_invalidate(). Invalidation
notifiers are invoked before finalization notifiers, in an
unspecified order.</doc>
        <source-position filename="gclosure.h" line="257" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="closure" transfer-ownership="none" gs:managed-name="closure" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1922">a #GClosure</doc>
            <type name="Closure" c:type="GClosure*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="notify_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="notifyData" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1923">data to pass to @notify_func</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="notify_func" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="notifyFunc" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1924">the callback function to register</doc>
            <type name="ClosureNotify" c:type="GClosureNotify" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="notify_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="notifyData" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1923">data to pass to @notify_func</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="notify_func" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="notifyFunc" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1924">the callback function to register</doc>
            <type name="ClosureNotify" c:type="GClosureNotify" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="add_marshal_guards" c:identifier="g_closure_add_marshal_guards" introspectable="1" gs:pinvoke-only="1" gs:pinvoke-access-modifiers="private protected" gs:dll-name="gobject-2.0" gs:managed-name="AddMarshalGuards">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="1933">Adds a pair of notifiers which get invoked before and after the
closure callback, respectively. This is typically used to protect
the extra arguments for the duration of the callback. See
g_object_watch_closure() for an example of marshal guards.</doc>
        <source-position filename="gclosure.h" line="265" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="closure" transfer-ownership="none" gs:managed-name="closure" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1935">a #GClosure</doc>
            <type name="Closure" c:type="GClosure*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="pre_marshal_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="preMarshalData" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1936">data to pass
 to @pre_marshal_notify</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="pre_marshal_notify" transfer-ownership="none" nullable="1" allow-none="1" closure="2" gs:managed-name="preMarshalNotify" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1938">a function to call before the closure callback</doc>
            <type name="ClosureNotify" c:type="GClosureNotify" />
          </parameter>
          <parameter name="post_marshal_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="postMarshalData" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1939">data to pass
 to @post_marshal_notify</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="post_marshal_notify" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="postMarshalNotify" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1941">a function to call after the closure callback</doc>
            <type name="ClosureNotify" c:type="GClosureNotify" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="pre_marshal_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="preMarshalData" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1936">data to pass
 to @pre_marshal_notify</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="pre_marshal_notify" transfer-ownership="none" nullable="1" allow-none="1" closure="2" gs:managed-name="preMarshalNotify" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1938">a function to call before the closure callback</doc>
            <type name="ClosureNotify" c:type="GClosureNotify" />
          </parameter>
          <parameter name="post_marshal_notify" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="postMarshalNotify" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1941">a function to call after the closure callback</doc>
            <type name="ClosureNotify" c:type="GClosureNotify" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="invalidate" c:identifier="g_closure_invalidate" gs:dll-name="gobject-2.0" gs:managed-name="Invalidate">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="1950">Sets a flag on the closure to indicate that its calling
environment has become invalid, and thus causes any future
invocations of g_closure_invoke() on this @closure to be
ignored. Also, invalidation notifiers installed on the closure will
be called at this point. Note that unless you are holding a
reference to the closure yourself, the invalidation notifiers may
unref the closure and cause it to be destroyed, so if you need to
access the closure after calling g_closure_invalidate(), make sure
that you've previously called g_closure_ref().

Note that g_closure_invalidate() will also be called when the
reference count of a closure drops to zero (unless it has already
been invalidated before).</doc>
        <source-position filename="gclosure.h" line="278" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="closure" transfer-ownership="none" gs:managed-name="closure" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1952">#GClosure to invalidate</doc>
            <type name="Closure" c:type="GClosure*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="invoke" c:identifier="g_closure_invoke" gs:dll-name="gobject-2.0" gs:managed-name="Invoke">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="1970">Invokes the closure, i.e. executes the callback represented by the @closure.</doc>
        <source-position filename="gclosure.h" line="280" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="closure" transfer-ownership="none" gs:managed-name="closure" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1972">a #GClosure</doc>
            <type name="Closure" c:type="GClosure*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="return_value" direction="out" caller-allocates="1" transfer-ownership="none" optional="1" allow-none="1" gs:managed-name="returnValue">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1973">a #GValue to store the return
               value. May be %NULL if the callback of @closure
               doesn't return a value.</doc>
            <type name="Value" c:type="GValue*" />
          </parameter>
          <parameter name="n_param_values" transfer-ownership="none" gs:managed-name="nParamValues" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1976">the length of the @param_values array</doc>
            <type name="guint" c:type="guint" />
          </parameter>
          <parameter name="param_values" transfer-ownership="none" gs:managed-name="paramValues" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1977">an array of
               #GValues holding the arguments on which to
               invoke the callback of @closure</doc>
            <array length="1" zero-terminated="0" c:type="const GValue*" gs:is-pointer="1">
              <type name="Value" c:type="GValue" />
            </array>
          </parameter>
          <parameter name="invocation_hint" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="invocationHint" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1980">a context-dependent invocation hint</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="return_value" direction="out" caller-allocates="1" transfer-ownership="none" optional="1" allow-none="1" gs:managed-name="returnValue">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1973">a #GValue to store the return
               value. May be %NULL if the callback of @closure
               doesn't return a value.</doc>
            <type name="Value" c:type="GValue*" />
          </parameter>
          <parameter name="param_values" transfer-ownership="none" gs:managed-name="paramValues" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1977">an array of
               #GValues holding the arguments on which to
               invoke the callback of @closure</doc>
            <array length="1" zero-terminated="0" c:type="const GValue*" gs:is-pointer="1">
              <type name="Value" c:type="GValue" />
            </array>
          </parameter>
          <parameter name="invocation_hint" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="invocationHint" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1980">a context-dependent invocation hint</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="ref" c:identifier="g_closure_ref" gs:dll-name="gobject-2.0" gs:managed-name="Ref" gs:special-func="ref" gs:pinvoke-only="1">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2049">Increments the reference count on a closure to force it staying
alive while the caller holds a pointer to it.</doc>
        <source-position filename="gclosure.h" line="239" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="2056">The @closure passed in, for convenience</doc>
          <type name="Closure" c:type="GClosure*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="closure" transfer-ownership="none" gs:managed-name="closure" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2051">#GClosure to increment the reference count on</doc>
            <type name="Closure" c:type="GClosure*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="remove_finalize_notifier" c:identifier="g_closure_remove_finalize_notifier" introspectable="1" gs:pinvoke-only="1" gs:pinvoke-access-modifiers="private protected" gs:dll-name="gobject-2.0" gs:managed-name="RemoveFinalizeNotifier">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2060">Removes a finalization notifier.

Notice that notifiers are automatically removed after they are run.</doc>
        <source-position filename="gclosure.h" line="253" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="closure" transfer-ownership="none" gs:managed-name="closure" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2062">a #GClosure</doc>
            <type name="Closure" c:type="GClosure*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="notify_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="notifyData" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2063">data which was passed to g_closure_add_finalize_notifier()
 when registering @notify_func</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="notify_func" transfer-ownership="none" gs:managed-name="notifyFunc" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2065">the callback function to remove</doc>
            <type name="ClosureNotify" c:type="GClosureNotify" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="notify_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="notifyData" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2063">data which was passed to g_closure_add_finalize_notifier()
 when registering @notify_func</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="notify_func" transfer-ownership="none" gs:managed-name="notifyFunc" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2065">the callback function to remove</doc>
            <type name="ClosureNotify" c:type="GClosureNotify" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="remove_invalidate_notifier" c:identifier="g_closure_remove_invalidate_notifier" introspectable="1" gs:pinvoke-only="1" gs:pinvoke-access-modifiers="private protected" gs:dll-name="gobject-2.0" gs:managed-name="RemoveInvalidateNotifier">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2073">Removes an invalidation notifier.

Notice that notifiers are automatically removed after they are run.</doc>
        <source-position filename="gclosure.h" line="261" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="closure" transfer-ownership="none" gs:managed-name="closure" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2075">a #GClosure</doc>
            <type name="Closure" c:type="GClosure*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="notify_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="notifyData" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2076">data which was passed to g_closure_add_invalidate_notifier()
              when registering @notify_func</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="notify_func" transfer-ownership="none" gs:managed-name="notifyFunc" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2078">the callback function to remove</doc>
            <type name="ClosureNotify" c:type="GClosureNotify" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="notify_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="notifyData" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2076">data which was passed to g_closure_add_invalidate_notifier()
              when registering @notify_func</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="notify_func" transfer-ownership="none" gs:managed-name="notifyFunc" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2078">the callback function to remove</doc>
            <type name="ClosureNotify" c:type="GClosureNotify" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_marshal" c:identifier="g_closure_set_marshal" introspectable="1" gs:pinvoke-only="1" gs:pinvoke-access-modifiers="private protected" gs:dll-name="gobject-2.0" gs:managed-name="SetMarshal">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2086">Sets the marshaller of @closure. The `marshal_data`
of @marshal provides a way for a meta marshaller to provide additional
information to the marshaller. (See g_closure_set_meta_marshal().) For
GObject's C predefined marshallers (the g_cclosure_marshal_*()
functions), what it provides is a callback function to use instead of
@closure-&gt;callback.</doc>
        <source-position filename="gclosure.h" line="271" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="closure" transfer-ownership="none" gs:managed-name="closure" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2088">a #GClosure</doc>
            <type name="Closure" c:type="GClosure*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="marshal" transfer-ownership="none" gs:managed-name="marshal" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2089">a #GClosureMarshal function</doc>
            <type name="ClosureMarshal" c:type="GClosureMarshal" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="marshal" transfer-ownership="none" gs:managed-name="marshal" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2089">a #GClosureMarshal function</doc>
            <type name="ClosureMarshal" c:type="GClosureMarshal" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_meta_marshal" c:identifier="g_closure_set_meta_marshal" introspectable="1" gs:pinvoke-only="1" gs:pinvoke-access-modifiers="private protected" gs:dll-name="gobject-2.0" gs:managed-name="SetMetaMarshal">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2100">Sets the meta marshaller of @closure.  A meta marshaller wraps
@closure-&gt;marshal and modifies the way it is called in some
fashion. The most common use of this facility is for C callbacks.
The same marshallers (generated by [glib-genmarshal][glib-genmarshal]),
are used everywhere, but the way that we get the callback function
differs. In most cases we want to use @closure-&gt;callback, but in
other cases we want to use some different technique to retrieve the
callback function.

For example, class closures for signals (see
g_signal_type_cclosure_new()) retrieve the callback function from a
fixed offset in the class structure.  The meta marshaller retrieves
the right callback and passes it to the marshaller as the
@marshal_data argument.</doc>
        <source-position filename="gclosure.h" line="274" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="closure" transfer-ownership="none" gs:managed-name="closure" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2102">a #GClosure</doc>
            <type name="Closure" c:type="GClosure*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="marshalData" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2103">context-dependent data to pass
 to @meta_marshal</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="meta_marshal" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="metaMarshal" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2105">a #GClosureMarshal function</doc>
            <type name="ClosureMarshal" c:type="GClosureMarshal" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="marshalData" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2103">context-dependent data to pass
 to @meta_marshal</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="meta_marshal" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="metaMarshal" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2105">a #GClosureMarshal function</doc>
            <type name="ClosureMarshal" c:type="GClosureMarshal" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="sink" c:identifier="g_closure_sink" gs:pinvoke-only="1" gs:dll-name="gobject-2.0" gs:managed-name="Sink">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2124">Takes over the initial ownership of a closure.  Each closure is
initially created in a "floating" state, which means that the initial
reference count is not owned by any caller. g_closure_sink() checks
to see if the object is still floating, and if so, unsets the
floating state and decreases the reference count. If the closure
is not floating, g_closure_sink() does nothing. The reason for the
existence of the floating state is to prevent cumbersome code
sequences like:
|[&lt;!-- language="C" --&gt;
closure = g_cclosure_new (cb_func, cb_data);
g_source_set_closure (source, closure);
g_closure_unref (closure); // GObject doesn't really need this
]|
Because g_source_set_closure() (and similar functions) take ownership of the
initial reference count, if it is unowned, we instead can write:
|[&lt;!-- language="C" --&gt;
g_source_set_closure (source, g_cclosure_new (cb_func, cb_data));
]|

Generally, this function is used together with g_closure_ref(). An example
of storing a closure for later notification looks like:
|[&lt;!-- language="C" --&gt;
static GClosure *notify_closure = NULL;
void
foo_notify_set_closure (GClosure *closure)
{
  if (notify_closure)
    g_closure_unref (notify_closure);
  notify_closure = closure;
  if (notify_closure)
    {
      g_closure_ref (notify_closure);
      g_closure_sink (notify_closure);
    }
}
]|

Because g_closure_sink() may decrement the reference count of a closure
(if it hasn't been called on @closure yet) just like g_closure_unref(),
g_closure_ref() should be called prior to this function.</doc>
        <source-position filename="gclosure.h" line="241" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="closure" transfer-ownership="none" gs:managed-name="closure" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2126">#GClosure to decrement the initial reference count on, if it's
          still being held</doc>
            <type name="Closure" c:type="GClosure*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="unref" c:identifier="g_closure_unref" gs:dll-name="gobject-2.0" gs:managed-name="Unref" gs:special-func="unref" gs:pinvoke-only="1">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2172">Decrements the reference count of a closure after it was previously
incremented by the same caller. If no other callers are using the
closure, then the closure will be destroyed and freed.</doc>
        <source-position filename="gclosure.h" line="243" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="closure" transfer-ownership="none" gs:managed-name="closure" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2174">#GClosure to decrement the reference count on</doc>
            <type name="Closure" c:type="GClosure*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_closure_get_type" gs:access-modifiers="private" gs:dll-name="gobject-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </glib:boxed>
    <callback name="ClosureMarshal" c:type="GClosureMarshal" gs:dll-name="gobject-2.0" gs:managed-name="ClosureMarshal">
      <doc xml:space="preserve" filename="gclosure.h" line="97">The type used for marshaller functions.</doc>
      <source-position filename="gclosure.h" line="115" />
      <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
        <type name="none" c:type="void" />
      </return-value>
      <parameters>
        <parameter name="closure" transfer-ownership="none" gs:managed-name="closure" direction="in">
          <doc xml:space="preserve" filename="gclosure.h" line="99">the #GClosure to which the marshaller belongs</doc>
          <type name="Closure" c:type="GClosure*" gs:is-pointer="1" />
        </parameter>
        <parameter name="return_value" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="returnValue" direction="in">
          <doc xml:space="preserve" filename="gclosure.h" line="100">a #GValue to store the return
 value. May be %NULL if the callback of @closure doesn't return a
 value.</doc>
          <type name="Value" c:type="GValue*" gs:is-pointer="1" />
        </parameter>
        <parameter name="n_param_values" transfer-ownership="none" gs:managed-name="nParamValues" direction="in">
          <doc xml:space="preserve" filename="gclosure.h" line="103">the length of the @param_values array</doc>
          <type name="guint" c:type="guint" />
        </parameter>
        <parameter name="param_values" transfer-ownership="none" gs:managed-name="paramValues" direction="in">
          <doc xml:space="preserve" filename="gclosure.h" line="104">an array of
 #GValues holding the arguments on which to invoke the
 callback of @closure</doc>
          <array length="2" zero-terminated="0" c:type="const GValue*" gs:is-pointer="1">
            <type name="Value" c:type="GValue" />
          </array>
        </parameter>
        <parameter name="invocation_hint" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="invocationHint" direction="in">
          <doc xml:space="preserve" filename="gclosure.h" line="107">the invocation hint given as the
 last argument to g_closure_invoke()</doc>
          <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
        </parameter>
        <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="marshalData" direction="in">
          <doc xml:space="preserve" filename="gclosure.h" line="109">additional data specified when
 registering the marshaller, see g_closure_set_marshal() and
 g_closure_set_meta_marshal()</doc>
          <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
        </parameter>
      </parameters>
      <gs:managed-parameters>
        <parameter name="closure" transfer-ownership="none" gs:managed-name="closure" direction="in">
          <doc xml:space="preserve" filename="gclosure.h" line="99">the #GClosure to which the marshaller belongs</doc>
          <type name="Closure" c:type="GClosure*" gs:is-pointer="1" />
        </parameter>
        <parameter name="return_value" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="returnValue" direction="in">
          <doc xml:space="preserve" filename="gclosure.h" line="100">a #GValue to store the return
 value. May be %NULL if the callback of @closure doesn't return a
 value.</doc>
          <type name="Value" c:type="GValue*" gs:is-pointer="1" />
        </parameter>
        <parameter name="param_values" transfer-ownership="none" gs:managed-name="paramValues" direction="in">
          <doc xml:space="preserve" filename="gclosure.h" line="104">an array of
 #GValues holding the arguments on which to invoke the
 callback of @closure</doc>
          <array length="2" zero-terminated="0" c:type="const GValue*" gs:is-pointer="1">
            <type name="Value" c:type="GValue" />
          </array>
        </parameter>
        <parameter name="invocation_hint" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="invocationHint" direction="in">
          <doc xml:space="preserve" filename="gclosure.h" line="107">the invocation hint given as the
 last argument to g_closure_invoke()</doc>
          <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
        </parameter>
        <parameter name="marshal_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="marshalData" direction="in">
          <doc xml:space="preserve" filename="gclosure.h" line="109">additional data specified when
 registering the marshaller, see g_closure_set_marshal() and
 g_closure_set_meta_marshal()</doc>
          <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
        </parameter>
      </gs:managed-parameters>
    </callback>
    <callback name="ClosureNotify" c:type="GClosureNotify" gs:dll-name="gobject-2.0" gs:managed-name="ClosureNotify">
      <doc xml:space="preserve" filename="gclosure.h" line="87">The type used for the various notification callbacks which can be registered
on closures.</doc>
      <source-position filename="gclosure.h" line="95" />
      <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
        <type name="none" c:type="void" />
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
          <doc xml:space="preserve" filename="gclosure.h" line="89">data specified when registering the notification callback</doc>
          <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
        </parameter>
        <parameter name="closure" transfer-ownership="none" gs:managed-name="closure" direction="in">
          <doc xml:space="preserve" filename="gclosure.h" line="90">the #GClosure on which the notification is emitted</doc>
          <type name="Closure" c:type="GClosure*" gs:is-pointer="1" />
        </parameter>
      </parameters>
      <gs:managed-parameters>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
          <doc xml:space="preserve" filename="gclosure.h" line="89">data specified when registering the notification callback</doc>
          <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
        </parameter>
        <parameter name="closure" transfer-ownership="none" gs:managed-name="closure" direction="in">
          <doc xml:space="preserve" filename="gclosure.h" line="90">the #GClosure on which the notification is emitted</doc>
          <type name="Closure" c:type="GClosure*" gs:is-pointer="1" />
        </parameter>
      </gs:managed-parameters>
    </callback>
    <record name="ClosureNotifyData" c:type="GClosureNotifyData" gs:managed-name="ClosureNotifyData">
      <source-position filename="gclosure.h" line="165" />
      <field name="data" writable="1" gs:managed-name="Data">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="notify" writable="1" gs:managed-name="Notify">
        <type name="ClosureNotify" c:type="GClosureNotify" />
      </field>
    </record>
    <bitfield name="ConnectFlags" c:type="GConnectFlags" gs:managed-name="ConnectFlags">
      <doc xml:space="preserve" filename="gsignal.h" line="145">The connection flags are used to specify the behaviour of a signal's
connection.</doc>
      <source-position filename="gsignal.h" line="159" />
      <member name="after" value="1" c:identifier="G_CONNECT_AFTER" gs:managed-name="After">
        <doc xml:space="preserve" filename="gsignal.h" line="147">whether the handler should be called before or after the
 default handler of the signal.</doc>
      </member>
      <member name="swapped" value="2" c:identifier="G_CONNECT_SWAPPED" gs:managed-name="Swapped">
        <doc xml:space="preserve" filename="gsignal.h" line="149">whether the instance and data should be swapped when
 calling the handler; see g_signal_connect_swapped() for an example.</doc>
      </member>
    </bitfield>
    <record name="EnumClass" c:type="GEnumClass" disguised="1" gs:has-parent="1" gs:managed-name="EnumClass">
      <doc xml:space="preserve" filename="genums.h" line="143">The class of an enumeration type holds information about its
possible values.</doc>
      <source-position filename="genums.h" line="164" />
      <field name="g_type_class" writable="1" gs:managed-name="GTypeClass">
        <doc xml:space="preserve" filename="genums.h" line="145">the parent class</doc>
        <type name="TypeClass" c:type="GTypeClass" />
      </field>
      <field name="minimum" writable="1" gs:managed-name="Minimum">
        <doc xml:space="preserve" filename="genums.h" line="146">the smallest possible value.</doc>
        <type name="gint" c:type="gint" />
      </field>
      <field name="maximum" writable="1" gs:managed-name="Maximum">
        <doc xml:space="preserve" filename="genums.h" line="147">the largest possible value.</doc>
        <type name="gint" c:type="gint" />
      </field>
      <field name="n_values" writable="1" gs:managed-name="NValues">
        <doc xml:space="preserve" filename="genums.h" line="148">the number of possible values.</doc>
        <type name="guint" c:type="guint" />
      </field>
      <field name="values" writable="1" gs:managed-name="Values">
        <doc xml:space="preserve" filename="genums.h" line="149">an array of #GEnumValue structs describing the
 individual values.</doc>
        <type name="EnumValue" c:type="GEnumValue*" gs:is-pointer="1" />
      </field>
    </record>
    <record name="EnumValue" c:type="GEnumValue" gs:managed-name="EnumValue">
      <doc xml:space="preserve" filename="genums.h" line="185">A structure which contains a single enum value, its name, and its
nickname.</doc>
      <source-position filename="genums.h" line="199" />
      <field name="value" writable="1" gs:managed-name="Value">
        <doc xml:space="preserve" filename="genums.h" line="187">the enum value</doc>
        <type name="gint" c:type="gint" />
      </field>
      <field name="value_name" writable="1" gs:managed-name="ValueName">
        <doc xml:space="preserve" filename="genums.h" line="188">the name of the value</doc>
        <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
      </field>
      <field name="value_nick" writable="1" gs:managed-name="ValueNick">
        <doc xml:space="preserve" filename="genums.h" line="189">the nickname of the value</doc>
        <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
      </field>
    </record>
    <record name="FlagsClass" c:type="GFlagsClass" disguised="1" gs:has-parent="1" gs:managed-name="FlagsClass">
      <doc xml:space="preserve" filename="genums.h" line="165">The class of a flags type holds information about its
possible values.</doc>
      <source-position filename="genums.h" line="184" />
      <field name="g_type_class" writable="1" gs:managed-name="GTypeClass">
        <doc xml:space="preserve" filename="genums.h" line="167">the parent class</doc>
        <type name="TypeClass" c:type="GTypeClass" />
      </field>
      <field name="mask" writable="1" gs:managed-name="Mask">
        <doc xml:space="preserve" filename="genums.h" line="168">a mask covering all possible values.</doc>
        <type name="guint" c:type="guint" />
      </field>
      <field name="n_values" writable="1" gs:managed-name="NValues">
        <doc xml:space="preserve" filename="genums.h" line="169">the number of possible values.</doc>
        <type name="guint" c:type="guint" />
      </field>
      <field name="values" writable="1" gs:managed-name="Values">
        <doc xml:space="preserve" filename="genums.h" line="170">an array of #GFlagsValue structs describing the
 individual values.</doc>
        <type name="FlagsValue" c:type="GFlagsValue*" gs:is-pointer="1" />
      </field>
    </record>
    <record name="FlagsValue" c:type="GFlagsValue" gs:managed-name="FlagsValue">
      <doc xml:space="preserve" filename="genums.h" line="200">A structure which contains a single flags value, its name, and its
nickname.</doc>
      <source-position filename="genums.h" line="214" />
      <field name="value" writable="1" gs:managed-name="Value">
        <doc xml:space="preserve" filename="genums.h" line="202">the flags value</doc>
        <type name="guint" c:type="guint" />
      </field>
      <field name="value_name" writable="1" gs:managed-name="ValueName">
        <doc xml:space="preserve" filename="genums.h" line="203">the name of the value</doc>
        <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
      </field>
      <field name="value_nick" writable="1" gs:managed-name="ValueNick">
        <doc xml:space="preserve" filename="genums.h" line="204">the nickname of the value</doc>
        <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
      </field>
    </record>
    <class name="InitiallyUnowned" c:symbol-prefix="initially_unowned" c:type="GInitiallyUnowned" parent="Object" glib:type-name="GInitiallyUnowned" glib:get-type="g_initially_unowned_get_type" glib:type-struct="InitiallyUnownedClass" gs:managed-name="InitiallyUnowned">
      <doc xml:space="preserve" filename="gobject.h" line="370">All the fields in the GInitiallyUnowned structure
are private to the #GInitiallyUnowned implementation and should never be
accessed directly.</doc>
      <source-position filename="gobject.h" line="190" />
      <field name="parent" gs:managed-name="Parent">
  <type name="Object" c:type="GObject" />
</field>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_initially_unowned_get_type" gs:access-modifiers="private" gs:dll-name="gobject-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </class>
    <record name="InitiallyUnownedClass" c:type="GInitiallyUnownedClass" glib:is-gtype-struct-for="InitiallyUnowned" gs:managed-name="InitiallyUnownedClass">
      <doc xml:space="preserve" filename="gobject.h" line="377">The class structure for the GInitiallyUnowned type.</doc>
      <source-position filename="gobject.h" line="190" />
      <field name="parent" gs:managed-name="Parent">
  <type name="ObjectClass" c:type="GObjectClass" />
</field>
    </record>
    <callback name="InstanceInitFunc" c:type="GInstanceInitFunc" gs:dll-name="gobject-2.0" gs:managed-name="InstanceInitFunc">
      <doc xml:space="preserve" filename="gtype.h" line="902">A callback function used by the type system to initialize a new
instance of a type. This function initializes all instance members and
allocates any resources required by it.

Initialization of a derived instance involves calling all its parent
types instance initializers, so the class member of the instance
is altered during its initialization to always point to the class that
belongs to the type the current initializer was introduced for.

The extended members of @instance are guaranteed to have been filled with
zeros before this function is called.</doc>
      <source-position filename="gtype.h" line="920" />
      <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
        <type name="none" c:type="void" />
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none" gs:managed-name="instance" direction="in">
          <doc xml:space="preserve" filename="gtype.h" line="904">The instance to initialize</doc>
          <type name="TypeInstance" c:type="GTypeInstance*" gs:is-pointer="1" />
        </parameter>
        <parameter name="g_class" transfer-ownership="none" gs:managed-name="gClass" direction="in">
          <doc xml:space="preserve" filename="gtype.h" line="905">The class of the type the instance is
   created for</doc>
          <type name="TypeClass" c:type="gpointer" gs:is-pointer="1" />
        </parameter>
      </parameters>
      <gs:managed-parameters>
        <parameter name="instance" transfer-ownership="none" gs:managed-name="instance" direction="in">
          <doc xml:space="preserve" filename="gtype.h" line="904">The instance to initialize</doc>
          <type name="TypeInstance" c:type="GTypeInstance*" gs:is-pointer="1" />
        </parameter>
        <parameter name="g_class" transfer-ownership="none" gs:managed-name="gClass" direction="in">
          <doc xml:space="preserve" filename="gtype.h" line="905">The class of the type the instance is
   created for</doc>
          <type name="TypeClass" c:type="gpointer" gs:is-pointer="1" />
        </parameter>
      </gs:managed-parameters>
    </callback>
    <callback name="InterfaceFinalizeFunc" c:type="GInterfaceFinalizeFunc" gs:dll-name="gobject-2.0" gs:managed-name="InterfaceFinalizeFunc">
      <doc xml:space="preserve" filename="gtype.h" line="936">A callback function used by the type system to finalize an interface.
This function should destroy any internal data and release any resources
allocated by the corresponding GInterfaceInitFunc() function.</doc>
      <source-position filename="gtype.h" line="945" />
      <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
        <type name="none" c:type="void" />
      </return-value>
      <parameters>
        <parameter name="g_iface" transfer-ownership="none" gs:managed-name="gIface" direction="in">
          <doc xml:space="preserve" filename="gtype.h" line="938">The interface structure to finalize</doc>
          <type name="TypeInterface" c:type="gpointer" gs:is-pointer="1" />
        </parameter>
        <parameter name="iface_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="ifaceData" direction="in">
          <doc xml:space="preserve" filename="gtype.h" line="939">The @interface_data supplied via the #GInterfaceInfo structure</doc>
          <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
        </parameter>
      </parameters>
      <gs:managed-parameters>
        <parameter name="g_iface" transfer-ownership="none" gs:managed-name="gIface" direction="in">
          <doc xml:space="preserve" filename="gtype.h" line="938">The interface structure to finalize</doc>
          <type name="TypeInterface" c:type="gpointer" gs:is-pointer="1" />
        </parameter>
        <parameter name="iface_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="ifaceData" direction="in">
          <doc xml:space="preserve" filename="gtype.h" line="939">The @interface_data supplied via the #GInterfaceInfo structure</doc>
          <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
        </parameter>
      </gs:managed-parameters>
    </callback>
    <record name="InterfaceInfo" c:type="GInterfaceInfo" gs:managed-name="InterfaceInfo">
      <doc xml:space="preserve" filename="gtype.h" line="1076">A structure that provides information to the type system which is
used specifically for managing interface types.</doc>
      <source-position filename="gtype.h" line="1090" />
      <field name="interface_init" writable="1" gs:managed-name="InterfaceInit">
        <doc xml:space="preserve" filename="gtype.h" line="1078">location of the interface initialization function</doc>
        <type name="InterfaceInitFunc" c:type="GInterfaceInitFunc" />
      </field>
      <field name="interface_finalize" writable="1" gs:managed-name="InterfaceFinalize">
        <doc xml:space="preserve" filename="gtype.h" line="1079">location of the interface finalization function</doc>
        <type name="InterfaceFinalizeFunc" c:type="GInterfaceFinalizeFunc" />
      </field>
      <field name="interface_data" writable="1" gs:managed-name="InterfaceData">
        <doc xml:space="preserve" filename="gtype.h" line="1080">user-supplied data passed to the interface init/finalize functions</doc>
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
    </record>
    <callback name="InterfaceInitFunc" c:type="GInterfaceInitFunc" gs:dll-name="gobject-2.0" gs:managed-name="InterfaceInitFunc">
      <doc xml:space="preserve" filename="gtype.h" line="922">A callback function used by the type system to initialize a new
interface.  This function should initialize all internal data and
allocate any resources required by the interface.

The members of @iface_data are guaranteed to have been filled with
zeros before this function is called.</doc>
      <source-position filename="gtype.h" line="934" />
      <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
        <type name="none" c:type="void" />
      </return-value>
      <parameters>
        <parameter name="g_iface" transfer-ownership="none" gs:managed-name="gIface" direction="in">
          <doc xml:space="preserve" filename="gtype.h" line="924">The interface structure to initialize</doc>
          <type name="TypeInterface" c:type="gpointer" gs:is-pointer="1" />
        </parameter>
        <parameter name="iface_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="ifaceData" direction="in">
          <doc xml:space="preserve" filename="gtype.h" line="925">The @interface_data supplied via the #GInterfaceInfo structure</doc>
          <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
        </parameter>
      </parameters>
      <gs:managed-parameters>
        <parameter name="g_iface" transfer-ownership="none" gs:managed-name="gIface" direction="in">
          <doc xml:space="preserve" filename="gtype.h" line="924">The interface structure to initialize</doc>
          <type name="TypeInterface" c:type="gpointer" gs:is-pointer="1" />
        </parameter>
        <parameter name="iface_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="ifaceData" direction="in">
          <doc xml:space="preserve" filename="gtype.h" line="925">The @interface_data supplied via the #GInterfaceInfo structure</doc>
          <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
        </parameter>
      </gs:managed-parameters>
    </callback>
    <class name="Object" c:symbol-prefix="object" c:type="GObject" glib:type-name="GObject" glib:get-type="g_object_get_type" glib:type-struct="ObjectClass" gs:custom-default-constructor="1" gs:custom-dispose="1" gs:managed-name="Object">
      <doc xml:space="preserve" filename="gobject.h" line="239">All the fields in the GObject structure are private
to the #GObject implementation and should never be accessed directly.</doc>
      <source-position filename="gobject.h" line="354" />
      <constructor name="newv" c:identifier="g_object_newv" deprecated="1" deprecated-version="2.54" gs:dll-name="gobject-2.0" gs:managed-name="Newv">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3098">Creates a new instance of a #GObject subtype and sets its properties.

Construction parameters (see #G_PARAM_CONSTRUCT, #G_PARAM_CONSTRUCT_ONLY)
which are not explicitly specified are set to their default values.</doc>
        <doc-deprecated xml:space="preserve">Use g_object_new_with_properties() instead.
deprecated. See #GParameter for more information.</doc-deprecated>
        <source-position filename="gobject.h" line="431" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3109">a new instance of
@object_type</doc>
          <type name="Object" c:type="gpointer" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="object_type" transfer-ownership="none" gs:managed-name="objectType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3100">the type id of the #GObject subtype to instantiate</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="n_parameters" transfer-ownership="none" gs:managed-name="nParameters" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3101">the length of the @parameters array</doc>
            <type name="guint" c:type="guint" />
          </parameter>
          <parameter name="parameters" transfer-ownership="none" gs:managed-name="parameters" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3102">an array of #GParameter</doc>
            <array length="1" zero-terminated="0" c:type="GParameter*" gs:is-pointer="1">
              <type name="Parameter" c:type="GParameter" />
            </array>
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="object_type" transfer-ownership="none" gs:managed-name="objectType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3100">the type id of the #GObject subtype to instantiate</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="parameters" transfer-ownership="none" gs:managed-name="parameters" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3102">an array of #GParameter</doc>
            <array length="1" zero-terminated="0" c:type="GParameter*" gs:is-pointer="1">
              <type name="Parameter" c:type="GParameter" />
            </array>
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <function name="compat_control" c:identifier="g_object_compat_control" gs:dll-name="gobject-2.0" gs:managed-name="CompatControl">
        <source-position filename="gobject.h" line="647" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="gsize" c:type="gsize" />
        </return-value>
        <parameters>
          <parameter name="what" transfer-ownership="none" gs:managed-name="what" direction="in">
            <type name="gsize" c:type="gsize" />
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="what" transfer-ownership="none" gs:managed-name="what" direction="in">
            <type name="gsize" c:type="gsize" />
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <virtual-method name="constructed" gs:dll-name="gobject-2.0" gs:managed-name="DoConstructed">
        <source-position filename="gobject.h" line="347" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <type name="Object" c:type="GObject*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </virtual-method>
      <virtual-method name="dispatch_properties_changed" gs:dll-name="gobject-2.0" gs:managed-name="DoDispatchPropertiesChanged">
        <source-position filename="gobject.h" line="339" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <type name="Object" c:type="GObject*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="n_pspecs" transfer-ownership="none" gs:managed-name="nPspecs" direction="in">
            <type name="guint" c:type="guint" />
          </parameter>
          <parameter name="pspecs" transfer-ownership="none" gs:managed-name="pspecs" direction="in">
            <type name="ParamSpec" c:type="GParamSpec**" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="n_pspecs" transfer-ownership="none" gs:managed-name="nPspecs" direction="in">
            <type name="guint" c:type="guint" />
          </parameter>
          <parameter name="pspecs" transfer-ownership="none" gs:managed-name="pspecs" direction="in">
            <type name="ParamSpec" c:type="GParamSpec**" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="dispose" gs:dll-name="gobject-2.0" gs:managed-name="DoDispose">
        <source-position filename="gobject.h" line="336" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <type name="Object" c:type="GObject*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </virtual-method>
      <virtual-method name="finalize" gs:dll-name="gobject-2.0" gs:managed-name="DoFinalize">
        <source-position filename="gobject.h" line="337" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <type name="Object" c:type="GObject*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </virtual-method>
      <virtual-method name="get_property" gs:dll-name="gobject-2.0" gs:managed-name="DoGetProperty">
        <source-position filename="gobject.h" line="332" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <type name="Object" c:type="GObject*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="property_id" transfer-ownership="none" gs:managed-name="propertyId" direction="in">
            <type name="guint" c:type="guint" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <type name="Value" c:type="GValue*" gs:is-pointer="1" />
          </parameter>
          <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="property_id" transfer-ownership="none" gs:managed-name="propertyId" direction="in">
            <type name="guint" c:type="guint" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <type name="Value" c:type="GValue*" gs:is-pointer="1" />
          </parameter>
          <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="notify" invoker="notify" gs:dll-name="gobject-2.0" gs:managed-name="DoNotify">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3116">Emits a "notify" signal for the property @property_name on @object.

When possible, eg. when signaling a property change from within the class
that registered the property, you should use g_object_notify_by_pspec()
instead.

Note that emission of the notify signal may be blocked with
g_object_freeze_notify(). In this case, the signal emissions are queued
and will be emitted (in reverse order) when g_object_thaw_notify() is
called.</doc>
        <source-position filename="gobject.h" line="343" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3118">a #GObject</doc>
            <type name="Object" c:type="GObject*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="set_property" gs:dll-name="gobject-2.0" gs:managed-name="DoSetProperty">
        <source-position filename="gobject.h" line="328" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <type name="Object" c:type="GObject*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="property_id" transfer-ownership="none" gs:managed-name="propertyId" direction="in">
            <type name="guint" c:type="guint" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </parameter>
          <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="property_id" transfer-ownership="none" gs:managed-name="propertyId" direction="in">
            <type name="guint" c:type="guint" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </parameter>
          <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <method name="add_toggle_ref" c:identifier="g_object_add_toggle_ref" version="2.8" introspectable="1" gs:pinvoke-only="1" gs:dll-name="gobject-2.0" gs:managed-name="AddToggleRef">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2367">Increases the reference count of the object by one and sets a
callback to be called when all other references to the object are
dropped, or when this is already the last reference to the object
and another reference is established.

This functionality is intended for binding @object to a proxy
object managed by another memory manager. This is done with two
paired references: the strong reference added by
g_object_add_toggle_ref() and a reverse reference to the proxy
object which is either a strong reference or weak reference.

The setup is that when there are no other references to @object,
only a weak reference is held in the reverse direction from @object
to the proxy object, but when there are other references held to
@object, a strong reference is held. The @notify callback is called
when the reference from @object to the proxy object should be
"toggled" from strong to weak (@is_last_ref true) or weak to strong
(@is_last_ref false).

Since a (normal) reference must be held to the object before
calling g_object_add_toggle_ref(), the initial state of the reverse
link is always strong.

Multiple toggle references may be added to the same gobject,
however if there are multiple toggle references to an object, none
of them will ever be notified until all but one are removed.  For
this reason, you should only ever use a toggle reference if there
is important state in the proxy object.</doc>
        <source-position filename="gobject.h" line="539" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2369">a #GObject</doc>
            <type name="Object" c:type="GObject*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="notify" transfer-ownership="none" closure="1" gs:managed-name="notify" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2370">a function to call when this reference is the
 last reference to the object, or is no longer
 the last reference.</doc>
            <type name="ToggleNotify" c:type="GToggleNotify" />
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2373">data to pass to @notify</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="notify" transfer-ownership="none" closure="1" gs:managed-name="notify" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2370">a function to call when this reference is the
 last reference to the object, or is no longer
 the last reference.</doc>
            <type name="ToggleNotify" c:type="GToggleNotify" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="bind_property" c:identifier="g_object_bind_property" version="2.26" gs:dll-name="gobject-2.0" gs:managed-name="BindProperty">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2426">Creates a binding between @source_property on @source and @target_property
on @target. Whenever the @source_property is changed the @target_property is
updated using the same value. For instance:

|[
  g_object_bind_property (action, "active", widget, "sensitive", 0);
]|

Will result in the "sensitive" property of the widget #GObject instance to be
updated with the same value of the "active" property of the action #GObject
instance.

If @flags contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
if @target_property on @target changes then the @source_property on @source
will be updated as well.

The binding will automatically be removed when either the @source or the
@target instances are finalized. To remove the binding without affecting the
@source and the @target you can just call g_object_unref() on the returned
#GBinding instance.

Removing the binding by calling g_object_unref() on it must only be done if
the binding, @source and @target are only used from a single thread and it
is clear that both @source and @target outlive the binding. Especially it
is not safe to rely on this if the binding, @source or @target can be
finalized from different threads. Keep another reference to the binding and
use g_binding_unbind() instead to be on the safe side.

A #GObject can have multiple bindings.</doc>
        <source-position filename="gbinding.h" line="123" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="2464">the #GBinding instance representing the
    binding between the two #GObject instances. The binding is released
    whenever the #GBinding reference count reaches zero.</doc>
          <type name="Binding" c:type="GBinding*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2428">the source #GObject</doc>
            <type name="Object" c:type="gpointer" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="source_property" transfer-ownership="none" gs:managed-name="sourceProperty" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2429">the property on @source to bind</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="target" transfer-ownership="none" gs:managed-name="target" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2430">the target #GObject</doc>
            <type name="Object" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="target_property" transfer-ownership="none" gs:managed-name="targetProperty" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2431">the property on @target to bind</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2432">flags to pass to #GBinding</doc>
            <type name="BindingFlags" c:type="GBindingFlags" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="source_property" transfer-ownership="none" gs:managed-name="sourceProperty" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2429">the property on @source to bind</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="target" transfer-ownership="none" gs:managed-name="target" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2430">the target #GObject</doc>
            <type name="Object" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="target_property" transfer-ownership="none" gs:managed-name="targetProperty" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2431">the property on @target to bind</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2432">flags to pass to #GBinding</doc>
            <type name="BindingFlags" c:type="GBindingFlags" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="bind_property_full" c:identifier="g_object_bind_property_full" version="2.26" gs:pinvoke-only="1" gs:dll-name="gobject-2.0" gs:managed-name="BindPropertyFull">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2471">Complete version of g_object_bind_property().

Creates a binding between @source_property on @source and @target_property
on @target, allowing you to set the transformation functions to be used by
the binding.

If @flags contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
if @target_property on @target changes then the @source_property on @source
will be updated as well. The @transform_from function is only used in case
of bidirectional bindings, otherwise it will be ignored

The binding will automatically be removed when either the @source or the
@target instances are finalized. This will release the reference that is
being held on the #GBinding instance; if you want to hold on to the
#GBinding instance, you will need to hold a reference to it.

To remove the binding, call g_binding_unbind().

A #GObject can have multiple bindings.

The same @user_data parameter will be used for both @transform_to
and @transform_from transformation functions; the @notify function will
be called once, when the binding is removed. If you need different data
for each transformation function, please use
g_object_bind_property_with_closures() instead.</doc>
        <source-position filename="gbinding.h" line="129" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="2513">the #GBinding instance representing the
    binding between the two #GObject instances. The binding is released
    whenever the #GBinding reference count reaches zero.</doc>
          <type name="Binding" c:type="GBinding*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2473">the source #GObject</doc>
            <type name="Object" c:type="gpointer" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="source_property" transfer-ownership="none" gs:managed-name="sourceProperty" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2474">the property on @source to bind</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="target" transfer-ownership="none" gs:managed-name="target" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2475">the target #GObject</doc>
            <type name="Object" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="target_property" transfer-ownership="none" gs:managed-name="targetProperty" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2476">the property on @target to bind</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2477">flags to pass to #GBinding</doc>
            <type name="BindingFlags" c:type="GBindingFlags" />
          </parameter>
          <parameter name="transform_to" transfer-ownership="none" nullable="1" allow-none="1" scope="notified" gs:managed-name="transformTo" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2478">the transformation function
    from the @source to the @target, or %NULL to use the default</doc>
            <type name="BindingTransformFunc" c:type="GBindingTransformFunc" />
          </parameter>
          <parameter name="transform_from" transfer-ownership="none" nullable="1" allow-none="1" scope="notified" closure="6" destroy="7" gs:managed-name="transformFrom" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2480">the transformation function
    from the @target to the @source, or %NULL to use the default</doc>
            <type name="BindingTransformFunc" c:type="GBindingTransformFunc" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2482">custom data to be passed to the transformation functions,
    or %NULL</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="notify" transfer-ownership="none" nullable="1" allow-none="1" scope="async" gs:managed-name="notify" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2484">a function to call when disposing the binding, to free
    resources used by the transformation functions, or %NULL if not required</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="source_property" transfer-ownership="none" gs:managed-name="sourceProperty" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2474">the property on @source to bind</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="target" transfer-ownership="none" gs:managed-name="target" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2475">the target #GObject</doc>
            <type name="Object" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="target_property" transfer-ownership="none" gs:managed-name="targetProperty" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2476">the property on @target to bind</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2477">flags to pass to #GBinding</doc>
            <type name="BindingFlags" c:type="GBindingFlags" />
          </parameter>
          <parameter name="transform_to" transfer-ownership="none" nullable="1" allow-none="1" scope="notified" gs:managed-name="transformTo" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2478">the transformation function
    from the @source to the @target, or %NULL to use the default</doc>
            <type name="BindingTransformFunc" c:type="GBindingTransformFunc" />
          </parameter>
          <parameter name="transform_from" transfer-ownership="none" nullable="1" allow-none="1" scope="notified" closure="6" destroy="7" gs:managed-name="transformFrom" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2480">the transformation function
    from the @target to the @source, or %NULL to use the default</doc>
            <type name="BindingTransformFunc" c:type="GBindingTransformFunc" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="bind_property_with_closures" c:identifier="g_object_bind_property_with_closures" shadows="bind_property" version="2.26" gs:dll-name="gobject-2.0" gs:managed-name="BindProperty">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2520">Creates a binding between @source_property on @source and @target_property
on @target, allowing you to set the transformation functions to be used by
the binding.

This function is the language bindings friendly version of
g_object_bind_property_full(), using #GClosures instead of
function pointers.</doc>
        <source-position filename="gbinding.h" line="139" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="2540">the #GBinding instance representing the
    binding between the two #GObject instances. The binding is released
    whenever the #GBinding reference count reaches zero.</doc>
          <type name="Binding" c:type="GBinding*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2522">the source #GObject</doc>
            <type name="Object" c:type="gpointer" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="source_property" transfer-ownership="none" gs:managed-name="sourceProperty" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2523">the property on @source to bind</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="target" transfer-ownership="none" gs:managed-name="target" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2524">the target #GObject</doc>
            <type name="Object" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="target_property" transfer-ownership="none" gs:managed-name="targetProperty" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2525">the property on @target to bind</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2526">flags to pass to #GBinding</doc>
            <type name="BindingFlags" c:type="GBindingFlags" />
          </parameter>
          <parameter name="transform_to" transfer-ownership="none" gs:managed-name="transformTo" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2527">a #GClosure wrapping the transformation function
    from the @source to the @target, or %NULL to use the default</doc>
            <type name="Closure" c:type="GClosure*" gs:is-pointer="1" />
          </parameter>
          <parameter name="transform_from" transfer-ownership="none" gs:managed-name="transformFrom" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2529">a #GClosure wrapping the transformation function
    from the @target to the @source, or %NULL to use the default</doc>
            <type name="Closure" c:type="GClosure*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="source_property" transfer-ownership="none" gs:managed-name="sourceProperty" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2523">the property on @source to bind</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="target" transfer-ownership="none" gs:managed-name="target" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2524">the target #GObject</doc>
            <type name="Object" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="target_property" transfer-ownership="none" gs:managed-name="targetProperty" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2525">the property on @target to bind</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2526">flags to pass to #GBinding</doc>
            <type name="BindingFlags" c:type="GBindingFlags" />
          </parameter>
          <parameter name="transform_to" transfer-ownership="none" gs:managed-name="transformTo" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2527">a #GClosure wrapping the transformation function
    from the @source to the @target, or %NULL to use the default</doc>
            <type name="Closure" c:type="GClosure*" gs:is-pointer="1" />
          </parameter>
          <parameter name="transform_from" transfer-ownership="none" gs:managed-name="transformFrom" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2529">a #GClosure wrapping the transformation function
    from the @target to the @source, or %NULL to use the default</doc>
            <type name="Closure" c:type="GClosure*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="dup_data" c:identifier="g_object_dup_data" version="2.34" introspectable="1" gs:pinvoke-only="1" gs:dll-name="gobject-2.0" gs:managed-name="DupData">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2744">This is a variant of g_object_get_data() which returns
a 'duplicate' of the value. @dup_func defines the
meaning of 'duplicate' in this context, it could e.g.
take a reference on a ref-counted object.

If the @key is not set on the object then @dup_func
will be called with a %NULL argument.

Note that @dup_func is called while user data of @object
is locked.

This function can be useful to avoid races when multiple
threads are using object data on the same key on the same
object.</doc>
        <source-position filename="gobject.h" line="593" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="2766">the result of calling @dup_func on the value
    associated with @key on @object, or %NULL if not set.
    If @dup_func is %NULL, the value is returned
    unmodified.</doc>
          <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2746">the #GObject to store user data on</doc>
            <type name="Object" c:type="GObject*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2747">a string, naming the user data pointer</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="dup_func" transfer-ownership="none" nullable="1" allow-none="1" closure="2" gs:managed-name="dupFunc" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2748">function to dup the value</doc>
            <type name="GLib.DuplicateFunc" c:type="GDuplicateFunc" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2749">passed as user_data to @dup_func</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2747">a string, naming the user data pointer</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="dup_func" transfer-ownership="none" nullable="1" allow-none="1" closure="2" gs:managed-name="dupFunc" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2748">function to dup the value</doc>
            <type name="GLib.DuplicateFunc" c:type="GDuplicateFunc" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="dup_qdata" c:identifier="g_object_dup_qdata" version="2.34" introspectable="1" gs:pinvoke-only="1" gs:dll-name="gobject-2.0" gs:managed-name="DupQdata">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2774">This is a variant of g_object_get_qdata() which returns
a 'duplicate' of the value. @dup_func defines the
meaning of 'duplicate' in this context, it could e.g.
take a reference on a ref-counted object.

If the @quark is not set on the object then @dup_func
will be called with a %NULL argument.

Note that @dup_func is called while user data of @object
is locked.

This function can be useful to avoid races when multiple
threads are using object data on the same key on the same
object.</doc>
        <source-position filename="gobject.h" line="564" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="2796">the result of calling @dup_func on the value
    associated with @quark on @object, or %NULL if not set.
    If @dup_func is %NULL, the value is returned
    unmodified.</doc>
          <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2776">the #GObject to store user data on</doc>
            <type name="Object" c:type="GObject*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="quark" transfer-ownership="none" gs:managed-name="quark" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2777">a #GQuark, naming the user data pointer</doc>
            <type name="GLib.Quark" c:type="GQuark" />
          </parameter>
          <parameter name="dup_func" transfer-ownership="none" nullable="1" allow-none="1" closure="2" gs:managed-name="dupFunc" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2778">function to dup the value</doc>
            <type name="GLib.DuplicateFunc" c:type="GDuplicateFunc" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2779">passed as user_data to @dup_func</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="quark" transfer-ownership="none" gs:managed-name="quark" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2777">a #GQuark, naming the user data pointer</doc>
            <type name="GLib.Quark" c:type="GQuark" />
          </parameter>
          <parameter name="dup_func" transfer-ownership="none" nullable="1" allow-none="1" closure="2" gs:managed-name="dupFunc" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2778">function to dup the value</doc>
            <type name="GLib.DuplicateFunc" c:type="GDuplicateFunc" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="force_floating" c:identifier="g_object_force_floating" version="2.10" gs:pinvoke-only="1" gs:dll-name="gobject-2.0" gs:managed-name="ForceFloating">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2804">This function is intended for #GObject implementations to re-enforce
a [floating][floating-ref] object reference. Doing this is seldom
required: all #GInitiallyUnowneds are created with a floating reference
which usually just needs to be sunken by calling g_object_ref_sink().</doc>
        <source-position filename="gobject.h" line="634" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2806">a #GObject</doc>
            <type name="Object" c:type="GObject*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="freeze_notify" c:identifier="g_object_freeze_notify" gs:dll-name="gobject-2.0" gs:managed-name="FreezeNotify">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2817">Increases the freeze count on @object. If the freeze count is
non-zero, the emission of "notify" signals on @object is
stopped. The signals are queued until the freeze count is decreased
to zero. Duplicate notifications are squashed so that at most one
#GObject::notify signal is emitted for each property modified while the
object is frozen.

This is necessary for accessors that modify multiple properties to prevent
premature notification while the object is still being modified.</doc>
        <source-position filename="gobject.h" line="484" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2819">a #GObject</doc>
            <type name="Object" c:type="GObject*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="get_data" c:identifier="g_object_get_data" introspectable="1" gs:pinvoke-only="1" gs:dll-name="gobject-2.0" gs:managed-name="GetData">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2869">Gets a named field from the objects table of associations (see g_object_set_data()).</doc>
        <source-position filename="gobject.h" line="577" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="2876">the data if found,
         or %NULL if no such data exists.</doc>
          <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2871">#GObject containing the associations</doc>
            <type name="Object" c:type="GObject*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2872">name of the key for that association</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2872">name of the key for that association</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_property" c:identifier="g_object_get_property" gs:dll-name="gobject-2.0" gs:managed-name="GetProperty">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2881">Gets a property of an object.

The @value can be:

 - an empty #GValue initialized by %G_VALUE_INIT, which will be
   automatically initialized with the expected type of the property
   (since GLib 2.60)
 - a #GValue initialized with the expected type of the property
 - a #GValue initialized with a type to which the expected type
   of the property can be transformed

In general, a copy is made of the property contents and the caller is
responsible for freeing the memory by calling g_value_unset().

Note that g_object_get_property() is really intended for language
bindings, g_object_get() is much more convenient for C programming.</doc>
        <source-position filename="gobject.h" line="480" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2883">a #GObject</doc>
            <type name="Object" c:type="GObject*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="property_name" transfer-ownership="none" gs:managed-name="propertyName" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2884">the name of the property to get</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2885">return location for the property value</doc>
            <type name="Value" c:type="GValue*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="property_name" transfer-ownership="none" gs:managed-name="propertyName" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2884">the name of the property to get</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2885">return location for the property value</doc>
            <type name="Value" c:type="GValue*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_qdata" c:identifier="g_object_get_qdata" introspectable="1" gs:pinvoke-only="1" gs:dll-name="gobject-2.0" gs:managed-name="GetQdata">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2906">This function gets back user data pointers stored via
g_object_set_qdata().</doc>
        <source-position filename="gobject.h" line="548" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="2914">The user data pointer set, or %NULL</doc>
          <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2908">The GObject to get a stored user data pointer from</doc>
            <type name="Object" c:type="GObject*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="quark" transfer-ownership="none" gs:managed-name="quark" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2909">A #GQuark, naming the user data pointer</doc>
            <type name="GLib.Quark" c:type="GQuark" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="quark" transfer-ownership="none" gs:managed-name="quark" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2909">A #GQuark, naming the user data pointer</doc>
            <type name="GLib.Quark" c:type="GQuark" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_properties" c:identifier="g_object_getv" version="2.54" gs:dll-name="gobject-2.0" gs:managed-name="GetProperties">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2935">Gets @n_properties properties for an @object.
Obtained properties will be set to @values. All properties must be valid.
Warnings will be emitted and undefined behaviour may result if invalid
properties are passed in.</doc>
        <source-position filename="gobject.h" line="467" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2937">a #GObject</doc>
            <type name="Object" c:type="GObject*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="n_properties" transfer-ownership="none" gs:managed-name="nProperties" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2938">the number of properties</doc>
            <type name="guint" c:type="guint" />
          </parameter>
          <parameter name="names" transfer-ownership="none" gs:managed-name="names" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2939">the names of each property to get</doc>
            <array length="0" zero-terminated="0" c:type="const gchar**" gs:is-pointer="1">
              <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="values" transfer-ownership="none" gs:managed-name="values" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2940">the values of each property to get</doc>
            <array length="0" zero-terminated="0" c:type="GValue*" gs:is-pointer="1">
              <type name="Value" c:type="GValue" />
            </array>
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="names" transfer-ownership="none" gs:managed-name="names" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2939">the names of each property to get</doc>
            <array length="0" zero-terminated="0" c:type="const gchar**" gs:is-pointer="1">
              <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="values" transfer-ownership="none" gs:managed-name="values" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2940">the values of each property to get</doc>
            <array length="0" zero-terminated="0" c:type="GValue*" gs:is-pointer="1">
              <type name="Value" c:type="GValue" />
            </array>
          </parameter>
        </gs:managed-parameters>
      </method>
      <gs:managed-property name="is_floating" version="2.10" gs:dll-name="gobject-2.0" gs:managed-name="IsFloating">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3018">Checks whether @object has a [floating][floating-ref] reference.</doc>
        <source-position filename="gobject.h" line="494" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3025">%TRUE if @object has a floating reference</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3020">a #GObject</doc>
            <type name="Object" c:type="gpointer" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="is_floating" c:identifier="g_object_is_floating" version="2.10" gs:dll-name="gobject-2.0" gs:managed-name="GetIsFloating" gs:property-getter-for="IsFloating" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3018">Checks whether @object has a [floating][floating-ref] reference.</doc>
        <source-position filename="gobject.h" line="494" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3025">%TRUE if @object has a floating reference</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3020">a #GObject</doc>
            <type name="Object" c:type="gpointer" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="notify" c:identifier="g_object_notify" gs:dll-name="gobject-2.0" gs:managed-name="Notify">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3116">Emits a "notify" signal for the property @property_name on @object.

When possible, eg. when signaling a property change from within the class
that registered the property, you should use g_object_notify_by_pspec()
instead.

Note that emission of the notify signal may be blocked with
g_object_freeze_notify(). In this case, the signal emissions are queued
and will be emitted (in reverse order) when g_object_thaw_notify() is
called.</doc>
        <source-position filename="gobject.h" line="486" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3118">a #GObject</doc>
            <type name="Object" c:type="GObject*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="property_name" transfer-ownership="none" gs:managed-name="propertyName" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3119">the name of a property installed on the class of @object.</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="property_name" transfer-ownership="none" gs:managed-name="propertyName" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3119">the name of a property installed on the class of @object.</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="notify" c:identifier="g_object_notify_by_pspec" version="2.26" gs:dll-name="gobject-2.0" gs:managed-name="Notify">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3134">Emits a "notify" signal for the property specified by @pspec on @object.

This function omits the property name lookup, hence it is faster than
g_object_notify().

One way to avoid using g_object_notify() from within the
class that registered the properties, and using g_object_notify_by_pspec()
instead, is to store the GParamSpec used with
g_object_class_install_property() inside a static array, e.g.:

|[&lt;!-- language="C" --&gt;
  enum
  {
    PROP_0,
    PROP_FOO,
    PROP_LAST
  };

  static GParamSpec *properties[PROP_LAST];

  static void
  my_object_class_init (MyObjectClass *klass)
  {
    properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
                                             0, 100,
                                             50,
                                             G_PARAM_READWRITE);
    g_object_class_install_property (gobject_class,
                                     PROP_FOO,
                                     properties[PROP_FOO]);
  }
]|

and then notify a change on the "foo" property with:

|[&lt;!-- language="C" --&gt;
  g_object_notify_by_pspec (self, properties[PROP_FOO]);
]|</doc>
        <source-position filename="gobject.h" line="489" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3136">a #GObject</doc>
            <type name="Object" c:type="GObject*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3137">the #GParamSpec of a property installed on the class of @object.</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3137">the #GParamSpec of a property installed on the class of @object.</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="ref" c:identifier="g_object_ref" gs:dll-name="gobject-2.0" gs:managed-name="Ref" gs:special-func="ref" gs:pinvoke-only="1">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3182">Increases the reference count of @object.

Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
of @object will be propagated to the return type (using the GCC typeof()
extension), so any casting the caller needs to do on the return type must be
explicit.</doc>
        <source-position filename="gobject.h" line="498" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3193">the same @object</doc>
          <type name="Object" c:type="gpointer" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3184">a #GObject</doc>
            <type name="Object" c:type="gpointer" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="ref_sink" c:identifier="g_object_ref_sink" version="2.10" gs:pinvoke-only="1" gs:dll-name="gobject-2.0" gs:managed-name="RefSink">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3197">Increase the reference count of @object, and possibly remove the
[floating][floating-ref] reference, if @object has a floating reference.

In other words, if the object is floating, then this call "assumes
ownership" of the floating reference, converting it to a normal
reference by clearing the floating flag while leaving the reference
count unchanged.  If the object is not floating, then this call
adds a new normal reference increasing the reference count by one.

Since GLib 2.56, the type of @object will be propagated to the return type
under the same conditions as for g_object_ref().</doc>
        <source-position filename="gobject.h" line="496" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3214">@object</doc>
          <type name="Object" c:type="gpointer" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3199">a #GObject</doc>
            <type name="Object" c:type="gpointer" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="remove_toggle_ref" c:identifier="g_object_remove_toggle_ref" version="2.8" introspectable="1" gs:pinvoke-only="1" gs:dll-name="gobject-2.0" gs:managed-name="RemoveToggleRef">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3218">Removes a reference added with g_object_add_toggle_ref(). The
reference count of the object is decreased by one.</doc>
        <source-position filename="gobject.h" line="543" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3220">a #GObject</doc>
            <type name="Object" c:type="GObject*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="notify" transfer-ownership="none" closure="1" gs:managed-name="notify" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3221">a function to call when this reference is the
 last reference to the object, or is no longer
 the last reference.</doc>
            <type name="ToggleNotify" c:type="GToggleNotify" />
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3224">data to pass to @notify</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="notify" transfer-ownership="none" closure="1" gs:managed-name="notify" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3221">a function to call when this reference is the
 last reference to the object, or is no longer
 the last reference.</doc>
            <type name="ToggleNotify" c:type="GToggleNotify" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="replace_data" c:identifier="g_object_replace_data" version="2.34" introspectable="1" gs:pinvoke-only="1" gs:dll-name="gobject-2.0" gs:managed-name="TryReplaceData">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3245">Compares the user data for the key @key on @object with
@oldval, and if they are the same, replaces @oldval with
@newval.

This is like a typical atomic compare-and-exchange
operation, for user data on an object.

If the previous value was replaced then ownership of the
old value (@oldval) is passed to the caller, including
the registered destroy notify for it (passed out in @old_destroy).
It’s up to the caller to free this as needed, which may
or may not include using @old_destroy as sometimes replacement
should not destroy the object in the normal way.

See g_object_set_data() for guidance on using a small, bounded set of values
for @key.</doc>
        <source-position filename="gobject.h" line="598" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3271">%TRUE if the existing value for @key was replaced
 by @newval, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3247">the #GObject to store user data on</doc>
            <type name="Object" c:type="GObject*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3248">a string, naming the user data pointer</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="oldval" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="oldval" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3249">the old value to compare against</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="newval" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="newval" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3250">the new value</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="destroy" transfer-ownership="none" nullable="1" allow-none="1" scope="async" gs:managed-name="destroy" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3251">a destroy notify for the new value</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify" />
          </parameter>
          <parameter name="old_destroy" direction="out" caller-allocates="0" transfer-ownership="none" optional="1" allow-none="1" scope="async" gs:managed-name="oldDestroy">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3252">destroy notify for the existing value</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify*" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3248">a string, naming the user data pointer</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="oldval" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="oldval" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3249">the old value to compare against</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="newval" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="newval" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3250">the new value</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="destroy" transfer-ownership="none" nullable="1" allow-none="1" scope="async" gs:managed-name="destroy" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3251">a destroy notify for the new value</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify" />
          </parameter>
          <parameter name="old_destroy" direction="out" caller-allocates="0" transfer-ownership="none" optional="1" allow-none="1" scope="async" gs:managed-name="oldDestroy">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3252">destroy notify for the existing value</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify*" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="replace_qdata" c:identifier="g_object_replace_qdata" version="2.34" introspectable="1" gs:pinvoke-only="1" gs:dll-name="gobject-2.0" gs:managed-name="TryReplaceQdata">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3277">Compares the user data for the key @quark on @object with
@oldval, and if they are the same, replaces @oldval with
@newval.

This is like a typical atomic compare-and-exchange
operation, for user data on an object.

If the previous value was replaced then ownership of the
old value (@oldval) is passed to the caller, including
the registered destroy notify for it (passed out in @old_destroy).
It’s up to the caller to free this as needed, which may
or may not include using @old_destroy as sometimes replacement
should not destroy the object in the normal way.</doc>
        <source-position filename="gobject.h" line="569" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3300">%TRUE if the existing value for @quark was replaced
 by @newval, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3279">the #GObject to store user data on</doc>
            <type name="Object" c:type="GObject*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="quark" transfer-ownership="none" gs:managed-name="quark" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3280">a #GQuark, naming the user data pointer</doc>
            <type name="GLib.Quark" c:type="GQuark" />
          </parameter>
          <parameter name="oldval" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="oldval" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3281">the old value to compare against</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="newval" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="newval" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3282">the new value</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="destroy" transfer-ownership="none" nullable="1" allow-none="1" scope="async" gs:managed-name="destroy" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3283">a destroy notify for the new value</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify" />
          </parameter>
          <parameter name="old_destroy" direction="out" caller-allocates="0" transfer-ownership="none" optional="1" allow-none="1" scope="async" gs:managed-name="oldDestroy">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3284">destroy notify for the existing value</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify*" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="quark" transfer-ownership="none" gs:managed-name="quark" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3280">a #GQuark, naming the user data pointer</doc>
            <type name="GLib.Quark" c:type="GQuark" />
          </parameter>
          <parameter name="oldval" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="oldval" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3281">the old value to compare against</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="newval" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="newval" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3282">the new value</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="destroy" transfer-ownership="none" nullable="1" allow-none="1" scope="async" gs:managed-name="destroy" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3283">a destroy notify for the new value</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify" />
          </parameter>
          <parameter name="old_destroy" direction="out" caller-allocates="0" transfer-ownership="none" optional="1" allow-none="1" scope="async" gs:managed-name="oldDestroy">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3284">destroy notify for the existing value</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify*" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="run_dispose" c:identifier="g_object_run_dispose" gs:dll-name="gobject-2.0" gs:managed-name="RunDispose">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3306">Releases all references to other objects. This can be used to break
reference cycles.

This function should only be called from object system implementations.</doc>
        <source-position filename="gobject.h" line="636" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3308">a #GObject</doc>
            <type name="Object" c:type="GObject*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="set_data" c:identifier="g_object_set_data" introspectable="1" gs:pinvoke-only="1" gs:dll-name="gobject-2.0" gs:managed-name="SetData">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3337">Each object carries around a table of associations from
strings to pointers.  This function lets you set an association.

If the object already had an association with that name,
the old association will be destroyed.

Internally, the @key is converted to a #GQuark using g_quark_from_string().
This means a copy of @key is kept permanently (even after @object has been
finalized) — so it is recommended to only use a small, bounded set of values
for @key in your program, to avoid the #GQuark storage growing unbounded.</doc>
        <source-position filename="gobject.h" line="580" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3339">#GObject containing the associations.</doc>
            <type name="Object" c:type="GObject*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3340">name of the key</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3341">data to associate with that key</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3340">name of the key</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3341">data to associate with that key</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_data_full" c:identifier="g_object_set_data_full" introspectable="1" gs:pinvoke-only="1" gs:dll-name="gobject-2.0" gs:managed-name="SetDataFull">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3356">Like g_object_set_data() except it adds notification
for when the association is destroyed, either by setting it
to a different value or when the object is destroyed.

Note that the @destroy callback is not called if @data is %NULL.</doc>
        <source-position filename="gobject.h" line="584" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3358">#GObject containing the associations</doc>
            <type name="Object" c:type="GObject*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3359">name of the key</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3360">data to associate with that key</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="destroy" transfer-ownership="none" nullable="1" allow-none="1" scope="async" gs:managed-name="destroy" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3361">function to call when the association is destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3359">name of the key</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3360">data to associate with that key</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="destroy" transfer-ownership="none" nullable="1" allow-none="1" scope="async" gs:managed-name="destroy" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3361">function to call when the association is destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_property" c:identifier="g_object_set_property" gs:dll-name="gobject-2.0" gs:managed-name="SetProperty">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3371">Sets a property on an object.</doc>
        <source-position filename="gobject.h" line="476" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3373">a #GObject</doc>
            <type name="Object" c:type="GObject*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="property_name" transfer-ownership="none" gs:managed-name="propertyName" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3374">the name of the property to set</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3375">the value</doc>
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="property_name" transfer-ownership="none" gs:managed-name="propertyName" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3374">the name of the property to set</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3375">the value</doc>
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_qdata" c:identifier="g_object_set_qdata" introspectable="1" gs:pinvoke-only="1" gs:dll-name="gobject-2.0" gs:managed-name="SetQdata">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3381">This sets an opaque, named pointer on an object.
The name is specified through a #GQuark (retrieved e.g. via
g_quark_from_static_string()), and the pointer
can be gotten back from the @object with g_object_get_qdata()
until the @object is finalized.
Setting a previously set user data pointer, overrides (frees)
the old pointer set, using #NULL as pointer essentially
removes the data stored.</doc>
        <source-position filename="gobject.h" line="551" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3383">The GObject to set store a user data pointer</doc>
            <type name="Object" c:type="GObject*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="quark" transfer-ownership="none" gs:managed-name="quark" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3384">A #GQuark, naming the user data pointer</doc>
            <type name="GLib.Quark" c:type="GQuark" />
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3385">An opaque user data pointer</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="quark" transfer-ownership="none" gs:managed-name="quark" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3384">A #GQuark, naming the user data pointer</doc>
            <type name="GLib.Quark" c:type="GQuark" />
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3385">An opaque user data pointer</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_qdata_full" c:identifier="g_object_set_qdata_full" introspectable="1" gs:pinvoke-only="1" gs:dll-name="gobject-2.0" gs:managed-name="SetQdataFull">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3398">This function works like g_object_set_qdata(), but in addition,
a void (*destroy) (gpointer) function may be specified which is
called with @data as argument when the @object is finalized, or
the data is being overwritten by a call to g_object_set_qdata()
with the same @quark.</doc>
        <source-position filename="gobject.h" line="555" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3400">The GObject to set store a user data pointer</doc>
            <type name="Object" c:type="GObject*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="quark" transfer-ownership="none" gs:managed-name="quark" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3401">A #GQuark, naming the user data pointer</doc>
            <type name="GLib.Quark" c:type="GQuark" />
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3402">An opaque user data pointer</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="destroy" transfer-ownership="none" nullable="1" allow-none="1" scope="async" gs:managed-name="destroy" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3403">Function to invoke with @data as argument, when @data
          needs to be freed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="quark" transfer-ownership="none" gs:managed-name="quark" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3401">A #GQuark, naming the user data pointer</doc>
            <type name="GLib.Quark" c:type="GQuark" />
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3402">An opaque user data pointer</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="destroy" transfer-ownership="none" nullable="1" allow-none="1" scope="async" gs:managed-name="destroy" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3403">Function to invoke with @data as argument, when @data
          needs to be freed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="steal_data" c:identifier="g_object_steal_data" gs:pinvoke-only="1" introspectable="1" gs:dll-name="gobject-2.0" gs:managed-name="StealData">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3441">Remove a specified datum from the object's data associations,
without invoking the association's destroy handler.</doc>
        <source-position filename="gobject.h" line="589" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3449">the data if found, or %NULL
         if no such data exists.</doc>
          <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3443">#GObject containing the associations</doc>
            <type name="Object" c:type="GObject*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3444">name of the key</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3444">name of the key</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="steal_qdata" c:identifier="g_object_steal_qdata" gs:pinvoke-only="1" introspectable="1" gs:dll-name="gobject-2.0" gs:managed-name="StealQdata">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3454">This function gets back user data pointers stored via
g_object_set_qdata() and removes the @data from object
without invoking its destroy() function (if any was
set).
Usually, calling this function is only required to update
user data pointers with a destroy notifier, for example:
|[&lt;!-- language="C" --&gt;
void
object_add_to_user_list (GObject     *object,
                         const gchar *new_string)
{
  // the quark, naming the object data
  GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
  // retrieve the old string list
  GList *list = g_object_steal_qdata (object, quark_string_list);

  // prepend new string
  list = g_list_prepend (list, g_strdup (new_string));
  // this changed 'list', so we need to set it again
  g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
}
static void
free_string_list (gpointer data)
{
  GList *node, *list = data;

  for (node = list; node; node = node-&gt;next)
    g_free (node-&gt;data);
  g_list_free (list);
}
]|
Using g_object_get_qdata() in the above example, instead of
g_object_steal_qdata() would have left the destroy function set,
and thus the partial string list would have been freed upon
g_object_set_qdata_full().</doc>
        <source-position filename="gobject.h" line="560" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3495">The user data pointer set, or %NULL</doc>
          <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3456">The GObject to get a stored user data pointer from</doc>
            <type name="Object" c:type="GObject*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="quark" transfer-ownership="none" gs:managed-name="quark" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3457">A #GQuark, naming the user data pointer</doc>
            <type name="GLib.Quark" c:type="GQuark" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="quark" transfer-ownership="none" gs:managed-name="quark" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3457">A #GQuark, naming the user data pointer</doc>
            <type name="GLib.Quark" c:type="GQuark" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="thaw_notify" c:identifier="g_object_thaw_notify" gs:dll-name="gobject-2.0" gs:managed-name="ThawNotify">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3499">Reverts the effect of a previous call to
g_object_freeze_notify(). The freeze count is decreased on @object
and when it reaches zero, queued "notify" signals are emitted.

Duplicate notifications for each property are squashed so that at most one
#GObject::notify signal is emitted for each property, in the reverse order
in which they have been queued.

It is an error to call this function when the freeze count is zero.</doc>
        <source-position filename="gobject.h" line="492" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3501">a #GObject</doc>
            <type name="Object" c:type="GObject*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="unref" c:identifier="g_object_unref" gs:dll-name="gobject-2.0" gs:managed-name="Unref" gs:special-func="unref" gs:pinvoke-only="1">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3515">Decreases the reference count of @object. When its reference count
drops to 0, the object is finalized (i.e. its memory is freed).

If the pointer to the #GObject may be reused in future (for example, if it is
an instance variable of another object), it is recommended to clear the
pointer to %NULL rather than retain a dangling pointer to a potentially
invalid #GObject instance. Use g_clear_object() for this.</doc>
        <source-position filename="gobject.h" line="500" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3517">a #GObject</doc>
            <type name="Object" c:type="gpointer" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="watch_closure" c:identifier="g_object_watch_closure" gs:dll-name="gobject-2.0" gs:managed-name="WatchClosure">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3529">This function essentially limits the life time of the @closure to
the life time of the object. That is, when the object is finalized,
the @closure is invalidated by calling g_closure_invalidate() on
it, in order to prevent invocations of the closure with a finalized
(nonexisting) object. Also, g_object_ref() and g_object_unref() are
added as marshal guards to the @closure, to ensure that an extra
reference count is held on @object during invocation of the
@closure.  Usually, this function will be called on closures that
use this @object as closure data.</doc>
        <source-position filename="gobject.h" line="607" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3531">#GObject restricting lifetime of @closure</doc>
            <type name="Object" c:type="GObject*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="closure" transfer-ownership="none" gs:managed-name="closure" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3532">#GClosure to watch</doc>
            <type name="Closure" c:type="GClosure*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="closure" transfer-ownership="none" gs:managed-name="closure" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3532">#GClosure to watch</doc>
            <type name="Closure" c:type="GClosure*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <field name="g_type_instance" gs:managed-name="GTypeInstance">
        <type name="TypeInstance" c:type="GTypeInstance" />
      </field>
      <field name="ref_count" readable="0" private="1" gs:managed-name="RefCount">
        <type name="guint" c:type="volatile guint" />
      </field>
      <field name="qdata" readable="0" private="1" gs:managed-name="Qdata">
        <type name="GLib.Data" c:type="GData*" gs:is-pointer="1" />
      </field>
      <glib:signal name="notify" when="first" no-recurse="1" detailed="1" action="1" no-hooks="1" gs:dll-name="gobject-2.0" gs:managed-name="NotifySignal">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="58">The notify signal is emitted on an object when one of its properties has
its value set through g_object_set_property(), g_object_set(), et al.

Note that getting this signal doesn’t itself guarantee that the value of
the property has actually changed. When it is emitted is determined by the
derived GObject class. If the implementor did not create the property with
%G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
in ::notify being emitted, even if the new value is the same as the old.
If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
and common practice is to do that only when the value has actually changed.

This signal is typically used to obtain change notification for a
single property, by specifying the property name as a detail in the
g_signal_connect() call, like this:
|[&lt;!-- language="C" --&gt;
g_signal_connect (text_view-&gt;buffer, "notify::paste-target-list",
                  G_CALLBACK (gtk_text_view_target_list_notify),
                  text_view)
]|
It is important to note that you must use
[canonical parameter names][canonical-parameter-names] as
detail strings for the notify signal.</doc>
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc>the instance on which the signal was invoked</doc>
            <type name="Object" c:name="gpointer" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="61">the #GParamSpec of the property which changed.</doc>
            <type name="ParamSpec" gs:is-pointer="1" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="1" gs:managed-name="userData" direction="in">
            <type name="gpointer" c:name="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc>the instance on which the signal was invoked</doc>
            <type name="Object" c:name="gpointer" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="61">the #GParamSpec of the property which changed.</doc>
            <type name="ParamSpec" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </glib:signal>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_object_get_type" gs:access-modifiers="private" gs:dll-name="gobject-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </class>
    <record name="ObjectClass" c:type="GObjectClass" glib:is-gtype-struct-for="Object" gs:managed-name="ObjectClass">
      <doc xml:space="preserve" filename="gobject.h" line="253">The class structure for the GObject type.

|[&lt;!-- language="C" --&gt;
// Example of implementing a singleton using a constructor.
static MySingleton *the_singleton = NULL;

static GObject*
my_singleton_constructor (GType                  type,
                          guint                  n_construct_params,
                          GObjectConstructParam *construct_params)
{
  GObject *object;
  
  if (!the_singleton)
    {
      object = G_OBJECT_CLASS (parent_class)-&gt;constructor (type,
                                                           n_construct_params,
                                                           construct_params);
      the_singleton = MY_SINGLETON (object);
    }
  else
    object = g_object_ref (G_OBJECT (the_singleton));

  return object;
}
]|</doc>
      <source-position filename="gobject.h" line="354" />
      <field name="g_type_class" gs:managed-name="GTypeClass">
        <doc xml:space="preserve" filename="gobject.h" line="255">the parent class</doc>
        <type name="TypeClass" c:type="GTypeClass" />
      </field>
      <field name="construct_properties" readable="0" private="1" gs:managed-name="ConstructProperties">
        <type name="GLib.SList" c:type="GSList*" gs:is-pointer="1">
          <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
        </type>
      </field>
      <field name="constructor" introspectable="1" gs:managed-name="Constructor">
        <callback name="constructor" introspectable="1" gs:dll-name="gobject-2.0" gs:managed-name="Constructor">
          <source-position filename="gobject.h" line="324" />
          <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
            <type name="Object" c:type="GObject*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
              <type name="GType" c:type="GType" />
            </parameter>
            <parameter name="n_construct_properties" transfer-ownership="none" gs:managed-name="nConstructProperties" direction="in">
              <type name="guint" c:type="guint" />
            </parameter>
            <parameter name="construct_properties" transfer-ownership="none" gs:managed-name="constructProperties" direction="in">
              <type name="ObjectConstructParam" c:type="GObjectConstructParam*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
              <type name="GType" c:type="GType" />
            </parameter>
            <parameter name="n_construct_properties" transfer-ownership="none" gs:managed-name="nConstructProperties" direction="in">
              <type name="guint" c:type="guint" />
            </parameter>
            <parameter name="construct_properties" transfer-ownership="none" gs:managed-name="constructProperties" direction="in">
              <type name="ObjectConstructParam" c:type="GObjectConstructParam*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="set_property" gs:managed-name="SetProperty">
        <callback name="set_property" gs:dll-name="gobject-2.0" gs:managed-name="SetProperty">
          <source-position filename="gobject.h" line="328" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
              <type name="Object" c:type="GObject*" gs:is-pointer="1" />
            </parameter>
            <parameter name="property_id" transfer-ownership="none" gs:managed-name="propertyId" direction="in">
              <type name="guint" c:type="guint" />
            </parameter>
            <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
              <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
            </parameter>
            <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
              <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
              <type name="Object" c:type="GObject*" gs:is-pointer="1" />
            </parameter>
            <parameter name="property_id" transfer-ownership="none" gs:managed-name="propertyId" direction="in">
              <type name="guint" c:type="guint" />
            </parameter>
            <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
              <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
            </parameter>
            <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
              <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="get_property" gs:managed-name="GetProperty">
        <callback name="get_property" gs:dll-name="gobject-2.0" gs:managed-name="GetProperty">
          <source-position filename="gobject.h" line="332" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
              <type name="Object" c:type="GObject*" gs:is-pointer="1" />
            </parameter>
            <parameter name="property_id" transfer-ownership="none" gs:managed-name="propertyId" direction="in">
              <type name="guint" c:type="guint" />
            </parameter>
            <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
              <type name="Value" c:type="GValue*" gs:is-pointer="1" />
            </parameter>
            <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
              <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
              <type name="Object" c:type="GObject*" gs:is-pointer="1" />
            </parameter>
            <parameter name="property_id" transfer-ownership="none" gs:managed-name="propertyId" direction="in">
              <type name="guint" c:type="guint" />
            </parameter>
            <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
              <type name="Value" c:type="GValue*" gs:is-pointer="1" />
            </parameter>
            <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
              <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="dispose" gs:managed-name="Dispose">
        <callback name="dispose" gs:dll-name="gobject-2.0" gs:managed-name="Dispose">
          <source-position filename="gobject.h" line="336" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
              <type name="Object" c:type="GObject*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
              <type name="Object" c:type="GObject*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="finalize" gs:managed-name="Finalize">
        <callback name="finalize" gs:dll-name="gobject-2.0" gs:managed-name="Finalize">
          <source-position filename="gobject.h" line="337" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
              <type name="Object" c:type="GObject*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
              <type name="Object" c:type="GObject*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="dispatch_properties_changed" gs:managed-name="DispatchPropertiesChanged">
        <callback name="dispatch_properties_changed" gs:dll-name="gobject-2.0" gs:managed-name="DispatchPropertiesChanged">
          <source-position filename="gobject.h" line="339" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
              <type name="Object" c:type="GObject*" gs:is-pointer="1" />
            </parameter>
            <parameter name="n_pspecs" transfer-ownership="none" gs:managed-name="nPspecs" direction="in">
              <type name="guint" c:type="guint" />
            </parameter>
            <parameter name="pspecs" transfer-ownership="none" gs:managed-name="pspecs" direction="in">
              <type name="ParamSpec" c:type="GParamSpec**" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
              <type name="Object" c:type="GObject*" gs:is-pointer="1" />
            </parameter>
            <parameter name="n_pspecs" transfer-ownership="none" gs:managed-name="nPspecs" direction="in">
              <type name="guint" c:type="guint" />
            </parameter>
            <parameter name="pspecs" transfer-ownership="none" gs:managed-name="pspecs" direction="in">
              <type name="ParamSpec" c:type="GParamSpec**" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="notify" gs:managed-name="Notify">
        <callback name="notify" gs:dll-name="gobject-2.0" gs:managed-name="Notify">
          <source-position filename="gobject.h" line="343" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
              <doc xml:space="preserve" filename="gobject-2.0.c" line="3118">a #GObject</doc>
              <type name="Object" c:type="GObject*" gs:is-pointer="1" />
            </parameter>
            <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
              <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
              <doc xml:space="preserve" filename="gobject-2.0.c" line="3118">a #GObject</doc>
              <type name="Object" c:type="GObject*" gs:is-pointer="1" />
            </parameter>
            <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
              <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="constructed" gs:managed-name="Constructed">
        <callback name="constructed" gs:dll-name="gobject-2.0" gs:managed-name="Constructed">
          <source-position filename="gobject.h" line="347" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
              <type name="Object" c:type="GObject*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
              <type name="Object" c:type="GObject*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="flags" readable="0" private="1" gs:managed-name="Flags">
        <type name="gsize" c:type="gsize" />
      </field>
      <field name="pdummy0" readable="0" private="1" gs:managed-name="Pdummy0">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="pdummy1" readable="0" private="1" gs:managed-name="Pdummy1">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="pdummy2" readable="0" private="1" gs:managed-name="Pdummy2">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="pdummy3" readable="0" private="1" gs:managed-name="Pdummy3">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="pdummy4" readable="0" private="1" gs:managed-name="Pdummy4">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="pdummy5" readable="0" private="1" gs:managed-name="Pdummy5">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <method name="find_property" c:identifier="g_object_class_find_property" gs:dll-name="gobject-2.0" gs:managed-name="FindProperty">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2547">Looks up the #GParamSpec for a property of a class.</doc>
        <source-position filename="gobject.h" line="392" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="2554">the #GParamSpec for the property, or
         %NULL if the class doesn't have a property of that name</doc>
          <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="oclass" transfer-ownership="none" gs:managed-name="oclass" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2549">a #GObjectClass</doc>
            <type name="ObjectClass" c:type="GObjectClass*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="property_name" transfer-ownership="none" gs:managed-name="propertyName" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2550">the name of the property to look up</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="property_name" transfer-ownership="none" gs:managed-name="propertyName" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2550">the name of the property to look up</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="install_properties" c:identifier="g_object_class_install_properties" version="2.26" gs:dll-name="gobject-2.0" gs:managed-name="InstallProperties">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2559">Installs new properties from an array of #GParamSpecs.

All properties should be installed during the class initializer.  It
is possible to install properties after that, but doing so is not
recommend, and specifically, is not guaranteed to be thread-safe vs.
use of properties on the same type on other threads.

The property id of each property is the index of each #GParamSpec in
the @pspecs array.

The property id of 0 is treated specially by #GObject and it should not
be used to store a #GParamSpec.

This function should be used if you plan to use a static array of
#GParamSpecs and g_object_notify_by_pspec(). For instance, this
class initialization:

|[&lt;!-- language="C" --&gt;
enum {
  PROP_0, PROP_FOO, PROP_BAR, N_PROPERTIES
};

static GParamSpec *obj_properties[N_PROPERTIES] = { NULL, };

static void
my_object_class_init (MyObjectClass *klass)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);

  obj_properties[PROP_FOO] =
    g_param_spec_int ("foo", "Foo", "Foo",
                      -1, G_MAXINT,
                      0,
                      G_PARAM_READWRITE);

  obj_properties[PROP_BAR] =
    g_param_spec_string ("bar", "Bar", "Bar",
                         NULL,
                         G_PARAM_READWRITE);

  gobject_class-&gt;set_property = my_object_set_property;
  gobject_class-&gt;get_property = my_object_get_property;
  g_object_class_install_properties (gobject_class,
                                     N_PROPERTIES,
                                     obj_properties);
}
]|

allows calling g_object_notify_by_pspec() to notify of property changes:

|[&lt;!-- language="C" --&gt;
void
my_object_set_foo (MyObject *self, gint foo)
{
  if (self-&gt;foo != foo)
    {
      self-&gt;foo = foo;
      g_object_notify_by_pspec (G_OBJECT (self), obj_properties[PROP_FOO]);
    }
 }
]|</doc>
        <source-position filename="gobject.h" line="402" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="oclass" transfer-ownership="none" gs:managed-name="oclass" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2561">a #GObjectClass</doc>
            <type name="ObjectClass" c:type="GObjectClass*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="n_pspecs" transfer-ownership="none" gs:managed-name="nPspecs" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2562">the length of the #GParamSpecs array</doc>
            <type name="guint" c:type="guint" />
          </parameter>
          <parameter name="pspecs" transfer-ownership="none" gs:managed-name="pspecs" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2563">the #GParamSpecs array
  defining the new properties</doc>
            <array length="0" zero-terminated="0" c:type="GParamSpec**" gs:is-pointer="1">
              <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
            </array>
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="pspecs" transfer-ownership="none" gs:managed-name="pspecs" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2563">the #GParamSpecs array
  defining the new properties</doc>
            <array length="0" zero-terminated="0" c:type="GParamSpec**" gs:is-pointer="1">
              <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
            </array>
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="install_property" c:identifier="g_object_class_install_property" gs:dll-name="gobject-2.0" gs:managed-name="InstallProperty">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2632">Installs a new property.

All properties should be installed during the class initializer.  It
is possible to install properties after that, but doing so is not
recommend, and specifically, is not guaranteed to be thread-safe vs.
use of properties on the same type on other threads.

Note that it is possible to redefine a property in a derived class,
by installing a property with the same name. This can be useful at times,
e.g. to change the range of allowed values or the default value.</doc>
        <source-position filename="gobject.h" line="388" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="oclass" transfer-ownership="none" gs:managed-name="oclass" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2634">a #GObjectClass</doc>
            <type name="ObjectClass" c:type="GObjectClass*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="property_id" transfer-ownership="none" gs:managed-name="propertyId" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2635">the id for the new property</doc>
            <type name="guint" c:type="guint" />
          </parameter>
          <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2636">the #GParamSpec for the new property</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="property_id" transfer-ownership="none" gs:managed-name="propertyId" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2635">the id for the new property</doc>
            <type name="guint" c:type="guint" />
          </parameter>
          <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2636">the #GParamSpec for the new property</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="list_properties" c:identifier="g_object_class_list_properties" gs:dll-name="gobject-2.0" gs:managed-name="ListProperties">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2651">Get an array of #GParamSpec* for all properties of a class.</doc>
        <source-position filename="gobject.h" line="395" />
        <return-value transfer-ownership="container" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="2658">an array of
         #GParamSpec* which should be freed after use</doc>
          <array length="0" zero-terminated="0" c:type="GParamSpec**" gs:is-pointer="1">
            <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="oclass" transfer-ownership="none" gs:managed-name="oclass" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2653">a #GObjectClass</doc>
            <type name="ObjectClass" c:type="GObjectClass*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="n_properties" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="nProperties">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2654">return location for the length of the returned array</doc>
            <type name="guint" c:type="guint*" />
          </parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="override_property" c:identifier="g_object_class_override_property" version="2.4" gs:dll-name="gobject-2.0" gs:managed-name="OverrideProperty">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2663">Registers @property_id as referring to a property with the name
@name in a parent class or in an interface implemented by @oclass.
This allows this class to "override" a property implementation in
a parent class or to provide the implementation of a property from
an interface.

Internally, overriding is implemented by creating a property of type
#GParamSpecOverride; generally operations that query the properties of
the object class, such as g_object_class_find_property() or
g_object_class_list_properties() will return the overridden
property. However, in one case, the @construct_properties argument of
the @constructor virtual function, the #GParamSpecOverride is passed
instead, so that the @param_id field of the #GParamSpec will be
correct.  For virtually all uses, this makes no difference. If you
need to get the overridden property, you can call
g_param_spec_get_redirect_target().</doc>
        <source-position filename="gobject.h" line="398" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="oclass" transfer-ownership="none" gs:managed-name="oclass" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2665">a #GObjectClass</doc>
            <type name="ObjectClass" c:type="GObjectClass*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="property_id" transfer-ownership="none" gs:managed-name="propertyId" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2666">the new property ID</doc>
            <type name="guint" c:type="guint" />
          </parameter>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2667">the name of a property registered in a parent class or
 in an interface of this class.</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="property_id" transfer-ownership="none" gs:managed-name="propertyId" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2666">the new property ID</doc>
            <type name="guint" c:type="guint" />
          </parameter>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2667">the name of a property registered in a parent class or
 in an interface of this class.</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
    </record>
    <record name="ObjectConstructParam" c:type="GObjectConstructParam" gs:managed-name="ObjectConstructParam">
      <doc xml:space="preserve" filename="gobject.h" line="355">The GObjectConstructParam struct is an auxiliary
structure used to hand #GParamSpec/#GValue pairs to the @constructor of
a #GObjectClass.</doc>
      <source-position filename="gobject.h" line="368" />
      <field name="pspec" writable="1" gs:managed-name="Pspec">
        <doc xml:space="preserve" filename="gobject.h" line="357">the #GParamSpec of the construct parameter</doc>
        <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
      </field>
      <field name="value" writable="1" gs:managed-name="Value">
        <doc xml:space="preserve" filename="gobject.h" line="358">the value to set the parameter to</doc>
        <type name="Value" c:type="GValue*" gs:is-pointer="1" />
      </field>
    </record>
    <bitfield name="ParamFlags" c:type="GParamFlags" gs:managed-name="ParamFlags">
      <doc xml:space="preserve" filename="gparam.h" line="116">Through the #GParamFlags flag values, certain aspects of parameters
can be configured. See also #G_PARAM_STATIC_STRINGS.</doc>
      <source-position filename="gparam.h" line="166" />
      <member name="readable" value="1" c:identifier="G_PARAM_READABLE" gs:managed-name="Readable">
        <doc xml:space="preserve" filename="gparam.h" line="118">the parameter is readable</doc>
      </member>
      <member name="writable" value="2" c:identifier="G_PARAM_WRITABLE" gs:managed-name="Writable">
        <doc xml:space="preserve" filename="gparam.h" line="119">the parameter is writable</doc>
      </member>
      <member name="readwrite" value="3" c:identifier="G_PARAM_READWRITE" gs:managed-name="Readwrite">
        <doc xml:space="preserve" filename="gparam.h" line="120">alias for %G_PARAM_READABLE | %G_PARAM_WRITABLE</doc>
      </member>
      <member name="construct" value="4" c:identifier="G_PARAM_CONSTRUCT" gs:managed-name="Construct">
        <doc xml:space="preserve" filename="gparam.h" line="121">the parameter will be set upon object construction</doc>
      </member>
      <member name="construct_only" value="8" c:identifier="G_PARAM_CONSTRUCT_ONLY" gs:managed-name="ConstructOnly">
        <doc xml:space="preserve" filename="gparam.h" line="122">the parameter can only be set upon object construction</doc>
      </member>
      <member name="lax_validation" value="16" c:identifier="G_PARAM_LAX_VALIDATION" gs:managed-name="LaxValidation">
        <doc xml:space="preserve" filename="gparam.h" line="123">upon parameter conversion (see g_param_value_convert())
 strict validation is not required</doc>
      </member>
      <member name="static_name" value="32" c:identifier="G_PARAM_STATIC_NAME" version="2.8" gs:managed-name="StaticName">
        <doc xml:space="preserve" filename="gparam.h" line="125">the string used as name when constructing the
 parameter is guaranteed to remain valid and
 unmodified for the lifetime of the parameter.</doc>
      </member>
      <member name="private" value="32" c:identifier="G_PARAM_PRIVATE" gs:managed-name="Private">
        <doc xml:space="preserve" filename="gparam.h" line="141">internal</doc>
      </member>
      <member name="static_nick" value="64" c:identifier="G_PARAM_STATIC_NICK" version="2.8" gs:managed-name="StaticNick">
        <doc xml:space="preserve" filename="gparam.h" line="129">the string used as nick when constructing the
 parameter is guaranteed to remain valid and
 unmmodified for the lifetime of the parameter.</doc>
      </member>
      <member name="static_blurb" value="128" c:identifier="G_PARAM_STATIC_BLURB" version="2.8" gs:managed-name="StaticBlurb">
        <doc xml:space="preserve" filename="gparam.h" line="133">the string used as blurb when constructing the
 parameter is guaranteed to remain valid and
 unmodified for the lifetime of the parameter.</doc>
      </member>
      <member name="explicit_notify" value="1073741824" c:identifier="G_PARAM_EXPLICIT_NOTIFY" version="2.42" gs:managed-name="ExplicitNotify">
        <doc xml:space="preserve" filename="gparam.h" line="137">calls to g_object_set_property() for this
  property will not automatically result in a "notify" signal being
  emitted: the implementation must call g_object_notify() themselves
  in case the property actually changes.</doc>
      </member>
      <member name="deprecated" value="2147483648" c:identifier="G_PARAM_DEPRECATED" version="2.26" gs:managed-name="Deprecated">
        <doc xml:space="preserve" filename="gparam.h" line="142">the parameter is deprecated and will be removed
 in a future version. A warning will be generated if it is used
 while running with G_ENABLE_DIAGNOSTIC=1.</doc>
      </member>
    </bitfield>
    <class name="ParamSpec" c:symbol-prefix="param_spec" c:type="GParamSpec" abstract="1" glib:type-name="GParam" glib:get-type="intern" glib:type-struct="ParamSpecClass" glib:fundamental="1" glib:ref-func="g_param_spec_ref_sink" glib:unref-func="g_param_spec_uref" glib:set-value-func="g_value_set_param" glib:get-value-func="g_value_get_param" gs:custom-default-constructor="1" gs:custom-dispose="1" gs:managed-name="ParamSpec">
      <doc xml:space="preserve" filename="gobject-2.0.c" line="409">#GParamSpec is an object structure that encapsulates the metadata
required to specify parameters, such as e.g. #GObject properties.

## Parameter names # {#canonical-parameter-names}

A property name consists of one or more segments consisting of ASCII letters
and digits, separated by either the `-` or `_` character. The first
character of a property name must be a letter. These are the same rules as
for signal naming (see g_signal_new()).

When creating and looking up a #GParamSpec, either separator can be
used, but they cannot be mixed. Using `-` is considerably more
efficient, and is the ‘canonical form’. Using `_` is discouraged.</doc>
      <source-position filename="gparam.h" line="260" />
      <function name="is_valid_name" c:identifier="g_param_spec_is_valid_name" version="2.66" gs:dll-name="gobject-2.0" gs:managed-name="IsValidName">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3867">Validate a property name for a #GParamSpec. This can be useful for
dynamically-generated properties which need to be validated at run-time
before actually trying to create them.

See [canonical parameter names][canonical-parameter-names] for details of
the rules for valid names.</doc>
        <source-position filename="gparam.h" line="399" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3878">%TRUE if @name is a valid property name, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3869">the canonical name of the property</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3869">the canonical name of the property</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <virtual-method name="finalize" gs:dll-name="gobject-2.0" gs:managed-name="DoFinalize">
        <source-position filename="gparam.h" line="248" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </virtual-method>
      <virtual-method name="value_set_default" gs:dll-name="gobject-2.0" gs:managed-name="DoValueSetDefault">
        <source-position filename="gparam.h" line="251" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <type name="Value" c:type="GValue*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <type name="Value" c:type="GValue*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="value_validate" gs:dll-name="gobject-2.0" gs:managed-name="DoValueValidate">
        <source-position filename="gparam.h" line="253" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <type name="Value" c:type="GValue*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <type name="Value" c:type="GValue*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="values_cmp" gs:dll-name="gobject-2.0" gs:managed-name="DoValuesCmp">
        <source-position filename="gparam.h" line="255" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="gint" c:type="gint" />
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="value1" transfer-ownership="none" gs:managed-name="value1" direction="in">
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </parameter>
          <parameter name="value2" transfer-ownership="none" gs:managed-name="value2" direction="in">
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="value1" transfer-ownership="none" gs:managed-name="value1" direction="in">
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </parameter>
          <parameter name="value2" transfer-ownership="none" gs:managed-name="value2" direction="in">
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <gs:managed-property name="get_blurb" gs:dll-name="gobject-2.0" gs:managed-name="Blurb">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3701">Get the short description of a #GParamSpec.</doc>
        <source-position filename="gparam.h" line="328" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3707">the short description of @pspec.</doc>
          <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3703">a valid #GParamSpec</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_blurb" c:identifier="g_param_spec_get_blurb" gs:dll-name="gobject-2.0" gs:managed-name="GetBlurb" gs:property-getter-for="Blurb" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3701">Get the short description of a #GParamSpec.</doc>
        <source-position filename="gparam.h" line="328" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3707">the short description of @pspec.</doc>
          <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3703">a valid #GParamSpec</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_default_value" version="2.38" gs:dll-name="gobject-2.0" gs:managed-name="DefaultValue">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3711">Gets the default value of @pspec as a pointer to a #GValue.

The #GValue will remain valid for the life of @pspec.</doc>
        <source-position filename="gparam.h" line="345" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3719">a pointer to a #GValue which must not be modified</doc>
          <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3713">a #GParamSpec</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_default_value" c:identifier="g_param_spec_get_default_value" version="2.38" gs:dll-name="gobject-2.0" gs:managed-name="GetDefaultValue" gs:property-getter-for="DefaultValue" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3711">Gets the default value of @pspec as a pointer to a #GValue.

The #GValue will remain valid for the life of @pspec.</doc>
        <source-position filename="gparam.h" line="345" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3719">a pointer to a #GValue which must not be modified</doc>
          <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3713">a #GParamSpec</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_name" gs:dll-name="gobject-2.0" gs:managed-name="Name">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3724">Get the name of a #GParamSpec.

The name is always an "interned" string (as per g_intern_string()).
This allows for pointer-value comparisons.</doc>
        <source-position filename="gparam.h" line="324" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3733">the name of @pspec.</doc>
          <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3726">a valid #GParamSpec</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_name" c:identifier="g_param_spec_get_name" gs:dll-name="gobject-2.0" gs:managed-name="GetName" gs:property-getter-for="Name" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3724">Get the name of a #GParamSpec.

The name is always an "interned" string (as per g_intern_string()).
This allows for pointer-value comparisons.</doc>
        <source-position filename="gparam.h" line="324" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3733">the name of @pspec.</doc>
          <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3726">a valid #GParamSpec</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_name_quark" version="2.46" gs:dll-name="gobject-2.0" gs:managed-name="NameQuark">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3737">Gets the GQuark for the name.</doc>
        <source-position filename="gparam.h" line="348" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3743">the GQuark for @pspec-&gt;name.</doc>
          <type name="GLib.Quark" c:type="GQuark" />
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3739">a #GParamSpec</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_name_quark" c:identifier="g_param_spec_get_name_quark" version="2.46" gs:dll-name="gobject-2.0" gs:managed-name="GetNameQuark" gs:property-getter-for="NameQuark" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3737">Gets the GQuark for the name.</doc>
        <source-position filename="gparam.h" line="348" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3743">the GQuark for @pspec-&gt;name.</doc>
          <type name="GLib.Quark" c:type="GQuark" />
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3739">a #GParamSpec</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_nick" gs:dll-name="gobject-2.0" gs:managed-name="Nick">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3748">Get the nickname of a #GParamSpec.</doc>
        <source-position filename="gparam.h" line="326" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3754">the nickname of @pspec.</doc>
          <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3750">a valid #GParamSpec</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_nick" c:identifier="g_param_spec_get_nick" gs:dll-name="gobject-2.0" gs:managed-name="GetNick" gs:property-getter-for="Nick" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3748">Get the nickname of a #GParamSpec.</doc>
        <source-position filename="gparam.h" line="326" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3754">the nickname of @pspec.</doc>
          <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3750">a valid #GParamSpec</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="get_qdata" c:identifier="g_param_spec_get_qdata" gs:dll-name="gobject-2.0" gs:managed-name="GetQdata">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3758">Gets back user data pointers stored via g_param_spec_set_qdata().</doc>
        <source-position filename="gparam.h" line="288" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3765">the user data pointer set, or %NULL</doc>
          <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3760">a valid #GParamSpec</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="quark" transfer-ownership="none" gs:managed-name="quark" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3761">a #GQuark, naming the user data pointer</doc>
            <type name="GLib.Quark" c:type="GQuark" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="quark" transfer-ownership="none" gs:managed-name="quark" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3761">a #GQuark, naming the user data pointer</doc>
            <type name="GLib.Quark" c:type="GQuark" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <gs:managed-property name="get_redirect_target" version="2.4" gs:dll-name="gobject-2.0" gs:managed-name="RedirectTarget">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3769">If the paramspec redirects operations to another paramspec,
returns that paramspec. Redirect is used typically for
providing a new implementation of a property in a derived
type while preserving all the properties from the parent
type. Redirection is established by creating a property
of type #GParamSpecOverride. See g_object_class_override_property()
for an example of the use of this capability.</doc>
        <source-position filename="gparam.h" line="303" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3782">paramspec to which requests on this
         paramspec should be redirected, or %NULL if none.</doc>
          <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3771">a #GParamSpec</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_redirect_target" c:identifier="g_param_spec_get_redirect_target" version="2.4" gs:dll-name="gobject-2.0" gs:managed-name="GetRedirectTarget" gs:property-getter-for="RedirectTarget" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3769">If the paramspec redirects operations to another paramspec,
returns that paramspec. Redirect is used typically for
providing a new implementation of a property in a derived
type while preserving all the properties from the parent
type. Redirection is established by creating a property
of type #GParamSpecOverride. See g_object_class_override_property()
for an example of the use of this capability.</doc>
        <source-position filename="gparam.h" line="303" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3782">paramspec to which requests on this
         paramspec should be redirected, or %NULL if none.</doc>
          <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3771">a #GParamSpec</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="ref" c:identifier="g_param_spec_ref" introspectable="1" gs:dll-name="gobject-2.0" gs:managed-name="Ref" gs:special-func="ref" gs:pinvoke-only="1">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="4044">Increments the reference count of @pspec.</doc>
        <source-position filename="gparam.h" line="280" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="4050">the #GParamSpec that was passed into this function</doc>
          <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4046">a valid #GParamSpec</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="ref_sink" c:identifier="g_param_spec_ref_sink" version="2.10" introspectable="1" gs:pinvoke-only="1" gs:dll-name="gobject-2.0" gs:managed-name="RefSink">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="4054">Convenience function to ref and sink a #GParamSpec.</doc>
        <source-position filename="gparam.h" line="286" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="4061">the #GParamSpec that was passed into this function</doc>
          <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4056">a valid #GParamSpec</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="set_qdata" c:identifier="g_param_spec_set_qdata" gs:dll-name="gobject-2.0" gs:managed-name="SetQdata">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="4065">Sets an opaque, named pointer on a #GParamSpec. The name is
specified through a #GQuark (retrieved e.g. via
g_quark_from_static_string()), and the pointer can be gotten back
from the @pspec with g_param_spec_get_qdata().  Setting a
previously set user data pointer, overrides (frees) the old pointer
set, using %NULL as pointer essentially removes the data stored.</doc>
        <source-position filename="gparam.h" line="291" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4067">the #GParamSpec to set store a user data pointer</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="quark" transfer-ownership="none" gs:managed-name="quark" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4068">a #GQuark, naming the user data pointer</doc>
            <type name="GLib.Quark" c:type="GQuark" />
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4069">an opaque user data pointer</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="quark" transfer-ownership="none" gs:managed-name="quark" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4068">a #GQuark, naming the user data pointer</doc>
            <type name="GLib.Quark" c:type="GQuark" />
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4069">an opaque user data pointer</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_qdata_full" c:identifier="g_param_spec_set_qdata_full" introspectable="1" gs:pinvoke-only="1" gs:dll-name="gobject-2.0" gs:managed-name="SetQdataFull">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="4080">This function works like g_param_spec_set_qdata(), but in addition,
a `void (*destroy) (gpointer)` function may be
specified which is called with @data as argument when the @pspec is
finalized, or the data is being overwritten by a call to
g_param_spec_set_qdata() with the same @quark.</doc>
        <source-position filename="gparam.h" line="295" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4082">the #GParamSpec to set store a user data pointer</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="quark" transfer-ownership="none" gs:managed-name="quark" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4083">a #GQuark, naming the user data pointer</doc>
            <type name="GLib.Quark" c:type="GQuark" />
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4084">an opaque user data pointer</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="destroy" transfer-ownership="none" nullable="1" allow-none="1" scope="async" gs:managed-name="destroy" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4085">function to invoke with @data as argument, when @data needs to
 be freed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="quark" transfer-ownership="none" gs:managed-name="quark" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4083">a #GQuark, naming the user data pointer</doc>
            <type name="GLib.Quark" c:type="GQuark" />
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4084">an opaque user data pointer</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="destroy" transfer-ownership="none" nullable="1" allow-none="1" scope="async" gs:managed-name="destroy" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4085">function to invoke with @data as argument, when @data needs to
 be freed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="sink" c:identifier="g_param_spec_sink" gs:pinvoke-only="1" gs:dll-name="gobject-2.0" gs:managed-name="Sink">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="4096">The initial reference count of a newly created #GParamSpec is 1,
even though no one has explicitly called g_param_spec_ref() on it
yet. So the initial reference count is flagged as "floating", until
someone calls `g_param_spec_ref (pspec); g_param_spec_sink
(pspec);` in sequence on it, taking over the initial
reference count (thus ending up with a @pspec that has a reference
count of 1 still, but is not flagged "floating" anymore).</doc>
        <source-position filename="gparam.h" line="284" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4098">a valid #GParamSpec</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="steal_qdata" c:identifier="g_param_spec_steal_qdata" gs:pinvoke-only="1" gs:dll-name="gobject-2.0" gs:managed-name="StealQdata">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="4110">Gets back user data pointers stored via g_param_spec_set_qdata()
and removes the @data from @pspec without invoking its destroy()
function (if any was set).  Usually, calling this function is only
required to update user data pointers with a destroy notifier.</doc>
        <source-position filename="gparam.h" line="300" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="4120">the user data pointer set, or %NULL</doc>
          <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4112">the #GParamSpec to get a stored user data pointer from</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="quark" transfer-ownership="none" gs:managed-name="quark" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4113">a #GQuark, naming the user data pointer</doc>
            <type name="GLib.Quark" c:type="GQuark" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="quark" transfer-ownership="none" gs:managed-name="quark" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4113">a #GQuark, naming the user data pointer</doc>
            <type name="GLib.Quark" c:type="GQuark" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="unref" c:identifier="g_param_spec_unref" introspectable="1" gs:dll-name="gobject-2.0" gs:managed-name="Unref" gs:special-func="unref" gs:pinvoke-only="1">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="4230">Decrements the reference count of a @pspec.</doc>
        <source-position filename="gparam.h" line="282" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4232">a valid #GParamSpec</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <field name="g_type_instance" gs:managed-name="GTypeInstance">
        <doc xml:space="preserve" filename="gparam.h" line="198">private #GTypeInstance portion</doc>
        <type name="TypeInstance" c:type="GTypeInstance" />
      </field>
      <field name="name" gs:managed-name="Name">
        <doc xml:space="preserve" filename="gparam.h" line="199">name of this parameter: always an interned string</doc>
        <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
      </field>
      <field name="flags" gs:managed-name="Flags">
        <doc xml:space="preserve" filename="gparam.h" line="200">#GParamFlags flags for this parameter</doc>
        <type name="ParamFlags" c:type="GParamFlags" />
      </field>
      <field name="value_type" gs:managed-name="ValueType">
        <doc xml:space="preserve" filename="gparam.h" line="201">the #GValue type for this parameter</doc>
        <type name="GType" c:type="GType" />
      </field>
      <field name="owner_type" gs:managed-name="OwnerType">
        <doc xml:space="preserve" filename="gparam.h" line="202">#GType type that uses (introduces) this parameter</doc>
        <type name="GType" c:type="GType" />
      </field>
      <field name="_nick" readable="0" private="1" gs:managed-name="Nick">
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </field>
      <field name="_blurb" readable="0" private="1" gs:managed-name="Blurb">
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </field>
      <field name="qdata" readable="0" private="1" gs:managed-name="Qdata">
        <type name="GLib.Data" c:type="GData*" gs:is-pointer="1" />
      </field>
      <field name="ref_count" readable="0" private="1" gs:managed-name="RefCount">
        <type name="guint" c:type="guint" />
      </field>
      <field name="param_id" readable="0" private="1" gs:managed-name="ParamId">
        <type name="guint" c:type="guint" />
      </field>
      <constant name="MASK" value="255" c:type="G_PARAM_MASK" gs:access-modifiers="private" gs:managed-name="mask">
        <doc xml:space="preserve" filename="gparam.h" line="177">Mask containing the bits of #GParamSpec.flags which are reserved for GLib.</doc>
        <source-position filename="gparam.h" line="182" />
        <type name="gint" c:type="gint" />
      </constant>
      <constant name="STATIC_STRINGS" value="224" c:type="G_PARAM_STATIC_STRINGS" gs:access-modifiers="private" gs:managed-name="staticStrings">
        <doc xml:space="preserve" filename="gparam.h" line="168">#GParamFlags value alias for %G_PARAM_STATIC_NAME | %G_PARAM_STATIC_NICK | %G_PARAM_STATIC_BLURB.

Since 2.13.0</doc>
        <source-position filename="gparam.h" line="175" />
        <type name="gint" c:type="gint" />
      </constant>
      <constant name="USER_SHIFT" value="8" c:type="G_PARAM_USER_SHIFT" gs:access-modifiers="private" gs:managed-name="userShift">
        <doc xml:space="preserve" filename="gparam.h" line="183">Minimum shift count to be used for user defined flags, to be stored in
#GParamSpec.flags. The maximum allowed is 10.</doc>
        <source-position filename="gparam.h" line="189" />
        <type name="gint" c:type="gint" />
      </constant>
    </class>
    <class name="ParamSpecBoolean" c:symbol-prefix="param_spec_boolean" c:type="GParamSpecBoolean" parent="ParamSpec" glib:type-name="GParamBoolean" glib:get-type="intern" glib:fundamental="1" gs:managed-name="ParamSpecBoolean">
      <doc xml:space="preserve" filename="gparamspecs.h" line="644">A #GParamSpec derived structure that contains the meta data for boolean properties.</doc>
      <field name="parent_instance" gs:managed-name="ParentInstance">
        <doc xml:space="preserve" filename="gparamspecs.h" line="646">private #GParamSpec portion</doc>
        <type name="ParamSpec" c:type="GParamSpec" />
      </field>
      <field name="default_value" gs:managed-name="DefaultValue">
        <doc xml:space="preserve" filename="gparamspecs.h" line="647">default value for the property specified</doc>
        <type name="gboolean" c:type="gboolean" />
      </field>
      <constructor name="new" c:identifier="g_param_spec_boolean" gs:dll-name="gobject-2.0" gs:managed-name="New">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3575">Creates a new #GParamSpecBoolean instance specifying a %G_TYPE_BOOLEAN
property. In many cases, it may be more appropriate to use an enum with
g_param_spec_enum(), both to improve code clarity by using explicitly named
values, and to allow for more values to be added in future without breaking
API.

See g_param_spec_internal() for details on property names.</doc>
        <source-position filename="gparamspecs.h" line="1001" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3591">a newly created parameter specification</doc>
          <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3577">canonical name of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="nick" transfer-ownership="none" gs:managed-name="nick" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3578">nick name for the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="blurb" transfer-ownership="none" gs:managed-name="blurb" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3579">description of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="default_value" transfer-ownership="none" gs:managed-name="defaultValue" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3580">default value for the property specified</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3581">flags for the property specified</doc>
            <type name="ParamFlags" c:type="GParamFlags" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3577">canonical name of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="nick" transfer-ownership="none" gs:managed-name="nick" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3578">nick name for the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="blurb" transfer-ownership="none" gs:managed-name="blurb" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3579">description of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="default_value" transfer-ownership="none" gs:managed-name="defaultValue" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3580">default value for the property specified</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3581">flags for the property specified</doc>
            <type name="ParamFlags" c:type="GParamFlags" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
    </class>
    <class name="ParamSpecBoxed" c:symbol-prefix="param_spec_boxed" c:type="GParamSpecBoxed" parent="ParamSpec" glib:type-name="GParamBoxed" glib:get-type="intern" glib:fundamental="1" gs:managed-name="ParamSpecBoxed">
      <doc xml:space="preserve" filename="gparamspecs.h" line="879">A #GParamSpec derived structure that contains the meta data for boxed properties.</doc>
      <field name="parent_instance" gs:managed-name="ParentInstance">
        <doc xml:space="preserve" filename="gparamspecs.h" line="881">private #GParamSpec portion</doc>
        <type name="ParamSpec" c:type="GParamSpec" />
      </field>
      <constructor name="new" c:identifier="g_param_spec_boxed" gs:dll-name="gobject-2.0" gs:managed-name="New">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3595">Creates a new #GParamSpecBoxed instance specifying a %G_TYPE_BOXED
derived property.

See g_param_spec_internal() for details on property names.</doc>
        <source-position filename="gparamspecs.h" line="1103" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3608">a newly created parameter specification</doc>
          <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3597">canonical name of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="nick" transfer-ownership="none" gs:managed-name="nick" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3598">nick name for the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="blurb" transfer-ownership="none" gs:managed-name="blurb" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3599">description of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="boxed_type" transfer-ownership="none" gs:managed-name="boxedType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3600">%G_TYPE_BOXED derived type of this property</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3601">flags for the property specified</doc>
            <type name="ParamFlags" c:type="GParamFlags" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3597">canonical name of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="nick" transfer-ownership="none" gs:managed-name="nick" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3598">nick name for the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="blurb" transfer-ownership="none" gs:managed-name="blurb" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3599">description of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="boxed_type" transfer-ownership="none" gs:managed-name="boxedType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3600">%G_TYPE_BOXED derived type of this property</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3601">flags for the property specified</doc>
            <type name="ParamFlags" c:type="GParamFlags" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
    </class>
    <class name="ParamSpecChar" c:symbol-prefix="param_spec_char" c:type="GParamSpecChar" parent="ParamSpec" glib:type-name="GParamChar" glib:get-type="intern" glib:fundamental="1" gs:managed-name="ParamSpecChar">
      <doc xml:space="preserve" filename="gparamspecs.h" line="610">A #GParamSpec derived structure that contains the meta data for character properties.</doc>
      <field name="parent_instance" gs:managed-name="ParentInstance">
        <doc xml:space="preserve" filename="gparamspecs.h" line="612">private #GParamSpec portion</doc>
        <type name="ParamSpec" c:type="GParamSpec" />
      </field>
      <field name="minimum" gs:managed-name="Minimum">
        <doc xml:space="preserve" filename="gparamspecs.h" line="613">minimum value for the property specified</doc>
        <type name="gint8" c:type="gint8" />
      </field>
      <field name="maximum" gs:managed-name="Maximum">
        <doc xml:space="preserve" filename="gparamspecs.h" line="614">maximum value for the property specified</doc>
        <type name="gint8" c:type="gint8" />
      </field>
      <field name="default_value" gs:managed-name="DefaultValue">
        <doc xml:space="preserve" filename="gparamspecs.h" line="615">default value for the property specified</doc>
        <type name="gint8" c:type="gint8" />
      </field>
      <constructor name="new" c:identifier="g_param_spec_char" gs:dll-name="gobject-2.0" gs:managed-name="New">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3612">Creates a new #GParamSpecChar instance specifying a %G_TYPE_CHAR property.</doc>
        <source-position filename="gparamspecs.h" line="985" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3624">a newly created parameter specification</doc>
          <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3614">canonical name of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="nick" transfer-ownership="none" gs:managed-name="nick" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3615">nick name for the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="blurb" transfer-ownership="none" gs:managed-name="blurb" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3616">description of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="minimum" transfer-ownership="none" gs:managed-name="minimum" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3617">minimum value for the property specified</doc>
            <type name="gint8" c:type="gint8" />
          </parameter>
          <parameter name="maximum" transfer-ownership="none" gs:managed-name="maximum" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3618">maximum value for the property specified</doc>
            <type name="gint8" c:type="gint8" />
          </parameter>
          <parameter name="default_value" transfer-ownership="none" gs:managed-name="defaultValue" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3619">default value for the property specified</doc>
            <type name="gint8" c:type="gint8" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3620">flags for the property specified</doc>
            <type name="ParamFlags" c:type="GParamFlags" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3614">canonical name of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="nick" transfer-ownership="none" gs:managed-name="nick" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3615">nick name for the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="blurb" transfer-ownership="none" gs:managed-name="blurb" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3616">description of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="minimum" transfer-ownership="none" gs:managed-name="minimum" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3617">minimum value for the property specified</doc>
            <type name="gint8" c:type="gint8" />
          </parameter>
          <parameter name="maximum" transfer-ownership="none" gs:managed-name="maximum" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3618">maximum value for the property specified</doc>
            <type name="gint8" c:type="gint8" />
          </parameter>
          <parameter name="default_value" transfer-ownership="none" gs:managed-name="defaultValue" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3619">default value for the property specified</doc>
            <type name="gint8" c:type="gint8" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3620">flags for the property specified</doc>
            <type name="ParamFlags" c:type="GParamFlags" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
    </class>
    <record name="ParamSpecClass" c:type="GParamSpecClass" glib:is-gtype-struct-for="ParamSpec" gs:managed-name="ParamSpecClass">
      <doc xml:space="preserve" filename="gparam.h" line="223">The class structure for the GParamSpec type.
Normally, GParamSpec classes are filled by
g_param_type_register_static().</doc>
      <source-position filename="gparam.h" line="260" />
      <field name="g_type_class" gs:managed-name="GTypeClass">
        <doc xml:space="preserve" filename="gparam.h" line="225">the parent class</doc>
        <type name="TypeClass" c:type="GTypeClass" />
      </field>
      <field name="value_type" gs:managed-name="ValueType">
        <doc xml:space="preserve" filename="gparam.h" line="226">the #GValue type for this parameter</doc>
        <type name="GType" c:type="GType" />
      </field>
      <field name="finalize" gs:managed-name="Finalize">
        <callback name="finalize" gs:dll-name="gobject-2.0" gs:managed-name="Finalize">
          <source-position filename="gparam.h" line="248" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
              <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
              <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="value_set_default" gs:managed-name="ValueSetDefault">
        <callback name="value_set_default" gs:dll-name="gobject-2.0" gs:managed-name="ValueSetDefault">
          <source-position filename="gparam.h" line="251" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
              <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
            </parameter>
            <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
              <type name="Value" c:type="GValue*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
              <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
            </parameter>
            <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
              <type name="Value" c:type="GValue*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="value_validate" gs:managed-name="ValueValidate">
        <callback name="value_validate" gs:dll-name="gobject-2.0" gs:managed-name="ValueValidate">
          <source-position filename="gparam.h" line="253" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
              <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
            </parameter>
            <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
              <type name="Value" c:type="GValue*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
              <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
            </parameter>
            <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
              <type name="Value" c:type="GValue*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="values_cmp" gs:managed-name="ValuesCmp">
        <callback name="values_cmp" gs:dll-name="gobject-2.0" gs:managed-name="ValuesCmp">
          <source-position filename="gparam.h" line="255" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="gint" c:type="gint" />
          </return-value>
          <parameters>
            <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
              <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
            </parameter>
            <parameter name="value1" transfer-ownership="none" gs:managed-name="value1" direction="in">
              <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
            </parameter>
            <parameter name="value2" transfer-ownership="none" gs:managed-name="value2" direction="in">
              <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
              <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
            </parameter>
            <parameter name="value1" transfer-ownership="none" gs:managed-name="value1" direction="in">
              <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
            </parameter>
            <parameter name="value2" transfer-ownership="none" gs:managed-name="value2" direction="in">
              <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="dummy0" readable="0" private="1" gs:managed-name="Dummy0">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="dummy1" readable="0" private="1" gs:managed-name="Dummy1">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="dummy2" readable="0" private="1" gs:managed-name="Dummy2">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="dummy3" readable="0" private="1" gs:managed-name="Dummy3">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
    </record>
    <class name="ParamSpecDouble" c:symbol-prefix="param_spec_double" c:type="GParamSpecDouble" parent="ParamSpec" glib:type-name="GParamDouble" glib:get-type="intern" glib:fundamental="1" gs:managed-name="ParamSpecDouble">
      <doc xml:space="preserve" filename="gparamspecs.h" line="824">A #GParamSpec derived structure that contains the meta data for double properties.</doc>
      <field name="parent_instance" gs:managed-name="ParentInstance">
        <doc xml:space="preserve" filename="gparamspecs.h" line="826">private #GParamSpec portion</doc>
        <type name="ParamSpec" c:type="GParamSpec" />
      </field>
      <field name="minimum" gs:managed-name="Minimum">
        <doc xml:space="preserve" filename="gparamspecs.h" line="827">minimum value for the property specified</doc>
        <type name="gdouble" c:type="gdouble" />
      </field>
      <field name="maximum" gs:managed-name="Maximum">
        <doc xml:space="preserve" filename="gparamspecs.h" line="828">maximum value for the property specified</doc>
        <type name="gdouble" c:type="gdouble" />
      </field>
      <field name="default_value" gs:managed-name="DefaultValue">
        <doc xml:space="preserve" filename="gparamspecs.h" line="829">default value for the property specified</doc>
        <type name="gdouble" c:type="gdouble" />
      </field>
      <field name="epsilon" gs:managed-name="Epsilon">
        <doc xml:space="preserve" filename="gparamspecs.h" line="830">values closer than @epsilon will be considered identical
 by g_param_values_cmp(); the default value is 1e-90.</doc>
        <type name="gdouble" c:type="gdouble" />
      </field>
      <constructor name="new" c:identifier="g_param_spec_double" gs:dll-name="gobject-2.0" gs:managed-name="New">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3628">Creates a new #GParamSpecDouble instance specifying a %G_TYPE_DOUBLE
property.

See g_param_spec_internal() for details on property names.</doc>
        <source-position filename="gparamspecs.h" line="1083" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3643">a newly created parameter specification</doc>
          <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3630">canonical name of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="nick" transfer-ownership="none" gs:managed-name="nick" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3631">nick name for the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="blurb" transfer-ownership="none" gs:managed-name="blurb" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3632">description of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="minimum" transfer-ownership="none" gs:managed-name="minimum" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3633">minimum value for the property specified</doc>
            <type name="gdouble" c:type="gdouble" />
          </parameter>
          <parameter name="maximum" transfer-ownership="none" gs:managed-name="maximum" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3634">maximum value for the property specified</doc>
            <type name="gdouble" c:type="gdouble" />
          </parameter>
          <parameter name="default_value" transfer-ownership="none" gs:managed-name="defaultValue" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3635">default value for the property specified</doc>
            <type name="gdouble" c:type="gdouble" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3636">flags for the property specified</doc>
            <type name="ParamFlags" c:type="GParamFlags" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3630">canonical name of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="nick" transfer-ownership="none" gs:managed-name="nick" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3631">nick name for the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="blurb" transfer-ownership="none" gs:managed-name="blurb" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3632">description of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="minimum" transfer-ownership="none" gs:managed-name="minimum" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3633">minimum value for the property specified</doc>
            <type name="gdouble" c:type="gdouble" />
          </parameter>
          <parameter name="maximum" transfer-ownership="none" gs:managed-name="maximum" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3634">maximum value for the property specified</doc>
            <type name="gdouble" c:type="gdouble" />
          </parameter>
          <parameter name="default_value" transfer-ownership="none" gs:managed-name="defaultValue" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3635">default value for the property specified</doc>
            <type name="gdouble" c:type="gdouble" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3636">flags for the property specified</doc>
            <type name="ParamFlags" c:type="GParamFlags" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
    </class>
    <class name="ParamSpecEnum" c:symbol-prefix="param_spec_enum" c:type="GParamSpecEnum" parent="ParamSpec" glib:type-name="GParamEnum" glib:get-type="intern" glib:fundamental="1" gs:managed-name="ParamSpecEnum">
      <doc xml:space="preserve" filename="gparamspecs.h" line="772">A #GParamSpec derived structure that contains the meta data for enum
properties.</doc>
      <field name="parent_instance" gs:managed-name="ParentInstance">
        <doc xml:space="preserve" filename="gparamspecs.h" line="774">private #GParamSpec portion</doc>
        <type name="ParamSpec" c:type="GParamSpec" />
      </field>
      <field name="enum_class" gs:managed-name="EnumClass">
        <doc xml:space="preserve" filename="gparamspecs.h" line="775">the #GEnumClass for the enum</doc>
        <type name="EnumClass" c:type="GEnumClass*" gs:is-pointer="1" />
      </field>
      <field name="default_value" gs:managed-name="DefaultValue">
        <doc xml:space="preserve" filename="gparamspecs.h" line="776">default value for the property specified</doc>
        <type name="gint" c:type="gint" />
      </field>
      <constructor name="new" c:identifier="g_param_spec_enum" gs:dll-name="gobject-2.0" gs:managed-name="New">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3647">Creates a new #GParamSpecEnum instance specifying a %G_TYPE_ENUM
property.

See g_param_spec_internal() for details on property names.</doc>
        <source-position filename="gparamspecs.h" line="1061" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3661">a newly created parameter specification</doc>
          <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3649">canonical name of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="nick" transfer-ownership="none" gs:managed-name="nick" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3650">nick name for the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="blurb" transfer-ownership="none" gs:managed-name="blurb" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3651">description of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="enum_type" transfer-ownership="none" gs:managed-name="enumType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3652">a #GType derived from %G_TYPE_ENUM</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="default_value" transfer-ownership="none" gs:managed-name="defaultValue" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3653">default value for the property specified</doc>
            <type name="gint" c:type="gint" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3654">flags for the property specified</doc>
            <type name="ParamFlags" c:type="GParamFlags" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3649">canonical name of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="nick" transfer-ownership="none" gs:managed-name="nick" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3650">nick name for the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="blurb" transfer-ownership="none" gs:managed-name="blurb" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3651">description of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="enum_type" transfer-ownership="none" gs:managed-name="enumType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3652">a #GType derived from %G_TYPE_ENUM</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="default_value" transfer-ownership="none" gs:managed-name="defaultValue" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3653">default value for the property specified</doc>
            <type name="gint" c:type="gint" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3654">flags for the property specified</doc>
            <type name="ParamFlags" c:type="GParamFlags" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
    </class>
    <class name="ParamSpecFlags" c:symbol-prefix="param_spec_flags" c:type="GParamSpecFlags" parent="ParamSpec" glib:type-name="GParamFlags" glib:get-type="intern" glib:fundamental="1" gs:managed-name="ParamSpecFlags">
      <doc xml:space="preserve" filename="gparamspecs.h" line="788">A #GParamSpec derived structure that contains the meta data for flags
properties.</doc>
      <field name="parent_instance" gs:managed-name="ParentInstance">
        <doc xml:space="preserve" filename="gparamspecs.h" line="790">private #GParamSpec portion</doc>
        <type name="ParamSpec" c:type="GParamSpec" />
      </field>
      <field name="flags_class" gs:managed-name="FlagsClass">
        <doc xml:space="preserve" filename="gparamspecs.h" line="791">the #GFlagsClass for the flags</doc>
        <type name="FlagsClass" c:type="GFlagsClass*" gs:is-pointer="1" />
      </field>
      <field name="default_value" gs:managed-name="DefaultValue">
        <doc xml:space="preserve" filename="gparamspecs.h" line="792">default value for the property specified</doc>
        <type name="guint" c:type="guint" />
      </field>
      <constructor name="new" c:identifier="g_param_spec_flags" gs:dll-name="gobject-2.0" gs:managed-name="New">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3665">Creates a new #GParamSpecFlags instance specifying a %G_TYPE_FLAGS
property.

See g_param_spec_internal() for details on property names.</doc>
        <source-position filename="gparamspecs.h" line="1068" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3679">a newly created parameter specification</doc>
          <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3667">canonical name of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="nick" transfer-ownership="none" gs:managed-name="nick" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3668">nick name for the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="blurb" transfer-ownership="none" gs:managed-name="blurb" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3669">description of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags_type" transfer-ownership="none" gs:managed-name="flagsType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3670">a #GType derived from %G_TYPE_FLAGS</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="default_value" transfer-ownership="none" gs:managed-name="defaultValue" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3671">default value for the property specified</doc>
            <type name="guint" c:type="guint" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3672">flags for the property specified</doc>
            <type name="ParamFlags" c:type="GParamFlags" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3667">canonical name of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="nick" transfer-ownership="none" gs:managed-name="nick" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3668">nick name for the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="blurb" transfer-ownership="none" gs:managed-name="blurb" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3669">description of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags_type" transfer-ownership="none" gs:managed-name="flagsType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3670">a #GType derived from %G_TYPE_FLAGS</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="default_value" transfer-ownership="none" gs:managed-name="defaultValue" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3671">default value for the property specified</doc>
            <type name="guint" c:type="guint" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3672">flags for the property specified</doc>
            <type name="ParamFlags" c:type="GParamFlags" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
    </class>
    <class name="ParamSpecFloat" c:symbol-prefix="param_spec_float" c:type="GParamSpecFloat" parent="ParamSpec" glib:type-name="GParamFloat" glib:get-type="intern" glib:fundamental="1" gs:managed-name="ParamSpecFloat">
      <doc xml:space="preserve" filename="gparamspecs.h" line="804">A #GParamSpec derived structure that contains the meta data for float properties.</doc>
      <field name="parent_instance" gs:managed-name="ParentInstance">
        <doc xml:space="preserve" filename="gparamspecs.h" line="806">private #GParamSpec portion</doc>
        <type name="ParamSpec" c:type="GParamSpec" />
      </field>
      <field name="minimum" gs:managed-name="Minimum">
        <doc xml:space="preserve" filename="gparamspecs.h" line="807">minimum value for the property specified</doc>
        <type name="gfloat" c:type="gfloat" />
      </field>
      <field name="maximum" gs:managed-name="Maximum">
        <doc xml:space="preserve" filename="gparamspecs.h" line="808">maximum value for the property specified</doc>
        <type name="gfloat" c:type="gfloat" />
      </field>
      <field name="default_value" gs:managed-name="DefaultValue">
        <doc xml:space="preserve" filename="gparamspecs.h" line="809">default value for the property specified</doc>
        <type name="gfloat" c:type="gfloat" />
      </field>
      <field name="epsilon" gs:managed-name="Epsilon">
        <doc xml:space="preserve" filename="gparamspecs.h" line="810">values closer than @epsilon will be considered identical
 by g_param_values_cmp(); the default value is 1e-30.</doc>
        <type name="gfloat" c:type="gfloat" />
      </field>
      <constructor name="new" c:identifier="g_param_spec_float" gs:dll-name="gobject-2.0" gs:managed-name="New">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3683">Creates a new #GParamSpecFloat instance specifying a %G_TYPE_FLOAT property.

See g_param_spec_internal() for details on property names.</doc>
        <source-position filename="gparamspecs.h" line="1075" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3697">a newly created parameter specification</doc>
          <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3685">canonical name of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="nick" transfer-ownership="none" gs:managed-name="nick" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3686">nick name for the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="blurb" transfer-ownership="none" gs:managed-name="blurb" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3687">description of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="minimum" transfer-ownership="none" gs:managed-name="minimum" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3688">minimum value for the property specified</doc>
            <type name="gfloat" c:type="gfloat" />
          </parameter>
          <parameter name="maximum" transfer-ownership="none" gs:managed-name="maximum" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3689">maximum value for the property specified</doc>
            <type name="gfloat" c:type="gfloat" />
          </parameter>
          <parameter name="default_value" transfer-ownership="none" gs:managed-name="defaultValue" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3690">default value for the property specified</doc>
            <type name="gfloat" c:type="gfloat" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3691">flags for the property specified</doc>
            <type name="ParamFlags" c:type="GParamFlags" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3685">canonical name of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="nick" transfer-ownership="none" gs:managed-name="nick" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3686">nick name for the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="blurb" transfer-ownership="none" gs:managed-name="blurb" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3687">description of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="minimum" transfer-ownership="none" gs:managed-name="minimum" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3688">minimum value for the property specified</doc>
            <type name="gfloat" c:type="gfloat" />
          </parameter>
          <parameter name="maximum" transfer-ownership="none" gs:managed-name="maximum" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3689">maximum value for the property specified</doc>
            <type name="gfloat" c:type="gfloat" />
          </parameter>
          <parameter name="default_value" transfer-ownership="none" gs:managed-name="defaultValue" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3690">default value for the property specified</doc>
            <type name="gfloat" c:type="gfloat" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3691">flags for the property specified</doc>
            <type name="ParamFlags" c:type="GParamFlags" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
    </class>
    <class name="ParamSpecGType" c:symbol-prefix="param_spec_gtype" c:type="GParamSpecGType" version="2.10" parent="ParamSpec" glib:type-name="GParamGType" glib:get-type="intern" glib:fundamental="1" gs:managed-name="ParamSpecGType">
      <doc xml:space="preserve" filename="gparamspecs.h" line="943">A #GParamSpec derived structure that contains the meta data for #GType properties.</doc>
      <field name="parent_instance" gs:managed-name="ParentInstance">
        <doc xml:space="preserve" filename="gparamspecs.h" line="945">private #GParamSpec portion</doc>
        <type name="ParamSpec" c:type="GParamSpec" />
      </field>
      <field name="is_a_type" gs:managed-name="IsAType">
        <doc xml:space="preserve" filename="gparamspecs.h" line="946">a #GType whose subtypes can occur as values</doc>
        <type name="GType" c:type="GType" />
      </field>
      <constructor name="new" c:identifier="g_param_spec_gtype" version="2.10" gs:dll-name="gobject-2.0" gs:managed-name="New">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3787">Creates a new #GParamSpecGType instance specifying a
%G_TYPE_GTYPE property.

See g_param_spec_internal() for details on property names.</doc>
        <source-position filename="gparamspecs.h" line="1129" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3802">a newly created parameter specification</doc>
          <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3789">canonical name of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="nick" transfer-ownership="none" gs:managed-name="nick" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3790">nick name for the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="blurb" transfer-ownership="none" gs:managed-name="blurb" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3791">description of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="is_a_type" transfer-ownership="none" gs:managed-name="isAType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3792">a #GType whose subtypes are allowed as values
 of the property (use %G_TYPE_NONE for any type)</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3794">flags for the property specified</doc>
            <type name="ParamFlags" c:type="GParamFlags" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3789">canonical name of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="nick" transfer-ownership="none" gs:managed-name="nick" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3790">nick name for the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="blurb" transfer-ownership="none" gs:managed-name="blurb" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3791">description of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="is_a_type" transfer-ownership="none" gs:managed-name="isAType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3792">a #GType whose subtypes are allowed as values
 of the property (use %G_TYPE_NONE for any type)</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3794">flags for the property specified</doc>
            <type name="ParamFlags" c:type="GParamFlags" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
    </class>
    <class name="ParamSpecInt" c:symbol-prefix="param_spec_int" c:type="GParamSpecInt" parent="ParamSpec" glib:type-name="GParamInt" glib:get-type="intern" glib:fundamental="1" gs:managed-name="ParamSpecInt">
      <doc xml:space="preserve" filename="gparamspecs.h" line="657">A #GParamSpec derived structure that contains the meta data for integer properties.</doc>
      <field name="parent_instance" gs:managed-name="ParentInstance">
        <doc xml:space="preserve" filename="gparamspecs.h" line="659">private #GParamSpec portion</doc>
        <type name="ParamSpec" c:type="GParamSpec" />
      </field>
      <field name="minimum" gs:managed-name="Minimum">
        <doc xml:space="preserve" filename="gparamspecs.h" line="660">minimum value for the property specified</doc>
        <type name="gint" c:type="gint" />
      </field>
      <field name="maximum" gs:managed-name="Maximum">
        <doc xml:space="preserve" filename="gparamspecs.h" line="661">maximum value for the property specified</doc>
        <type name="gint" c:type="gint" />
      </field>
      <field name="default_value" gs:managed-name="DefaultValue">
        <doc xml:space="preserve" filename="gparamspecs.h" line="662">default value for the property specified</doc>
        <type name="gint" c:type="gint" />
      </field>
      <constructor name="new" c:identifier="g_param_spec_int" gs:dll-name="gobject-2.0" gs:managed-name="New">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3806">Creates a new #GParamSpecInt instance specifying a %G_TYPE_INT property.

See g_param_spec_internal() for details on property names.</doc>
        <source-position filename="gparamspecs.h" line="1007" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3820">a newly created parameter specification</doc>
          <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3808">canonical name of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="nick" transfer-ownership="none" gs:managed-name="nick" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3809">nick name for the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="blurb" transfer-ownership="none" gs:managed-name="blurb" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3810">description of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="minimum" transfer-ownership="none" gs:managed-name="minimum" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3811">minimum value for the property specified</doc>
            <type name="gint" c:type="gint" />
          </parameter>
          <parameter name="maximum" transfer-ownership="none" gs:managed-name="maximum" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3812">maximum value for the property specified</doc>
            <type name="gint" c:type="gint" />
          </parameter>
          <parameter name="default_value" transfer-ownership="none" gs:managed-name="defaultValue" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3813">default value for the property specified</doc>
            <type name="gint" c:type="gint" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3814">flags for the property specified</doc>
            <type name="ParamFlags" c:type="GParamFlags" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3808">canonical name of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="nick" transfer-ownership="none" gs:managed-name="nick" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3809">nick name for the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="blurb" transfer-ownership="none" gs:managed-name="blurb" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3810">description of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="minimum" transfer-ownership="none" gs:managed-name="minimum" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3811">minimum value for the property specified</doc>
            <type name="gint" c:type="gint" />
          </parameter>
          <parameter name="maximum" transfer-ownership="none" gs:managed-name="maximum" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3812">maximum value for the property specified</doc>
            <type name="gint" c:type="gint" />
          </parameter>
          <parameter name="default_value" transfer-ownership="none" gs:managed-name="defaultValue" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3813">default value for the property specified</doc>
            <type name="gint" c:type="gint" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3814">flags for the property specified</doc>
            <type name="ParamFlags" c:type="GParamFlags" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
    </class>
    <class name="ParamSpecInt64" c:symbol-prefix="param_spec_int64" c:type="GParamSpecInt64" parent="ParamSpec" glib:type-name="GParamInt64" glib:get-type="intern" glib:fundamental="1" gs:managed-name="ParamSpecInt64">
      <doc xml:space="preserve" filename="gparamspecs.h" line="725">A #GParamSpec derived structure that contains the meta data for 64bit integer properties.</doc>
      <field name="parent_instance" gs:managed-name="ParentInstance">
        <doc xml:space="preserve" filename="gparamspecs.h" line="727">private #GParamSpec portion</doc>
        <type name="ParamSpec" c:type="GParamSpec" />
      </field>
      <field name="minimum" gs:managed-name="Minimum">
        <doc xml:space="preserve" filename="gparamspecs.h" line="728">minimum value for the property specified</doc>
        <type name="gint64" c:type="gint64" />
      </field>
      <field name="maximum" gs:managed-name="Maximum">
        <doc xml:space="preserve" filename="gparamspecs.h" line="729">maximum value for the property specified</doc>
        <type name="gint64" c:type="gint64" />
      </field>
      <field name="default_value" gs:managed-name="DefaultValue">
        <doc xml:space="preserve" filename="gparamspecs.h" line="730">default value for the property specified</doc>
        <type name="gint64" c:type="gint64" />
      </field>
      <constructor name="new" c:identifier="g_param_spec_int64" gs:dll-name="gobject-2.0" gs:managed-name="New">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3824">Creates a new #GParamSpecInt64 instance specifying a %G_TYPE_INT64 property.

See g_param_spec_internal() for details on property names.</doc>
        <source-position filename="gparamspecs.h" line="1039" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3838">a newly created parameter specification</doc>
          <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3826">canonical name of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="nick" transfer-ownership="none" gs:managed-name="nick" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3827">nick name for the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="blurb" transfer-ownership="none" gs:managed-name="blurb" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3828">description of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="minimum" transfer-ownership="none" gs:managed-name="minimum" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3829">minimum value for the property specified</doc>
            <type name="gint64" c:type="gint64" />
          </parameter>
          <parameter name="maximum" transfer-ownership="none" gs:managed-name="maximum" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3830">maximum value for the property specified</doc>
            <type name="gint64" c:type="gint64" />
          </parameter>
          <parameter name="default_value" transfer-ownership="none" gs:managed-name="defaultValue" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3831">default value for the property specified</doc>
            <type name="gint64" c:type="gint64" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3832">flags for the property specified</doc>
            <type name="ParamFlags" c:type="GParamFlags" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3826">canonical name of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="nick" transfer-ownership="none" gs:managed-name="nick" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3827">nick name for the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="blurb" transfer-ownership="none" gs:managed-name="blurb" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3828">description of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="minimum" transfer-ownership="none" gs:managed-name="minimum" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3829">minimum value for the property specified</doc>
            <type name="gint64" c:type="gint64" />
          </parameter>
          <parameter name="maximum" transfer-ownership="none" gs:managed-name="maximum" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3830">maximum value for the property specified</doc>
            <type name="gint64" c:type="gint64" />
          </parameter>
          <parameter name="default_value" transfer-ownership="none" gs:managed-name="defaultValue" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3831">default value for the property specified</doc>
            <type name="gint64" c:type="gint64" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3832">flags for the property specified</doc>
            <type name="ParamFlags" c:type="GParamFlags" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
    </class>
    <class name="ParamSpecLong" c:symbol-prefix="param_spec_long" c:type="GParamSpecLong" parent="ParamSpec" glib:type-name="GParamLong" glib:get-type="intern" glib:fundamental="1" gs:managed-name="ParamSpecLong">
      <doc xml:space="preserve" filename="gparamspecs.h" line="691">A #GParamSpec derived structure that contains the meta data for long integer properties.</doc>
      <field name="parent_instance" gs:managed-name="ParentInstance">
        <doc xml:space="preserve" filename="gparamspecs.h" line="693">private #GParamSpec portion</doc>
        <type name="ParamSpec" c:type="GParamSpec" />
      </field>
      <field name="minimum" gs:managed-name="Minimum">
        <doc xml:space="preserve" filename="gparamspecs.h" line="694">minimum value for the property specified</doc>
        <type name="glong" c:type="glong" />
      </field>
      <field name="maximum" gs:managed-name="Maximum">
        <doc xml:space="preserve" filename="gparamspecs.h" line="695">maximum value for the property specified</doc>
        <type name="glong" c:type="glong" />
      </field>
      <field name="default_value" gs:managed-name="DefaultValue">
        <doc xml:space="preserve" filename="gparamspecs.h" line="696">default value for the property specified</doc>
        <type name="glong" c:type="glong" />
      </field>
      <constructor name="new" c:identifier="g_param_spec_long" gs:dll-name="gobject-2.0" gs:managed-name="New">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3883">Creates a new #GParamSpecLong instance specifying a %G_TYPE_LONG property.

See g_param_spec_internal() for details on property names.</doc>
        <source-position filename="gparamspecs.h" line="1023" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3897">a newly created parameter specification</doc>
          <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3885">canonical name of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="nick" transfer-ownership="none" gs:managed-name="nick" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3886">nick name for the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="blurb" transfer-ownership="none" gs:managed-name="blurb" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3887">description of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="minimum" transfer-ownership="none" gs:managed-name="minimum" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3888">minimum value for the property specified</doc>
            <type name="glong" c:type="glong" />
          </parameter>
          <parameter name="maximum" transfer-ownership="none" gs:managed-name="maximum" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3889">maximum value for the property specified</doc>
            <type name="glong" c:type="glong" />
          </parameter>
          <parameter name="default_value" transfer-ownership="none" gs:managed-name="defaultValue" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3890">default value for the property specified</doc>
            <type name="glong" c:type="glong" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3891">flags for the property specified</doc>
            <type name="ParamFlags" c:type="GParamFlags" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3885">canonical name of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="nick" transfer-ownership="none" gs:managed-name="nick" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3886">nick name for the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="blurb" transfer-ownership="none" gs:managed-name="blurb" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3887">description of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="minimum" transfer-ownership="none" gs:managed-name="minimum" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3888">minimum value for the property specified</doc>
            <type name="glong" c:type="glong" />
          </parameter>
          <parameter name="maximum" transfer-ownership="none" gs:managed-name="maximum" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3889">maximum value for the property specified</doc>
            <type name="glong" c:type="glong" />
          </parameter>
          <parameter name="default_value" transfer-ownership="none" gs:managed-name="defaultValue" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3890">default value for the property specified</doc>
            <type name="glong" c:type="glong" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3891">flags for the property specified</doc>
            <type name="ParamFlags" c:type="GParamFlags" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
    </class>
    <class name="ParamSpecObject" c:symbol-prefix="param_spec_object" c:type="GParamSpecObject" parent="ParamSpec" glib:type-name="GParamObject" glib:get-type="intern" glib:fundamental="1" gs:managed-name="ParamSpecObject">
      <doc xml:space="preserve" filename="gparamspecs.h" line="913">A #GParamSpec derived structure that contains the meta data for object properties.</doc>
      <field name="parent_instance" gs:managed-name="ParentInstance">
        <doc xml:space="preserve" filename="gparamspecs.h" line="915">private #GParamSpec portion</doc>
        <type name="ParamSpec" c:type="GParamSpec" />
      </field>
      <constructor name="new" c:identifier="g_param_spec_object" gs:dll-name="gobject-2.0" gs:managed-name="New">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3901">Creates a new #GParamSpecBoxed instance specifying a %G_TYPE_OBJECT
derived property.

See g_param_spec_internal() for details on property names.</doc>
        <source-position filename="gparamspecs.h" line="1120" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3914">a newly created parameter specification</doc>
          <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3903">canonical name of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="nick" transfer-ownership="none" gs:managed-name="nick" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3904">nick name for the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="blurb" transfer-ownership="none" gs:managed-name="blurb" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3905">description of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="object_type" transfer-ownership="none" gs:managed-name="objectType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3906">%G_TYPE_OBJECT derived type of this property</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3907">flags for the property specified</doc>
            <type name="ParamFlags" c:type="GParamFlags" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3903">canonical name of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="nick" transfer-ownership="none" gs:managed-name="nick" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3904">nick name for the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="blurb" transfer-ownership="none" gs:managed-name="blurb" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3905">description of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="object_type" transfer-ownership="none" gs:managed-name="objectType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3906">%G_TYPE_OBJECT derived type of this property</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3907">flags for the property specified</doc>
            <type name="ParamFlags" c:type="GParamFlags" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
    </class>
    <class name="ParamSpecOverride" c:symbol-prefix="param_spec_override" c:type="GParamSpecOverride" version="2.4" parent="ParamSpec" glib:type-name="GParamOverride" glib:get-type="intern" glib:fundamental="1" gs:managed-name="ParamSpecOverride">
      <doc xml:space="preserve" filename="gparamspecs.h" line="923">This is a type of #GParamSpec type that simply redirects operations to
another paramspec.  All operations other than getting or
setting the value are redirected, including accessing the nick and
blurb, validating a value, and so forth. See
g_param_spec_get_redirect_target() for retrieving the overridden
property. #GParamSpecOverride is used in implementing
g_object_class_override_property(), and will not be directly useful
unless you are implementing a new base type similar to GObject.</doc>
      <field name="parent_instance" readable="0" private="1" gs:managed-name="ParentInstance">
        <type name="ParamSpec" c:type="GParamSpec" />
      </field>
      <field name="overridden" readable="0" private="1" gs:managed-name="Overridden">
        <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
      </field>
    </class>
    <class name="ParamSpecParam" c:symbol-prefix="param_spec_param" c:type="GParamSpecParam" parent="ParamSpec" glib:type-name="GParamParam" glib:get-type="intern" glib:fundamental="1" gs:managed-name="ParamSpecParam">
      <doc xml:space="preserve" filename="gparamspecs.h" line="868">A #GParamSpec derived structure that contains the meta data for %G_TYPE_PARAM
properties.</doc>
      <field name="parent_instance" gs:managed-name="ParentInstance">
        <doc xml:space="preserve" filename="gparamspecs.h" line="870">private #GParamSpec portion</doc>
        <type name="ParamSpec" c:type="GParamSpec" />
      </field>
      <constructor name="new" c:identifier="g_param_spec_param" gs:dll-name="gobject-2.0" gs:managed-name="New">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3932">Creates a new #GParamSpecParam instance specifying a %G_TYPE_PARAM
property.

See g_param_spec_internal() for details on property names.</doc>
        <source-position filename="gparamspecs.h" line="1097" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3945">a newly created parameter specification</doc>
          <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3934">canonical name of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="nick" transfer-ownership="none" gs:managed-name="nick" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3935">nick name for the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="blurb" transfer-ownership="none" gs:managed-name="blurb" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3936">description of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="param_type" transfer-ownership="none" gs:managed-name="paramType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3937">a #GType derived from %G_TYPE_PARAM</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3938">flags for the property specified</doc>
            <type name="ParamFlags" c:type="GParamFlags" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3934">canonical name of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="nick" transfer-ownership="none" gs:managed-name="nick" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3935">nick name for the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="blurb" transfer-ownership="none" gs:managed-name="blurb" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3936">description of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="param_type" transfer-ownership="none" gs:managed-name="paramType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3937">a #GType derived from %G_TYPE_PARAM</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3938">flags for the property specified</doc>
            <type name="ParamFlags" c:type="GParamFlags" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
    </class>
    <class name="ParamSpecPointer" c:symbol-prefix="param_spec_pointer" c:type="GParamSpecPointer" parent="ParamSpec" glib:type-name="GParamPointer" glib:get-type="intern" glib:fundamental="1" gs:managed-name="ParamSpecPointer">
      <doc xml:space="preserve" filename="gparamspecs.h" line="889">A #GParamSpec derived structure that contains the meta data for pointer properties.</doc>
      <field name="parent_instance" gs:managed-name="ParentInstance">
        <doc xml:space="preserve" filename="gparamspecs.h" line="891">private #GParamSpec portion</doc>
        <type name="ParamSpec" c:type="GParamSpec" />
      </field>
      <constructor name="new" c:identifier="g_param_spec_pointer" gs:dll-name="gobject-2.0" gs:managed-name="New">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3949">Creates a new #GParamSpecPointer instance specifying a pointer property.
Where possible, it is better to use g_param_spec_object() or
g_param_spec_boxed() to expose memory management information.

See g_param_spec_internal() for details on property names.</doc>
        <source-position filename="gparamspecs.h" line="1109" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3962">a newly created parameter specification</doc>
          <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3951">canonical name of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="nick" transfer-ownership="none" gs:managed-name="nick" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3952">nick name for the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="blurb" transfer-ownership="none" gs:managed-name="blurb" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3953">description of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3954">flags for the property specified</doc>
            <type name="ParamFlags" c:type="GParamFlags" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3951">canonical name of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="nick" transfer-ownership="none" gs:managed-name="nick" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3952">nick name for the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="blurb" transfer-ownership="none" gs:managed-name="blurb" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3953">description of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3954">flags for the property specified</doc>
            <type name="ParamFlags" c:type="GParamFlags" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
    </class>
    <record name="ParamSpecPool" c:type="GParamSpecPool" disguised="1" gs:managed-name="ParamSpecPool">
      <doc xml:space="preserve" filename="gobject-2.0.c" line="89">A #GParamSpecPool maintains a collection of #GParamSpecs which can be
quickly accessed by owner and name. The implementation of the #GObject property
system uses such a pool to store the #GParamSpecs of the properties all object
types.</doc>
      <source-position filename="gparam.h" line="195" />
      <method name="insert" c:identifier="g_param_spec_pool_insert" gs:dll-name="gobject-2.0" gs:managed-name="Insert">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3966">Inserts a #GParamSpec in the pool.</doc>
        <source-position filename="gparam.h" line="417" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="pool" transfer-ownership="none" gs:managed-name="pool" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3968">a #GParamSpecPool.</doc>
            <type name="ParamSpecPool" c:type="GParamSpecPool*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3969">the #GParamSpec to insert</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
          </parameter>
          <parameter name="owner_type" transfer-ownership="none" gs:managed-name="ownerType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3970">a #GType identifying the owner of @pspec</doc>
            <type name="GType" c:type="GType" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3969">the #GParamSpec to insert</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
          </parameter>
          <parameter name="owner_type" transfer-ownership="none" gs:managed-name="ownerType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3970">a #GType identifying the owner of @pspec</doc>
            <type name="GType" c:type="GType" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="list" c:identifier="g_param_spec_pool_list" gs:dll-name="gobject-2.0" gs:managed-name="List">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3976">Gets an array of all #GParamSpecs owned by @owner_type in
the pool.</doc>
        <source-position filename="gparam.h" line="432" />
        <return-value transfer-ownership="container" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3985">a newly
         allocated array containing pointers to all #GParamSpecs
         owned by @owner_type in the pool</doc>
          <array length="1" zero-terminated="0" c:type="GParamSpec**" gs:is-pointer="1">
            <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="pool" transfer-ownership="none" gs:managed-name="pool" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3978">a #GParamSpecPool</doc>
            <type name="ParamSpecPool" c:type="GParamSpecPool*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="owner_type" transfer-ownership="none" gs:managed-name="ownerType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3979">the owner to look for</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="n_pspecs_p" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="nPspecsP">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3980">return location for the length of the returned array</doc>
            <type name="guint" c:type="guint*" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="owner_type" transfer-ownership="none" gs:managed-name="ownerType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3979">the owner to look for</doc>
            <type name="GType" c:type="GType" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="list_owned" c:identifier="g_param_spec_pool_list_owned" gs:dll-name="gobject-2.0" gs:managed-name="ListOwned">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3991">Gets an #GList of all #GParamSpecs owned by @owner_type in
the pool.</doc>
        <source-position filename="gparam.h" line="429" />
        <return-value transfer-ownership="container" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3999">a
         #GList of all #GParamSpecs owned by @owner_type in
         the pool#GParamSpecs.</doc>
          <type name="GLib.List" c:type="GList*" gs:is-pointer="1">
            <type name="ParamSpec" />
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="pool" transfer-ownership="none" gs:managed-name="pool" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3993">a #GParamSpecPool</doc>
            <type name="ParamSpecPool" c:type="GParamSpecPool*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="owner_type" transfer-ownership="none" gs:managed-name="ownerType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3994">the owner to look for</doc>
            <type name="GType" c:type="GType" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="owner_type" transfer-ownership="none" gs:managed-name="ownerType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3994">the owner to look for</doc>
            <type name="GType" c:type="GType" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="lookup" c:identifier="g_param_spec_pool_lookup" gs:dll-name="gobject-2.0" gs:managed-name="Lookup">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="4005">Looks up a #GParamSpec in the pool.</doc>
        <source-position filename="gparam.h" line="424" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="4015">The found #GParamSpec, or %NULL if no
matching #GParamSpec was found.</doc>
          <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="pool" transfer-ownership="none" gs:managed-name="pool" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4007">a #GParamSpecPool</doc>
            <type name="ParamSpecPool" c:type="GParamSpecPool*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="param_name" transfer-ownership="none" gs:managed-name="paramName" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4008">the name to look for</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="owner_type" transfer-ownership="none" gs:managed-name="ownerType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4009">the owner to look for</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="walk_ancestors" transfer-ownership="none" gs:managed-name="walkAncestors" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4010">If %TRUE, also try to find a #GParamSpec with @param_name
 owned by an ancestor of @owner_type.</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="param_name" transfer-ownership="none" gs:managed-name="paramName" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4008">the name to look for</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="owner_type" transfer-ownership="none" gs:managed-name="ownerType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4009">the owner to look for</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="walk_ancestors" transfer-ownership="none" gs:managed-name="walkAncestors" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4010">If %TRUE, also try to find a #GParamSpec with @param_name
 owned by an ancestor of @owner_type.</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="remove" c:identifier="g_param_spec_pool_remove" gs:dll-name="gobject-2.0" gs:managed-name="Remove">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="4035">Removes a #GParamSpec from the pool.</doc>
        <source-position filename="gparam.h" line="421" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="pool" transfer-ownership="none" gs:managed-name="pool" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4037">a #GParamSpecPool</doc>
            <type name="ParamSpecPool" c:type="GParamSpecPool*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4038">the #GParamSpec to remove</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4038">the #GParamSpec to remove</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
    </record>
    <class name="ParamSpecString" c:symbol-prefix="param_spec_string" c:type="GParamSpecString" parent="ParamSpec" glib:type-name="GParamString" glib:get-type="intern" glib:fundamental="1" gs:managed-name="ParamSpecString">
      <doc xml:space="preserve" filename="gparamspecs.h" line="844">A #GParamSpec derived structure that contains the meta data for string
properties.</doc>
      <field name="parent_instance" gs:managed-name="ParentInstance">
        <doc xml:space="preserve" filename="gparamspecs.h" line="846">private #GParamSpec portion</doc>
        <type name="ParamSpec" c:type="GParamSpec" />
      </field>
      <field name="default_value" gs:managed-name="DefaultValue">
        <doc xml:space="preserve" filename="gparamspecs.h" line="847">default value for the property specified</doc>
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </field>
      <field name="cset_first" gs:managed-name="CsetFirst">
        <doc xml:space="preserve" filename="gparamspecs.h" line="848">a string containing the allowed values for the first byte</doc>
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </field>
      <field name="cset_nth" gs:managed-name="CsetNth">
        <doc xml:space="preserve" filename="gparamspecs.h" line="849">a string containing the allowed values for the subsequent bytes</doc>
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </field>
      <field name="substitutor" gs:managed-name="Substitutor">
        <doc xml:space="preserve" filename="gparamspecs.h" line="850">the replacement byte for bytes which don't match @cset_first or @cset_nth.</doc>
        <type name="gchar" c:type="gchar" />
      </field>
      <field name="bits5" gs:managed-name="Bits5">
        <type name="guint" c:type="guint" />
        <gs:bits name="null_fold_if_empty" bits="1" gs:managed-name="NullFoldIfEmpty">
          <doc xml:space="preserve" filename="gparamspecs.h" line="851">replace empty string by %NULL</doc>
          <type name="guint" c:type="guint" />
        </gs:bits>
        <gs:bits name="ensure_non_null" bits="1" gs:managed-name="EnsureNonNull">
          <doc xml:space="preserve" filename="gparamspecs.h" line="852">replace %NULL strings by an empty string</doc>
          <type name="guint" c:type="guint" />
        </gs:bits>
      </field>
      <constructor name="new" c:identifier="g_param_spec_string" gs:dll-name="gobject-2.0" gs:managed-name="New">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="4124">Creates a new #GParamSpecString instance.

See g_param_spec_internal() for details on property names.</doc>
        <source-position filename="gparamspecs.h" line="1091" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="4136">a newly created parameter specification</doc>
          <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4126">canonical name of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="nick" transfer-ownership="none" gs:managed-name="nick" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4127">nick name for the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="blurb" transfer-ownership="none" gs:managed-name="blurb" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4128">description of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="default_value" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="defaultValue" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4129">default value for the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4130">flags for the property specified</doc>
            <type name="ParamFlags" c:type="GParamFlags" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4126">canonical name of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="nick" transfer-ownership="none" gs:managed-name="nick" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4127">nick name for the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="blurb" transfer-ownership="none" gs:managed-name="blurb" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4128">description of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="default_value" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="defaultValue" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4129">default value for the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4130">flags for the property specified</doc>
            <type name="ParamFlags" c:type="GParamFlags" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
    </class>
    <record name="ParamSpecTypeInfo" c:type="GParamSpecTypeInfo" gs:managed-name="ParamSpecTypeInfo">
      <doc xml:space="preserve" filename="gparam.h" line="352">This structure is used to provide the type system with the information
required to initialize and destruct (finalize) a parameter's class and
instances thereof.
The initialized structure is passed to the g_param_type_register_static()
The type system will perform a deep copy of this structure, so its memory
does not need to be persistent across invocation of
g_param_type_register_static().</doc>
      <source-position filename="gparam.h" line="393" />
      <field name="instance_size" writable="1" gs:managed-name="InstanceSize">
        <doc xml:space="preserve" filename="gparam.h" line="354">Size of the instance (object) structure.</doc>
        <type name="guint16" c:type="guint16" />
      </field>
      <field name="n_preallocs" writable="1" gs:managed-name="NPreallocs">
        <doc xml:space="preserve" filename="gparam.h" line="355">Prior to GLib 2.10, it specified the number of pre-allocated (cached) instances to reserve memory for (0 indicates no caching). Since GLib 2.10, it is ignored, since instances are allocated with the [slice allocator][glib-Memory-Slices] now.</doc>
        <type name="guint16" c:type="guint16" />
      </field>
      <field name="instance_init" gs:managed-name="InstanceInit">
        <callback name="instance_init" gs:dll-name="gobject-2.0" gs:managed-name="InstanceInit">
          <source-position filename="gparam.h" line="381" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
              <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
              <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="value_type" writable="1" gs:managed-name="ValueType">
        <doc xml:space="preserve" filename="gparam.h" line="357">The #GType of values conforming to this #GParamSpec</doc>
        <type name="GType" c:type="GType" />
      </field>
      <field name="finalize" gs:managed-name="Finalize">
        <callback name="finalize" gs:dll-name="gobject-2.0" gs:managed-name="Finalize">
          <source-position filename="gparam.h" line="385" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
              <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
              <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="value_set_default" gs:managed-name="ValueSetDefault">
        <callback name="value_set_default" gs:dll-name="gobject-2.0" gs:managed-name="ValueSetDefault">
          <source-position filename="gparam.h" line="386" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
              <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
            </parameter>
            <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
              <type name="Value" c:type="GValue*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
              <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
            </parameter>
            <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
              <type name="Value" c:type="GValue*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="value_validate" gs:managed-name="ValueValidate">
        <callback name="value_validate" gs:dll-name="gobject-2.0" gs:managed-name="ValueValidate">
          <source-position filename="gparam.h" line="388" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
              <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
            </parameter>
            <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
              <type name="Value" c:type="GValue*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
              <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
            </parameter>
            <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
              <type name="Value" c:type="GValue*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="values_cmp" gs:managed-name="ValuesCmp">
        <callback name="values_cmp" gs:dll-name="gobject-2.0" gs:managed-name="ValuesCmp">
          <source-position filename="gparam.h" line="390" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="gint" c:type="gint" />
          </return-value>
          <parameters>
            <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
              <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
            </parameter>
            <parameter name="value1" transfer-ownership="none" gs:managed-name="value1" direction="in">
              <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
            </parameter>
            <parameter name="value2" transfer-ownership="none" gs:managed-name="value2" direction="in">
              <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
              <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
            </parameter>
            <parameter name="value1" transfer-ownership="none" gs:managed-name="value1" direction="in">
              <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
            </parameter>
            <parameter name="value2" transfer-ownership="none" gs:managed-name="value2" direction="in">
              <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
    </record>
    <class name="ParamSpecUChar" c:symbol-prefix="param_spec_uchar" c:type="GParamSpecUChar" parent="ParamSpec" glib:type-name="GParamUChar" glib:get-type="intern" glib:fundamental="1" gs:managed-name="ParamSpecUChar">
      <doc xml:space="preserve" filename="gparamspecs.h" line="627">A #GParamSpec derived structure that contains the meta data for unsigned character properties.</doc>
      <field name="parent_instance" gs:managed-name="ParentInstance">
        <doc xml:space="preserve" filename="gparamspecs.h" line="629">private #GParamSpec portion</doc>
        <type name="ParamSpec" c:type="GParamSpec" />
      </field>
      <field name="minimum" gs:managed-name="Minimum">
        <doc xml:space="preserve" filename="gparamspecs.h" line="630">minimum value for the property specified</doc>
        <type name="guint8" c:type="guint8" />
      </field>
      <field name="maximum" gs:managed-name="Maximum">
        <doc xml:space="preserve" filename="gparamspecs.h" line="631">maximum value for the property specified</doc>
        <type name="guint8" c:type="guint8" />
      </field>
      <field name="default_value" gs:managed-name="DefaultValue">
        <doc xml:space="preserve" filename="gparamspecs.h" line="632">default value for the property specified</doc>
        <type name="guint8" c:type="guint8" />
      </field>
      <constructor name="new" c:identifier="g_param_spec_uchar" gs:dll-name="gobject-2.0" gs:managed-name="New">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="4140">Creates a new #GParamSpecUChar instance specifying a %G_TYPE_UCHAR property.</doc>
        <source-position filename="gparamspecs.h" line="993" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="4152">a newly created parameter specification</doc>
          <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4142">canonical name of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="nick" transfer-ownership="none" gs:managed-name="nick" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4143">nick name for the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="blurb" transfer-ownership="none" gs:managed-name="blurb" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4144">description of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="minimum" transfer-ownership="none" gs:managed-name="minimum" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4145">minimum value for the property specified</doc>
            <type name="guint8" c:type="guint8" />
          </parameter>
          <parameter name="maximum" transfer-ownership="none" gs:managed-name="maximum" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4146">maximum value for the property specified</doc>
            <type name="guint8" c:type="guint8" />
          </parameter>
          <parameter name="default_value" transfer-ownership="none" gs:managed-name="defaultValue" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4147">default value for the property specified</doc>
            <type name="guint8" c:type="guint8" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4148">flags for the property specified</doc>
            <type name="ParamFlags" c:type="GParamFlags" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4142">canonical name of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="nick" transfer-ownership="none" gs:managed-name="nick" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4143">nick name for the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="blurb" transfer-ownership="none" gs:managed-name="blurb" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4144">description of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="minimum" transfer-ownership="none" gs:managed-name="minimum" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4145">minimum value for the property specified</doc>
            <type name="guint8" c:type="guint8" />
          </parameter>
          <parameter name="maximum" transfer-ownership="none" gs:managed-name="maximum" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4146">maximum value for the property specified</doc>
            <type name="guint8" c:type="guint8" />
          </parameter>
          <parameter name="default_value" transfer-ownership="none" gs:managed-name="defaultValue" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4147">default value for the property specified</doc>
            <type name="guint8" c:type="guint8" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4148">flags for the property specified</doc>
            <type name="ParamFlags" c:type="GParamFlags" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
    </class>
    <class name="ParamSpecUInt" c:symbol-prefix="param_spec_uint" c:type="GParamSpecUInt" parent="ParamSpec" glib:type-name="GParamUInt" glib:get-type="intern" glib:fundamental="1" gs:managed-name="ParamSpecUInt">
      <doc xml:space="preserve" filename="gparamspecs.h" line="674">A #GParamSpec derived structure that contains the meta data for unsigned integer properties.</doc>
      <field name="parent_instance" gs:managed-name="ParentInstance">
        <doc xml:space="preserve" filename="gparamspecs.h" line="676">private #GParamSpec portion</doc>
        <type name="ParamSpec" c:type="GParamSpec" />
      </field>
      <field name="minimum" gs:managed-name="Minimum">
        <doc xml:space="preserve" filename="gparamspecs.h" line="677">minimum value for the property specified</doc>
        <type name="guint" c:type="guint" />
      </field>
      <field name="maximum" gs:managed-name="Maximum">
        <doc xml:space="preserve" filename="gparamspecs.h" line="678">maximum value for the property specified</doc>
        <type name="guint" c:type="guint" />
      </field>
      <field name="default_value" gs:managed-name="DefaultValue">
        <doc xml:space="preserve" filename="gparamspecs.h" line="679">default value for the property specified</doc>
        <type name="guint" c:type="guint" />
      </field>
      <constructor name="new" c:identifier="g_param_spec_uint" gs:dll-name="gobject-2.0" gs:managed-name="New">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="4156">Creates a new #GParamSpecUInt instance specifying a %G_TYPE_UINT property.

See g_param_spec_internal() for details on property names.</doc>
        <source-position filename="gparamspecs.h" line="1015" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="4170">a newly created parameter specification</doc>
          <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4158">canonical name of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="nick" transfer-ownership="none" gs:managed-name="nick" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4159">nick name for the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="blurb" transfer-ownership="none" gs:managed-name="blurb" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4160">description of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="minimum" transfer-ownership="none" gs:managed-name="minimum" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4161">minimum value for the property specified</doc>
            <type name="guint" c:type="guint" />
          </parameter>
          <parameter name="maximum" transfer-ownership="none" gs:managed-name="maximum" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4162">maximum value for the property specified</doc>
            <type name="guint" c:type="guint" />
          </parameter>
          <parameter name="default_value" transfer-ownership="none" gs:managed-name="defaultValue" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4163">default value for the property specified</doc>
            <type name="guint" c:type="guint" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4164">flags for the property specified</doc>
            <type name="ParamFlags" c:type="GParamFlags" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4158">canonical name of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="nick" transfer-ownership="none" gs:managed-name="nick" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4159">nick name for the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="blurb" transfer-ownership="none" gs:managed-name="blurb" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4160">description of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="minimum" transfer-ownership="none" gs:managed-name="minimum" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4161">minimum value for the property specified</doc>
            <type name="guint" c:type="guint" />
          </parameter>
          <parameter name="maximum" transfer-ownership="none" gs:managed-name="maximum" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4162">maximum value for the property specified</doc>
            <type name="guint" c:type="guint" />
          </parameter>
          <parameter name="default_value" transfer-ownership="none" gs:managed-name="defaultValue" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4163">default value for the property specified</doc>
            <type name="guint" c:type="guint" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4164">flags for the property specified</doc>
            <type name="ParamFlags" c:type="GParamFlags" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
    </class>
    <class name="ParamSpecUInt64" c:symbol-prefix="param_spec_uint64" c:type="GParamSpecUInt64" parent="ParamSpec" glib:type-name="GParamUInt64" glib:get-type="intern" glib:fundamental="1" gs:managed-name="ParamSpecUInt64">
      <doc xml:space="preserve" filename="gparamspecs.h" line="742">A #GParamSpec derived structure that contains the meta data for unsigned 64bit integer properties.</doc>
      <field name="parent_instance" gs:managed-name="ParentInstance">
        <doc xml:space="preserve" filename="gparamspecs.h" line="744">private #GParamSpec portion</doc>
        <type name="ParamSpec" c:type="GParamSpec" />
      </field>
      <field name="minimum" gs:managed-name="Minimum">
        <doc xml:space="preserve" filename="gparamspecs.h" line="745">minimum value for the property specified</doc>
        <type name="guint64" c:type="guint64" />
      </field>
      <field name="maximum" gs:managed-name="Maximum">
        <doc xml:space="preserve" filename="gparamspecs.h" line="746">maximum value for the property specified</doc>
        <type name="guint64" c:type="guint64" />
      </field>
      <field name="default_value" gs:managed-name="DefaultValue">
        <doc xml:space="preserve" filename="gparamspecs.h" line="747">default value for the property specified</doc>
        <type name="guint64" c:type="guint64" />
      </field>
      <constructor name="new" c:identifier="g_param_spec_uint64" gs:dll-name="gobject-2.0" gs:managed-name="New">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="4174">Creates a new #GParamSpecUInt64 instance specifying a %G_TYPE_UINT64
property.

See g_param_spec_internal() for details on property names.</doc>
        <source-position filename="gparamspecs.h" line="1047" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="4189">a newly created parameter specification</doc>
          <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4176">canonical name of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="nick" transfer-ownership="none" gs:managed-name="nick" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4177">nick name for the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="blurb" transfer-ownership="none" gs:managed-name="blurb" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4178">description of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="minimum" transfer-ownership="none" gs:managed-name="minimum" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4179">minimum value for the property specified</doc>
            <type name="guint64" c:type="guint64" />
          </parameter>
          <parameter name="maximum" transfer-ownership="none" gs:managed-name="maximum" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4180">maximum value for the property specified</doc>
            <type name="guint64" c:type="guint64" />
          </parameter>
          <parameter name="default_value" transfer-ownership="none" gs:managed-name="defaultValue" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4181">default value for the property specified</doc>
            <type name="guint64" c:type="guint64" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4182">flags for the property specified</doc>
            <type name="ParamFlags" c:type="GParamFlags" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4176">canonical name of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="nick" transfer-ownership="none" gs:managed-name="nick" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4177">nick name for the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="blurb" transfer-ownership="none" gs:managed-name="blurb" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4178">description of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="minimum" transfer-ownership="none" gs:managed-name="minimum" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4179">minimum value for the property specified</doc>
            <type name="guint64" c:type="guint64" />
          </parameter>
          <parameter name="maximum" transfer-ownership="none" gs:managed-name="maximum" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4180">maximum value for the property specified</doc>
            <type name="guint64" c:type="guint64" />
          </parameter>
          <parameter name="default_value" transfer-ownership="none" gs:managed-name="defaultValue" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4181">default value for the property specified</doc>
            <type name="guint64" c:type="guint64" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4182">flags for the property specified</doc>
            <type name="ParamFlags" c:type="GParamFlags" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
    </class>
    <class name="ParamSpecULong" c:symbol-prefix="param_spec_ulong" c:type="GParamSpecULong" parent="ParamSpec" glib:type-name="GParamULong" glib:get-type="intern" glib:fundamental="1" gs:managed-name="ParamSpecULong">
      <doc xml:space="preserve" filename="gparamspecs.h" line="708">A #GParamSpec derived structure that contains the meta data for unsigned long integer properties.</doc>
      <field name="parent_instance" gs:managed-name="ParentInstance">
        <doc xml:space="preserve" filename="gparamspecs.h" line="710">private #GParamSpec portion</doc>
        <type name="ParamSpec" c:type="GParamSpec" />
      </field>
      <field name="minimum" gs:managed-name="Minimum">
        <doc xml:space="preserve" filename="gparamspecs.h" line="711">minimum value for the property specified</doc>
        <type name="gulong" c:type="gulong" />
      </field>
      <field name="maximum" gs:managed-name="Maximum">
        <doc xml:space="preserve" filename="gparamspecs.h" line="712">maximum value for the property specified</doc>
        <type name="gulong" c:type="gulong" />
      </field>
      <field name="default_value" gs:managed-name="DefaultValue">
        <doc xml:space="preserve" filename="gparamspecs.h" line="713">default value for the property specified</doc>
        <type name="gulong" c:type="gulong" />
      </field>
      <constructor name="new" c:identifier="g_param_spec_ulong" gs:dll-name="gobject-2.0" gs:managed-name="New">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="4193">Creates a new #GParamSpecULong instance specifying a %G_TYPE_ULONG
property.

See g_param_spec_internal() for details on property names.</doc>
        <source-position filename="gparamspecs.h" line="1031" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="4208">a newly created parameter specification</doc>
          <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4195">canonical name of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="nick" transfer-ownership="none" gs:managed-name="nick" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4196">nick name for the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="blurb" transfer-ownership="none" gs:managed-name="blurb" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4197">description of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="minimum" transfer-ownership="none" gs:managed-name="minimum" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4198">minimum value for the property specified</doc>
            <type name="gulong" c:type="gulong" />
          </parameter>
          <parameter name="maximum" transfer-ownership="none" gs:managed-name="maximum" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4199">maximum value for the property specified</doc>
            <type name="gulong" c:type="gulong" />
          </parameter>
          <parameter name="default_value" transfer-ownership="none" gs:managed-name="defaultValue" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4200">default value for the property specified</doc>
            <type name="gulong" c:type="gulong" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4201">flags for the property specified</doc>
            <type name="ParamFlags" c:type="GParamFlags" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4195">canonical name of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="nick" transfer-ownership="none" gs:managed-name="nick" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4196">nick name for the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="blurb" transfer-ownership="none" gs:managed-name="blurb" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4197">description of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="minimum" transfer-ownership="none" gs:managed-name="minimum" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4198">minimum value for the property specified</doc>
            <type name="gulong" c:type="gulong" />
          </parameter>
          <parameter name="maximum" transfer-ownership="none" gs:managed-name="maximum" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4199">maximum value for the property specified</doc>
            <type name="gulong" c:type="gulong" />
          </parameter>
          <parameter name="default_value" transfer-ownership="none" gs:managed-name="defaultValue" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4200">default value for the property specified</doc>
            <type name="gulong" c:type="gulong" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4201">flags for the property specified</doc>
            <type name="ParamFlags" c:type="GParamFlags" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
    </class>
    <class name="ParamSpecUnichar" c:symbol-prefix="param_spec_unichar" c:type="GParamSpecUnichar" parent="ParamSpec" glib:type-name="GParamUnichar" glib:get-type="intern" glib:fundamental="1" gs:managed-name="ParamSpecUnichar">
      <doc xml:space="preserve" filename="gparamspecs.h" line="759">A #GParamSpec derived structure that contains the meta data for unichar (unsigned integer) properties.</doc>
      <field name="parent_instance" gs:managed-name="ParentInstance">
        <doc xml:space="preserve" filename="gparamspecs.h" line="761">private #GParamSpec portion</doc>
        <type name="ParamSpec" c:type="GParamSpec" />
      </field>
      <field name="default_value" gs:managed-name="DefaultValue">
        <doc xml:space="preserve" filename="gparamspecs.h" line="762">default value for the property specified</doc>
        <type name="gunichar" c:type="gunichar" />
      </field>
      <constructor name="new" c:identifier="g_param_spec_unichar" gs:dll-name="gobject-2.0" gs:managed-name="New">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="4212">Creates a new #GParamSpecUnichar instance specifying a %G_TYPE_UINT
property. #GValue structures for this property can be accessed with
g_value_set_uint() and g_value_get_uint().

See g_param_spec_internal() for details on property names.</doc>
        <source-position filename="gparamspecs.h" line="1055" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="4226">a newly created parameter specification</doc>
          <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4214">canonical name of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="nick" transfer-ownership="none" gs:managed-name="nick" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4215">nick name for the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="blurb" transfer-ownership="none" gs:managed-name="blurb" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4216">description of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="default_value" transfer-ownership="none" gs:managed-name="defaultValue" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4217">default value for the property specified</doc>
            <type name="gunichar" c:type="gunichar" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4218">flags for the property specified</doc>
            <type name="ParamFlags" c:type="GParamFlags" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4214">canonical name of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="nick" transfer-ownership="none" gs:managed-name="nick" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4215">nick name for the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="blurb" transfer-ownership="none" gs:managed-name="blurb" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4216">description of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="default_value" transfer-ownership="none" gs:managed-name="defaultValue" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4217">default value for the property specified</doc>
            <type name="gunichar" c:type="gunichar" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4218">flags for the property specified</doc>
            <type name="ParamFlags" c:type="GParamFlags" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
    </class>
    <class name="ParamSpecValueArray" c:symbol-prefix="param_spec_value_array" c:type="GParamSpecValueArray" parent="ParamSpec" glib:type-name="GParamValueArray" glib:get-type="intern" glib:fundamental="1" gs:managed-name="ParamSpecValueArray">
      <doc xml:space="preserve" filename="gparamspecs.h" line="899">A #GParamSpec derived structure that contains the meta data for #GValueArray properties.</doc>
      <field name="parent_instance" gs:managed-name="ParentInstance">
        <doc xml:space="preserve" filename="gparamspecs.h" line="901">private #GParamSpec portion</doc>
        <type name="ParamSpec" c:type="GParamSpec" />
      </field>
      <field name="element_spec" gs:managed-name="ElementSpec">
        <doc xml:space="preserve" filename="gparamspecs.h" line="902">a #GParamSpec describing the elements contained in arrays of this property, may be %NULL</doc>
        <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
      </field>
      <field name="fixed_n_elements" gs:managed-name="FixedNElements">
        <doc xml:space="preserve" filename="gparamspecs.h" line="903">if greater than 0, arrays of this property will always have this many elements</doc>
        <type name="guint" c:type="guint" />
      </field>
    </class>
    <class name="ParamSpecVariant" c:symbol-prefix="param_spec_variant" c:type="GParamSpecVariant" version="2.26" parent="ParamSpec" glib:type-name="GParamVariant" glib:get-type="intern" glib:fundamental="1" gs:managed-name="ParamSpecVariant">
      <doc xml:space="preserve" filename="gparamspecs.h" line="957">A #GParamSpec derived structure that contains the meta data for #GVariant properties.

When comparing values with g_param_values_cmp(), scalar values with the same
type will be compared with g_variant_compare(). Other non-%NULL variants will
be checked for equality with g_variant_equal(), and their sort order is
otherwise undefined. %NULL is ordered before non-%NULL variants. Two %NULL
values compare equal.</doc>
      <field name="parent_instance" gs:managed-name="ParentInstance">
        <doc xml:space="preserve" filename="gparamspecs.h" line="959">private #GParamSpec portion</doc>
        <type name="ParamSpec" c:type="GParamSpec" />
      </field>
      <field name="type" gs:managed-name="Type">
        <doc xml:space="preserve" filename="gparamspecs.h" line="960">a #GVariantType, or %NULL</doc>
        <type name="GLib.VariantType" c:type="GVariantType*" gs:is-pointer="1" />
      </field>
      <field name="default_value" gs:managed-name="DefaultValue">
        <doc xml:space="preserve" filename="gparamspecs.h" line="961">a #GVariant, or %NULL</doc>
        <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
      </field>
      <field name="padding0" readable="0" private="1" gs:managed-name="Padding0">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="padding1" readable="0" private="1" gs:managed-name="Padding1">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="padding2" readable="0" private="1" gs:managed-name="Padding2">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="padding3" readable="0" private="1" gs:managed-name="Padding3">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <constructor name="new" c:identifier="g_param_spec_variant" version="2.26" gs:dll-name="gobject-2.0" gs:managed-name="New">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="4258">Creates a new #GParamSpecVariant instance specifying a #GVariant
property.

If @default_value is floating, it is consumed.

See g_param_spec_internal() for details on property names.</doc>
        <source-position filename="gparamspecs.h" line="1135" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="4275">the newly created #GParamSpec</doc>
          <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4260">canonical name of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="nick" transfer-ownership="none" gs:managed-name="nick" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4261">nick name for the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="blurb" transfer-ownership="none" gs:managed-name="blurb" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4262">description of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4263">a #GVariantType</doc>
            <type name="GLib.VariantType" c:type="const GVariantType*" gs:is-pointer="1" />
          </parameter>
          <parameter name="default_value" transfer-ownership="full" nullable="1" allow-none="1" gs:managed-name="defaultValue" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4264">a #GVariant of type @type to
                use as the default value, or %NULL</doc>
            <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4266">flags for the property specified</doc>
            <type name="ParamFlags" c:type="GParamFlags" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4260">canonical name of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="nick" transfer-ownership="none" gs:managed-name="nick" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4261">nick name for the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="blurb" transfer-ownership="none" gs:managed-name="blurb" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4262">description of the property specified</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4263">a #GVariantType</doc>
            <type name="GLib.VariantType" c:type="const GVariantType*" gs:is-pointer="1" />
          </parameter>
          <parameter name="default_value" transfer-ownership="full" nullable="1" allow-none="1" gs:managed-name="defaultValue" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4264">a #GVariant of type @type to
                use as the default value, or %NULL</doc>
            <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4266">flags for the property specified</doc>
            <type name="ParamFlags" c:type="GParamFlags" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
    </class>
    <record name="Parameter" c:type="GParameter" deprecated="1" deprecated-version="2.54" gs:managed-name="Parameter">
      <doc xml:space="preserve" filename="gparam.h" line="261">The GParameter struct is an auxiliary structure used
to hand parameter name/value pairs to g_object_newv().</doc>
      <doc-deprecated xml:space="preserve">This type is not introspectable.</doc-deprecated>
      <source-position filename="gparam.h" line="275" />
      <field name="name" writable="1" gs:managed-name="Name">
        <doc xml:space="preserve" filename="gparam.h" line="263">the parameter name</doc>
        <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
      </field>
      <field name="value" writable="1" gs:managed-name="Value">
        <doc xml:space="preserve" filename="gparam.h" line="264">the parameter value</doc>
        <type name="Value" c:type="GValue" />
      </field>
    </record>
    <callback name="SignalAccumulator" c:type="GSignalAccumulator" gs:dll-name="gobject-2.0" gs:managed-name="SignalAccumulator">
      <doc xml:space="preserve" filename="gsignal.h" line="74">The signal accumulator is a special callback function that can be used
to collect return values of the various callbacks that are called
during a signal emission. The signal accumulator is specified at signal
creation time, if it is left %NULL, no accumulation of callback return
values is performed. The return value of signal emissions is then the
value returned by the last callback.</doc>
      <source-position filename="gsignal.h" line="93" />
      <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
        <doc xml:space="preserve" filename="gsignal.h" line="89">The accumulator function returns whether the signal emission
 should be aborted. Returning %FALSE means to abort the
 current emission and %TRUE is returned for continuation.</doc>
        <type name="gboolean" c:type="gboolean" />
      </return-value>
      <parameters>
        <parameter name="ihint" transfer-ownership="none" gs:managed-name="ihint" direction="in">
          <doc xml:space="preserve" filename="gsignal.h" line="76">Signal invocation hint, see #GSignalInvocationHint.</doc>
          <type name="SignalInvocationHint" c:type="GSignalInvocationHint*" gs:is-pointer="1" />
        </parameter>
        <parameter name="return_accu" transfer-ownership="none" gs:managed-name="returnAccu" direction="in">
          <doc xml:space="preserve" filename="gsignal.h" line="77">Accumulator to collect callback return values in, this
 is the return value of the current signal emission.</doc>
          <type name="Value" c:type="GValue*" gs:is-pointer="1" />
        </parameter>
        <parameter name="handler_return" transfer-ownership="none" gs:managed-name="handlerReturn" direction="in">
          <doc xml:space="preserve" filename="gsignal.h" line="79">A #GValue holding the return value of the signal handler.</doc>
          <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
        </parameter>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
          <doc xml:space="preserve" filename="gsignal.h" line="80">Callback data that was specified when creating the signal.</doc>
          <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
        </parameter>
      </parameters>
      <gs:managed-parameters>
        <parameter name="ihint" transfer-ownership="none" gs:managed-name="ihint" direction="in">
          <doc xml:space="preserve" filename="gsignal.h" line="76">Signal invocation hint, see #GSignalInvocationHint.</doc>
          <type name="SignalInvocationHint" c:type="GSignalInvocationHint*" gs:is-pointer="1" />
        </parameter>
        <parameter name="return_accu" transfer-ownership="none" gs:managed-name="returnAccu" direction="in">
          <doc xml:space="preserve" filename="gsignal.h" line="77">Accumulator to collect callback return values in, this
 is the return value of the current signal emission.</doc>
          <type name="Value" c:type="GValue*" gs:is-pointer="1" />
        </parameter>
        <parameter name="handler_return" transfer-ownership="none" gs:managed-name="handlerReturn" direction="in">
          <doc xml:space="preserve" filename="gsignal.h" line="79">A #GValue holding the return value of the signal handler.</doc>
          <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
        </parameter>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
          <doc xml:space="preserve" filename="gsignal.h" line="80">Callback data that was specified when creating the signal.</doc>
          <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
        </parameter>
      </gs:managed-parameters>
    </callback>
    <callback name="SignalEmissionHook" c:type="GSignalEmissionHook" gs:dll-name="gobject-2.0" gs:managed-name="SignalEmissionHook">
      <doc xml:space="preserve" filename="gsignal.h" line="52">A simple function pointer to get invoked when the signal is emitted. This
allows you to tie a hook to the signal type, so that it will trap all
emissions of that signal, from any object.

You may not attach these to signals created with the #G_SIGNAL_NO_HOOKS flag.</doc>
      <source-position filename="gsignal.h" line="70" />
      <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
        <doc xml:space="preserve" filename="gsignal.h" line="67">whether it wants to stay connected. If it returns %FALSE, the signal
 hook is disconnected (and destroyed).</doc>
        <type name="gboolean" c:type="gboolean" />
      </return-value>
      <parameters>
        <parameter name="ihint" transfer-ownership="none" gs:managed-name="ihint" direction="in">
          <doc xml:space="preserve" filename="gsignal.h" line="54">Signal invocation hint, see #GSignalInvocationHint.</doc>
          <type name="SignalInvocationHint" c:type="GSignalInvocationHint*" gs:is-pointer="1" />
        </parameter>
        <parameter name="n_param_values" transfer-ownership="none" gs:managed-name="nParamValues" direction="in">
          <doc xml:space="preserve" filename="gsignal.h" line="55">the number of parameters to the function, including
 the instance on which the signal was emitted.</doc>
          <type name="guint" c:type="guint" />
        </parameter>
        <parameter name="param_values" transfer-ownership="none" gs:managed-name="paramValues" direction="in">
          <doc xml:space="preserve" filename="gsignal.h" line="57">the instance on which
 the signal was emitted, followed by the parameters of the emission.</doc>
          <array length="1" zero-terminated="0" c:type="const GValue*" gs:is-pointer="1">
            <type name="Value" c:type="GValue" />
          </array>
        </parameter>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" closure="3" gs:managed-name="data" direction="in">
          <doc xml:space="preserve" filename="gsignal.h" line="59">user data associated with the hook.</doc>
          <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
        </parameter>
      </parameters>
      <gs:managed-parameters>
        <parameter name="ihint" transfer-ownership="none" gs:managed-name="ihint" direction="in">
          <doc xml:space="preserve" filename="gsignal.h" line="54">Signal invocation hint, see #GSignalInvocationHint.</doc>
          <type name="SignalInvocationHint" c:type="GSignalInvocationHint*" gs:is-pointer="1" />
        </parameter>
        <parameter name="param_values" transfer-ownership="none" gs:managed-name="paramValues" direction="in">
          <doc xml:space="preserve" filename="gsignal.h" line="57">the instance on which
 the signal was emitted, followed by the parameters of the emission.</doc>
          <array length="1" zero-terminated="0" c:type="const GValue*" gs:is-pointer="1">
            <type name="Value" c:type="GValue" />
          </array>
        </parameter>
      </gs:managed-parameters>
    </callback>
    <bitfield name="SignalFlags" c:type="GSignalFlags" gs:managed-name="SignalFlags">
      <doc xml:space="preserve" filename="gsignal.h" line="100">The signal flags are used to specify a signal's behaviour, the overall
signal description outlines how especially the RUN flags control the
stages of a signal emission.</doc>
      <source-position filename="gsignal.h" line="138" />
      <member name="run_first" value="1" c:identifier="G_SIGNAL_RUN_FIRST" gs:managed-name="RunFirst">
        <doc xml:space="preserve" filename="gsignal.h" line="102">Invoke the object method handler in the first emission stage.</doc>
      </member>
      <member name="run_last" value="2" c:identifier="G_SIGNAL_RUN_LAST" gs:managed-name="RunLast">
        <doc xml:space="preserve" filename="gsignal.h" line="103">Invoke the object method handler in the third emission stage.</doc>
      </member>
      <member name="run_cleanup" value="4" c:identifier="G_SIGNAL_RUN_CLEANUP" gs:managed-name="RunCleanup">
        <doc xml:space="preserve" filename="gsignal.h" line="104">Invoke the object method handler in the last emission stage.</doc>
      </member>
      <member name="no_recurse" value="8" c:identifier="G_SIGNAL_NO_RECURSE" gs:managed-name="NoRecurse">
        <doc xml:space="preserve" filename="gsignal.h" line="105">Signals being emitted for an object while currently being in
 emission for this very object will not be emitted recursively,
 but instead cause the first emission to be restarted.</doc>
      </member>
      <member name="detailed" value="16" c:identifier="G_SIGNAL_DETAILED" gs:managed-name="Detailed">
        <doc xml:space="preserve" filename="gsignal.h" line="108">This signal supports "::detail" appendices to the signal name
 upon handler connections and emissions.</doc>
      </member>
      <member name="action" value="32" c:identifier="G_SIGNAL_ACTION" gs:managed-name="Action">
        <doc xml:space="preserve" filename="gsignal.h" line="110">Action signals are signals that may freely be emitted on alive
 objects from user code via g_signal_emit() and friends, without
 the need of being embedded into extra code that performs pre or
 post emission adjustments on the object. They can also be thought
 of as object methods which can be called generically by
 third-party code.</doc>
      </member>
      <member name="no_hooks" value="64" c:identifier="G_SIGNAL_NO_HOOKS" gs:managed-name="NoHooks">
        <doc xml:space="preserve" filename="gsignal.h" line="116">No emissions hooks are supported for this signal.</doc>
      </member>
      <member name="must_collect" value="128" c:identifier="G_SIGNAL_MUST_COLLECT" version="2.30" gs:managed-name="MustCollect">
        <doc xml:space="preserve" filename="gsignal.h" line="117">Varargs signal emission will always collect the
  arguments, even if there are no signal handlers connected.</doc>
      </member>
      <member name="deprecated" value="256" c:identifier="G_SIGNAL_DEPRECATED" version="2.32" gs:managed-name="Deprecated">
        <doc xml:space="preserve" filename="gsignal.h" line="119">The signal is deprecated and will be removed
  in a future version. A warning will be generated if it is connected while
  running with G_ENABLE_DIAGNOSTIC=1.</doc>
      </member>
    </bitfield>
    <record name="SignalInvocationHint" c:type="GSignalInvocationHint" gs:managed-name="SignalInvocationHint">
      <doc xml:space="preserve" filename="gsignal.h" line="212">The #GSignalInvocationHint structure is used to pass on additional information
to callbacks during a signal emission.</doc>
      <source-position filename="gsignal.h" line="228" />
      <field name="signal_id" writable="1" gs:managed-name="SignalId">
        <doc xml:space="preserve" filename="gsignal.h" line="214">The signal id of the signal invoking the callback</doc>
        <type name="guint" c:type="guint" />
      </field>
      <field name="detail" writable="1" gs:managed-name="Detail">
        <doc xml:space="preserve" filename="gsignal.h" line="215">The detail passed on for this emission</doc>
        <type name="GLib.Quark" c:type="GQuark" />
      </field>
      <field name="run_type" writable="1" gs:managed-name="RunType">
        <doc xml:space="preserve" filename="gsignal.h" line="216">The stage the signal emission is currently in, this
 field will contain one of %G_SIGNAL_RUN_FIRST,
 %G_SIGNAL_RUN_LAST or %G_SIGNAL_RUN_CLEANUP.</doc>
        <type name="SignalFlags" c:type="GSignalFlags" />
      </field>
    </record>
    <bitfield name="SignalMatchType" c:type="GSignalMatchType" gs:managed-name="SignalMatchType">
      <doc xml:space="preserve" filename="gsignal.h" line="160">The match types specify what g_signal_handlers_block_matched(),
g_signal_handlers_unblock_matched() and g_signal_handlers_disconnect_matched()
match signals by.</doc>
      <source-position filename="gsignal.h" line="181" />
      <member name="id" value="1" c:identifier="G_SIGNAL_MATCH_ID" gs:managed-name="Id">
        <doc xml:space="preserve" filename="gsignal.h" line="162">The signal id must be equal.</doc>
      </member>
      <member name="detail" value="2" c:identifier="G_SIGNAL_MATCH_DETAIL" gs:managed-name="Detail">
        <doc xml:space="preserve" filename="gsignal.h" line="163">The signal detail must be equal.</doc>
      </member>
      <member name="closure" value="4" c:identifier="G_SIGNAL_MATCH_CLOSURE" gs:managed-name="Closure">
        <doc xml:space="preserve" filename="gsignal.h" line="164">The closure must be the same.</doc>
      </member>
      <member name="func" value="8" c:identifier="G_SIGNAL_MATCH_FUNC" gs:managed-name="Func">
        <doc xml:space="preserve" filename="gsignal.h" line="165">The C closure callback must be the same.</doc>
      </member>
      <member name="data" value="16" c:identifier="G_SIGNAL_MATCH_DATA" gs:managed-name="Data">
        <doc xml:space="preserve" filename="gsignal.h" line="166">The closure data must be the same.</doc>
      </member>
      <member name="unblocked" value="32" c:identifier="G_SIGNAL_MATCH_UNBLOCKED" gs:managed-name="Unblocked">
        <doc xml:space="preserve" filename="gsignal.h" line="167">Only unblocked signals may be matched.</doc>
      </member>
    </bitfield>
    <record name="SignalQuery" c:type="GSignalQuery" gs:managed-name="SignalQuery">
      <doc xml:space="preserve" filename="gsignal.h" line="229">A structure holding in-depth information for a specific signal. It is
filled in by the g_signal_query() function.</doc>
      <source-position filename="gsignal.h" line="258" />
      <field name="signal_id" writable="1" gs:managed-name="SignalId">
        <doc xml:space="preserve" filename="gsignal.h" line="231">The signal id of the signal being queried, or 0 if the
 signal to be queried was unknown.</doc>
        <type name="guint" c:type="guint" />
      </field>
      <field name="signal_name" writable="1" gs:managed-name="SignalName">
        <doc xml:space="preserve" filename="gsignal.h" line="233">The signal name.</doc>
        <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
      </field>
      <field name="itype" writable="1" gs:managed-name="Itype">
        <doc xml:space="preserve" filename="gsignal.h" line="234">The interface/instance type that this signal can be emitted for.</doc>
        <type name="GType" c:type="GType" />
      </field>
      <field name="signal_flags" writable="1" gs:managed-name="SignalFlags">
        <doc xml:space="preserve" filename="gsignal.h" line="235">The signal flags as passed in to g_signal_new().</doc>
        <type name="SignalFlags" c:type="GSignalFlags" />
      </field>
      <field name="return_type" writable="1" gs:managed-name="ReturnType">
        <doc xml:space="preserve" filename="gsignal.h" line="236">The return type for user callbacks.</doc>
        <type name="GType" c:type="GType" />
      </field>
      <field name="n_params" writable="1" gs:managed-name="NParams">
        <doc xml:space="preserve" filename="gsignal.h" line="237">The number of parameters that user callbacks take.</doc>
        <type name="guint" c:type="guint" />
      </field>
      <field name="param_types" writable="1" gs:managed-name="ParamTypes">
        <doc xml:space="preserve" filename="gsignal.h" line="238">The individual parameter types for
 user callbacks, note that the effective callback signature is:
 |[&lt;!-- language="C" --&gt;
 @return_type callback (#gpointer     data1,
 [param_types param_names,]
 gpointer     data2);
 ]|</doc>
        <array length="5" zero-terminated="0" c:type="const GType*" gs:is-pointer="1">
          <type name="GType" c:type="GType" />
        </array>
      </field>
    </record>
    <callback name="ToggleNotify" c:type="GToggleNotify" gs:dll-name="gobject-2.0" gs:managed-name="ToggleNotify">
      <doc xml:space="preserve" filename="gobject.h" line="522">A callback function used for notification when the state
of a toggle reference changes. See g_object_add_toggle_ref().</doc>
      <source-position filename="gobject.h" line="534" />
      <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
        <type name="none" c:type="void" />
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
          <doc xml:space="preserve" filename="gobject.h" line="524">Callback data passed to g_object_add_toggle_ref()</doc>
          <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
        </parameter>
        <parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
          <doc xml:space="preserve" filename="gobject.h" line="525">The object on which g_object_add_toggle_ref() was called.</doc>
          <type name="Object" c:type="GObject*" gs:is-pointer="1" />
        </parameter>
        <parameter name="is_last_ref" transfer-ownership="none" gs:managed-name="isLastRef" direction="in">
          <doc xml:space="preserve" filename="gobject.h" line="526">%TRUE if the toggle reference is now the
 last reference to the object. %FALSE if the toggle
 reference was the last reference and there are now other
 references.</doc>
          <type name="gboolean" c:type="gboolean" />
        </parameter>
      </parameters>
      <gs:managed-parameters>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
          <doc xml:space="preserve" filename="gobject.h" line="524">Callback data passed to g_object_add_toggle_ref()</doc>
          <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
        </parameter>
        <parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
          <doc xml:space="preserve" filename="gobject.h" line="525">The object on which g_object_add_toggle_ref() was called.</doc>
          <type name="Object" c:type="GObject*" gs:is-pointer="1" />
        </parameter>
        <parameter name="is_last_ref" transfer-ownership="none" gs:managed-name="isLastRef" direction="in">
          <doc xml:space="preserve" filename="gobject.h" line="526">%TRUE if the toggle reference is now the
 last reference to the object. %FALSE if the toggle
 reference was the last reference and there are now other
 references.</doc>
          <type name="gboolean" c:type="gboolean" />
        </parameter>
      </gs:managed-parameters>
    </callback>
    <union name="TypeCValue" c:type="GTypeCValue" gs:managed-name="TypeCValue">
      <source-position filename="gtype.h" line="389" />
    </union>
    <record name="TypeClass" c:type="GTypeClass" disguised="1" gs:inheritance-modifiers="abstract" gs:custom-default-constructor="1" gs:managed-name="TypeClass">
      <doc xml:space="preserve" filename="gtype.h" line="403">An opaque structure used as the base of all classes.</doc>
      <source-position filename="gtype.h" line="412" />
      <field name="g_type" readable="0" private="1" gs:managed-name="GType">
        <type name="GType" c:type="GType" />
      </field>
      <method name="add_private" c:identifier="g_type_class_add_private" version="2.4" deprecated="1" deprecated-version="2.58" gs:dll-name="gobject-2.0" gs:managed-name="AddPrivate">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="5303">Registers a private structure for an instantiatable type.

When an object is allocated, the private structures for
the type and all of its parent types are allocated
sequentially in the same memory block as the public
structures, and are zero-filled.

Note that the accumulated size of the private structures of
a type and all its parent types cannot exceed 64 KiB.

This function should be called in the type's class_init() function.
The private structure can be retrieved using the
G_TYPE_INSTANCE_GET_PRIVATE() macro.

The following example shows attaching a private structure
MyObjectPrivate to an object MyObject defined in the standard
GObject fashion in the type's class_init() function.

Note the use of a structure member "priv" to avoid the overhead
of repeatedly calling MY_OBJECT_GET_PRIVATE().

|[&lt;!-- language="C" --&gt;
typedef struct _MyObject        MyObject;
typedef struct _MyObjectPrivate MyObjectPrivate;

struct _MyObject {
 GObject parent;

 MyObjectPrivate *priv;
};

struct _MyObjectPrivate {
  int some_field;
};

static void
my_object_class_init (MyObjectClass *klass)
{
  g_type_class_add_private (klass, sizeof (MyObjectPrivate));
}

static void
my_object_init (MyObject *my_object)
{
  my_object-&gt;priv = G_TYPE_INSTANCE_GET_PRIVATE (my_object,
                                                 MY_TYPE_OBJECT,
                                                 MyObjectPrivate);
  // my_object-&gt;priv-&gt;some_field will be automatically initialised to 0
}

static int
my_object_get_some_field (MyObject *my_object)
{
  MyObjectPrivate *priv;

  g_return_val_if_fail (MY_IS_OBJECT (my_object), 0);

  priv = my_object-&gt;priv;

  return priv-&gt;some_field;
}
]|</doc>
        <doc-deprecated xml:space="preserve">Use the G_ADD_PRIVATE() macro with the `G_DEFINE_*`
  family of macros to add instance private data to a type</doc-deprecated>
        <source-position filename="gtype.h" line="1304" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="g_class" transfer-ownership="none" gs:managed-name="gClass" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5305">class structure for an instantiatable
   type</doc>
            <type name="TypeClass" c:type="gpointer" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="private_size" transfer-ownership="none" gs:managed-name="privateSize" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5307">size of private structure</doc>
            <type name="gsize" c:type="gsize" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="private_size" transfer-ownership="none" gs:managed-name="privateSize" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5307">size of private structure</doc>
            <type name="gsize" c:type="gsize" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_private" c:identifier="g_type_class_get_private" gs:dll-name="gobject-2.0" gs:managed-name="GetPrivate">
        <source-position filename="gtype.h" line="1320" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="klass" transfer-ownership="none" gs:managed-name="klass" direction="in">
            <type name="TypeClass" c:type="GTypeClass*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="private_type" transfer-ownership="none" gs:managed-name="privateType" direction="in">
            <type name="GType" c:type="GType" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="private_type" transfer-ownership="none" gs:managed-name="privateType" direction="in">
            <type name="GType" c:type="GType" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="peek_parent" c:identifier="g_type_class_peek_parent" gs:pinvoke-only="1" gs:pinvoke-access-modifiers="private protected" gs:dll-name="gobject-2.0" gs:managed-name="PeekParent">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="5412">This is a convenience function often needed in class initializers.
It returns the class structure of the immediate parent type of the
class passed in.  Since derived classes hold a reference count on
their parent classes as long as they are instantiated, the returned
class will always exist.

This function is essentially equivalent to:
g_type_class_peek (g_type_parent (G_TYPE_FROM_CLASS (g_class)))</doc>
        <source-position filename="gtype.h" line="721" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="5426">the parent class
    of @g_class</doc>
          <type name="TypeClass" c:type="gpointer" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="g_class" transfer-ownership="none" gs:managed-name="gClass" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5414">the #GTypeClass structure to
    retrieve the parent class for</doc>
            <type name="TypeClass" c:type="gpointer" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="unref" c:identifier="g_type_class_unref" gs:pinvoke-access-modifiers="internal" gs:dll-name="gobject-2.0" gs:managed-name="Unref" gs:special-func="unref" gs:pinvoke-only="1">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="5458">Decrements the reference count of the class structure being passed in.
Once the last reference count of a class has been released, classes
may be finalized by the type system, so further dereferencing of a
class pointer after g_type_class_unref() are invalid.</doc>
        <source-position filename="gtype.h" line="719" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="g_class" transfer-ownership="none" gs:managed-name="gClass" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5460">a #GTypeClass structure to unref</doc>
            <type name="TypeClass" c:type="gpointer" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <function name="adjust_private_offset" c:identifier="g_type_class_adjust_private_offset" gs:dll-name="gobject-2.0" gs:managed-name="AdjustPrivateOffset">
        <source-position filename="gtype.h" line="1313" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <parameter name="g_class" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="gClass" direction="in">
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="private_size_or_offset" transfer-ownership="none" gs:managed-name="privateSizeOrOffset" direction="in">
            <type name="gint" c:type="gint*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="g_class" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="gClass" direction="in">
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="private_size_or_offset" transfer-ownership="none" gs:managed-name="privateSizeOrOffset" direction="in">
            <type name="gint" c:type="gint*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="peek" c:identifier="g_type_class_peek" gs:pinvoke-only="1" gs:pinvoke-access-modifiers="private protected" gs:dll-name="gobject-2.0" gs:managed-name="Peek">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="5396">This function is essentially the same as g_type_class_ref(),
except that the classes reference count isn't incremented.
As a consequence, this function may return %NULL if the class
of the type passed in does not currently exist (hasn't been
referenced before).</doc>
        <source-position filename="gtype.h" line="715" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="5406">the #GTypeClass
    structure for the given type ID or %NULL if the class does not
    currently exist</doc>
          <type name="TypeClass" c:type="gpointer" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5398">type ID of a classed type</doc>
            <type name="GType" c:type="GType" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5398">type ID of a classed type</doc>
            <type name="GType" c:type="GType" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="peek_static" c:identifier="g_type_class_peek_static" version="2.4" gs:pinvoke-only="1" gs:pinvoke-access-modifiers="private protected" gs:dll-name="gobject-2.0" gs:managed-name="PeekStatic">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="5431">A more efficient version of g_type_class_peek() which works only for
static types.</doc>
        <source-position filename="gtype.h" line="717" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="5438">the #GTypeClass
    structure for the given type ID or %NULL if the class does not
    currently exist or is dynamically loaded</doc>
          <type name="TypeClass" c:type="gpointer" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5433">type ID of a classed type</doc>
            <type name="GType" c:type="GType" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5433">type ID of a classed type</doc>
            <type name="GType" c:type="GType" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="ref" c:identifier="g_type_class_ref" gs:pinvoke-access-modifiers="internal" gs:dll-name="gobject-2.0" gs:managed-name="Ref">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="5445">Increments the reference count of the class structure belonging to
@type. This function will demand-create the class if it doesn't
exist already.</doc>
        <source-position filename="gtype.h" line="713" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="5453">the #GTypeClass
    structure for the given type ID</doc>
          <type name="TypeClass" c:type="gpointer" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5447">type ID of a classed type</doc>
            <type name="GType" c:type="GType" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5447">type ID of a classed type</doc>
            <type name="GType" c:type="GType" />
          </parameter>
        </gs:managed-parameters>
      </function>
    </record>
    <bitfield name="TypeDebugFlags" deprecated="1" deprecated-version="2.36" c:type="GTypeDebugFlags" gs:managed-name="TypeDebugFlags">
      <doc xml:space="preserve" filename="gtype.h" line="662">These flags used to be passed to g_type_init_with_debug_flags() which
is now deprecated.

If you need to enable debugging features, use the GOBJECT_DEBUG
environment variable.</doc>
      <doc-deprecated xml:space="preserve">g_type_init() is now done automatically</doc-deprecated>
      <source-position filename="gtype.h" line="685" />
      <member name="none" value="0" c:identifier="G_TYPE_DEBUG_NONE" gs:managed-name="None">
        <doc xml:space="preserve" filename="gtype.h" line="664">Print no messages</doc>
      </member>
      <member name="objects" value="1" c:identifier="G_TYPE_DEBUG_OBJECTS" gs:managed-name="Objects">
        <doc xml:space="preserve" filename="gtype.h" line="665">Print messages about object bookkeeping</doc>
      </member>
      <member name="signals" value="2" c:identifier="G_TYPE_DEBUG_SIGNALS" gs:managed-name="Signals">
        <doc xml:space="preserve" filename="gtype.h" line="666">Print messages about signal emissions</doc>
      </member>
      <member name="instance_count" value="4" c:identifier="G_TYPE_DEBUG_INSTANCE_COUNT" gs:managed-name="InstanceCount">
        <doc xml:space="preserve" filename="gtype.h" line="668">Keep a count of instances of each type</doc>
      </member>
      <member name="mask" value="7" c:identifier="G_TYPE_DEBUG_MASK" gs:managed-name="Mask">
        <doc xml:space="preserve" filename="gtype.h" line="667">Mask covering all debug flags</doc>
      </member>
    </bitfield>
    <bitfield name="TypeFlags" c:type="GTypeFlags" gs:managed-name="TypeFlags">
      <doc xml:space="preserve" filename="gtype.h" line="998">Bit masks used to check or determine characteristics of a type.</doc>
      <source-position filename="gtype.h" line="1012" />
      <member name="abstract" value="16" c:identifier="G_TYPE_FLAG_ABSTRACT" gs:managed-name="Abstract">
        <doc xml:space="preserve" filename="gtype.h" line="1000">Indicates an abstract type. No instances can be
 created for an abstract type</doc>
      </member>
      <member name="value_abstract" value="32" c:identifier="G_TYPE_FLAG_VALUE_ABSTRACT" gs:managed-name="ValueAbstract">
        <doc xml:space="preserve" filename="gtype.h" line="1002">Indicates an abstract value type, i.e. a type
 that introduces a value table, but can't be used for
 g_value_init()</doc>
      </member>
    </bitfield>
    <bitfield name="TypeFundamentalFlags" c:type="GTypeFundamentalFlags" gs:managed-name="TypeFundamentalFlags">
      <doc xml:space="preserve" filename="gtype.h" line="981">Bit masks used to check or determine specific characteristics of a
fundamental type.</doc>
      <source-position filename="gtype.h" line="997" />
      <member name="classed" value="1" c:identifier="G_TYPE_FLAG_CLASSED" gs:managed-name="Classed">
        <doc xml:space="preserve" filename="gtype.h" line="983">Indicates a classed type</doc>
      </member>
      <member name="instantiatable" value="2" c:identifier="G_TYPE_FLAG_INSTANTIATABLE" gs:managed-name="Instantiatable">
        <doc xml:space="preserve" filename="gtype.h" line="984">Indicates an instantiable type (implies classed)</doc>
      </member>
      <member name="derivable" value="4" c:identifier="G_TYPE_FLAG_DERIVABLE" gs:managed-name="Derivable">
        <doc xml:space="preserve" filename="gtype.h" line="985">Indicates a flat derivable type</doc>
      </member>
      <member name="deep_derivable" value="8" c:identifier="G_TYPE_FLAG_DEEP_DERIVABLE" gs:managed-name="DeepDerivable">
        <doc xml:space="preserve" filename="gtype.h" line="986">Indicates a deep derivable type (implies derivable)</doc>
      </member>
    </bitfield>
    <record name="TypeFundamentalInfo" c:type="GTypeFundamentalInfo" gs:managed-name="TypeFundamentalInfo">
      <doc xml:space="preserve" filename="gtype.h" line="1065">A structure that provides information to the type system which is
used specifically for managing fundamental types.</doc>
      <source-position filename="gtype.h" line="1075" />
      <field name="type_flags" writable="1" gs:managed-name="TypeFlags">
        <doc xml:space="preserve" filename="gtype.h" line="1067">#GTypeFundamentalFlags describing the characteristics of the fundamental type</doc>
        <type name="TypeFundamentalFlags" c:type="GTypeFundamentalFlags" />
      </field>
    </record>
    <record name="TypeInfo" c:type="GTypeInfo" gs:managed-name="TypeInfo">
      <doc xml:space="preserve" filename="gtype.h" line="1013">This structure is used to provide the type system with the information
required to initialize and destruct (finalize) a type's class and
its instances.

The initialized structure is passed to the g_type_register_static() function
(or is copied into the provided #GTypeInfo structure in the
g_type_plugin_complete_type_info()). The type system will perform a deep
copy of this structure, so its memory does not need to be persistent
across invocation of g_type_register_static().</doc>
      <source-position filename="gtype.h" line="1064" />
      <field name="class_size" writable="1" gs:managed-name="ClassSize">
        <doc xml:space="preserve" filename="gtype.h" line="1015">Size of the class structure (required for interface, classed and instantiatable types)</doc>
        <type name="guint16" c:type="guint16" />
      </field>
      <field name="base_init" writable="1" gs:managed-name="BaseInit">
        <doc xml:space="preserve" filename="gtype.h" line="1016">Location of the base initialization function (optional)</doc>
        <type name="BaseInitFunc" c:type="GBaseInitFunc" />
      </field>
      <field name="base_finalize" writable="1" gs:managed-name="BaseFinalize">
        <doc xml:space="preserve" filename="gtype.h" line="1017">Location of the base finalization function (optional)</doc>
        <type name="BaseFinalizeFunc" c:type="GBaseFinalizeFunc" />
      </field>
      <field name="class_init" writable="1" gs:managed-name="ClassInit">
        <doc xml:space="preserve" filename="gtype.h" line="1018">Location of the class initialization function for
 classed and instantiatable types. Location of the default vtable
 inititalization function for interface types. (optional) This function
 is used both to fill in virtual functions in the class or default vtable,
 and to do type-specific setup such as registering signals and object
 properties.</doc>
        <type name="ClassInitFunc" c:type="GClassInitFunc" />
      </field>
      <field name="class_finalize" writable="1" gs:managed-name="ClassFinalize">
        <doc xml:space="preserve" filename="gtype.h" line="1024">Location of the class finalization function for
 classed and instantiatable types. Location of the default vtable
 finalization function for interface types. (optional)</doc>
        <type name="ClassFinalizeFunc" c:type="GClassFinalizeFunc" />
      </field>
      <field name="class_data" writable="1" gs:managed-name="ClassData">
        <doc xml:space="preserve" filename="gtype.h" line="1027">User-supplied data passed to the class init/finalize functions</doc>
        <type name="gpointer" c:type="gconstpointer" gs:is-pointer="1" />
      </field>
      <field name="instance_size" writable="1" gs:managed-name="InstanceSize">
        <doc xml:space="preserve" filename="gtype.h" line="1028">Size of the instance (object) structure (required for instantiatable types only)</doc>
        <type name="guint16" c:type="guint16" />
      </field>
      <field name="n_preallocs" writable="1" gs:managed-name="NPreallocs">
        <doc xml:space="preserve" filename="gtype.h" line="1029">Prior to GLib 2.10, it specified the number of pre-allocated (cached) instances to reserve memory for (0 indicates no caching). Since GLib 2.10, it is ignored, since instances are allocated with the [slice allocator][glib-Memory-Slices] now.</doc>
        <type name="guint16" c:type="guint16" />
      </field>
      <field name="instance_init" writable="1" gs:managed-name="InstanceInit">
        <doc xml:space="preserve" filename="gtype.h" line="1030">Location of the instance initialization function (optional, for instantiatable types only)</doc>
        <type name="InstanceInitFunc" c:type="GInstanceInitFunc" />
      </field>
      <field name="value_table" writable="1" gs:managed-name="ValueTable">
        <doc xml:space="preserve" filename="gtype.h" line="1031">A #GTypeValueTable function table for generic handling of GValues
 of this type (usually only useful for fundamental types)</doc>
        <type name="TypeValueTable" c:type="const GTypeValueTable*" gs:is-pointer="1" />
      </field>
    </record>
    <record name="TypeInstance" c:type="GTypeInstance" disguised="1" gs:inheritance-modifiers="abstract" gs:managed-name="TypeInstance">
      <doc xml:space="preserve" filename="gtype.h" line="413">An opaque structure used as the base of all type instances.</doc>
      <source-position filename="gtype.h" line="422" />
      <field name="g_class" readable="0" private="1" gs:managed-name="GClass">
        <type name="TypeClass" c:type="GTypeClass*" gs:is-pointer="1" />
      </field>
      <method name="get_private" c:identifier="g_type_instance_get_private" gs:dll-name="gobject-2.0" gs:managed-name="GetPrivate">
        <source-position filename="gtype.h" line="1310" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="instance" transfer-ownership="none" gs:managed-name="instance" direction="in">
            <type name="TypeInstance" c:type="GTypeInstance*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="private_type" transfer-ownership="none" gs:managed-name="privateType" direction="in">
            <type name="GType" c:type="GType" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="private_type" transfer-ownership="none" gs:managed-name="privateType" direction="in">
            <type name="GType" c:type="GType" />
          </parameter>
        </gs:managed-parameters>
      </method>
    </record>
    <record name="TypeInterface" c:type="GTypeInterface" disguised="1" gs:inheritance-modifiers="abstract" gs:managed-name="TypeInterface">
      <doc xml:space="preserve" filename="gtype.h" line="423">An opaque structure used as the base of all interface types.</doc>
      <source-position filename="gtype.h" line="433" />
      <field name="g_type" readable="0" private="1" gs:managed-name="GType">
        <type name="GType" c:type="GType" />
      </field>
      <field name="g_instance_type" readable="0" private="1" gs:managed-name="GInstanceType">
        <type name="GType" c:type="GType" />
      </field>
      <method name="peek_parent" c:identifier="g_type_interface_peek_parent" gs:pinvoke-only="1" gs:dll-name="gobject-2.0" gs:managed-name="PeekParent">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="5779">Returns the corresponding #GTypeInterface structure of the parent type
of the instance type to which @g_iface belongs. This is useful when
deriving the implementation of an interface from the parent type and
then possibly overriding some methods.</doc>
        <source-position filename="gtype.h" line="726" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="5788">the
    corresponding #GTypeInterface structure of the parent type of the
    instance type to which @g_iface belongs, or %NULL if the parent
    type doesn't conform to the interface</doc>
          <type name="TypeInterface" c:type="gpointer" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="g_iface" transfer-ownership="none" gs:managed-name="gIface" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5781">a #GTypeInterface structure</doc>
            <type name="TypeInterface" c:type="gpointer" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <function name="add_prerequisite" c:identifier="g_type_interface_add_prerequisite" gs:dll-name="gobject-2.0" gs:managed-name="AddPrerequisite">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="5721">Adds @prerequisite_type to the list of prerequisites of @interface_type.
This means that any type implementing @interface_type must also implement
@prerequisite_type. Prerequisites can be thought of as an alternative to
interface derivation (which GType doesn't support). An interface can have
at most one instantiatable prerequisite type.</doc>
        <source-position filename="gtype.h" line="1298" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <parameter name="interface_type" transfer-ownership="none" gs:managed-name="interfaceType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5723">#GType value of an interface type</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="prerequisite_type" transfer-ownership="none" gs:managed-name="prerequisiteType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5724">#GType value of an interface or instantiatable type</doc>
            <type name="GType" c:type="GType" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="interface_type" transfer-ownership="none" gs:managed-name="interfaceType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5723">#GType value of an interface type</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="prerequisite_type" transfer-ownership="none" gs:managed-name="prerequisiteType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5724">#GType value of an interface or instantiatable type</doc>
            <type name="GType" c:type="GType" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="peek" c:identifier="g_type_interface_peek" gs:pinvoke-only="1" gs:dll-name="gobject-2.0" gs:managed-name="Peek">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="5765">Returns the #GTypeInterface structure of an interface to which the
passed in class conforms.</doc>
        <source-position filename="gtype.h" line="723" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="5773">the #GTypeInterface
    structure of @iface_type if implemented by @instance_class, %NULL
    otherwise</doc>
          <type name="TypeInterface" c:type="gpointer" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="instance_class" transfer-ownership="none" gs:managed-name="instanceClass" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5767">a #GTypeClass structure</doc>
            <type name="TypeClass" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="iface_type" transfer-ownership="none" gs:managed-name="ifaceType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5768">an interface ID which this class conforms to</doc>
            <type name="GType" c:type="GType" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="instance_class" transfer-ownership="none" gs:managed-name="instanceClass" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5767">a #GTypeClass structure</doc>
            <type name="TypeClass" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="iface_type" transfer-ownership="none" gs:managed-name="ifaceType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5768">an interface ID which this class conforms to</doc>
            <type name="GType" c:type="GType" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="prerequisites" c:identifier="g_type_interface_prerequisites" version="2.2" gs:dll-name="gobject-2.0" gs:managed-name="Prerequisites">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="5795">Returns the prerequisites of an interfaces type.</doc>
        <source-position filename="gtype.h" line="1301" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="5804">a
    newly-allocated zero-terminated array of #GType containing
    the prerequisites of @interface_type</doc>
          <array length="1" zero-terminated="0" c:type="GType*" gs:is-pointer="1">
            <type name="GType" c:type="GType" />
          </array>
        </return-value>
        <parameters>
          <parameter name="interface_type" transfer-ownership="none" gs:managed-name="interfaceType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5797">an interface type</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="n_prerequisites" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="nPrerequisites">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5798">location to return the number
    of prerequisites, or %NULL</doc>
            <type name="guint" c:type="guint*" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="interface_type" transfer-ownership="none" gs:managed-name="interfaceType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5797">an interface type</doc>
            <type name="GType" c:type="GType" />
          </parameter>
        </gs:managed-parameters>
      </function>
    </record>
    <callback name="TypeInterfaceCheckFunc" c:type="GTypeInterfaceCheckFunc" version="2.4" gs:dll-name="gobject-2.0" gs:managed-name="TypeInterfaceCheckFunc">
      <doc xml:space="preserve" filename="gtype.h" line="968">A callback called after an interface vtable is initialized.
See g_type_add_interface_check().</doc>
      <source-position filename="gtype.h" line="979" />
      <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
        <type name="none" c:type="void" />
      </return-value>
      <parameters>
        <parameter name="check_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="checkData" direction="in">
          <doc xml:space="preserve" filename="gtype.h" line="970">data passed to g_type_add_interface_check()</doc>
          <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
        </parameter>
        <parameter name="g_iface" transfer-ownership="none" gs:managed-name="gIface" direction="in">
          <doc xml:space="preserve" filename="gtype.h" line="971">the interface that has been
   initialized</doc>
          <type name="TypeInterface" c:type="gpointer" gs:is-pointer="1" />
        </parameter>
      </parameters>
      <gs:managed-parameters>
        <parameter name="check_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="checkData" direction="in">
          <doc xml:space="preserve" filename="gtype.h" line="970">data passed to g_type_add_interface_check()</doc>
          <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
        </parameter>
        <parameter name="g_iface" transfer-ownership="none" gs:managed-name="gIface" direction="in">
          <doc xml:space="preserve" filename="gtype.h" line="971">the interface that has been
   initialized</doc>
          <type name="TypeInterface" c:type="gpointer" gs:is-pointer="1" />
        </parameter>
      </gs:managed-parameters>
    </callback>
    <interface name="TypePlugin" c:symbol-prefix="type_plugin" c:type="GTypePlugin" glib:type-name="GTypePlugin" glib:get-type="g_type_plugin_get_type" gs:managed-name="ITypePlugin">
      <doc xml:space="preserve" filename="gobject-2.0.c" line="514">The GObject type system supports dynamic loading of types.
The #GTypePlugin interface is used to handle the lifecycle
of dynamically loaded types. It goes as follows:

1. The type is initially introduced (usually upon loading the module
   the first time, or by your main application that knows what modules
   introduces what types), like this:
   |[&lt;!-- language="C" --&gt;
   new_type_id = g_type_register_dynamic (parent_type_id,
                                          "TypeName",
                                          new_type_plugin,
                                          type_flags);
   ]|
   where @new_type_plugin is an implementation of the
   #GTypePlugin interface.

2. The type's implementation is referenced, e.g. through
   g_type_class_ref() or through g_type_create_instance() (this is
   being called by g_object_new()) or through one of the above done on
   a type derived from @new_type_id.

3. This causes the type system to load the type's implementation by
   calling g_type_plugin_use() and g_type_plugin_complete_type_info()
   on @new_type_plugin.

4. At some point the type's implementation isn't required anymore,
   e.g. after g_type_class_unref() or g_type_free_instance() (called
   when the reference count of an instance drops to zero).

5. This causes the type system to throw away the information retrieved
   from g_type_plugin_complete_type_info() and then it calls
   g_type_plugin_unuse() on @new_type_plugin.

6. Things may repeat from the second step.

So basically, you need to implement a #GTypePlugin type that
carries a use_count, once use_count goes from zero to one, you need
to load the implementation to successfully handle the upcoming
g_type_plugin_complete_type_info() call. Later, maybe after
succeeding use/unuse calls, once use_count drops to zero, you can
unload the implementation again. The type system makes sure to call
g_type_plugin_use() and g_type_plugin_complete_type_info() again
when the type is needed again.

#GTypeModule is an implementation of #GTypePlugin that already
implements most of this except for the actual module loading and
unloading. It even handles multiple registered types per module.</doc>
      <method name="complete_interface_info" c:identifier="g_type_plugin_complete_interface_info" gs:dll-name="gobject-2.0" gs:managed-name="CompleteInterfaceInfo" gs:extension-method="1">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6011">Calls the @complete_interface_info function from the
#GTypePluginClass of @plugin. There should be no need to use this
function outside of the GObject type system itself.</doc>
        <source-position filename="gtypeplugin.h" line="127" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none" gs:managed-name="plugin" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6013">the #GTypePlugin</doc>
            <type name="TypePlugin" c:type="GTypePlugin*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="instance_type" transfer-ownership="none" gs:managed-name="instanceType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6014">the #GType of an instantiatable type to which the interface
 is added</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="interface_type" transfer-ownership="none" gs:managed-name="interfaceType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6016">the #GType of the interface whose info is completed</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6017">the #GInterfaceInfo to fill in</doc>
            <type name="InterfaceInfo" c:type="GInterfaceInfo*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="plugin" transfer-ownership="none" gs:managed-name="plugin" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6013">the #GTypePlugin</doc>
            <type name="TypePlugin" c:type="GTypePlugin*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="instance_type" transfer-ownership="none" gs:managed-name="instanceType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6014">the #GType of an instantiatable type to which the interface
 is added</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="interface_type" transfer-ownership="none" gs:managed-name="interfaceType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6016">the #GType of the interface whose info is completed</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6017">the #GInterfaceInfo to fill in</doc>
            <type name="InterfaceInfo" c:type="GInterfaceInfo*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="complete_type_info" c:identifier="g_type_plugin_complete_type_info" gs:dll-name="gobject-2.0" gs:managed-name="CompleteTypeInfo" gs:extension-method="1">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6025">Calls the @complete_type_info function from the #GTypePluginClass of @plugin.
There should be no need to use this function outside of the GObject
type system itself.</doc>
        <source-position filename="gtypeplugin.h" line="122" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none" gs:managed-name="plugin" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6027">a #GTypePlugin</doc>
            <type name="TypePlugin" c:type="GTypePlugin*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="g_type" transfer-ownership="none" gs:managed-name="gType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6028">the #GType whose info is completed</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6029">the #GTypeInfo struct to fill in</doc>
            <type name="TypeInfo" c:type="GTypeInfo*" gs:is-pointer="1" />
          </parameter>
          <parameter name="value_table" transfer-ownership="none" gs:managed-name="valueTable" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6030">the #GTypeValueTable to fill in</doc>
            <type name="TypeValueTable" c:type="GTypeValueTable*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="plugin" transfer-ownership="none" gs:managed-name="plugin" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6027">a #GTypePlugin</doc>
            <type name="TypePlugin" c:type="GTypePlugin*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="g_type" transfer-ownership="none" gs:managed-name="gType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6028">the #GType whose info is completed</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6029">the #GTypeInfo struct to fill in</doc>
            <type name="TypeInfo" c:type="GTypeInfo*" gs:is-pointer="1" />
          </parameter>
          <parameter name="value_table" transfer-ownership="none" gs:managed-name="valueTable" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6030">the #GTypeValueTable to fill in</doc>
            <type name="TypeValueTable" c:type="GTypeValueTable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="unuse" c:identifier="g_type_plugin_unuse" gs:dll-name="gobject-2.0" gs:managed-name="Unuse" gs:extension-method="1">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6038">Calls the @unuse_plugin function from the #GTypePluginClass of
@plugin.  There should be no need to use this function outside of
the GObject type system itself.</doc>
        <source-position filename="gtypeplugin.h" line="120" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none" gs:managed-name="plugin" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6040">a #GTypePlugin</doc>
            <type name="TypePlugin" c:type="GTypePlugin*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="plugin" transfer-ownership="none" gs:managed-name="plugin" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6040">a #GTypePlugin</doc>
            <type name="TypePlugin" c:type="GTypePlugin*" gs:is-pointer="1" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="use" c:identifier="g_type_plugin_use" gs:dll-name="gobject-2.0" gs:managed-name="Use" gs:extension-method="1">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6048">Calls the @use_plugin function from the #GTypePluginClass of
@plugin.  There should be no need to use this function outside of
the GObject type system itself.</doc>
        <source-position filename="gtypeplugin.h" line="118" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none" gs:managed-name="plugin" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6050">a #GTypePlugin</doc>
            <type name="TypePlugin" c:type="GTypePlugin*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="plugin" transfer-ownership="none" gs:managed-name="plugin" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6050">a #GTypePlugin</doc>
            <type name="TypePlugin" c:type="GTypePlugin*" gs:is-pointer="1" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_type_plugin_get_type" gs:access-modifiers="private" gs:dll-name="gobject-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </interface>
    <record name="TypePluginClass" c:type="GTypePluginClass" gs:managed-name="TypePluginClass">
      <doc xml:space="preserve" filename="gtypeplugin.h" line="87">The #GTypePlugin interface is used by the type system in order to handle
the lifecycle of dynamically loaded types.</doc>
      <source-position filename="gtypeplugin.h" line="111" />
      <field name="base_iface" readable="0" private="1" gs:managed-name="BaseIface">
        <type name="TypeInterface" c:type="GTypeInterface" />
      </field>
      <field name="use_plugin" writable="1" gs:managed-name="UsePlugin">
        <doc xml:space="preserve" filename="gtypeplugin.h" line="89">Increases the use count of the plugin.</doc>
        <type name="TypePluginUse" c:type="GTypePluginUse" />
      </field>
      <field name="unuse_plugin" writable="1" gs:managed-name="UnusePlugin">
        <doc xml:space="preserve" filename="gtypeplugin.h" line="90">Decreases the use count of the plugin.</doc>
        <type name="TypePluginUnuse" c:type="GTypePluginUnuse" />
      </field>
      <field name="complete_type_info" writable="1" gs:managed-name="CompleteTypeInfo">
        <doc xml:space="preserve" filename="gtypeplugin.h" line="91">Fills in the #GTypeInfo and
 #GTypeValueTable structs for the type. The structs are initialized
 with `memset(s, 0, sizeof (s))` before calling this function.</doc>
        <type name="TypePluginCompleteTypeInfo" c:type="GTypePluginCompleteTypeInfo" />
      </field>
      <field name="complete_interface_info" writable="1" gs:managed-name="CompleteInterfaceInfo">
        <doc xml:space="preserve" filename="gtypeplugin.h" line="94">Fills in missing parts of the #GInterfaceInfo
 for the interface. The structs is initialized with
 `memset(s, 0, sizeof (s))` before calling this function.</doc>
        <type name="TypePluginCompleteInterfaceInfo" c:type="GTypePluginCompleteInterfaceInfo" />
      </field>
    </record>
    <callback name="TypePluginCompleteInterfaceInfo" c:type="GTypePluginCompleteInterfaceInfo" gs:dll-name="gobject-2.0" gs:managed-name="TypePluginCompleteInterfaceInfo">
      <doc xml:space="preserve" filename="gtypeplugin.h" line="67">The type of the @complete_interface_info function of #GTypePluginClass.</doc>
      <source-position filename="gtypeplugin.h" line="77" />
      <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
        <type name="none" c:type="void" />
      </return-value>
      <parameters>
        <parameter name="plugin" transfer-ownership="none" gs:managed-name="plugin" direction="in">
          <doc xml:space="preserve" filename="gtypeplugin.h" line="69">the #GTypePlugin</doc>
          <type name="TypePlugin" c:type="GTypePlugin*" gs:is-pointer="1" />
        </parameter>
        <parameter name="instance_type" transfer-ownership="none" gs:managed-name="instanceType" direction="in">
          <doc xml:space="preserve" filename="gtypeplugin.h" line="70">the #GType of an instantiable type to which the interface
 is added</doc>
          <type name="GType" c:type="GType" />
        </parameter>
        <parameter name="interface_type" transfer-ownership="none" gs:managed-name="interfaceType" direction="in">
          <doc xml:space="preserve" filename="gtypeplugin.h" line="72">the #GType of the interface whose info is completed</doc>
          <type name="GType" c:type="GType" />
        </parameter>
        <parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
          <doc xml:space="preserve" filename="gtypeplugin.h" line="73">the #GInterfaceInfo to fill in</doc>
          <type name="InterfaceInfo" c:type="GInterfaceInfo*" gs:is-pointer="1" />
        </parameter>
      </parameters>
      <gs:managed-parameters>
        <parameter name="plugin" transfer-ownership="none" gs:managed-name="plugin" direction="in">
          <doc xml:space="preserve" filename="gtypeplugin.h" line="69">the #GTypePlugin</doc>
          <type name="TypePlugin" c:type="GTypePlugin*" gs:is-pointer="1" />
        </parameter>
        <parameter name="instance_type" transfer-ownership="none" gs:managed-name="instanceType" direction="in">
          <doc xml:space="preserve" filename="gtypeplugin.h" line="70">the #GType of an instantiable type to which the interface
 is added</doc>
          <type name="GType" c:type="GType" />
        </parameter>
        <parameter name="interface_type" transfer-ownership="none" gs:managed-name="interfaceType" direction="in">
          <doc xml:space="preserve" filename="gtypeplugin.h" line="72">the #GType of the interface whose info is completed</doc>
          <type name="GType" c:type="GType" />
        </parameter>
        <parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
          <doc xml:space="preserve" filename="gtypeplugin.h" line="73">the #GInterfaceInfo to fill in</doc>
          <type name="InterfaceInfo" c:type="GInterfaceInfo*" gs:is-pointer="1" />
        </parameter>
      </gs:managed-parameters>
    </callback>
    <callback name="TypePluginCompleteTypeInfo" c:type="GTypePluginCompleteTypeInfo" gs:dll-name="gobject-2.0" gs:managed-name="TypePluginCompleteTypeInfo">
      <doc xml:space="preserve" filename="gtypeplugin.h" line="54">The type of the @complete_type_info function of #GTypePluginClass.</doc>
      <source-position filename="gtypeplugin.h" line="63" />
      <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
        <type name="none" c:type="void" />
      </return-value>
      <parameters>
        <parameter name="plugin" transfer-ownership="none" gs:managed-name="plugin" direction="in">
          <doc xml:space="preserve" filename="gtypeplugin.h" line="56">the #GTypePlugin</doc>
          <type name="TypePlugin" c:type="GTypePlugin*" gs:is-pointer="1" />
        </parameter>
        <parameter name="g_type" transfer-ownership="none" gs:managed-name="gType" direction="in">
          <doc xml:space="preserve" filename="gtypeplugin.h" line="57">the #GType whose info is completed</doc>
          <type name="GType" c:type="GType" />
        </parameter>
        <parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
          <doc xml:space="preserve" filename="gtypeplugin.h" line="58">the #GTypeInfo struct to fill in</doc>
          <type name="TypeInfo" c:type="GTypeInfo*" gs:is-pointer="1" />
        </parameter>
        <parameter name="value_table" transfer-ownership="none" gs:managed-name="valueTable" direction="in">
          <doc xml:space="preserve" filename="gtypeplugin.h" line="59">the #GTypeValueTable to fill in</doc>
          <type name="TypeValueTable" c:type="GTypeValueTable*" gs:is-pointer="1" />
        </parameter>
      </parameters>
      <gs:managed-parameters>
        <parameter name="plugin" transfer-ownership="none" gs:managed-name="plugin" direction="in">
          <doc xml:space="preserve" filename="gtypeplugin.h" line="56">the #GTypePlugin</doc>
          <type name="TypePlugin" c:type="GTypePlugin*" gs:is-pointer="1" />
        </parameter>
        <parameter name="g_type" transfer-ownership="none" gs:managed-name="gType" direction="in">
          <doc xml:space="preserve" filename="gtypeplugin.h" line="57">the #GType whose info is completed</doc>
          <type name="GType" c:type="GType" />
        </parameter>
        <parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
          <doc xml:space="preserve" filename="gtypeplugin.h" line="58">the #GTypeInfo struct to fill in</doc>
          <type name="TypeInfo" c:type="GTypeInfo*" gs:is-pointer="1" />
        </parameter>
        <parameter name="value_table" transfer-ownership="none" gs:managed-name="valueTable" direction="in">
          <doc xml:space="preserve" filename="gtypeplugin.h" line="59">the #GTypeValueTable to fill in</doc>
          <type name="TypeValueTable" c:type="GTypeValueTable*" gs:is-pointer="1" />
        </parameter>
      </gs:managed-parameters>
    </callback>
    <callback name="TypePluginUnuse" c:type="GTypePluginUnuse" gs:dll-name="gobject-2.0" gs:managed-name="TypePluginUnuse">
      <doc xml:space="preserve" filename="gtypeplugin.h" line="47">The type of the @unuse_plugin function of #GTypePluginClass.</doc>
      <source-position filename="gtypeplugin.h" line="53" />
      <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
        <type name="none" c:type="void" />
      </return-value>
      <parameters>
        <parameter name="plugin" transfer-ownership="none" gs:managed-name="plugin" direction="in">
          <doc xml:space="preserve" filename="gtypeplugin.h" line="49">the #GTypePlugin whose use count should be decreased</doc>
          <type name="TypePlugin" c:type="GTypePlugin*" gs:is-pointer="1" />
        </parameter>
      </parameters>
      <gs:managed-parameters>
        <parameter name="plugin" transfer-ownership="none" gs:managed-name="plugin" direction="in">
          <doc xml:space="preserve" filename="gtypeplugin.h" line="49">the #GTypePlugin whose use count should be decreased</doc>
          <type name="TypePlugin" c:type="GTypePlugin*" gs:is-pointer="1" />
        </parameter>
      </gs:managed-parameters>
    </callback>
    <callback name="TypePluginUse" c:type="GTypePluginUse" gs:dll-name="gobject-2.0" gs:managed-name="TypePluginUse">
      <doc xml:space="preserve" filename="gtypeplugin.h" line="39">The type of the @use_plugin function of #GTypePluginClass, which gets called
to increase the use count of @plugin.</doc>
      <source-position filename="gtypeplugin.h" line="46" />
      <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
        <type name="none" c:type="void" />
      </return-value>
      <parameters>
        <parameter name="plugin" transfer-ownership="none" gs:managed-name="plugin" direction="in">
          <doc xml:space="preserve" filename="gtypeplugin.h" line="41">the #GTypePlugin whose use count should be increased</doc>
          <type name="TypePlugin" c:type="GTypePlugin*" gs:is-pointer="1" />
        </parameter>
      </parameters>
      <gs:managed-parameters>
        <parameter name="plugin" transfer-ownership="none" gs:managed-name="plugin" direction="in">
          <doc xml:space="preserve" filename="gtypeplugin.h" line="41">the #GTypePlugin whose use count should be increased</doc>
          <type name="TypePlugin" c:type="GTypePlugin*" gs:is-pointer="1" />
        </parameter>
      </gs:managed-parameters>
    </callback>
    <record name="TypeQuery" c:type="GTypeQuery" gs:managed-name="TypeQuery">
      <doc xml:space="preserve" filename="gtype.h" line="434">A structure holding information for a specific type.
It is filled in by the g_type_query() function.</doc>
      <source-position filename="gtype.h" line="450" />
      <field name="type" writable="1" gs:managed-name="Type">
        <doc xml:space="preserve" filename="gtype.h" line="436">the #GType value of the type</doc>
        <type name="GType" c:type="GType" />
      </field>
      <field name="type_name" writable="1" gs:managed-name="TypeName">
        <doc xml:space="preserve" filename="gtype.h" line="437">the name of the type</doc>
        <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
      </field>
      <field name="class_size" writable="1" gs:managed-name="ClassSize">
        <doc xml:space="preserve" filename="gtype.h" line="438">the size of the class structure</doc>
        <type name="guint" c:type="guint" />
      </field>
      <field name="instance_size" writable="1" gs:managed-name="InstanceSize">
        <doc xml:space="preserve" filename="gtype.h" line="439">the size of the instance structure</doc>
        <type name="guint" c:type="guint" />
      </field>
    </record>
    <record name="TypeValueTable" c:type="GTypeValueTable" gs:managed-name="TypeValueTable">
      <doc xml:space="preserve" filename="gtype.h" line="1091">The #GTypeValueTable provides the functions required by the #GValue
implementation, to serve as a container for values of a type.</doc>
      <source-position filename="gtype.h" line="1263" />
      <field name="value_init" gs:managed-name="ValueInit">
        <callback name="value_init" gs:dll-name="gobject-2.0" gs:managed-name="ValueInit">
          <source-position filename="gtype.h" line="1247" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
              <type name="Value" c:type="GValue*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
              <type name="Value" c:type="GValue*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="value_free" gs:managed-name="ValueFree">
        <callback name="value_free" gs:dll-name="gobject-2.0" gs:managed-name="ValueFree">
          <source-position filename="gtype.h" line="1248" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
              <type name="Value" c:type="GValue*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
              <type name="Value" c:type="GValue*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="value_copy" gs:managed-name="ValueCopy">
        <callback name="value_copy" gs:dll-name="gobject-2.0" gs:managed-name="ValueCopy">
          <source-position filename="gtype.h" line="1249" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="src_value" transfer-ownership="none" gs:managed-name="srcValue" direction="in">
              <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
            </parameter>
            <parameter name="dest_value" transfer-ownership="none" gs:managed-name="destValue" direction="in">
              <type name="Value" c:type="GValue*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="src_value" transfer-ownership="none" gs:managed-name="srcValue" direction="in">
              <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
            </parameter>
            <parameter name="dest_value" transfer-ownership="none" gs:managed-name="destValue" direction="in">
              <type name="Value" c:type="GValue*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="value_peek_pointer" gs:managed-name="ValuePeekPointer">
        <callback name="value_peek_pointer" gs:dll-name="gobject-2.0" gs:managed-name="ValuePeekPointer">
          <source-position filename="gtype.h" line="1252" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
              <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
              <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="collect_format" writable="1" gs:managed-name="CollectFormat">
        <doc xml:space="preserve" filename="gtype.h" line="1128">A string format describing how to collect the contents of
 this value bit-by-bit. Each character in the format represents
 an argument to be collected, and the characters themselves indicate
 the type of the argument. Currently supported arguments are:
 - 'i' - Integers. passed as collect_values[].v_int.
 - 'l' - Longs. passed as collect_values[].v_long.
 - 'd' - Doubles. passed as collect_values[].v_double.
 - 'p' - Pointers. passed as collect_values[].v_pointer.
 It should be noted that for variable argument list construction,
 ANSI C promotes every type smaller than an integer to an int, and
 floats to doubles. So for collection of short int or char, 'i'
 needs to be used, and for collection of floats 'd'.</doc>
        <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
      </field>
      <field name="collect_value" gs:managed-name="CollectValue">
        <callback name="collect_value" gs:dll-name="gobject-2.0" gs:managed-name="CollectValue">
          <source-position filename="gtype.h" line="1254" />
          <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
            <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
              <type name="Value" c:type="GValue*" gs:is-pointer="1" />
            </parameter>
            <parameter name="n_collect_values" transfer-ownership="none" gs:managed-name="nCollectValues" direction="in">
              <type name="guint" c:type="guint" />
            </parameter>
            <parameter name="collect_values" transfer-ownership="none" gs:managed-name="collectValues" direction="in">
              <type name="TypeCValue" c:type="GTypeCValue*" gs:is-pointer="1" />
            </parameter>
            <parameter name="collect_flags" transfer-ownership="none" gs:managed-name="collectFlags" direction="in">
              <type name="guint" c:type="guint" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
              <type name="Value" c:type="GValue*" gs:is-pointer="1" />
            </parameter>
            <parameter name="n_collect_values" transfer-ownership="none" gs:managed-name="nCollectValues" direction="in">
              <type name="guint" c:type="guint" />
            </parameter>
            <parameter name="collect_values" transfer-ownership="none" gs:managed-name="collectValues" direction="in">
              <type name="TypeCValue" c:type="GTypeCValue*" gs:is-pointer="1" />
            </parameter>
            <parameter name="collect_flags" transfer-ownership="none" gs:managed-name="collectFlags" direction="in">
              <type name="guint" c:type="guint" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="lcopy_format" writable="1" gs:managed-name="LcopyFormat">
        <doc xml:space="preserve" filename="gtype.h" line="1204">Format description of the arguments to collect for @lcopy_value,
 analogous to @collect_format. Usually, @lcopy_format string consists
 only of 'p's to provide lcopy_value() with pointers to storage locations.</doc>
        <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
      </field>
      <field name="lcopy_value" gs:managed-name="LcopyValue">
        <callback name="lcopy_value" gs:dll-name="gobject-2.0" gs:managed-name="LcopyValue">
          <source-position filename="gtype.h" line="1259" />
          <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
            <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
              <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
            </parameter>
            <parameter name="n_collect_values" transfer-ownership="none" gs:managed-name="nCollectValues" direction="in">
              <type name="guint" c:type="guint" />
            </parameter>
            <parameter name="collect_values" transfer-ownership="none" gs:managed-name="collectValues" direction="in">
              <type name="TypeCValue" c:type="GTypeCValue*" gs:is-pointer="1" />
            </parameter>
            <parameter name="collect_flags" transfer-ownership="none" gs:managed-name="collectFlags" direction="in">
              <type name="guint" c:type="guint" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
              <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
            </parameter>
            <parameter name="n_collect_values" transfer-ownership="none" gs:managed-name="nCollectValues" direction="in">
              <type name="guint" c:type="guint" />
            </parameter>
            <parameter name="collect_values" transfer-ownership="none" gs:managed-name="collectValues" direction="in">
              <type name="TypeCValue" c:type="GTypeCValue*" gs:is-pointer="1" />
            </parameter>
            <parameter name="collect_flags" transfer-ownership="none" gs:managed-name="collectFlags" direction="in">
              <type name="guint" c:type="guint" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
    </record>
    <record name="Value" c:type="GValue" glib:type-name="GValue" glib:get-type="g_value_get_type" c:symbol-prefix="value" gs:managed-name="Value">
      <doc xml:space="preserve" filename="gvalue.h" line="96">An opaque structure used to hold different types of values.
The data within the structure has protected scope: it is accessible only
to functions within a #GTypeValueTable structure, or implementations of
the g_value_*() API. That is, code portions which implement new fundamental
types.
#GValue users cannot make any assumptions about how data is stored
within the 2 element @data union, and the @g_type member should
only be accessed through the G_VALUE_TYPE() macro.</doc>
      <source-position filename="gvalue.h" line="125" />
      <field name="g_type" readable="0" private="1" gs:managed-name="GType">
        <type name="GType" c:type="GType" />
      </field>
      <field name="data0" writable="1" gs:managed-name="Data0">
        <type name="_Value__data__union" />
      </field>
      <field name="data1" writable="1" gs:managed-name="Data1">
        <type name="_Value__data__union" />
      </field>
      <method name="copy" c:identifier="g_value_copy" gs:dll-name="gobject-2.0" gs:managed-name="Copy">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6338">Copies the value of @src_value into @dest_value.</doc>
        <source-position filename="gvalue.h" line="133" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="src_value" transfer-ownership="none" gs:managed-name="srcValue" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6340">An initialized #GValue structure.</doc>
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="dest_value" transfer-ownership="none" gs:managed-name="destValue" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6341">An initialized #GValue structure of the same type as @src_value.</doc>
            <type name="Value" c:type="GValue*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="dest_value" transfer-ownership="none" gs:managed-name="destValue" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6341">An initialized #GValue structure of the same type as @src_value.</doc>
            <type name="Value" c:type="GValue*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="dup_boxed" c:identifier="g_value_dup_boxed" introspectable="1" gs:pinvoke-only="1" gs:dll-name="gobject-2.0" gs:managed-name="DupBoxed">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6347">Get the contents of a %G_TYPE_BOXED derived #GValue.  Upon getting,
the boxed value is duplicated and needs to be later freed with
g_boxed_free(), e.g. like: g_boxed_free (G_VALUE_TYPE (@value),
return_value);</doc>
        <source-position filename="gboxed.h" line="90" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6356">boxed contents of @value</doc>
          <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6349">a valid #GValue of %G_TYPE_BOXED derived type</doc>
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="dup_object" c:identifier="g_value_dup_object" gs:dll-name="gobject-2.0" gs:managed-name="DupObject">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6360">Get the contents of a %G_TYPE_OBJECT derived #GValue, increasing
its reference count. If the contents of the #GValue are %NULL, then
%NULL will be returned.</doc>
        <source-position filename="gobject.h" line="624" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6368">object content of @value,
         should be unreferenced when no longer needed.</doc>
          <type name="Object" c:type="gpointer" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6362">a valid #GValue whose type is derived from %G_TYPE_OBJECT</doc>
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="dup_string" c:identifier="g_value_dup_string" gs:dll-name="gobject-2.0" gs:managed-name="DupString">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6385">Get a copy the contents of a %G_TYPE_STRING #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="263" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6391">a newly allocated copy of the string content of @value</doc>
          <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6387">a valid #GValue of type %G_TYPE_STRING</doc>
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="dup_variant" c:identifier="g_value_dup_variant" version="2.26" gs:dll-name="gobject-2.0" gs:managed-name="DupVariant">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6395">Get the contents of a variant #GValue, increasing its refcount. The returned
#GVariant is never floating.</doc>
        <source-position filename="gvaluetypes.h" line="285" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6402">variant contents of @value (may be %NULL);
   should be unreffed using g_variant_unref() when no longer needed</doc>
          <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6397">a valid #GValue of type %G_TYPE_VARIANT</doc>
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="fits_pointer" c:identifier="g_value_fits_pointer" gs:dll-name="gobject-2.0" gs:managed-name="FitsPointer">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6408">Determines if @value will fit inside the size of a pointer value.
This is an internal function introduced mainly for C marshallers.</doc>
        <source-position filename="gvalue.h" line="149" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6415">%TRUE if @value will fit inside a pointer value.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6410">An initialized #GValue structure.</doc>
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_boolean" gs:dll-name="gobject-2.0" gs:managed-name="Boolean">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6419">Get the contents of a %G_TYPE_BOOLEAN #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="210" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6425">boolean contents of @value</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6421">a valid #GValue of type %G_TYPE_BOOLEAN</doc>
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_boolean" c:identifier="g_value_get_boolean" gs:dll-name="gobject-2.0" gs:managed-name="GetBoolean" gs:property-getter-for="Boolean" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6419">Get the contents of a %G_TYPE_BOOLEAN #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="210" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6425">boolean contents of @value</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6421">a valid #GValue of type %G_TYPE_BOOLEAN</doc>
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="get_boxed" c:identifier="g_value_get_boxed" gs:pinvoke-only="1" gs:dll-name="gobject-2.0" gs:managed-name="GetBoxed">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6429">Get the contents of a %G_TYPE_BOXED derived #GValue.</doc>
        <source-position filename="gboxed.h" line="88" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6435">boxed contents of @value</doc>
          <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6431">a valid #GValue of %G_TYPE_BOXED derived type</doc>
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_double" gs:dll-name="gobject-2.0" gs:managed-name="Double">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6453">Get the contents of a %G_TYPE_DOUBLE #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="250" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6459">double contents of @value</doc>
          <type name="gdouble" c:type="gdouble" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6455">a valid #GValue of type %G_TYPE_DOUBLE</doc>
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_double" c:identifier="g_value_get_double" gs:dll-name="gobject-2.0" gs:managed-name="GetDouble" gs:property-getter-for="Double" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6453">Get the contents of a %G_TYPE_DOUBLE #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="250" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6459">double contents of @value</doc>
          <type name="gdouble" c:type="gdouble" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6455">a valid #GValue of type %G_TYPE_DOUBLE</doc>
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_enum" gs:dll-name="gobject-2.0" gs:managed-name="Enum">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6463">Get the contents of a %G_TYPE_ENUM #GValue.</doc>
        <source-position filename="genums.h" line="246" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6469">enum contents of @value</doc>
          <type name="gint" c:type="gint" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6465">a valid #GValue whose type is derived from %G_TYPE_ENUM</doc>
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_enum" c:identifier="g_value_get_enum" gs:dll-name="gobject-2.0" gs:managed-name="GetEnum" gs:property-getter-for="Enum" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6463">Get the contents of a %G_TYPE_ENUM #GValue.</doc>
        <source-position filename="genums.h" line="246" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6469">enum contents of @value</doc>
          <type name="gint" c:type="gint" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6465">a valid #GValue whose type is derived from %G_TYPE_ENUM</doc>
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_flags" gs:dll-name="gobject-2.0" gs:managed-name="Flags">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6473">Get the contents of a %G_TYPE_FLAGS #GValue.</doc>
        <source-position filename="genums.h" line="251" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6479">flags contents of @value</doc>
          <type name="guint" c:type="guint" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6475">a valid #GValue whose type is derived from %G_TYPE_FLAGS</doc>
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_flags" c:identifier="g_value_get_flags" gs:dll-name="gobject-2.0" gs:managed-name="GetFlags" gs:property-getter-for="Flags" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6473">Get the contents of a %G_TYPE_FLAGS #GValue.</doc>
        <source-position filename="genums.h" line="251" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6479">flags contents of @value</doc>
          <type name="guint" c:type="guint" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6475">a valid #GValue whose type is derived from %G_TYPE_FLAGS</doc>
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_float" gs:dll-name="gobject-2.0" gs:managed-name="Float">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6483">Get the contents of a %G_TYPE_FLOAT #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="245" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6489">float contents of @value</doc>
          <type name="gfloat" c:type="gfloat" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6485">a valid #GValue of type %G_TYPE_FLOAT</doc>
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_float" c:identifier="g_value_get_float" gs:dll-name="gobject-2.0" gs:managed-name="GetFloat" gs:property-getter-for="Float" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6483">Get the contents of a %G_TYPE_FLOAT #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="245" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6489">float contents of @value</doc>
          <type name="gfloat" c:type="gfloat" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6485">a valid #GValue of type %G_TYPE_FLOAT</doc>
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_g_type" version="2.12" gs:dll-name="gobject-2.0" gs:managed-name="GType">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6493">Get the contents of a %G_TYPE_GTYPE #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="275" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6500">the #GType stored in @value</doc>
          <type name="GType" c:type="GType" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6495">a valid #GValue of type %G_TYPE_GTYPE</doc>
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_g_type" c:identifier="g_value_get_gtype" version="2.12" gs:dll-name="gobject-2.0" gs:managed-name="GetGType" gs:property-getter-for="GType" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6493">Get the contents of a %G_TYPE_GTYPE #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="275" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6500">the #GType stored in @value</doc>
          <type name="GType" c:type="GType" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6495">a valid #GValue of type %G_TYPE_GTYPE</doc>
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_int" gs:dll-name="gobject-2.0" gs:managed-name="Int">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6504">Get the contents of a %G_TYPE_INT #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="215" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6510">integer contents of @value</doc>
          <type name="gint" c:type="gint" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6506">a valid #GValue of type %G_TYPE_INT</doc>
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_int" c:identifier="g_value_get_int" gs:dll-name="gobject-2.0" gs:managed-name="GetInt" gs:property-getter-for="Int" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6504">Get the contents of a %G_TYPE_INT #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="215" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6510">integer contents of @value</doc>
          <type name="gint" c:type="gint" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6506">a valid #GValue of type %G_TYPE_INT</doc>
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_int64" gs:dll-name="gobject-2.0" gs:managed-name="Int64">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6514">Get the contents of a %G_TYPE_INT64 #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="235" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6520">64bit integer contents of @value</doc>
          <type name="gint64" c:type="gint64" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6516">a valid #GValue of type %G_TYPE_INT64</doc>
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_int64" c:identifier="g_value_get_int64" gs:dll-name="gobject-2.0" gs:managed-name="GetInt64" gs:property-getter-for="Int64" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6514">Get the contents of a %G_TYPE_INT64 #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="235" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6520">64bit integer contents of @value</doc>
          <type name="gint64" c:type="gint64" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6516">a valid #GValue of type %G_TYPE_INT64</doc>
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_long" gs:dll-name="gobject-2.0" gs:managed-name="Long">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6524">Get the contents of a %G_TYPE_LONG #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="225" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6530">long integer contents of @value</doc>
          <type name="glong" c:type="glong" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6526">a valid #GValue of type %G_TYPE_LONG</doc>
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_long" c:identifier="g_value_get_long" gs:dll-name="gobject-2.0" gs:managed-name="GetLong" gs:property-getter-for="Long" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6524">Get the contents of a %G_TYPE_LONG #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="225" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6530">long integer contents of @value</doc>
          <type name="glong" c:type="glong" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6526">a valid #GValue of type %G_TYPE_LONG</doc>
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_object" gs:dll-name="gobject-2.0" gs:managed-name="Object">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6534">Get the contents of a %G_TYPE_OBJECT derived #GValue.</doc>
        <source-position filename="gobject.h" line="622" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6540">object contents of @value</doc>
          <type name="Object" c:type="gpointer" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6536">a valid #GValue of %G_TYPE_OBJECT derived type</doc>
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_object" c:identifier="g_value_get_object" gs:dll-name="gobject-2.0" gs:managed-name="GetObject" gs:property-getter-for="Object" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6534">Get the contents of a %G_TYPE_OBJECT derived #GValue.</doc>
        <source-position filename="gobject.h" line="622" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6540">object contents of @value</doc>
          <type name="Object" c:type="gpointer" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6536">a valid #GValue of %G_TYPE_OBJECT derived type</doc>
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_param" gs:dll-name="gobject-2.0" gs:managed-name="Param">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6544">Get the contents of a %G_TYPE_PARAM #GValue.</doc>
        <source-position filename="gparam.h" line="333" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6550">#GParamSpec content of @value</doc>
          <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6546">a valid #GValue whose type is derived from %G_TYPE_PARAM</doc>
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_param" c:identifier="g_value_get_param" gs:dll-name="gobject-2.0" gs:managed-name="GetParam" gs:property-getter-for="Param" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6544">Get the contents of a %G_TYPE_PARAM #GValue.</doc>
        <source-position filename="gparam.h" line="333" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6550">#GParamSpec content of @value</doc>
          <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6546">a valid #GValue whose type is derived from %G_TYPE_PARAM</doc>
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_pointer" gs:dll-name="gobject-2.0" gs:managed-name="Pointer">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6554">Get the contents of a pointer #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="268" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6560">pointer contents of @value</doc>
          <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6556">a valid #GValue of %G_TYPE_POINTER</doc>
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_pointer" c:identifier="g_value_get_pointer" gs:dll-name="gobject-2.0" gs:managed-name="GetPointer" gs:property-getter-for="Pointer" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6554">Get the contents of a pointer #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="268" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6560">pointer contents of @value</doc>
          <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6556">a valid #GValue of %G_TYPE_POINTER</doc>
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_char" version="2.32" gs:dll-name="gobject-2.0" gs:managed-name="Char">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6564">Get the contents of a %G_TYPE_CHAR #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="200" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6570">signed 8 bit integer contents of @value</doc>
          <type name="gint8" c:type="gint8" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6566">a valid #GValue of type %G_TYPE_CHAR</doc>
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_char" c:identifier="g_value_get_schar" version="2.32" gs:dll-name="gobject-2.0" gs:managed-name="GetChar" gs:property-getter-for="Char" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6564">Get the contents of a %G_TYPE_CHAR #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="200" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6570">signed 8 bit integer contents of @value</doc>
          <type name="gint8" c:type="gint8" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6566">a valid #GValue of type %G_TYPE_CHAR</doc>
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_string" gs:dll-name="gobject-2.0" gs:managed-name="String">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6575">Get the contents of a %G_TYPE_STRING #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="261" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6581">string content of @value</doc>
          <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6577">a valid #GValue of type %G_TYPE_STRING</doc>
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_string" c:identifier="g_value_get_string" gs:dll-name="gobject-2.0" gs:managed-name="GetString" gs:property-getter-for="String" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6575">Get the contents of a %G_TYPE_STRING #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="261" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6581">string content of @value</doc>
          <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6577">a valid #GValue of type %G_TYPE_STRING</doc>
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_u_char" gs:dll-name="gobject-2.0" gs:managed-name="UChar">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6585">Get the contents of a %G_TYPE_UCHAR #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="205" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6591">unsigned character contents of @value</doc>
          <type name="guint8" c:type="guchar" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6587">a valid #GValue of type %G_TYPE_UCHAR</doc>
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_u_char" c:identifier="g_value_get_uchar" gs:dll-name="gobject-2.0" gs:managed-name="GetUChar" gs:property-getter-for="UChar" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6585">Get the contents of a %G_TYPE_UCHAR #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="205" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6591">unsigned character contents of @value</doc>
          <type name="guint8" c:type="guchar" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6587">a valid #GValue of type %G_TYPE_UCHAR</doc>
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_u_int" gs:dll-name="gobject-2.0" gs:managed-name="UInt">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6595">Get the contents of a %G_TYPE_UINT #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="220" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6601">unsigned integer contents of @value</doc>
          <type name="guint" c:type="guint" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6597">a valid #GValue of type %G_TYPE_UINT</doc>
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_u_int" c:identifier="g_value_get_uint" gs:dll-name="gobject-2.0" gs:managed-name="GetUInt" gs:property-getter-for="UInt" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6595">Get the contents of a %G_TYPE_UINT #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="220" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6601">unsigned integer contents of @value</doc>
          <type name="guint" c:type="guint" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6597">a valid #GValue of type %G_TYPE_UINT</doc>
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_u_int64" gs:dll-name="gobject-2.0" gs:managed-name="UInt64">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6605">Get the contents of a %G_TYPE_UINT64 #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="240" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6611">unsigned 64bit integer contents of @value</doc>
          <type name="guint64" c:type="guint64" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6607">a valid #GValue of type %G_TYPE_UINT64</doc>
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_u_int64" c:identifier="g_value_get_uint64" gs:dll-name="gobject-2.0" gs:managed-name="GetUInt64" gs:property-getter-for="UInt64" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6605">Get the contents of a %G_TYPE_UINT64 #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="240" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6611">unsigned 64bit integer contents of @value</doc>
          <type name="guint64" c:type="guint64" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6607">a valid #GValue of type %G_TYPE_UINT64</doc>
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_u_long" gs:dll-name="gobject-2.0" gs:managed-name="ULong">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6615">Get the contents of a %G_TYPE_ULONG #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="230" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6621">unsigned long integer contents of @value</doc>
          <type name="gulong" c:type="gulong" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6617">a valid #GValue of type %G_TYPE_ULONG</doc>
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_u_long" c:identifier="g_value_get_ulong" gs:dll-name="gobject-2.0" gs:managed-name="GetULong" gs:property-getter-for="ULong" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6615">Get the contents of a %G_TYPE_ULONG #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="230" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6621">unsigned long integer contents of @value</doc>
          <type name="gulong" c:type="gulong" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6617">a valid #GValue of type %G_TYPE_ULONG</doc>
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_variant" version="2.26" gs:dll-name="gobject-2.0" gs:managed-name="Variant">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6625">Get the contents of a variant #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="283" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6631">variant contents of @value (may be %NULL)</doc>
          <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6627">a valid #GValue of type %G_TYPE_VARIANT</doc>
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_variant" c:identifier="g_value_get_variant" version="2.26" gs:dll-name="gobject-2.0" gs:managed-name="GetVariant" gs:property-getter-for="Variant" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6625">Get the contents of a variant #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="283" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6631">variant contents of @value (may be %NULL)</doc>
          <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6627">a valid #GValue of type %G_TYPE_VARIANT</doc>
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="init" c:identifier="g_value_init" gs:dll-name="gobject-2.0" gs:managed-name="Init">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6636">Initializes @value with the default value of @type.</doc>
        <source-position filename="gvalue.h" line="130" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6643">the #GValue structure that has been passed in</doc>
          <type name="Value" c:type="GValue*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6638">A zero-filled (uninitialized) #GValue structure.</doc>
            <type name="Value" c:type="GValue*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="g_type" transfer-ownership="none" gs:managed-name="gType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6639">Type the #GValue should hold values of.</doc>
            <type name="GType" c:type="GType" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="g_type" transfer-ownership="none" gs:managed-name="gType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6639">Type the #GValue should hold values of.</doc>
            <type name="GType" c:type="GType" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="init" c:identifier="g_value_init_from_instance" version="2.42" gs:dll-name="gobject-2.0" gs:managed-name="Init">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6647">Initializes and sets @value from an instantiatable type via the
value_table's collect_value() function.

Note: The @value will be initialised with the exact type of
@instance.  If you wish to set the @value's type to a different GType
(such as a parent class GType), you need to manually call
g_value_init() and g_value_set_instance().</doc>
        <source-position filename="gvalue.h" line="143" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6649">An uninitialized #GValue structure.</doc>
            <type name="Value" c:type="GValue*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="instance" transfer-ownership="none" gs:managed-name="instance" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6650">the instance</doc>
            <type name="TypeInstance" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="instance" transfer-ownership="none" gs:managed-name="instance" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6650">the instance</doc>
            <type name="TypeInstance" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="peek_pointer" c:identifier="g_value_peek_pointer" gs:pinvoke-only="1" gs:dll-name="gobject-2.0" gs:managed-name="PeekPointer">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6664">Returns the value contents as pointer. This function asserts that
g_value_fits_pointer() returned %TRUE for the passed in value.
This is an internal function introduced mainly for C marshallers.</doc>
        <source-position filename="gvalue.h" line="151" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6672">the value contents as pointer</doc>
          <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6666">An initialized #GValue structure</doc>
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="reset" c:identifier="g_value_reset" gs:dll-name="gobject-2.0" gs:managed-name="Reset">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6689">Clears the current value in @value and resets it to the default value
(as if the value had just been initialized).</doc>
        <source-position filename="gvalue.h" line="136" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6696">the #GValue structure that has been passed in</doc>
          <type name="Value" c:type="GValue*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6691">An initialized #GValue structure.</doc>
            <type name="Value" c:type="GValue*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="set_boolean" c:identifier="g_value_set_boolean" gs:dll-name="gobject-2.0" gs:managed-name="SetBoolean" gs:property-setter-for="Boolean" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6700">Set the contents of a %G_TYPE_BOOLEAN #GValue to @v_boolean.</doc>
        <source-position filename="gvaluetypes.h" line="207" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6702">a valid #GValue of type %G_TYPE_BOOLEAN</doc>
            <type name="Value" c:type="GValue*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="v_boolean" transfer-ownership="none" gs:managed-name="vBoolean" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6703">boolean value to be set</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="v_boolean" transfer-ownership="none" gs:managed-name="vBoolean" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6703">boolean value to be set</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_boxed" c:identifier="g_value_set_boxed" gs:pinvoke-only="1" gs:dll-name="gobject-2.0" gs:managed-name="SetBoxed">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6709">Set the contents of a %G_TYPE_BOXED derived #GValue to @v_boxed.</doc>
        <source-position filename="gboxed.h" line="76" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6711">a valid #GValue of %G_TYPE_BOXED derived type</doc>
            <type name="Value" c:type="GValue*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="v_boxed" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="vBoxed" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6712">boxed value to be set</doc>
            <type name="gpointer" c:type="gconstpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="v_boxed" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="vBoxed" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6712">boxed value to be set</doc>
            <type name="gpointer" c:type="gconstpointer" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_boxed_take_ownership" c:identifier="g_value_set_boxed_take_ownership" deprecated="1" deprecated-version="2.4" gs:pinvoke-only="1" gs:dll-name="gobject-2.0" gs:managed-name="SetBoxedTakeOwnership">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6718">This is an internal function introduced mainly for C marshallers.</doc>
        <doc-deprecated xml:space="preserve">Use g_value_take_boxed() instead.</doc-deprecated>
        <source-position filename="gboxed.h" line="85" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6720">a valid #GValue of %G_TYPE_BOXED derived type</doc>
            <type name="Value" c:type="GValue*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="v_boxed" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="vBoxed" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6721">duplicated unowned boxed value to be set</doc>
            <type name="gpointer" c:type="gconstpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="v_boxed" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="vBoxed" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6721">duplicated unowned boxed value to be set</doc>
            <type name="gpointer" c:type="gconstpointer" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_double" c:identifier="g_value_set_double" gs:dll-name="gobject-2.0" gs:managed-name="SetDouble" gs:property-setter-for="Double" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6740">Set the contents of a %G_TYPE_DOUBLE #GValue to @v_double.</doc>
        <source-position filename="gvaluetypes.h" line="247" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6742">a valid #GValue of type %G_TYPE_DOUBLE</doc>
            <type name="Value" c:type="GValue*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="v_double" transfer-ownership="none" gs:managed-name="vDouble" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6743">double value to be set</doc>
            <type name="gdouble" c:type="gdouble" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="v_double" transfer-ownership="none" gs:managed-name="vDouble" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6743">double value to be set</doc>
            <type name="gdouble" c:type="gdouble" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_enum" c:identifier="g_value_set_enum" gs:dll-name="gobject-2.0" gs:managed-name="SetEnum" gs:property-setter-for="Enum" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6749">Set the contents of a %G_TYPE_ENUM #GValue to @v_enum.</doc>
        <source-position filename="genums.h" line="243" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6751">a valid #GValue whose type is derived from %G_TYPE_ENUM</doc>
            <type name="Value" c:type="GValue*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="v_enum" transfer-ownership="none" gs:managed-name="vEnum" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6752">enum value to be set</doc>
            <type name="gint" c:type="gint" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="v_enum" transfer-ownership="none" gs:managed-name="vEnum" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6752">enum value to be set</doc>
            <type name="gint" c:type="gint" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_flags" c:identifier="g_value_set_flags" gs:dll-name="gobject-2.0" gs:managed-name="SetFlags" gs:property-setter-for="Flags" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6758">Set the contents of a %G_TYPE_FLAGS #GValue to @v_flags.</doc>
        <source-position filename="genums.h" line="248" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6760">a valid #GValue whose type is derived from %G_TYPE_FLAGS</doc>
            <type name="Value" c:type="GValue*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="v_flags" transfer-ownership="none" gs:managed-name="vFlags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6761">flags value to be set</doc>
            <type name="guint" c:type="guint" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="v_flags" transfer-ownership="none" gs:managed-name="vFlags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6761">flags value to be set</doc>
            <type name="guint" c:type="guint" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_float" c:identifier="g_value_set_float" gs:dll-name="gobject-2.0" gs:managed-name="SetFloat" gs:property-setter-for="Float" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6767">Set the contents of a %G_TYPE_FLOAT #GValue to @v_float.</doc>
        <source-position filename="gvaluetypes.h" line="242" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6769">a valid #GValue of type %G_TYPE_FLOAT</doc>
            <type name="Value" c:type="GValue*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="v_float" transfer-ownership="none" gs:managed-name="vFloat" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6770">float value to be set</doc>
            <type name="gfloat" c:type="gfloat" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="v_float" transfer-ownership="none" gs:managed-name="vFloat" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6770">float value to be set</doc>
            <type name="gfloat" c:type="gfloat" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_g_type" c:identifier="g_value_set_gtype" version="2.12" gs:dll-name="gobject-2.0" gs:managed-name="SetGType" gs:property-setter-for="GType" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6776">Set the contents of a %G_TYPE_GTYPE #GValue to @v_gtype.</doc>
        <source-position filename="gvaluetypes.h" line="272" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6778">a valid #GValue of type %G_TYPE_GTYPE</doc>
            <type name="Value" c:type="GValue*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="v_gtype" transfer-ownership="none" gs:managed-name="vGtype" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6779">#GType to be set</doc>
            <type name="GType" c:type="GType" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="v_gtype" transfer-ownership="none" gs:managed-name="vGtype" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6779">#GType to be set</doc>
            <type name="GType" c:type="GType" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set" c:identifier="g_value_set_instance" gs:dll-name="gobject-2.0" gs:managed-name="Set">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6787">Sets @value from an instantiatable type via the
value_table's collect_value() function.</doc>
        <source-position filename="gvalue.h" line="140" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6789">An initialized #GValue structure.</doc>
            <type name="Value" c:type="GValue*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="instance" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="instance" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6790">the instance</doc>
            <type name="TypeInstance" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="instance" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="instance" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6790">the instance</doc>
            <type name="TypeInstance" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_int" c:identifier="g_value_set_int" gs:dll-name="gobject-2.0" gs:managed-name="SetInt" gs:property-setter-for="Int" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6797">Set the contents of a %G_TYPE_INT #GValue to @v_int.</doc>
        <source-position filename="gvaluetypes.h" line="212" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6799">a valid #GValue of type %G_TYPE_INT</doc>
            <type name="Value" c:type="GValue*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="v_int" transfer-ownership="none" gs:managed-name="vInt" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6800">integer value to be set</doc>
            <type name="gint" c:type="gint" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="v_int" transfer-ownership="none" gs:managed-name="vInt" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6800">integer value to be set</doc>
            <type name="gint" c:type="gint" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_int64" c:identifier="g_value_set_int64" gs:dll-name="gobject-2.0" gs:managed-name="SetInt64" gs:property-setter-for="Int64" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6806">Set the contents of a %G_TYPE_INT64 #GValue to @v_int64.</doc>
        <source-position filename="gvaluetypes.h" line="232" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6808">a valid #GValue of type %G_TYPE_INT64</doc>
            <type name="Value" c:type="GValue*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="v_int64" transfer-ownership="none" gs:managed-name="vInt64" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6809">64bit integer value to be set</doc>
            <type name="gint64" c:type="gint64" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="v_int64" transfer-ownership="none" gs:managed-name="vInt64" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6809">64bit integer value to be set</doc>
            <type name="gint64" c:type="gint64" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_interned_string" c:identifier="g_value_set_interned_string" version="2.66" gs:dll-name="gobject-2.0" gs:managed-name="SetInternedString">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6815">Set the contents of a %G_TYPE_STRING #GValue to @v_string.  The string is
assumed to be static and interned (canonical, for example from
g_intern_string()), and is thus not duplicated when setting the #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="258" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6817">a valid #GValue of type %G_TYPE_STRING</doc>
            <type name="Value" c:type="GValue*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="v_string" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="vString" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6818">static string to be set</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="v_string" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="vString" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6818">static string to be set</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_long" c:identifier="g_value_set_long" gs:dll-name="gobject-2.0" gs:managed-name="SetLong" gs:property-setter-for="Long" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6828">Set the contents of a %G_TYPE_LONG #GValue to @v_long.</doc>
        <source-position filename="gvaluetypes.h" line="222" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6830">a valid #GValue of type %G_TYPE_LONG</doc>
            <type name="Value" c:type="GValue*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="v_long" transfer-ownership="none" gs:managed-name="vLong" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6831">long integer value to be set</doc>
            <type name="glong" c:type="glong" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="v_long" transfer-ownership="none" gs:managed-name="vLong" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6831">long integer value to be set</doc>
            <type name="glong" c:type="glong" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_object" c:identifier="g_value_set_object" gs:dll-name="gobject-2.0" gs:managed-name="SetObject" gs:property-setter-for="Object" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6837">Set the contents of a %G_TYPE_OBJECT derived #GValue to @v_object.

g_value_set_object() increases the reference count of @v_object
(the #GValue holds a reference to @v_object).  If you do not wish
to increase the reference count of the object (i.e. you wish to
pass your current reference to the #GValue because you no longer
need it), use g_value_take_object() instead.

It is important that your #GValue holds a reference to @v_object (either its
own, or one it has taken) to ensure that the object won't be destroyed while
the #GValue still exists).</doc>
        <source-position filename="gobject.h" line="619" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6839">a valid #GValue of %G_TYPE_OBJECT derived type</doc>
            <type name="Value" c:type="GValue*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="v_object" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="vObject" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6840">object value to be set</doc>
            <type name="Object" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="v_object" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="vObject" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6840">object value to be set</doc>
            <type name="Object" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_param" c:identifier="g_value_set_param" gs:dll-name="gobject-2.0" gs:managed-name="SetParam" gs:property-setter-for="Param" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6867">Set the contents of a %G_TYPE_PARAM #GValue to @param.</doc>
        <source-position filename="gparam.h" line="330" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6869">a valid #GValue of type %G_TYPE_PARAM</doc>
            <type name="Value" c:type="GValue*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="param" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="param" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6870">the #GParamSpec to be set</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="param" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="param" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6870">the #GParamSpec to be set</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_pointer" c:identifier="g_value_set_pointer" gs:dll-name="gobject-2.0" gs:managed-name="SetPointer" gs:property-setter-for="Pointer" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6887">Set the contents of a pointer #GValue to @v_pointer.</doc>
        <source-position filename="gvaluetypes.h" line="265" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6889">a valid #GValue of %G_TYPE_POINTER</doc>
            <type name="Value" c:type="GValue*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="v_pointer" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="vPointer" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6890">pointer value to be set</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="v_pointer" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="vPointer" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6890">pointer value to be set</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_char" c:identifier="g_value_set_schar" version="2.32" gs:dll-name="gobject-2.0" gs:managed-name="SetChar" gs:property-setter-for="Char" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6896">Set the contents of a %G_TYPE_CHAR #GValue to @v_char.</doc>
        <source-position filename="gvaluetypes.h" line="197" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6898">a valid #GValue of type %G_TYPE_CHAR</doc>
            <type name="Value" c:type="GValue*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="v_char" transfer-ownership="none" gs:managed-name="vChar" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6899">signed 8 bit integer to be set</doc>
            <type name="gint8" c:type="gint8" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="v_char" transfer-ownership="none" gs:managed-name="vChar" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6899">signed 8 bit integer to be set</doc>
            <type name="gint8" c:type="gint8" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_static_boxed" c:identifier="g_value_set_static_boxed" gs:pinvoke-only="1" gs:dll-name="gobject-2.0" gs:managed-name="SetStaticBoxed">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6907">Set the contents of a %G_TYPE_BOXED derived #GValue to @v_boxed.
The boxed value is assumed to be static, and is thus not duplicated
when setting the #GValue.</doc>
        <source-position filename="gboxed.h" line="79" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6909">a valid #GValue of %G_TYPE_BOXED derived type</doc>
            <type name="Value" c:type="GValue*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="v_boxed" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="vBoxed" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6910">static boxed value to be set</doc>
            <type name="gpointer" c:type="gconstpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="v_boxed" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="vBoxed" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6910">static boxed value to be set</doc>
            <type name="gpointer" c:type="gconstpointer" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_static_string" c:identifier="g_value_set_static_string" gs:dll-name="gobject-2.0" gs:managed-name="SetStaticString">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6918">Set the contents of a %G_TYPE_STRING #GValue to @v_string.
The string is assumed to be static, and is thus not duplicated
when setting the #GValue.

If the the string is a canonical string, using g_value_set_interned_string()
is more appropriate.</doc>
        <source-position filename="gvaluetypes.h" line="255" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6920">a valid #GValue of type %G_TYPE_STRING</doc>
            <type name="Value" c:type="GValue*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="v_string" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="vString" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6921">static string to be set</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="v_string" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="vString" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6921">static string to be set</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_string" c:identifier="g_value_set_string" gs:dll-name="gobject-2.0" gs:managed-name="SetString" gs:property-setter-for="String" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6932">Set the contents of a %G_TYPE_STRING #GValue to @v_string.</doc>
        <source-position filename="gvaluetypes.h" line="252" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6934">a valid #GValue of type %G_TYPE_STRING</doc>
            <type name="Value" c:type="GValue*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="v_string" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="vString" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6935">caller-owned string to be duplicated for the #GValue</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="v_string" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="vString" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6935">caller-owned string to be duplicated for the #GValue</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_string_take_ownership" c:identifier="g_value_set_string_take_ownership" deprecated="1" deprecated-version="2.4" gs:pinvoke-only="1" gs:dll-name="gobject-2.0" gs:managed-name="SetStringTakeOwnership">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6941">This is an internal function introduced mainly for C marshallers.</doc>
        <doc-deprecated xml:space="preserve">Use g_value_take_string() instead.</doc-deprecated>
        <source-position filename="gvaluetypes.h" line="301" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6943">a valid #GValue of type %G_TYPE_STRING</doc>
            <type name="Value" c:type="GValue*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="v_string" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="vString" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6944">duplicated unowned string to be set</doc>
            <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="v_string" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="vString" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6944">duplicated unowned string to be set</doc>
            <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_u_char" c:identifier="g_value_set_uchar" gs:dll-name="gobject-2.0" gs:managed-name="SetUChar" gs:property-setter-for="UChar" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6952">Set the contents of a %G_TYPE_UCHAR #GValue to @v_uchar.</doc>
        <source-position filename="gvaluetypes.h" line="202" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6954">a valid #GValue of type %G_TYPE_UCHAR</doc>
            <type name="Value" c:type="GValue*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="v_uchar" transfer-ownership="none" gs:managed-name="vUchar" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6955">unsigned character value to be set</doc>
            <type name="guint8" c:type="guchar" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="v_uchar" transfer-ownership="none" gs:managed-name="vUchar" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6955">unsigned character value to be set</doc>
            <type name="guint8" c:type="guchar" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_u_int" c:identifier="g_value_set_uint" gs:dll-name="gobject-2.0" gs:managed-name="SetUInt" gs:property-setter-for="UInt" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6961">Set the contents of a %G_TYPE_UINT #GValue to @v_uint.</doc>
        <source-position filename="gvaluetypes.h" line="217" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6963">a valid #GValue of type %G_TYPE_UINT</doc>
            <type name="Value" c:type="GValue*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="v_uint" transfer-ownership="none" gs:managed-name="vUint" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6964">unsigned integer value to be set</doc>
            <type name="guint" c:type="guint" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="v_uint" transfer-ownership="none" gs:managed-name="vUint" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6964">unsigned integer value to be set</doc>
            <type name="guint" c:type="guint" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_u_int64" c:identifier="g_value_set_uint64" gs:dll-name="gobject-2.0" gs:managed-name="SetUInt64" gs:property-setter-for="UInt64" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6970">Set the contents of a %G_TYPE_UINT64 #GValue to @v_uint64.</doc>
        <source-position filename="gvaluetypes.h" line="237" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6972">a valid #GValue of type %G_TYPE_UINT64</doc>
            <type name="Value" c:type="GValue*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="v_uint64" transfer-ownership="none" gs:managed-name="vUint64" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6973">unsigned 64bit integer value to be set</doc>
            <type name="guint64" c:type="guint64" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="v_uint64" transfer-ownership="none" gs:managed-name="vUint64" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6973">unsigned 64bit integer value to be set</doc>
            <type name="guint64" c:type="guint64" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_u_long" c:identifier="g_value_set_ulong" gs:dll-name="gobject-2.0" gs:managed-name="SetULong" gs:property-setter-for="ULong" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6979">Set the contents of a %G_TYPE_ULONG #GValue to @v_ulong.</doc>
        <source-position filename="gvaluetypes.h" line="227" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6981">a valid #GValue of type %G_TYPE_ULONG</doc>
            <type name="Value" c:type="GValue*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="v_ulong" transfer-ownership="none" gs:managed-name="vUlong" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6982">unsigned long integer value to be set</doc>
            <type name="gulong" c:type="gulong" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="v_ulong" transfer-ownership="none" gs:managed-name="vUlong" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6982">unsigned long integer value to be set</doc>
            <type name="gulong" c:type="gulong" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_variant" c:identifier="g_value_set_variant" version="2.26" gs:dll-name="gobject-2.0" gs:managed-name="SetVariant" gs:property-setter-for="Variant" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6988">Set the contents of a variant #GValue to @variant.
If the variant is floating, it is consumed.</doc>
        <source-position filename="gvaluetypes.h" line="277" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6990">a valid #GValue of type %G_TYPE_VARIANT</doc>
            <type name="Value" c:type="GValue*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="variant" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="variant" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6991">a #GVariant, or %NULL</doc>
            <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="variant" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="variant" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6991">a #GVariant, or %NULL</doc>
            <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="take_boxed" c:identifier="g_value_take_boxed" version="2.4" gs:pinvoke-only="1" gs:dll-name="gobject-2.0" gs:managed-name="TakeBoxed">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="7000">Sets the contents of a %G_TYPE_BOXED derived #GValue to @v_boxed
and takes over the ownership of the caller’s reference to @v_boxed;
the caller doesn’t have to unref it any more.</doc>
        <source-position filename="gboxed.h" line="82" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="7002">a valid #GValue of %G_TYPE_BOXED derived type</doc>
            <type name="Value" c:type="GValue*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="v_boxed" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="vBoxed" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="7003">duplicated unowned boxed value to be set</doc>
            <type name="gpointer" c:type="gconstpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="v_boxed" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="vBoxed" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="7003">duplicated unowned boxed value to be set</doc>
            <type name="gpointer" c:type="gconstpointer" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="take_string" c:identifier="g_value_take_string" version="2.4" gs:pinvoke-only="1" gs:dll-name="gobject-2.0" gs:managed-name="TakeString">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="7043">Sets the contents of a %G_TYPE_STRING #GValue to @v_string.</doc>
        <source-position filename="gvaluetypes.h" line="298" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="7045">a valid #GValue of type %G_TYPE_STRING</doc>
            <type name="Value" c:type="GValue*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="v_string" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="vString" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="7046">string to take ownership of</doc>
            <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="v_string" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="vString" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="7046">string to take ownership of</doc>
            <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="take_variant" c:identifier="g_value_take_variant" version="2.26" gs:pinvoke-only="1" gs:dll-name="gobject-2.0" gs:managed-name="TakeVariant">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="7054">Set the contents of a variant #GValue to @variant, and takes over
the ownership of the caller's reference to @variant;
the caller doesn't have to unref it any more (i.e. the reference
count of the variant is not increased).

If @variant was floating then its floating reference is converted to
a hard reference.

If you want the #GValue to hold its own reference to @variant, use
g_value_set_variant() instead.

This is an internal function introduced mainly for C marshallers.</doc>
        <source-position filename="gvaluetypes.h" line="280" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="7056">a valid #GValue of type %G_TYPE_VARIANT</doc>
            <type name="Value" c:type="GValue*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="variant" transfer-ownership="full" nullable="1" allow-none="1" gs:managed-name="variant" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="7057">a #GVariant, or %NULL</doc>
            <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="variant" transfer-ownership="full" nullable="1" allow-none="1" gs:managed-name="variant" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="7057">a #GVariant, or %NULL</doc>
            <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="transform" c:identifier="g_value_transform" gs:dll-name="gobject-2.0" gs:managed-name="Transform">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="7076">Tries to cast the contents of @src_value into a type appropriate
to store in @dest_value, e.g. to transform a %G_TYPE_INT value
into a %G_TYPE_FLOAT value. Performing transformations between
value types might incur precision lossage. Especially
transformations into strings might reveal seemingly arbitrary
results and shouldn't be relied upon for production code (such
as rcfile value or object property serialization).</doc>
        <source-position filename="gvalue.h" line="162" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="7089">Whether a transformation rule was found and could be applied.
 Upon failing transformations, @dest_value is left untouched.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="src_value" transfer-ownership="none" gs:managed-name="srcValue" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="7078">Source value.</doc>
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="dest_value" transfer-ownership="none" gs:managed-name="destValue" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="7079">Target value.</doc>
            <type name="Value" c:type="GValue*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="dest_value" transfer-ownership="none" gs:managed-name="destValue" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="7079">Target value.</doc>
            <type name="Value" c:type="GValue*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="unset" c:identifier="g_value_unset" gs:dll-name="gobject-2.0" gs:managed-name="Unset">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="7120">Clears the current value in @value (if any) and "unsets" the type,
this releases all resources associated with this GValue. An unset
value is the same as an uninitialized (zero-filled) #GValue
structure.</doc>
        <source-position filename="gvalue.h" line="138" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="7122">An initialized #GValue structure.</doc>
            <type name="Value" c:type="GValue*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <function name="register_transform_func" c:identifier="g_value_register_transform_func" introspectable="1" gs:pinvoke-only="1" gs:dll-name="gobject-2.0" gs:managed-name="RegisterTransformFunc">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6676">Registers a value transformation function for use in g_value_transform().
A previously registered transformation function for @src_type and @dest_type
will be replaced.</doc>
        <source-position filename="gvalue.h" line="165" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <parameter name="src_type" transfer-ownership="none" gs:managed-name="srcType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6678">Source type.</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="dest_type" transfer-ownership="none" gs:managed-name="destType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6679">Target type.</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="transform_func" transfer-ownership="none" gs:managed-name="transformFunc" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6680">a function which transforms values of type @src_type
 into value of type @dest_type</doc>
            <type name="ValueTransform" c:type="GValueTransform" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="src_type" transfer-ownership="none" gs:managed-name="srcType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6678">Source type.</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="dest_type" transfer-ownership="none" gs:managed-name="destType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6679">Target type.</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="transform_func" transfer-ownership="none" gs:managed-name="transformFunc" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6680">a function which transforms values of type @src_type
 into value of type @dest_type</doc>
            <type name="ValueTransform" c:type="GValueTransform" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="type_compatible" c:identifier="g_value_type_compatible" gs:dll-name="gobject-2.0" gs:managed-name="TypeCompatible">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="7094">Returns whether a #GValue of type @src_type can be copied into
a #GValue of type @dest_type.</doc>
        <source-position filename="gvalue.h" line="156" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="7102">%TRUE if g_value_copy() is possible with @src_type and @dest_type.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <parameter name="src_type" transfer-ownership="none" gs:managed-name="srcType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="7096">source type to be copied.</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="dest_type" transfer-ownership="none" gs:managed-name="destType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="7097">destination type for copying.</doc>
            <type name="GType" c:type="GType" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="src_type" transfer-ownership="none" gs:managed-name="srcType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="7096">source type to be copied.</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="dest_type" transfer-ownership="none" gs:managed-name="destType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="7097">destination type for copying.</doc>
            <type name="GType" c:type="GType" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="type_transformable" c:identifier="g_value_type_transformable" gs:dll-name="gobject-2.0" gs:managed-name="TypeTransformable">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="7106">Check whether g_value_transform() is able to transform values
of type @src_type into values of type @dest_type. Note that for
the types to be transformable, they must be compatible or a
transformation function must be registered.</doc>
        <source-position filename="gvalue.h" line="159" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="7116">%TRUE if the transformation is possible, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <parameter name="src_type" transfer-ownership="none" gs:managed-name="srcType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="7108">Source type.</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="dest_type" transfer-ownership="none" gs:managed-name="destType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="7109">Target type.</doc>
            <type name="GType" c:type="GType" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="src_type" transfer-ownership="none" gs:managed-name="srcType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="7108">Source type.</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="dest_type" transfer-ownership="none" gs:managed-name="destType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="7109">Target type.</doc>
            <type name="GType" c:type="GType" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="strdup_value_contents" c:identifier="g_strdup_value_contents" gs:pinvoke-only="1" gs:dll-name="gobject-2.0" gs:managed-name="StrdupValueContents">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="5185">Return a newly allocated string, which describes the contents of a
#GValue.  The main purpose of this function is to describe #GValue
contents for debugging output, the way in which the contents are
described may change between different GLib versions.</doc>
        <source-position filename="gvaluetypes.h" line="294" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="5194">Newly allocated string.</doc>
          <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5187">#GValue which contents are to be described.</doc>
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5187">#GValue which contents are to be described.</doc>
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <constant name="INTERNED_STRING" value="268435456" c:type="G_VALUE_INTERNED_STRING" version="2.66" gs:access-modifiers="private" gs:managed-name="internedString">
        <doc xml:space="preserve" filename="gvalue.h" line="179">For string values, indicates that the string contained is canonical and will
exist for the duration of the process. See g_value_set_interned_string().</doc>
        <source-position filename="gvalue.h" line="187" />
        <type name="gint" c:type="gint" />
      </constant>
      <constant name="NOCOPY_CONTENTS" value="134217728" c:type="G_VALUE_NOCOPY_CONTENTS" gs:access-modifiers="private" gs:managed-name="nocopyContents">
        <doc xml:space="preserve" filename="gvalue.h" line="169">If passed to G_VALUE_COLLECT(), allocated data won't be copied
but used verbatim. This does not affect ref-counted types like
objects. This does not affect usage of g_value_copy(), the data will
be copied if it is not ref-counted.</doc>
        <source-position filename="gvalue.h" line="177" />
        <type name="gint" c:type="gint" />
      </constant>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_value_get_type" gs:access-modifiers="private" gs:dll-name="gobject-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </record>
    <callback name="ValueTransform" c:type="GValueTransform" gs:dll-name="gobject-2.0" gs:managed-name="ValueTransform">
      <doc xml:space="preserve" filename="gvalue.h" line="84">The type of value transformation functions which can be registered with
g_value_register_transform_func().

@dest_value will be initialized to the correct destination type.</doc>
      <source-position filename="gvalue.h" line="94" />
      <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
        <type name="none" c:type="void" />
      </return-value>
      <parameters>
        <parameter name="src_value" transfer-ownership="none" gs:managed-name="srcValue" direction="in">
          <doc xml:space="preserve" filename="gvalue.h" line="86">Source value.</doc>
          <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
        </parameter>
        <parameter name="dest_value" transfer-ownership="none" gs:managed-name="destValue" direction="in">
          <doc xml:space="preserve" filename="gvalue.h" line="87">Target value.</doc>
          <type name="Value" c:type="GValue*" gs:is-pointer="1" />
        </parameter>
      </parameters>
      <gs:managed-parameters>
        <parameter name="src_value" transfer-ownership="none" gs:managed-name="srcValue" direction="in">
          <doc xml:space="preserve" filename="gvalue.h" line="86">Source value.</doc>
          <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
        </parameter>
        <parameter name="dest_value" transfer-ownership="none" gs:managed-name="destValue" direction="in">
          <doc xml:space="preserve" filename="gvalue.h" line="87">Target value.</doc>
          <type name="Value" c:type="GValue*" gs:is-pointer="1" />
        </parameter>
      </gs:managed-parameters>
    </callback>
    <union name="_Value__data__union" gs:managed-name="ValueDataUnion">
      <field name="v_int" writable="1" gs:managed-name="VInt">
        <type name="gint" c:type="gint" />
      </field>
      <field name="v_uint" writable="1" gs:managed-name="VUint">
        <type name="guint" c:type="guint" />
      </field>
      <field name="v_long" writable="1" gs:managed-name="VLong">
        <type name="glong" c:type="glong" />
      </field>
      <field name="v_ulong" writable="1" gs:managed-name="VUlong">
        <type name="gulong" c:type="gulong" />
      </field>
      <field name="v_int64" writable="1" gs:managed-name="VInt64">
        <type name="gint64" c:type="gint64" />
      </field>
      <field name="v_uint64" writable="1" gs:managed-name="VUint64">
        <type name="guint64" c:type="guint64" />
      </field>
      <field name="v_float" writable="1" gs:managed-name="VFloat">
        <type name="gfloat" c:type="gfloat" />
      </field>
      <field name="v_double" writable="1" gs:managed-name="VDouble">
        <type name="gdouble" c:type="gdouble" />
      </field>
      <field name="v_pointer" writable="1" gs:managed-name="VPointer">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
    </union>
    <docsection name="enumerations_flags" gs:managed-name="EnumerationsFlags">
      <doc xml:space="preserve" filename="gobject-2.0.c" line="125">The GLib type system provides fundamental types for enumeration and
flags types. (Flags types are like enumerations, but allow their
values to be combined by bitwise or). A registered enumeration or
flags type associates a name and a nickname with each allowed
value, and the methods g_enum_get_value_by_name(),
g_enum_get_value_by_nick(), g_flags_get_value_by_name() and
g_flags_get_value_by_nick() can look up values by their name or
nickname.  When an enumeration or flags type is registered with the
GLib type system, it can be used as value type for object
properties, using g_param_spec_enum() or g_param_spec_flags().

GObject ships with a utility called [glib-mkenums][glib-mkenums],
that can construct suitable type registration functions from C enumeration
definitions.

Example of how to get a string representation of an enum value:
|[&lt;!-- language="C" --&gt;
GEnumClass *enum_class;
GEnumValue *enum_value;

enum_class = g_type_class_ref (MAMAN_TYPE_MY_ENUM);
enum_value = g_enum_get_value (enum_class, MAMAN_MY_ENUM_FOO);

g_print ("Name: %s\n", enum_value-&gt;value_name);

g_type_class_unref (enum_class);
]|</doc>
    </docsection>
    <docsection name="gboxed" gs:managed-name="Gboxed">
      <doc xml:space="preserve" filename="gobject-2.0.c" line="247">#GBoxed is a generic wrapper mechanism for arbitrary C structures. The only
thing the type system needs to know about the structures is how to copy them
(a #GBoxedCopyFunc) and how to free them (a #GBoxedFreeFunc) — beyond that
they are treated as opaque chunks of memory.

Boxed types are useful for simple value-holder structures like rectangles or
points. They can also be used for wrapping structures defined in non-#GObject
based libraries. They allow arbitrary structures to be handled in a uniform
way, allowing uniform copying (or referencing) and freeing (or unreferencing)
of them, and uniform representation of the type of the contained structure.
In turn, this allows any type which can be boxed to be set as the data in a
#GValue, which allows for polymorphic handling of a much wider range of data
types, and hence usage of such types as #GObject property values.

#GBoxed is designed so that reference counted types can be boxed. Use the
type’s ‘ref’ function as the #GBoxedCopyFunc, and its ‘unref’ function as the
#GBoxedFreeFunc. For example, for #GBytes, the #GBoxedCopyFunc is
g_bytes_ref(), and the #GBoxedFreeFunc is g_bytes_unref().</doc>
    </docsection>
    <docsection name="generic_values" gs:managed-name="GenericValues">
      <doc xml:space="preserve" filename="gobject-2.0.c" line="326">The #GValue structure is basically a variable container that consists
of a type identifier and a specific value of that type.
The type identifier within a #GValue structure always determines the
type of the associated value.
To create an undefined #GValue structure, simply create a zero-filled
#GValue structure. To initialize the #GValue, use the g_value_init()
function. A #GValue cannot be used until it is initialized.
The basic type operations (such as freeing and copying) are determined
by the #GTypeValueTable associated with the type ID stored in the #GValue.
Other #GValue operations (such as converting values between types) are
provided by this interface.

The code in the example program below demonstrates #GValue's
features.

|[&lt;!-- language="C" --&gt;
#include &lt;glib-object.h&gt;

static void
int2string (const GValue *src_value,
            GValue       *dest_value)
{
  if (g_value_get_int (src_value) == 42)
    g_value_set_static_string (dest_value, "An important number");
  else
    g_value_set_static_string (dest_value, "What's that?");
}

int
main (int   argc,
      char *argv[])
{
  // GValues must be initialized
  GValue a = G_VALUE_INIT;
  GValue b = G_VALUE_INIT;
  const gchar *message;

  // The GValue starts empty
  g_assert (!G_VALUE_HOLDS_STRING (&amp;a));

  // Put a string in it
  g_value_init (&amp;a, G_TYPE_STRING);
  g_assert (G_VALUE_HOLDS_STRING (&amp;a));
  g_value_set_static_string (&amp;a, "Hello, world!");
  g_printf ("%s\n", g_value_get_string (&amp;a));

  // Reset it to its pristine state
  g_value_unset (&amp;a);

  // It can then be reused for another type
  g_value_init (&amp;a, G_TYPE_INT);
  g_value_set_int (&amp;a, 42);

  // Attempt to transform it into a GValue of type STRING
  g_value_init (&amp;b, G_TYPE_STRING);

  // An INT is transformable to a STRING
  g_assert (g_value_type_transformable (G_TYPE_INT, G_TYPE_STRING));

  g_value_transform (&amp;a, &amp;b);
  g_printf ("%s\n", g_value_get_string (&amp;b));

  // Attempt to transform it again using a custom transform function
  g_value_register_transform_func (G_TYPE_INT, G_TYPE_STRING, int2string);
  g_value_transform (&amp;a, &amp;b);
  g_printf ("%s\n", g_value_get_string (&amp;b));
  return 0;
}
]|</doc>
    </docsection>
    <docsection name="gtype" gs:managed-name="Gtype">
      <doc xml:space="preserve" filename="gobject-2.0.c" line="433">The GType API is the foundation of the GObject system.  It provides the
facilities for registering and managing all fundamental data types,
user-defined object and interface types.

For type creation and registration purposes, all types fall into one of
two categories: static or dynamic.  Static types are never loaded or
unloaded at run-time as dynamic types may be.  Static types are created
with g_type_register_static() that gets type specific information passed
in via a #GTypeInfo structure.

Dynamic types are created with g_type_register_dynamic() which takes a
#GTypePlugin structure instead. The remaining type information (the
#GTypeInfo structure) is retrieved during runtime through #GTypePlugin
and the g_type_plugin_*() API.

These registration functions are usually called only once from a
function whose only purpose is to return the type identifier for a
specific class.  Once the type (or class or interface) is registered,
it may be instantiated, inherited, or implemented depending on exactly
what sort of type it is.

There is also a third registration function for registering fundamental
types called g_type_register_fundamental() which requires both a #GTypeInfo
structure and a #GTypeFundamentalInfo structure but it is seldom used
since most fundamental types are predefined rather than user-defined.

Type instance and class structs are limited to a total of 64 KiB,
including all parent types. Similarly, type instances' private data
(as created by G_ADD_PRIVATE()) are limited to a total of
64 KiB. If a type instance needs a large static buffer, allocate it
separately (typically by using #GArray or #GPtrArray) and put a pointer
to the buffer in the structure.

As mentioned in the [GType conventions][gtype-conventions], type names must
be at least three characters long. There is no upper length limit. The first
character must be a letter (a–z or A–Z) or an underscore (‘_’). Subsequent
characters can be letters, numbers or any of ‘-_+’.</doc>
    </docsection>
    <docsection name="objects" gs:managed-name="Objects">
      <doc xml:space="preserve" filename="gobject-2.0.c" line="570">GObject is the fundamental type providing the common attributes and
methods for all object types in GTK+, Pango and other libraries
based on GObject.  The GObject class provides methods for object
construction and destruction, property access methods, and signal
support.  Signals are described in detail [here][gobject-Signals].

For a tutorial on implementing a new GObject class, see [How to define and
implement a new GObject][howto-gobject]. For a list of naming conventions for
GObjects and their methods, see the [GType conventions][gtype-conventions].
For the high-level concepts behind GObject, read [Instantiatable classed types:
Objects][gtype-instantiatable-classed].

## Floating references # {#floating-ref}

**Note**: Floating references are a C convenience API and should not be
used in modern GObject code. Language bindings in particular find the
concept highly problematic, as floating references are not identifiable
through annotations, and neither are deviations from the floating reference
behavior, like types that inherit from #GInitiallyUnowned and still return
a full reference from g_object_new().

GInitiallyUnowned is derived from GObject. The only difference between
the two is that the initial reference of a GInitiallyUnowned is flagged
as a "floating" reference. This means that it is not specifically
claimed to be "owned" by any code portion. The main motivation for
providing floating references is C convenience. In particular, it
allows code to be written as:
|[&lt;!-- language="C" --&gt;
container = create_container ();
container_add_child (container, create_child());
]|
If container_add_child() calls g_object_ref_sink() on the passed-in child,
no reference of the newly created child is leaked. Without floating
references, container_add_child() can only g_object_ref() the new child,
so to implement this code without reference leaks, it would have to be
written as:
|[&lt;!-- language="C" --&gt;
Child *child;
container = create_container ();
child = create_child ();
container_add_child (container, child);
g_object_unref (child);
]|
The floating reference can be converted into an ordinary reference by
calling g_object_ref_sink(). For already sunken objects (objects that
don't have a floating reference anymore), g_object_ref_sink() is equivalent
to g_object_ref() and returns a new reference.

Since floating references are useful almost exclusively for C convenience,
language bindings that provide automated reference and memory ownership
maintenance (such as smart pointers or garbage collection) should not
expose floating references in their API. The best practice for handling
types that have initially floating references is to immediately sink those
references after g_object_new() returns, by checking if the #GType
inherits from #GInitiallyUnowned. For instance:

|[&lt;!-- language="C" --&gt;
GObject *res = g_object_new_with_properties (gtype,
                                             n_props,
                                             prop_names,
                                             prop_values);

// or: if (g_type_is_a (gtype, G_TYPE_INITIALLY_UNOWNED))
if (G_IS_INITIALLY_UNOWNED (res))
  g_object_ref_sink (res);

return res;
]|

Some object implementations may need to save an objects floating state
across certain code portions (an example is #GtkMenu), to achieve this,
the following sequence can be used:

|[&lt;!-- language="C" --&gt;
// save floating state
gboolean was_floating = g_object_is_floating (object);
g_object_ref_sink (object);
// protected code portion

...

// restore floating state
if (was_floating)
  g_object_force_floating (object);
else
  g_object_unref (object); // release previously acquired reference
]|</doc>
    </docsection>
    <docsection name="param_value_types" gs:managed-name="ParamValueTypes">
      <doc xml:space="preserve" filename="gobject-2.0.c" line="666">#GValue provides an abstract container structure which can be
copied, transformed and compared while holding a value of any
(derived) type, which is registered as a #GType with a
#GTypeValueTable in its #GTypeInfo structure.  Parameter
specifications for most value types can be created as #GParamSpec
derived instances, to implement e.g. #GObject properties which
operate on #GValue containers.

Parameter names need to start with a letter (a-z or A-Z). Subsequent
characters can be letters, numbers or a '-'.
All other characters are replaced by a '-' during construction.</doc>
    </docsection>
    <docsection name="signals" gs:managed-name="Signals">
      <doc xml:space="preserve" filename="gobject-2.0.c" line="686">The basic concept of the signal system is that of the emission
of a signal. Signals are introduced per-type and are identified
through strings. Signals introduced for a parent type are available
in derived types as well, so basically they are a per-type facility
that is inherited.

A signal emission mainly involves invocation of a certain set of
callbacks in precisely defined manner. There are two main categories
of such callbacks, per-object ones and user provided ones.
(Although signals can deal with any kind of instantiatable type, I'm
referring to those types as "object types" in the following, simply
because that is the context most users will encounter signals in.)
The per-object callbacks are most often referred to as "object method
handler" or "default (signal) handler", while user provided callbacks are
usually just called "signal handler".

The object method handler is provided at signal creation time (this most
frequently happens at the end of an object class' creation), while user
provided handlers are frequently connected and disconnected to/from a
certain signal on certain object instances.

A signal emission consists of five stages, unless prematurely stopped:

1. Invocation of the object method handler for %G_SIGNAL_RUN_FIRST signals

2. Invocation of normal user-provided signal handlers (where the @after
   flag is not set)

3. Invocation of the object method handler for %G_SIGNAL_RUN_LAST signals

4. Invocation of user provided signal handlers (where the @after flag is set)

5. Invocation of the object method handler for %G_SIGNAL_RUN_CLEANUP signals

The user-provided signal handlers are called in the order they were
connected in.

All handlers may prematurely stop a signal emission, and any number of
handlers may be connected, disconnected, blocked or unblocked during
a signal emission.

There are certain criteria for skipping user handlers in stages 2 and 4
of a signal emission.

First, user handlers may be blocked. Blocked handlers are omitted during
callback invocation, to return from the blocked state, a handler has to
get unblocked exactly the same amount of times it has been blocked before.

Second, upon emission of a %G_SIGNAL_DETAILED signal, an additional
@detail argument passed in to g_signal_emit() has to match the detail
argument of the signal handler currently subject to invocation.
Specification of no detail argument for signal handlers (omission of the
detail part of the signal specification upon connection) serves as a
wildcard and matches any detail argument passed in to emission.

While the @detail argument is typically used to pass an object property name
(as with #GObject::notify), no specific format is mandated for the detail
string, other than that it must be non-empty.

## Memory management of signal handlers # {#signal-memory-management}

If you are connecting handlers to signals and using a #GObject instance as
your signal handler user data, you should remember to pair calls to
g_signal_connect() with calls to g_signal_handler_disconnect() or
g_signal_handlers_disconnect_by_func(). While signal handlers are
automatically disconnected when the object emitting the signal is finalised,
they are not automatically disconnected when the signal handler user data is
destroyed. If this user data is a #GObject instance, using it from a
signal handler after it has been finalised is an error.

There are two strategies for managing such user data. The first is to
disconnect the signal handler (using g_signal_handler_disconnect() or
g_signal_handlers_disconnect_by_func()) when the user data (object) is
finalised; this has to be implemented manually. For non-threaded programs,
g_signal_connect_object() can be used to implement this automatically.
Currently, however, it is unsafe to use in threaded programs.

The second is to hold a strong reference on the user data until after the
signal is disconnected for other reasons. This can be implemented
automatically using g_signal_connect_data().

The first approach is recommended, as the second approach can result in
effective memory leaks of the user data if the signal handler is never
disconnected for some reason.</doc>
    </docsection>
    <docsection name="value_arrays" gs:managed-name="ValueArrays">
      <doc xml:space="preserve" filename="gobject-2.0.c" line="779">The prime purpose of a #GValueArray is for it to be used as an
object property that holds an array of values. A #GValueArray wraps
an array of #GValue elements in order for it to be used as a boxed
type through %G_TYPE_VALUE_ARRAY.

#GValueArray is deprecated in favour of #GArray since GLib 2.32. It
is possible to create a #GArray that behaves like a #GValueArray by
using the size of #GValue as the element size, and by setting
g_value_unset() as the clear function using g_array_set_clear_func(),
for instance, the following code:

|[&lt;!-- language="C" --&gt;
  GValueArray *array = g_value_array_new (10);
]|

can be replaced by:

|[&lt;!-- language="C" --&gt;
  GArray *array = g_array_sized_new (FALSE, TRUE, sizeof (GValue), 10);
  g_array_set_clear_func (array, (GDestroyNotify) g_value_unset);
]|</doc>
    </docsection>
    <gs:static-class name="Flags" gs:managed-name="Flags">
      <function name="complete_type_info" c:identifier="g_flags_complete_type_info" gs:dll-name="gobject-2.0" gs:managed-name="CompleteTypeInfo">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2284">This function is meant to be called from the complete_type_info()
function of a #GTypePlugin implementation, see the example for
g_enum_complete_type_info() above.</doc>
        <source-position filename="genums.h" line="273" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <parameter name="g_flags_type" transfer-ownership="none" gs:managed-name="gFlagsType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2286">the type identifier of the type being completed</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="info" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="info">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2287">the #GTypeInfo struct to be filled in</doc>
            <type name="TypeInfo" c:type="GTypeInfo*" />
          </parameter>
          <parameter name="const_values" transfer-ownership="none" gs:managed-name="constValues" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2288">An array of #GFlagsValue structs for the possible
 enumeration values. The array is terminated by a struct with all
 members being 0.</doc>
            <array zero-terminated="1" c:type="const GFlagsValue*" gs:is-pointer="1">
              <type name="FlagsValue" c:type="const GFlagsValue" />
            </array>
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="g_flags_type" transfer-ownership="none" gs:managed-name="gFlagsType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2286">the type identifier of the type being completed</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="info" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="info">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2287">the #GTypeInfo struct to be filled in</doc>
            <type name="TypeInfo" c:type="GTypeInfo*" />
          </parameter>
          <parameter name="const_values" transfer-ownership="none" gs:managed-name="constValues" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2288">An array of #GFlagsValue structs for the possible
 enumeration values. The array is terminated by a struct with all
 members being 0.</doc>
            <array zero-terminated="1" c:type="const GFlagsValue*" gs:is-pointer="1">
              <type name="FlagsValue" c:type="const GFlagsValue" />
            </array>
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="get_first_value" c:identifier="g_flags_get_first_value" gs:dll-name="gobject-2.0" gs:managed-name="GetFirstValue">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2298">Returns the first #GFlagsValue which is set in @value.</doc>
        <source-position filename="genums.h" line="228" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="2305">the first #GFlagsValue which is set in
         @value, or %NULL if none is set</doc>
          <type name="FlagsValue" c:type="GFlagsValue*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="flags_class" transfer-ownership="none" gs:managed-name="flagsClass" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2300">a #GFlagsClass</doc>
            <type name="FlagsClass" c:type="GFlagsClass*" gs:is-pointer="1" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2301">the value</doc>
            <type name="guint" c:type="guint" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="flags_class" transfer-ownership="none" gs:managed-name="flagsClass" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2300">a #GFlagsClass</doc>
            <type name="FlagsClass" c:type="GFlagsClass*" gs:is-pointer="1" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2301">the value</doc>
            <type name="guint" c:type="guint" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="get_value_by_name" c:identifier="g_flags_get_value_by_name" gs:dll-name="gobject-2.0" gs:managed-name="GetValueByName">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2310">Looks up a #GFlagsValue by name.</doc>
        <source-position filename="genums.h" line="231" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="2317">the #GFlagsValue with name @name,
         or %NULL if there is no flag with that name</doc>
          <type name="FlagsValue" c:type="GFlagsValue*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="flags_class" transfer-ownership="none" gs:managed-name="flagsClass" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2312">a #GFlagsClass</doc>
            <type name="FlagsClass" c:type="GFlagsClass*" gs:is-pointer="1" />
          </parameter>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2313">the name to look up</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="flags_class" transfer-ownership="none" gs:managed-name="flagsClass" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2312">a #GFlagsClass</doc>
            <type name="FlagsClass" c:type="GFlagsClass*" gs:is-pointer="1" />
          </parameter>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2313">the name to look up</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="get_value_by_nick" c:identifier="g_flags_get_value_by_nick" gs:dll-name="gobject-2.0" gs:managed-name="GetValueByNick">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2322">Looks up a #GFlagsValue by nickname.</doc>
        <source-position filename="genums.h" line="234" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="2329">the #GFlagsValue with nickname @nick,
         or %NULL if there is no flag with that nickname</doc>
          <type name="FlagsValue" c:type="GFlagsValue*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="flags_class" transfer-ownership="none" gs:managed-name="flagsClass" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2324">a #GFlagsClass</doc>
            <type name="FlagsClass" c:type="GFlagsClass*" gs:is-pointer="1" />
          </parameter>
          <parameter name="nick" transfer-ownership="none" gs:managed-name="nick" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2325">the nickname to look up</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="flags_class" transfer-ownership="none" gs:managed-name="flagsClass" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2324">a #GFlagsClass</doc>
            <type name="FlagsClass" c:type="GFlagsClass*" gs:is-pointer="1" />
          </parameter>
          <parameter name="nick" transfer-ownership="none" gs:managed-name="nick" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2325">the nickname to look up</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="register_static" c:identifier="g_flags_register_static" gs:dll-name="gobject-2.0" gs:managed-name="RegisterStatic">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2334">Registers a new static flags type with the name @name.

It is normally more convenient to let [glib-mkenums][glib-mkenums]
generate a my_flags_get_type() function from a usual C enumeration
definition than to write one yourself using g_flags_register_static().</doc>
        <source-position filename="genums.h" line="263" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="2347">The new type identifier.</doc>
          <type name="GType" c:type="GType" />
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2336">A nul-terminated string used as the name of the new type.</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="const_static_values" transfer-ownership="none" gs:managed-name="constStaticValues" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2337">An array of #GFlagsValue structs for the possible
 flags values. The array is terminated by a struct with all members being 0.
 GObject keeps a reference to the data, so it cannot be stack-allocated.</doc>
            <array zero-terminated="1" c:type="const GFlagsValue*" gs:is-pointer="1">
              <type name="FlagsValue" c:type="const GFlagsValue" />
            </array>
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2336">A nul-terminated string used as the name of the new type.</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="const_static_values" transfer-ownership="none" gs:managed-name="constStaticValues" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2337">An array of #GFlagsValue structs for the possible
 flags values. The array is terminated by a struct with all members being 0.
 GObject keeps a reference to the data, so it cannot be stack-allocated.</doc>
            <array zero-terminated="1" c:type="const GFlagsValue*" gs:is-pointer="1">
              <type name="FlagsValue" c:type="const GFlagsValue" />
            </array>
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="to_string" c:identifier="g_flags_to_string" version="2.54" gs:dll-name="gobject-2.0" gs:managed-name="ToString">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2351">Pretty-prints @value in the form of the flag names separated by ` | ` and
sorted. Any extra bits will be shown at the end as a hexadecimal number.

This is intended to be used for debugging purposes. The format of the output
may change in the future.</doc>
        <source-position filename="genums.h" line="240" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="2362">a newly-allocated text string</doc>
          <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="flags_type" transfer-ownership="none" gs:managed-name="flagsType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2353">the type identifier of a #GFlagsClass type</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2354">the value</doc>
            <type name="guint" c:type="guint" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="flags_type" transfer-ownership="none" gs:managed-name="flagsType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2353">the type identifier of a #GFlagsClass type</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2354">the value</doc>
            <type name="guint" c:type="guint" />
          </parameter>
        </gs:managed-parameters>
      </function>
    </gs:static-class>
    <gs:static-class name="ObjectInterface" gs:managed-name="ObjectInterface">
      <method name="find_property" c:identifier="g_object_interface_find_property" version="2.4" gs:dll-name="gobject-2.0" gs:managed-name="FindProperty" gs:extension-method="1">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2951">Find the #GParamSpec with the given name for an
interface. Generally, the interface vtable passed in as @g_iface
will be the default vtable from g_type_default_interface_ref(), or,
if you know the interface has already been loaded,
g_type_default_interface_peek().</doc>
        <source-position filename="gobject.h" line="410" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="2964">the #GParamSpec for the property of the
         interface with the name @property_name, or %NULL if no
         such property exists.</doc>
          <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="g_iface" transfer-ownership="none" gs:managed-name="gIface" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2953">any interface vtable for the
 interface, or the default vtable for the interface</doc>
            <type name="TypeInterface" c:type="gpointer" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="property_name" transfer-ownership="none" gs:managed-name="propertyName" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2955">name of a property to look up.</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="g_iface" transfer-ownership="none" gs:managed-name="gIface" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2953">any interface vtable for the
 interface, or the default vtable for the interface</doc>
            <type name="TypeInterface" c:type="gpointer" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="property_name" transfer-ownership="none" gs:managed-name="propertyName" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2955">name of a property to look up.</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="install_property" c:identifier="g_object_interface_install_property" version="2.4" gs:dll-name="gobject-2.0" gs:managed-name="InstallProperty" gs:extension-method="1">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2970">Add a property to an interface; this is only useful for interfaces
that are added to GObject-derived types. Adding a property to an
interface forces all objects classes with that interface to have a
compatible property. The compatible property could be a newly
created #GParamSpec, but normally
g_object_class_override_property() will be used so that the object
class only needs to provide an implementation and inherits the
property description, default value, bounds, and so forth from the
interface property.

This function is meant to be called from the interface's default
vtable initialization function (the @class_init member of
#GTypeInfo.) It must not be called after after @class_init has
been called for any object types implementing this interface.

If @pspec is a floating reference, it will be consumed.</doc>
        <source-position filename="gobject.h" line="407" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="g_iface" transfer-ownership="none" gs:managed-name="gIface" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2972">any interface vtable for the
   interface, or the default
 vtable for the interface.</doc>
            <type name="TypeInterface" c:type="gpointer" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2975">the #GParamSpec for the new property</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="g_iface" transfer-ownership="none" gs:managed-name="gIface" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2972">any interface vtable for the
   interface, or the default
 vtable for the interface.</doc>
            <type name="TypeInterface" c:type="gpointer" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2975">the #GParamSpec for the new property</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="list_properties" c:identifier="g_object_interface_list_properties" version="2.4" gs:dll-name="gobject-2.0" gs:managed-name="ListProperties" gs:extension-method="1">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2998">Lists the properties of an interface.Generally, the interface
vtable passed in as @g_iface will be the default vtable from
g_type_default_interface_ref(), or, if you know the interface has
already been loaded, g_type_default_interface_peek().</doc>
        <source-position filename="gobject.h" line="413" />
        <return-value transfer-ownership="container" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3010">a
         pointer to an array of pointers to #GParamSpec
         structures. The paramspecs are owned by GLib, but the
         array should be freed with g_free() when you are done with
         it.</doc>
          <array length="0" zero-terminated="0" c:type="GParamSpec**" gs:is-pointer="1">
            <type name="ParamSpec" c:type="GParamSpec*" gs:is-pointer="1" />
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="g_iface" transfer-ownership="none" gs:managed-name="gIface" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3000">any interface vtable for the
 interface, or the default vtable for the interface</doc>
            <type name="TypeInterface" c:type="gpointer" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="n_properties_p" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="nPropertiesP">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3002">location to store number of properties returned.</doc>
            <type name="guint" c:type="guint*" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="g_iface" transfer-ownership="none" gs:managed-name="gIface" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3000">any interface vtable for the
 interface, or the default vtable for the interface</doc>
            <type name="TypeInterface" c:type="gpointer" gs:is-pointer="1" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
    </gs:static-class>
    <gs:static-class name="Enum" gs:managed-name="Enum">
      <function name="complete_type_info" c:identifier="g_enum_complete_type_info" gs:dll-name="gobject-2.0" gs:managed-name="CompleteTypeInfo">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2182">This function is meant to be called from the `complete_type_info`
function of a #GTypePlugin implementation, as in the following
example:

|[&lt;!-- language="C" --&gt;
static void
my_enum_complete_type_info (GTypePlugin     *plugin,
                            GType            g_type,
                            GTypeInfo       *info,
                            GTypeValueTable *value_table)
{
  static const GEnumValue values[] = {
    { MY_ENUM_FOO, "MY_ENUM_FOO", "foo" },
    { MY_ENUM_BAR, "MY_ENUM_BAR", "bar" },
    { 0, NULL, NULL }
  };

  g_enum_complete_type_info (type, info, values);
}
]|</doc>
        <source-position filename="genums.h" line="269" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <parameter name="g_enum_type" transfer-ownership="none" gs:managed-name="gEnumType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2184">the type identifier of the type being completed</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="info" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="info">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2185">the #GTypeInfo struct to be filled in</doc>
            <type name="TypeInfo" c:type="GTypeInfo*" />
          </parameter>
          <parameter name="const_values" transfer-ownership="none" gs:managed-name="constValues" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2186">An array of #GEnumValue structs for the possible
 enumeration values. The array is terminated by a struct with all
 members being 0.</doc>
            <array zero-terminated="1" c:type="const GEnumValue*" gs:is-pointer="1">
              <type name="EnumValue" c:type="const GEnumValue" />
            </array>
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="g_enum_type" transfer-ownership="none" gs:managed-name="gEnumType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2184">the type identifier of the type being completed</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="info" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="info">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2185">the #GTypeInfo struct to be filled in</doc>
            <type name="TypeInfo" c:type="GTypeInfo*" />
          </parameter>
          <parameter name="const_values" transfer-ownership="none" gs:managed-name="constValues" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2186">An array of #GEnumValue structs for the possible
 enumeration values. The array is terminated by a struct with all
 members being 0.</doc>
            <array zero-terminated="1" c:type="const GEnumValue*" gs:is-pointer="1">
              <type name="EnumValue" c:type="const GEnumValue" />
            </array>
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="get_value" c:identifier="g_enum_get_value" gs:dll-name="gobject-2.0" gs:managed-name="GetValue">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2213">Returns the #GEnumValue for a value.</doc>
        <source-position filename="genums.h" line="219" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="2220">the #GEnumValue for @value, or %NULL
         if @value is not a member of the enumeration</doc>
          <type name="EnumValue" c:type="GEnumValue*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="enum_class" transfer-ownership="none" gs:managed-name="enumClass" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2215">a #GEnumClass</doc>
            <type name="EnumClass" c:type="GEnumClass*" gs:is-pointer="1" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2216">the value to look up</doc>
            <type name="gint" c:type="gint" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="enum_class" transfer-ownership="none" gs:managed-name="enumClass" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2215">a #GEnumClass</doc>
            <type name="EnumClass" c:type="GEnumClass*" gs:is-pointer="1" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2216">the value to look up</doc>
            <type name="gint" c:type="gint" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="get_value_by_name" c:identifier="g_enum_get_value_by_name" gs:dll-name="gobject-2.0" gs:managed-name="GetValueByName">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2225">Looks up a #GEnumValue by name.</doc>
        <source-position filename="genums.h" line="222" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="2232">the #GEnumValue with name @name,
         or %NULL if the enumeration doesn't have a member
         with that name</doc>
          <type name="EnumValue" c:type="GEnumValue*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="enum_class" transfer-ownership="none" gs:managed-name="enumClass" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2227">a #GEnumClass</doc>
            <type name="EnumClass" c:type="GEnumClass*" gs:is-pointer="1" />
          </parameter>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2228">the name to look up</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="enum_class" transfer-ownership="none" gs:managed-name="enumClass" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2227">a #GEnumClass</doc>
            <type name="EnumClass" c:type="GEnumClass*" gs:is-pointer="1" />
          </parameter>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2228">the name to look up</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="get_value_by_nick" c:identifier="g_enum_get_value_by_nick" gs:dll-name="gobject-2.0" gs:managed-name="GetValueByNick">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2238">Looks up a #GEnumValue by nickname.</doc>
        <source-position filename="genums.h" line="225" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="2245">the #GEnumValue with nickname @nick,
         or %NULL if the enumeration doesn't have a member
         with that nickname</doc>
          <type name="EnumValue" c:type="GEnumValue*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="enum_class" transfer-ownership="none" gs:managed-name="enumClass" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2240">a #GEnumClass</doc>
            <type name="EnumClass" c:type="GEnumClass*" gs:is-pointer="1" />
          </parameter>
          <parameter name="nick" transfer-ownership="none" gs:managed-name="nick" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2241">the nickname to look up</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="enum_class" transfer-ownership="none" gs:managed-name="enumClass" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2240">a #GEnumClass</doc>
            <type name="EnumClass" c:type="GEnumClass*" gs:is-pointer="1" />
          </parameter>
          <parameter name="nick" transfer-ownership="none" gs:managed-name="nick" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2241">the nickname to look up</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="register_static" c:identifier="g_enum_register_static" gs:dll-name="gobject-2.0" gs:managed-name="RegisterStatic">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2251">Registers a new static enumeration type with the name @name.

It is normally more convenient to let [glib-mkenums][glib-mkenums],
generate a my_enum_get_type() function from a usual C enumeration
definition  than to write one yourself using g_enum_register_static().</doc>
        <source-position filename="genums.h" line="260" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="2265">The new type identifier.</doc>
          <type name="GType" c:type="GType" />
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2253">A nul-terminated string used as the name of the new type.</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="const_static_values" transfer-ownership="none" gs:managed-name="constStaticValues" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2254">An array of #GEnumValue structs for the possible
 enumeration values. The array is terminated by a struct with all
 members being 0. GObject keeps a reference to the data, so it cannot
 be stack-allocated.</doc>
            <array zero-terminated="1" c:type="const GEnumValue*" gs:is-pointer="1">
              <type name="EnumValue" c:type="const GEnumValue" />
            </array>
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2253">A nul-terminated string used as the name of the new type.</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="const_static_values" transfer-ownership="none" gs:managed-name="constStaticValues" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2254">An array of #GEnumValue structs for the possible
 enumeration values. The array is terminated by a struct with all
 members being 0. GObject keeps a reference to the data, so it cannot
 be stack-allocated.</doc>
            <array zero-terminated="1" c:type="const GEnumValue*" gs:is-pointer="1">
              <type name="EnumValue" c:type="const GEnumValue" />
            </array>
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="to_string" c:identifier="g_enum_to_string" version="2.54" gs:dll-name="gobject-2.0" gs:managed-name="ToString">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2269">Pretty-prints @value in the form of the enum’s name.

This is intended to be used for debugging purposes. The format of the output
may change in the future.</doc>
        <source-position filename="genums.h" line="237" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="2279">a newly-allocated text string</doc>
          <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="g_enum_type" transfer-ownership="none" gs:managed-name="gEnumType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2271">the type identifier of a #GEnumClass type</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2272">the value</doc>
            <type name="gint" c:type="gint" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="g_enum_type" transfer-ownership="none" gs:managed-name="gEnumType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2271">the type identifier of a #GEnumClass type</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2272">the value</doc>
            <type name="gint" c:type="gint" />
          </parameter>
        </gs:managed-parameters>
      </function>
    </gs:static-class>
    <gs:static-class name="Signal" gs:managed-name="Signal">
      <function name="accumulator_first_wins" c:identifier="g_signal_accumulator_first_wins" version="2.28" gs:pinvoke-only="1" gs:dll-name="gobject-2.0" gs:managed-name="AccumulatorFirstWins">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="4377">A predefined #GSignalAccumulator for signals intended to be used as a
hook for application code to provide a particular value.  Usually
only one such value is desired and multiple handlers for the same
signal don't make much sense (except for the case of the default
handler defined in the class structure, in which case you will
usually want the signal connection to override the class handler).

This accumulator will use the return value from the first signal
handler that is run as the return value for the signal and not run
any further handlers (ie: the first handler "wins").</doc>
        <source-position filename="gsignal.h" line="613" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="4395">standard #GSignalAccumulator result</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <parameter name="ihint" transfer-ownership="none" gs:managed-name="ihint" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4379">standard #GSignalAccumulator parameter</doc>
            <type name="SignalInvocationHint" c:type="GSignalInvocationHint*" gs:is-pointer="1" />
          </parameter>
          <parameter name="return_accu" transfer-ownership="none" gs:managed-name="returnAccu" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4380">standard #GSignalAccumulator parameter</doc>
            <type name="Value" c:type="GValue*" gs:is-pointer="1" />
          </parameter>
          <parameter name="handler_return" transfer-ownership="none" gs:managed-name="handlerReturn" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4381">standard #GSignalAccumulator parameter</doc>
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </parameter>
          <parameter name="dummy" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="dummy" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4382">standard #GSignalAccumulator parameter</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="ihint" transfer-ownership="none" gs:managed-name="ihint" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4379">standard #GSignalAccumulator parameter</doc>
            <type name="SignalInvocationHint" c:type="GSignalInvocationHint*" gs:is-pointer="1" />
          </parameter>
          <parameter name="return_accu" transfer-ownership="none" gs:managed-name="returnAccu" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4380">standard #GSignalAccumulator parameter</doc>
            <type name="Value" c:type="GValue*" gs:is-pointer="1" />
          </parameter>
          <parameter name="handler_return" transfer-ownership="none" gs:managed-name="handlerReturn" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4381">standard #GSignalAccumulator parameter</doc>
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </parameter>
          <parameter name="dummy" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="dummy" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4382">standard #GSignalAccumulator parameter</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="accumulator_true_handled" c:identifier="g_signal_accumulator_true_handled" version="2.4" gs:pinvoke-only="1" gs:dll-name="gobject-2.0" gs:managed-name="AccumulatorTrueHandled">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="4400">A predefined #GSignalAccumulator for signals that return a
boolean values. The behavior that this accumulator gives is
that a return of %TRUE stops the signal emission: no further
callbacks will be invoked, while a return of %FALSE allows
the emission to continue. The idea here is that a %TRUE return
indicates that the callback handled the signal, and no further
handling is needed.</doc>
        <source-position filename="gsignal.h" line="607" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="4416">standard #GSignalAccumulator result</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <parameter name="ihint" transfer-ownership="none" gs:managed-name="ihint" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4402">standard #GSignalAccumulator parameter</doc>
            <type name="SignalInvocationHint" c:type="GSignalInvocationHint*" gs:is-pointer="1" />
          </parameter>
          <parameter name="return_accu" transfer-ownership="none" gs:managed-name="returnAccu" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4403">standard #GSignalAccumulator parameter</doc>
            <type name="Value" c:type="GValue*" gs:is-pointer="1" />
          </parameter>
          <parameter name="handler_return" transfer-ownership="none" gs:managed-name="handlerReturn" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4404">standard #GSignalAccumulator parameter</doc>
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </parameter>
          <parameter name="dummy" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="dummy" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4405">standard #GSignalAccumulator parameter</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="ihint" transfer-ownership="none" gs:managed-name="ihint" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4402">standard #GSignalAccumulator parameter</doc>
            <type name="SignalInvocationHint" c:type="GSignalInvocationHint*" gs:is-pointer="1" />
          </parameter>
          <parameter name="return_accu" transfer-ownership="none" gs:managed-name="returnAccu" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4403">standard #GSignalAccumulator parameter</doc>
            <type name="Value" c:type="GValue*" gs:is-pointer="1" />
          </parameter>
          <parameter name="handler_return" transfer-ownership="none" gs:managed-name="handlerReturn" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4404">standard #GSignalAccumulator parameter</doc>
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </parameter>
          <parameter name="dummy" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="dummy" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4405">standard #GSignalAccumulator parameter</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="add_emission_hook" c:identifier="g_signal_add_emission_hook" gs:dll-name="gobject-2.0" gs:managed-name="AddEmissionHook">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="4420">Adds an emission hook for a signal, which will get called for any emission
of that signal, independent of the instance. This is possible only
for signals which don't have #G_SIGNAL_NO_HOOKS flag set.</doc>
        <source-position filename="gsignal.h" line="362" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="4432">the hook id, for later use with g_signal_remove_emission_hook().</doc>
          <type name="gulong" c:type="gulong" />
        </return-value>
        <parameters>
          <parameter name="signal_id" transfer-ownership="none" gs:managed-name="signalId" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4422">the signal identifier, as returned by g_signal_lookup().</doc>
            <type name="guint" c:type="guint" />
          </parameter>
          <parameter name="detail" transfer-ownership="none" gs:managed-name="detail" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4423">the detail on which to call the hook.</doc>
            <type name="GLib.Quark" c:type="GQuark" />
          </parameter>
          <parameter name="hook_func" transfer-ownership="none" scope="notified" closure="3" destroy="4" gs:managed-name="hookFunc" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4424">a #GSignalEmissionHook function.</doc>
            <type name="SignalEmissionHook" c:type="GSignalEmissionHook" />
          </parameter>
          <parameter name="hook_data" transfer-ownership="none" nullable="1" allow-none="1" scope="notified" gs:managed-name="hookData" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4425">user data for @hook_func.</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="data_destroy" transfer-ownership="none" nullable="1" allow-none="1" scope="async" destroy="3" gs:managed-name="dataDestroy" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4426">a #GDestroyNotify for @hook_data.</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="signal_id" transfer-ownership="none" gs:managed-name="signalId" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4422">the signal identifier, as returned by g_signal_lookup().</doc>
            <type name="guint" c:type="guint" />
          </parameter>
          <parameter name="detail" transfer-ownership="none" gs:managed-name="detail" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4423">the detail on which to call the hook.</doc>
            <type name="GLib.Quark" c:type="GQuark" />
          </parameter>
          <parameter name="hook_func" transfer-ownership="none" scope="notified" closure="3" destroy="4" gs:managed-name="hookFunc" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4424">a #GSignalEmissionHook function.</doc>
            <type name="SignalEmissionHook" c:type="GSignalEmissionHook" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="chain_from_overridden" c:identifier="g_signal_chain_from_overridden" gs:dll-name="gobject-2.0" gs:managed-name="ChainFromOverridden">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="4436">Calls the original class closure of a signal. This function should only
be called from an overridden class closure; see
g_signal_override_class_closure() and
g_signal_override_class_handler().</doc>
        <source-position filename="gsignal.h" line="468" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <parameter name="instance_and_params" transfer-ownership="none" gs:managed-name="instanceAndParams" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4438">the argument list of the signal emission.
 The first element in the array is a #GValue for the instance the signal
 is being emitted on. The rest are any arguments to be passed to the signal.</doc>
            <array zero-terminated="1" c:type="const GValue*" gs:is-pointer="1">
              <type name="Value" c:type="GValue" />
            </array>
          </parameter>
          <parameter name="return_value" transfer-ownership="none" gs:managed-name="returnValue" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4441">Location for the return value.</doc>
            <type name="Value" c:type="GValue*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="instance_and_params" transfer-ownership="none" gs:managed-name="instanceAndParams" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4438">the argument list of the signal emission.
 The first element in the array is a #GValue for the instance the signal
 is being emitted on. The rest are any arguments to be passed to the signal.</doc>
            <array zero-terminated="1" c:type="const GValue*" gs:is-pointer="1">
              <type name="Value" c:type="GValue" />
            </array>
          </parameter>
          <parameter name="return_value" transfer-ownership="none" gs:managed-name="returnValue" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4441">Location for the return value.</doc>
            <type name="Value" c:type="GValue*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="connect_closure" c:identifier="g_signal_connect_closure" shadows="connect" gs:dll-name="gobject-2.0" gs:managed-name="Connect">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="4467">Connects a closure to a signal for a particular object.</doc>
        <source-position filename="gsignal.h" line="385" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="4477">the handler ID (always greater than 0 for successful connections)</doc>
          <type name="gulong" c:type="gulong" />
        </return-value>
        <parameters>
          <parameter name="instance" transfer-ownership="none" gs:managed-name="instance" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4469">the instance to connect to.</doc>
            <type name="Object" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="detailed_signal" transfer-ownership="none" gs:managed-name="detailedSignal" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4470">a string of the form "signal-name::detail".</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="closure" transfer-ownership="none" gs:managed-name="closure" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4471">the closure to connect.</doc>
            <type name="Closure" c:type="GClosure*" gs:is-pointer="1" />
          </parameter>
          <parameter name="after" transfer-ownership="none" gs:default="false" gs:managed-name="after" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4472">whether the handler should be called before or after the
 default handler of the signal.</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="instance" transfer-ownership="none" gs:managed-name="instance" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4469">the instance to connect to.</doc>
            <type name="Object" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="detailed_signal" transfer-ownership="none" gs:managed-name="detailedSignal" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4470">a string of the form "signal-name::detail".</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="closure" transfer-ownership="none" gs:managed-name="closure" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4471">the closure to connect.</doc>
            <type name="Closure" c:type="GClosure*" gs:is-pointer="1" />
          </parameter>
          <parameter name="after" transfer-ownership="none" gs:default="false" gs:managed-name="after" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4472">whether the handler should be called before or after the
 default handler of the signal.</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="connect_closure_by_id" c:identifier="g_signal_connect_closure_by_id" shadows="connect" gs:dll-name="gobject-2.0" gs:managed-name="Connect">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="4481">Connects a closure to a signal for a particular object.</doc>
        <source-position filename="gsignal.h" line="379" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="4492">the handler ID (always greater than 0 for successful connections)</doc>
          <type name="gulong" c:type="gulong" />
        </return-value>
        <parameters>
          <parameter name="instance" transfer-ownership="none" gs:managed-name="instance" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4483">the instance to connect to.</doc>
            <type name="Object" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="signal_id" transfer-ownership="none" gs:managed-name="signalId" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4484">the id of the signal.</doc>
            <type name="guint" c:type="guint" />
          </parameter>
          <parameter name="detail" transfer-ownership="none" gs:managed-name="detail" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4485">the detail.</doc>
            <type name="GLib.Quark" c:type="GQuark" />
          </parameter>
          <parameter name="closure" transfer-ownership="none" gs:managed-name="closure" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4486">the closure to connect.</doc>
            <type name="Closure" c:type="GClosure*" gs:is-pointer="1" />
          </parameter>
          <parameter name="after" transfer-ownership="none" gs:default="false" gs:managed-name="after" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4487">whether the handler should be called before or after the
 default handler of the signal.</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="instance" transfer-ownership="none" gs:managed-name="instance" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4483">the instance to connect to.</doc>
            <type name="Object" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="signal_id" transfer-ownership="none" gs:managed-name="signalId" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4484">the id of the signal.</doc>
            <type name="guint" c:type="guint" />
          </parameter>
          <parameter name="detail" transfer-ownership="none" gs:managed-name="detail" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4485">the detail.</doc>
            <type name="GLib.Quark" c:type="GQuark" />
          </parameter>
          <parameter name="closure" transfer-ownership="none" gs:managed-name="closure" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4486">the closure to connect.</doc>
            <type name="Closure" c:type="GClosure*" gs:is-pointer="1" />
          </parameter>
          <parameter name="after" transfer-ownership="none" gs:default="false" gs:managed-name="after" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4487">whether the handler should be called before or after the
 default handler of the signal.</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="connect_data" c:identifier="g_signal_connect_data" introspectable="1" gs:pinvoke-only="1" shadows="connect" gs:dll-name="gobject-2.0" gs:managed-name="Connect">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="4496">Connects a #GCallback function to a signal for a particular object. Similar
to g_signal_connect(), but allows to provide a #GClosureNotify for the data
which will be called when the signal handler is disconnected and no longer
used. Specify @connect_flags if you need `..._after()` or
`..._swapped()` variants of this function.</doc>
        <source-position filename="gsignal.h" line="390" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="4511">the handler ID (always greater than 0 for successful connections)</doc>
          <type name="gulong" c:type="gulong" />
        </return-value>
        <parameters>
          <parameter name="instance" transfer-ownership="none" gs:managed-name="instance" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4498">the instance to connect to.</doc>
            <type name="Object" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="detailed_signal" transfer-ownership="none" gs:managed-name="detailedSignal" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4499">a string of the form "signal-name::detail".</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="c_handler" transfer-ownership="none" closure="3" gs:managed-name="cHandler" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4500">the #GCallback to connect.</doc>
            <type name="Callback" c:type="GCallback" />
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" scope="notified" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4501">data to pass to @c_handler calls.</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="destroy_data" transfer-ownership="none" nullable="1" allow-none="1" scope="notified" destroy="3" gs:managed-name="destroyData" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4502">a #GClosureNotify for @data.</doc>
            <type name="ClosureNotify" c:type="GClosureNotify" />
          </parameter>
          <parameter name="connect_flags" transfer-ownership="none" gs:managed-name="connectFlags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4503">a combination of #GConnectFlags.</doc>
            <type name="ConnectFlags" c:type="GConnectFlags" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="instance" transfer-ownership="none" gs:managed-name="instance" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4498">the instance to connect to.</doc>
            <type name="Object" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="detailed_signal" transfer-ownership="none" gs:managed-name="detailedSignal" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4499">a string of the form "signal-name::detail".</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="c_handler" transfer-ownership="none" closure="3" gs:managed-name="cHandler" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4500">the #GCallback to connect.</doc>
            <type name="Callback" c:type="GCallback" />
          </parameter>
          <parameter name="destroy_data" transfer-ownership="none" nullable="1" allow-none="1" scope="notified" destroy="3" gs:managed-name="destroyData" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4502">a #GClosureNotify for @data.</doc>
            <type name="ClosureNotify" c:type="GClosureNotify" />
          </parameter>
          <parameter name="connect_flags" transfer-ownership="none" gs:managed-name="connectFlags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4503">a combination of #GConnectFlags.</doc>
            <type name="ConnectFlags" c:type="GConnectFlags" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="emitv" c:identifier="g_signal_emitv" gs:dll-name="gobject-2.0" gs:managed-name="Emitv">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="4585">Emits a signal.

Note that g_signal_emitv() doesn't change @return_value if no handlers are
connected, in contrast to g_signal_emit() and g_signal_emit_valist().</doc>
        <source-position filename="gsignal.h" line="312" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <parameter name="instance_and_params" transfer-ownership="none" gs:managed-name="instanceAndParams" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4587">argument list for the signal emission.
 The first element in the array is a #GValue for the instance the signal
 is being emitted on. The rest are any arguments to be passed to the signal.</doc>
            <array zero-terminated="1" c:type="const GValue*" gs:is-pointer="1">
              <type name="Value" c:type="GValue" />
            </array>
          </parameter>
          <parameter name="signal_id" transfer-ownership="none" gs:managed-name="signalId" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4590">the signal id</doc>
            <type name="guint" c:type="guint" />
          </parameter>
          <parameter name="detail" transfer-ownership="none" gs:managed-name="detail" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4591">the detail</doc>
            <type name="GLib.Quark" c:type="GQuark" />
          </parameter>
          <parameter name="return_value" direction="inout" caller-allocates="0" transfer-ownership="full" optional="1" gs:managed-name="returnValue">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4592">Location to
store the return value of the signal emission. This must be provided if the
specified signal returns a value, but may be ignored otherwise.</doc>
            <type name="Value" c:type="GValue*" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="instance_and_params" transfer-ownership="none" gs:managed-name="instanceAndParams" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4587">argument list for the signal emission.
 The first element in the array is a #GValue for the instance the signal
 is being emitted on. The rest are any arguments to be passed to the signal.</doc>
            <array zero-terminated="1" c:type="const GValue*" gs:is-pointer="1">
              <type name="Value" c:type="GValue" />
            </array>
          </parameter>
          <parameter name="signal_id" transfer-ownership="none" gs:managed-name="signalId" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4590">the signal id</doc>
            <type name="guint" c:type="guint" />
          </parameter>
          <parameter name="detail" transfer-ownership="none" gs:managed-name="detail" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4591">the detail</doc>
            <type name="GLib.Quark" c:type="GQuark" />
          </parameter>
          <parameter name="return_value" direction="inout" caller-allocates="0" transfer-ownership="full" optional="1" gs:managed-name="returnValue">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4592">Location to
store the return value of the signal emission. This must be provided if the
specified signal returns a value, but may be ignored otherwise.</doc>
            <type name="Value" c:type="GValue*" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="get_invocation_hint" c:identifier="g_signal_get_invocation_hint" gs:dll-name="gobject-2.0" gs:managed-name="GetInvocationHint">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="4603">Returns the invocation hint of the innermost signal emission of instance.</doc>
        <source-position filename="gsignal.h" line="350" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="4609">the invocation hint of the innermost
    signal emission, or %NULL if not found.</doc>
          <type name="SignalInvocationHint" c:type="GSignalInvocationHint*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="instance" transfer-ownership="none" gs:managed-name="instance" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4605">the instance to query</doc>
            <type name="Object" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="instance" transfer-ownership="none" gs:managed-name="instance" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4605">the instance to query</doc>
            <type name="Object" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="handler_block" c:identifier="g_signal_handler_block" gs:dll-name="gobject-2.0" gs:managed-name="HandlerBlock">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="4614">Blocks a handler of an instance so it will not be called during any
signal emissions unless it is unblocked again. Thus "blocking" a
signal handler means to temporarily deactivate it, a signal handler
has to be unblocked exactly the same amount of times it has been
blocked before to become active again.

The @handler_id has to be a valid signal handler id, connected to a
signal of @instance.</doc>
        <source-position filename="gsignal.h" line="397" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <parameter name="instance" transfer-ownership="none" gs:managed-name="instance" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4616">The instance to block the signal handler of.</doc>
            <type name="Object" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="handler_id" transfer-ownership="none" gs:managed-name="handlerId" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4617">Handler id of the handler to be blocked.</doc>
            <type name="gulong" c:type="gulong" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="instance" transfer-ownership="none" gs:managed-name="instance" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4616">The instance to block the signal handler of.</doc>
            <type name="Object" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="handler_id" transfer-ownership="none" gs:managed-name="handlerId" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4617">Handler id of the handler to be blocked.</doc>
            <type name="gulong" c:type="gulong" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="handler_disconnect" c:identifier="g_signal_handler_disconnect" gs:dll-name="gobject-2.0" gs:managed-name="HandlerDisconnect">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="4630">Disconnects a handler from an instance so it will not be called during
any future or currently ongoing emissions of the signal it has been
connected to. The @handler_id becomes invalid and may be reused.

The @handler_id has to be a valid signal handler id, connected to a
signal of @instance.</doc>
        <source-position filename="gsignal.h" line="403" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <parameter name="instance" transfer-ownership="none" gs:managed-name="instance" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4632">The instance to remove the signal handler from.</doc>
            <type name="Object" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="handler_id" transfer-ownership="none" gs:managed-name="handlerId" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4633">Handler id of the handler to be disconnected.</doc>
            <type name="gulong" c:type="gulong" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="instance" transfer-ownership="none" gs:managed-name="instance" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4632">The instance to remove the signal handler from.</doc>
            <type name="Object" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="handler_id" transfer-ownership="none" gs:managed-name="handlerId" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4633">Handler id of the handler to be disconnected.</doc>
            <type name="gulong" c:type="gulong" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="handler_find" c:identifier="g_signal_handler_find" gs:pinvoke-only="1" gs:dll-name="gobject-2.0" gs:managed-name="HandlerFind">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="4644">Finds the first signal handler that matches certain selection criteria.
The criteria mask is passed as an OR-ed combination of #GSignalMatchType
flags, and the criteria values are passed as arguments.
The match @mask has to be non-0 for successful matches.
If no handler was found, 0 is returned.</doc>
        <source-position filename="gsignal.h" line="409" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="4661">A valid non-0 signal handler id for a successful match.</doc>
          <type name="gulong" c:type="gulong" />
        </return-value>
        <parameters>
          <parameter name="instance" transfer-ownership="none" gs:managed-name="instance" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4646">The instance owning the signal handler to be found.</doc>
            <type name="Object" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="mask" transfer-ownership="none" gs:managed-name="mask" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4647">Mask indicating which of @signal_id, @detail, @closure, @func
 and/or @data the handler has to match.</doc>
            <type name="SignalMatchType" c:type="GSignalMatchType" />
          </parameter>
          <parameter name="signal_id" transfer-ownership="none" gs:managed-name="signalId" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4649">Signal the handler has to be connected to.</doc>
            <type name="guint" c:type="guint" />
          </parameter>
          <parameter name="detail" transfer-ownership="none" gs:managed-name="detail" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4650">Signal detail the handler has to be connected to.</doc>
            <type name="GLib.Quark" c:type="GQuark" />
          </parameter>
          <parameter name="closure" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="closure" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4651">The closure the handler will invoke.</doc>
            <type name="Closure" c:type="GClosure*" gs:is-pointer="1" />
          </parameter>
          <parameter name="func" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="func" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4652">The C closure callback of the handler (useless for non-C closures).</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4653">The closure data of the handler's closure.</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="instance" transfer-ownership="none" gs:managed-name="instance" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4646">The instance owning the signal handler to be found.</doc>
            <type name="Object" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="mask" transfer-ownership="none" gs:managed-name="mask" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4647">Mask indicating which of @signal_id, @detail, @closure, @func
 and/or @data the handler has to match.</doc>
            <type name="SignalMatchType" c:type="GSignalMatchType" />
          </parameter>
          <parameter name="signal_id" transfer-ownership="none" gs:managed-name="signalId" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4649">Signal the handler has to be connected to.</doc>
            <type name="guint" c:type="guint" />
          </parameter>
          <parameter name="detail" transfer-ownership="none" gs:managed-name="detail" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4650">Signal detail the handler has to be connected to.</doc>
            <type name="GLib.Quark" c:type="GQuark" />
          </parameter>
          <parameter name="closure" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="closure" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4651">The closure the handler will invoke.</doc>
            <type name="Closure" c:type="GClosure*" gs:is-pointer="1" />
          </parameter>
          <parameter name="func" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="func" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4652">The C closure callback of the handler (useless for non-C closures).</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4653">The closure data of the handler's closure.</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="handler_is_connected" c:identifier="g_signal_handler_is_connected" gs:dll-name="gobject-2.0" gs:managed-name="HandlerIsConnected">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="4665">Returns whether @handler_id is the ID of a handler connected to @instance.</doc>
        <source-position filename="gsignal.h" line="406" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="4672">whether @handler_id identifies a handler connected to @instance.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <parameter name="instance" transfer-ownership="none" gs:managed-name="instance" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4667">The instance where a signal handler is sought.</doc>
            <type name="Object" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="handler_id" transfer-ownership="none" gs:managed-name="handlerId" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4668">the handler ID.</doc>
            <type name="gulong" c:type="gulong" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="instance" transfer-ownership="none" gs:managed-name="instance" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4667">The instance where a signal handler is sought.</doc>
            <type name="Object" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="handler_id" transfer-ownership="none" gs:managed-name="handlerId" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4668">the handler ID.</doc>
            <type name="gulong" c:type="gulong" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="handler_unblock" c:identifier="g_signal_handler_unblock" gs:dll-name="gobject-2.0" gs:managed-name="HandlerUnblock">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="4676">Undoes the effect of a previous g_signal_handler_block() call.  A
blocked handler is skipped during signal emissions and will not be
invoked, unblocking it (for exactly the amount of times it has been
blocked before) reverts its "blocked" state, so the handler will be
recognized by the signal system and is called upon future or
currently ongoing signal emissions (since the order in which
handlers are called during signal emissions is deterministic,
whether the unblocked handler in question is called as part of a
currently ongoing emission depends on how far that emission has
proceeded yet).

The @handler_id has to be a valid id of a signal handler that is
connected to a signal of @instance and is currently blocked.</doc>
        <source-position filename="gsignal.h" line="400" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <parameter name="instance" transfer-ownership="none" gs:managed-name="instance" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4678">The instance to unblock the signal handler of.</doc>
            <type name="Object" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="handler_id" transfer-ownership="none" gs:managed-name="handlerId" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4679">Handler id of the handler to be unblocked.</doc>
            <type name="gulong" c:type="gulong" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="instance" transfer-ownership="none" gs:managed-name="instance" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4678">The instance to unblock the signal handler of.</doc>
            <type name="Object" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="handler_id" transfer-ownership="none" gs:managed-name="handlerId" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4679">Handler id of the handler to be unblocked.</doc>
            <type name="gulong" c:type="gulong" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="handlers_block_matched" c:identifier="g_signal_handlers_block_matched" gs:pinvoke-only="1" gs:dll-name="gobject-2.0" gs:managed-name="HandlersBlockMatched">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="4697">Blocks all handlers on an instance that match a certain selection criteria.
The criteria mask is passed as an OR-ed combination of #GSignalMatchType
flags, and the criteria values are passed as arguments.
Passing at least one of the %G_SIGNAL_MATCH_CLOSURE, %G_SIGNAL_MATCH_FUNC
or %G_SIGNAL_MATCH_DATA match flags is required for successful matches.
If no handlers were found, 0 is returned, the number of blocked handlers
otherwise.</doc>
        <source-position filename="gsignal.h" line="417" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="4716">The number of handlers that matched.</doc>
          <type name="guint" c:type="guint" />
        </return-value>
        <parameters>
          <parameter name="instance" transfer-ownership="none" gs:managed-name="instance" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4699">The instance to block handlers from.</doc>
            <type name="Object" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="mask" transfer-ownership="none" gs:managed-name="mask" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4700">Mask indicating which of @signal_id, @detail, @closure, @func
 and/or @data the handlers have to match.</doc>
            <type name="SignalMatchType" c:type="GSignalMatchType" />
          </parameter>
          <parameter name="signal_id" transfer-ownership="none" gs:managed-name="signalId" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4702">Signal the handlers have to be connected to.</doc>
            <type name="guint" c:type="guint" />
          </parameter>
          <parameter name="detail" transfer-ownership="none" gs:managed-name="detail" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4703">Signal detail the handlers have to be connected to.</doc>
            <type name="GLib.Quark" c:type="GQuark" />
          </parameter>
          <parameter name="closure" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="closure" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4704">The closure the handlers will invoke.</doc>
            <type name="Closure" c:type="GClosure*" gs:is-pointer="1" />
          </parameter>
          <parameter name="func" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="func" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4705">The C closure callback of the handlers (useless for non-C closures).</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4706">The closure data of the handlers' closures.</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="instance" transfer-ownership="none" gs:managed-name="instance" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4699">The instance to block handlers from.</doc>
            <type name="Object" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="mask" transfer-ownership="none" gs:managed-name="mask" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4700">Mask indicating which of @signal_id, @detail, @closure, @func
 and/or @data the handlers have to match.</doc>
            <type name="SignalMatchType" c:type="GSignalMatchType" />
          </parameter>
          <parameter name="signal_id" transfer-ownership="none" gs:managed-name="signalId" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4702">Signal the handlers have to be connected to.</doc>
            <type name="guint" c:type="guint" />
          </parameter>
          <parameter name="detail" transfer-ownership="none" gs:managed-name="detail" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4703">Signal detail the handlers have to be connected to.</doc>
            <type name="GLib.Quark" c:type="GQuark" />
          </parameter>
          <parameter name="closure" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="closure" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4704">The closure the handlers will invoke.</doc>
            <type name="Closure" c:type="GClosure*" gs:is-pointer="1" />
          </parameter>
          <parameter name="func" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="func" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4705">The C closure callback of the handlers (useless for non-C closures).</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4706">The closure data of the handlers' closures.</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="handlers_destroy" c:identifier="g_signal_handlers_destroy" gs:pinvoke-only="1" gs:dll-name="gobject-2.0" gs:managed-name="HandlersDestroy">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="4720">Destroy all signal handlers of a type instance. This function is
an implementation detail of the #GObject dispose implementation,
and should not be used outside of the type system.</doc>
        <source-position filename="gsignal.h" line="620" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <parameter name="instance" transfer-ownership="none" gs:managed-name="instance" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4722">The instance whose signal handlers are destroyed</doc>
            <type name="Object" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="instance" transfer-ownership="none" gs:managed-name="instance" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4722">The instance whose signal handlers are destroyed</doc>
            <type name="Object" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="handlers_disconnect_matched" c:identifier="g_signal_handlers_disconnect_matched" gs:pinvoke-only="1" gs:dll-name="gobject-2.0" gs:managed-name="HandlersDisconnectMatched">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="4730">Disconnects all handlers on an instance that match a certain
selection criteria. The criteria mask is passed as an OR-ed
combination of #GSignalMatchType flags, and the criteria values are
passed as arguments.  Passing at least one of the
%G_SIGNAL_MATCH_CLOSURE, %G_SIGNAL_MATCH_FUNC or
%G_SIGNAL_MATCH_DATA match flags is required for successful
matches.  If no handlers were found, 0 is returned, the number of
disconnected handlers otherwise.</doc>
        <source-position filename="gsignal.h" line="433" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="4750">The number of handlers that matched.</doc>
          <type name="guint" c:type="guint" />
        </return-value>
        <parameters>
          <parameter name="instance" transfer-ownership="none" gs:managed-name="instance" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4732">The instance to remove handlers from.</doc>
            <type name="Object" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="mask" transfer-ownership="none" gs:managed-name="mask" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4733">Mask indicating which of @signal_id, @detail, @closure, @func
 and/or @data the handlers have to match.</doc>
            <type name="SignalMatchType" c:type="GSignalMatchType" />
          </parameter>
          <parameter name="signal_id" transfer-ownership="none" gs:managed-name="signalId" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4735">Signal the handlers have to be connected to.</doc>
            <type name="guint" c:type="guint" />
          </parameter>
          <parameter name="detail" transfer-ownership="none" gs:managed-name="detail" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4736">Signal detail the handlers have to be connected to.</doc>
            <type name="GLib.Quark" c:type="GQuark" />
          </parameter>
          <parameter name="closure" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="closure" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4737">The closure the handlers will invoke.</doc>
            <type name="Closure" c:type="GClosure*" gs:is-pointer="1" />
          </parameter>
          <parameter name="func" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="func" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4738">The C closure callback of the handlers (useless for non-C closures).</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4739">The closure data of the handlers' closures.</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="instance" transfer-ownership="none" gs:managed-name="instance" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4732">The instance to remove handlers from.</doc>
            <type name="Object" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="mask" transfer-ownership="none" gs:managed-name="mask" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4733">Mask indicating which of @signal_id, @detail, @closure, @func
 and/or @data the handlers have to match.</doc>
            <type name="SignalMatchType" c:type="GSignalMatchType" />
          </parameter>
          <parameter name="signal_id" transfer-ownership="none" gs:managed-name="signalId" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4735">Signal the handlers have to be connected to.</doc>
            <type name="guint" c:type="guint" />
          </parameter>
          <parameter name="detail" transfer-ownership="none" gs:managed-name="detail" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4736">Signal detail the handlers have to be connected to.</doc>
            <type name="GLib.Quark" c:type="GQuark" />
          </parameter>
          <parameter name="closure" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="closure" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4737">The closure the handlers will invoke.</doc>
            <type name="Closure" c:type="GClosure*" gs:is-pointer="1" />
          </parameter>
          <parameter name="func" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="func" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4738">The C closure callback of the handlers (useless for non-C closures).</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4739">The closure data of the handlers' closures.</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="handlers_unblock_matched" c:identifier="g_signal_handlers_unblock_matched" gs:pinvoke-only="1" gs:dll-name="gobject-2.0" gs:managed-name="HandlersUnblockMatched">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="4754">Unblocks all handlers on an instance that match a certain selection
criteria. The criteria mask is passed as an OR-ed combination of
#GSignalMatchType flags, and the criteria values are passed as arguments.
Passing at least one of the %G_SIGNAL_MATCH_CLOSURE, %G_SIGNAL_MATCH_FUNC
or %G_SIGNAL_MATCH_DATA match flags is required for successful matches.
If no handlers were found, 0 is returned, the number of unblocked handlers
otherwise. The match criteria should not apply to any handlers that are
not currently blocked.</doc>
        <source-position filename="gsignal.h" line="425" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="4774">The number of handlers that matched.</doc>
          <type name="guint" c:type="guint" />
        </return-value>
        <parameters>
          <parameter name="instance" transfer-ownership="none" gs:managed-name="instance" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4756">The instance to unblock handlers from.</doc>
            <type name="Object" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="mask" transfer-ownership="none" gs:managed-name="mask" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4757">Mask indicating which of @signal_id, @detail, @closure, @func
 and/or @data the handlers have to match.</doc>
            <type name="SignalMatchType" c:type="GSignalMatchType" />
          </parameter>
          <parameter name="signal_id" transfer-ownership="none" gs:managed-name="signalId" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4759">Signal the handlers have to be connected to.</doc>
            <type name="guint" c:type="guint" />
          </parameter>
          <parameter name="detail" transfer-ownership="none" gs:managed-name="detail" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4760">Signal detail the handlers have to be connected to.</doc>
            <type name="GLib.Quark" c:type="GQuark" />
          </parameter>
          <parameter name="closure" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="closure" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4761">The closure the handlers will invoke.</doc>
            <type name="Closure" c:type="GClosure*" gs:is-pointer="1" />
          </parameter>
          <parameter name="func" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="func" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4762">The C closure callback of the handlers (useless for non-C closures).</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4763">The closure data of the handlers' closures.</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="instance" transfer-ownership="none" gs:managed-name="instance" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4756">The instance to unblock handlers from.</doc>
            <type name="Object" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="mask" transfer-ownership="none" gs:managed-name="mask" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4757">Mask indicating which of @signal_id, @detail, @closure, @func
 and/or @data the handlers have to match.</doc>
            <type name="SignalMatchType" c:type="GSignalMatchType" />
          </parameter>
          <parameter name="signal_id" transfer-ownership="none" gs:managed-name="signalId" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4759">Signal the handlers have to be connected to.</doc>
            <type name="guint" c:type="guint" />
          </parameter>
          <parameter name="detail" transfer-ownership="none" gs:managed-name="detail" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4760">Signal detail the handlers have to be connected to.</doc>
            <type name="GLib.Quark" c:type="GQuark" />
          </parameter>
          <parameter name="closure" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="closure" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4761">The closure the handlers will invoke.</doc>
            <type name="Closure" c:type="GClosure*" gs:is-pointer="1" />
          </parameter>
          <parameter name="func" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="func" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4762">The C closure callback of the handlers (useless for non-C closures).</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4763">The closure data of the handlers' closures.</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="has_handler_pending" c:identifier="g_signal_has_handler_pending" gs:dll-name="gobject-2.0" gs:managed-name="HasHandlerPending">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="4778">Returns whether there are any handlers connected to @instance for the
given signal id and detail.

If @detail is 0 then it will only match handlers that were connected
without detail.  If @detail is non-zero then it will match handlers
connected both without detail and with the given detail.  This is
consistent with how a signal emitted with @detail would be delivered
to those handlers.

Since 2.46 this also checks for a non-default class closure being
installed, as this is basically always what you want.

One example of when you might use this is when the arguments to the
signal are difficult to compute. A class implementor may opt to not
emit the signal if no one is attached anyway, thus saving the cost
of building the arguments.</doc>
        <source-position filename="gsignal.h" line="374" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="4802">%TRUE if a handler is connected to the signal, %FALSE
         otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <parameter name="instance" transfer-ownership="none" gs:managed-name="instance" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4780">the object whose signal handlers are sought.</doc>
            <type name="Object" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="signal_id" transfer-ownership="none" gs:managed-name="signalId" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4781">the signal id.</doc>
            <type name="guint" c:type="guint" />
          </parameter>
          <parameter name="detail" transfer-ownership="none" gs:default="default" gs:managed-name="detail" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4782">the detail.</doc>
            <type name="GLib.Quark" c:type="GQuark" />
          </parameter>
          <parameter name="may_be_blocked" transfer-ownership="none" gs:default="false" gs:managed-name="mayBeBlocked" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4783">whether blocked handlers should count as match.</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="instance" transfer-ownership="none" gs:managed-name="instance" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4780">the object whose signal handlers are sought.</doc>
            <type name="Object" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="signal_id" transfer-ownership="none" gs:managed-name="signalId" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4781">the signal id.</doc>
            <type name="guint" c:type="guint" />
          </parameter>
          <parameter name="detail" transfer-ownership="none" gs:default="default" gs:managed-name="detail" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4782">the detail.</doc>
            <type name="GLib.Quark" c:type="GQuark" />
          </parameter>
          <parameter name="may_be_blocked" transfer-ownership="none" gs:default="false" gs:managed-name="mayBeBlocked" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4783">whether blocked handlers should count as match.</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="is_valid_name" c:identifier="g_signal_is_valid_name" version="2.66" gs:dll-name="gobject-2.0" gs:managed-name="IsValidName">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="4807">Validate a signal name. This can be useful for dynamically-generated signals
which need to be validated at run-time before actually trying to create them.

See [canonical parameter names][canonical-parameter-names] for details of
the rules for valid names. The rules for signal names are the same as those
for property names.</doc>
        <source-position filename="gsignal.h" line="342" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="4818">%TRUE if @name is a valid signal name, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4809">the canonical name of the signal</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4809">the canonical name of the signal</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="list_ids" c:identifier="g_signal_list_ids" gs:dll-name="gobject-2.0" gs:managed-name="ListIds">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="4823">Lists the signals by id that a certain instance or interface type
created. Further information about the signals can be acquired through
g_signal_query().</doc>
        <source-position filename="gsignal.h" line="339" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="4832">Newly allocated array of signal IDs.</doc>
          <array length="1" zero-terminated="0" c:type="guint*" gs:is-pointer="1">
            <type name="guint" c:type="guint" />
          </array>
        </return-value>
        <parameters>
          <parameter name="itype" transfer-ownership="none" gs:managed-name="itype" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4825">Instance or interface type.</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="n_ids" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="nIds">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4826">Location to store the number of signal ids for @itype.</doc>
            <type name="guint" c:type="guint*" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="itype" transfer-ownership="none" gs:managed-name="itype" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4825">Instance or interface type.</doc>
            <type name="GType" c:type="GType" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="lookup" c:identifier="g_signal_lookup" gs:dll-name="gobject-2.0" gs:managed-name="Lookup">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="4836">Given the name of the signal and the type of object it connects to, gets
the signal's identifying integer. Emitting the signal by number is
somewhat faster than using the name each time.

Also tries the ancestors of the given type.

The type class passed as @itype must already have been instantiated (for
example, using g_type_class_ref()) for this function to work, as signals are
always installed during class initialization.

See g_signal_new() for details on allowed signal names.</doc>
        <source-position filename="gsignal.h" line="331" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="4853">the signal's identifying number, or 0 if no signal was found.</doc>
          <type name="guint" c:type="guint" />
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4838">the signal's name.</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="itype" transfer-ownership="none" gs:managed-name="itype" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4839">the type that the signal operates on.</doc>
            <type name="GType" c:type="GType" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4838">the signal's name.</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="itype" transfer-ownership="none" gs:managed-name="itype" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4839">the type that the signal operates on.</doc>
            <type name="GType" c:type="GType" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="name" c:identifier="g_signal_name" gs:dll-name="gobject-2.0" gs:managed-name="Name">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="4857">Given the signal's identifier, finds its name.

Two different signals may have the same name, if they have differing types.</doc>
        <source-position filename="gsignal.h" line="334" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="4865">the signal name, or %NULL if the signal number was invalid.</doc>
          <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="signal_id" transfer-ownership="none" gs:managed-name="signalId" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4859">the signal's identifying number.</doc>
            <type name="guint" c:type="guint" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="signal_id" transfer-ownership="none" gs:managed-name="signalId" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4859">the signal's identifying number.</doc>
            <type name="guint" c:type="guint" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="newv" c:identifier="g_signal_newv" introspectable="1" gs:pinvoke-only="1" gs:dll-name="gobject-2.0" gs:managed-name="Newv">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="4989">Creates a new signal. (This is usually done in the class initializer.)

See g_signal_new() for details on allowed signal names.

If c_marshaller is %NULL, g_cclosure_marshal_generic() will be used as
the marshaller for this signal.</doc>
        <source-position filename="gsignal.h" line="263" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="5017">the signal id</doc>
          <type name="guint" c:type="guint" />
        </return-value>
        <parameters>
          <parameter name="signal_name" transfer-ownership="none" gs:managed-name="signalName" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4991">the name for the signal</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="itype" transfer-ownership="none" gs:managed-name="itype" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4992">the type this signal pertains to. It will also pertain to
    types which are derived from this type</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="signal_flags" transfer-ownership="none" gs:managed-name="signalFlags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4994">a combination of #GSignalFlags specifying detail of when
    the default handler is to be invoked. You should at least specify
    %G_SIGNAL_RUN_FIRST or %G_SIGNAL_RUN_LAST</doc>
            <type name="SignalFlags" c:type="GSignalFlags" />
          </parameter>
          <parameter name="class_closure" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="classClosure" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4997">The closure to invoke on signal emission;
    may be %NULL</doc>
            <type name="Closure" c:type="GClosure*" gs:is-pointer="1" />
          </parameter>
          <parameter name="accumulator" transfer-ownership="none" nullable="1" allow-none="1" closure="5" gs:managed-name="accumulator" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4999">the accumulator for this signal; may be %NULL</doc>
            <type name="SignalAccumulator" c:type="GSignalAccumulator" />
          </parameter>
          <parameter name="accu_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="accuData" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5000">user data for the @accumulator</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="c_marshaller" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cMarshaller" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5001">the function to translate arrays of
    parameter values to signal emissions into C language callback
    invocations or %NULL</doc>
            <type name="SignalCMarshaller" c:type="GSignalCMarshaller" />
          </parameter>
          <parameter name="return_type" transfer-ownership="none" gs:managed-name="returnType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5004">the type of return value, or #G_TYPE_NONE for a signal
    without a return value</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="n_params" transfer-ownership="none" gs:managed-name="nParams" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5006">the length of @param_types</doc>
            <type name="guint" c:type="guint" />
          </parameter>
          <parameter name="param_types" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="paramTypes" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5007">an array of types, one for
    each parameter (may be %NULL if @n_params is zero)</doc>
            <array length="8" zero-terminated="0" c:type="GType*" gs:is-pointer="1">
              <type name="GType" c:type="GType" />
            </array>
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="signal_name" transfer-ownership="none" gs:managed-name="signalName" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4991">the name for the signal</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="itype" transfer-ownership="none" gs:managed-name="itype" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4992">the type this signal pertains to. It will also pertain to
    types which are derived from this type</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="signal_flags" transfer-ownership="none" gs:managed-name="signalFlags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4994">a combination of #GSignalFlags specifying detail of when
    the default handler is to be invoked. You should at least specify
    %G_SIGNAL_RUN_FIRST or %G_SIGNAL_RUN_LAST</doc>
            <type name="SignalFlags" c:type="GSignalFlags" />
          </parameter>
          <parameter name="class_closure" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="classClosure" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4997">The closure to invoke on signal emission;
    may be %NULL</doc>
            <type name="Closure" c:type="GClosure*" gs:is-pointer="1" />
          </parameter>
          <parameter name="accumulator" transfer-ownership="none" nullable="1" allow-none="1" closure="5" gs:managed-name="accumulator" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4999">the accumulator for this signal; may be %NULL</doc>
            <type name="SignalAccumulator" c:type="GSignalAccumulator" />
          </parameter>
          <parameter name="c_marshaller" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cMarshaller" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5001">the function to translate arrays of
    parameter values to signal emissions into C language callback
    invocations or %NULL</doc>
            <type name="SignalCMarshaller" c:type="GSignalCMarshaller" />
          </parameter>
          <parameter name="return_type" transfer-ownership="none" gs:managed-name="returnType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5004">the type of return value, or #G_TYPE_NONE for a signal
    without a return value</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="param_types" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="paramTypes" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5007">an array of types, one for
    each parameter (may be %NULL if @n_params is zero)</doc>
            <array length="8" zero-terminated="0" c:type="GType*" gs:is-pointer="1">
              <type name="GType" c:type="GType" />
            </array>
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="override_class_closure" c:identifier="g_signal_override_class_closure" gs:dll-name="gobject-2.0" gs:managed-name="OverrideClassClosure">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="5021">Overrides the class closure (i.e. the default handler) for the given signal
for emissions on instances of @instance_type. @instance_type must be derived
from the type to which the signal belongs.

See g_signal_chain_from_overridden() and
g_signal_chain_from_overridden_handler() for how to chain up to the
parent class closure from inside the overridden one.</doc>
        <source-position filename="gsignal.h" line="460" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <parameter name="signal_id" transfer-ownership="none" gs:managed-name="signalId" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5023">the signal id</doc>
            <type name="guint" c:type="guint" />
          </parameter>
          <parameter name="instance_type" transfer-ownership="none" gs:managed-name="instanceType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5024">the instance type on which to override the class closure
 for the signal.</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="class_closure" transfer-ownership="none" gs:managed-name="classClosure" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5026">the closure.</doc>
            <type name="Closure" c:type="GClosure*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="signal_id" transfer-ownership="none" gs:managed-name="signalId" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5023">the signal id</doc>
            <type name="guint" c:type="guint" />
          </parameter>
          <parameter name="instance_type" transfer-ownership="none" gs:managed-name="instanceType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5024">the instance type on which to override the class closure
 for the signal.</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="class_closure" transfer-ownership="none" gs:managed-name="classClosure" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5026">the closure.</doc>
            <type name="Closure" c:type="GClosure*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="parse_name" c:identifier="g_signal_parse_name" gs:dll-name="gobject-2.0" gs:managed-name="TryParseName">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="5058">Internal function to parse a signal name into its @signal_id
and @detail quark.</doc>
        <source-position filename="gsignal.h" line="344" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="5069">Whether the signal name could successfully be parsed and @signal_id_p and @detail_p contain valid return values.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <parameter name="detailed_signal" transfer-ownership="none" gs:managed-name="detailedSignal" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5060">a string of the form "signal-name::detail".</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="itype" transfer-ownership="none" gs:managed-name="itype" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5061">The interface/instance type that introduced "signal-name".</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="signal_id_p" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="signalIdP">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5062">Location to store the signal id.</doc>
            <type name="guint" c:type="guint*" />
          </parameter>
          <parameter name="detail_p" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="detailP">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5063">Location to store the detail quark.</doc>
            <type name="GLib.Quark" c:type="GQuark*" />
          </parameter>
          <parameter name="force_detail_quark" transfer-ownership="none" gs:default="false" gs:managed-name="forceDetailQuark" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5064">%TRUE forces creation of a #GQuark for the detail.</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="detailed_signal" transfer-ownership="none" gs:managed-name="detailedSignal" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5060">a string of the form "signal-name::detail".</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="itype" transfer-ownership="none" gs:managed-name="itype" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5061">The interface/instance type that introduced "signal-name".</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="signal_id_p" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="signalIdP">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5062">Location to store the signal id.</doc>
            <type name="guint" c:type="guint*" />
          </parameter>
          <parameter name="detail_p" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="detailP">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5063">Location to store the detail quark.</doc>
            <type name="GLib.Quark" c:type="GQuark*" />
          </parameter>
          <parameter name="force_detail_quark" transfer-ownership="none" gs:default="false" gs:managed-name="forceDetailQuark" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5064">%TRUE forces creation of a #GQuark for the detail.</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="query" c:identifier="g_signal_query" gs:dll-name="gobject-2.0" gs:managed-name="Query">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="5073">Queries the signal system for in-depth information about a
specific signal. This function will fill in a user-provided
structure to hold signal-specific information. If an invalid
signal id is passed in, the @signal_id member of the #GSignalQuery
is 0. All members filled into the #GSignalQuery structure should
be considered constant and have to be left untouched.</doc>
        <source-position filename="gsignal.h" line="336" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <parameter name="signal_id" transfer-ownership="none" gs:managed-name="signalId" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5075">The signal id of the signal to query information for.</doc>
            <type name="guint" c:type="guint" />
          </parameter>
          <parameter name="query" direction="out" caller-allocates="1" transfer-ownership="none" gs:managed-name="query">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5076">A user provided structure that is
 filled in with constant values upon success.</doc>
            <type name="SignalQuery" c:type="GSignalQuery*" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="signal_id" transfer-ownership="none" gs:managed-name="signalId" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5075">The signal id of the signal to query information for.</doc>
            <type name="guint" c:type="guint" />
          </parameter>
          <parameter name="query" direction="out" caller-allocates="1" transfer-ownership="none" gs:managed-name="query">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5076">A user provided structure that is
 filled in with constant values upon success.</doc>
            <type name="SignalQuery" c:type="GSignalQuery*" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="remove_emission_hook" c:identifier="g_signal_remove_emission_hook" gs:dll-name="gobject-2.0" gs:managed-name="RemoveEmissionHook">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="5088">Deletes an emission hook.</doc>
        <source-position filename="gsignal.h" line="368" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <parameter name="signal_id" transfer-ownership="none" gs:managed-name="signalId" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5090">the id of the signal</doc>
            <type name="guint" c:type="guint" />
          </parameter>
          <parameter name="hook_id" transfer-ownership="none" gs:managed-name="hookId" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5091">the id of the emission hook, as returned by
 g_signal_add_emission_hook()</doc>
            <type name="gulong" c:type="gulong" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="signal_id" transfer-ownership="none" gs:managed-name="signalId" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5090">the id of the signal</doc>
            <type name="guint" c:type="guint" />
          </parameter>
          <parameter name="hook_id" transfer-ownership="none" gs:managed-name="hookId" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5091">the id of the emission hook, as returned by
 g_signal_add_emission_hook()</doc>
            <type name="gulong" c:type="gulong" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="stop_emission" c:identifier="g_signal_stop_emission" gs:dll-name="gobject-2.0" gs:managed-name="StopEmission">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="5113">Stops a signal's current emission.

This will prevent the default method from running, if the signal was
%G_SIGNAL_RUN_LAST and you connected normally (i.e. without the "after"
flag).

Prints a warning if used on a signal which isn't being emitted.</doc>
        <source-position filename="gsignal.h" line="355" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <parameter name="instance" transfer-ownership="none" gs:managed-name="instance" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5115">the object whose signal handlers you wish to stop.</doc>
            <type name="Object" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="signal_id" transfer-ownership="none" gs:managed-name="signalId" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5116">the signal identifier, as returned by g_signal_lookup().</doc>
            <type name="guint" c:type="guint" />
          </parameter>
          <parameter name="detail" transfer-ownership="none" gs:default="default" gs:managed-name="detail" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5117">the detail which the signal was emitted with.</doc>
            <type name="GLib.Quark" c:type="GQuark" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="instance" transfer-ownership="none" gs:managed-name="instance" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5115">the object whose signal handlers you wish to stop.</doc>
            <type name="Object" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="signal_id" transfer-ownership="none" gs:managed-name="signalId" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5116">the signal identifier, as returned by g_signal_lookup().</doc>
            <type name="guint" c:type="guint" />
          </parameter>
          <parameter name="detail" transfer-ownership="none" gs:default="default" gs:managed-name="detail" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5117">the detail which the signal was emitted with.</doc>
            <type name="GLib.Quark" c:type="GQuark" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="stop_emission_by_name" c:identifier="g_signal_stop_emission_by_name" shadows="stop_emission" gs:dll-name="gobject-2.0" gs:managed-name="StopEmission">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="5129">Stops a signal's current emission.

This is just like g_signal_stop_emission() except it will look up the
signal id for you.</doc>
        <source-position filename="gsignal.h" line="359" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <parameter name="instance" transfer-ownership="none" gs:managed-name="instance" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5131">the object whose signal handlers you wish to stop.</doc>
            <type name="Object" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="detailed_signal" transfer-ownership="none" gs:managed-name="detailedSignal" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5132">a string of the form "signal-name::detail".</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="instance" transfer-ownership="none" gs:managed-name="instance" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5131">the object whose signal handlers you wish to stop.</doc>
            <type name="Object" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="detailed_signal" transfer-ownership="none" gs:managed-name="detailedSignal" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5132">a string of the form "signal-name::detail".</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="type_cclosure_new" c:identifier="g_signal_type_cclosure_new" gs:dll-name="gobject-2.0" gs:managed-name="TypeCclosureNew">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="5141">Creates a new closure which invokes the function found at the offset
@struct_offset in the class structure of the interface or classed type
identified by @itype.</doc>
        <source-position filename="gclosure.h" line="233" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="5151">a floating reference to a new #GCClosure</doc>
          <type name="Closure" c:type="GClosure*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="itype" transfer-ownership="none" gs:managed-name="itype" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5143">the #GType identifier of an interface or classed type</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="struct_offset" transfer-ownership="none" gs:managed-name="structOffset" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5144">the offset of the member function of @itype's class
 structure which is to be invoked by the new closure</doc>
            <type name="guint" c:type="guint" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="itype" transfer-ownership="none" gs:managed-name="itype" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5143">the #GType identifier of an interface or classed type</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="struct_offset" transfer-ownership="none" gs:managed-name="structOffset" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5144">the offset of the member function of @itype's class
 structure which is to be invoked by the new closure</doc>
            <type name="guint" c:type="guint" />
          </parameter>
        </gs:managed-parameters>
      </function>
    </gs:static-class>
    <alias name="TypeDefaultInterface" c:type="GTypeInterface" gs:custom-default-constructor="1" gs:custom-dispose="1" gs:managed-name="TypeDefaultInterface">
  <type name="TypeInterface" c:type="GTypeInterface" />
<method name="peek" c:identifier="g_type_default_interface_peek" version="2.4" gs:pinvoke-only="1" gs:dll-name="gobject-2.0" gs:managed-name="Peek"><doc xml:space="preserve" filename="gobject-2.0.c" line="5506">If the interface type @g_type is currently in use, returns its
default interface vtable.</doc><source-position filename="gtype.h" line="731" /><return-value transfer-ownership="none" gs:managed-name="ret" direction="in"><doc xml:space="preserve" filename="gobject-2.0.c" line="5514">the default
    vtable for the interface, or %NULL if the type is not currently
    in use</doc><type name="TypeInterface" c:type="gpointer" gs:is-pointer="1" /></return-value><parameters><instance-parameter name="g_type" transfer-ownership="none" gs:managed-name="gType" direction="in"><doc xml:space="preserve" filename="gobject-2.0.c" line="5508">an interface type</doc><type name="GType" c:type="GType" /></instance-parameter></parameters><gs:managed-parameters /></method><constructor name="ref" c:identifier="g_type_default_interface_ref" version="2.4" gs:dll-name="gobject-2.0" gs:managed-name="Ref"><doc xml:space="preserve" filename="gobject-2.0.c" line="5520">Increments the reference count for the interface type @g_type,
and returns the default interface vtable for the type.

If the type is not currently in use, then the default vtable
for the type will be created and initialized by calling
the base interface init and default vtable init functions for
the type (the @base_init and @class_init members of #GTypeInfo).
Calling g_type_default_interface_ref() is useful when you
want to make sure that signals and properties for an interface
have been installed.</doc><source-position filename="gtype.h" line="729" /><return-value transfer-ownership="full" gs:managed-name="ret" direction="in"><doc xml:space="preserve" filename="gobject-2.0.c" line="5536">the default
    vtable for the interface; call g_type_default_interface_unref()
    when you are done using the interface.</doc><type name="TypeInterface" c:type="gpointer" gs:is-pointer="1" /></return-value><parameters><parameter name="g_type" transfer-ownership="none" gs:managed-name="gType" direction="in"><doc xml:space="preserve" filename="gobject-2.0.c" line="5522">an interface type</doc><type name="GType" c:type="GType" /></parameter></parameters><gs:managed-parameters><parameter name="g_type" transfer-ownership="none" gs:managed-name="gType" direction="in"><doc xml:space="preserve" filename="gobject-2.0.c" line="5522">an interface type</doc><type name="GType" c:type="GType" /></parameter></gs:managed-parameters></constructor><method name="unref" c:identifier="g_type_default_interface_unref" version="2.4" gs:dll-name="gobject-2.0" gs:managed-name="Unref" gs:special-func="unref" gs:pinvoke-only="1"><doc xml:space="preserve" filename="gobject-2.0.c" line="5542">Decrements the reference count for the type corresponding to the
interface default vtable @g_iface. If the type is dynamic, then
when no one is using the interface and all references have
been released, the finalize function for the interface's default
vtable (the @class_finalize member of #GTypeInfo) will be called.</doc><source-position filename="gtype.h" line="733" /><return-value transfer-ownership="none" gs:managed-name="ret" direction="in"><type name="none" c:type="void" /></return-value><parameters><instance-parameter name="g_iface" transfer-ownership="none" gs:managed-name="gIface" direction="in"><doc xml:space="preserve" filename="gobject-2.0.c" line="5544">the default vtable
    structure for an interface, as returned by g_type_default_interface_ref()</doc><type name="TypeInterface" c:type="gpointer" gs:is-pointer="1" /></instance-parameter></parameters><gs:managed-parameters /></method></alias>
    <gs:static-class name="TypeExtensions" gs:managed-name="TypeExtensions">
      <method name="add_class_private" c:identifier="g_type_add_class_private" version="2.24" gs:dll-name="gobject-2.0" gs:managed-name="AddClassPrivate" gs:extension-method="1">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="5213">Registers a private class structure for a classed type;
when the class is allocated, the private structures for
the class and all of its parent types are allocated
sequentially in the same memory block as the public
structures, and are zero-filled.

This function should be called in the
type's get_type() function after the type is registered.
The private structure can be retrieved using the
G_TYPE_CLASS_GET_PRIVATE() macro.</doc>
        <source-position filename="gtype.h" line="1317" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="class_type" transfer-ownership="none" gs:managed-name="classType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5215">GType of a classed type</doc>
            <type name="GType" c:type="GType" />
          </instance-parameter>
          <parameter name="private_size" transfer-ownership="none" gs:managed-name="privateSize" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5216">size of private structure</doc>
            <type name="gsize" c:type="gsize" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="class_type" transfer-ownership="none" gs:managed-name="classType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5215">GType of a classed type</doc>
            <type name="GType" c:type="GType" />
          </instance-parameter>
          <parameter name="private_size" transfer-ownership="none" gs:managed-name="privateSize" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5216">size of private structure</doc>
            <type name="gsize" c:type="gsize" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="add_instance_private" c:identifier="g_type_add_instance_private" gs:dll-name="gobject-2.0" gs:managed-name="AddInstancePrivate" gs:extension-method="1">
        <source-position filename="gtype.h" line="1307" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="gint" c:type="gint" />
        </return-value>
        <parameters>
          <instance-parameter name="class_type" transfer-ownership="none" gs:managed-name="classType" direction="in">
            <type name="GType" c:type="GType" />
          </instance-parameter>
          <parameter name="private_size" transfer-ownership="none" gs:managed-name="privateSize" direction="in">
            <type name="gsize" c:type="gsize" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="class_type" transfer-ownership="none" gs:managed-name="classType" direction="in">
            <type name="GType" c:type="GType" />
          </instance-parameter>
          <parameter name="private_size" transfer-ownership="none" gs:managed-name="privateSize" direction="in">
            <type name="gsize" c:type="gsize" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="add_interface_static" c:identifier="g_type_add_interface_static" gs:pinvoke-only="1" gs:dll-name="gobject-2.0" gs:managed-name="AddInterfaceStatic" gs:extension-method="1">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="5265">Adds @interface_type to the static @instance_type.
The information contained in the #GInterfaceInfo structure
pointed to by @info is used to manage the relationship.</doc>
        <source-position filename="gtype.h" line="1290" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="instance_type" transfer-ownership="none" gs:managed-name="instanceType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5267">#GType value of an instantiatable type</doc>
            <type name="GType" c:type="GType" />
          </instance-parameter>
          <parameter name="interface_type" transfer-ownership="none" gs:managed-name="interfaceType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5268">#GType value of an interface type</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5269">#GInterfaceInfo structure for this
       (@instance_type, @interface_type) combination</doc>
            <type name="InterfaceInfo" c:type="const GInterfaceInfo*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="instance_type" transfer-ownership="none" gs:managed-name="instanceType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5267">#GType value of an instantiatable type</doc>
            <type name="GType" c:type="GType" />
          </instance-parameter>
          <parameter name="interface_type" transfer-ownership="none" gs:managed-name="interfaceType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5268">#GType value of an interface type</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5269">#GInterfaceInfo structure for this
       (@instance_type, @interface_type) combination</doc>
            <type name="InterfaceInfo" c:type="const GInterfaceInfo*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <function name="check_class_is_a" c:identifier="g_type_check_class_is_a" gs:dll-name="gobject-2.0" gs:managed-name="CheckClassIsA">
        <source-position filename="gtype.h" line="2273" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <parameter name="g_class" transfer-ownership="none" gs:managed-name="gClass" direction="in">
            <type name="TypeClass" c:type="GTypeClass*" gs:is-pointer="1" />
          </parameter>
          <parameter name="is_a_type" transfer-ownership="none" gs:managed-name="isAType" direction="in">
            <type name="GType" c:type="GType" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="g_class" transfer-ownership="none" gs:managed-name="gClass" direction="in">
            <type name="TypeClass" c:type="GTypeClass*" gs:is-pointer="1" />
          </parameter>
          <parameter name="is_a_type" transfer-ownership="none" gs:managed-name="isAType" direction="in">
            <type name="GType" c:type="GType" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="check_instance" c:identifier="g_type_check_instance" gs:dll-name="gobject-2.0" gs:managed-name="CheckInstance">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="5278">Private helper function to aid implementation of the
G_TYPE_CHECK_INSTANCE() macro.</doc>
        <source-position filename="gtype.h" line="2259" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="5285">%TRUE if @instance is valid, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <parameter name="instance" transfer-ownership="none" gs:managed-name="instance" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5280">a valid #GTypeInstance structure</doc>
            <type name="TypeInstance" c:type="GTypeInstance*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="instance" transfer-ownership="none" gs:managed-name="instance" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5280">a valid #GTypeInstance structure</doc>
            <type name="TypeInstance" c:type="GTypeInstance*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="check_instance_is_a" c:identifier="g_type_check_instance_is_a" gs:dll-name="gobject-2.0" gs:managed-name="CheckInstanceIsA">
        <source-position filename="gtype.h" line="2264" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <parameter name="instance" transfer-ownership="none" gs:managed-name="instance" direction="in">
            <type name="TypeInstance" c:type="GTypeInstance*" gs:is-pointer="1" />
          </parameter>
          <parameter name="iface_type" transfer-ownership="none" gs:managed-name="ifaceType" direction="in">
            <type name="GType" c:type="GType" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="instance" transfer-ownership="none" gs:managed-name="instance" direction="in">
            <type name="TypeInstance" c:type="GTypeInstance*" gs:is-pointer="1" />
          </parameter>
          <parameter name="iface_type" transfer-ownership="none" gs:managed-name="ifaceType" direction="in">
            <type name="GType" c:type="GType" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="check_instance_is_fundamentally_a" c:identifier="g_type_check_instance_is_fundamentally_a" gs:dll-name="gobject-2.0" gs:managed-name="CheckInstanceIsFundamentallyA">
        <source-position filename="gtype.h" line="2267" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <parameter name="instance" transfer-ownership="none" gs:managed-name="instance" direction="in">
            <type name="TypeInstance" c:type="GTypeInstance*" gs:is-pointer="1" />
          </parameter>
          <parameter name="fundamental_type" transfer-ownership="none" gs:managed-name="fundamentalType" direction="in">
            <type name="GType" c:type="GType" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="instance" transfer-ownership="none" gs:managed-name="instance" direction="in">
            <type name="TypeInstance" c:type="GTypeInstance*" gs:is-pointer="1" />
          </parameter>
          <parameter name="fundamental_type" transfer-ownership="none" gs:managed-name="fundamentalType" direction="in">
            <type name="GType" c:type="GType" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="check_value" c:identifier="g_type_check_value" gs:dll-name="gobject-2.0" gs:managed-name="CheckValue">
        <source-position filename="gtype.h" line="2278" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="check_value_holds" c:identifier="g_type_check_value_holds" gs:dll-name="gobject-2.0" gs:managed-name="CheckValueHolds">
        <source-position filename="gtype.h" line="2280" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </parameter>
          <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <type name="GType" c:type="GType" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <type name="Value" c:type="const GValue*" gs:is-pointer="1" />
          </parameter>
          <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <type name="GType" c:type="GType" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <method name="depth" c:identifier="g_type_depth" gs:dll-name="gobject-2.0" gs:managed-name="Depth" gs:extension-method="1">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="5557">Returns the length of the ancestry of the passed in type. This
includes the type itself, so that e.g. a fundamental type has depth 1.</doc>
        <source-position filename="gtype.h" line="705" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="5564">the depth of @type</doc>
          <type name="guint" c:type="guint" />
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5559">a #GType</doc>
            <type name="GType" c:type="GType" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5559">a #GType</doc>
            <type name="GType" c:type="GType" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="ensure" c:identifier="g_type_ensure" version="2.34" gs:dll-name="gobject-2.0" gs:managed-name="Ensure" gs:extension-method="1">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="5568">Ensures that the indicated @type has been registered with the
type system, and its _class_init() method has been run.

In theory, simply calling the type's _get_type() method (or using
the corresponding macro) is supposed take care of this. However,
_get_type() methods are often marked %G_GNUC_CONST for performance
reasons, even though this is technically incorrect (since
%G_GNUC_CONST requires that the function not have side effects,
which _get_type() methods do on the first call). As a result, if
you write a bare call to a _get_type() macro, it may get optimized
out by the compiler. Using g_type_ensure() guarantees that the
type's _get_type() method is called.</doc>
        <source-position filename="gtype.h" line="1326" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5570">a #GType</doc>
            <type name="GType" c:type="GType" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5570">a #GType</doc>
            <type name="GType" c:type="GType" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <function name="free_instance" c:identifier="g_type_free_instance" gs:dll-name="gobject-2.0" gs:managed-name="FreeInstance">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="5589">Frees an instance of a type, returning it to the instance pool for
the type, if there is one.

Like g_type_create_instance(), this function is reserved for
implementors of fundamental types.</doc>
        <source-position filename="gtype.h" line="2235" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <parameter name="instance" transfer-ownership="none" gs:managed-name="instance" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5591">an instance of a type</doc>
            <type name="TypeInstance" c:type="GTypeInstance*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="instance" transfer-ownership="none" gs:managed-name="instance" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5591">an instance of a type</doc>
            <type name="TypeInstance" c:type="GTypeInstance*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="fundamental_next" c:identifier="g_type_fundamental_next" gs:dll-name="gobject-2.0" gs:managed-name="FundamentalNext">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="5625">Returns the next free fundamental type id which can be used to
register a new fundamental type with g_type_register_fundamental().
The returned type ID represents the highest currently registered
fundamental type identifier.</doc>
        <source-position filename="gtype.h" line="2229" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="5633">the next available fundamental type ID to be registered,
    or 0 if the type system ran out of fundamental type IDs</doc>
          <type name="GType" c:type="GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
      <method name="get_instance_count" c:identifier="g_type_get_instance_count" version="2.44" gs:dll-name="gobject-2.0" gs:managed-name="GetInstanceCount" gs:extension-method="1">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="5638">Returns the number of instances allocated of the particular type;
this is only available if GLib is built with debugging support and
the instance_count debug flag is set (by setting the GOBJECT_DEBUG
variable to include instance-count).</doc>
        <source-position filename="gtype.h" line="756" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="5647">the number of instances allocated of the given type;
  if instance counts are not available, returns 0.</doc>
          <type name="gint" c:type="int" />
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5640">a #GType</doc>
            <type name="GType" c:type="GType" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5640">a #GType</doc>
            <type name="GType" c:type="GType" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_q_data" c:identifier="g_type_get_qdata" gs:dll-name="gobject-2.0" gs:managed-name="GetQData" gs:extension-method="1">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="5664">Obtains data which has previously been attached to @type
with g_type_set_qdata().

Note that this does not take subtyping into account; data
attached to one type with g_type_set_qdata() cannot
be retrieved from a subtype using g_type_get_qdata().</doc>
        <source-position filename="gtype.h" line="749" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="5676">the data, or %NULL if no data was found</doc>
          <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5666">a #GType</doc>
            <type name="GType" c:type="GType" />
          </instance-parameter>
          <parameter name="quark" transfer-ownership="none" gs:managed-name="quark" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5667">a #GQuark id to identify the data</doc>
            <type name="GLib.Quark" c:type="GQuark" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5666">a #GType</doc>
            <type name="GType" c:type="GType" />
          </instance-parameter>
          <parameter name="quark" transfer-ownership="none" gs:managed-name="quark" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5667">a #GQuark id to identify the data</doc>
            <type name="GLib.Quark" c:type="GQuark" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <gs:managed-property name="get_type_registration_serial" version="2.36" gs:dll-name="gobject-2.0" gs:managed-name="TypeRegistrationSerial">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="5680">Returns an opaque serial number that represents the state of the set
of registered types. Any time a type is registered this serial changes,
which means you can cache information based on type lookups (such as
g_type_from_name()) and know if the cache is still valid at a later
time by comparing the current serial with the one at the type lookup.</doc>
        <source-position filename="gtype.h" line="1328" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="5690">An unsigned int, representing the state of type registrations</doc>
          <type name="guint" c:type="guint" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </gs:managed-property>
      <function name="get_type_registration_serial" c:identifier="g_type_get_type_registration_serial" version="2.36" gs:dll-name="gobject-2.0" gs:managed-name="GetTypeRegistrationSerial" gs:property-getter-for="TypeRegistrationSerial" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="5680">Returns an opaque serial number that represents the state of the set
of registered types. Any time a type is registered this serial changes,
which means you can cache information based on type lookups (such as
g_type_from_name()) and know if the cache is still valid at a later
time by comparing the current serial with the one at the type lookup.</doc>
        <source-position filename="gtype.h" line="1328" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="5690">An unsigned int, representing the state of type registrations</doc>
          <type name="guint" c:type="guint" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
      <function name="init" c:identifier="g_type_init" deprecated="1" deprecated-version="2.36" gs:dll-name="gobject-2.0" gs:managed-name="Init">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="5694">This function used to initialise the type system.  Since GLib 2.36,
the type system is initialised automatically and this function does
nothing.</doc>
        <doc-deprecated xml:space="preserve">the type system is now initialised automatically</doc-deprecated>
        <source-position filename="gtype.h" line="691" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
      <function name="init_with_debug_flags" c:identifier="g_type_init_with_debug_flags" deprecated="1" deprecated-version="2.36" gs:dll-name="gobject-2.0" gs:managed-name="InitWithDebugFlags">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="5705">This function used to initialise the type system with debugging
flags.  Since GLib 2.36, the type system is initialised automatically
and this function does nothing.

If you need to enable debugging features, use the GOBJECT_DEBUG
environment variable.</doc>
        <doc-deprecated xml:space="preserve">the type system is now initialised automatically</doc-deprecated>
        <source-position filename="gtype.h" line="693" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <parameter name="debug_flags" transfer-ownership="none" gs:managed-name="debugFlags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5707">bitwise combination of #GTypeDebugFlags values for
    debugging purposes</doc>
            <type name="TypeDebugFlags" c:type="GTypeDebugFlags" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="debug_flags" transfer-ownership="none" gs:managed-name="debugFlags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5707">bitwise combination of #GTypeDebugFlags values for
    debugging purposes</doc>
            <type name="TypeDebugFlags" c:type="GTypeDebugFlags" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <method name="interfaces" c:identifier="g_type_interfaces" gs:dll-name="gobject-2.0" gs:managed-name="Interfaces" gs:extension-method="1">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="5810">Return a newly allocated and 0-terminated array of type IDs, listing
the interface types that @type conforms to.</doc>
        <source-position filename="gtype.h" line="740" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="5819">Newly allocated
    and 0-terminated array of interface types, free with g_free()</doc>
          <array length="0" zero-terminated="0" c:type="GType*" gs:is-pointer="1">
            <type name="GType" c:type="GType" />
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5812">the type to list interface types for</doc>
            <type name="GType" c:type="GType" />
          </instance-parameter>
          <parameter name="n_interfaces" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="nInterfaces">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5813">location to store the length of
    the returned array, or %NULL</doc>
            <type name="guint" c:type="guint*" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5812">the type to list interface types for</doc>
            <type name="GType" c:type="GType" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <function name="name_from_class" c:identifier="g_type_name_from_class" gs:dll-name="gobject-2.0" gs:managed-name="NameFromClass">
        <source-position filename="gtype.h" line="2291" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="g_class" transfer-ownership="none" gs:managed-name="gClass" direction="in">
            <type name="TypeClass" c:type="GTypeClass*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="g_class" transfer-ownership="none" gs:managed-name="gClass" direction="in">
            <type name="TypeClass" c:type="GTypeClass*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="name_from_instance" c:identifier="g_type_name_from_instance" gs:dll-name="gobject-2.0" gs:managed-name="NameFromInstance">
        <source-position filename="gtype.h" line="2289" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="instance" transfer-ownership="none" gs:managed-name="instance" direction="in">
            <type name="TypeInstance" c:type="GTypeInstance*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="instance" transfer-ownership="none" gs:managed-name="instance" direction="in">
            <type name="TypeInstance" c:type="GTypeInstance*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <method name="next_base" c:identifier="g_type_next_base" gs:dll-name="gobject-2.0" gs:managed-name="NextBase" gs:extension-method="1">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="5983">Given a @leaf_type and a @root_type which is contained in its
ancestry, return the type that @root_type is the immediate parent
of. In other words, this function determines the type that is
derived directly from @root_type which is also a base class of
@leaf_type.  Given a root type and a leaf type, this function can
be used to determine the types and order in which the leaf type is
descended from the root type.</doc>
        <source-position filename="gtype.h" line="707" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="5996">immediate child of @root_type and ancestor of @leaf_type</doc>
          <type name="GType" c:type="GType" />
        </return-value>
        <parameters>
          <instance-parameter name="leaf_type" transfer-ownership="none" gs:managed-name="leafType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5985">descendant of @root_type and the type to be returned</doc>
            <type name="GType" c:type="GType" />
          </instance-parameter>
          <parameter name="root_type" transfer-ownership="none" gs:managed-name="rootType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5986">immediate parent of the returned type</doc>
            <type name="GType" c:type="GType" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="leaf_type" transfer-ownership="none" gs:managed-name="leafType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5985">descendant of @root_type and the type to be returned</doc>
            <type name="GType" c:type="GType" />
          </instance-parameter>
          <parameter name="root_type" transfer-ownership="none" gs:managed-name="rootType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5986">immediate parent of the returned type</doc>
            <type name="GType" c:type="GType" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="q_name" c:identifier="g_type_qname" gs:dll-name="gobject-2.0" gs:managed-name="QName" gs:extension-method="1">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6058">Get the corresponding quark of the type IDs name.</doc>
        <source-position filename="gtype.h" line="699" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6064">the type names quark or 0</doc>
          <type name="GLib.Quark" c:type="GQuark" />
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6060">type to return quark of type name for</doc>
            <type name="GType" c:type="GType" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6060">type to return quark of type name for</doc>
            <type name="GType" c:type="GType" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="query" c:identifier="g_type_query" gs:dll-name="gobject-2.0" gs:managed-name="Query" gs:extension-method="1">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6068">Queries the type system for information about a specific type.
This function will fill in a user-provided structure to hold
type-specific information. If an invalid #GType is passed in, the
@type member of the #GTypeQuery is 0. All members filled into the
#GTypeQuery structure should be considered constant and have to be
left untouched.</doc>
        <source-position filename="gtype.h" line="752" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6070">#GType of a static, classed type</doc>
            <type name="GType" c:type="GType" />
          </instance-parameter>
          <parameter name="query" direction="out" caller-allocates="1" transfer-ownership="none" gs:managed-name="query">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6071">a user provided structure that is
    filled in with constant values upon success</doc>
            <type name="TypeQuery" c:type="GTypeQuery*" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6070">#GType of a static, classed type</doc>
            <type name="GType" c:type="GType" />
          </instance-parameter>
          <parameter name="query" direction="out" caller-allocates="1" transfer-ownership="none" gs:managed-name="query">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6071">a user provided structure that is
    filled in with constant values upon success</doc>
            <type name="TypeQuery" c:type="GTypeQuery*" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="register_fundamental" c:identifier="g_type_register_fundamental" gs:dll-name="gobject-2.0" gs:managed-name="RegisterFundamental" gs:extension-method="1">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6100">Registers @type_id as the predefined identifier and @type_name as the
name of a fundamental type. If @type_id is already registered, or a
type named @type_name is already registered, the behaviour is undefined.
The type system uses the information contained in the #GTypeInfo structure
pointed to by @info and the #GTypeFundamentalInfo structure pointed to by
@finfo to manage the type and its instances. The value of @flags determines
additional characteristics of the fundamental type.</doc>
        <source-position filename="gtype.h" line="1284" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6116">the predefined type identifier</doc>
          <type name="GType" c:type="GType" />
        </return-value>
        <parameters>
          <instance-parameter name="type_id" transfer-ownership="none" gs:managed-name="typeId" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6102">a predefined type identifier</doc>
            <type name="GType" c:type="GType" />
          </instance-parameter>
          <parameter name="type_name" transfer-ownership="none" gs:managed-name="typeName" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6103">0-terminated string used as the name of the new type</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6104">#GTypeInfo structure for this type</doc>
            <type name="TypeInfo" c:type="const GTypeInfo*" gs:is-pointer="1" />
          </parameter>
          <parameter name="finfo" transfer-ownership="none" gs:managed-name="finfo" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6105">#GTypeFundamentalInfo structure for this type</doc>
            <type name="TypeFundamentalInfo" c:type="const GTypeFundamentalInfo*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6106">bitwise combination of #GTypeFlags values</doc>
            <type name="TypeFlags" c:type="GTypeFlags" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="type_id" transfer-ownership="none" gs:managed-name="typeId" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6102">a predefined type identifier</doc>
            <type name="GType" c:type="GType" />
          </instance-parameter>
          <parameter name="type_name" transfer-ownership="none" gs:managed-name="typeName" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6103">0-terminated string used as the name of the new type</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6104">#GTypeInfo structure for this type</doc>
            <type name="TypeInfo" c:type="const GTypeInfo*" gs:is-pointer="1" />
          </parameter>
          <parameter name="finfo" transfer-ownership="none" gs:managed-name="finfo" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6105">#GTypeFundamentalInfo structure for this type</doc>
            <type name="TypeFundamentalInfo" c:type="const GTypeFundamentalInfo*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6106">bitwise combination of #GTypeFlags values</doc>
            <type name="TypeFlags" c:type="GTypeFlags" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="register_static" c:identifier="g_type_register_static" gs:pinvoke-only="1" gs:dll-name="gobject-2.0" gs:managed-name="RegisterStatic" gs:extension-method="1">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6120">Registers @type_name as the name of a new static type derived from
@parent_type. The type system uses the information contained in the
#GTypeInfo structure pointed to by @info to manage the type and its
instances (if not abstract). The value of @flags determines the nature
(e.g. abstract or not) of the type.</doc>
        <source-position filename="gtype.h" line="1265" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6133">the new type identifier</doc>
          <type name="GType" c:type="GType" />
        </return-value>
        <parameters>
          <instance-parameter name="parent_type" transfer-ownership="none" gs:managed-name="parentType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6122">type from which this type will be derived</doc>
            <type name="GType" c:type="GType" />
          </instance-parameter>
          <parameter name="type_name" transfer-ownership="none" gs:managed-name="typeName" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6123">0-terminated string used as the name of the new type</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6124">#GTypeInfo structure for this type</doc>
            <type name="TypeInfo" c:type="const GTypeInfo*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6125">bitwise combination of #GTypeFlags values</doc>
            <type name="TypeFlags" c:type="GTypeFlags" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="parent_type" transfer-ownership="none" gs:managed-name="parentType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6122">type from which this type will be derived</doc>
            <type name="GType" c:type="GType" />
          </instance-parameter>
          <parameter name="type_name" transfer-ownership="none" gs:managed-name="typeName" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6123">0-terminated string used as the name of the new type</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6124">#GTypeInfo structure for this type</doc>
            <type name="TypeInfo" c:type="const GTypeInfo*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6125">bitwise combination of #GTypeFlags values</doc>
            <type name="TypeFlags" c:type="GTypeFlags" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_q_data" c:identifier="g_type_set_qdata" gs:dll-name="gobject-2.0" gs:managed-name="SetQData" gs:extension-method="1">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6180">Attaches arbitrary data to a type.</doc>
        <source-position filename="gtype.h" line="745" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6182">a #GType</doc>
            <type name="GType" c:type="GType" />
          </instance-parameter>
          <parameter name="quark" transfer-ownership="none" gs:managed-name="quark" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6183">a #GQuark id to identify the data</doc>
            <type name="GLib.Quark" c:type="GQuark" />
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6184">the data</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6182">a #GType</doc>
            <type name="GType" c:type="GType" />
          </instance-parameter>
          <parameter name="quark" transfer-ownership="none" gs:managed-name="quark" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6183">a #GQuark id to identify the data</doc>
            <type name="GLib.Quark" c:type="GQuark" />
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6184">the data</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <constant name="FLAG_RESERVED_ID_BIT" value="1" c:type="G_TYPE_FLAG_RESERVED_ID_BIT" gs:access-modifiers="private" gs:managed-name="flagReservedIdBit">
        <doc xml:space="preserve" filename="gtype.h" line="2345">A bit in the type number that's supposed to be left untouched.</doc>
        <source-position filename="gtype.h" line="2350" />
        <type name="gsize" c:type="GType" />
      </constant>
      <constant name="FUNDAMENTAL_MAX" value="255" c:type="G_TYPE_FUNDAMENTAL_MAX" gs:access-modifiers="private" gs:managed-name="fundamentalMax">
        <doc xml:space="preserve" filename="gtype.h" line="39">An integer constant that represents the number of identifiers reserved
for types that are assigned at compile-time.</doc>
        <source-position filename="gtype.h" line="45" />
        <type name="gint" c:type="gint" />
      </constant>
      <constant name="FUNDAMENTAL_SHIFT" value="2" c:type="G_TYPE_FUNDAMENTAL_SHIFT" gs:access-modifiers="private" gs:managed-name="fundamentalShift">
        <doc xml:space="preserve" filename="gtype.h" line="205">Shift value used in converting numbers to type IDs.</doc>
        <source-position filename="gtype.h" line="210" />
        <type name="gint" c:type="gint" />
      </constant>
      <constant name="RESERVED_BSE_FIRST" value="32" c:type="G_TYPE_RESERVED_BSE_FIRST" gs:access-modifiers="private" gs:managed-name="reservedBseFirst">
        <doc xml:space="preserve" filename="gtype.h" line="235">First fundamental type number to create a new fundamental type id with
G_TYPE_MAKE_FUNDAMENTAL() reserved for BSE.</doc>
        <source-position filename="gtype.h" line="241" />
        <type name="gint" c:type="gint" />
      </constant>
      <constant name="RESERVED_BSE_LAST" value="48" c:type="G_TYPE_RESERVED_BSE_LAST" gs:access-modifiers="private" gs:managed-name="reservedBseLast">
        <doc xml:space="preserve" filename="gtype.h" line="242">Last fundamental type number reserved for BSE.</doc>
        <source-position filename="gtype.h" line="247" />
        <type name="gint" c:type="gint" />
      </constant>
      <constant name="RESERVED_GLIB_FIRST" value="22" c:type="G_TYPE_RESERVED_GLIB_FIRST" gs:access-modifiers="private" gs:managed-name="reservedGlibFirst">
        <doc xml:space="preserve" filename="gtype.h" line="222">First fundamental type number to create a new fundamental type id with
G_TYPE_MAKE_FUNDAMENTAL() reserved for GLib.</doc>
        <source-position filename="gtype.h" line="228" />
        <type name="gint" c:type="gint" />
      </constant>
      <constant name="RESERVED_GLIB_LAST" value="31" c:type="G_TYPE_RESERVED_GLIB_LAST" gs:access-modifiers="private" gs:managed-name="reservedGlibLast">
        <doc xml:space="preserve" filename="gtype.h" line="229">Last fundamental type number reserved for GLib.</doc>
        <source-position filename="gtype.h" line="234" />
        <type name="gint" c:type="gint" />
      </constant>
      <constant name="RESERVED_USER_FIRST" value="49" c:type="G_TYPE_RESERVED_USER_FIRST" gs:access-modifiers="private" gs:managed-name="reservedUserFirst">
        <doc xml:space="preserve" filename="gtype.h" line="248">First available fundamental type number to create new fundamental
type id with G_TYPE_MAKE_FUNDAMENTAL().</doc>
        <source-position filename="gtype.h" line="254" />
        <type name="gint" c:type="gint" />
      </constant>
    </gs:static-class>
  </namespace>
</repository>