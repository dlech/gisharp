// SPDX-License-Identifier: MIT
// ATTENTION: This file is automatically generated. Do not edit manually.
#nullable enable
namespace GISharp.Lib.GObject
{
    /// <include file="Flags.xmldoc" path="declaration/member[@name='Flags']/*" />
    public static unsafe partial class Flags
    {
        /// <summary>
        /// This function is meant to be called from the complete_type_info()
        /// function of a #GTypePlugin implementation, see the example for
        /// g_enum_complete_type_info() above.
        /// </summary>
        /// <param name="gFlagsType">
        /// the type identifier of the type being completed
        /// </param>
        /// <param name="info">
        /// the #GTypeInfo struct to be filled in
        /// </param>
        /// <param name="constValues">
        /// An array of #GFlagsValue structs for the possible
        ///  enumeration values. The array is terminated by a struct with all
        ///  members being 0.
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_flags_complete_type_info(
        /* <type name="GType" type="GType" managed-name="GISharp.Runtime.GType" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.GType gFlagsType,
        /* <type name="TypeInfo" type="GTypeInfo*" managed-name="TypeInfo" /> */
        /* direction:out caller-allocates:0 transfer-ownership:full */
        GISharp.Lib.GObject.TypeInfo* info,
        /* <array zero-terminated="1" type="const GFlagsValue*" managed-name="GISharp.Runtime.CArray" is-pointer="1">
*   <type name="FlagsValue" type="const GFlagsValue" managed-name="FlagsValue" />
* </array> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.FlagsValue* constValues);
        static partial void CheckCompleteTypeInfoArgs(GISharp.Runtime.GType gFlagsType, System.ReadOnlySpan<GISharp.Lib.GObject.FlagsValue> constValues);

        /// <include file="Flags.xmldoc" path="declaration/member[@name='Flags.CompleteTypeInfo(GISharp.Runtime.GType,GISharp.Lib.GObject.TypeInfo,System.ReadOnlySpan&lt;GISharp.Lib.GObject.FlagsValue&gt;)']/*" />
        public static void CompleteTypeInfo(GISharp.Runtime.GType gFlagsType, out GISharp.Lib.GObject.TypeInfo info, System.ReadOnlySpan<GISharp.Lib.GObject.FlagsValue> constValues)
        {
            fixed (GISharp.Lib.GObject.FlagsValue* constValuesData_ = constValues)
            {
                CheckCompleteTypeInfoArgs(gFlagsType, constValues);
                var gFlagsType_ = (GISharp.Runtime.GType)gFlagsType;
                var constValues_ = (GISharp.Lib.GObject.FlagsValue*)constValuesData_;
                GISharp.Lib.GObject.TypeInfo info_;
                g_flags_complete_type_info(gFlagsType_, &info_, constValues_);
                info = (GISharp.Lib.GObject.TypeInfo)info_;
            }
        }

        /// <summary>
        /// Returns the first #GFlagsValue which is set in @value.
        /// </summary>
        /// <param name="flagsClass">
        /// a #GFlagsClass
        /// </param>
        /// <param name="value">
        /// the value
        /// </param>
        /// <returns>
        /// the first #GFlagsValue which is set in
        ///          @value, or %NULL if none is set
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FlagsValue" type="GFlagsValue*" managed-name="FlagsValue" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GObject.FlagsValue* g_flags_get_first_value(
        /* <type name="FlagsClass" type="GFlagsClass*" managed-name="FlagsClass" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.FlagsClass.UnmanagedStruct* flagsClass,
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        uint value);
        static partial void CheckGetFirstValueArgs(GISharp.Lib.GObject.FlagsClass flagsClass, uint value);

        /// <include file="Flags.xmldoc" path="declaration/member[@name='Flags.GetFirstValue(GISharp.Lib.GObject.FlagsClass,uint)']/*" />
        public static ref readonly GISharp.Lib.GObject.FlagsValue GetFirstValue(GISharp.Lib.GObject.FlagsClass flagsClass, uint value)
        {
            CheckGetFirstValueArgs(flagsClass, value);
            var flagsClass_ = (GISharp.Lib.GObject.FlagsClass.UnmanagedStruct*)flagsClass.UnsafeHandle;
            var value_ = (uint)value;
            var ret_ = g_flags_get_first_value(flagsClass_,value_);
            ref var ret = ref System.Runtime.CompilerServices.Unsafe.AsRef<GISharp.Lib.GObject.FlagsValue>(ret_);
            return ref ret;
        }

        /// <summary>
        /// Looks up a #GFlagsValue by name.
        /// </summary>
        /// <param name="flagsClass">
        /// a #GFlagsClass
        /// </param>
        /// <param name="name">
        /// the name to look up
        /// </param>
        /// <returns>
        /// the #GFlagsValue with name @name,
        ///          or %NULL if there is no flag with that name
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FlagsValue" type="GFlagsValue*" managed-name="FlagsValue" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GObject.FlagsValue* g_flags_get_value_by_name(
        /* <type name="FlagsClass" type="GFlagsClass*" managed-name="FlagsClass" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.FlagsClass.UnmanagedStruct* flagsClass,
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* name);
        static partial void CheckGetValueByNameArgs(GISharp.Lib.GObject.FlagsClass flagsClass, GISharp.Lib.GLib.UnownedUtf8 name);

        /// <include file="Flags.xmldoc" path="declaration/member[@name='Flags.GetValueByName(GISharp.Lib.GObject.FlagsClass,GISharp.Lib.GLib.UnownedUtf8)']/*" />
        public static ref readonly GISharp.Lib.GObject.FlagsValue GetValueByName(GISharp.Lib.GObject.FlagsClass flagsClass, GISharp.Lib.GLib.UnownedUtf8 name)
        {
            CheckGetValueByNameArgs(flagsClass, name);
            var flagsClass_ = (GISharp.Lib.GObject.FlagsClass.UnmanagedStruct*)flagsClass.UnsafeHandle;
            var name_ = (byte*)name.UnsafeHandle;
            var ret_ = g_flags_get_value_by_name(flagsClass_,name_);
            ref var ret = ref System.Runtime.CompilerServices.Unsafe.AsRef<GISharp.Lib.GObject.FlagsValue>(ret_);
            return ref ret;
        }

        /// <summary>
        /// Looks up a #GFlagsValue by nickname.
        /// </summary>
        /// <param name="flagsClass">
        /// a #GFlagsClass
        /// </param>
        /// <param name="nick">
        /// the nickname to look up
        /// </param>
        /// <returns>
        /// the #GFlagsValue with nickname @nick,
        ///          or %NULL if there is no flag with that nickname
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FlagsValue" type="GFlagsValue*" managed-name="FlagsValue" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GObject.FlagsValue* g_flags_get_value_by_nick(
        /* <type name="FlagsClass" type="GFlagsClass*" managed-name="FlagsClass" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.FlagsClass.UnmanagedStruct* flagsClass,
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* nick);
        static partial void CheckGetValueByNickArgs(GISharp.Lib.GObject.FlagsClass flagsClass, GISharp.Lib.GLib.UnownedUtf8 nick);

        /// <include file="Flags.xmldoc" path="declaration/member[@name='Flags.GetValueByNick(GISharp.Lib.GObject.FlagsClass,GISharp.Lib.GLib.UnownedUtf8)']/*" />
        public static ref readonly GISharp.Lib.GObject.FlagsValue GetValueByNick(GISharp.Lib.GObject.FlagsClass flagsClass, GISharp.Lib.GLib.UnownedUtf8 nick)
        {
            CheckGetValueByNickArgs(flagsClass, nick);
            var flagsClass_ = (GISharp.Lib.GObject.FlagsClass.UnmanagedStruct*)flagsClass.UnsafeHandle;
            var nick_ = (byte*)nick.UnsafeHandle;
            var ret_ = g_flags_get_value_by_nick(flagsClass_,nick_);
            ref var ret = ref System.Runtime.CompilerServices.Unsafe.AsRef<GISharp.Lib.GObject.FlagsValue>(ret_);
            return ref ret;
        }

        /// <summary>
        /// Registers a new static flags type with the name @name.
        /// </summary>
        /// <remarks>
        /// <para>
        /// It is normally more convenient to let [glib-mkenums][glib-mkenums]
        /// generate a my_flags_get_type() function from a usual C enumeration
        /// definition than to write one yourself using g_flags_register_static().
        /// </para>
        /// </remarks>
        /// <param name="name">
        /// A nul-terminated string used as the name of the new type.
        /// </param>
        /// <param name="constStaticValues">
        /// An array of #GFlagsValue structs for the possible
        ///  flags values. The array is terminated by a struct with all members being 0.
        ///  GObject keeps a reference to the data, so it cannot be stack-allocated.
        /// </param>
        /// <returns>
        /// The new type identifier.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="GType" type="GType" managed-name="GISharp.Runtime.GType" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.GType g_flags_register_static(
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* name,
        /* <array zero-terminated="1" type="const GFlagsValue*" managed-name="GISharp.Runtime.CArray" is-pointer="1">
*   <type name="FlagsValue" type="const GFlagsValue" managed-name="FlagsValue" />
* </array> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.FlagsValue* constStaticValues);
        static partial void CheckRegisterStaticArgs(GISharp.Lib.GLib.UnownedUtf8 name, System.ReadOnlySpan<GISharp.Lib.GObject.FlagsValue> constStaticValues);

        /// <include file="Flags.xmldoc" path="declaration/member[@name='Flags.RegisterStatic(GISharp.Lib.GLib.UnownedUtf8,System.ReadOnlySpan&lt;GISharp.Lib.GObject.FlagsValue&gt;)']/*" />
        public static GISharp.Runtime.GType RegisterStatic(GISharp.Lib.GLib.UnownedUtf8 name, System.ReadOnlySpan<GISharp.Lib.GObject.FlagsValue> constStaticValues)
        {
            fixed (GISharp.Lib.GObject.FlagsValue* constStaticValuesData_ = constStaticValues)
            {
                CheckRegisterStaticArgs(name, constStaticValues);
                var name_ = (byte*)name.UnsafeHandle;
                var constStaticValues_ = (GISharp.Lib.GObject.FlagsValue*)constStaticValuesData_;
                var ret_ = g_flags_register_static(name_,constStaticValues_);
                var ret = (GISharp.Runtime.GType)ret_;
                return ret;
            }
        }

        /// <summary>
        /// Pretty-prints @value in the form of the flag names separated by ` | ` and
        /// sorted. Any extra bits will be shown at the end as a hexadecimal number.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This is intended to be used for debugging purposes. The format of the output
        /// may change in the future.
        /// </para>
        /// </remarks>
        /// <param name="flagsType">
        /// the type identifier of a #GFlagsClass type
        /// </param>
        /// <param name="value">
        /// the value
        /// </param>
        /// <returns>
        /// a newly-allocated text string
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.54")]
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern byte* g_flags_to_string(
        /* <type name="GType" type="GType" managed-name="GISharp.Runtime.GType" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.GType flagsType,
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        uint value);
        static partial void CheckToStringArgs(GISharp.Runtime.GType flagsType, uint value);

        /// <include file="Flags.xmldoc" path="declaration/member[@name='Flags.ToString(GISharp.Runtime.GType,uint)']/*" />
        [GISharp.Runtime.SinceAttribute("2.54")]
        public static GISharp.Lib.GLib.Utf8 ToString(GISharp.Runtime.GType flagsType, uint value)
        {
            CheckToStringArgs(flagsType, value);
            var flagsType_ = (GISharp.Runtime.GType)flagsType;
            var value_ = (uint)value;
            var ret_ = g_flags_to_string(flagsType_,value_);
            var ret = GISharp.Lib.GLib.Utf8.GetInstance<GISharp.Lib.GLib.Utf8>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }
    }
}