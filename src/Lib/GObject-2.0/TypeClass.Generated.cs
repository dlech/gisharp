// SPDX-License-Identifier: MIT
// ATTENTION: This file is automatically generated. Do not edit manually.
#nullable enable
namespace GISharp.Lib.GObject
{
    /// <include file="TypeClass.xmldoc" path="declaration/member[@name='TypeClass']/*" />
    public unsafe partial struct TypeClass
    {
#pragma warning disable CS0169, CS0649
        /// <include file="TypeClass.xmldoc" path="declaration/member[@name='TypeClass.GType']/*" />
        public readonly GISharp.Lib.GObject.GType GType;
#pragma warning restore CS0169, CS0649
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_type_class_adjust_private_offset(
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr gClass,
        /* <type name="gint" type="gint*" managed-name="System.Int32" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        int* privateSizeOrOffset);
        static partial void CheckAdjustPrivateOffsetArgs(System.IntPtr gClass, int privateSizeOrOffset);

        /// <include file="TypeClass.xmldoc" path="declaration/member[@name='TypeClass.AdjustPrivateOffset(System.IntPtr,int)']/*" />
        public static void AdjustPrivateOffset(System.IntPtr gClass, int privateSizeOrOffset)
        {
            CheckAdjustPrivateOffsetArgs(gClass, privateSizeOrOffset);
            var gClass_ = (System.IntPtr)gClass;
            var privateSizeOrOffset_ = &privateSizeOrOffset;
            g_type_class_adjust_private_offset(gClass_, privateSizeOrOffset_);
        }

        /// <summary>
        /// This function is essentially the same as g_type_class_ref(),
        /// except that the classes reference count isn't incremented.
        /// As a consequence, this function may return %NULL if the class
        /// of the type passed in does not currently exist (hasn't been
        /// referenced before).
        /// </summary>
        /// <param name="type">
        /// type ID of a classed type
        /// </param>
        /// <returns>
        /// the #GTypeClass
        ///     structure for the given type ID or %NULL if the class does not
        ///     currently exist
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="TypeClass" type="gpointer" managed-name="TypeClass" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GObject.TypeClass* g_type_class_peek(
        /* <type name="GType" type="GType" managed-name="GISharp.Lib.GObject.GType" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.GType type);
        static partial void CheckPeekArgs(GISharp.Lib.GObject.GType type);

        /// <include file="TypeClass.xmldoc" path="declaration/member[@name='TypeClass.Peek(GISharp.Lib.GObject.GType)']/*" />
        public static ref readonly GISharp.Lib.GObject.TypeClass Peek(GISharp.Lib.GObject.GType type)
        {
            CheckPeekArgs(type);
            var type_ = (GISharp.Lib.GObject.GType)type;
            var ret_ = g_type_class_peek(type_);
            ref readonly var ret = ref System.Runtime.CompilerServices.Unsafe.AsRef<GISharp.Lib.GObject.TypeClass>(ret_);
            return ref ret;
        }

        /// <summary>
        /// A more efficient version of g_type_class_peek() which works only for
        /// static types.
        /// </summary>
        /// <param name="type">
        /// type ID of a classed type
        /// </param>
        /// <returns>
        /// the #GTypeClass
        ///     structure for the given type ID or %NULL if the class does not
        ///     currently exist or is dynamically loaded
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.4")]
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="TypeClass" type="gpointer" managed-name="TypeClass" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GObject.TypeClass* g_type_class_peek_static(
        /* <type name="GType" type="GType" managed-name="GISharp.Lib.GObject.GType" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.GType type);
        static partial void CheckPeekStaticArgs(GISharp.Lib.GObject.GType type);

        /// <include file="TypeClass.xmldoc" path="declaration/member[@name='TypeClass.PeekStatic(GISharp.Lib.GObject.GType)']/*" />
        [GISharp.Runtime.SinceAttribute("2.4")]
        public static ref readonly GISharp.Lib.GObject.TypeClass PeekStatic(GISharp.Lib.GObject.GType type)
        {
            CheckPeekStaticArgs(type);
            var type_ = (GISharp.Lib.GObject.GType)type;
            var ret_ = g_type_class_peek_static(type_);
            ref readonly var ret = ref System.Runtime.CompilerServices.Unsafe.AsRef<GISharp.Lib.GObject.TypeClass>(ret_);
            return ref ret;
        }

        /// <summary>
        /// Increments the reference count of the class structure belonging to
        /// @type. This function will demand-create the class if it doesn't
        /// exist already.
        /// </summary>
        /// <param name="type">
        /// type ID of a classed type
        /// </param>
        /// <returns>
        /// the #GTypeClass
        ///     structure for the given type ID
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="TypeClass" type="gpointer" managed-name="TypeClass" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GObject.TypeClass* g_type_class_ref(
        /* <type name="GType" type="GType" managed-name="GISharp.Lib.GObject.GType" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.GType type);
        static partial void CheckRefArgs(GISharp.Lib.GObject.GType type);

        /// <include file="TypeClass.xmldoc" path="declaration/member[@name='TypeClass.Ref(GISharp.Lib.GObject.GType)']/*" />
        public static ref readonly GISharp.Lib.GObject.TypeClass Ref(GISharp.Lib.GObject.GType type)
        {
            CheckRefArgs(type);
            var type_ = (GISharp.Lib.GObject.GType)type;
            var ret_ = g_type_class_ref(type_);
            ref readonly var ret = ref System.Runtime.CompilerServices.Unsafe.AsRef<GISharp.Lib.GObject.TypeClass>(ret_);
            return ref ret;
        }

        /// <summary>
        /// Registers a private structure for an instantiatable type.
        /// </summary>
        /// <remarks>
        /// When an object is allocated, the private structures for
        /// the type and all of its parent types are allocated
        /// sequentially in the same memory block as the public
        /// structures, and are zero-filled.
        /// 
        /// Note that the accumulated size of the private structures of
        /// a type and all its parent types cannot exceed 64 KiB.
        /// 
        /// This function should be called in the type's class_init() function.
        /// The private structure can be retrieved using the
        /// G_TYPE_INSTANCE_GET_PRIVATE() macro.
        /// 
        /// The following example shows attaching a private structure
        /// MyObjectPrivate to an object MyObject defined in the standard
        /// GObject fashion in the type's class_init() function.
        /// 
        /// Note the use of a structure member "priv" to avoid the overhead
        /// of repeatedly calling MY_OBJECT_GET_PRIVATE().
        /// 
        /// |[&lt;!-- language="C" --&gt;
        /// typedef struct _MyObject        MyObject;
        /// typedef struct _MyObjectPrivate MyObjectPrivate;
        /// 
        /// struct _MyObject {
        ///  GObject parent;
        /// 
        ///  MyObjectPrivate *priv;
        /// };
        /// 
        /// struct _MyObjectPrivate {
        ///   int some_field;
        /// };
        /// 
        /// static void
        /// my_object_class_init (MyObjectClass *klass)
        /// {
        ///   g_type_class_add_private (klass, sizeof (MyObjectPrivate));
        /// }
        /// 
        /// static void
        /// my_object_init (MyObject *my_object)
        /// {
        ///   my_object-&gt;priv = G_TYPE_INSTANCE_GET_PRIVATE (my_object,
        ///                                                  MY_TYPE_OBJECT,
        ///                                                  MyObjectPrivate);
        ///   // my_object-&gt;priv-&gt;some_field will be automatically initialised to 0
        /// }
        /// 
        /// static int
        /// my_object_get_some_field (MyObject *my_object)
        /// {
        ///   MyObjectPrivate *priv;
        /// 
        ///   g_return_val_if_fail (MY_IS_OBJECT (my_object), 0);
        /// 
        ///   priv = my_object-&gt;priv;
        /// 
        ///   return priv-&gt;some_field;
        /// }
        /// ]|
        /// </remarks>
        /// <param name="gClass">
        /// class structure for an instantiatable
        ///    type
        /// </param>
        /// <param name="privateSize">
        /// size of private structure
        /// </param>
        [System.ObsoleteAttribute("Use the G_ADD_PRIVATE() macro with the `G_DEFINE_*`\n  family of macros to add instance private data to a type")]
        [GISharp.Runtime.DeprecatedSinceAttribute("2.58")]
        [GISharp.Runtime.SinceAttribute("2.4")]
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_type_class_add_private(
        /* <type name="TypeClass" type="gpointer" managed-name="TypeClass" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.TypeClass* gClass,
        /* <type name="gsize" type="gsize" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        nuint privateSize);
        partial void CheckAddPrivateArgs(int privateSize);

        /// <include file="TypeClass.xmldoc" path="declaration/member[@name='TypeClass.AddPrivate(int)']/*" />
        [System.ObsoleteAttribute("Use the G_ADD_PRIVATE() macro with the `G_DEFINE_*`\n  family of macros to add instance private data to a type")]
        [GISharp.Runtime.DeprecatedSinceAttribute("2.58")]
        [GISharp.Runtime.SinceAttribute("2.4")]
        public void AddPrivate(int privateSize)
        {
            fixed (GISharp.Lib.GObject.TypeClass* this_ = &this)
            {
                CheckAddPrivateArgs(privateSize);
                var gClass_ = this_;
                var privateSize_ = (nuint)privateSize;
                g_type_class_add_private(gClass_, privateSize_);
            }
        }

        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 direction:in */
        private static extern System.IntPtr g_type_class_get_private(
/* <type name="TypeClass" type="GTypeClass*" managed-name="TypeClass" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.GObject.TypeClass* klass,
/* <type name="GType" type="GType" managed-name="GISharp.Lib.GObject.GType" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.GObject.GType privateType);
        partial void CheckGetPrivateArgs(GISharp.Lib.GObject.GType privateType);

        /// <include file="TypeClass.xmldoc" path="declaration/member[@name='TypeClass.GetPrivate(GISharp.Lib.GObject.GType)']/*" />
        public System.IntPtr GetPrivate(GISharp.Lib.GObject.GType privateType)
        {
            fixed (GISharp.Lib.GObject.TypeClass* this_ = &this)
            {
                CheckGetPrivateArgs(privateType);
                var klass_ = this_;
                var privateType_ = (GISharp.Lib.GObject.GType)privateType;
                var ret_ = g_type_class_get_private(klass_,privateType_);
                var ret = (System.IntPtr)ret_;
                return ret;
            }
        }

        /// <summary>
        /// This is a convenience function often needed in class initializers.
        /// It returns the class structure of the immediate parent type of the
        /// class passed in.  Since derived classes hold a reference count on
        /// their parent classes as long as they are instantiated, the returned
        /// class will always exist.
        /// </summary>
        /// <remarks>
        /// This function is essentially equivalent to:
        /// g_type_class_peek (g_type_parent (G_TYPE_FROM_CLASS (g_class)))
        /// </remarks>
        /// <param name="gClass">
        /// the #GTypeClass structure to
        ///     retrieve the parent class for
        /// </param>
        /// <returns>
        /// the parent class
        ///     of @g_class
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="TypeClass" type="gpointer" managed-name="TypeClass" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GObject.TypeClass* g_type_class_peek_parent(
        /* <type name="TypeClass" type="gpointer" managed-name="TypeClass" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.TypeClass* gClass);
        partial void CheckPeekParentArgs();

        /// <include file="TypeClass.xmldoc" path="declaration/member[@name='TypeClass.PeekParent()']/*" />
        public ref readonly GISharp.Lib.GObject.TypeClass PeekParent()
        {
            fixed (GISharp.Lib.GObject.TypeClass* this_ = &this)
            {
                CheckPeekParentArgs();
                var gClass_ = this_;
                var ret_ = g_type_class_peek_parent(gClass_);
                ref readonly var ret = ref System.Runtime.CompilerServices.Unsafe.AsRef<GISharp.Lib.GObject.TypeClass>(ret_);
                return ref ret;
            }
        }

        /// <summary>
        /// Decrements the reference count of the class structure being passed in.
        /// Once the last reference count of a class has been released, classes
        /// may be finalized by the type system, so further dereferencing of a
        /// class pointer after g_type_class_unref() are invalid.
        /// </summary>
        /// <param name="gClass">
        /// a #GTypeClass structure to unref
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_type_class_unref(
        /* <type name="TypeClass" type="gpointer" managed-name="TypeClass" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.TypeClass* gClass);

        /// <inheritdoc/>
        protected override void Dispose(bool disposing)
        {
            if (handle != System.IntPtr.Zero)
            {
                g_type_class_unref((UnmanagedStruct*)handle);
            }

            base.Dispose(disposing);
        }
    }
}