// SPDX-License-Identifier: MIT
// ATTENTION: This file is automatically generated. Do not edit manually.
#nullable enable
namespace GISharp.Lib.GObject
{
    /// <include file="TypeClass.xmldoc" path="declaration/member[@name='TypeClass']/*" />
    public abstract unsafe partial class TypeClass : GISharp.Runtime.Opaque
    {
        /// <summary>
        /// The unmanaged data structure.
        /// </summary>
        public struct UnmanagedStruct
        {
#pragma warning disable CS0169, CS0414, CS0649
            /// <include file="TypeClass.xmldoc" path="declaration/member[@name='UnmanagedStruct.GType']/*" />
            internal readonly GISharp.Runtime.GType GType;
#pragma warning restore CS0169, CS0414, CS0649
        }

        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_type_class_adjust_private_offset(
       /* <type name="gpointer" type="gpointer" is-pointer="1" /> */
       /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
       System.IntPtr gClass,
       /* <type name="gint" type="gint*" is-pointer="1" /> */
       /* transfer-ownership:none direction:in */
       int* privateSizeOrOffset);
        static partial void CheckAdjustPrivateOffsetArgs(System.IntPtr gClass, ref int privateSizeOrOffset);

        /// <include file="TypeClass.xmldoc" path="declaration/member[@name='TypeClass.AdjustPrivateOffset(System.IntPtr,int)']/*" />
        public static void AdjustPrivateOffset(System.IntPtr gClass, ref int privateSizeOrOffset)
        {
            fixed (int* privateSizeOrOffset_ = &privateSizeOrOffset)
            {
                CheckAdjustPrivateOffsetArgs(gClass, ref privateSizeOrOffset);
                var gClass_ = (System.IntPtr)gClass;
                g_type_class_adjust_private_offset(gClass_, privateSizeOrOffset_);
                GISharp.Runtime.GMarshal.PopUnhandledException();
            }
        }

        /// <summary>
        /// This function is essentially the same as g_type_class_ref(),
        /// except that the classes reference count isn't incremented.
        /// As a consequence, this function may return %NULL if the class
        /// of the type passed in does not currently exist (hasn't been
        /// referenced before).
        /// </summary>
        /// <param name="type">
        /// type ID of a classed type
        /// </param>
        /// <returns>
        /// the #GTypeClass
        ///     structure for the given type ID or %NULL if the class does not
        ///     currently exist
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="TypeClass" type="gpointer" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private protected static extern GISharp.Lib.GObject.TypeClass.UnmanagedStruct* g_type_class_peek(
        /* <type name="GType" type="GType" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.GType type);

        /// <summary>
        /// A more efficient version of g_type_class_peek() which works only for
        /// static types.
        /// </summary>
        /// <param name="type">
        /// type ID of a classed type
        /// </param>
        /// <returns>
        /// the #GTypeClass
        ///     structure for the given type ID or %NULL if the class does not
        ///     currently exist or is dynamically loaded
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.4")]
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="TypeClass" type="gpointer" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private protected static extern GISharp.Lib.GObject.TypeClass.UnmanagedStruct* g_type_class_peek_static(
        /* <type name="GType" type="GType" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.GType type);

        /// <summary>
        /// Increments the reference count of the class structure belonging to
        /// @type. This function will demand-create the class if it doesn't
        /// exist already.
        /// </summary>
        /// <param name="type">
        /// type ID of a classed type
        /// </param>
        /// <returns>
        /// the #GTypeClass
        ///     structure for the given type ID
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="TypeClass" type="gpointer" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        internal static extern GISharp.Lib.GObject.TypeClass.UnmanagedStruct* g_type_class_ref(
        /* <type name="GType" type="GType" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.GType type);
        static partial void CheckRefArgs(GISharp.Runtime.GType type);

        /// <include file="TypeClass.xmldoc" path="declaration/member[@name='TypeClass.Ref(GISharp.Runtime.GType)']/*" />
        public static GISharp.Lib.GObject.TypeClass Ref(GISharp.Runtime.GType type)
        {
            CheckRefArgs(type);
            var type_ = (GISharp.Runtime.GType)type;
            var ret_ = g_type_class_ref(type_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Lib.GObject.TypeClass.GetInstance<GISharp.Lib.GObject.TypeClass>((System.IntPtr)ret_, GISharp.Runtime.Transfer.None)!;
            return ret;
        }

        /// <summary>
        /// Registers a private structure for an instantiatable type.
        /// </summary>
        /// <remarks>
        /// <para>
        /// When an object is allocated, the private structures for
        /// the type and all of its parent types are allocated
        /// sequentially in the same memory block as the public
        /// structures, and are zero-filled.
        /// </para>
        /// <para>
        /// Note that the accumulated size of the private structures of
        /// a type and all its parent types cannot exceed 64 KiB.
        /// </para>
        /// <para>
        /// This function should be called in the type's class_init() function.
        /// The private structure can be retrieved using the
        /// G_TYPE_INSTANCE_GET_PRIVATE() macro.
        /// </para>
        /// <para>
        /// The following example shows attaching a private structure
        /// MyObjectPrivate to an object MyObject defined in the standard
        /// GObject fashion in the type's class_init() function.
        /// </para>
        /// <para>
        /// Note the use of a structure member "priv" to avoid the overhead
        /// of repeatedly calling MY_OBJECT_GET_PRIVATE().
        /// </para>
        /// <para>
        /// |[&lt;!-- language="C" --&gt;
        /// typedef struct _MyObject        MyObject;
        /// typedef struct _MyObjectPrivate MyObjectPrivate;
        /// </para>
        /// <para>
        /// struct _MyObject {
        ///  GObject parent;
        /// </para>
        /// <para>
        ///  MyObjectPrivate *priv;
        /// };
        /// </para>
        /// <para>
        /// struct _MyObjectPrivate {
        ///   int some_field;
        /// };
        /// </para>
        /// <para>
        /// static void
        /// my_object_class_init (MyObjectClass *klass)
        /// {
        ///   g_type_class_add_private (klass, sizeof (MyObjectPrivate));
        /// }
        /// </para>
        /// <para>
        /// static void
        /// my_object_init (MyObject *my_object)
        /// {
        ///   my_object-&gt;priv = G_TYPE_INSTANCE_GET_PRIVATE (my_object,
        ///                                                  MY_TYPE_OBJECT,
        ///                                                  MyObjectPrivate);
        ///   // my_object-&gt;priv-&gt;some_field will be automatically initialised to 0
        /// }
        /// </para>
        /// <para>
        /// static int
        /// my_object_get_some_field (MyObject *my_object)
        /// {
        ///   MyObjectPrivate *priv;
        /// </para>
        /// <para>
        ///   g_return_val_if_fail (MY_IS_OBJECT (my_object), 0);
        /// </para>
        /// <para>
        ///   priv = my_object-&gt;priv;
        /// </para>
        /// <para>
        ///   return priv-&gt;some_field;
        /// }
        /// ]|
        /// </para>
        /// </remarks>
        /// <param name="gClass">
        /// class structure for an instantiatable
        ///    type
        /// </param>
        /// <param name="privateSize">
        /// size of private structure
        /// </param>
        [System.ObsoleteAttribute("Use the G_ADD_PRIVATE() macro with the `G_DEFINE_*`\n  family of macros to add instance private data to a type")]
        [GISharp.Runtime.DeprecatedSinceAttribute("2.58")]
        [GISharp.Runtime.SinceAttribute("2.4")]
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_type_class_add_private(
        /* <type name="TypeClass" type="gpointer" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.TypeClass.UnmanagedStruct* gClass,
        /* <type name="gsize" type="gsize" /> */
        /* transfer-ownership:none direction:in */
        nuint privateSize);
        partial void CheckAddPrivateArgs(int privateSize);

        /// <include file="TypeClass.xmldoc" path="declaration/member[@name='TypeClass.AddPrivate(int)']/*" />
        [System.ObsoleteAttribute("Use the G_ADD_PRIVATE() macro with the `G_DEFINE_*`\n  family of macros to add instance private data to a type")]
        [GISharp.Runtime.DeprecatedSinceAttribute("2.58")]
        [GISharp.Runtime.SinceAttribute("2.4")]
        public void AddPrivate(int privateSize)
        {
            CheckAddPrivateArgs(privateSize);
            var gClass_ = (GISharp.Lib.GObject.TypeClass.UnmanagedStruct*)UnsafeHandle;
            var privateSize_ = (nuint)privateSize;
            g_type_class_add_private(gClass_, privateSize_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
        }

        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gpointer" type="gpointer" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 direction:in */
        private static extern System.IntPtr g_type_class_get_private(
/* <type name="TypeClass" type="GTypeClass*" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.GObject.TypeClass.UnmanagedStruct* klass,
/* <type name="GType" type="GType" /> */
/* transfer-ownership:none direction:in */
GISharp.Runtime.GType privateType);
        partial void CheckGetPrivateArgs(GISharp.Runtime.GType privateType);

        /// <include file="TypeClass.xmldoc" path="declaration/member[@name='TypeClass.GetPrivate(GISharp.Runtime.GType)']/*" />
        public System.IntPtr GetPrivate(GISharp.Runtime.GType privateType)
        {
            CheckGetPrivateArgs(privateType);
            var klass_ = (GISharp.Lib.GObject.TypeClass.UnmanagedStruct*)UnsafeHandle;
            var privateType_ = (GISharp.Runtime.GType)privateType;
            var ret_ = g_type_class_get_private(klass_,privateType_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = (System.IntPtr)ret_;
            return ret;
        }

        /// <summary>
        /// This is a convenience function often needed in class initializers.
        /// It returns the class structure of the immediate parent type of the
        /// class passed in.  Since derived classes hold a reference count on
        /// their parent classes as long as they are instantiated, the returned
        /// class will always exist.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This function is essentially equivalent to:
        /// g_type_class_peek (g_type_parent (G_TYPE_FROM_CLASS (g_class)))
        /// </para>
        /// </remarks>
        /// <param name="gClass">
        /// the #GTypeClass structure to
        ///     retrieve the parent class for
        /// </param>
        /// <returns>
        /// the parent class
        ///     of @g_class
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="TypeClass" type="gpointer" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private protected static extern GISharp.Lib.GObject.TypeClass.UnmanagedStruct* g_type_class_peek_parent(
        /* <type name="TypeClass" type="gpointer" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.TypeClass.UnmanagedStruct* gClass);

        /// <summary>
        /// Decrements the reference count of the class structure being passed in.
        /// Once the last reference count of a class has been released, classes
        /// may be finalized by the type system, so further dereferencing of a
        /// class pointer after g_type_class_unref() are invalid.
        /// </summary>
        /// <param name="gClass">
        /// a #GTypeClass structure to unref
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" /> */
        /* transfer-ownership:none direction:in */
        internal static extern void g_type_class_unref(
        /* <type name="TypeClass" type="gpointer" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.TypeClass.UnmanagedStruct* gClass);

        /// <inheritdoc/>
        protected override void Dispose(bool disposing)
        {
            if (handle != System.IntPtr.Zero)
            {
                g_type_class_unref((UnmanagedStruct*)handle);
                GISharp.Runtime.GMarshal.PopUnhandledException();
            }

            base.Dispose(disposing);
        }
    }
}