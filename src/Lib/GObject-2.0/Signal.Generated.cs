// SPDX-License-Identifier: MIT
// ATTENTION: This file is automatically generated. Do not edit manually.
#nullable enable
namespace GISharp.Lib.GObject
{
    /// <include file="Signal.xmldoc" path="declaration/member[@name='Signal']/*" />
    public static unsafe partial class Signal
    {
        /// <summary>
        /// A predefined #GSignalAccumulator for signals intended to be used as a
        /// hook for application code to provide a particular value.  Usually
        /// only one such value is desired and multiple handlers for the same
        /// signal don't make much sense (except for the case of the default
        /// handler defined in the class structure, in which case you will
        /// usually want the signal connection to override the class handler).
        /// </summary>
        /// <remarks>
        /// <para>
        /// This accumulator will use the return value from the first signal
        /// handler that is run as the return value for the signal and not run
        /// any further handlers (ie: the first handler "wins").
        /// </para>
        /// </remarks>
        /// <param name="ihint">
        /// standard #GSignalAccumulator parameter
        /// </param>
        /// <param name="returnAccu">
        /// standard #GSignalAccumulator parameter
        /// </param>
        /// <param name="handlerReturn">
        /// standard #GSignalAccumulator parameter
        /// </param>
        /// <param name="dummy">
        /// standard #GSignalAccumulator parameter
        /// </param>
        /// <returns>
        /// standard #GSignalAccumulator result
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.28")]
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_signal_accumulator_first_wins(
        /* <type name="SignalInvocationHint" type="GSignalInvocationHint*" managed-name="SignalInvocationHint" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.SignalInvocationHint* ihint,
        /* <type name="Value" type="GValue*" managed-name="Value" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Value* returnAccu,
        /* <type name="Value" type="const GValue*" managed-name="Value" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Value* handlerReturn,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr dummy);

        /// <summary>
        /// A predefined #GSignalAccumulator for signals that return a
        /// boolean values. The behavior that this accumulator gives is
        /// that a return of %TRUE stops the signal emission: no further
        /// callbacks will be invoked, while a return of %FALSE allows
        /// the emission to continue. The idea here is that a %TRUE return
        /// indicates that the callback handled the signal, and no further
        /// handling is needed.
        /// </summary>
        /// <param name="ihint">
        /// standard #GSignalAccumulator parameter
        /// </param>
        /// <param name="returnAccu">
        /// standard #GSignalAccumulator parameter
        /// </param>
        /// <param name="handlerReturn">
        /// standard #GSignalAccumulator parameter
        /// </param>
        /// <param name="dummy">
        /// standard #GSignalAccumulator parameter
        /// </param>
        /// <returns>
        /// standard #GSignalAccumulator result
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.4")]
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_signal_accumulator_true_handled(
        /* <type name="SignalInvocationHint" type="GSignalInvocationHint*" managed-name="SignalInvocationHint" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.SignalInvocationHint* ihint,
        /* <type name="Value" type="GValue*" managed-name="Value" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Value* returnAccu,
        /* <type name="Value" type="const GValue*" managed-name="Value" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Value* handlerReturn,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr dummy);

        /// <summary>
        /// Adds an emission hook for a signal, which will get called for any emission
        /// of that signal, independent of the instance. This is possible only
        /// for signals which don't have #G_SIGNAL_NO_HOOKS flag set.
        /// </summary>
        /// <param name="signalId">
        /// the signal identifier, as returned by g_signal_lookup().
        /// </param>
        /// <param name="detail">
        /// the detail on which to call the hook.
        /// </param>
        /// <param name="hookFunc">
        /// a #GSignalEmissionHook function.
        /// </param>
        /// <param name="hookData">
        /// user data for @hook_func.
        /// </param>
        /// <param name="dataDestroy">
        /// a #GDestroyNotify for @hook_data.
        /// </param>
        /// <returns>
        /// the hook id, for later use with g_signal_remove_emission_hook().
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gulong" type="gulong" managed-name="GISharp.Runtime.CULong" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.CULong g_signal_add_emission_hook(
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        uint signalId,
        /* <type name="GLib.Quark" type="GQuark" managed-name="GISharp.Lib.GLib.Quark" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Quark detail,
        /* <type name="SignalEmissionHook" type="GSignalEmissionHook" managed-name="SignalEmissionHook" /> */
        /* transfer-ownership:none scope:notified closure:3 destroy:4 direction:in */
        delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.SignalInvocationHint*, uint, GISharp.Lib.GObject.Value*, System.IntPtr, GISharp.Runtime.Boolean> hookFunc,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr hookData,
        /* <type name="GLib.DestroyNotify" type="GDestroyNotify" managed-name="GISharp.Lib.GLib.DestroyNotify" /> */
        /* transfer-ownership:none scope:async direction:in */
        delegate* unmanaged[Cdecl]<System.IntPtr, void> dataDestroy);
        static partial void CheckAddEmissionHookArgs(uint signalId, GISharp.Lib.GLib.Quark detail, GISharp.Lib.GObject.SignalEmissionHook hookFunc);

        /// <include file="Signal.xmldoc" path="declaration/member[@name='Signal.AddEmissionHook(uint,GISharp.Lib.GLib.Quark,GISharp.Lib.GObject.SignalEmissionHook)']/*" />
        public static GISharp.Runtime.CULong AddEmissionHook(uint signalId, GISharp.Lib.GLib.Quark detail, GISharp.Lib.GObject.SignalEmissionHook hookFunc)
        {
            CheckAddEmissionHookArgs(signalId, detail, hookFunc);
            var signalId_ = (uint)signalId;
            var detail_ = (GISharp.Lib.GLib.Quark)detail;
            var hookFunc_ = (delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.SignalInvocationHint*, uint, GISharp.Lib.GObject.Value*, System.IntPtr, GISharp.Runtime.Boolean>)&GISharp.Lib.GObject.SignalEmissionHookMarshal.Callback;
            var hookFuncHandle = System.Runtime.InteropServices.GCHandle.Alloc((hookFunc, GISharp.Runtime.CallbackScope.Notified));
            var hookData_ = (System.IntPtr)hookFuncHandle;
            var dataDestroy_ = (delegate* unmanaged[Cdecl]<System.IntPtr, void>)&GISharp.Runtime.GMarshal.DestroyGCHandle;
            var ret_ = g_signal_add_emission_hook(signalId_,detail_,hookFunc_,hookData_,dataDestroy_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = (GISharp.Runtime.CULong)ret_;
            return ret;
        }

        /// <summary>
        /// Calls the original class closure of a signal. This function should only
        /// be called from an overridden class closure; see
        /// g_signal_override_class_closure() and
        /// g_signal_override_class_handler().
        /// </summary>
        /// <param name="instanceAndParams">
        /// the argument list of the signal emission.
        ///  The first element in the array is a #GValue for the instance the signal
        ///  is being emitted on. The rest are any arguments to be passed to the signal.
        /// </param>
        /// <param name="returnValue">
        /// Location for the return value.
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_signal_chain_from_overridden(
        /* <array zero-terminated="1" type="const GValue*" managed-name="GISharp.Runtime.CArray" is-pointer="1">
*   <type name="Value" type="GValue" managed-name="Value" />
* </array> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Value* instanceAndParams,
        /* <type name="Value" type="GValue*" managed-name="Value" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Value* returnValue);
        static partial void CheckChainFromOverriddenArgs(System.ReadOnlySpan<GISharp.Lib.GObject.Value> instanceAndParams, ref GISharp.Lib.GObject.Value returnValue);

        /// <include file="Signal.xmldoc" path="declaration/member[@name='Signal.ChainFromOverridden(System.ReadOnlySpan&lt;GISharp.Lib.GObject.Value&gt;,GISharp.Lib.GObject.Value)']/*" />
        public static void ChainFromOverridden(System.ReadOnlySpan<GISharp.Lib.GObject.Value> instanceAndParams, ref GISharp.Lib.GObject.Value returnValue)
        {
            fixed (GISharp.Lib.GObject.Value* returnValue_ = &returnValue)
            {
                fixed (GISharp.Lib.GObject.Value* instanceAndParamsData_ = instanceAndParams)
                {
                    CheckChainFromOverriddenArgs(instanceAndParams, ref returnValue);
                    var instanceAndParams_ = (GISharp.Lib.GObject.Value*)instanceAndParamsData_;
                    g_signal_chain_from_overridden(instanceAndParams_, returnValue_);
                    GISharp.Runtime.GMarshal.PopUnhandledException();
                }
            }
        }

        /// <summary>
        /// Connects a closure to a signal for a particular object.
        /// </summary>
        /// <param name="instance">
        /// the instance to connect to.
        /// </param>
        /// <param name="detailedSignal">
        /// a string of the form "signal-name::detail".
        /// </param>
        /// <param name="closure">
        /// the closure to connect.
        /// </param>
        /// <param name="after">
        /// whether the handler should be called before or after the
        ///  default handler of the signal.
        /// </param>
        /// <returns>
        /// the handler ID (always greater than 0 for successful connections)
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gulong" type="gulong" managed-name="GISharp.Runtime.CULong" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.CULong g_signal_connect_closure(
        /* <type name="Object" type="gpointer" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* instance,
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* detailedSignal,
        /* <type name="Closure" type="GClosure*" managed-name="Closure" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Closure.UnmanagedStruct* closure,
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.Boolean after);
        static partial void CheckConnectArgs(GISharp.Lib.GObject.Object instance, GISharp.Lib.GLib.UnownedUtf8 detailedSignal, GISharp.Lib.GObject.Closure closure, bool after = false);

        /// <include file="Signal.xmldoc" path="declaration/member[@name='Signal.Connect(GISharp.Lib.GObject.Object,GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.GObject.Closure,bool)']/*" />
        public static GISharp.Runtime.CULong Connect(GISharp.Lib.GObject.Object instance, GISharp.Lib.GLib.UnownedUtf8 detailedSignal, GISharp.Lib.GObject.Closure closure, bool after = false)
        {
            CheckConnectArgs(instance, detailedSignal, closure, after);
            var instance_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)instance.UnsafeHandle;
            var detailedSignal_ = (byte*)detailedSignal.UnsafeHandle;
            var closure_ = (GISharp.Lib.GObject.Closure.UnmanagedStruct*)closure.UnsafeHandle;
            var after_ = GISharp.Runtime.BooleanExtensions.ToBoolean(after);
            var ret_ = g_signal_connect_closure(instance_,detailedSignal_,closure_,after_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = (GISharp.Runtime.CULong)ret_;
            return ret;
        }

        /// <summary>
        /// Connects a closure to a signal for a particular object.
        /// </summary>
        /// <param name="instance">
        /// the instance to connect to.
        /// </param>
        /// <param name="signalId">
        /// the id of the signal.
        /// </param>
        /// <param name="detail">
        /// the detail.
        /// </param>
        /// <param name="closure">
        /// the closure to connect.
        /// </param>
        /// <param name="after">
        /// whether the handler should be called before or after the
        ///  default handler of the signal.
        /// </param>
        /// <returns>
        /// the handler ID (always greater than 0 for successful connections)
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gulong" type="gulong" managed-name="GISharp.Runtime.CULong" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.CULong g_signal_connect_closure_by_id(
        /* <type name="Object" type="gpointer" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* instance,
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        uint signalId,
        /* <type name="GLib.Quark" type="GQuark" managed-name="GISharp.Lib.GLib.Quark" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Quark detail,
        /* <type name="Closure" type="GClosure*" managed-name="Closure" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Closure.UnmanagedStruct* closure,
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.Boolean after);
        static partial void CheckConnectArgs(GISharp.Lib.GObject.Object instance, uint signalId, GISharp.Lib.GLib.Quark detail, GISharp.Lib.GObject.Closure closure, bool after = false);

        /// <include file="Signal.xmldoc" path="declaration/member[@name='Signal.Connect(GISharp.Lib.GObject.Object,uint,GISharp.Lib.GLib.Quark,GISharp.Lib.GObject.Closure,bool)']/*" />
        public static GISharp.Runtime.CULong Connect(GISharp.Lib.GObject.Object instance, uint signalId, GISharp.Lib.GLib.Quark detail, GISharp.Lib.GObject.Closure closure, bool after = false)
        {
            CheckConnectArgs(instance, signalId, detail, closure, after);
            var instance_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)instance.UnsafeHandle;
            var signalId_ = (uint)signalId;
            var detail_ = (GISharp.Lib.GLib.Quark)detail;
            var closure_ = (GISharp.Lib.GObject.Closure.UnmanagedStruct*)closure.UnsafeHandle;
            var after_ = GISharp.Runtime.BooleanExtensions.ToBoolean(after);
            var ret_ = g_signal_connect_closure_by_id(instance_,signalId_,detail_,closure_,after_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = (GISharp.Runtime.CULong)ret_;
            return ret;
        }

        /// <summary>
        /// Connects a #GCallback function to a signal for a particular object. Similar
        /// to g_signal_connect(), but allows to provide a #GClosureNotify for the data
        /// which will be called when the signal handler is disconnected and no longer
        /// used. Specify @connect_flags if you need `..._after()` or
        /// `..._swapped()` variants of this function.
        /// </summary>
        /// <param name="instance">
        /// the instance to connect to.
        /// </param>
        /// <param name="detailedSignal">
        /// a string of the form "signal-name::detail".
        /// </param>
        /// <param name="cHandler">
        /// the #GCallback to connect.
        /// </param>
        /// <param name="data">
        /// data to pass to @c_handler calls.
        /// </param>
        /// <param name="destroyData">
        /// a #GClosureNotify for @data.
        /// </param>
        /// <param name="connectFlags">
        /// a combination of #GConnectFlags.
        /// </param>
        /// <returns>
        /// the handler ID (always greater than 0 for successful connections)
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gulong" type="gulong" managed-name="GISharp.Runtime.CULong" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.CULong g_signal_connect_data(
        /* <type name="Object" type="gpointer" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* instance,
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* detailedSignal,
        /* <type name="Callback" type="GCallback" managed-name="Callback" /> */
        /* transfer-ownership:none closure:3 direction:in */
        delegate* unmanaged[Cdecl]<void> cHandler,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr data,
        /* <type name="ClosureNotify" type="GClosureNotify" managed-name="ClosureNotify" /> */
        /* transfer-ownership:none direction:in */
        delegate* unmanaged[Cdecl]<System.IntPtr, GISharp.Lib.GObject.Closure.UnmanagedStruct*, void> destroyData,
        /* <type name="ConnectFlags" type="GConnectFlags" managed-name="ConnectFlags" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.ConnectFlags connectFlags);

        /// <summary>
        /// Emits a signal.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Note that g_signal_emitv() doesn't change @return_value if no handlers are
        /// connected, in contrast to g_signal_emit() and g_signal_emit_valist().
        /// </para>
        /// </remarks>
        /// <param name="instanceAndParams">
        /// argument list for the signal emission.
        ///  The first element in the array is a #GValue for the instance the signal
        ///  is being emitted on. The rest are any arguments to be passed to the signal.
        /// </param>
        /// <param name="signalId">
        /// the signal id
        /// </param>
        /// <param name="detail">
        /// the detail
        /// </param>
        /// <param name="returnValue">
        /// Location to
        /// store the return value of the signal emission. This must be provided if the
        /// specified signal returns a value, but may be ignored otherwise.
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_signal_emitv(
        /* <array zero-terminated="1" type="const GValue*" managed-name="GISharp.Runtime.CArray" is-pointer="1">
*   <type name="Value" type="GValue" managed-name="Value" />
* </array> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Value* instanceAndParams,
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        uint signalId,
        /* <type name="GLib.Quark" type="GQuark" managed-name="GISharp.Lib.GLib.Quark" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Quark detail,
        /* <type name="Value" type="GValue*" managed-name="Value" /> */
        /* direction:inout caller-allocates:0 transfer-ownership:full optional:1 */
        GISharp.Lib.GObject.Value* returnValue);
        static partial void CheckEmitvArgs(System.ReadOnlySpan<GISharp.Lib.GObject.Value> instanceAndParams, uint signalId, GISharp.Lib.GLib.Quark detail, ref GISharp.Lib.GObject.Value returnValue);

        /// <include file="Signal.xmldoc" path="declaration/member[@name='Signal.Emitv(System.ReadOnlySpan&lt;GISharp.Lib.GObject.Value&gt;,uint,GISharp.Lib.GLib.Quark,GISharp.Lib.GObject.Value)']/*" />
        public static void Emitv(System.ReadOnlySpan<GISharp.Lib.GObject.Value> instanceAndParams, uint signalId, GISharp.Lib.GLib.Quark detail, ref GISharp.Lib.GObject.Value returnValue)
        {
            fixed (GISharp.Lib.GObject.Value* returnValue_ = &returnValue)
            {
                fixed (GISharp.Lib.GObject.Value* instanceAndParamsData_ = instanceAndParams)
                {
                    CheckEmitvArgs(instanceAndParams, signalId, detail, ref returnValue);
                    var instanceAndParams_ = (GISharp.Lib.GObject.Value*)instanceAndParamsData_;
                    var signalId_ = (uint)signalId;
                    var detail_ = (GISharp.Lib.GLib.Quark)detail;
                    g_signal_emitv(instanceAndParams_, signalId_, detail_, returnValue_);
                    GISharp.Runtime.GMarshal.PopUnhandledException();
                }
            }
        }

        /// <summary>
        /// Returns the invocation hint of the innermost signal emission of instance.
        /// </summary>
        /// <param name="instance">
        /// the instance to query
        /// </param>
        /// <returns>
        /// the invocation hint of the innermost signal  emission.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="SignalInvocationHint" type="GSignalInvocationHint*" managed-name="SignalInvocationHint" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GObject.SignalInvocationHint* g_signal_get_invocation_hint(
        /* <type name="Object" type="gpointer" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* instance);
        static partial void CheckGetInvocationHintArgs(GISharp.Lib.GObject.Object instance);

        /// <include file="Signal.xmldoc" path="declaration/member[@name='Signal.GetInvocationHint(GISharp.Lib.GObject.Object)']/*" />
        public static ref readonly GISharp.Lib.GObject.SignalInvocationHint GetInvocationHint(GISharp.Lib.GObject.Object instance)
        {
            CheckGetInvocationHintArgs(instance);
            var instance_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)instance.UnsafeHandle;
            var ret_ = g_signal_get_invocation_hint(instance_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            ref var ret = ref System.Runtime.CompilerServices.Unsafe.AsRef<GISharp.Lib.GObject.SignalInvocationHint>(ret_);
            return ref ret;
        }

        /// <summary>
        /// Blocks a handler of an instance so it will not be called during any
        /// signal emissions unless it is unblocked again. Thus "blocking" a
        /// signal handler means to temporarily deactivate it, a signal handler
        /// has to be unblocked exactly the same amount of times it has been
        /// blocked before to become active again.
        /// </summary>
        /// <remarks>
        /// <para>
        /// The @handler_id has to be a valid signal handler id, connected to a
        /// signal of @instance.
        /// </para>
        /// </remarks>
        /// <param name="instance">
        /// The instance to block the signal handler of.
        /// </param>
        /// <param name="handlerId">
        /// Handler id of the handler to be blocked.
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_signal_handler_block(
        /* <type name="Object" type="gpointer" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* instance,
        /* <type name="gulong" type="gulong" managed-name="GISharp.Runtime.CULong" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.CULong handlerId);
        static partial void CheckHandlerBlockArgs(GISharp.Lib.GObject.Object instance, GISharp.Runtime.CULong handlerId);

        /// <include file="Signal.xmldoc" path="declaration/member[@name='Signal.HandlerBlock(GISharp.Lib.GObject.Object,GISharp.Runtime.CULong)']/*" />
        public static void HandlerBlock(GISharp.Lib.GObject.Object instance, GISharp.Runtime.CULong handlerId)
        {
            CheckHandlerBlockArgs(instance, handlerId);
            var instance_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)instance.UnsafeHandle;
            var handlerId_ = (GISharp.Runtime.CULong)handlerId;
            g_signal_handler_block(instance_, handlerId_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
        }

        /// <summary>
        /// Disconnects a handler from an instance so it will not be called during
        /// any future or currently ongoing emissions of the signal it has been
        /// connected to. The @handler_id becomes invalid and may be reused.
        /// </summary>
        /// <remarks>
        /// <para>
        /// The @handler_id has to be a valid signal handler id, connected to a
        /// signal of @instance.
        /// </para>
        /// </remarks>
        /// <param name="instance">
        /// The instance to remove the signal handler from.
        /// </param>
        /// <param name="handlerId">
        /// Handler id of the handler to be disconnected.
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_signal_handler_disconnect(
        /* <type name="Object" type="gpointer" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* instance,
        /* <type name="gulong" type="gulong" managed-name="GISharp.Runtime.CULong" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.CULong handlerId);
        static partial void CheckHandlerDisconnectArgs(GISharp.Lib.GObject.Object instance, GISharp.Runtime.CULong handlerId);

        /// <include file="Signal.xmldoc" path="declaration/member[@name='Signal.HandlerDisconnect(GISharp.Lib.GObject.Object,GISharp.Runtime.CULong)']/*" />
        public static void HandlerDisconnect(GISharp.Lib.GObject.Object instance, GISharp.Runtime.CULong handlerId)
        {
            CheckHandlerDisconnectArgs(instance, handlerId);
            var instance_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)instance.UnsafeHandle;
            var handlerId_ = (GISharp.Runtime.CULong)handlerId;
            g_signal_handler_disconnect(instance_, handlerId_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
        }

        /// <summary>
        /// Finds the first signal handler that matches certain selection criteria.
        /// The criteria mask is passed as an OR-ed combination of #GSignalMatchType
        /// flags, and the criteria values are passed as arguments.
        /// The match @mask has to be non-0 for successful matches.
        /// If no handler was found, 0 is returned.
        /// </summary>
        /// <param name="instance">
        /// The instance owning the signal handler to be found.
        /// </param>
        /// <param name="mask">
        /// Mask indicating which of @signal_id, @detail, @closure, @func
        ///  and/or @data the handler has to match.
        /// </param>
        /// <param name="signalId">
        /// Signal the handler has to be connected to.
        /// </param>
        /// <param name="detail">
        /// Signal detail the handler has to be connected to.
        /// </param>
        /// <param name="closure">
        /// The closure the handler will invoke.
        /// </param>
        /// <param name="func">
        /// The C closure callback of the handler (useless for non-C closures).
        /// </param>
        /// <param name="data">
        /// The closure data of the handler's closure.
        /// </param>
        /// <returns>
        /// A valid non-0 signal handler id for a successful match.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gulong" type="gulong" managed-name="GISharp.Runtime.CULong" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.CULong g_signal_handler_find(
        /* <type name="Object" type="gpointer" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* instance,
        /* <type name="SignalMatchType" type="GSignalMatchType" managed-name="SignalMatchType" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.SignalMatchType mask,
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        uint signalId,
        /* <type name="GLib.Quark" type="GQuark" managed-name="GISharp.Lib.GLib.Quark" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Quark detail,
        /* <type name="Closure" type="GClosure*" managed-name="Closure" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.GObject.Closure.UnmanagedStruct* closure,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr func,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr data);

        /// <summary>
        /// Returns whether @handler_id is the ID of a handler connected to @instance.
        /// </summary>
        /// <param name="instance">
        /// The instance where a signal handler is sought.
        /// </param>
        /// <param name="handlerId">
        /// the handler ID.
        /// </param>
        /// <returns>
        /// whether @handler_id identifies a handler connected to @instance.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_signal_handler_is_connected(
        /* <type name="Object" type="gpointer" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* instance,
        /* <type name="gulong" type="gulong" managed-name="GISharp.Runtime.CULong" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.CULong handlerId);
        static partial void CheckHandlerIsConnectedArgs(GISharp.Lib.GObject.Object instance, GISharp.Runtime.CULong handlerId);

        /// <include file="Signal.xmldoc" path="declaration/member[@name='Signal.HandlerIsConnected(GISharp.Lib.GObject.Object,GISharp.Runtime.CULong)']/*" />
        public static bool HandlerIsConnected(GISharp.Lib.GObject.Object instance, GISharp.Runtime.CULong handlerId)
        {
            CheckHandlerIsConnectedArgs(instance, handlerId);
            var instance_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)instance.UnsafeHandle;
            var handlerId_ = (GISharp.Runtime.CULong)handlerId;
            var ret_ = g_signal_handler_is_connected(instance_,handlerId_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Undoes the effect of a previous g_signal_handler_block() call.  A
        /// blocked handler is skipped during signal emissions and will not be
        /// invoked, unblocking it (for exactly the amount of times it has been
        /// blocked before) reverts its "blocked" state, so the handler will be
        /// recognized by the signal system and is called upon future or
        /// currently ongoing signal emissions (since the order in which
        /// handlers are called during signal emissions is deterministic,
        /// whether the unblocked handler in question is called as part of a
        /// currently ongoing emission depends on how far that emission has
        /// proceeded yet).
        /// </summary>
        /// <remarks>
        /// <para>
        /// The @handler_id has to be a valid id of a signal handler that is
        /// connected to a signal of @instance and is currently blocked.
        /// </para>
        /// </remarks>
        /// <param name="instance">
        /// The instance to unblock the signal handler of.
        /// </param>
        /// <param name="handlerId">
        /// Handler id of the handler to be unblocked.
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_signal_handler_unblock(
        /* <type name="Object" type="gpointer" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* instance,
        /* <type name="gulong" type="gulong" managed-name="GISharp.Runtime.CULong" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.CULong handlerId);
        static partial void CheckHandlerUnblockArgs(GISharp.Lib.GObject.Object instance, GISharp.Runtime.CULong handlerId);

        /// <include file="Signal.xmldoc" path="declaration/member[@name='Signal.HandlerUnblock(GISharp.Lib.GObject.Object,GISharp.Runtime.CULong)']/*" />
        public static void HandlerUnblock(GISharp.Lib.GObject.Object instance, GISharp.Runtime.CULong handlerId)
        {
            CheckHandlerUnblockArgs(instance, handlerId);
            var instance_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)instance.UnsafeHandle;
            var handlerId_ = (GISharp.Runtime.CULong)handlerId;
            g_signal_handler_unblock(instance_, handlerId_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
        }

        /// <summary>
        /// Blocks all handlers on an instance that match a certain selection criteria.
        /// The criteria mask is passed as an OR-ed combination of #GSignalMatchType
        /// flags, and the criteria values are passed as arguments.
        /// Passing at least one of the %G_SIGNAL_MATCH_CLOSURE, %G_SIGNAL_MATCH_FUNC
        /// or %G_SIGNAL_MATCH_DATA match flags is required for successful matches.
        /// If no handlers were found, 0 is returned, the number of blocked handlers
        /// otherwise.
        /// </summary>
        /// <param name="instance">
        /// The instance to block handlers from.
        /// </param>
        /// <param name="mask">
        /// Mask indicating which of @signal_id, @detail, @closure, @func
        ///  and/or @data the handlers have to match.
        /// </param>
        /// <param name="signalId">
        /// Signal the handlers have to be connected to.
        /// </param>
        /// <param name="detail">
        /// Signal detail the handlers have to be connected to.
        /// </param>
        /// <param name="closure">
        /// The closure the handlers will invoke.
        /// </param>
        /// <param name="func">
        /// The C closure callback of the handlers (useless for non-C closures).
        /// </param>
        /// <param name="data">
        /// The closure data of the handlers' closures.
        /// </param>
        /// <returns>
        /// The number of handlers that matched.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        private static extern uint g_signal_handlers_block_matched(
        /* <type name="Object" type="gpointer" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* instance,
        /* <type name="SignalMatchType" type="GSignalMatchType" managed-name="SignalMatchType" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.SignalMatchType mask,
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        uint signalId,
        /* <type name="GLib.Quark" type="GQuark" managed-name="GISharp.Lib.GLib.Quark" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Quark detail,
        /* <type name="Closure" type="GClosure*" managed-name="Closure" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.GObject.Closure.UnmanagedStruct* closure,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr func,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr data);

        /// <summary>
        /// Destroy all signal handlers of a type instance. This function is
        /// an implementation detail of the #GObject dispose implementation,
        /// and should not be used outside of the type system.
        /// </summary>
        /// <param name="instance">
        /// The instance whose signal handlers are destroyed
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_signal_handlers_destroy(
        /* <type name="Object" type="gpointer" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* instance);

        /// <summary>
        /// Disconnects all handlers on an instance that match a certain
        /// selection criteria. The criteria mask is passed as an OR-ed
        /// combination of #GSignalMatchType flags, and the criteria values are
        /// passed as arguments.  Passing at least one of the
        /// %G_SIGNAL_MATCH_CLOSURE, %G_SIGNAL_MATCH_FUNC or
        /// %G_SIGNAL_MATCH_DATA match flags is required for successful
        /// matches.  If no handlers were found, 0 is returned, the number of
        /// disconnected handlers otherwise.
        /// </summary>
        /// <param name="instance">
        /// The instance to remove handlers from.
        /// </param>
        /// <param name="mask">
        /// Mask indicating which of @signal_id, @detail, @closure, @func
        ///  and/or @data the handlers have to match.
        /// </param>
        /// <param name="signalId">
        /// Signal the handlers have to be connected to.
        /// </param>
        /// <param name="detail">
        /// Signal detail the handlers have to be connected to.
        /// </param>
        /// <param name="closure">
        /// The closure the handlers will invoke.
        /// </param>
        /// <param name="func">
        /// The C closure callback of the handlers (useless for non-C closures).
        /// </param>
        /// <param name="data">
        /// The closure data of the handlers' closures.
        /// </param>
        /// <returns>
        /// The number of handlers that matched.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        private static extern uint g_signal_handlers_disconnect_matched(
        /* <type name="Object" type="gpointer" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* instance,
        /* <type name="SignalMatchType" type="GSignalMatchType" managed-name="SignalMatchType" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.SignalMatchType mask,
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        uint signalId,
        /* <type name="GLib.Quark" type="GQuark" managed-name="GISharp.Lib.GLib.Quark" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Quark detail,
        /* <type name="Closure" type="GClosure*" managed-name="Closure" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.GObject.Closure.UnmanagedStruct* closure,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr func,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr data);

        /// <summary>
        /// Unblocks all handlers on an instance that match a certain selection
        /// criteria. The criteria mask is passed as an OR-ed combination of
        /// #GSignalMatchType flags, and the criteria values are passed as arguments.
        /// Passing at least one of the %G_SIGNAL_MATCH_CLOSURE, %G_SIGNAL_MATCH_FUNC
        /// or %G_SIGNAL_MATCH_DATA match flags is required for successful matches.
        /// If no handlers were found, 0 is returned, the number of unblocked handlers
        /// otherwise. The match criteria should not apply to any handlers that are
        /// not currently blocked.
        /// </summary>
        /// <param name="instance">
        /// The instance to unblock handlers from.
        /// </param>
        /// <param name="mask">
        /// Mask indicating which of @signal_id, @detail, @closure, @func
        ///  and/or @data the handlers have to match.
        /// </param>
        /// <param name="signalId">
        /// Signal the handlers have to be connected to.
        /// </param>
        /// <param name="detail">
        /// Signal detail the handlers have to be connected to.
        /// </param>
        /// <param name="closure">
        /// The closure the handlers will invoke.
        /// </param>
        /// <param name="func">
        /// The C closure callback of the handlers (useless for non-C closures).
        /// </param>
        /// <param name="data">
        /// The closure data of the handlers' closures.
        /// </param>
        /// <returns>
        /// The number of handlers that matched.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        private static extern uint g_signal_handlers_unblock_matched(
        /* <type name="Object" type="gpointer" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* instance,
        /* <type name="SignalMatchType" type="GSignalMatchType" managed-name="SignalMatchType" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.SignalMatchType mask,
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        uint signalId,
        /* <type name="GLib.Quark" type="GQuark" managed-name="GISharp.Lib.GLib.Quark" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Quark detail,
        /* <type name="Closure" type="GClosure*" managed-name="Closure" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.GObject.Closure.UnmanagedStruct* closure,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr func,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr data);

        /// <summary>
        /// Returns whether there are any handlers connected to @instance for the
        /// given signal id and detail.
        /// </summary>
        /// <remarks>
        /// <para>
        /// If @detail is 0 then it will only match handlers that were connected
        /// without detail.  If @detail is non-zero then it will match handlers
        /// connected both without detail and with the given detail.  This is
        /// consistent with how a signal emitted with @detail would be delivered
        /// to those handlers.
        /// </para>
        /// <para>
        /// Since 2.46 this also checks for a non-default class closure being
        /// installed, as this is basically always what you want.
        /// </para>
        /// <para>
        /// One example of when you might use this is when the arguments to the
        /// signal are difficult to compute. A class implementor may opt to not
        /// emit the signal if no one is attached anyway, thus saving the cost
        /// of building the arguments.
        /// </para>
        /// </remarks>
        /// <param name="instance">
        /// the object whose signal handlers are sought.
        /// </param>
        /// <param name="signalId">
        /// the signal id.
        /// </param>
        /// <param name="detail">
        /// the detail.
        /// </param>
        /// <param name="mayBeBlocked">
        /// whether blocked handlers should count as match.
        /// </param>
        /// <returns>
        /// %TRUE if a handler is connected to the signal, %FALSE
        ///          otherwise.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_signal_has_handler_pending(
        /* <type name="Object" type="gpointer" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* instance,
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        uint signalId,
        /* <type name="GLib.Quark" type="GQuark" managed-name="GISharp.Lib.GLib.Quark" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Quark detail,
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.Boolean mayBeBlocked);
        static partial void CheckHasHandlerPendingArgs(GISharp.Lib.GObject.Object instance, uint signalId, GISharp.Lib.GLib.Quark detail = default, bool mayBeBlocked = false);

        /// <include file="Signal.xmldoc" path="declaration/member[@name='Signal.HasHandlerPending(GISharp.Lib.GObject.Object,uint,GISharp.Lib.GLib.Quark,bool)']/*" />
        public static bool HasHandlerPending(GISharp.Lib.GObject.Object instance, uint signalId, GISharp.Lib.GLib.Quark detail = default, bool mayBeBlocked = false)
        {
            CheckHasHandlerPendingArgs(instance, signalId, detail, mayBeBlocked);
            var instance_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)instance.UnsafeHandle;
            var signalId_ = (uint)signalId;
            var detail_ = (GISharp.Lib.GLib.Quark)detail;
            var mayBeBlocked_ = GISharp.Runtime.BooleanExtensions.ToBoolean(mayBeBlocked);
            var ret_ = g_signal_has_handler_pending(instance_,signalId_,detail_,mayBeBlocked_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Validate a signal name. This can be useful for dynamically-generated signals
        /// which need to be validated at run-time before actually trying to create them.
        /// </summary>
        /// <remarks>
        /// <para>
        /// See [canonical parameter names][canonical-parameter-names] for details of
        /// the rules for valid names. The rules for signal names are the same as those
        /// for property names.
        /// </para>
        /// </remarks>
        /// <param name="name">
        /// the canonical name of the signal
        /// </param>
        /// <returns>
        /// %TRUE if @name is a valid signal name, %FALSE otherwise.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.66")]
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_signal_is_valid_name(
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* name);
        static partial void CheckIsValidNameArgs(GISharp.Lib.GLib.UnownedUtf8 name);

        /// <include file="Signal.xmldoc" path="declaration/member[@name='Signal.IsValidName(GISharp.Lib.GLib.UnownedUtf8)']/*" />
        [GISharp.Runtime.SinceAttribute("2.66")]
        public static bool IsValidName(GISharp.Lib.GLib.UnownedUtf8 name)
        {
            CheckIsValidNameArgs(name);
            var name_ = (byte*)name.UnsafeHandle;
            var ret_ = g_signal_is_valid_name(name_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Lists the signals by id that a certain instance or interface type
        /// created. Further information about the signals can be acquired through
        /// g_signal_query().
        /// </summary>
        /// <param name="itype">
        /// Instance or interface type.
        /// </param>
        /// <param name="nIds">
        /// Location to store the number of signal ids for @itype.
        /// </param>
        /// <returns>
        /// Newly allocated array of signal IDs.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <array length="1" zero-terminated="0" type="guint*" managed-name="GISharp.Runtime.CArray" is-pointer="1">
*   <type name="guint" type="guint" managed-name="System.UInt32" />
* </array> */
        /* transfer-ownership:full direction:in */
        private static extern uint* g_signal_list_ids(
        /* <type name="GType" type="GType" managed-name="GISharp.Runtime.GType" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.GType itype,
        /* <type name="guint" type="guint*" managed-name="System.UInt32" /> */
        /* direction:out caller-allocates:0 transfer-ownership:full */
        uint* nIds);
        static partial void CheckListIdsArgs(GISharp.Runtime.GType itype);

        /// <include file="Signal.xmldoc" path="declaration/member[@name='Signal.ListIds(GISharp.Runtime.GType)']/*" />
        public static GISharp.Runtime.CArray<uint> ListIds(GISharp.Runtime.GType itype)
        {
            CheckListIdsArgs(itype);
            var itype_ = (GISharp.Runtime.GType)itype;
            uint nIds_;
            var ret_ = g_signal_list_ids(itype_,&nIds_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = new GISharp.Runtime.CArray<uint>((System.IntPtr)ret_, (int)nIds_, GISharp.Runtime.Transfer.Full);
            return ret;
        }

        /// <summary>
        /// Given the name of the signal and the type of object it connects to, gets
        /// the signal's identifying integer. Emitting the signal by number is
        /// somewhat faster than using the name each time.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Also tries the ancestors of the given type.
        /// </para>
        /// <para>
        /// The type class passed as @itype must already have been instantiated (for
        /// example, using g_type_class_ref()) for this function to work, as signals are
        /// always installed during class initialization.
        /// </para>
        /// <para>
        /// See g_signal_new() for details on allowed signal names.
        /// </para>
        /// </remarks>
        /// <param name="name">
        /// the signal's name.
        /// </param>
        /// <param name="itype">
        /// the type that the signal operates on.
        /// </param>
        /// <returns>
        /// the signal's identifying number, or 0 if no signal was found.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        private static extern uint g_signal_lookup(
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* name,
        /* <type name="GType" type="GType" managed-name="GISharp.Runtime.GType" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.GType itype);
        static partial void CheckLookupArgs(GISharp.Lib.GLib.UnownedUtf8 name, GISharp.Runtime.GType itype);

        /// <include file="Signal.xmldoc" path="declaration/member[@name='Signal.Lookup(GISharp.Lib.GLib.UnownedUtf8,GISharp.Runtime.GType)']/*" />
        public static uint Lookup(GISharp.Lib.GLib.UnownedUtf8 name, GISharp.Runtime.GType itype)
        {
            CheckLookupArgs(name, itype);
            var name_ = (byte*)name.UnsafeHandle;
            var itype_ = (GISharp.Runtime.GType)itype;
            var ret_ = g_signal_lookup(name_,itype_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = (uint)ret_;
            return ret;
        }

        /// <summary>
        /// Given the signal's identifier, finds its name.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Two different signals may have the same name, if they have differing types.
        /// </para>
        /// </remarks>
        /// <param name="signalId">
        /// the signal's identifying number.
        /// </param>
        /// <returns>
        /// the signal name, or %NULL if the signal number was invalid.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern byte* g_signal_name(
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        uint signalId);
        static partial void CheckNameArgs(uint signalId);

        /// <include file="Signal.xmldoc" path="declaration/member[@name='Signal.Name(uint)']/*" />
        public static GISharp.Lib.GLib.UnownedUtf8 Name(uint signalId)
        {
            CheckNameArgs(signalId);
            var signalId_ = (uint)signalId;
            var ret_ = g_signal_name(signalId_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = new GISharp.Lib.GLib.UnownedUtf8(ret_);
            return ret;
        }

        /// <summary>
        /// Creates a new signal. (This is usually done in the class initializer.)
        /// </summary>
        /// <remarks>
        /// <para>
        /// See g_signal_new() for details on allowed signal names.
        /// </para>
        /// <para>
        /// If c_marshaller is %NULL, g_cclosure_marshal_generic() will be used as
        /// the marshaller for this signal.
        /// </para>
        /// </remarks>
        /// <param name="signalName">
        /// the name for the signal
        /// </param>
        /// <param name="itype">
        /// the type this signal pertains to. It will also pertain to
        ///     types which are derived from this type
        /// </param>
        /// <param name="signalFlags">
        /// a combination of #GSignalFlags specifying detail of when
        ///     the default handler is to be invoked. You should at least specify
        ///     %G_SIGNAL_RUN_FIRST or %G_SIGNAL_RUN_LAST
        /// </param>
        /// <param name="classClosure">
        /// The closure to invoke on signal emission;
        ///     may be %NULL
        /// </param>
        /// <param name="accumulator">
        /// the accumulator for this signal; may be %NULL
        /// </param>
        /// <param name="accuData">
        /// user data for the @accumulator
        /// </param>
        /// <param name="cMarshaller">
        /// the function to translate arrays of
        ///     parameter values to signal emissions into C language callback
        ///     invocations or %NULL
        /// </param>
        /// <param name="returnType">
        /// the type of return value, or #G_TYPE_NONE for a signal
        ///     without a return value
        /// </param>
        /// <param name="nParams">
        /// the length of @param_types
        /// </param>
        /// <param name="paramTypes">
        /// an array of types, one for
        ///     each parameter
        /// </param>
        /// <returns>
        /// the signal id
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        private static extern uint g_signal_newv(
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* signalName,
        /* <type name="GType" type="GType" managed-name="GISharp.Runtime.GType" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.GType itype,
        /* <type name="SignalFlags" type="GSignalFlags" managed-name="SignalFlags" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.SignalFlags signalFlags,
        /* <type name="Closure" type="GClosure*" managed-name="Closure" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.GObject.Closure.UnmanagedStruct* classClosure,
        /* <type name="SignalAccumulator" type="GSignalAccumulator" managed-name="SignalAccumulator" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 closure:5 direction:in */
        delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.SignalInvocationHint*, GISharp.Lib.GObject.Value*, GISharp.Lib.GObject.Value*, System.IntPtr, GISharp.Runtime.Boolean> accumulator,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr accuData,
        /* <type name="SignalCMarshaller" type="GSignalCMarshaller" managed-name="SignalCMarshaller" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Closure.UnmanagedStruct*, GISharp.Lib.GObject.Value*, uint, GISharp.Lib.GObject.Value*, System.IntPtr, System.IntPtr, void> cMarshaller,
        /* <type name="GType" type="GType" managed-name="GISharp.Runtime.GType" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.GType returnType,
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        uint nParams,
        /* <array length="8" zero-terminated="0" type="GType*" managed-name="GISharp.Runtime.CArray" is-pointer="1">
*   <type name="GType" type="GType" managed-name="GISharp.Runtime.GType" />
* </array> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.GType* paramTypes);

        /// <summary>
        /// Overrides the class closure (i.e. the default handler) for the given signal
        /// for emissions on instances of @instance_type. @instance_type must be derived
        /// from the type to which the signal belongs.
        /// </summary>
        /// <remarks>
        /// <para>
        /// See g_signal_chain_from_overridden() and
        /// g_signal_chain_from_overridden_handler() for how to chain up to the
        /// parent class closure from inside the overridden one.
        /// </para>
        /// </remarks>
        /// <param name="signalId">
        /// the signal id
        /// </param>
        /// <param name="instanceType">
        /// the instance type on which to override the class closure
        ///  for the signal.
        /// </param>
        /// <param name="classClosure">
        /// the closure.
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_signal_override_class_closure(
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        uint signalId,
        /* <type name="GType" type="GType" managed-name="GISharp.Runtime.GType" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.GType instanceType,
        /* <type name="Closure" type="GClosure*" managed-name="Closure" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Closure.UnmanagedStruct* classClosure);
        static partial void CheckOverrideClassClosureArgs(uint signalId, GISharp.Runtime.GType instanceType, GISharp.Lib.GObject.Closure classClosure);

        /// <include file="Signal.xmldoc" path="declaration/member[@name='Signal.OverrideClassClosure(uint,GISharp.Runtime.GType,GISharp.Lib.GObject.Closure)']/*" />
        public static void OverrideClassClosure(uint signalId, GISharp.Runtime.GType instanceType, GISharp.Lib.GObject.Closure classClosure)
        {
            CheckOverrideClassClosureArgs(signalId, instanceType, classClosure);
            var signalId_ = (uint)signalId;
            var instanceType_ = (GISharp.Runtime.GType)instanceType;
            var classClosure_ = (GISharp.Lib.GObject.Closure.UnmanagedStruct*)classClosure.UnsafeHandle;
            g_signal_override_class_closure(signalId_, instanceType_, classClosure_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
        }

        /// <summary>
        /// Internal function to parse a signal name into its @signal_id
        /// and @detail quark.
        /// </summary>
        /// <param name="detailedSignal">
        /// a string of the form "signal-name::detail".
        /// </param>
        /// <param name="itype">
        /// The interface/instance type that introduced "signal-name".
        /// </param>
        /// <param name="signalIdP">
        /// Location to store the signal id.
        /// </param>
        /// <param name="detailP">
        /// Location to store the detail quark.
        /// </param>
        /// <param name="forceDetailQuark">
        /// %TRUE forces creation of a #GQuark for the detail.
        /// </param>
        /// <returns>
        /// Whether the signal name could successfully be parsed and @signal_id_p and @detail_p contain valid return values.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_signal_parse_name(
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* detailedSignal,
        /* <type name="GType" type="GType" managed-name="GISharp.Runtime.GType" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.GType itype,
        /* <type name="guint" type="guint*" managed-name="System.UInt32" /> */
        /* direction:out caller-allocates:0 transfer-ownership:full */
        uint* signalIdP,
        /* <type name="GLib.Quark" type="GQuark*" managed-name="GISharp.Lib.GLib.Quark" /> */
        /* direction:out caller-allocates:0 transfer-ownership:full */
        GISharp.Lib.GLib.Quark* detailP,
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.Boolean forceDetailQuark);
        static partial void CheckTryParseNameArgs(GISharp.Lib.GLib.UnownedUtf8 detailedSignal, GISharp.Runtime.GType itype, bool forceDetailQuark = false);

        /// <include file="Signal.xmldoc" path="declaration/member[@name='Signal.TryParseName(GISharp.Lib.GLib.UnownedUtf8,GISharp.Runtime.GType,uint,GISharp.Lib.GLib.Quark,bool)']/*" />
        public static bool TryParseName(GISharp.Lib.GLib.UnownedUtf8 detailedSignal, GISharp.Runtime.GType itype, out uint signalIdP, out GISharp.Lib.GLib.Quark detailP, bool forceDetailQuark = false)
        {
            CheckTryParseNameArgs(detailedSignal, itype, forceDetailQuark);
            var detailedSignal_ = (byte*)detailedSignal.UnsafeHandle;
            var itype_ = (GISharp.Runtime.GType)itype;
            var forceDetailQuark_ = GISharp.Runtime.BooleanExtensions.ToBoolean(forceDetailQuark);
            uint signalIdP_;
            GISharp.Lib.GLib.Quark detailP_;
            var ret_ = g_signal_parse_name(detailedSignal_,itype_,&signalIdP_,&detailP_,forceDetailQuark_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            signalIdP = (uint)signalIdP_;
            detailP = (GISharp.Lib.GLib.Quark)detailP_;
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Queries the signal system for in-depth information about a
        /// specific signal. This function will fill in a user-provided
        /// structure to hold signal-specific information. If an invalid
        /// signal id is passed in, the @signal_id member of the #GSignalQuery
        /// is 0. All members filled into the #GSignalQuery structure should
        /// be considered constant and have to be left untouched.
        /// </summary>
        /// <param name="signalId">
        /// The signal id of the signal to query information for.
        /// </param>
        /// <param name="query">
        /// A user provided structure that is
        ///  filled in with constant values upon success.
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_signal_query(
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        uint signalId,
        /* <type name="SignalQuery" type="GSignalQuery*" managed-name="SignalQuery" /> */
        /* direction:out caller-allocates:1 transfer-ownership:none */
        GISharp.Lib.GObject.SignalQuery* query);
        static partial void CheckQueryArgs(uint signalId);

        /// <include file="Signal.xmldoc" path="declaration/member[@name='Signal.Query(uint,GISharp.Lib.GObject.SignalQuery)']/*" />
        public static void Query(uint signalId, out GISharp.Lib.GObject.SignalQuery query)
        {
            fixed (GISharp.Lib.GObject.SignalQuery* query_ = &query)
            {
                CheckQueryArgs(signalId);
                var signalId_ = (uint)signalId;
                g_signal_query(signalId_, query_);
                GISharp.Runtime.GMarshal.PopUnhandledException();
            }
        }

        /// <summary>
        /// Deletes an emission hook.
        /// </summary>
        /// <param name="signalId">
        /// the id of the signal
        /// </param>
        /// <param name="hookId">
        /// the id of the emission hook, as returned by
        ///  g_signal_add_emission_hook()
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_signal_remove_emission_hook(
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        uint signalId,
        /* <type name="gulong" type="gulong" managed-name="GISharp.Runtime.CULong" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.CULong hookId);
        static partial void CheckRemoveEmissionHookArgs(uint signalId, GISharp.Runtime.CULong hookId);

        /// <include file="Signal.xmldoc" path="declaration/member[@name='Signal.RemoveEmissionHook(uint,GISharp.Runtime.CULong)']/*" />
        public static void RemoveEmissionHook(uint signalId, GISharp.Runtime.CULong hookId)
        {
            CheckRemoveEmissionHookArgs(signalId, hookId);
            var signalId_ = (uint)signalId;
            var hookId_ = (GISharp.Runtime.CULong)hookId;
            g_signal_remove_emission_hook(signalId_, hookId_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
        }

        /// <summary>
        /// Stops a signal's current emission.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This will prevent the default method from running, if the signal was
        /// %G_SIGNAL_RUN_LAST and you connected normally (i.e. without the "after"
        /// flag).
        /// </para>
        /// <para>
        /// Prints a warning if used on a signal which isn't being emitted.
        /// </para>
        /// </remarks>
        /// <param name="instance">
        /// the object whose signal handlers you wish to stop.
        /// </param>
        /// <param name="signalId">
        /// the signal identifier, as returned by g_signal_lookup().
        /// </param>
        /// <param name="detail">
        /// the detail which the signal was emitted with.
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_signal_stop_emission(
        /* <type name="Object" type="gpointer" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* instance,
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        uint signalId,
        /* <type name="GLib.Quark" type="GQuark" managed-name="GISharp.Lib.GLib.Quark" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Quark detail);
        static partial void CheckStopEmissionArgs(GISharp.Lib.GObject.Object instance, uint signalId, GISharp.Lib.GLib.Quark detail = default);

        /// <include file="Signal.xmldoc" path="declaration/member[@name='Signal.StopEmission(GISharp.Lib.GObject.Object,uint,GISharp.Lib.GLib.Quark)']/*" />
        public static void StopEmission(GISharp.Lib.GObject.Object instance, uint signalId, GISharp.Lib.GLib.Quark detail = default)
        {
            CheckStopEmissionArgs(instance, signalId, detail);
            var instance_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)instance.UnsafeHandle;
            var signalId_ = (uint)signalId;
            var detail_ = (GISharp.Lib.GLib.Quark)detail;
            g_signal_stop_emission(instance_, signalId_, detail_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
        }

        /// <summary>
        /// Stops a signal's current emission.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This is just like g_signal_stop_emission() except it will look up the
        /// signal id for you.
        /// </para>
        /// </remarks>
        /// <param name="instance">
        /// the object whose signal handlers you wish to stop.
        /// </param>
        /// <param name="detailedSignal">
        /// a string of the form "signal-name::detail".
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_signal_stop_emission_by_name(
        /* <type name="Object" type="gpointer" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* instance,
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* detailedSignal);
        static partial void CheckStopEmissionArgs(GISharp.Lib.GObject.Object instance, GISharp.Lib.GLib.UnownedUtf8 detailedSignal);

        /// <include file="Signal.xmldoc" path="declaration/member[@name='Signal.StopEmission(GISharp.Lib.GObject.Object,GISharp.Lib.GLib.UnownedUtf8)']/*" />
        public static void StopEmission(GISharp.Lib.GObject.Object instance, GISharp.Lib.GLib.UnownedUtf8 detailedSignal)
        {
            CheckStopEmissionArgs(instance, detailedSignal);
            var instance_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)instance.UnsafeHandle;
            var detailedSignal_ = (byte*)detailedSignal.UnsafeHandle;
            g_signal_stop_emission_by_name(instance_, detailedSignal_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
        }

        /// <summary>
        /// Creates a new closure which invokes the function found at the offset
        /// @struct_offset in the class structure of the interface or classed type
        /// identified by @itype.
        /// </summary>
        /// <param name="itype">
        /// the #GType identifier of an interface or classed type
        /// </param>
        /// <param name="structOffset">
        /// the offset of the member function of @itype's class
        ///  structure which is to be invoked by the new closure
        /// </param>
        /// <returns>
        /// a floating reference to a new #GCClosure
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Closure" type="GClosure*" managed-name="Closure" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GObject.Closure.UnmanagedStruct* g_signal_type_cclosure_new(
        /* <type name="GType" type="GType" managed-name="GISharp.Runtime.GType" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.GType itype,
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        uint structOffset);
        static partial void CheckTypeCclosureNewArgs(GISharp.Runtime.GType itype, uint structOffset);

        /// <include file="Signal.xmldoc" path="declaration/member[@name='Signal.TypeCclosureNew(GISharp.Runtime.GType,uint)']/*" />
        public static GISharp.Lib.GObject.Closure TypeCclosureNew(GISharp.Runtime.GType itype, uint structOffset)
        {
            CheckTypeCclosureNewArgs(itype, structOffset);
            var itype_ = (GISharp.Runtime.GType)itype;
            var structOffset_ = (uint)structOffset;
            var ret_ = g_signal_type_cclosure_new(itype_,structOffset_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Lib.GObject.Closure.GetInstance<GISharp.Lib.GObject.Closure>((System.IntPtr)ret_, GISharp.Runtime.Transfer.None)!;
            return ret;
        }
    }
}