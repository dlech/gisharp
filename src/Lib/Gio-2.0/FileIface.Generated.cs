// SPDX-License-Identifier: MIT
// ATTENTION: This file is automatically generated. Do not edit manually.
#nullable enable
namespace GISharp.Lib.Gio
{
    /// <include file="FileIface.xmldoc" path="declaration/member[@name='FileIface']/*" />
    public sealed unsafe partial class FileIface : GISharp.Lib.GObject.TypeInterface
    {
        /// <summary>
        /// The unmanaged data structure.
        /// </summary>
        public new struct UnmanagedStruct
        {
#pragma warning disable CS0169, CS0414, CS0649
            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.GIface']/*" />
            public readonly GISharp.Lib.GObject.TypeInterface.UnmanagedStruct GIface;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.Dup']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, GISharp.Lib.Gio.File.UnmanagedStruct*> Dup;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.Hash']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, uint> Hash;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.Equal']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, GISharp.Lib.Gio.File.UnmanagedStruct*, GISharp.Runtime.Boolean> Equal;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.IsNative']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, GISharp.Runtime.Boolean> IsNative;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.HasUriScheme']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, byte*, GISharp.Runtime.Boolean> HasUriScheme;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.GetUriScheme']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, byte*> GetUriScheme;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.GetBasename']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, byte*> GetBasename;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.GetPath']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, byte*> GetPath;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.GetUri']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, byte*> GetUri;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.GetParseName']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, byte*> GetParseName;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.GetParent']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, GISharp.Lib.Gio.File.UnmanagedStruct*> GetParent;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.PrefixMatches']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, GISharp.Lib.Gio.File.UnmanagedStruct*, GISharp.Runtime.Boolean> PrefixMatches;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.GetRelativePath']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, GISharp.Lib.Gio.File.UnmanagedStruct*, byte*> GetRelativePath;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.ResolveRelativePath']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, byte*, GISharp.Lib.Gio.File.UnmanagedStruct*> ResolveRelativePath;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.GetChildForDisplayName']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, byte*, GISharp.Lib.GLib.Error.UnmanagedStruct**, GISharp.Lib.Gio.File.UnmanagedStruct*> GetChildForDisplayName;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.EnumerateChildren']/*" />
            public readonly System.IntPtr EnumerateChildren;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.EnumerateChildrenAsync']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, byte*, GISharp.Lib.Gio.FileQueryInfoFlags, int, GISharp.Lib.Gio.Cancellable.UnmanagedStruct*, delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void>, System.IntPtr, void> EnumerateChildrenAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.EnumerateChildrenFinish']/*" />
            public readonly System.IntPtr EnumerateChildrenFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.QueryInfo']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, byte*, GISharp.Lib.Gio.FileQueryInfoFlags, GISharp.Lib.Gio.Cancellable.UnmanagedStruct*, GISharp.Lib.GLib.Error.UnmanagedStruct**, GISharp.Lib.Gio.FileInfo.UnmanagedStruct*> QueryInfo;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.QueryInfoAsync']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, byte*, GISharp.Lib.Gio.FileQueryInfoFlags, int, GISharp.Lib.Gio.Cancellable.UnmanagedStruct*, delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void>, System.IntPtr, void> QueryInfoAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.QueryInfoFinish']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, GISharp.Lib.GLib.Error.UnmanagedStruct**, GISharp.Lib.Gio.FileInfo.UnmanagedStruct*> QueryInfoFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.QueryFilesystemInfo']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, byte*, GISharp.Lib.Gio.Cancellable.UnmanagedStruct*, GISharp.Lib.GLib.Error.UnmanagedStruct**, GISharp.Lib.Gio.FileInfo.UnmanagedStruct*> QueryFilesystemInfo;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.QueryFilesystemInfoAsync']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, byte*, int, GISharp.Lib.Gio.Cancellable.UnmanagedStruct*, delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void>, System.IntPtr, void> QueryFilesystemInfoAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.QueryFilesystemInfoFinish']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, GISharp.Lib.GLib.Error.UnmanagedStruct**, GISharp.Lib.Gio.FileInfo.UnmanagedStruct*> QueryFilesystemInfoFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.FindEnclosingMount']/*" />
            public readonly System.IntPtr FindEnclosingMount;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.FindEnclosingMountAsync']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, int, GISharp.Lib.Gio.Cancellable.UnmanagedStruct*, delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void>, System.IntPtr, void> FindEnclosingMountAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.FindEnclosingMountFinish']/*" />
            public readonly System.IntPtr FindEnclosingMountFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.SetDisplayName']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, byte*, GISharp.Lib.Gio.Cancellable.UnmanagedStruct*, GISharp.Lib.GLib.Error.UnmanagedStruct**, GISharp.Lib.Gio.File.UnmanagedStruct*> SetDisplayName;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.SetDisplayNameAsync']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, byte*, int, GISharp.Lib.Gio.Cancellable.UnmanagedStruct*, delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void>, System.IntPtr, void> SetDisplayNameAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.SetDisplayNameFinish']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, GISharp.Lib.GLib.Error.UnmanagedStruct**, GISharp.Lib.Gio.File.UnmanagedStruct*> SetDisplayNameFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.QuerySettableAttributes']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, GISharp.Lib.Gio.Cancellable.UnmanagedStruct*, GISharp.Lib.GLib.Error.UnmanagedStruct**, GISharp.Lib.Gio.FileAttributeInfoList.UnmanagedStruct*> QuerySettableAttributes;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.QuerySettableAttributesAsync']/*" />
            public readonly System.IntPtr QuerySettableAttributesAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.QuerySettableAttributesFinish']/*" />
            public readonly System.IntPtr QuerySettableAttributesFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.QueryWritableNamespaces']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, GISharp.Lib.Gio.Cancellable.UnmanagedStruct*, GISharp.Lib.GLib.Error.UnmanagedStruct**, GISharp.Lib.Gio.FileAttributeInfoList.UnmanagedStruct*> QueryWritableNamespaces;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.QueryWritableNamespacesAsync']/*" />
            public readonly System.IntPtr QueryWritableNamespacesAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.QueryWritableNamespacesFinish']/*" />
            public readonly System.IntPtr QueryWritableNamespacesFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.SetAttribute']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, byte*, GISharp.Lib.Gio.FileAttributeType, System.IntPtr, GISharp.Lib.Gio.FileQueryInfoFlags, GISharp.Lib.Gio.Cancellable.UnmanagedStruct*, GISharp.Lib.GLib.Error.UnmanagedStruct**, GISharp.Runtime.Boolean> SetAttribute;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.SetAttributesFromInfo']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, GISharp.Lib.Gio.FileInfo.UnmanagedStruct*, GISharp.Lib.Gio.FileQueryInfoFlags, GISharp.Lib.Gio.Cancellable.UnmanagedStruct*, GISharp.Lib.GLib.Error.UnmanagedStruct**, GISharp.Runtime.Boolean> SetAttributesFromInfo;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.SetAttributesAsync']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, GISharp.Lib.Gio.FileInfo.UnmanagedStruct*, GISharp.Lib.Gio.FileQueryInfoFlags, int, GISharp.Lib.Gio.Cancellable.UnmanagedStruct*, delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void>, System.IntPtr, void> SetAttributesAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.SetAttributesFinish']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, GISharp.Lib.Gio.FileInfo.UnmanagedStruct**, GISharp.Lib.GLib.Error.UnmanagedStruct**, GISharp.Runtime.Boolean> SetAttributesFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.ReadFn']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, GISharp.Lib.Gio.Cancellable.UnmanagedStruct*, GISharp.Lib.GLib.Error.UnmanagedStruct**, GISharp.Lib.Gio.FileInputStream.UnmanagedStruct*> ReadFn;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.ReadAsync']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, int, GISharp.Lib.Gio.Cancellable.UnmanagedStruct*, delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void>, System.IntPtr, void> ReadAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.ReadFinish']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, GISharp.Lib.GLib.Error.UnmanagedStruct**, GISharp.Lib.Gio.FileInputStream.UnmanagedStruct*> ReadFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.AppendTo']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, GISharp.Lib.Gio.FileCreateFlags, GISharp.Lib.Gio.Cancellable.UnmanagedStruct*, GISharp.Lib.GLib.Error.UnmanagedStruct**, GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct*> AppendTo;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.AppendToAsync']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, GISharp.Lib.Gio.FileCreateFlags, int, GISharp.Lib.Gio.Cancellable.UnmanagedStruct*, delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void>, System.IntPtr, void> AppendToAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.AppendToFinish']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, GISharp.Lib.GLib.Error.UnmanagedStruct**, GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct*> AppendToFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.Create']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, GISharp.Lib.Gio.FileCreateFlags, GISharp.Lib.Gio.Cancellable.UnmanagedStruct*, GISharp.Lib.GLib.Error.UnmanagedStruct**, GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct*> Create;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.CreateAsync']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, GISharp.Lib.Gio.FileCreateFlags, int, GISharp.Lib.Gio.Cancellable.UnmanagedStruct*, delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void>, System.IntPtr, void> CreateAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.CreateFinish']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, GISharp.Lib.GLib.Error.UnmanagedStruct**, GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct*> CreateFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.Replace']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, byte*, GISharp.Runtime.Boolean, GISharp.Lib.Gio.FileCreateFlags, GISharp.Lib.Gio.Cancellable.UnmanagedStruct*, GISharp.Lib.GLib.Error.UnmanagedStruct**, GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct*> Replace;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.ReplaceAsync']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, byte*, GISharp.Runtime.Boolean, GISharp.Lib.Gio.FileCreateFlags, int, GISharp.Lib.Gio.Cancellable.UnmanagedStruct*, delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void>, System.IntPtr, void> ReplaceAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.ReplaceFinish']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, GISharp.Lib.GLib.Error.UnmanagedStruct**, GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct*> ReplaceFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.DeleteFile']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, GISharp.Lib.Gio.Cancellable.UnmanagedStruct*, GISharp.Lib.GLib.Error.UnmanagedStruct**, GISharp.Runtime.Boolean> DeleteFile;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.DeleteFileAsync']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, int, GISharp.Lib.Gio.Cancellable.UnmanagedStruct*, delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void>, System.IntPtr, void> DeleteFileAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.DeleteFileFinish']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, GISharp.Lib.GLib.Error.UnmanagedStruct**, GISharp.Runtime.Boolean> DeleteFileFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.Trash']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, GISharp.Lib.Gio.Cancellable.UnmanagedStruct*, GISharp.Lib.GLib.Error.UnmanagedStruct**, GISharp.Runtime.Boolean> Trash;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.TrashAsync']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, int, GISharp.Lib.Gio.Cancellable.UnmanagedStruct*, delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void>, System.IntPtr, void> TrashAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.TrashFinish']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, GISharp.Lib.GLib.Error.UnmanagedStruct**, GISharp.Runtime.Boolean> TrashFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.MakeDirectory']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, GISharp.Lib.Gio.Cancellable.UnmanagedStruct*, GISharp.Lib.GLib.Error.UnmanagedStruct**, GISharp.Runtime.Boolean> MakeDirectory;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.MakeDirectoryAsync']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, int, GISharp.Lib.Gio.Cancellable.UnmanagedStruct*, delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void>, System.IntPtr, void> MakeDirectoryAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.MakeDirectoryFinish']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, GISharp.Lib.GLib.Error.UnmanagedStruct**, GISharp.Runtime.Boolean> MakeDirectoryFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.MakeSymbolicLink']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, byte*, GISharp.Lib.Gio.Cancellable.UnmanagedStruct*, GISharp.Lib.GLib.Error.UnmanagedStruct**, GISharp.Runtime.Boolean> MakeSymbolicLink;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.MakeSymbolicLinkAsync']/*" />
            public readonly System.IntPtr MakeSymbolicLinkAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.MakeSymbolicLinkFinish']/*" />
            public readonly System.IntPtr MakeSymbolicLinkFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.Copy']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, GISharp.Lib.Gio.File.UnmanagedStruct*, GISharp.Lib.Gio.FileCopyFlags, GISharp.Lib.Gio.Cancellable.UnmanagedStruct*, delegate* unmanaged[Cdecl]<long, long, System.IntPtr, void>, System.IntPtr, GISharp.Lib.GLib.Error.UnmanagedStruct**, GISharp.Runtime.Boolean> Copy;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.CopyAsync']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, GISharp.Lib.Gio.File.UnmanagedStruct*, GISharp.Lib.Gio.FileCopyFlags, int, GISharp.Lib.Gio.Cancellable.UnmanagedStruct*, delegate* unmanaged[Cdecl]<long, long, System.IntPtr, void>, System.IntPtr, delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void>, System.IntPtr, void> CopyAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.CopyFinish']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, GISharp.Lib.GLib.Error.UnmanagedStruct**, GISharp.Runtime.Boolean> CopyFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.Move']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, GISharp.Lib.Gio.File.UnmanagedStruct*, GISharp.Lib.Gio.FileCopyFlags, GISharp.Lib.Gio.Cancellable.UnmanagedStruct*, delegate* unmanaged[Cdecl]<long, long, System.IntPtr, void>, System.IntPtr, GISharp.Lib.GLib.Error.UnmanagedStruct**, GISharp.Runtime.Boolean> Move;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.MoveAsync']/*" />
            public readonly System.IntPtr MoveAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.MoveFinish']/*" />
            public readonly System.IntPtr MoveFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.MountMountable']/*" />
            public readonly System.IntPtr MountMountable;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.MountMountableFinish']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, GISharp.Lib.GLib.Error.UnmanagedStruct**, GISharp.Lib.Gio.File.UnmanagedStruct*> MountMountableFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.UnmountMountable']/*" />
            public readonly System.IntPtr UnmountMountable;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.UnmountMountableFinish']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, GISharp.Lib.GLib.Error.UnmanagedStruct**, GISharp.Runtime.Boolean> UnmountMountableFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.EjectMountable']/*" />
            public readonly System.IntPtr EjectMountable;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.EjectMountableFinish']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, GISharp.Lib.GLib.Error.UnmanagedStruct**, GISharp.Runtime.Boolean> EjectMountableFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.MountEnclosingVolume']/*" />
            public readonly System.IntPtr MountEnclosingVolume;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.MountEnclosingVolumeFinish']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, GISharp.Lib.GLib.Error.UnmanagedStruct**, GISharp.Runtime.Boolean> MountEnclosingVolumeFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.MonitorDir']/*" />
            public readonly System.IntPtr MonitorDir;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.MonitorFile']/*" />
            public readonly System.IntPtr MonitorFile;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.OpenReadwrite']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, GISharp.Lib.Gio.Cancellable.UnmanagedStruct*, GISharp.Lib.GLib.Error.UnmanagedStruct**, GISharp.Lib.Gio.FileIOStream.UnmanagedStruct*> OpenReadwrite;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.OpenReadwriteAsync']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, int, GISharp.Lib.Gio.Cancellable.UnmanagedStruct*, delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void>, System.IntPtr, void> OpenReadwriteAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.OpenReadwriteFinish']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, GISharp.Lib.GLib.Error.UnmanagedStruct**, GISharp.Lib.Gio.FileIOStream.UnmanagedStruct*> OpenReadwriteFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.CreateReadwrite']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, GISharp.Lib.Gio.FileCreateFlags, GISharp.Lib.Gio.Cancellable.UnmanagedStruct*, GISharp.Lib.GLib.Error.UnmanagedStruct**, GISharp.Lib.Gio.FileIOStream.UnmanagedStruct*> CreateReadwrite;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.CreateReadwriteAsync']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, GISharp.Lib.Gio.FileCreateFlags, int, GISharp.Lib.Gio.Cancellable.UnmanagedStruct*, delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void>, System.IntPtr, void> CreateReadwriteAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.CreateReadwriteFinish']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, GISharp.Lib.GLib.Error.UnmanagedStruct**, GISharp.Lib.Gio.FileIOStream.UnmanagedStruct*> CreateReadwriteFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.ReplaceReadwrite']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, byte*, GISharp.Runtime.Boolean, GISharp.Lib.Gio.FileCreateFlags, GISharp.Lib.Gio.Cancellable.UnmanagedStruct*, GISharp.Lib.GLib.Error.UnmanagedStruct**, GISharp.Lib.Gio.FileIOStream.UnmanagedStruct*> ReplaceReadwrite;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.ReplaceReadwriteAsync']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, byte*, GISharp.Runtime.Boolean, GISharp.Lib.Gio.FileCreateFlags, int, GISharp.Lib.Gio.Cancellable.UnmanagedStruct*, delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void>, System.IntPtr, void> ReplaceReadwriteAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.ReplaceReadwriteFinish']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, GISharp.Lib.GLib.Error.UnmanagedStruct**, GISharp.Lib.Gio.FileIOStream.UnmanagedStruct*> ReplaceReadwriteFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.StartMountable']/*" />
            public readonly System.IntPtr StartMountable;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.StartMountableFinish']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, GISharp.Lib.GLib.Error.UnmanagedStruct**, GISharp.Runtime.Boolean> StartMountableFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.StopMountable']/*" />
            public readonly System.IntPtr StopMountable;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.StopMountableFinish']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, GISharp.Lib.GLib.Error.UnmanagedStruct**, GISharp.Runtime.Boolean> StopMountableFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.SupportsThreadContexts']/*" />
            public readonly GISharp.Runtime.Boolean SupportsThreadContexts;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.UnmountMountableWithOperation']/*" />
            public readonly System.IntPtr UnmountMountableWithOperation;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.UnmountMountableWithOperationFinish']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, GISharp.Lib.GLib.Error.UnmanagedStruct**, GISharp.Runtime.Boolean> UnmountMountableWithOperationFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.EjectMountableWithOperation']/*" />
            public readonly System.IntPtr EjectMountableWithOperation;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.EjectMountableWithOperationFinish']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, GISharp.Lib.GLib.Error.UnmanagedStruct**, GISharp.Runtime.Boolean> EjectMountableWithOperationFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.PollMountable']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, GISharp.Lib.Gio.Cancellable.UnmanagedStruct*, delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void>, System.IntPtr, void> PollMountable;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.PollMountableFinish']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, GISharp.Lib.GLib.Error.UnmanagedStruct**, GISharp.Runtime.Boolean> PollMountableFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.MeasureDiskUsage']/*" />
            public readonly System.IntPtr MeasureDiskUsage;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.MeasureDiskUsageAsync']/*" />
            public readonly System.IntPtr MeasureDiskUsageAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.MeasureDiskUsageFinish']/*" />
            public readonly delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.File.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, ulong*, ulong*, ulong*, GISharp.Lib.GLib.Error.UnmanagedStruct**, GISharp.Runtime.Boolean> MeasureDiskUsageFinish;
#pragma warning restore CS0169, CS0414, CS0649
        }

        static FileIface()
        {
            int dupOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.Dup));
            RegisterVirtualMethod(dupOffset, DupMarshal.Create);
            int hashOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.Hash));
            RegisterVirtualMethod(hashOffset, HashMarshal.Create);
            int equalOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.Equal));
            RegisterVirtualMethod(equalOffset, EqualMarshal.Create);
            int isNativeOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.IsNative));
            RegisterVirtualMethod(isNativeOffset, IsNativeMarshal.Create);
            int hasUriSchemeOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.HasUriScheme));
            RegisterVirtualMethod(hasUriSchemeOffset, HasUriSchemeMarshal.Create);
            int getUriSchemeOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.GetUriScheme));
            RegisterVirtualMethod(getUriSchemeOffset, GetUriSchemeMarshal.Create);
            int getBasenameOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.GetBasename));
            RegisterVirtualMethod(getBasenameOffset, GetBasenameMarshal.Create);
            int getPathOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.GetPath));
            RegisterVirtualMethod(getPathOffset, GetPathMarshal.Create);
            int getUriOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.GetUri));
            RegisterVirtualMethod(getUriOffset, GetUriMarshal.Create);
            int getParseNameOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.GetParseName));
            RegisterVirtualMethod(getParseNameOffset, GetParseNameMarshal.Create);
            int getParentOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.GetParent));
            RegisterVirtualMethod(getParentOffset, GetParentMarshal.Create);
            int prefixMatchesOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.PrefixMatches));
            RegisterVirtualMethod(prefixMatchesOffset, PrefixMatchesMarshal.Create);
            int getRelativePathOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.GetRelativePath));
            RegisterVirtualMethod(getRelativePathOffset, GetRelativePathMarshal.Create);
            int resolveRelativePathOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.ResolveRelativePath));
            RegisterVirtualMethod(resolveRelativePathOffset, ResolveRelativePathMarshal.Create);
            int getChildForDisplayNameOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.GetChildForDisplayName));
            RegisterVirtualMethod(getChildForDisplayNameOffset, GetChildForDisplayNameMarshal.Create);
            int enumerateChildrenAsyncOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.EnumerateChildrenAsync));
            RegisterVirtualMethod(enumerateChildrenAsyncOffset, EnumerateChildrenAsyncMarshal.Create);
            int queryInfoOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.QueryInfo));
            RegisterVirtualMethod(queryInfoOffset, QueryInfoMarshal.Create);
            int queryInfoAsyncOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.QueryInfoAsync));
            RegisterVirtualMethod(queryInfoAsyncOffset, QueryInfoAsyncMarshal.Create);
            int queryInfoFinishOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.QueryInfoFinish));
            RegisterVirtualMethod(queryInfoFinishOffset, QueryInfoFinishMarshal.Create);
            int queryFilesystemInfoOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.QueryFilesystemInfo));
            RegisterVirtualMethod(queryFilesystemInfoOffset, QueryFilesystemInfoMarshal.Create);
            int queryFilesystemInfoAsyncOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.QueryFilesystemInfoAsync));
            RegisterVirtualMethod(queryFilesystemInfoAsyncOffset, QueryFilesystemInfoAsyncMarshal.Create);
            int queryFilesystemInfoFinishOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.QueryFilesystemInfoFinish));
            RegisterVirtualMethod(queryFilesystemInfoFinishOffset, QueryFilesystemInfoFinishMarshal.Create);
            int findEnclosingMountAsyncOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.FindEnclosingMountAsync));
            RegisterVirtualMethod(findEnclosingMountAsyncOffset, FindEnclosingMountAsyncMarshal.Create);
            int setDisplayNameOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.SetDisplayName));
            RegisterVirtualMethod(setDisplayNameOffset, SetDisplayNameMarshal.Create);
            int setDisplayNameAsyncOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.SetDisplayNameAsync));
            RegisterVirtualMethod(setDisplayNameAsyncOffset, SetDisplayNameAsyncMarshal.Create);
            int setDisplayNameFinishOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.SetDisplayNameFinish));
            RegisterVirtualMethod(setDisplayNameFinishOffset, SetDisplayNameFinishMarshal.Create);
            int querySettableAttributesOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.QuerySettableAttributes));
            RegisterVirtualMethod(querySettableAttributesOffset, QuerySettableAttributesMarshal.Create);
            int queryWritableNamespacesOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.QueryWritableNamespaces));
            RegisterVirtualMethod(queryWritableNamespacesOffset, QueryWritableNamespacesMarshal.Create);
            int setAttributeOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.SetAttribute));
            RegisterVirtualMethod(setAttributeOffset, SetAttributeMarshal.Create);
            int setAttributesFromInfoOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.SetAttributesFromInfo));
            RegisterVirtualMethod(setAttributesFromInfoOffset, SetAttributesFromInfoMarshal.Create);
            int setAttributesAsyncOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.SetAttributesAsync));
            RegisterVirtualMethod(setAttributesAsyncOffset, SetAttributesAsyncMarshal.Create);
            int setAttributesFinishOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.SetAttributesFinish));
            RegisterVirtualMethod(setAttributesFinishOffset, SetAttributesFinishMarshal.Create);
            int readFnOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.ReadFn));
            RegisterVirtualMethod(readFnOffset, ReadFnMarshal.Create);
            int readAsyncOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.ReadAsync));
            RegisterVirtualMethod(readAsyncOffset, ReadAsyncMarshal.Create);
            int readFinishOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.ReadFinish));
            RegisterVirtualMethod(readFinishOffset, ReadFinishMarshal.Create);
            int appendToOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.AppendTo));
            RegisterVirtualMethod(appendToOffset, AppendToMarshal.Create);
            int appendToAsyncOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.AppendToAsync));
            RegisterVirtualMethod(appendToAsyncOffset, AppendToAsyncMarshal.Create);
            int appendToFinishOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.AppendToFinish));
            RegisterVirtualMethod(appendToFinishOffset, AppendToFinishMarshal.Create);
            int createOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.Create));
            RegisterVirtualMethod(createOffset, CreateMarshal.Create);
            int createAsyncOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.CreateAsync));
            RegisterVirtualMethod(createAsyncOffset, CreateAsyncMarshal.Create);
            int createFinishOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.CreateFinish));
            RegisterVirtualMethod(createFinishOffset, CreateFinishMarshal.Create);
            int replaceOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.Replace));
            RegisterVirtualMethod(replaceOffset, ReplaceMarshal.Create);
            int replaceAsyncOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.ReplaceAsync));
            RegisterVirtualMethod(replaceAsyncOffset, ReplaceAsyncMarshal.Create);
            int replaceFinishOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.ReplaceFinish));
            RegisterVirtualMethod(replaceFinishOffset, ReplaceFinishMarshal.Create);
            int deleteFileOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.DeleteFile));
            RegisterVirtualMethod(deleteFileOffset, DeleteFileMarshal.Create);
            int deleteFileAsyncOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.DeleteFileAsync));
            RegisterVirtualMethod(deleteFileAsyncOffset, DeleteFileAsyncMarshal.Create);
            int deleteFileFinishOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.DeleteFileFinish));
            RegisterVirtualMethod(deleteFileFinishOffset, DeleteFileFinishMarshal.Create);
            int trashOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.Trash));
            RegisterVirtualMethod(trashOffset, TrashMarshal.Create);
            int trashAsyncOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.TrashAsync));
            RegisterVirtualMethod(trashAsyncOffset, TrashAsyncMarshal.Create);
            int trashFinishOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.TrashFinish));
            RegisterVirtualMethod(trashFinishOffset, TrashFinishMarshal.Create);
            int makeDirectoryOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.MakeDirectory));
            RegisterVirtualMethod(makeDirectoryOffset, MakeDirectoryMarshal.Create);
            int makeDirectoryAsyncOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.MakeDirectoryAsync));
            RegisterVirtualMethod(makeDirectoryAsyncOffset, MakeDirectoryAsyncMarshal.Create);
            int makeDirectoryFinishOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.MakeDirectoryFinish));
            RegisterVirtualMethod(makeDirectoryFinishOffset, MakeDirectoryFinishMarshal.Create);
            int makeSymbolicLinkOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.MakeSymbolicLink));
            RegisterVirtualMethod(makeSymbolicLinkOffset, MakeSymbolicLinkMarshal.Create);
            int copyOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.Copy));
            RegisterVirtualMethod(copyOffset, CopyMarshal.Create);
            int copyAsyncOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.CopyAsync));
            RegisterVirtualMethod(copyAsyncOffset, CopyAsyncMarshal.Create);
            int copyFinishOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.CopyFinish));
            RegisterVirtualMethod(copyFinishOffset, CopyFinishMarshal.Create);
            int moveOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.Move));
            RegisterVirtualMethod(moveOffset, MoveMarshal.Create);
            int mountMountableFinishOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.MountMountableFinish));
            RegisterVirtualMethod(mountMountableFinishOffset, MountMountableFinishMarshal.Create);
            int unmountMountableFinishOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.UnmountMountableFinish));
            RegisterVirtualMethod(unmountMountableFinishOffset, UnmountMountableFinishMarshal.Create);
            int ejectMountableFinishOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.EjectMountableFinish));
            RegisterVirtualMethod(ejectMountableFinishOffset, EjectMountableFinishMarshal.Create);
            int mountEnclosingVolumeFinishOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.MountEnclosingVolumeFinish));
            RegisterVirtualMethod(mountEnclosingVolumeFinishOffset, MountEnclosingVolumeFinishMarshal.Create);
            int openReadwriteOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.OpenReadwrite));
            RegisterVirtualMethod(openReadwriteOffset, OpenReadwriteMarshal.Create);
            int openReadwriteAsyncOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.OpenReadwriteAsync));
            RegisterVirtualMethod(openReadwriteAsyncOffset, OpenReadwriteAsyncMarshal.Create);
            int openReadwriteFinishOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.OpenReadwriteFinish));
            RegisterVirtualMethod(openReadwriteFinishOffset, OpenReadwriteFinishMarshal.Create);
            int createReadwriteOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.CreateReadwrite));
            RegisterVirtualMethod(createReadwriteOffset, CreateReadwriteMarshal.Create);
            int createReadwriteAsyncOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.CreateReadwriteAsync));
            RegisterVirtualMethod(createReadwriteAsyncOffset, CreateReadwriteAsyncMarshal.Create);
            int createReadwriteFinishOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.CreateReadwriteFinish));
            RegisterVirtualMethod(createReadwriteFinishOffset, CreateReadwriteFinishMarshal.Create);
            int replaceReadwriteOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.ReplaceReadwrite));
            RegisterVirtualMethod(replaceReadwriteOffset, ReplaceReadwriteMarshal.Create);
            int replaceReadwriteAsyncOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.ReplaceReadwriteAsync));
            RegisterVirtualMethod(replaceReadwriteAsyncOffset, ReplaceReadwriteAsyncMarshal.Create);
            int replaceReadwriteFinishOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.ReplaceReadwriteFinish));
            RegisterVirtualMethod(replaceReadwriteFinishOffset, ReplaceReadwriteFinishMarshal.Create);
            int startMountableFinishOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.StartMountableFinish));
            RegisterVirtualMethod(startMountableFinishOffset, StartMountableFinishMarshal.Create);
            int stopMountableFinishOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.StopMountableFinish));
            RegisterVirtualMethod(stopMountableFinishOffset, StopMountableFinishMarshal.Create);
            int unmountMountableWithOperationFinishOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.UnmountMountableWithOperationFinish));
            RegisterVirtualMethod(unmountMountableWithOperationFinishOffset, UnmountMountableWithOperationFinishMarshal.Create);
            int ejectMountableWithOperationFinishOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.EjectMountableWithOperationFinish));
            RegisterVirtualMethod(ejectMountableWithOperationFinishOffset, EjectMountableWithOperationFinishMarshal.Create);
            int pollMountableOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.PollMountable));
            RegisterVirtualMethod(pollMountableOffset, PollMountableMarshal.Create);
            int pollMountableFinishOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.PollMountableFinish));
            RegisterVirtualMethod(pollMountableFinishOffset, PollMountableFinishMarshal.Create);
            int measureDiskUsageFinishOffset = (int)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.MeasureDiskUsageFinish));
            RegisterVirtualMethod(measureDiskUsageFinishOffset, MeasureDiskUsageFinishMarshal.Create);
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_Dup']/*" />
        public delegate GISharp.Lib.Gio.IFile _Dup();

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate GISharp.Lib.Gio.File.UnmanagedStruct* UnmanagedDup(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file);

        /// <summary>
        /// Class for marshalling <see cref="_Dup"/> methods.
        /// </summary>
        public static unsafe class DupMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedDup Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Lib.Gio.File.UnmanagedStruct* unmanagedDup(GISharp.Lib.Gio.File.UnmanagedStruct* file_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var doDup = (_Dup)methodInfo.CreateDelegate(typeof(_Dup), file); var ret = doDup(); var ret_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)ret.Take(); return ret_; } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(GISharp.Lib.Gio.File.UnmanagedStruct*); }

                return unmanagedDup;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_Hash']/*" />
        public delegate uint _Hash();

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        public unsafe delegate uint UnmanagedHash(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file);

        /// <summary>
        /// Class for marshalling <see cref="_Hash"/> methods.
        /// </summary>
        public static unsafe class HashMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedHash Create(System.Reflection.MethodInfo methodInfo)
            {
                uint unmanagedHash(GISharp.Lib.Gio.File.UnmanagedStruct* file_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var doHash = (_Hash)methodInfo.CreateDelegate(typeof(_Hash), file); var ret = doHash(); var ret_ = (uint)ret; return ret_; } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(uint); }

                return unmanagedHash;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_Equal']/*" />
        public delegate bool _Equal(GISharp.Lib.Gio.IFile file2);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedEqual(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file1,
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file2);

        /// <summary>
        /// Class for marshalling <see cref="_Equal"/> methods.
        /// </summary>
        public static unsafe class EqualMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedEqual Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedEqual(GISharp.Lib.Gio.File.UnmanagedStruct* file1_, GISharp.Lib.Gio.File.UnmanagedStruct* file2_) { try { var file1 = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file1_, GISharp.Runtime.Transfer.None)!; var file2 = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file2_, GISharp.Runtime.Transfer.None)!; var doEqual = (_Equal)methodInfo.CreateDelegate(typeof(_Equal), file1); var ret = doEqual(file2); var ret_ = GISharp.Runtime.BooleanExtensions.ToBoolean(ret); return ret_; } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(GISharp.Runtime.Boolean); }

                return unmanagedEqual;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_IsNative']/*" />
        public delegate bool _IsNative();

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedIsNative(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file);

        /// <summary>
        /// Class for marshalling <see cref="_IsNative"/> methods.
        /// </summary>
        public static unsafe class IsNativeMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedIsNative Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedIsNative(GISharp.Lib.Gio.File.UnmanagedStruct* file_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var doIsNative = (_IsNative)methodInfo.CreateDelegate(typeof(_IsNative), file); var ret = doIsNative(); var ret_ = GISharp.Runtime.BooleanExtensions.ToBoolean(ret); return ret_; } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(GISharp.Runtime.Boolean); }

                return unmanagedIsNative;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_HasUriScheme']/*" />
        public delegate bool _HasUriScheme(GISharp.Lib.GLib.UnownedUtf8 uriScheme);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedHasUriScheme(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
byte* uriScheme);

        /// <summary>
        /// Class for marshalling <see cref="_HasUriScheme"/> methods.
        /// </summary>
        public static unsafe class HasUriSchemeMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedHasUriScheme Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedHasUriScheme(GISharp.Lib.Gio.File.UnmanagedStruct* file_, byte* uriScheme_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var uriScheme = new GISharp.Lib.GLib.UnownedUtf8(uriScheme_); var doHasUriScheme = (_HasUriScheme)methodInfo.CreateDelegate(typeof(_HasUriScheme), file); var ret = doHasUriScheme(uriScheme); var ret_ = GISharp.Runtime.BooleanExtensions.ToBoolean(ret); return ret_; } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(GISharp.Runtime.Boolean); }

                return unmanagedHasUriScheme;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_GetUriScheme']/*" />
        public delegate GISharp.Lib.GLib.Utf8 _GetUriScheme();

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate byte* UnmanagedGetUriScheme(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file);

        /// <summary>
        /// Class for marshalling <see cref="_GetUriScheme"/> methods.
        /// </summary>
        public static unsafe class GetUriSchemeMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedGetUriScheme Create(System.Reflection.MethodInfo methodInfo)
            {
                byte* unmanagedGetUriScheme(GISharp.Lib.Gio.File.UnmanagedStruct* file_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var doGetUriScheme = (_GetUriScheme)methodInfo.CreateDelegate(typeof(_GetUriScheme), file); var ret = doGetUriScheme(); var ret_ = (byte*)ret.Take(); return ret_; } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(byte*); }

                return unmanagedGetUriScheme;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_GetBasename']/*" />
        public delegate GISharp.Lib.GLib.Utf8 _GetBasename();

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate byte* UnmanagedGetBasename(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file);

        /// <summary>
        /// Class for marshalling <see cref="_GetBasename"/> methods.
        /// </summary>
        public static unsafe class GetBasenameMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedGetBasename Create(System.Reflection.MethodInfo methodInfo)
            {
                byte* unmanagedGetBasename(GISharp.Lib.Gio.File.UnmanagedStruct* file_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var doGetBasename = (_GetBasename)methodInfo.CreateDelegate(typeof(_GetBasename), file); var ret = doGetBasename(); var ret_ = (byte*)ret.Take(); return ret_; } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(byte*); }

                return unmanagedGetBasename;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_GetPath']/*" />
        public delegate GISharp.Lib.GLib.Utf8 _GetPath();

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate byte* UnmanagedGetPath(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file);

        /// <summary>
        /// Class for marshalling <see cref="_GetPath"/> methods.
        /// </summary>
        public static unsafe class GetPathMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedGetPath Create(System.Reflection.MethodInfo methodInfo)
            {
                byte* unmanagedGetPath(GISharp.Lib.Gio.File.UnmanagedStruct* file_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var doGetPath = (_GetPath)methodInfo.CreateDelegate(typeof(_GetPath), file); var ret = doGetPath(); var ret_ = (byte*)ret.Take(); return ret_; } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(byte*); }

                return unmanagedGetPath;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_GetUri']/*" />
        public delegate GISharp.Lib.GLib.Utf8 _GetUri();

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate byte* UnmanagedGetUri(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file);

        /// <summary>
        /// Class for marshalling <see cref="_GetUri"/> methods.
        /// </summary>
        public static unsafe class GetUriMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedGetUri Create(System.Reflection.MethodInfo methodInfo)
            {
                byte* unmanagedGetUri(GISharp.Lib.Gio.File.UnmanagedStruct* file_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var doGetUri = (_GetUri)methodInfo.CreateDelegate(typeof(_GetUri), file); var ret = doGetUri(); var ret_ = (byte*)ret.Take(); return ret_; } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(byte*); }

                return unmanagedGetUri;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_GetParseName']/*" />
        public delegate GISharp.Lib.GLib.Utf8 _GetParseName();

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate byte* UnmanagedGetParseName(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file);

        /// <summary>
        /// Class for marshalling <see cref="_GetParseName"/> methods.
        /// </summary>
        public static unsafe class GetParseNameMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedGetParseName Create(System.Reflection.MethodInfo methodInfo)
            {
                byte* unmanagedGetParseName(GISharp.Lib.Gio.File.UnmanagedStruct* file_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var doGetParseName = (_GetParseName)methodInfo.CreateDelegate(typeof(_GetParseName), file); var ret = doGetParseName(); var ret_ = (byte*)ret.Take(); return ret_; } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(byte*); }

                return unmanagedGetParseName;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_GetParent']/*" />
        public delegate GISharp.Lib.Gio.IFile? _GetParent();

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
        /* transfer-ownership:full nullable:1 direction:in */
        public unsafe delegate GISharp.Lib.Gio.File.UnmanagedStruct* UnmanagedGetParent(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file);

        /// <summary>
        /// Class for marshalling <see cref="_GetParent"/> methods.
        /// </summary>
        public static unsafe class GetParentMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedGetParent Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Lib.Gio.File.UnmanagedStruct* unmanagedGetParent(GISharp.Lib.Gio.File.UnmanagedStruct* file_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var doGetParent = (_GetParent)methodInfo.CreateDelegate(typeof(_GetParent), file); var ret = doGetParent(); var ret_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)(ret?.Take() ?? System.IntPtr.Zero); return ret_; } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(GISharp.Lib.Gio.File.UnmanagedStruct*); }

                return unmanagedGetParent;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_PrefixMatches']/*" />
        public delegate bool _PrefixMatches(GISharp.Lib.Gio.IFile file);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedPrefixMatches(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* prefix,
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file);

        /// <summary>
        /// Class for marshalling <see cref="_PrefixMatches"/> methods.
        /// </summary>
        public static unsafe class PrefixMatchesMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedPrefixMatches Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedPrefixMatches(GISharp.Lib.Gio.File.UnmanagedStruct* prefix_, GISharp.Lib.Gio.File.UnmanagedStruct* file_) { try { var prefix = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)prefix_, GISharp.Runtime.Transfer.None)!; var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var doPrefixMatches = (_PrefixMatches)methodInfo.CreateDelegate(typeof(_PrefixMatches), prefix); var ret = doPrefixMatches(file); var ret_ = GISharp.Runtime.BooleanExtensions.ToBoolean(ret); return ret_; } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(GISharp.Runtime.Boolean); }

                return unmanagedPrefixMatches;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_GetRelativePath']/*" />
        public delegate GISharp.Lib.GLib.Utf8 _GetRelativePath(GISharp.Lib.Gio.IFile descendant);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate byte* UnmanagedGetRelativePath(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* parent,
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* descendant);

        /// <summary>
        /// Class for marshalling <see cref="_GetRelativePath"/> methods.
        /// </summary>
        public static unsafe class GetRelativePathMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedGetRelativePath Create(System.Reflection.MethodInfo methodInfo)
            {
                byte* unmanagedGetRelativePath(GISharp.Lib.Gio.File.UnmanagedStruct* parent_, GISharp.Lib.Gio.File.UnmanagedStruct* descendant_) { try { var parent = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)parent_, GISharp.Runtime.Transfer.None)!; var descendant = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)descendant_, GISharp.Runtime.Transfer.None)!; var doGetRelativePath = (_GetRelativePath)methodInfo.CreateDelegate(typeof(_GetRelativePath), parent); var ret = doGetRelativePath(descendant); var ret_ = (byte*)ret.Take(); return ret_; } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(byte*); }

                return unmanagedGetRelativePath;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_ResolveRelativePath']/*" />
        public delegate GISharp.Lib.Gio.IFile _ResolveRelativePath(GISharp.Lib.GLib.Filename relativePath);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate GISharp.Lib.Gio.File.UnmanagedStruct* UnmanagedResolveRelativePath(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="filename" type="const char*" managed-name="GISharp.Lib.GLib.Filename" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
byte* relativePath);

        /// <summary>
        /// Class for marshalling <see cref="_ResolveRelativePath"/> methods.
        /// </summary>
        public static unsafe class ResolveRelativePathMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedResolveRelativePath Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Lib.Gio.File.UnmanagedStruct* unmanagedResolveRelativePath(GISharp.Lib.Gio.File.UnmanagedStruct* file_, byte* relativePath_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var relativePath = GISharp.Lib.GLib.Filename.GetInstance<GISharp.Lib.GLib.Filename>((System.IntPtr)relativePath_, GISharp.Runtime.Transfer.None)!; var doResolveRelativePath = (_ResolveRelativePath)methodInfo.CreateDelegate(typeof(_ResolveRelativePath), file); var ret = doResolveRelativePath(relativePath); var ret_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)ret.Take(); return ret_; } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(GISharp.Lib.Gio.File.UnmanagedStruct*); }

                return unmanagedResolveRelativePath;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_GetChildForDisplayName']/*" />
        public delegate GISharp.Lib.Gio.IFile _GetChildForDisplayName(GISharp.Lib.GLib.UnownedUtf8 displayName);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate GISharp.Lib.Gio.File.UnmanagedStruct* UnmanagedGetChildForDisplayName(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
byte* displayName,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="_GetChildForDisplayName"/> methods.
        /// </summary>
        public static unsafe class GetChildForDisplayNameMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedGetChildForDisplayName Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Lib.Gio.File.UnmanagedStruct* unmanagedGetChildForDisplayName(GISharp.Lib.Gio.File.UnmanagedStruct* file_, byte* displayName_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var displayName = new GISharp.Lib.GLib.UnownedUtf8(displayName_); var doGetChildForDisplayName = (_GetChildForDisplayName)methodInfo.CreateDelegate(typeof(_GetChildForDisplayName), file); var ret = doGetChildForDisplayName(displayName); var ret_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)ret.Take(); return ret_; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(GISharp.Lib.Gio.File.UnmanagedStruct*); }

                return unmanagedGetChildForDisplayName;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_EnumerateChildrenAsync']/*" />
        public delegate void _EnumerateChildrenAsync(GISharp.Lib.GLib.UnownedUtf8 attributes, GISharp.Lib.Gio.FileQueryInfoFlags flags, int ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        public unsafe delegate void UnmanagedEnumerateChildrenAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
byte* attributes,
/* <type name="FileQueryInfoFlags" type="GFileQueryInfoFlags" managed-name="FileQueryInfoFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileQueryInfoFlags flags,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
int ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="AsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:6 direction:in */
delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:6 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Class for marshalling <see cref="_EnumerateChildrenAsync"/> methods.
        /// </summary>
        public static unsafe class EnumerateChildrenAsyncMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedEnumerateChildrenAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedEnumerateChildrenAsync(GISharp.Lib.Gio.File.UnmanagedStruct* file_, byte* attributes_, GISharp.Lib.Gio.FileQueryInfoFlags flags_, int ioPriority_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback_, System.IntPtr userData_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var attributes = new GISharp.Lib.GLib.UnownedUtf8(attributes_); var flags = (GISharp.Lib.Gio.FileQueryInfoFlags)flags_; var ioPriority = (int)ioPriority_; var callback = callback_ is null ? default(GISharp.Lib.Gio.AsyncReadyCallback) : GISharp.Lib.Gio.AsyncReadyCallbackMarshal.FromPointer(callback_, userData_); var cancellable = GISharp.Lib.Gio.Cancellable.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doEnumerateChildrenAsync = (_EnumerateChildrenAsync)methodInfo.CreateDelegate(typeof(_EnumerateChildrenAsync), file); doEnumerateChildrenAsync(attributes, flags, ioPriority, callback, cancellable); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } }

                return unmanagedEnumerateChildrenAsync;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_QueryInfo']/*" />
        public delegate GISharp.Lib.Gio.FileInfo _QueryInfo(GISharp.Lib.GLib.UnownedUtf8 attributes, GISharp.Lib.Gio.FileQueryInfoFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileInfo" type="GFileInfo*" managed-name="FileInfo" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate GISharp.Lib.Gio.FileInfo.UnmanagedStruct* UnmanagedQueryInfo(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
byte* attributes,
/* <type name="FileQueryInfoFlags" type="GFileQueryInfoFlags" managed-name="FileQueryInfoFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileQueryInfoFlags flags,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="_QueryInfo"/> methods.
        /// </summary>
        public static unsafe class QueryInfoMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedQueryInfo Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Lib.Gio.FileInfo.UnmanagedStruct* unmanagedQueryInfo(GISharp.Lib.Gio.File.UnmanagedStruct* file_, byte* attributes_, GISharp.Lib.Gio.FileQueryInfoFlags flags_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var attributes = new GISharp.Lib.GLib.UnownedUtf8(attributes_); var flags = (GISharp.Lib.Gio.FileQueryInfoFlags)flags_; var cancellable = GISharp.Lib.Gio.Cancellable.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doQueryInfo = (_QueryInfo)methodInfo.CreateDelegate(typeof(_QueryInfo), file); var ret = doQueryInfo(attributes, flags, cancellable); var ret_ = (GISharp.Lib.Gio.FileInfo.UnmanagedStruct*)ret.Take(); return ret_; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(GISharp.Lib.Gio.FileInfo.UnmanagedStruct*); }

                return unmanagedQueryInfo;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_QueryInfoAsync']/*" />
        public delegate void _QueryInfoAsync(GISharp.Lib.GLib.UnownedUtf8 attributes, GISharp.Lib.Gio.FileQueryInfoFlags flags, int ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        public unsafe delegate void UnmanagedQueryInfoAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
byte* attributes,
/* <type name="FileQueryInfoFlags" type="GFileQueryInfoFlags" managed-name="FileQueryInfoFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileQueryInfoFlags flags,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
int ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="AsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:6 direction:in */
delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:6 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Class for marshalling <see cref="_QueryInfoAsync"/> methods.
        /// </summary>
        public static unsafe class QueryInfoAsyncMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedQueryInfoAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedQueryInfoAsync(GISharp.Lib.Gio.File.UnmanagedStruct* file_, byte* attributes_, GISharp.Lib.Gio.FileQueryInfoFlags flags_, int ioPriority_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback_, System.IntPtr userData_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var attributes = new GISharp.Lib.GLib.UnownedUtf8(attributes_); var flags = (GISharp.Lib.Gio.FileQueryInfoFlags)flags_; var ioPriority = (int)ioPriority_; var callback = callback_ is null ? default(GISharp.Lib.Gio.AsyncReadyCallback) : GISharp.Lib.Gio.AsyncReadyCallbackMarshal.FromPointer(callback_, userData_); var cancellable = GISharp.Lib.Gio.Cancellable.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doQueryInfoAsync = (_QueryInfoAsync)methodInfo.CreateDelegate(typeof(_QueryInfoAsync), file); doQueryInfoAsync(attributes, flags, ioPriority, callback, cancellable); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } }

                return unmanagedQueryInfoAsync;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_QueryInfoFinish']/*" />
        public delegate GISharp.Lib.Gio.FileInfo _QueryInfoFinish(GISharp.Lib.Gio.IAsyncResult res);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileInfo" type="GFileInfo*" managed-name="FileInfo" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate GISharp.Lib.Gio.FileInfo.UnmanagedStruct* UnmanagedQueryInfoFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="_QueryInfoFinish"/> methods.
        /// </summary>
        public static unsafe class QueryInfoFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedQueryInfoFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Lib.Gio.FileInfo.UnmanagedStruct* unmanagedQueryInfoFinish(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var res = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)res_, GISharp.Runtime.Transfer.None)!; var doQueryInfoFinish = (_QueryInfoFinish)methodInfo.CreateDelegate(typeof(_QueryInfoFinish), file); var ret = doQueryInfoFinish(res); var ret_ = (GISharp.Lib.Gio.FileInfo.UnmanagedStruct*)ret.Take(); return ret_; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(GISharp.Lib.Gio.FileInfo.UnmanagedStruct*); }

                return unmanagedQueryInfoFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_QueryFilesystemInfo']/*" />
        public delegate GISharp.Lib.Gio.FileInfo _QueryFilesystemInfo(GISharp.Lib.GLib.UnownedUtf8 attributes, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileInfo" type="GFileInfo*" managed-name="FileInfo" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate GISharp.Lib.Gio.FileInfo.UnmanagedStruct* UnmanagedQueryFilesystemInfo(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
byte* attributes,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="_QueryFilesystemInfo"/> methods.
        /// </summary>
        public static unsafe class QueryFilesystemInfoMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedQueryFilesystemInfo Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Lib.Gio.FileInfo.UnmanagedStruct* unmanagedQueryFilesystemInfo(GISharp.Lib.Gio.File.UnmanagedStruct* file_, byte* attributes_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var attributes = new GISharp.Lib.GLib.UnownedUtf8(attributes_); var cancellable = GISharp.Lib.Gio.Cancellable.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doQueryFilesystemInfo = (_QueryFilesystemInfo)methodInfo.CreateDelegate(typeof(_QueryFilesystemInfo), file); var ret = doQueryFilesystemInfo(attributes, cancellable); var ret_ = (GISharp.Lib.Gio.FileInfo.UnmanagedStruct*)ret.Take(); return ret_; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(GISharp.Lib.Gio.FileInfo.UnmanagedStruct*); }

                return unmanagedQueryFilesystemInfo;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_QueryFilesystemInfoAsync']/*" />
        public delegate void _QueryFilesystemInfoAsync(GISharp.Lib.GLib.UnownedUtf8 attributes, int ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        public unsafe delegate void UnmanagedQueryFilesystemInfoAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
byte* attributes,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
int ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="AsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:5 direction:in */
delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:5 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Class for marshalling <see cref="_QueryFilesystemInfoAsync"/> methods.
        /// </summary>
        public static unsafe class QueryFilesystemInfoAsyncMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedQueryFilesystemInfoAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedQueryFilesystemInfoAsync(GISharp.Lib.Gio.File.UnmanagedStruct* file_, byte* attributes_, int ioPriority_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback_, System.IntPtr userData_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var attributes = new GISharp.Lib.GLib.UnownedUtf8(attributes_); var ioPriority = (int)ioPriority_; var callback = callback_ is null ? default(GISharp.Lib.Gio.AsyncReadyCallback) : GISharp.Lib.Gio.AsyncReadyCallbackMarshal.FromPointer(callback_, userData_); var cancellable = GISharp.Lib.Gio.Cancellable.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doQueryFilesystemInfoAsync = (_QueryFilesystemInfoAsync)methodInfo.CreateDelegate(typeof(_QueryFilesystemInfoAsync), file); doQueryFilesystemInfoAsync(attributes, ioPriority, callback, cancellable); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } }

                return unmanagedQueryFilesystemInfoAsync;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_QueryFilesystemInfoFinish']/*" />
        public delegate GISharp.Lib.Gio.FileInfo _QueryFilesystemInfoFinish(GISharp.Lib.Gio.IAsyncResult res);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileInfo" type="GFileInfo*" managed-name="FileInfo" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate GISharp.Lib.Gio.FileInfo.UnmanagedStruct* UnmanagedQueryFilesystemInfoFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="_QueryFilesystemInfoFinish"/> methods.
        /// </summary>
        public static unsafe class QueryFilesystemInfoFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedQueryFilesystemInfoFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Lib.Gio.FileInfo.UnmanagedStruct* unmanagedQueryFilesystemInfoFinish(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var res = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)res_, GISharp.Runtime.Transfer.None)!; var doQueryFilesystemInfoFinish = (_QueryFilesystemInfoFinish)methodInfo.CreateDelegate(typeof(_QueryFilesystemInfoFinish), file); var ret = doQueryFilesystemInfoFinish(res); var ret_ = (GISharp.Lib.Gio.FileInfo.UnmanagedStruct*)ret.Take(); return ret_; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(GISharp.Lib.Gio.FileInfo.UnmanagedStruct*); }

                return unmanagedQueryFilesystemInfoFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_FindEnclosingMountAsync']/*" />
        public delegate void _FindEnclosingMountAsync(int ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        public unsafe delegate void UnmanagedFindEnclosingMountAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
int ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="AsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:4 direction:in */
delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:4 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Class for marshalling <see cref="_FindEnclosingMountAsync"/> methods.
        /// </summary>
        public static unsafe class FindEnclosingMountAsyncMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedFindEnclosingMountAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedFindEnclosingMountAsync(GISharp.Lib.Gio.File.UnmanagedStruct* file_, int ioPriority_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback_, System.IntPtr userData_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var ioPriority = (int)ioPriority_; var callback = callback_ is null ? default(GISharp.Lib.Gio.AsyncReadyCallback) : GISharp.Lib.Gio.AsyncReadyCallbackMarshal.FromPointer(callback_, userData_); var cancellable = GISharp.Lib.Gio.Cancellable.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doFindEnclosingMountAsync = (_FindEnclosingMountAsync)methodInfo.CreateDelegate(typeof(_FindEnclosingMountAsync), file); doFindEnclosingMountAsync(ioPriority, callback, cancellable); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } }

                return unmanagedFindEnclosingMountAsync;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_SetDisplayName']/*" />
        public delegate GISharp.Lib.Gio.IFile _SetDisplayName(GISharp.Lib.GLib.UnownedUtf8 displayName, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate GISharp.Lib.Gio.File.UnmanagedStruct* UnmanagedSetDisplayName(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
byte* displayName,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="_SetDisplayName"/> methods.
        /// </summary>
        public static unsafe class SetDisplayNameMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedSetDisplayName Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Lib.Gio.File.UnmanagedStruct* unmanagedSetDisplayName(GISharp.Lib.Gio.File.UnmanagedStruct* file_, byte* displayName_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var displayName = new GISharp.Lib.GLib.UnownedUtf8(displayName_); var cancellable = GISharp.Lib.Gio.Cancellable.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doSetDisplayName = (_SetDisplayName)methodInfo.CreateDelegate(typeof(_SetDisplayName), file); var ret = doSetDisplayName(displayName, cancellable); var ret_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)ret.Take(); return ret_; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(GISharp.Lib.Gio.File.UnmanagedStruct*); }

                return unmanagedSetDisplayName;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_SetDisplayNameAsync']/*" />
        public delegate void _SetDisplayNameAsync(GISharp.Lib.GLib.UnownedUtf8 displayName, int ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        public unsafe delegate void UnmanagedSetDisplayNameAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
byte* displayName,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
int ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="AsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:5 direction:in */
delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:5 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Class for marshalling <see cref="_SetDisplayNameAsync"/> methods.
        /// </summary>
        public static unsafe class SetDisplayNameAsyncMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedSetDisplayNameAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedSetDisplayNameAsync(GISharp.Lib.Gio.File.UnmanagedStruct* file_, byte* displayName_, int ioPriority_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback_, System.IntPtr userData_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var displayName = new GISharp.Lib.GLib.UnownedUtf8(displayName_); var ioPriority = (int)ioPriority_; var callback = callback_ is null ? default(GISharp.Lib.Gio.AsyncReadyCallback) : GISharp.Lib.Gio.AsyncReadyCallbackMarshal.FromPointer(callback_, userData_); var cancellable = GISharp.Lib.Gio.Cancellable.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doSetDisplayNameAsync = (_SetDisplayNameAsync)methodInfo.CreateDelegate(typeof(_SetDisplayNameAsync), file); doSetDisplayNameAsync(displayName, ioPriority, callback, cancellable); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } }

                return unmanagedSetDisplayNameAsync;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_SetDisplayNameFinish']/*" />
        public delegate GISharp.Lib.Gio.IFile _SetDisplayNameFinish(GISharp.Lib.Gio.IAsyncResult res);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate GISharp.Lib.Gio.File.UnmanagedStruct* UnmanagedSetDisplayNameFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="_SetDisplayNameFinish"/> methods.
        /// </summary>
        public static unsafe class SetDisplayNameFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedSetDisplayNameFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Lib.Gio.File.UnmanagedStruct* unmanagedSetDisplayNameFinish(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var res = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)res_, GISharp.Runtime.Transfer.None)!; var doSetDisplayNameFinish = (_SetDisplayNameFinish)methodInfo.CreateDelegate(typeof(_SetDisplayNameFinish), file); var ret = doSetDisplayNameFinish(res); var ret_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)ret.Take(); return ret_; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(GISharp.Lib.Gio.File.UnmanagedStruct*); }

                return unmanagedSetDisplayNameFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_QuerySettableAttributes']/*" />
        public delegate GISharp.Lib.Gio.FileAttributeInfoList _QuerySettableAttributes(GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileAttributeInfoList" type="GFileAttributeInfoList*" managed-name="FileAttributeInfoList" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate GISharp.Lib.Gio.FileAttributeInfoList.UnmanagedStruct* UnmanagedQuerySettableAttributes(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="_QuerySettableAttributes"/> methods.
        /// </summary>
        public static unsafe class QuerySettableAttributesMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedQuerySettableAttributes Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Lib.Gio.FileAttributeInfoList.UnmanagedStruct* unmanagedQuerySettableAttributes(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var cancellable = GISharp.Lib.Gio.Cancellable.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doQuerySettableAttributes = (_QuerySettableAttributes)methodInfo.CreateDelegate(typeof(_QuerySettableAttributes), file); var ret = doQuerySettableAttributes(cancellable); var ret_ = (GISharp.Lib.Gio.FileAttributeInfoList.UnmanagedStruct*)ret.Take(); return ret_; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(GISharp.Lib.Gio.FileAttributeInfoList.UnmanagedStruct*); }

                return unmanagedQuerySettableAttributes;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_QueryWritableNamespaces']/*" />
        public delegate GISharp.Lib.Gio.FileAttributeInfoList _QueryWritableNamespaces(GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileAttributeInfoList" type="GFileAttributeInfoList*" managed-name="FileAttributeInfoList" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate GISharp.Lib.Gio.FileAttributeInfoList.UnmanagedStruct* UnmanagedQueryWritableNamespaces(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="_QueryWritableNamespaces"/> methods.
        /// </summary>
        public static unsafe class QueryWritableNamespacesMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedQueryWritableNamespaces Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Lib.Gio.FileAttributeInfoList.UnmanagedStruct* unmanagedQueryWritableNamespaces(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var cancellable = GISharp.Lib.Gio.Cancellable.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doQueryWritableNamespaces = (_QueryWritableNamespaces)methodInfo.CreateDelegate(typeof(_QueryWritableNamespaces), file); var ret = doQueryWritableNamespaces(cancellable); var ret_ = (GISharp.Lib.Gio.FileAttributeInfoList.UnmanagedStruct*)ret.Take(); return ret_; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(GISharp.Lib.Gio.FileAttributeInfoList.UnmanagedStruct*); }

                return unmanagedQueryWritableNamespaces;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_SetAttribute']/*" />
        public delegate void _SetAttribute(GISharp.Lib.GLib.UnownedUtf8 attribute, GISharp.Lib.Gio.FileAttributeType type, System.IntPtr valueP, GISharp.Lib.Gio.FileQueryInfoFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedSetAttribute(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
byte* attribute,
/* <type name="FileAttributeType" type="GFileAttributeType" managed-name="FileAttributeType" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileAttributeType type,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr valueP,
/* <type name="FileQueryInfoFlags" type="GFileQueryInfoFlags" managed-name="FileQueryInfoFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileQueryInfoFlags flags,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="_SetAttribute"/> methods.
        /// </summary>
        public static unsafe class SetAttributeMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedSetAttribute Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedSetAttribute(GISharp.Lib.Gio.File.UnmanagedStruct* file_, byte* attribute_, GISharp.Lib.Gio.FileAttributeType type_, System.IntPtr valueP_, GISharp.Lib.Gio.FileQueryInfoFlags flags_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var attribute = new GISharp.Lib.GLib.UnownedUtf8(attribute_); var type = (GISharp.Lib.Gio.FileAttributeType)type_; var valueP = (System.IntPtr)valueP_; var flags = (GISharp.Lib.Gio.FileQueryInfoFlags)flags_; var cancellable = GISharp.Lib.Gio.Cancellable.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doSetAttribute = (_SetAttribute)methodInfo.CreateDelegate(typeof(_SetAttribute), file); doSetAttribute(attribute, type, valueP, flags, cancellable); return GISharp.Runtime.Boolean.True; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(GISharp.Runtime.Boolean); }

                return unmanagedSetAttribute;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_SetAttributesFromInfo']/*" />
        public delegate void _SetAttributesFromInfo(GISharp.Lib.Gio.FileInfo info, GISharp.Lib.Gio.FileQueryInfoFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedSetAttributesFromInfo(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="FileInfo" type="GFileInfo*" managed-name="FileInfo" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileInfo.UnmanagedStruct* info,
/* <type name="FileQueryInfoFlags" type="GFileQueryInfoFlags" managed-name="FileQueryInfoFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileQueryInfoFlags flags,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="_SetAttributesFromInfo"/> methods.
        /// </summary>
        public static unsafe class SetAttributesFromInfoMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedSetAttributesFromInfo Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedSetAttributesFromInfo(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.FileInfo.UnmanagedStruct* info_, GISharp.Lib.Gio.FileQueryInfoFlags flags_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var info = GISharp.Lib.Gio.FileInfo.GetInstance<GISharp.Lib.Gio.FileInfo>((System.IntPtr)info_, GISharp.Runtime.Transfer.None)!; var flags = (GISharp.Lib.Gio.FileQueryInfoFlags)flags_; var cancellable = GISharp.Lib.Gio.Cancellable.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doSetAttributesFromInfo = (_SetAttributesFromInfo)methodInfo.CreateDelegate(typeof(_SetAttributesFromInfo), file); doSetAttributesFromInfo(info, flags, cancellable); return GISharp.Runtime.Boolean.True; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(GISharp.Runtime.Boolean); }

                return unmanagedSetAttributesFromInfo;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_SetAttributesAsync']/*" />
        public delegate void _SetAttributesAsync(GISharp.Lib.Gio.FileInfo info, GISharp.Lib.Gio.FileQueryInfoFlags flags, int ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        public unsafe delegate void UnmanagedSetAttributesAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="FileInfo" type="GFileInfo*" managed-name="FileInfo" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileInfo.UnmanagedStruct* info,
/* <type name="FileQueryInfoFlags" type="GFileQueryInfoFlags" managed-name="FileQueryInfoFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileQueryInfoFlags flags,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
int ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="AsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:6 direction:in */
delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:6 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Class for marshalling <see cref="_SetAttributesAsync"/> methods.
        /// </summary>
        public static unsafe class SetAttributesAsyncMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedSetAttributesAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedSetAttributesAsync(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.FileInfo.UnmanagedStruct* info_, GISharp.Lib.Gio.FileQueryInfoFlags flags_, int ioPriority_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback_, System.IntPtr userData_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var info = GISharp.Lib.Gio.FileInfo.GetInstance<GISharp.Lib.Gio.FileInfo>((System.IntPtr)info_, GISharp.Runtime.Transfer.None)!; var flags = (GISharp.Lib.Gio.FileQueryInfoFlags)flags_; var ioPriority = (int)ioPriority_; var callback = callback_ is null ? default(GISharp.Lib.Gio.AsyncReadyCallback) : GISharp.Lib.Gio.AsyncReadyCallbackMarshal.FromPointer(callback_, userData_); var cancellable = GISharp.Lib.Gio.Cancellable.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doSetAttributesAsync = (_SetAttributesAsync)methodInfo.CreateDelegate(typeof(_SetAttributesAsync), file); doSetAttributesAsync(info, flags, ioPriority, callback, cancellable); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } }

                return unmanagedSetAttributesAsync;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_SetAttributesFinish']/*" />
        public delegate void _SetAttributesFinish(GISharp.Lib.Gio.IAsyncResult result, out GISharp.Lib.Gio.FileInfo info);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedSetAttributesFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result,
/* <type name="FileInfo" type="GFileInfo**" managed-name="FileInfo" is-pointer="1" /> */
/* direction:out caller-allocates:0 transfer-ownership:full */
GISharp.Lib.Gio.FileInfo.UnmanagedStruct** info,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="_SetAttributesFinish"/> methods.
        /// </summary>
        public static unsafe class SetAttributesFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedSetAttributesFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedSetAttributesFinish(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result_, GISharp.Lib.Gio.FileInfo.UnmanagedStruct** info_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)result_, GISharp.Runtime.Transfer.None)!; var doSetAttributesFinish = (_SetAttributesFinish)methodInfo.CreateDelegate(typeof(_SetAttributesFinish), file); doSetAttributesFinish(result,out var info); *info_ = (GISharp.Lib.Gio.FileInfo.UnmanagedStruct*)info.Take(); return GISharp.Runtime.Boolean.True; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(GISharp.Runtime.Boolean); }

                return unmanagedSetAttributesFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_ReadFn']/*" />
        public delegate GISharp.Lib.Gio.FileInputStream _ReadFn(GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileInputStream" type="GFileInputStream*" managed-name="FileInputStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate GISharp.Lib.Gio.FileInputStream.UnmanagedStruct* UnmanagedReadFn(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="_ReadFn"/> methods.
        /// </summary>
        public static unsafe class ReadFnMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedReadFn Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Lib.Gio.FileInputStream.UnmanagedStruct* unmanagedReadFn(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var cancellable = GISharp.Lib.Gio.Cancellable.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doReadFn = (_ReadFn)methodInfo.CreateDelegate(typeof(_ReadFn), file); var ret = doReadFn(cancellable); var ret_ = (GISharp.Lib.Gio.FileInputStream.UnmanagedStruct*)ret.Take(); return ret_; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(GISharp.Lib.Gio.FileInputStream.UnmanagedStruct*); }

                return unmanagedReadFn;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_ReadAsync']/*" />
        public delegate void _ReadAsync(int ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        public unsafe delegate void UnmanagedReadAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
int ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="AsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:4 direction:in */
delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:4 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Class for marshalling <see cref="_ReadAsync"/> methods.
        /// </summary>
        public static unsafe class ReadAsyncMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedReadAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedReadAsync(GISharp.Lib.Gio.File.UnmanagedStruct* file_, int ioPriority_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback_, System.IntPtr userData_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var ioPriority = (int)ioPriority_; var callback = callback_ is null ? default(GISharp.Lib.Gio.AsyncReadyCallback) : GISharp.Lib.Gio.AsyncReadyCallbackMarshal.FromPointer(callback_, userData_); var cancellable = GISharp.Lib.Gio.Cancellable.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doReadAsync = (_ReadAsync)methodInfo.CreateDelegate(typeof(_ReadAsync), file); doReadAsync(ioPriority, callback, cancellable); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } }

                return unmanagedReadAsync;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_ReadFinish']/*" />
        public delegate GISharp.Lib.Gio.FileInputStream _ReadFinish(GISharp.Lib.Gio.IAsyncResult res);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileInputStream" type="GFileInputStream*" managed-name="FileInputStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate GISharp.Lib.Gio.FileInputStream.UnmanagedStruct* UnmanagedReadFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="_ReadFinish"/> methods.
        /// </summary>
        public static unsafe class ReadFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedReadFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Lib.Gio.FileInputStream.UnmanagedStruct* unmanagedReadFinish(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var res = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)res_, GISharp.Runtime.Transfer.None)!; var doReadFinish = (_ReadFinish)methodInfo.CreateDelegate(typeof(_ReadFinish), file); var ret = doReadFinish(res); var ret_ = (GISharp.Lib.Gio.FileInputStream.UnmanagedStruct*)ret.Take(); return ret_; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(GISharp.Lib.Gio.FileInputStream.UnmanagedStruct*); }

                return unmanagedReadFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_AppendTo']/*" />
        public delegate GISharp.Lib.Gio.FileOutputStream _AppendTo(GISharp.Lib.Gio.FileCreateFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileOutputStream" type="GFileOutputStream*" managed-name="FileOutputStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct* UnmanagedAppendTo(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="FileCreateFlags" type="GFileCreateFlags" managed-name="FileCreateFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileCreateFlags flags,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="_AppendTo"/> methods.
        /// </summary>
        public static unsafe class AppendToMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedAppendTo Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct* unmanagedAppendTo(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.FileCreateFlags flags_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var flags = (GISharp.Lib.Gio.FileCreateFlags)flags_; var cancellable = GISharp.Lib.Gio.Cancellable.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doAppendTo = (_AppendTo)methodInfo.CreateDelegate(typeof(_AppendTo), file); var ret = doAppendTo(flags, cancellable); var ret_ = (GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct*)ret.Take(); return ret_; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct*); }

                return unmanagedAppendTo;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_AppendToAsync']/*" />
        public delegate void _AppendToAsync(GISharp.Lib.Gio.FileCreateFlags flags, int ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        public unsafe delegate void UnmanagedAppendToAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="FileCreateFlags" type="GFileCreateFlags" managed-name="FileCreateFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileCreateFlags flags,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
int ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="AsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:5 direction:in */
delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:5 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Class for marshalling <see cref="_AppendToAsync"/> methods.
        /// </summary>
        public static unsafe class AppendToAsyncMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedAppendToAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedAppendToAsync(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.FileCreateFlags flags_, int ioPriority_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback_, System.IntPtr userData_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var flags = (GISharp.Lib.Gio.FileCreateFlags)flags_; var ioPriority = (int)ioPriority_; var callback = callback_ is null ? default(GISharp.Lib.Gio.AsyncReadyCallback) : GISharp.Lib.Gio.AsyncReadyCallbackMarshal.FromPointer(callback_, userData_); var cancellable = GISharp.Lib.Gio.Cancellable.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doAppendToAsync = (_AppendToAsync)methodInfo.CreateDelegate(typeof(_AppendToAsync), file); doAppendToAsync(flags, ioPriority, callback, cancellable); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } }

                return unmanagedAppendToAsync;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_AppendToFinish']/*" />
        public delegate GISharp.Lib.Gio.FileOutputStream _AppendToFinish(GISharp.Lib.Gio.IAsyncResult res);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileOutputStream" type="GFileOutputStream*" managed-name="FileOutputStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct* UnmanagedAppendToFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="_AppendToFinish"/> methods.
        /// </summary>
        public static unsafe class AppendToFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedAppendToFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct* unmanagedAppendToFinish(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var res = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)res_, GISharp.Runtime.Transfer.None)!; var doAppendToFinish = (_AppendToFinish)methodInfo.CreateDelegate(typeof(_AppendToFinish), file); var ret = doAppendToFinish(res); var ret_ = (GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct*)ret.Take(); return ret_; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct*); }

                return unmanagedAppendToFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_Create']/*" />
        public delegate GISharp.Lib.Gio.FileOutputStream _Create(GISharp.Lib.Gio.FileCreateFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileOutputStream" type="GFileOutputStream*" managed-name="FileOutputStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct* UnmanagedCreate(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="FileCreateFlags" type="GFileCreateFlags" managed-name="FileCreateFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileCreateFlags flags,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="_Create"/> methods.
        /// </summary>
        public static unsafe class CreateMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedCreate Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct* unmanagedCreate(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.FileCreateFlags flags_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var flags = (GISharp.Lib.Gio.FileCreateFlags)flags_; var cancellable = GISharp.Lib.Gio.Cancellable.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doCreate = (_Create)methodInfo.CreateDelegate(typeof(_Create), file); var ret = doCreate(flags, cancellable); var ret_ = (GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct*)ret.Take(); return ret_; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct*); }

                return unmanagedCreate;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_CreateAsync']/*" />
        public delegate void _CreateAsync(GISharp.Lib.Gio.FileCreateFlags flags, int ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        public unsafe delegate void UnmanagedCreateAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="FileCreateFlags" type="GFileCreateFlags" managed-name="FileCreateFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileCreateFlags flags,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
int ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="AsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:5 direction:in */
delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:5 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Class for marshalling <see cref="_CreateAsync"/> methods.
        /// </summary>
        public static unsafe class CreateAsyncMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedCreateAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedCreateAsync(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.FileCreateFlags flags_, int ioPriority_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback_, System.IntPtr userData_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var flags = (GISharp.Lib.Gio.FileCreateFlags)flags_; var ioPriority = (int)ioPriority_; var callback = callback_ is null ? default(GISharp.Lib.Gio.AsyncReadyCallback) : GISharp.Lib.Gio.AsyncReadyCallbackMarshal.FromPointer(callback_, userData_); var cancellable = GISharp.Lib.Gio.Cancellable.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doCreateAsync = (_CreateAsync)methodInfo.CreateDelegate(typeof(_CreateAsync), file); doCreateAsync(flags, ioPriority, callback, cancellable); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } }

                return unmanagedCreateAsync;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_CreateFinish']/*" />
        public delegate GISharp.Lib.Gio.FileOutputStream _CreateFinish(GISharp.Lib.Gio.IAsyncResult res);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileOutputStream" type="GFileOutputStream*" managed-name="FileOutputStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct* UnmanagedCreateFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="_CreateFinish"/> methods.
        /// </summary>
        public static unsafe class CreateFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedCreateFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct* unmanagedCreateFinish(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var res = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)res_, GISharp.Runtime.Transfer.None)!; var doCreateFinish = (_CreateFinish)methodInfo.CreateDelegate(typeof(_CreateFinish), file); var ret = doCreateFinish(res); var ret_ = (GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct*)ret.Take(); return ret_; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct*); }

                return unmanagedCreateFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_Replace']/*" />
        public delegate GISharp.Lib.Gio.FileOutputStream _Replace(GISharp.Lib.GLib.NullableUnownedUtf8 etag, bool makeBackup, GISharp.Lib.Gio.FileCreateFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileOutputStream" type="GFileOutputStream*" managed-name="FileOutputStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct* UnmanagedReplace(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
byte* etag,
/* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
/* transfer-ownership:none direction:in */
GISharp.Runtime.Boolean makeBackup,
/* <type name="FileCreateFlags" type="GFileCreateFlags" managed-name="FileCreateFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileCreateFlags flags,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="_Replace"/> methods.
        /// </summary>
        public static unsafe class ReplaceMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedReplace Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct* unmanagedReplace(GISharp.Lib.Gio.File.UnmanagedStruct* file_, byte* etag_, GISharp.Runtime.Boolean makeBackup_, GISharp.Lib.Gio.FileCreateFlags flags_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var etag = new GISharp.Lib.GLib.NullableUnownedUtf8(etag_); var makeBackup = GISharp.Runtime.BooleanExtensions.IsTrue(makeBackup_); var flags = (GISharp.Lib.Gio.FileCreateFlags)flags_; var cancellable = GISharp.Lib.Gio.Cancellable.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doReplace = (_Replace)methodInfo.CreateDelegate(typeof(_Replace), file); var ret = doReplace(etag, makeBackup, flags, cancellable); var ret_ = (GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct*)ret.Take(); return ret_; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct*); }

                return unmanagedReplace;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_ReplaceAsync']/*" />
        public delegate void _ReplaceAsync(GISharp.Lib.GLib.NullableUnownedUtf8 etag, bool makeBackup, GISharp.Lib.Gio.FileCreateFlags flags, int ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        public unsafe delegate void UnmanagedReplaceAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
byte* etag,
/* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
/* transfer-ownership:none direction:in */
GISharp.Runtime.Boolean makeBackup,
/* <type name="FileCreateFlags" type="GFileCreateFlags" managed-name="FileCreateFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileCreateFlags flags,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
int ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="AsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:7 direction:in */
delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:7 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Class for marshalling <see cref="_ReplaceAsync"/> methods.
        /// </summary>
        public static unsafe class ReplaceAsyncMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedReplaceAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedReplaceAsync(GISharp.Lib.Gio.File.UnmanagedStruct* file_, byte* etag_, GISharp.Runtime.Boolean makeBackup_, GISharp.Lib.Gio.FileCreateFlags flags_, int ioPriority_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback_, System.IntPtr userData_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var etag = new GISharp.Lib.GLib.NullableUnownedUtf8(etag_); var makeBackup = GISharp.Runtime.BooleanExtensions.IsTrue(makeBackup_); var flags = (GISharp.Lib.Gio.FileCreateFlags)flags_; var ioPriority = (int)ioPriority_; var callback = callback_ is null ? default(GISharp.Lib.Gio.AsyncReadyCallback) : GISharp.Lib.Gio.AsyncReadyCallbackMarshal.FromPointer(callback_, userData_); var cancellable = GISharp.Lib.Gio.Cancellable.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doReplaceAsync = (_ReplaceAsync)methodInfo.CreateDelegate(typeof(_ReplaceAsync), file); doReplaceAsync(etag, makeBackup, flags, ioPriority, callback, cancellable); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } }

                return unmanagedReplaceAsync;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_ReplaceFinish']/*" />
        public delegate GISharp.Lib.Gio.FileOutputStream _ReplaceFinish(GISharp.Lib.Gio.IAsyncResult res);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileOutputStream" type="GFileOutputStream*" managed-name="FileOutputStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct* UnmanagedReplaceFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="_ReplaceFinish"/> methods.
        /// </summary>
        public static unsafe class ReplaceFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedReplaceFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct* unmanagedReplaceFinish(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var res = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)res_, GISharp.Runtime.Transfer.None)!; var doReplaceFinish = (_ReplaceFinish)methodInfo.CreateDelegate(typeof(_ReplaceFinish), file); var ret = doReplaceFinish(res); var ret_ = (GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct*)ret.Take(); return ret_; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct*); }

                return unmanagedReplaceFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_DeleteFile']/*" />
        public delegate void _DeleteFile(GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedDeleteFile(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="_DeleteFile"/> methods.
        /// </summary>
        public static unsafe class DeleteFileMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedDeleteFile Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedDeleteFile(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var cancellable = GISharp.Lib.Gio.Cancellable.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doDeleteFile = (_DeleteFile)methodInfo.CreateDelegate(typeof(_DeleteFile), file); doDeleteFile(cancellable); return GISharp.Runtime.Boolean.True; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(GISharp.Runtime.Boolean); }

                return unmanagedDeleteFile;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_DeleteFileAsync']/*" />
        public delegate void _DeleteFileAsync(int ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        public unsafe delegate void UnmanagedDeleteFileAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
int ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="AsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:4 direction:in */
delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:4 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Class for marshalling <see cref="_DeleteFileAsync"/> methods.
        /// </summary>
        public static unsafe class DeleteFileAsyncMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedDeleteFileAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedDeleteFileAsync(GISharp.Lib.Gio.File.UnmanagedStruct* file_, int ioPriority_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback_, System.IntPtr userData_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var ioPriority = (int)ioPriority_; var callback = callback_ is null ? default(GISharp.Lib.Gio.AsyncReadyCallback) : GISharp.Lib.Gio.AsyncReadyCallbackMarshal.FromPointer(callback_, userData_); var cancellable = GISharp.Lib.Gio.Cancellable.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doDeleteFileAsync = (_DeleteFileAsync)methodInfo.CreateDelegate(typeof(_DeleteFileAsync), file); doDeleteFileAsync(ioPriority, callback, cancellable); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } }

                return unmanagedDeleteFileAsync;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_DeleteFileFinish']/*" />
        public delegate void _DeleteFileFinish(GISharp.Lib.Gio.IAsyncResult result);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedDeleteFileFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="_DeleteFileFinish"/> methods.
        /// </summary>
        public static unsafe class DeleteFileFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedDeleteFileFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedDeleteFileFinish(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)result_, GISharp.Runtime.Transfer.None)!; var doDeleteFileFinish = (_DeleteFileFinish)methodInfo.CreateDelegate(typeof(_DeleteFileFinish), file); doDeleteFileFinish(result); return GISharp.Runtime.Boolean.True; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(GISharp.Runtime.Boolean); }

                return unmanagedDeleteFileFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_Trash']/*" />
        public delegate void _Trash(GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedTrash(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="_Trash"/> methods.
        /// </summary>
        public static unsafe class TrashMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedTrash Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedTrash(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var cancellable = GISharp.Lib.Gio.Cancellable.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doTrash = (_Trash)methodInfo.CreateDelegate(typeof(_Trash), file); doTrash(cancellable); return GISharp.Runtime.Boolean.True; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(GISharp.Runtime.Boolean); }

                return unmanagedTrash;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_TrashAsync']/*" />
        public delegate void _TrashAsync(int ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        public unsafe delegate void UnmanagedTrashAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
int ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="AsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:4 direction:in */
delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:4 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Class for marshalling <see cref="_TrashAsync"/> methods.
        /// </summary>
        public static unsafe class TrashAsyncMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedTrashAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedTrashAsync(GISharp.Lib.Gio.File.UnmanagedStruct* file_, int ioPriority_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback_, System.IntPtr userData_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var ioPriority = (int)ioPriority_; var callback = callback_ is null ? default(GISharp.Lib.Gio.AsyncReadyCallback) : GISharp.Lib.Gio.AsyncReadyCallbackMarshal.FromPointer(callback_, userData_); var cancellable = GISharp.Lib.Gio.Cancellable.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doTrashAsync = (_TrashAsync)methodInfo.CreateDelegate(typeof(_TrashAsync), file); doTrashAsync(ioPriority, callback, cancellable); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } }

                return unmanagedTrashAsync;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_TrashFinish']/*" />
        public delegate void _TrashFinish(GISharp.Lib.Gio.IAsyncResult result);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedTrashFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="_TrashFinish"/> methods.
        /// </summary>
        public static unsafe class TrashFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedTrashFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedTrashFinish(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)result_, GISharp.Runtime.Transfer.None)!; var doTrashFinish = (_TrashFinish)methodInfo.CreateDelegate(typeof(_TrashFinish), file); doTrashFinish(result); return GISharp.Runtime.Boolean.True; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(GISharp.Runtime.Boolean); }

                return unmanagedTrashFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_MakeDirectory']/*" />
        public delegate void _MakeDirectory(GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedMakeDirectory(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="_MakeDirectory"/> methods.
        /// </summary>
        public static unsafe class MakeDirectoryMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedMakeDirectory Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedMakeDirectory(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var cancellable = GISharp.Lib.Gio.Cancellable.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doMakeDirectory = (_MakeDirectory)methodInfo.CreateDelegate(typeof(_MakeDirectory), file); doMakeDirectory(cancellable); return GISharp.Runtime.Boolean.True; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(GISharp.Runtime.Boolean); }

                return unmanagedMakeDirectory;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_MakeDirectoryAsync']/*" />
        public delegate void _MakeDirectoryAsync(int ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        public unsafe delegate void UnmanagedMakeDirectoryAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
int ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="AsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:4 direction:in */
delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:4 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Class for marshalling <see cref="_MakeDirectoryAsync"/> methods.
        /// </summary>
        public static unsafe class MakeDirectoryAsyncMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedMakeDirectoryAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedMakeDirectoryAsync(GISharp.Lib.Gio.File.UnmanagedStruct* file_, int ioPriority_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback_, System.IntPtr userData_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var ioPriority = (int)ioPriority_; var callback = callback_ is null ? default(GISharp.Lib.Gio.AsyncReadyCallback) : GISharp.Lib.Gio.AsyncReadyCallbackMarshal.FromPointer(callback_, userData_); var cancellable = GISharp.Lib.Gio.Cancellable.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doMakeDirectoryAsync = (_MakeDirectoryAsync)methodInfo.CreateDelegate(typeof(_MakeDirectoryAsync), file); doMakeDirectoryAsync(ioPriority, callback, cancellable); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } }

                return unmanagedMakeDirectoryAsync;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_MakeDirectoryFinish']/*" />
        public delegate void _MakeDirectoryFinish(GISharp.Lib.Gio.IAsyncResult result);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedMakeDirectoryFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="_MakeDirectoryFinish"/> methods.
        /// </summary>
        public static unsafe class MakeDirectoryFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedMakeDirectoryFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedMakeDirectoryFinish(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)result_, GISharp.Runtime.Transfer.None)!; var doMakeDirectoryFinish = (_MakeDirectoryFinish)methodInfo.CreateDelegate(typeof(_MakeDirectoryFinish), file); doMakeDirectoryFinish(result); return GISharp.Runtime.Boolean.True; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(GISharp.Runtime.Boolean); }

                return unmanagedMakeDirectoryFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_MakeSymbolicLink']/*" />
        public delegate void _MakeSymbolicLink(GISharp.Lib.GLib.Filename symlinkValue, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedMakeSymbolicLink(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="filename" type="const char*" managed-name="GISharp.Lib.GLib.Filename" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
byte* symlinkValue,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="_MakeSymbolicLink"/> methods.
        /// </summary>
        public static unsafe class MakeSymbolicLinkMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedMakeSymbolicLink Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedMakeSymbolicLink(GISharp.Lib.Gio.File.UnmanagedStruct* file_, byte* symlinkValue_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var symlinkValue = GISharp.Lib.GLib.Filename.GetInstance<GISharp.Lib.GLib.Filename>((System.IntPtr)symlinkValue_, GISharp.Runtime.Transfer.None)!; var cancellable = GISharp.Lib.Gio.Cancellable.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doMakeSymbolicLink = (_MakeSymbolicLink)methodInfo.CreateDelegate(typeof(_MakeSymbolicLink), file); doMakeSymbolicLink(symlinkValue, cancellable); return GISharp.Runtime.Boolean.True; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(GISharp.Runtime.Boolean); }

                return unmanagedMakeSymbolicLink;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_Copy']/*" />
        public delegate void _Copy(GISharp.Lib.Gio.IFile destination, GISharp.Lib.Gio.FileCopyFlags flags, GISharp.Lib.Gio.FileProgressCallback? progressCallback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedCopy(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* source,
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* destination,
/* <type name="FileCopyFlags" type="GFileCopyFlags" managed-name="FileCopyFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileCopyFlags flags,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="FileProgressCallback" type="GFileProgressCallback" managed-name="FileProgressCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:call closure:5 direction:in */
delegate* unmanaged[Cdecl]<long, long, System.IntPtr, void> progressCallback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr progressCallbackData,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="_Copy"/> methods.
        /// </summary>
        public static unsafe class CopyMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedCopy Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedCopy(GISharp.Lib.Gio.File.UnmanagedStruct* source_, GISharp.Lib.Gio.File.UnmanagedStruct* destination_, GISharp.Lib.Gio.FileCopyFlags flags_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, delegate* unmanaged[Cdecl]<long, long, System.IntPtr, void> progressCallback_, System.IntPtr progressCallbackData_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var source = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)source_, GISharp.Runtime.Transfer.None)!; var destination = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)destination_, GISharp.Runtime.Transfer.None)!; var flags = (GISharp.Lib.Gio.FileCopyFlags)flags_; var progressCallback = progressCallback_ is null ? default(GISharp.Lib.Gio.FileProgressCallback) : GISharp.Lib.Gio.FileProgressCallbackMarshal.FromPointer(progressCallback_, progressCallbackData_); var cancellable = GISharp.Lib.Gio.Cancellable.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doCopy = (_Copy)methodInfo.CreateDelegate(typeof(_Copy), source); doCopy(destination, flags, progressCallback, cancellable); return GISharp.Runtime.Boolean.True; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(GISharp.Runtime.Boolean); }

                return unmanagedCopy;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_CopyAsync']/*" />
        public delegate void _CopyAsync(GISharp.Lib.Gio.IFile destination, GISharp.Lib.Gio.FileCopyFlags flags, int ioPriority, GISharp.Lib.Gio.FileProgressCallback? progressCallback, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        public unsafe delegate void UnmanagedCopyAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* source,
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* destination,
/* <type name="FileCopyFlags" type="GFileCopyFlags" managed-name="FileCopyFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileCopyFlags flags,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
int ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="FileProgressCallback" type="GFileProgressCallback" managed-name="FileProgressCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:notified closure:6 direction:in */
delegate* unmanaged[Cdecl]<long, long, System.IntPtr, void> progressCallback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:5 direction:in */
System.IntPtr progressCallbackData,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="AsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:8 direction:in */
delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:7 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Class for marshalling <see cref="_CopyAsync"/> methods.
        /// </summary>
        public static unsafe class CopyAsyncMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedCopyAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedCopyAsync(GISharp.Lib.Gio.File.UnmanagedStruct* source_, GISharp.Lib.Gio.File.UnmanagedStruct* destination_, GISharp.Lib.Gio.FileCopyFlags flags_, int ioPriority_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, delegate* unmanaged[Cdecl]<long, long, System.IntPtr, void> progressCallback_, System.IntPtr progressCallbackData_, delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback_, System.IntPtr userData_) { try { var source = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)source_, GISharp.Runtime.Transfer.None)!; var destination = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)destination_, GISharp.Runtime.Transfer.None)!; var flags = (GISharp.Lib.Gio.FileCopyFlags)flags_; var ioPriority = (int)ioPriority_; var progressCallback = progressCallback_ is null ? default(GISharp.Lib.Gio.FileProgressCallback) : GISharp.Lib.Gio.FileProgressCallbackMarshal.FromPointer(progressCallback_, progressCallbackData_); var callback = callback_ is null ? default(GISharp.Lib.Gio.AsyncReadyCallback) : GISharp.Lib.Gio.AsyncReadyCallbackMarshal.FromPointer(callback_, userData_); var cancellable = GISharp.Lib.Gio.Cancellable.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doCopyAsync = (_CopyAsync)methodInfo.CreateDelegate(typeof(_CopyAsync), source); doCopyAsync(destination, flags, ioPriority, progressCallback, callback, cancellable); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } }

                return unmanagedCopyAsync;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_CopyFinish']/*" />
        public delegate void _CopyFinish(GISharp.Lib.Gio.IAsyncResult res);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedCopyFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="_CopyFinish"/> methods.
        /// </summary>
        public static unsafe class CopyFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedCopyFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedCopyFinish(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var res = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)res_, GISharp.Runtime.Transfer.None)!; var doCopyFinish = (_CopyFinish)methodInfo.CreateDelegate(typeof(_CopyFinish), file); doCopyFinish(res); return GISharp.Runtime.Boolean.True; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(GISharp.Runtime.Boolean); }

                return unmanagedCopyFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_Move']/*" />
        public delegate void _Move(GISharp.Lib.Gio.IFile destination, GISharp.Lib.Gio.FileCopyFlags flags, GISharp.Lib.Gio.FileProgressCallback? progressCallback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedMove(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* source,
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* destination,
/* <type name="FileCopyFlags" type="GFileCopyFlags" managed-name="FileCopyFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileCopyFlags flags,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="FileProgressCallback" type="GFileProgressCallback" managed-name="FileProgressCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:call closure:5 direction:in */
delegate* unmanaged[Cdecl]<long, long, System.IntPtr, void> progressCallback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr progressCallbackData,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="_Move"/> methods.
        /// </summary>
        public static unsafe class MoveMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedMove Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedMove(GISharp.Lib.Gio.File.UnmanagedStruct* source_, GISharp.Lib.Gio.File.UnmanagedStruct* destination_, GISharp.Lib.Gio.FileCopyFlags flags_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, delegate* unmanaged[Cdecl]<long, long, System.IntPtr, void> progressCallback_, System.IntPtr progressCallbackData_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var source = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)source_, GISharp.Runtime.Transfer.None)!; var destination = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)destination_, GISharp.Runtime.Transfer.None)!; var flags = (GISharp.Lib.Gio.FileCopyFlags)flags_; var progressCallback = progressCallback_ is null ? default(GISharp.Lib.Gio.FileProgressCallback) : GISharp.Lib.Gio.FileProgressCallbackMarshal.FromPointer(progressCallback_, progressCallbackData_); var cancellable = GISharp.Lib.Gio.Cancellable.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doMove = (_Move)methodInfo.CreateDelegate(typeof(_Move), source); doMove(destination, flags, progressCallback, cancellable); return GISharp.Runtime.Boolean.True; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(GISharp.Runtime.Boolean); }

                return unmanagedMove;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_MountMountableFinish']/*" />
        public delegate GISharp.Lib.Gio.IFile _MountMountableFinish(GISharp.Lib.Gio.IAsyncResult result);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate GISharp.Lib.Gio.File.UnmanagedStruct* UnmanagedMountMountableFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="_MountMountableFinish"/> methods.
        /// </summary>
        public static unsafe class MountMountableFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedMountMountableFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Lib.Gio.File.UnmanagedStruct* unmanagedMountMountableFinish(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)result_, GISharp.Runtime.Transfer.None)!; var doMountMountableFinish = (_MountMountableFinish)methodInfo.CreateDelegate(typeof(_MountMountableFinish), file); var ret = doMountMountableFinish(result); var ret_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)ret.Take(); return ret_; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(GISharp.Lib.Gio.File.UnmanagedStruct*); }

                return unmanagedMountMountableFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_UnmountMountableFinish']/*" />
        public delegate void _UnmountMountableFinish(GISharp.Lib.Gio.IAsyncResult result);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedUnmountMountableFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="_UnmountMountableFinish"/> methods.
        /// </summary>
        public static unsafe class UnmountMountableFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedUnmountMountableFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedUnmountMountableFinish(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)result_, GISharp.Runtime.Transfer.None)!; var doUnmountMountableFinish = (_UnmountMountableFinish)methodInfo.CreateDelegate(typeof(_UnmountMountableFinish), file); doUnmountMountableFinish(result); return GISharp.Runtime.Boolean.True; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(GISharp.Runtime.Boolean); }

                return unmanagedUnmountMountableFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_EjectMountableFinish']/*" />
        public delegate void _EjectMountableFinish(GISharp.Lib.Gio.IAsyncResult result);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedEjectMountableFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="_EjectMountableFinish"/> methods.
        /// </summary>
        public static unsafe class EjectMountableFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedEjectMountableFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedEjectMountableFinish(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)result_, GISharp.Runtime.Transfer.None)!; var doEjectMountableFinish = (_EjectMountableFinish)methodInfo.CreateDelegate(typeof(_EjectMountableFinish), file); doEjectMountableFinish(result); return GISharp.Runtime.Boolean.True; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(GISharp.Runtime.Boolean); }

                return unmanagedEjectMountableFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_MountEnclosingVolumeFinish']/*" />
        public delegate void _MountEnclosingVolumeFinish(GISharp.Lib.Gio.IAsyncResult result);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedMountEnclosingVolumeFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* location,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="_MountEnclosingVolumeFinish"/> methods.
        /// </summary>
        public static unsafe class MountEnclosingVolumeFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedMountEnclosingVolumeFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedMountEnclosingVolumeFinish(GISharp.Lib.Gio.File.UnmanagedStruct* location_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var location = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)location_, GISharp.Runtime.Transfer.None)!; var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)result_, GISharp.Runtime.Transfer.None)!; var doMountEnclosingVolumeFinish = (_MountEnclosingVolumeFinish)methodInfo.CreateDelegate(typeof(_MountEnclosingVolumeFinish), location); doMountEnclosingVolumeFinish(result); return GISharp.Runtime.Boolean.True; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(GISharp.Runtime.Boolean); }

                return unmanagedMountEnclosingVolumeFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_OpenReadwrite']/*" />
        public delegate GISharp.Lib.Gio.FileIOStream _OpenReadwrite(GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileIOStream" type="GFileIOStream*" managed-name="FileIOStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate GISharp.Lib.Gio.FileIOStream.UnmanagedStruct* UnmanagedOpenReadwrite(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="_OpenReadwrite"/> methods.
        /// </summary>
        public static unsafe class OpenReadwriteMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedOpenReadwrite Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Lib.Gio.FileIOStream.UnmanagedStruct* unmanagedOpenReadwrite(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var cancellable = GISharp.Lib.Gio.Cancellable.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doOpenReadwrite = (_OpenReadwrite)methodInfo.CreateDelegate(typeof(_OpenReadwrite), file); var ret = doOpenReadwrite(cancellable); var ret_ = (GISharp.Lib.Gio.FileIOStream.UnmanagedStruct*)ret.Take(); return ret_; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(GISharp.Lib.Gio.FileIOStream.UnmanagedStruct*); }

                return unmanagedOpenReadwrite;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_OpenReadwriteAsync']/*" />
        public delegate void _OpenReadwriteAsync(int ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        public unsafe delegate void UnmanagedOpenReadwriteAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
int ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="AsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:4 direction:in */
delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:4 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Class for marshalling <see cref="_OpenReadwriteAsync"/> methods.
        /// </summary>
        public static unsafe class OpenReadwriteAsyncMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedOpenReadwriteAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedOpenReadwriteAsync(GISharp.Lib.Gio.File.UnmanagedStruct* file_, int ioPriority_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback_, System.IntPtr userData_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var ioPriority = (int)ioPriority_; var callback = callback_ is null ? default(GISharp.Lib.Gio.AsyncReadyCallback) : GISharp.Lib.Gio.AsyncReadyCallbackMarshal.FromPointer(callback_, userData_); var cancellable = GISharp.Lib.Gio.Cancellable.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doOpenReadwriteAsync = (_OpenReadwriteAsync)methodInfo.CreateDelegate(typeof(_OpenReadwriteAsync), file); doOpenReadwriteAsync(ioPriority, callback, cancellable); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } }

                return unmanagedOpenReadwriteAsync;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_OpenReadwriteFinish']/*" />
        public delegate GISharp.Lib.Gio.FileIOStream _OpenReadwriteFinish(GISharp.Lib.Gio.IAsyncResult res);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileIOStream" type="GFileIOStream*" managed-name="FileIOStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate GISharp.Lib.Gio.FileIOStream.UnmanagedStruct* UnmanagedOpenReadwriteFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="_OpenReadwriteFinish"/> methods.
        /// </summary>
        public static unsafe class OpenReadwriteFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedOpenReadwriteFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Lib.Gio.FileIOStream.UnmanagedStruct* unmanagedOpenReadwriteFinish(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var res = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)res_, GISharp.Runtime.Transfer.None)!; var doOpenReadwriteFinish = (_OpenReadwriteFinish)methodInfo.CreateDelegate(typeof(_OpenReadwriteFinish), file); var ret = doOpenReadwriteFinish(res); var ret_ = (GISharp.Lib.Gio.FileIOStream.UnmanagedStruct*)ret.Take(); return ret_; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(GISharp.Lib.Gio.FileIOStream.UnmanagedStruct*); }

                return unmanagedOpenReadwriteFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_CreateReadwrite']/*" />
        public delegate GISharp.Lib.Gio.FileIOStream _CreateReadwrite(GISharp.Lib.Gio.FileCreateFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileIOStream" type="GFileIOStream*" managed-name="FileIOStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate GISharp.Lib.Gio.FileIOStream.UnmanagedStruct* UnmanagedCreateReadwrite(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="FileCreateFlags" type="GFileCreateFlags" managed-name="FileCreateFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileCreateFlags flags,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="_CreateReadwrite"/> methods.
        /// </summary>
        public static unsafe class CreateReadwriteMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedCreateReadwrite Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Lib.Gio.FileIOStream.UnmanagedStruct* unmanagedCreateReadwrite(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.FileCreateFlags flags_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var flags = (GISharp.Lib.Gio.FileCreateFlags)flags_; var cancellable = GISharp.Lib.Gio.Cancellable.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doCreateReadwrite = (_CreateReadwrite)methodInfo.CreateDelegate(typeof(_CreateReadwrite), file); var ret = doCreateReadwrite(flags, cancellable); var ret_ = (GISharp.Lib.Gio.FileIOStream.UnmanagedStruct*)ret.Take(); return ret_; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(GISharp.Lib.Gio.FileIOStream.UnmanagedStruct*); }

                return unmanagedCreateReadwrite;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_CreateReadwriteAsync']/*" />
        public delegate void _CreateReadwriteAsync(GISharp.Lib.Gio.FileCreateFlags flags, int ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        public unsafe delegate void UnmanagedCreateReadwriteAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="FileCreateFlags" type="GFileCreateFlags" managed-name="FileCreateFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileCreateFlags flags,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
int ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="AsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:5 direction:in */
delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:5 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Class for marshalling <see cref="_CreateReadwriteAsync"/> methods.
        /// </summary>
        public static unsafe class CreateReadwriteAsyncMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedCreateReadwriteAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedCreateReadwriteAsync(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.FileCreateFlags flags_, int ioPriority_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback_, System.IntPtr userData_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var flags = (GISharp.Lib.Gio.FileCreateFlags)flags_; var ioPriority = (int)ioPriority_; var callback = callback_ is null ? default(GISharp.Lib.Gio.AsyncReadyCallback) : GISharp.Lib.Gio.AsyncReadyCallbackMarshal.FromPointer(callback_, userData_); var cancellable = GISharp.Lib.Gio.Cancellable.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doCreateReadwriteAsync = (_CreateReadwriteAsync)methodInfo.CreateDelegate(typeof(_CreateReadwriteAsync), file); doCreateReadwriteAsync(flags, ioPriority, callback, cancellable); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } }

                return unmanagedCreateReadwriteAsync;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_CreateReadwriteFinish']/*" />
        public delegate GISharp.Lib.Gio.FileIOStream _CreateReadwriteFinish(GISharp.Lib.Gio.IAsyncResult res);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileIOStream" type="GFileIOStream*" managed-name="FileIOStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate GISharp.Lib.Gio.FileIOStream.UnmanagedStruct* UnmanagedCreateReadwriteFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="_CreateReadwriteFinish"/> methods.
        /// </summary>
        public static unsafe class CreateReadwriteFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedCreateReadwriteFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Lib.Gio.FileIOStream.UnmanagedStruct* unmanagedCreateReadwriteFinish(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var res = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)res_, GISharp.Runtime.Transfer.None)!; var doCreateReadwriteFinish = (_CreateReadwriteFinish)methodInfo.CreateDelegate(typeof(_CreateReadwriteFinish), file); var ret = doCreateReadwriteFinish(res); var ret_ = (GISharp.Lib.Gio.FileIOStream.UnmanagedStruct*)ret.Take(); return ret_; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(GISharp.Lib.Gio.FileIOStream.UnmanagedStruct*); }

                return unmanagedCreateReadwriteFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_ReplaceReadwrite']/*" />
        public delegate GISharp.Lib.Gio.FileIOStream _ReplaceReadwrite(GISharp.Lib.GLib.NullableUnownedUtf8 etag, bool makeBackup, GISharp.Lib.Gio.FileCreateFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileIOStream" type="GFileIOStream*" managed-name="FileIOStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate GISharp.Lib.Gio.FileIOStream.UnmanagedStruct* UnmanagedReplaceReadwrite(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
byte* etag,
/* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
/* transfer-ownership:none direction:in */
GISharp.Runtime.Boolean makeBackup,
/* <type name="FileCreateFlags" type="GFileCreateFlags" managed-name="FileCreateFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileCreateFlags flags,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="_ReplaceReadwrite"/> methods.
        /// </summary>
        public static unsafe class ReplaceReadwriteMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedReplaceReadwrite Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Lib.Gio.FileIOStream.UnmanagedStruct* unmanagedReplaceReadwrite(GISharp.Lib.Gio.File.UnmanagedStruct* file_, byte* etag_, GISharp.Runtime.Boolean makeBackup_, GISharp.Lib.Gio.FileCreateFlags flags_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var etag = new GISharp.Lib.GLib.NullableUnownedUtf8(etag_); var makeBackup = GISharp.Runtime.BooleanExtensions.IsTrue(makeBackup_); var flags = (GISharp.Lib.Gio.FileCreateFlags)flags_; var cancellable = GISharp.Lib.Gio.Cancellable.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doReplaceReadwrite = (_ReplaceReadwrite)methodInfo.CreateDelegate(typeof(_ReplaceReadwrite), file); var ret = doReplaceReadwrite(etag, makeBackup, flags, cancellable); var ret_ = (GISharp.Lib.Gio.FileIOStream.UnmanagedStruct*)ret.Take(); return ret_; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(GISharp.Lib.Gio.FileIOStream.UnmanagedStruct*); }

                return unmanagedReplaceReadwrite;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_ReplaceReadwriteAsync']/*" />
        public delegate void _ReplaceReadwriteAsync(GISharp.Lib.GLib.NullableUnownedUtf8 etag, bool makeBackup, GISharp.Lib.Gio.FileCreateFlags flags, int ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        public unsafe delegate void UnmanagedReplaceReadwriteAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
byte* etag,
/* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
/* transfer-ownership:none direction:in */
GISharp.Runtime.Boolean makeBackup,
/* <type name="FileCreateFlags" type="GFileCreateFlags" managed-name="FileCreateFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileCreateFlags flags,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
int ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="AsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:7 direction:in */
delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:7 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Class for marshalling <see cref="_ReplaceReadwriteAsync"/> methods.
        /// </summary>
        public static unsafe class ReplaceReadwriteAsyncMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedReplaceReadwriteAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedReplaceReadwriteAsync(GISharp.Lib.Gio.File.UnmanagedStruct* file_, byte* etag_, GISharp.Runtime.Boolean makeBackup_, GISharp.Lib.Gio.FileCreateFlags flags_, int ioPriority_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback_, System.IntPtr userData_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var etag = new GISharp.Lib.GLib.NullableUnownedUtf8(etag_); var makeBackup = GISharp.Runtime.BooleanExtensions.IsTrue(makeBackup_); var flags = (GISharp.Lib.Gio.FileCreateFlags)flags_; var ioPriority = (int)ioPriority_; var callback = callback_ is null ? default(GISharp.Lib.Gio.AsyncReadyCallback) : GISharp.Lib.Gio.AsyncReadyCallbackMarshal.FromPointer(callback_, userData_); var cancellable = GISharp.Lib.Gio.Cancellable.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doReplaceReadwriteAsync = (_ReplaceReadwriteAsync)methodInfo.CreateDelegate(typeof(_ReplaceReadwriteAsync), file); doReplaceReadwriteAsync(etag, makeBackup, flags, ioPriority, callback, cancellable); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } }

                return unmanagedReplaceReadwriteAsync;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_ReplaceReadwriteFinish']/*" />
        public delegate GISharp.Lib.Gio.FileIOStream _ReplaceReadwriteFinish(GISharp.Lib.Gio.IAsyncResult res);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileIOStream" type="GFileIOStream*" managed-name="FileIOStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate GISharp.Lib.Gio.FileIOStream.UnmanagedStruct* UnmanagedReplaceReadwriteFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="_ReplaceReadwriteFinish"/> methods.
        /// </summary>
        public static unsafe class ReplaceReadwriteFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedReplaceReadwriteFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Lib.Gio.FileIOStream.UnmanagedStruct* unmanagedReplaceReadwriteFinish(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var res = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)res_, GISharp.Runtime.Transfer.None)!; var doReplaceReadwriteFinish = (_ReplaceReadwriteFinish)methodInfo.CreateDelegate(typeof(_ReplaceReadwriteFinish), file); var ret = doReplaceReadwriteFinish(res); var ret_ = (GISharp.Lib.Gio.FileIOStream.UnmanagedStruct*)ret.Take(); return ret_; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(GISharp.Lib.Gio.FileIOStream.UnmanagedStruct*); }

                return unmanagedReplaceReadwriteFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_StartMountableFinish']/*" />
        public delegate void _StartMountableFinish(GISharp.Lib.Gio.IAsyncResult result);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedStartMountableFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="_StartMountableFinish"/> methods.
        /// </summary>
        public static unsafe class StartMountableFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedStartMountableFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedStartMountableFinish(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)result_, GISharp.Runtime.Transfer.None)!; var doStartMountableFinish = (_StartMountableFinish)methodInfo.CreateDelegate(typeof(_StartMountableFinish), file); doStartMountableFinish(result); return GISharp.Runtime.Boolean.True; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(GISharp.Runtime.Boolean); }

                return unmanagedStartMountableFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_StopMountableFinish']/*" />
        public delegate void _StopMountableFinish(GISharp.Lib.Gio.IAsyncResult result);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedStopMountableFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="_StopMountableFinish"/> methods.
        /// </summary>
        public static unsafe class StopMountableFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedStopMountableFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedStopMountableFinish(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)result_, GISharp.Runtime.Transfer.None)!; var doStopMountableFinish = (_StopMountableFinish)methodInfo.CreateDelegate(typeof(_StopMountableFinish), file); doStopMountableFinish(result); return GISharp.Runtime.Boolean.True; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(GISharp.Runtime.Boolean); }

                return unmanagedStopMountableFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_UnmountMountableWithOperationFinish']/*" />
        public delegate void _UnmountMountableWithOperationFinish(GISharp.Lib.Gio.IAsyncResult result);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedUnmountMountableWithOperationFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="_UnmountMountableWithOperationFinish"/> methods.
        /// </summary>
        public static unsafe class UnmountMountableWithOperationFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedUnmountMountableWithOperationFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedUnmountMountableWithOperationFinish(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)result_, GISharp.Runtime.Transfer.None)!; var doUnmountMountableWithOperationFinish = (_UnmountMountableWithOperationFinish)methodInfo.CreateDelegate(typeof(_UnmountMountableWithOperationFinish), file); doUnmountMountableWithOperationFinish(result); return GISharp.Runtime.Boolean.True; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(GISharp.Runtime.Boolean); }

                return unmanagedUnmountMountableWithOperationFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_EjectMountableWithOperationFinish']/*" />
        public delegate void _EjectMountableWithOperationFinish(GISharp.Lib.Gio.IAsyncResult result);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedEjectMountableWithOperationFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="_EjectMountableWithOperationFinish"/> methods.
        /// </summary>
        public static unsafe class EjectMountableWithOperationFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedEjectMountableWithOperationFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedEjectMountableWithOperationFinish(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)result_, GISharp.Runtime.Transfer.None)!; var doEjectMountableWithOperationFinish = (_EjectMountableWithOperationFinish)methodInfo.CreateDelegate(typeof(_EjectMountableWithOperationFinish), file); doEjectMountableWithOperationFinish(result); return GISharp.Runtime.Boolean.True; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(GISharp.Runtime.Boolean); }

                return unmanagedEjectMountableWithOperationFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_PollMountable']/*" />
        public delegate void _PollMountable(GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        public unsafe delegate void UnmanagedPollMountable(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="AsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:3 direction:in */
delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:3 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Class for marshalling <see cref="_PollMountable"/> methods.
        /// </summary>
        public static unsafe class PollMountableMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedPollMountable Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedPollMountable(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback_, System.IntPtr userData_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var callback = callback_ is null ? default(GISharp.Lib.Gio.AsyncReadyCallback) : GISharp.Lib.Gio.AsyncReadyCallbackMarshal.FromPointer(callback_, userData_); var cancellable = GISharp.Lib.Gio.Cancellable.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doPollMountable = (_PollMountable)methodInfo.CreateDelegate(typeof(_PollMountable), file); doPollMountable(callback, cancellable); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } }

                return unmanagedPollMountable;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_PollMountableFinish']/*" />
        public delegate void _PollMountableFinish(GISharp.Lib.Gio.IAsyncResult result);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedPollMountableFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="_PollMountableFinish"/> methods.
        /// </summary>
        public static unsafe class PollMountableFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedPollMountableFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedPollMountableFinish(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)result_, GISharp.Runtime.Transfer.None)!; var doPollMountableFinish = (_PollMountableFinish)methodInfo.CreateDelegate(typeof(_PollMountableFinish), file); doPollMountableFinish(result); return GISharp.Runtime.Boolean.True; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(GISharp.Runtime.Boolean); }

                return unmanagedPollMountableFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='_MeasureDiskUsageFinish']/*" />
        public delegate void _MeasureDiskUsageFinish(GISharp.Lib.Gio.IAsyncResult result, out ulong diskUsage, out ulong numDirs, out ulong numFiles);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedMeasureDiskUsageFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result,
/* <type name="guint64" type="guint64*" managed-name="System.UInt64" /> */
/* direction:out caller-allocates:0 transfer-ownership:full optional:1 allow-none:1 */
ulong* diskUsage,
/* <type name="guint64" type="guint64*" managed-name="System.UInt64" /> */
/* direction:out caller-allocates:0 transfer-ownership:full optional:1 allow-none:1 */
ulong* numDirs,
/* <type name="guint64" type="guint64*" managed-name="System.UInt64" /> */
/* direction:out caller-allocates:0 transfer-ownership:full optional:1 allow-none:1 */
ulong* numFiles,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="_MeasureDiskUsageFinish"/> methods.
        /// </summary>
        public static unsafe class MeasureDiskUsageFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedMeasureDiskUsageFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedMeasureDiskUsageFinish(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result_, ulong* diskUsage_, ulong* numDirs_, ulong* numFiles_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)result_, GISharp.Runtime.Transfer.None)!; var doMeasureDiskUsageFinish = (_MeasureDiskUsageFinish)methodInfo.CreateDelegate(typeof(_MeasureDiskUsageFinish), file); doMeasureDiskUsageFinish(result,out var diskUsage,out var numDirs,out var numFiles); *diskUsage_ = (ulong)diskUsage; *numDirs_ = (ulong)numDirs; *numFiles_ = (ulong)numFiles; return GISharp.Runtime.Boolean.True; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Runtime.GMarshal.PushUnhandledException(ex); } return default(GISharp.Runtime.Boolean); }

                return unmanagedMeasureDiskUsageFinish;
            }
        }

        /// <summary>
        /// For internal runtime use only.
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        public FileIface(System.IntPtr handle, GISharp.Runtime.Transfer ownership) : base(handle, ownership)
        {
        }
    }
}