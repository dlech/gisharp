// SPDX-License-Identifier: MIT
// ATTENTION: This file is automatically generated. Do not edit manually.
#nullable enable
namespace GISharp.Lib.Gio
{
    /// <include file="FileIface.xmldoc" path="declaration/member[@name='FileIface']/*" />
    public sealed unsafe class FileIface : GISharp.Lib.GObject.TypeInterface
    {
        /// <summary>
        /// The unmanaged data structure.
        /// </summary>
        public new struct UnmanagedStruct
        {
#pragma warning disable CS0169, CS0649
            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.GIface']/*" />
            public readonly GISharp.Lib.GObject.TypeInterface.UnmanagedStruct GIface;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.Dup']/*" />
            public readonly System.IntPtr Dup;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.Hash']/*" />
            public readonly System.IntPtr Hash;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.Equal']/*" />
            public readonly System.IntPtr Equal;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.IsNative']/*" />
            public readonly System.IntPtr IsNative;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.HasUriScheme']/*" />
            public readonly System.IntPtr HasUriScheme;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.GetUriScheme']/*" />
            public readonly System.IntPtr GetUriScheme;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.GetBasename']/*" />
            public readonly System.IntPtr GetBasename;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.GetPath']/*" />
            public readonly System.IntPtr GetPath;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.GetUri']/*" />
            public readonly System.IntPtr GetUri;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.GetParseName']/*" />
            public readonly System.IntPtr GetParseName;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.GetParent']/*" />
            public readonly System.IntPtr GetParent;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.PrefixMatches']/*" />
            public readonly System.IntPtr PrefixMatches;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.GetRelativePath']/*" />
            public readonly System.IntPtr GetRelativePath;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.ResolveRelativePath']/*" />
            public readonly System.IntPtr ResolveRelativePath;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.GetChildForDisplayName']/*" />
            public readonly System.IntPtr GetChildForDisplayName;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.EnumerateChildren']/*" />
            public readonly System.IntPtr EnumerateChildren;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.EnumerateChildrenAsync']/*" />
            public readonly System.IntPtr EnumerateChildrenAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.EnumerateChildrenFinish']/*" />
            public readonly System.IntPtr EnumerateChildrenFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.QueryInfo']/*" />
            public readonly System.IntPtr QueryInfo;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.QueryInfoAsync']/*" />
            public readonly System.IntPtr QueryInfoAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.QueryInfoFinish']/*" />
            public readonly System.IntPtr QueryInfoFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.QueryFilesystemInfo']/*" />
            public readonly System.IntPtr QueryFilesystemInfo;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.QueryFilesystemInfoAsync']/*" />
            public readonly System.IntPtr QueryFilesystemInfoAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.QueryFilesystemInfoFinish']/*" />
            public readonly System.IntPtr QueryFilesystemInfoFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.FindEnclosingMount']/*" />
            public readonly System.IntPtr FindEnclosingMount;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.FindEnclosingMountAsync']/*" />
            public readonly System.IntPtr FindEnclosingMountAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.FindEnclosingMountFinish']/*" />
            public readonly System.IntPtr FindEnclosingMountFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.SetDisplayName']/*" />
            public readonly System.IntPtr SetDisplayName;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.SetDisplayNameAsync']/*" />
            public readonly System.IntPtr SetDisplayNameAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.SetDisplayNameFinish']/*" />
            public readonly System.IntPtr SetDisplayNameFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.QuerySettableAttributes']/*" />
            public readonly System.IntPtr QuerySettableAttributes;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.QuerySettableAttributesAsync']/*" />
            public readonly System.IntPtr QuerySettableAttributesAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.QuerySettableAttributesFinish']/*" />
            public readonly System.IntPtr QuerySettableAttributesFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.QueryWritableNamespaces']/*" />
            public readonly System.IntPtr QueryWritableNamespaces;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.QueryWritableNamespacesAsync']/*" />
            public readonly System.IntPtr QueryWritableNamespacesAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.QueryWritableNamespacesFinish']/*" />
            public readonly System.IntPtr QueryWritableNamespacesFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.SetAttribute']/*" />
            public readonly System.IntPtr SetAttribute;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.SetAttributesFromInfo']/*" />
            public readonly System.IntPtr SetAttributesFromInfo;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.SetAttributesAsync']/*" />
            public readonly System.IntPtr SetAttributesAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.SetAttributesFinish']/*" />
            public readonly System.IntPtr SetAttributesFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.ReadFn']/*" />
            public readonly System.IntPtr ReadFn;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.ReadAsync']/*" />
            public readonly System.IntPtr ReadAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.ReadFinish']/*" />
            public readonly System.IntPtr ReadFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.AppendTo']/*" />
            public readonly System.IntPtr AppendTo;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.AppendToAsync']/*" />
            public readonly System.IntPtr AppendToAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.AppendToFinish']/*" />
            public readonly System.IntPtr AppendToFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.Create']/*" />
            public readonly System.IntPtr Create;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.CreateAsync']/*" />
            public readonly System.IntPtr CreateAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.CreateFinish']/*" />
            public readonly System.IntPtr CreateFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.Replace']/*" />
            public readonly System.IntPtr Replace;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.ReplaceAsync']/*" />
            public readonly System.IntPtr ReplaceAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.ReplaceFinish']/*" />
            public readonly System.IntPtr ReplaceFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.DeleteFile']/*" />
            public readonly System.IntPtr DeleteFile;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.DeleteFileAsync']/*" />
            public readonly System.IntPtr DeleteFileAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.DeleteFileFinish']/*" />
            public readonly System.IntPtr DeleteFileFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.Trash']/*" />
            public readonly System.IntPtr Trash;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.TrashAsync']/*" />
            public readonly System.IntPtr TrashAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.TrashFinish']/*" />
            public readonly System.IntPtr TrashFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.MakeDirectory']/*" />
            public readonly System.IntPtr MakeDirectory;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.MakeDirectoryAsync']/*" />
            public readonly System.IntPtr MakeDirectoryAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.MakeDirectoryFinish']/*" />
            public readonly System.IntPtr MakeDirectoryFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.MakeSymbolicLink']/*" />
            public readonly System.IntPtr MakeSymbolicLink;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.MakeSymbolicLinkAsync']/*" />
            public readonly System.IntPtr MakeSymbolicLinkAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.MakeSymbolicLinkFinish']/*" />
            public readonly System.IntPtr MakeSymbolicLinkFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.Copy']/*" />
            public readonly System.IntPtr Copy;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.CopyAsync']/*" />
            public readonly System.IntPtr CopyAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.CopyFinish']/*" />
            public readonly System.IntPtr CopyFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.Move']/*" />
            public readonly System.IntPtr Move;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.MoveAsync']/*" />
            public readonly System.IntPtr MoveAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.MoveFinish']/*" />
            public readonly System.IntPtr MoveFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.MountMountable']/*" />
            public readonly System.IntPtr MountMountable;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.MountMountableFinish']/*" />
            public readonly System.IntPtr MountMountableFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.UnmountMountable']/*" />
            public readonly System.IntPtr UnmountMountable;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.UnmountMountableFinish']/*" />
            public readonly System.IntPtr UnmountMountableFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.EjectMountable']/*" />
            public readonly System.IntPtr EjectMountable;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.EjectMountableFinish']/*" />
            public readonly System.IntPtr EjectMountableFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.MountEnclosingVolume']/*" />
            public readonly System.IntPtr MountEnclosingVolume;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.MountEnclosingVolumeFinish']/*" />
            public readonly System.IntPtr MountEnclosingVolumeFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.MonitorDir']/*" />
            public readonly System.IntPtr MonitorDir;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.MonitorFile']/*" />
            public readonly System.IntPtr MonitorFile;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.OpenReadwrite']/*" />
            public readonly System.IntPtr OpenReadwrite;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.OpenReadwriteAsync']/*" />
            public readonly System.IntPtr OpenReadwriteAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.OpenReadwriteFinish']/*" />
            public readonly System.IntPtr OpenReadwriteFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.CreateReadwrite']/*" />
            public readonly System.IntPtr CreateReadwrite;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.CreateReadwriteAsync']/*" />
            public readonly System.IntPtr CreateReadwriteAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.CreateReadwriteFinish']/*" />
            public readonly System.IntPtr CreateReadwriteFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.ReplaceReadwrite']/*" />
            public readonly System.IntPtr ReplaceReadwrite;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.ReplaceReadwriteAsync']/*" />
            public readonly System.IntPtr ReplaceReadwriteAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.ReplaceReadwriteFinish']/*" />
            public readonly System.IntPtr ReplaceReadwriteFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.StartMountable']/*" />
            public readonly System.IntPtr StartMountable;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.StartMountableFinish']/*" />
            public readonly System.IntPtr StartMountableFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.StopMountable']/*" />
            public readonly System.IntPtr StopMountable;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.StopMountableFinish']/*" />
            public readonly System.IntPtr StopMountableFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.SupportsThreadContexts']/*" />
            public readonly GISharp.Runtime.Boolean SupportsThreadContexts;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.UnmountMountableWithOperation']/*" />
            public readonly System.IntPtr UnmountMountableWithOperation;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.UnmountMountableWithOperationFinish']/*" />
            public readonly System.IntPtr UnmountMountableWithOperationFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.EjectMountableWithOperation']/*" />
            public readonly System.IntPtr EjectMountableWithOperation;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.EjectMountableWithOperationFinish']/*" />
            public readonly System.IntPtr EjectMountableWithOperationFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.PollMountable']/*" />
            public readonly System.IntPtr PollMountable;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.PollMountableFinish']/*" />
            public readonly System.IntPtr PollMountableFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.MeasureDiskUsage']/*" />
            public readonly System.IntPtr MeasureDiskUsage;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.MeasureDiskUsageAsync']/*" />
            public readonly System.IntPtr MeasureDiskUsageAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmanagedStruct.MeasureDiskUsageFinish']/*" />
            public readonly System.IntPtr MeasureDiskUsageFinish;
#pragma warning restore CS0169, CS0649
        }

        static FileIface()
        {
            System.Int32 dupOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.Dup));
            RegisterVirtualMethod(dupOffset, DupMarshal.Create);
            System.Int32 hashOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.Hash));
            RegisterVirtualMethod(hashOffset, HashMarshal.Create);
            System.Int32 equalOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.Equal));
            RegisterVirtualMethod(equalOffset, EqualMarshal.Create);
            System.Int32 isNativeOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.IsNative));
            RegisterVirtualMethod(isNativeOffset, IsNativeMarshal.Create);
            System.Int32 hasUriSchemeOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.HasUriScheme));
            RegisterVirtualMethod(hasUriSchemeOffset, HasUriSchemeMarshal.Create);
            System.Int32 getUriSchemeOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.GetUriScheme));
            RegisterVirtualMethod(getUriSchemeOffset, GetUriSchemeMarshal.Create);
            System.Int32 getBasenameOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.GetBasename));
            RegisterVirtualMethod(getBasenameOffset, GetBasenameMarshal.Create);
            System.Int32 getPathOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.GetPath));
            RegisterVirtualMethod(getPathOffset, GetPathMarshal.Create);
            System.Int32 getUriOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.GetUri));
            RegisterVirtualMethod(getUriOffset, GetUriMarshal.Create);
            System.Int32 getParseNameOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.GetParseName));
            RegisterVirtualMethod(getParseNameOffset, GetParseNameMarshal.Create);
            System.Int32 getParentOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.GetParent));
            RegisterVirtualMethod(getParentOffset, GetParentMarshal.Create);
            System.Int32 prefixMatchesOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.PrefixMatches));
            RegisterVirtualMethod(prefixMatchesOffset, PrefixMatchesMarshal.Create);
            System.Int32 getRelativePathOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.GetRelativePath));
            RegisterVirtualMethod(getRelativePathOffset, GetRelativePathMarshal.Create);
            System.Int32 resolveRelativePathOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.ResolveRelativePath));
            RegisterVirtualMethod(resolveRelativePathOffset, ResolveRelativePathMarshal.Create);
            System.Int32 getChildForDisplayNameOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.GetChildForDisplayName));
            RegisterVirtualMethod(getChildForDisplayNameOffset, GetChildForDisplayNameMarshal.Create);
            System.Int32 enumerateChildrenAsyncOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.EnumerateChildrenAsync));
            RegisterVirtualMethod(enumerateChildrenAsyncOffset, EnumerateChildrenAsyncMarshal.Create);
            System.Int32 queryInfoOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.QueryInfo));
            RegisterVirtualMethod(queryInfoOffset, QueryInfoMarshal.Create);
            System.Int32 queryInfoAsyncOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.QueryInfoAsync));
            RegisterVirtualMethod(queryInfoAsyncOffset, QueryInfoAsyncMarshal.Create);
            System.Int32 queryInfoFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.QueryInfoFinish));
            RegisterVirtualMethod(queryInfoFinishOffset, QueryInfoFinishMarshal.Create);
            System.Int32 queryFilesystemInfoOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.QueryFilesystemInfo));
            RegisterVirtualMethod(queryFilesystemInfoOffset, QueryFilesystemInfoMarshal.Create);
            System.Int32 queryFilesystemInfoAsyncOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.QueryFilesystemInfoAsync));
            RegisterVirtualMethod(queryFilesystemInfoAsyncOffset, QueryFilesystemInfoAsyncMarshal.Create);
            System.Int32 queryFilesystemInfoFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.QueryFilesystemInfoFinish));
            RegisterVirtualMethod(queryFilesystemInfoFinishOffset, QueryFilesystemInfoFinishMarshal.Create);
            System.Int32 findEnclosingMountAsyncOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.FindEnclosingMountAsync));
            RegisterVirtualMethod(findEnclosingMountAsyncOffset, FindEnclosingMountAsyncMarshal.Create);
            System.Int32 setDisplayNameOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.SetDisplayName));
            RegisterVirtualMethod(setDisplayNameOffset, SetDisplayNameMarshal.Create);
            System.Int32 setDisplayNameAsyncOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.SetDisplayNameAsync));
            RegisterVirtualMethod(setDisplayNameAsyncOffset, SetDisplayNameAsyncMarshal.Create);
            System.Int32 setDisplayNameFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.SetDisplayNameFinish));
            RegisterVirtualMethod(setDisplayNameFinishOffset, SetDisplayNameFinishMarshal.Create);
            System.Int32 querySettableAttributesOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.QuerySettableAttributes));
            RegisterVirtualMethod(querySettableAttributesOffset, QuerySettableAttributesMarshal.Create);
            System.Int32 queryWritableNamespacesOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.QueryWritableNamespaces));
            RegisterVirtualMethod(queryWritableNamespacesOffset, QueryWritableNamespacesMarshal.Create);
            System.Int32 setAttributeOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.SetAttribute));
            RegisterVirtualMethod(setAttributeOffset, SetAttributeMarshal.Create);
            System.Int32 setAttributesFromInfoOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.SetAttributesFromInfo));
            RegisterVirtualMethod(setAttributesFromInfoOffset, SetAttributesFromInfoMarshal.Create);
            System.Int32 setAttributesAsyncOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.SetAttributesAsync));
            RegisterVirtualMethod(setAttributesAsyncOffset, SetAttributesAsyncMarshal.Create);
            System.Int32 setAttributesFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.SetAttributesFinish));
            RegisterVirtualMethod(setAttributesFinishOffset, SetAttributesFinishMarshal.Create);
            System.Int32 readFnOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.ReadFn));
            RegisterVirtualMethod(readFnOffset, ReadFnMarshal.Create);
            System.Int32 readAsyncOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.ReadAsync));
            RegisterVirtualMethod(readAsyncOffset, ReadAsyncMarshal.Create);
            System.Int32 readFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.ReadFinish));
            RegisterVirtualMethod(readFinishOffset, ReadFinishMarshal.Create);
            System.Int32 appendToOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.AppendTo));
            RegisterVirtualMethod(appendToOffset, AppendToMarshal.Create);
            System.Int32 appendToAsyncOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.AppendToAsync));
            RegisterVirtualMethod(appendToAsyncOffset, AppendToAsyncMarshal.Create);
            System.Int32 appendToFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.AppendToFinish));
            RegisterVirtualMethod(appendToFinishOffset, AppendToFinishMarshal.Create);
            System.Int32 createOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.Create));
            RegisterVirtualMethod(createOffset, CreateMarshal.Create);
            System.Int32 createAsyncOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.CreateAsync));
            RegisterVirtualMethod(createAsyncOffset, CreateAsyncMarshal.Create);
            System.Int32 createFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.CreateFinish));
            RegisterVirtualMethod(createFinishOffset, CreateFinishMarshal.Create);
            System.Int32 replaceOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.Replace));
            RegisterVirtualMethod(replaceOffset, ReplaceMarshal.Create);
            System.Int32 replaceAsyncOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.ReplaceAsync));
            RegisterVirtualMethod(replaceAsyncOffset, ReplaceAsyncMarshal.Create);
            System.Int32 replaceFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.ReplaceFinish));
            RegisterVirtualMethod(replaceFinishOffset, ReplaceFinishMarshal.Create);
            System.Int32 deleteFileOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.DeleteFile));
            RegisterVirtualMethod(deleteFileOffset, DeleteFileMarshal.Create);
            System.Int32 deleteFileAsyncOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.DeleteFileAsync));
            RegisterVirtualMethod(deleteFileAsyncOffset, DeleteFileAsyncMarshal.Create);
            System.Int32 deleteFileFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.DeleteFileFinish));
            RegisterVirtualMethod(deleteFileFinishOffset, DeleteFileFinishMarshal.Create);
            System.Int32 trashOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.Trash));
            RegisterVirtualMethod(trashOffset, TrashMarshal.Create);
            System.Int32 trashAsyncOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.TrashAsync));
            RegisterVirtualMethod(trashAsyncOffset, TrashAsyncMarshal.Create);
            System.Int32 trashFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.TrashFinish));
            RegisterVirtualMethod(trashFinishOffset, TrashFinishMarshal.Create);
            System.Int32 makeDirectoryOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.MakeDirectory));
            RegisterVirtualMethod(makeDirectoryOffset, MakeDirectoryMarshal.Create);
            System.Int32 makeDirectoryAsyncOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.MakeDirectoryAsync));
            RegisterVirtualMethod(makeDirectoryAsyncOffset, MakeDirectoryAsyncMarshal.Create);
            System.Int32 makeDirectoryFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.MakeDirectoryFinish));
            RegisterVirtualMethod(makeDirectoryFinishOffset, MakeDirectoryFinishMarshal.Create);
            System.Int32 makeSymbolicLinkOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.MakeSymbolicLink));
            RegisterVirtualMethod(makeSymbolicLinkOffset, MakeSymbolicLinkMarshal.Create);
            System.Int32 copyOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.Copy));
            RegisterVirtualMethod(copyOffset, CopyMarshal.Create);
            System.Int32 copyAsyncOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.CopyAsync));
            RegisterVirtualMethod(copyAsyncOffset, CopyAsyncMarshal.Create);
            System.Int32 copyFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.CopyFinish));
            RegisterVirtualMethod(copyFinishOffset, CopyFinishMarshal.Create);
            System.Int32 moveOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.Move));
            RegisterVirtualMethod(moveOffset, MoveMarshal.Create);
            System.Int32 mountMountableFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.MountMountableFinish));
            RegisterVirtualMethod(mountMountableFinishOffset, MountMountableFinishMarshal.Create);
            System.Int32 unmountMountableFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.UnmountMountableFinish));
            RegisterVirtualMethod(unmountMountableFinishOffset, UnmountMountableFinishMarshal.Create);
            System.Int32 ejectMountableFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.EjectMountableFinish));
            RegisterVirtualMethod(ejectMountableFinishOffset, EjectMountableFinishMarshal.Create);
            System.Int32 mountEnclosingVolumeFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.MountEnclosingVolumeFinish));
            RegisterVirtualMethod(mountEnclosingVolumeFinishOffset, MountEnclosingVolumeFinishMarshal.Create);
            System.Int32 openReadwriteOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.OpenReadwrite));
            RegisterVirtualMethod(openReadwriteOffset, OpenReadwriteMarshal.Create);
            System.Int32 openReadwriteAsyncOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.OpenReadwriteAsync));
            RegisterVirtualMethod(openReadwriteAsyncOffset, OpenReadwriteAsyncMarshal.Create);
            System.Int32 openReadwriteFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.OpenReadwriteFinish));
            RegisterVirtualMethod(openReadwriteFinishOffset, OpenReadwriteFinishMarshal.Create);
            System.Int32 createReadwriteOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.CreateReadwrite));
            RegisterVirtualMethod(createReadwriteOffset, CreateReadwriteMarshal.Create);
            System.Int32 createReadwriteAsyncOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.CreateReadwriteAsync));
            RegisterVirtualMethod(createReadwriteAsyncOffset, CreateReadwriteAsyncMarshal.Create);
            System.Int32 createReadwriteFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.CreateReadwriteFinish));
            RegisterVirtualMethod(createReadwriteFinishOffset, CreateReadwriteFinishMarshal.Create);
            System.Int32 replaceReadwriteOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.ReplaceReadwrite));
            RegisterVirtualMethod(replaceReadwriteOffset, ReplaceReadwriteMarshal.Create);
            System.Int32 replaceReadwriteAsyncOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.ReplaceReadwriteAsync));
            RegisterVirtualMethod(replaceReadwriteAsyncOffset, ReplaceReadwriteAsyncMarshal.Create);
            System.Int32 replaceReadwriteFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.ReplaceReadwriteFinish));
            RegisterVirtualMethod(replaceReadwriteFinishOffset, ReplaceReadwriteFinishMarshal.Create);
            System.Int32 startMountableFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.StartMountableFinish));
            RegisterVirtualMethod(startMountableFinishOffset, StartMountableFinishMarshal.Create);
            System.Int32 stopMountableFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.StopMountableFinish));
            RegisterVirtualMethod(stopMountableFinishOffset, StopMountableFinishMarshal.Create);
            System.Int32 unmountMountableWithOperationFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.UnmountMountableWithOperationFinish));
            RegisterVirtualMethod(unmountMountableWithOperationFinishOffset, UnmountMountableWithOperationFinishMarshal.Create);
            System.Int32 ejectMountableWithOperationFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.EjectMountableWithOperationFinish));
            RegisterVirtualMethod(ejectMountableWithOperationFinishOffset, EjectMountableWithOperationFinishMarshal.Create);
            System.Int32 pollMountableOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.PollMountable));
            RegisterVirtualMethod(pollMountableOffset, PollMountableMarshal.Create);
            System.Int32 pollMountableFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.PollMountableFinish));
            RegisterVirtualMethod(pollMountableFinishOffset, PollMountableFinishMarshal.Create);
            System.Int32 measureDiskUsageFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<UnmanagedStruct>(nameof(UnmanagedStruct.MeasureDiskUsageFinish));
            RegisterVirtualMethod(measureDiskUsageFinishOffset, MeasureDiskUsageFinishMarshal.Create);
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='Dup']/*" />
        public delegate GISharp.Lib.Gio.IFile Dup();

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate GISharp.Lib.Gio.File.UnmanagedStruct* UnmanagedDup(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file);

        /// <summary>
        /// Class for marshalling <see cref="Dup"/> methods.
        /// </summary>
        public static unsafe class DupMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedDup Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Lib.Gio.File.UnmanagedStruct* unmanagedDup(GISharp.Lib.Gio.File.UnmanagedStruct* file_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var doDup = (Dup)methodInfo.CreateDelegate(typeof(Dup), file); var ret = doDup(); var ret_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)ret.Take(); return ret_; } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(GISharp.Lib.Gio.File.UnmanagedStruct*); }

                return unmanagedDup;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='Hash']/*" />
        public delegate System.UInt32 Hash();

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        public unsafe delegate System.UInt32 UnmanagedHash(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file);

        /// <summary>
        /// Class for marshalling <see cref="Hash"/> methods.
        /// </summary>
        public static unsafe class HashMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedHash Create(System.Reflection.MethodInfo methodInfo)
            {
                System.UInt32 unmanagedHash(GISharp.Lib.Gio.File.UnmanagedStruct* file_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var doHash = (Hash)methodInfo.CreateDelegate(typeof(Hash), file); var ret = doHash(); var ret_ = (System.UInt32)ret; return ret_; } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(System.UInt32); }

                return unmanagedHash;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='Equal']/*" />
        public delegate System.Boolean Equal(GISharp.Lib.Gio.IFile file2);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedEqual(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file1,
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file2);

        /// <summary>
        /// Class for marshalling <see cref="Equal"/> methods.
        /// </summary>
        public static unsafe class EqualMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedEqual Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedEqual(GISharp.Lib.Gio.File.UnmanagedStruct* file1_, GISharp.Lib.Gio.File.UnmanagedStruct* file2_) { try { var file1 = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file1_, GISharp.Runtime.Transfer.None)!; var file2 = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file2_, GISharp.Runtime.Transfer.None)!; var doEqual = (Equal)methodInfo.CreateDelegate(typeof(Equal), file1); var ret = doEqual(file2); var ret_ = GISharp.Runtime.BooleanExtensions.ToBoolean(ret); return ret_; } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(GISharp.Runtime.Boolean); }

                return unmanagedEqual;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='IsNative']/*" />
        public delegate System.Boolean IsNative();

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedIsNative(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file);

        /// <summary>
        /// Class for marshalling <see cref="IsNative"/> methods.
        /// </summary>
        public static unsafe class IsNativeMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedIsNative Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedIsNative(GISharp.Lib.Gio.File.UnmanagedStruct* file_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var doIsNative = (IsNative)methodInfo.CreateDelegate(typeof(IsNative), file); var ret = doIsNative(); var ret_ = GISharp.Runtime.BooleanExtensions.ToBoolean(ret); return ret_; } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(GISharp.Runtime.Boolean); }

                return unmanagedIsNative;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='HasUriScheme']/*" />
        public delegate System.Boolean HasUriScheme(GISharp.Lib.GLib.UnownedUtf8 uriScheme);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedHasUriScheme(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.Byte* uriScheme);

        /// <summary>
        /// Class for marshalling <see cref="HasUriScheme"/> methods.
        /// </summary>
        public static unsafe class HasUriSchemeMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedHasUriScheme Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedHasUriScheme(GISharp.Lib.Gio.File.UnmanagedStruct* file_, System.Byte* uriScheme_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var uriScheme = new GISharp.Lib.GLib.UnownedUtf8(uriScheme_); var doHasUriScheme = (HasUriScheme)methodInfo.CreateDelegate(typeof(HasUriScheme), file); var ret = doHasUriScheme(uriScheme); var ret_ = GISharp.Runtime.BooleanExtensions.ToBoolean(ret); return ret_; } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(GISharp.Runtime.Boolean); }

                return unmanagedHasUriScheme;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='GetUriScheme']/*" />
        public delegate GISharp.Lib.GLib.Utf8 GetUriScheme();

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate System.Byte* UnmanagedGetUriScheme(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file);

        /// <summary>
        /// Class for marshalling <see cref="GetUriScheme"/> methods.
        /// </summary>
        public static unsafe class GetUriSchemeMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedGetUriScheme Create(System.Reflection.MethodInfo methodInfo)
            {
                System.Byte* unmanagedGetUriScheme(GISharp.Lib.Gio.File.UnmanagedStruct* file_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var doGetUriScheme = (GetUriScheme)methodInfo.CreateDelegate(typeof(GetUriScheme), file); var ret = doGetUriScheme(); var ret_ = (System.Byte*)ret.Take(); return ret_; } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(System.Byte*); }

                return unmanagedGetUriScheme;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='GetBasename']/*" />
        public delegate GISharp.Lib.GLib.Utf8 GetBasename();

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate System.Byte* UnmanagedGetBasename(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file);

        /// <summary>
        /// Class for marshalling <see cref="GetBasename"/> methods.
        /// </summary>
        public static unsafe class GetBasenameMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedGetBasename Create(System.Reflection.MethodInfo methodInfo)
            {
                System.Byte* unmanagedGetBasename(GISharp.Lib.Gio.File.UnmanagedStruct* file_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var doGetBasename = (GetBasename)methodInfo.CreateDelegate(typeof(GetBasename), file); var ret = doGetBasename(); var ret_ = (System.Byte*)ret.Take(); return ret_; } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(System.Byte*); }

                return unmanagedGetBasename;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='GetPath']/*" />
        public delegate GISharp.Lib.GLib.Utf8 GetPath();

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate System.Byte* UnmanagedGetPath(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file);

        /// <summary>
        /// Class for marshalling <see cref="GetPath"/> methods.
        /// </summary>
        public static unsafe class GetPathMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedGetPath Create(System.Reflection.MethodInfo methodInfo)
            {
                System.Byte* unmanagedGetPath(GISharp.Lib.Gio.File.UnmanagedStruct* file_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var doGetPath = (GetPath)methodInfo.CreateDelegate(typeof(GetPath), file); var ret = doGetPath(); var ret_ = (System.Byte*)ret.Take(); return ret_; } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(System.Byte*); }

                return unmanagedGetPath;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='GetUri']/*" />
        public delegate GISharp.Lib.GLib.Utf8 GetUri();

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate System.Byte* UnmanagedGetUri(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file);

        /// <summary>
        /// Class for marshalling <see cref="GetUri"/> methods.
        /// </summary>
        public static unsafe class GetUriMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedGetUri Create(System.Reflection.MethodInfo methodInfo)
            {
                System.Byte* unmanagedGetUri(GISharp.Lib.Gio.File.UnmanagedStruct* file_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var doGetUri = (GetUri)methodInfo.CreateDelegate(typeof(GetUri), file); var ret = doGetUri(); var ret_ = (System.Byte*)ret.Take(); return ret_; } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(System.Byte*); }

                return unmanagedGetUri;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='GetParseName']/*" />
        public delegate GISharp.Lib.GLib.Utf8 GetParseName();

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate System.Byte* UnmanagedGetParseName(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file);

        /// <summary>
        /// Class for marshalling <see cref="GetParseName"/> methods.
        /// </summary>
        public static unsafe class GetParseNameMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedGetParseName Create(System.Reflection.MethodInfo methodInfo)
            {
                System.Byte* unmanagedGetParseName(GISharp.Lib.Gio.File.UnmanagedStruct* file_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var doGetParseName = (GetParseName)methodInfo.CreateDelegate(typeof(GetParseName), file); var ret = doGetParseName(); var ret_ = (System.Byte*)ret.Take(); return ret_; } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(System.Byte*); }

                return unmanagedGetParseName;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='GetParent']/*" />
        public delegate GISharp.Lib.Gio.IFile? GetParent();

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
        /* transfer-ownership:full nullable:1 direction:in */
        public unsafe delegate GISharp.Lib.Gio.File.UnmanagedStruct* UnmanagedGetParent(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file);

        /// <summary>
        /// Class for marshalling <see cref="GetParent"/> methods.
        /// </summary>
        public static unsafe class GetParentMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedGetParent Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Lib.Gio.File.UnmanagedStruct* unmanagedGetParent(GISharp.Lib.Gio.File.UnmanagedStruct* file_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var doGetParent = (GetParent)methodInfo.CreateDelegate(typeof(GetParent), file); var ret = doGetParent(); var ret_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)(ret?.Take() ?? System.IntPtr.Zero); return ret_; } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(GISharp.Lib.Gio.File.UnmanagedStruct*); }

                return unmanagedGetParent;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='PrefixMatches']/*" />
        public delegate System.Boolean PrefixMatches(GISharp.Lib.Gio.IFile file);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedPrefixMatches(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* prefix,
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file);

        /// <summary>
        /// Class for marshalling <see cref="PrefixMatches"/> methods.
        /// </summary>
        public static unsafe class PrefixMatchesMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedPrefixMatches Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedPrefixMatches(GISharp.Lib.Gio.File.UnmanagedStruct* prefix_, GISharp.Lib.Gio.File.UnmanagedStruct* file_) { try { var prefix = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)prefix_, GISharp.Runtime.Transfer.None)!; var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var doPrefixMatches = (PrefixMatches)methodInfo.CreateDelegate(typeof(PrefixMatches), prefix); var ret = doPrefixMatches(file); var ret_ = GISharp.Runtime.BooleanExtensions.ToBoolean(ret); return ret_; } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(GISharp.Runtime.Boolean); }

                return unmanagedPrefixMatches;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='GetRelativePath']/*" />
        public delegate GISharp.Lib.GLib.Utf8 GetRelativePath(GISharp.Lib.Gio.IFile descendant);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate System.Byte* UnmanagedGetRelativePath(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* parent,
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* descendant);

        /// <summary>
        /// Class for marshalling <see cref="GetRelativePath"/> methods.
        /// </summary>
        public static unsafe class GetRelativePathMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedGetRelativePath Create(System.Reflection.MethodInfo methodInfo)
            {
                System.Byte* unmanagedGetRelativePath(GISharp.Lib.Gio.File.UnmanagedStruct* parent_, GISharp.Lib.Gio.File.UnmanagedStruct* descendant_) { try { var parent = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)parent_, GISharp.Runtime.Transfer.None)!; var descendant = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)descendant_, GISharp.Runtime.Transfer.None)!; var doGetRelativePath = (GetRelativePath)methodInfo.CreateDelegate(typeof(GetRelativePath), parent); var ret = doGetRelativePath(descendant); var ret_ = (System.Byte*)ret.Take(); return ret_; } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(System.Byte*); }

                return unmanagedGetRelativePath;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='ResolveRelativePath']/*" />
        public delegate GISharp.Lib.Gio.IFile ResolveRelativePath(GISharp.Lib.GLib.Filename relativePath);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate GISharp.Lib.Gio.File.UnmanagedStruct* UnmanagedResolveRelativePath(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="filename" type="const char*" managed-name="GISharp.Lib.GLib.Filename" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.Byte* relativePath);

        /// <summary>
        /// Class for marshalling <see cref="ResolveRelativePath"/> methods.
        /// </summary>
        public static unsafe class ResolveRelativePathMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedResolveRelativePath Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Lib.Gio.File.UnmanagedStruct* unmanagedResolveRelativePath(GISharp.Lib.Gio.File.UnmanagedStruct* file_, System.Byte* relativePath_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var relativePath = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Filename>((System.IntPtr)relativePath_, GISharp.Runtime.Transfer.None)!; var doResolveRelativePath = (ResolveRelativePath)methodInfo.CreateDelegate(typeof(ResolveRelativePath), file); var ret = doResolveRelativePath(relativePath); var ret_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)ret.Take(); return ret_; } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(GISharp.Lib.Gio.File.UnmanagedStruct*); }

                return unmanagedResolveRelativePath;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='GetChildForDisplayName']/*" />
        public delegate GISharp.Lib.Gio.IFile GetChildForDisplayName(GISharp.Lib.GLib.UnownedUtf8 displayName);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate GISharp.Lib.Gio.File.UnmanagedStruct* UnmanagedGetChildForDisplayName(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.Byte* displayName,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="GetChildForDisplayName"/> methods.
        /// </summary>
        public static unsafe class GetChildForDisplayNameMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedGetChildForDisplayName Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Lib.Gio.File.UnmanagedStruct* unmanagedGetChildForDisplayName(GISharp.Lib.Gio.File.UnmanagedStruct* file_, System.Byte* displayName_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var displayName = new GISharp.Lib.GLib.UnownedUtf8(displayName_); var doGetChildForDisplayName = (GetChildForDisplayName)methodInfo.CreateDelegate(typeof(GetChildForDisplayName), file); var ret = doGetChildForDisplayName(displayName); var ret_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)ret.Take(); return ret_; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(GISharp.Lib.Gio.File.UnmanagedStruct*); }

                return unmanagedGetChildForDisplayName;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='EnumerateChildrenAsync']/*" />
        public delegate void EnumerateChildrenAsync(GISharp.Lib.GLib.UnownedUtf8 attributes, GISharp.Lib.Gio.FileQueryInfoFlags flags, System.Int32 ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        public unsafe delegate void UnmanagedEnumerateChildrenAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.Byte* attributes,
/* <type name="FileQueryInfoFlags" type="GFileQueryInfoFlags" managed-name="FileQueryInfoFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileQueryInfoFlags flags,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
System.Int32 ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="AsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:6 direction:in */
System.IntPtr callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:6 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Class for marshalling <see cref="EnumerateChildrenAsync"/> methods.
        /// </summary>
        public static unsafe class EnumerateChildrenAsyncMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedEnumerateChildrenAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedEnumerateChildrenAsync(GISharp.Lib.Gio.File.UnmanagedStruct* file_, System.Byte* attributes_, GISharp.Lib.Gio.FileQueryInfoFlags flags_, System.Int32 ioPriority_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, System.IntPtr callback_, System.IntPtr userData_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var attributes = new GISharp.Lib.GLib.UnownedUtf8(attributes_); var flags = (GISharp.Lib.Gio.FileQueryInfoFlags)flags_; var ioPriority = (System.Int32)ioPriority_; var callback = callback_ == System.IntPtr.Zero ? default(GISharp.Lib.Gio.AsyncReadyCallback) : GISharp.Lib.Gio.AsyncReadyCallbackMarshal.FromPointer(callback_, userData_); var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doEnumerateChildrenAsync = (EnumerateChildrenAsync)methodInfo.CreateDelegate(typeof(EnumerateChildrenAsync), file); doEnumerateChildrenAsync(attributes, flags, ioPriority, callback, cancellable); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } }

                return unmanagedEnumerateChildrenAsync;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='QueryInfo']/*" />
        public delegate GISharp.Lib.Gio.FileInfo QueryInfo(GISharp.Lib.GLib.UnownedUtf8 attributes, GISharp.Lib.Gio.FileQueryInfoFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileInfo" type="GFileInfo*" managed-name="FileInfo" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate GISharp.Lib.Gio.FileInfo.UnmanagedStruct* UnmanagedQueryInfo(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.Byte* attributes,
/* <type name="FileQueryInfoFlags" type="GFileQueryInfoFlags" managed-name="FileQueryInfoFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileQueryInfoFlags flags,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="QueryInfo"/> methods.
        /// </summary>
        public static unsafe class QueryInfoMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedQueryInfo Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Lib.Gio.FileInfo.UnmanagedStruct* unmanagedQueryInfo(GISharp.Lib.Gio.File.UnmanagedStruct* file_, System.Byte* attributes_, GISharp.Lib.Gio.FileQueryInfoFlags flags_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var attributes = new GISharp.Lib.GLib.UnownedUtf8(attributes_); var flags = (GISharp.Lib.Gio.FileQueryInfoFlags)flags_; var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doQueryInfo = (QueryInfo)methodInfo.CreateDelegate(typeof(QueryInfo), file); var ret = doQueryInfo(attributes, flags, cancellable); var ret_ = (GISharp.Lib.Gio.FileInfo.UnmanagedStruct*)ret.Take(); return ret_; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(GISharp.Lib.Gio.FileInfo.UnmanagedStruct*); }

                return unmanagedQueryInfo;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='QueryInfoAsync']/*" />
        public delegate void QueryInfoAsync(GISharp.Lib.GLib.UnownedUtf8 attributes, GISharp.Lib.Gio.FileQueryInfoFlags flags, System.Int32 ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        public unsafe delegate void UnmanagedQueryInfoAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.Byte* attributes,
/* <type name="FileQueryInfoFlags" type="GFileQueryInfoFlags" managed-name="FileQueryInfoFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileQueryInfoFlags flags,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
System.Int32 ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="AsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:6 direction:in */
System.IntPtr callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:6 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Class for marshalling <see cref="QueryInfoAsync"/> methods.
        /// </summary>
        public static unsafe class QueryInfoAsyncMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedQueryInfoAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedQueryInfoAsync(GISharp.Lib.Gio.File.UnmanagedStruct* file_, System.Byte* attributes_, GISharp.Lib.Gio.FileQueryInfoFlags flags_, System.Int32 ioPriority_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, System.IntPtr callback_, System.IntPtr userData_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var attributes = new GISharp.Lib.GLib.UnownedUtf8(attributes_); var flags = (GISharp.Lib.Gio.FileQueryInfoFlags)flags_; var ioPriority = (System.Int32)ioPriority_; var callback = callback_ == System.IntPtr.Zero ? default(GISharp.Lib.Gio.AsyncReadyCallback) : GISharp.Lib.Gio.AsyncReadyCallbackMarshal.FromPointer(callback_, userData_); var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doQueryInfoAsync = (QueryInfoAsync)methodInfo.CreateDelegate(typeof(QueryInfoAsync), file); doQueryInfoAsync(attributes, flags, ioPriority, callback, cancellable); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } }

                return unmanagedQueryInfoAsync;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='QueryInfoFinish']/*" />
        public delegate GISharp.Lib.Gio.FileInfo QueryInfoFinish(GISharp.Lib.Gio.IAsyncResult res);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileInfo" type="GFileInfo*" managed-name="FileInfo" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate GISharp.Lib.Gio.FileInfo.UnmanagedStruct* UnmanagedQueryInfoFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="QueryInfoFinish"/> methods.
        /// </summary>
        public static unsafe class QueryInfoFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedQueryInfoFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Lib.Gio.FileInfo.UnmanagedStruct* unmanagedQueryInfoFinish(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var res = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)res_, GISharp.Runtime.Transfer.None)!; var doQueryInfoFinish = (QueryInfoFinish)methodInfo.CreateDelegate(typeof(QueryInfoFinish), file); var ret = doQueryInfoFinish(res); var ret_ = (GISharp.Lib.Gio.FileInfo.UnmanagedStruct*)ret.Take(); return ret_; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(GISharp.Lib.Gio.FileInfo.UnmanagedStruct*); }

                return unmanagedQueryInfoFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='QueryFilesystemInfo']/*" />
        public delegate GISharp.Lib.Gio.FileInfo QueryFilesystemInfo(GISharp.Lib.GLib.UnownedUtf8 attributes, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileInfo" type="GFileInfo*" managed-name="FileInfo" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate GISharp.Lib.Gio.FileInfo.UnmanagedStruct* UnmanagedQueryFilesystemInfo(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.Byte* attributes,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="QueryFilesystemInfo"/> methods.
        /// </summary>
        public static unsafe class QueryFilesystemInfoMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedQueryFilesystemInfo Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Lib.Gio.FileInfo.UnmanagedStruct* unmanagedQueryFilesystemInfo(GISharp.Lib.Gio.File.UnmanagedStruct* file_, System.Byte* attributes_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var attributes = new GISharp.Lib.GLib.UnownedUtf8(attributes_); var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doQueryFilesystemInfo = (QueryFilesystemInfo)methodInfo.CreateDelegate(typeof(QueryFilesystemInfo), file); var ret = doQueryFilesystemInfo(attributes, cancellable); var ret_ = (GISharp.Lib.Gio.FileInfo.UnmanagedStruct*)ret.Take(); return ret_; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(GISharp.Lib.Gio.FileInfo.UnmanagedStruct*); }

                return unmanagedQueryFilesystemInfo;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='QueryFilesystemInfoAsync']/*" />
        public delegate void QueryFilesystemInfoAsync(GISharp.Lib.GLib.UnownedUtf8 attributes, System.Int32 ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        public unsafe delegate void UnmanagedQueryFilesystemInfoAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.Byte* attributes,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
System.Int32 ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="AsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:5 direction:in */
System.IntPtr callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:5 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Class for marshalling <see cref="QueryFilesystemInfoAsync"/> methods.
        /// </summary>
        public static unsafe class QueryFilesystemInfoAsyncMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedQueryFilesystemInfoAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedQueryFilesystemInfoAsync(GISharp.Lib.Gio.File.UnmanagedStruct* file_, System.Byte* attributes_, System.Int32 ioPriority_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, System.IntPtr callback_, System.IntPtr userData_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var attributes = new GISharp.Lib.GLib.UnownedUtf8(attributes_); var ioPriority = (System.Int32)ioPriority_; var callback = callback_ == System.IntPtr.Zero ? default(GISharp.Lib.Gio.AsyncReadyCallback) : GISharp.Lib.Gio.AsyncReadyCallbackMarshal.FromPointer(callback_, userData_); var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doQueryFilesystemInfoAsync = (QueryFilesystemInfoAsync)methodInfo.CreateDelegate(typeof(QueryFilesystemInfoAsync), file); doQueryFilesystemInfoAsync(attributes, ioPriority, callback, cancellable); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } }

                return unmanagedQueryFilesystemInfoAsync;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='QueryFilesystemInfoFinish']/*" />
        public delegate GISharp.Lib.Gio.FileInfo QueryFilesystemInfoFinish(GISharp.Lib.Gio.IAsyncResult res);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileInfo" type="GFileInfo*" managed-name="FileInfo" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate GISharp.Lib.Gio.FileInfo.UnmanagedStruct* UnmanagedQueryFilesystemInfoFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="QueryFilesystemInfoFinish"/> methods.
        /// </summary>
        public static unsafe class QueryFilesystemInfoFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedQueryFilesystemInfoFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Lib.Gio.FileInfo.UnmanagedStruct* unmanagedQueryFilesystemInfoFinish(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var res = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)res_, GISharp.Runtime.Transfer.None)!; var doQueryFilesystemInfoFinish = (QueryFilesystemInfoFinish)methodInfo.CreateDelegate(typeof(QueryFilesystemInfoFinish), file); var ret = doQueryFilesystemInfoFinish(res); var ret_ = (GISharp.Lib.Gio.FileInfo.UnmanagedStruct*)ret.Take(); return ret_; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(GISharp.Lib.Gio.FileInfo.UnmanagedStruct*); }

                return unmanagedQueryFilesystemInfoFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='FindEnclosingMountAsync']/*" />
        public delegate void FindEnclosingMountAsync(System.Int32 ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        public unsafe delegate void UnmanagedFindEnclosingMountAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
System.Int32 ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="AsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:4 direction:in */
System.IntPtr callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:4 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Class for marshalling <see cref="FindEnclosingMountAsync"/> methods.
        /// </summary>
        public static unsafe class FindEnclosingMountAsyncMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedFindEnclosingMountAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedFindEnclosingMountAsync(GISharp.Lib.Gio.File.UnmanagedStruct* file_, System.Int32 ioPriority_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, System.IntPtr callback_, System.IntPtr userData_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var ioPriority = (System.Int32)ioPriority_; var callback = callback_ == System.IntPtr.Zero ? default(GISharp.Lib.Gio.AsyncReadyCallback) : GISharp.Lib.Gio.AsyncReadyCallbackMarshal.FromPointer(callback_, userData_); var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doFindEnclosingMountAsync = (FindEnclosingMountAsync)methodInfo.CreateDelegate(typeof(FindEnclosingMountAsync), file); doFindEnclosingMountAsync(ioPriority, callback, cancellable); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } }

                return unmanagedFindEnclosingMountAsync;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='SetDisplayName']/*" />
        public delegate GISharp.Lib.Gio.IFile SetDisplayName(GISharp.Lib.GLib.UnownedUtf8 displayName, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate GISharp.Lib.Gio.File.UnmanagedStruct* UnmanagedSetDisplayName(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.Byte* displayName,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="SetDisplayName"/> methods.
        /// </summary>
        public static unsafe class SetDisplayNameMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedSetDisplayName Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Lib.Gio.File.UnmanagedStruct* unmanagedSetDisplayName(GISharp.Lib.Gio.File.UnmanagedStruct* file_, System.Byte* displayName_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var displayName = new GISharp.Lib.GLib.UnownedUtf8(displayName_); var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doSetDisplayName = (SetDisplayName)methodInfo.CreateDelegate(typeof(SetDisplayName), file); var ret = doSetDisplayName(displayName, cancellable); var ret_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)ret.Take(); return ret_; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(GISharp.Lib.Gio.File.UnmanagedStruct*); }

                return unmanagedSetDisplayName;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='SetDisplayNameAsync']/*" />
        public delegate void SetDisplayNameAsync(GISharp.Lib.GLib.UnownedUtf8 displayName, System.Int32 ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        public unsafe delegate void UnmanagedSetDisplayNameAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.Byte* displayName,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
System.Int32 ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="AsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:5 direction:in */
System.IntPtr callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:5 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Class for marshalling <see cref="SetDisplayNameAsync"/> methods.
        /// </summary>
        public static unsafe class SetDisplayNameAsyncMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedSetDisplayNameAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedSetDisplayNameAsync(GISharp.Lib.Gio.File.UnmanagedStruct* file_, System.Byte* displayName_, System.Int32 ioPriority_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, System.IntPtr callback_, System.IntPtr userData_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var displayName = new GISharp.Lib.GLib.UnownedUtf8(displayName_); var ioPriority = (System.Int32)ioPriority_; var callback = callback_ == System.IntPtr.Zero ? default(GISharp.Lib.Gio.AsyncReadyCallback) : GISharp.Lib.Gio.AsyncReadyCallbackMarshal.FromPointer(callback_, userData_); var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doSetDisplayNameAsync = (SetDisplayNameAsync)methodInfo.CreateDelegate(typeof(SetDisplayNameAsync), file); doSetDisplayNameAsync(displayName, ioPriority, callback, cancellable); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } }

                return unmanagedSetDisplayNameAsync;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='SetDisplayNameFinish']/*" />
        public delegate GISharp.Lib.Gio.IFile SetDisplayNameFinish(GISharp.Lib.Gio.IAsyncResult res);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate GISharp.Lib.Gio.File.UnmanagedStruct* UnmanagedSetDisplayNameFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="SetDisplayNameFinish"/> methods.
        /// </summary>
        public static unsafe class SetDisplayNameFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedSetDisplayNameFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Lib.Gio.File.UnmanagedStruct* unmanagedSetDisplayNameFinish(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var res = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)res_, GISharp.Runtime.Transfer.None)!; var doSetDisplayNameFinish = (SetDisplayNameFinish)methodInfo.CreateDelegate(typeof(SetDisplayNameFinish), file); var ret = doSetDisplayNameFinish(res); var ret_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)ret.Take(); return ret_; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(GISharp.Lib.Gio.File.UnmanagedStruct*); }

                return unmanagedSetDisplayNameFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='QuerySettableAttributes']/*" />
        public delegate GISharp.Lib.Gio.FileAttributeInfoList QuerySettableAttributes(GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileAttributeInfoList" type="GFileAttributeInfoList*" managed-name="FileAttributeInfoList" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate GISharp.Lib.Gio.FileAttributeInfoList.UnmanagedStruct* UnmanagedQuerySettableAttributes(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="QuerySettableAttributes"/> methods.
        /// </summary>
        public static unsafe class QuerySettableAttributesMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedQuerySettableAttributes Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Lib.Gio.FileAttributeInfoList.UnmanagedStruct* unmanagedQuerySettableAttributes(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doQuerySettableAttributes = (QuerySettableAttributes)methodInfo.CreateDelegate(typeof(QuerySettableAttributes), file); var ret = doQuerySettableAttributes(cancellable); var ret_ = (GISharp.Lib.Gio.FileAttributeInfoList.UnmanagedStruct*)ret.Take(); return ret_; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(GISharp.Lib.Gio.FileAttributeInfoList.UnmanagedStruct*); }

                return unmanagedQuerySettableAttributes;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='QueryWritableNamespaces']/*" />
        public delegate GISharp.Lib.Gio.FileAttributeInfoList QueryWritableNamespaces(GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileAttributeInfoList" type="GFileAttributeInfoList*" managed-name="FileAttributeInfoList" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate GISharp.Lib.Gio.FileAttributeInfoList.UnmanagedStruct* UnmanagedQueryWritableNamespaces(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="QueryWritableNamespaces"/> methods.
        /// </summary>
        public static unsafe class QueryWritableNamespacesMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedQueryWritableNamespaces Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Lib.Gio.FileAttributeInfoList.UnmanagedStruct* unmanagedQueryWritableNamespaces(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doQueryWritableNamespaces = (QueryWritableNamespaces)methodInfo.CreateDelegate(typeof(QueryWritableNamespaces), file); var ret = doQueryWritableNamespaces(cancellable); var ret_ = (GISharp.Lib.Gio.FileAttributeInfoList.UnmanagedStruct*)ret.Take(); return ret_; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(GISharp.Lib.Gio.FileAttributeInfoList.UnmanagedStruct*); }

                return unmanagedQueryWritableNamespaces;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='SetAttribute']/*" />
        public delegate void SetAttribute(GISharp.Lib.GLib.UnownedUtf8 attribute, GISharp.Lib.Gio.FileAttributeType type, System.IntPtr valueP, GISharp.Lib.Gio.FileQueryInfoFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedSetAttribute(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.Byte* attribute,
/* <type name="FileAttributeType" type="GFileAttributeType" managed-name="FileAttributeType" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileAttributeType type,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr valueP,
/* <type name="FileQueryInfoFlags" type="GFileQueryInfoFlags" managed-name="FileQueryInfoFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileQueryInfoFlags flags,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="SetAttribute"/> methods.
        /// </summary>
        public static unsafe class SetAttributeMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedSetAttribute Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedSetAttribute(GISharp.Lib.Gio.File.UnmanagedStruct* file_, System.Byte* attribute_, GISharp.Lib.Gio.FileAttributeType type_, System.IntPtr valueP_, GISharp.Lib.Gio.FileQueryInfoFlags flags_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var attribute = new GISharp.Lib.GLib.UnownedUtf8(attribute_); var type = (GISharp.Lib.Gio.FileAttributeType)type_; var valueP = (System.IntPtr)valueP_; var flags = (GISharp.Lib.Gio.FileQueryInfoFlags)flags_; var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doSetAttribute = (SetAttribute)methodInfo.CreateDelegate(typeof(SetAttribute), file); doSetAttribute(attribute, type, valueP, flags, cancellable); return GISharp.Runtime.Boolean.True; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(GISharp.Runtime.Boolean); }

                return unmanagedSetAttribute;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='SetAttributesFromInfo']/*" />
        public delegate void SetAttributesFromInfo(GISharp.Lib.Gio.FileInfo info, GISharp.Lib.Gio.FileQueryInfoFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedSetAttributesFromInfo(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="FileInfo" type="GFileInfo*" managed-name="FileInfo" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileInfo.UnmanagedStruct* info,
/* <type name="FileQueryInfoFlags" type="GFileQueryInfoFlags" managed-name="FileQueryInfoFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileQueryInfoFlags flags,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="SetAttributesFromInfo"/> methods.
        /// </summary>
        public static unsafe class SetAttributesFromInfoMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedSetAttributesFromInfo Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedSetAttributesFromInfo(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.FileInfo.UnmanagedStruct* info_, GISharp.Lib.Gio.FileQueryInfoFlags flags_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var info = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.FileInfo>((System.IntPtr)info_, GISharp.Runtime.Transfer.None)!; var flags = (GISharp.Lib.Gio.FileQueryInfoFlags)flags_; var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doSetAttributesFromInfo = (SetAttributesFromInfo)methodInfo.CreateDelegate(typeof(SetAttributesFromInfo), file); doSetAttributesFromInfo(info, flags, cancellable); return GISharp.Runtime.Boolean.True; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(GISharp.Runtime.Boolean); }

                return unmanagedSetAttributesFromInfo;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='SetAttributesAsync']/*" />
        public delegate void SetAttributesAsync(GISharp.Lib.Gio.FileInfo info, GISharp.Lib.Gio.FileQueryInfoFlags flags, System.Int32 ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        public unsafe delegate void UnmanagedSetAttributesAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="FileInfo" type="GFileInfo*" managed-name="FileInfo" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileInfo.UnmanagedStruct* info,
/* <type name="FileQueryInfoFlags" type="GFileQueryInfoFlags" managed-name="FileQueryInfoFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileQueryInfoFlags flags,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
System.Int32 ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="AsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:6 direction:in */
System.IntPtr callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:6 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Class for marshalling <see cref="SetAttributesAsync"/> methods.
        /// </summary>
        public static unsafe class SetAttributesAsyncMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedSetAttributesAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedSetAttributesAsync(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.FileInfo.UnmanagedStruct* info_, GISharp.Lib.Gio.FileQueryInfoFlags flags_, System.Int32 ioPriority_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, System.IntPtr callback_, System.IntPtr userData_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var info = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.FileInfo>((System.IntPtr)info_, GISharp.Runtime.Transfer.None)!; var flags = (GISharp.Lib.Gio.FileQueryInfoFlags)flags_; var ioPriority = (System.Int32)ioPriority_; var callback = callback_ == System.IntPtr.Zero ? default(GISharp.Lib.Gio.AsyncReadyCallback) : GISharp.Lib.Gio.AsyncReadyCallbackMarshal.FromPointer(callback_, userData_); var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doSetAttributesAsync = (SetAttributesAsync)methodInfo.CreateDelegate(typeof(SetAttributesAsync), file); doSetAttributesAsync(info, flags, ioPriority, callback, cancellable); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } }

                return unmanagedSetAttributesAsync;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='SetAttributesFinish']/*" />
        public delegate void SetAttributesFinish(GISharp.Lib.Gio.IAsyncResult result, out GISharp.Lib.Gio.FileInfo info);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedSetAttributesFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result,
/* <type name="FileInfo" type="GFileInfo**" managed-name="FileInfo" is-pointer="1" /> */
/* direction:out caller-allocates:0 transfer-ownership:full */
GISharp.Lib.Gio.FileInfo.UnmanagedStruct** info,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="SetAttributesFinish"/> methods.
        /// </summary>
        public static unsafe class SetAttributesFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedSetAttributesFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedSetAttributesFinish(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result_, GISharp.Lib.Gio.FileInfo.UnmanagedStruct** info_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)result_, GISharp.Runtime.Transfer.None)!; var doSetAttributesFinish = (SetAttributesFinish)methodInfo.CreateDelegate(typeof(SetAttributesFinish), file); doSetAttributesFinish(result,out var info); *info_ = (GISharp.Lib.Gio.FileInfo.UnmanagedStruct*)info.Take(); return GISharp.Runtime.Boolean.True; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(GISharp.Runtime.Boolean); }

                return unmanagedSetAttributesFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='ReadFn']/*" />
        public delegate GISharp.Lib.Gio.FileInputStream ReadFn(GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileInputStream" type="GFileInputStream*" managed-name="FileInputStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate GISharp.Lib.Gio.FileInputStream.UnmanagedStruct* UnmanagedReadFn(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="ReadFn"/> methods.
        /// </summary>
        public static unsafe class ReadFnMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedReadFn Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Lib.Gio.FileInputStream.UnmanagedStruct* unmanagedReadFn(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doReadFn = (ReadFn)methodInfo.CreateDelegate(typeof(ReadFn), file); var ret = doReadFn(cancellable); var ret_ = (GISharp.Lib.Gio.FileInputStream.UnmanagedStruct*)ret.Take(); return ret_; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(GISharp.Lib.Gio.FileInputStream.UnmanagedStruct*); }

                return unmanagedReadFn;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='ReadAsync']/*" />
        public delegate void ReadAsync(System.Int32 ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        public unsafe delegate void UnmanagedReadAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
System.Int32 ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="AsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:4 direction:in */
System.IntPtr callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:4 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Class for marshalling <see cref="ReadAsync"/> methods.
        /// </summary>
        public static unsafe class ReadAsyncMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedReadAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedReadAsync(GISharp.Lib.Gio.File.UnmanagedStruct* file_, System.Int32 ioPriority_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, System.IntPtr callback_, System.IntPtr userData_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var ioPriority = (System.Int32)ioPriority_; var callback = callback_ == System.IntPtr.Zero ? default(GISharp.Lib.Gio.AsyncReadyCallback) : GISharp.Lib.Gio.AsyncReadyCallbackMarshal.FromPointer(callback_, userData_); var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doReadAsync = (ReadAsync)methodInfo.CreateDelegate(typeof(ReadAsync), file); doReadAsync(ioPriority, callback, cancellable); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } }

                return unmanagedReadAsync;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='ReadFinish']/*" />
        public delegate GISharp.Lib.Gio.FileInputStream ReadFinish(GISharp.Lib.Gio.IAsyncResult res);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileInputStream" type="GFileInputStream*" managed-name="FileInputStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate GISharp.Lib.Gio.FileInputStream.UnmanagedStruct* UnmanagedReadFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="ReadFinish"/> methods.
        /// </summary>
        public static unsafe class ReadFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedReadFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Lib.Gio.FileInputStream.UnmanagedStruct* unmanagedReadFinish(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var res = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)res_, GISharp.Runtime.Transfer.None)!; var doReadFinish = (ReadFinish)methodInfo.CreateDelegate(typeof(ReadFinish), file); var ret = doReadFinish(res); var ret_ = (GISharp.Lib.Gio.FileInputStream.UnmanagedStruct*)ret.Take(); return ret_; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(GISharp.Lib.Gio.FileInputStream.UnmanagedStruct*); }

                return unmanagedReadFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='AppendTo']/*" />
        public delegate GISharp.Lib.Gio.FileOutputStream AppendTo(GISharp.Lib.Gio.FileCreateFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileOutputStream" type="GFileOutputStream*" managed-name="FileOutputStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct* UnmanagedAppendTo(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="FileCreateFlags" type="GFileCreateFlags" managed-name="FileCreateFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileCreateFlags flags,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="AppendTo"/> methods.
        /// </summary>
        public static unsafe class AppendToMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedAppendTo Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct* unmanagedAppendTo(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.FileCreateFlags flags_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var flags = (GISharp.Lib.Gio.FileCreateFlags)flags_; var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doAppendTo = (AppendTo)methodInfo.CreateDelegate(typeof(AppendTo), file); var ret = doAppendTo(flags, cancellable); var ret_ = (GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct*)ret.Take(); return ret_; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct*); }

                return unmanagedAppendTo;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='AppendToAsync']/*" />
        public delegate void AppendToAsync(GISharp.Lib.Gio.FileCreateFlags flags, System.Int32 ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        public unsafe delegate void UnmanagedAppendToAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="FileCreateFlags" type="GFileCreateFlags" managed-name="FileCreateFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileCreateFlags flags,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
System.Int32 ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="AsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:5 direction:in */
System.IntPtr callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:5 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Class for marshalling <see cref="AppendToAsync"/> methods.
        /// </summary>
        public static unsafe class AppendToAsyncMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedAppendToAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedAppendToAsync(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.FileCreateFlags flags_, System.Int32 ioPriority_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, System.IntPtr callback_, System.IntPtr userData_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var flags = (GISharp.Lib.Gio.FileCreateFlags)flags_; var ioPriority = (System.Int32)ioPriority_; var callback = callback_ == System.IntPtr.Zero ? default(GISharp.Lib.Gio.AsyncReadyCallback) : GISharp.Lib.Gio.AsyncReadyCallbackMarshal.FromPointer(callback_, userData_); var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doAppendToAsync = (AppendToAsync)methodInfo.CreateDelegate(typeof(AppendToAsync), file); doAppendToAsync(flags, ioPriority, callback, cancellable); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } }

                return unmanagedAppendToAsync;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='AppendToFinish']/*" />
        public delegate GISharp.Lib.Gio.FileOutputStream AppendToFinish(GISharp.Lib.Gio.IAsyncResult res);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileOutputStream" type="GFileOutputStream*" managed-name="FileOutputStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct* UnmanagedAppendToFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="AppendToFinish"/> methods.
        /// </summary>
        public static unsafe class AppendToFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedAppendToFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct* unmanagedAppendToFinish(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var res = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)res_, GISharp.Runtime.Transfer.None)!; var doAppendToFinish = (AppendToFinish)methodInfo.CreateDelegate(typeof(AppendToFinish), file); var ret = doAppendToFinish(res); var ret_ = (GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct*)ret.Take(); return ret_; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct*); }

                return unmanagedAppendToFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='Create']/*" />
        public delegate GISharp.Lib.Gio.FileOutputStream Create(GISharp.Lib.Gio.FileCreateFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileOutputStream" type="GFileOutputStream*" managed-name="FileOutputStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct* UnmanagedCreate(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="FileCreateFlags" type="GFileCreateFlags" managed-name="FileCreateFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileCreateFlags flags,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="Create"/> methods.
        /// </summary>
        public static unsafe class CreateMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedCreate Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct* unmanagedCreate(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.FileCreateFlags flags_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var flags = (GISharp.Lib.Gio.FileCreateFlags)flags_; var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doCreate = (Create)methodInfo.CreateDelegate(typeof(Create), file); var ret = doCreate(flags, cancellable); var ret_ = (GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct*)ret.Take(); return ret_; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct*); }

                return unmanagedCreate;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='CreateAsync']/*" />
        public delegate void CreateAsync(GISharp.Lib.Gio.FileCreateFlags flags, System.Int32 ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        public unsafe delegate void UnmanagedCreateAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="FileCreateFlags" type="GFileCreateFlags" managed-name="FileCreateFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileCreateFlags flags,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
System.Int32 ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="AsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:5 direction:in */
System.IntPtr callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:5 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Class for marshalling <see cref="CreateAsync"/> methods.
        /// </summary>
        public static unsafe class CreateAsyncMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedCreateAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedCreateAsync(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.FileCreateFlags flags_, System.Int32 ioPriority_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, System.IntPtr callback_, System.IntPtr userData_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var flags = (GISharp.Lib.Gio.FileCreateFlags)flags_; var ioPriority = (System.Int32)ioPriority_; var callback = callback_ == System.IntPtr.Zero ? default(GISharp.Lib.Gio.AsyncReadyCallback) : GISharp.Lib.Gio.AsyncReadyCallbackMarshal.FromPointer(callback_, userData_); var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doCreateAsync = (CreateAsync)methodInfo.CreateDelegate(typeof(CreateAsync), file); doCreateAsync(flags, ioPriority, callback, cancellable); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } }

                return unmanagedCreateAsync;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='CreateFinish']/*" />
        public delegate GISharp.Lib.Gio.FileOutputStream CreateFinish(GISharp.Lib.Gio.IAsyncResult res);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileOutputStream" type="GFileOutputStream*" managed-name="FileOutputStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct* UnmanagedCreateFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="CreateFinish"/> methods.
        /// </summary>
        public static unsafe class CreateFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedCreateFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct* unmanagedCreateFinish(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var res = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)res_, GISharp.Runtime.Transfer.None)!; var doCreateFinish = (CreateFinish)methodInfo.CreateDelegate(typeof(CreateFinish), file); var ret = doCreateFinish(res); var ret_ = (GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct*)ret.Take(); return ret_; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct*); }

                return unmanagedCreateFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='Replace']/*" />
        public delegate GISharp.Lib.Gio.FileOutputStream Replace(GISharp.Lib.GLib.NullableUnownedUtf8 etag, System.Boolean makeBackup, GISharp.Lib.Gio.FileCreateFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileOutputStream" type="GFileOutputStream*" managed-name="FileOutputStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct* UnmanagedReplace(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.Byte* etag,
/* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
/* transfer-ownership:none direction:in */
GISharp.Runtime.Boolean makeBackup,
/* <type name="FileCreateFlags" type="GFileCreateFlags" managed-name="FileCreateFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileCreateFlags flags,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="Replace"/> methods.
        /// </summary>
        public static unsafe class ReplaceMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedReplace Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct* unmanagedReplace(GISharp.Lib.Gio.File.UnmanagedStruct* file_, System.Byte* etag_, GISharp.Runtime.Boolean makeBackup_, GISharp.Lib.Gio.FileCreateFlags flags_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var etag = new GISharp.Lib.GLib.NullableUnownedUtf8(etag_); var makeBackup = GISharp.Runtime.BooleanExtensions.IsTrue(makeBackup_); var flags = (GISharp.Lib.Gio.FileCreateFlags)flags_; var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doReplace = (Replace)methodInfo.CreateDelegate(typeof(Replace), file); var ret = doReplace(etag, makeBackup, flags, cancellable); var ret_ = (GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct*)ret.Take(); return ret_; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct*); }

                return unmanagedReplace;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='ReplaceAsync']/*" />
        public delegate void ReplaceAsync(GISharp.Lib.GLib.NullableUnownedUtf8 etag, System.Boolean makeBackup, GISharp.Lib.Gio.FileCreateFlags flags, System.Int32 ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        public unsafe delegate void UnmanagedReplaceAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.Byte* etag,
/* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
/* transfer-ownership:none direction:in */
GISharp.Runtime.Boolean makeBackup,
/* <type name="FileCreateFlags" type="GFileCreateFlags" managed-name="FileCreateFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileCreateFlags flags,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
System.Int32 ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="AsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:7 direction:in */
System.IntPtr callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:7 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Class for marshalling <see cref="ReplaceAsync"/> methods.
        /// </summary>
        public static unsafe class ReplaceAsyncMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedReplaceAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedReplaceAsync(GISharp.Lib.Gio.File.UnmanagedStruct* file_, System.Byte* etag_, GISharp.Runtime.Boolean makeBackup_, GISharp.Lib.Gio.FileCreateFlags flags_, System.Int32 ioPriority_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, System.IntPtr callback_, System.IntPtr userData_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var etag = new GISharp.Lib.GLib.NullableUnownedUtf8(etag_); var makeBackup = GISharp.Runtime.BooleanExtensions.IsTrue(makeBackup_); var flags = (GISharp.Lib.Gio.FileCreateFlags)flags_; var ioPriority = (System.Int32)ioPriority_; var callback = callback_ == System.IntPtr.Zero ? default(GISharp.Lib.Gio.AsyncReadyCallback) : GISharp.Lib.Gio.AsyncReadyCallbackMarshal.FromPointer(callback_, userData_); var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doReplaceAsync = (ReplaceAsync)methodInfo.CreateDelegate(typeof(ReplaceAsync), file); doReplaceAsync(etag, makeBackup, flags, ioPriority, callback, cancellable); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } }

                return unmanagedReplaceAsync;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='ReplaceFinish']/*" />
        public delegate GISharp.Lib.Gio.FileOutputStream ReplaceFinish(GISharp.Lib.Gio.IAsyncResult res);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileOutputStream" type="GFileOutputStream*" managed-name="FileOutputStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct* UnmanagedReplaceFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="ReplaceFinish"/> methods.
        /// </summary>
        public static unsafe class ReplaceFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedReplaceFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct* unmanagedReplaceFinish(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var res = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)res_, GISharp.Runtime.Transfer.None)!; var doReplaceFinish = (ReplaceFinish)methodInfo.CreateDelegate(typeof(ReplaceFinish), file); var ret = doReplaceFinish(res); var ret_ = (GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct*)ret.Take(); return ret_; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct*); }

                return unmanagedReplaceFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='DeleteFile']/*" />
        public delegate void DeleteFile(GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedDeleteFile(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="DeleteFile"/> methods.
        /// </summary>
        public static unsafe class DeleteFileMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedDeleteFile Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedDeleteFile(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doDeleteFile = (DeleteFile)methodInfo.CreateDelegate(typeof(DeleteFile), file); doDeleteFile(cancellable); return GISharp.Runtime.Boolean.True; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(GISharp.Runtime.Boolean); }

                return unmanagedDeleteFile;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='DeleteFileAsync']/*" />
        public delegate void DeleteFileAsync(System.Int32 ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        public unsafe delegate void UnmanagedDeleteFileAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
System.Int32 ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="AsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:4 direction:in */
System.IntPtr callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:4 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Class for marshalling <see cref="DeleteFileAsync"/> methods.
        /// </summary>
        public static unsafe class DeleteFileAsyncMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedDeleteFileAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedDeleteFileAsync(GISharp.Lib.Gio.File.UnmanagedStruct* file_, System.Int32 ioPriority_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, System.IntPtr callback_, System.IntPtr userData_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var ioPriority = (System.Int32)ioPriority_; var callback = callback_ == System.IntPtr.Zero ? default(GISharp.Lib.Gio.AsyncReadyCallback) : GISharp.Lib.Gio.AsyncReadyCallbackMarshal.FromPointer(callback_, userData_); var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doDeleteFileAsync = (DeleteFileAsync)methodInfo.CreateDelegate(typeof(DeleteFileAsync), file); doDeleteFileAsync(ioPriority, callback, cancellable); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } }

                return unmanagedDeleteFileAsync;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='DeleteFileFinish']/*" />
        public delegate void DeleteFileFinish(GISharp.Lib.Gio.IAsyncResult result);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedDeleteFileFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="DeleteFileFinish"/> methods.
        /// </summary>
        public static unsafe class DeleteFileFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedDeleteFileFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedDeleteFileFinish(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)result_, GISharp.Runtime.Transfer.None)!; var doDeleteFileFinish = (DeleteFileFinish)methodInfo.CreateDelegate(typeof(DeleteFileFinish), file); doDeleteFileFinish(result); return GISharp.Runtime.Boolean.True; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(GISharp.Runtime.Boolean); }

                return unmanagedDeleteFileFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='Trash']/*" />
        public delegate void Trash(GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedTrash(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="Trash"/> methods.
        /// </summary>
        public static unsafe class TrashMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedTrash Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedTrash(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doTrash = (Trash)methodInfo.CreateDelegate(typeof(Trash), file); doTrash(cancellable); return GISharp.Runtime.Boolean.True; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(GISharp.Runtime.Boolean); }

                return unmanagedTrash;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='TrashAsync']/*" />
        public delegate void TrashAsync(System.Int32 ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        public unsafe delegate void UnmanagedTrashAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
System.Int32 ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="AsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:4 direction:in */
System.IntPtr callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:4 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Class for marshalling <see cref="TrashAsync"/> methods.
        /// </summary>
        public static unsafe class TrashAsyncMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedTrashAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedTrashAsync(GISharp.Lib.Gio.File.UnmanagedStruct* file_, System.Int32 ioPriority_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, System.IntPtr callback_, System.IntPtr userData_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var ioPriority = (System.Int32)ioPriority_; var callback = callback_ == System.IntPtr.Zero ? default(GISharp.Lib.Gio.AsyncReadyCallback) : GISharp.Lib.Gio.AsyncReadyCallbackMarshal.FromPointer(callback_, userData_); var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doTrashAsync = (TrashAsync)methodInfo.CreateDelegate(typeof(TrashAsync), file); doTrashAsync(ioPriority, callback, cancellable); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } }

                return unmanagedTrashAsync;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='TrashFinish']/*" />
        public delegate void TrashFinish(GISharp.Lib.Gio.IAsyncResult result);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedTrashFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="TrashFinish"/> methods.
        /// </summary>
        public static unsafe class TrashFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedTrashFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedTrashFinish(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)result_, GISharp.Runtime.Transfer.None)!; var doTrashFinish = (TrashFinish)methodInfo.CreateDelegate(typeof(TrashFinish), file); doTrashFinish(result); return GISharp.Runtime.Boolean.True; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(GISharp.Runtime.Boolean); }

                return unmanagedTrashFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='MakeDirectory']/*" />
        public delegate void MakeDirectory(GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedMakeDirectory(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="MakeDirectory"/> methods.
        /// </summary>
        public static unsafe class MakeDirectoryMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedMakeDirectory Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedMakeDirectory(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doMakeDirectory = (MakeDirectory)methodInfo.CreateDelegate(typeof(MakeDirectory), file); doMakeDirectory(cancellable); return GISharp.Runtime.Boolean.True; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(GISharp.Runtime.Boolean); }

                return unmanagedMakeDirectory;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='MakeDirectoryAsync']/*" />
        public delegate void MakeDirectoryAsync(System.Int32 ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        public unsafe delegate void UnmanagedMakeDirectoryAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
System.Int32 ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="AsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:4 direction:in */
System.IntPtr callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:4 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Class for marshalling <see cref="MakeDirectoryAsync"/> methods.
        /// </summary>
        public static unsafe class MakeDirectoryAsyncMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedMakeDirectoryAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedMakeDirectoryAsync(GISharp.Lib.Gio.File.UnmanagedStruct* file_, System.Int32 ioPriority_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, System.IntPtr callback_, System.IntPtr userData_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var ioPriority = (System.Int32)ioPriority_; var callback = callback_ == System.IntPtr.Zero ? default(GISharp.Lib.Gio.AsyncReadyCallback) : GISharp.Lib.Gio.AsyncReadyCallbackMarshal.FromPointer(callback_, userData_); var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doMakeDirectoryAsync = (MakeDirectoryAsync)methodInfo.CreateDelegate(typeof(MakeDirectoryAsync), file); doMakeDirectoryAsync(ioPriority, callback, cancellable); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } }

                return unmanagedMakeDirectoryAsync;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='MakeDirectoryFinish']/*" />
        public delegate void MakeDirectoryFinish(GISharp.Lib.Gio.IAsyncResult result);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedMakeDirectoryFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="MakeDirectoryFinish"/> methods.
        /// </summary>
        public static unsafe class MakeDirectoryFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedMakeDirectoryFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedMakeDirectoryFinish(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)result_, GISharp.Runtime.Transfer.None)!; var doMakeDirectoryFinish = (MakeDirectoryFinish)methodInfo.CreateDelegate(typeof(MakeDirectoryFinish), file); doMakeDirectoryFinish(result); return GISharp.Runtime.Boolean.True; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(GISharp.Runtime.Boolean); }

                return unmanagedMakeDirectoryFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='MakeSymbolicLink']/*" />
        public delegate void MakeSymbolicLink(GISharp.Lib.GLib.Filename symlinkValue, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedMakeSymbolicLink(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="filename" type="const char*" managed-name="GISharp.Lib.GLib.Filename" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.Byte* symlinkValue,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="MakeSymbolicLink"/> methods.
        /// </summary>
        public static unsafe class MakeSymbolicLinkMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedMakeSymbolicLink Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedMakeSymbolicLink(GISharp.Lib.Gio.File.UnmanagedStruct* file_, System.Byte* symlinkValue_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var symlinkValue = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Filename>((System.IntPtr)symlinkValue_, GISharp.Runtime.Transfer.None)!; var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doMakeSymbolicLink = (MakeSymbolicLink)methodInfo.CreateDelegate(typeof(MakeSymbolicLink), file); doMakeSymbolicLink(symlinkValue, cancellable); return GISharp.Runtime.Boolean.True; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(GISharp.Runtime.Boolean); }

                return unmanagedMakeSymbolicLink;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='Copy']/*" />
        public delegate void Copy(GISharp.Lib.Gio.IFile destination, GISharp.Lib.Gio.FileCopyFlags flags, GISharp.Lib.Gio.FileProgressCallback? progressCallback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedCopy(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* source,
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* destination,
/* <type name="FileCopyFlags" type="GFileCopyFlags" managed-name="FileCopyFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileCopyFlags flags,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="FileProgressCallback" type="GFileProgressCallback" managed-name="FileProgressCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:call closure:5 direction:in */
System.IntPtr progressCallback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr progressCallbackData,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="Copy"/> methods.
        /// </summary>
        public static unsafe class CopyMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedCopy Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedCopy(GISharp.Lib.Gio.File.UnmanagedStruct* source_, GISharp.Lib.Gio.File.UnmanagedStruct* destination_, GISharp.Lib.Gio.FileCopyFlags flags_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, System.IntPtr progressCallback_, System.IntPtr progressCallbackData_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var source = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)source_, GISharp.Runtime.Transfer.None)!; var destination = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)destination_, GISharp.Runtime.Transfer.None)!; var flags = (GISharp.Lib.Gio.FileCopyFlags)flags_; var progressCallback = progressCallback_ == System.IntPtr.Zero ? default(GISharp.Lib.Gio.FileProgressCallback) : GISharp.Lib.Gio.FileProgressCallbackMarshal.FromPointer(progressCallback_, progressCallbackData_); var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doCopy = (Copy)methodInfo.CreateDelegate(typeof(Copy), source); doCopy(destination, flags, progressCallback, cancellable); return GISharp.Runtime.Boolean.True; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(GISharp.Runtime.Boolean); }

                return unmanagedCopy;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='CopyAsync']/*" />
        public delegate void CopyAsync(GISharp.Lib.Gio.IFile destination, GISharp.Lib.Gio.FileCopyFlags flags, System.Int32 ioPriority, GISharp.Lib.Gio.FileProgressCallback? progressCallback, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        public unsafe delegate void UnmanagedCopyAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* source,
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* destination,
/* <type name="FileCopyFlags" type="GFileCopyFlags" managed-name="FileCopyFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileCopyFlags flags,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
System.Int32 ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="FileProgressCallback" type="GFileProgressCallback" managed-name="FileProgressCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:notified closure:6 direction:in */
System.IntPtr progressCallback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:5 direction:in */
System.IntPtr progressCallbackData,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="AsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:8 direction:in */
System.IntPtr callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:7 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Class for marshalling <see cref="CopyAsync"/> methods.
        /// </summary>
        public static unsafe class CopyAsyncMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedCopyAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedCopyAsync(GISharp.Lib.Gio.File.UnmanagedStruct* source_, GISharp.Lib.Gio.File.UnmanagedStruct* destination_, GISharp.Lib.Gio.FileCopyFlags flags_, System.Int32 ioPriority_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, System.IntPtr progressCallback_, System.IntPtr progressCallbackData_, System.IntPtr callback_, System.IntPtr userData_) { try { var source = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)source_, GISharp.Runtime.Transfer.None)!; var destination = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)destination_, GISharp.Runtime.Transfer.None)!; var flags = (GISharp.Lib.Gio.FileCopyFlags)flags_; var ioPriority = (System.Int32)ioPriority_; var progressCallback = progressCallback_ == System.IntPtr.Zero ? default(GISharp.Lib.Gio.FileProgressCallback) : GISharp.Lib.Gio.FileProgressCallbackMarshal.FromPointer(progressCallback_, progressCallbackData_); var callback = callback_ == System.IntPtr.Zero ? default(GISharp.Lib.Gio.AsyncReadyCallback) : GISharp.Lib.Gio.AsyncReadyCallbackMarshal.FromPointer(callback_, userData_); var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doCopyAsync = (CopyAsync)methodInfo.CreateDelegate(typeof(CopyAsync), source); doCopyAsync(destination, flags, ioPriority, progressCallback, callback, cancellable); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } }

                return unmanagedCopyAsync;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='CopyFinish']/*" />
        public delegate void CopyFinish(GISharp.Lib.Gio.IAsyncResult res);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedCopyFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="CopyFinish"/> methods.
        /// </summary>
        public static unsafe class CopyFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedCopyFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedCopyFinish(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var res = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)res_, GISharp.Runtime.Transfer.None)!; var doCopyFinish = (CopyFinish)methodInfo.CreateDelegate(typeof(CopyFinish), file); doCopyFinish(res); return GISharp.Runtime.Boolean.True; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(GISharp.Runtime.Boolean); }

                return unmanagedCopyFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='Move']/*" />
        public delegate void Move(GISharp.Lib.Gio.IFile destination, GISharp.Lib.Gio.FileCopyFlags flags, GISharp.Lib.Gio.FileProgressCallback? progressCallback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedMove(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* source,
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* destination,
/* <type name="FileCopyFlags" type="GFileCopyFlags" managed-name="FileCopyFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileCopyFlags flags,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="FileProgressCallback" type="GFileProgressCallback" managed-name="FileProgressCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:call closure:5 direction:in */
System.IntPtr progressCallback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr progressCallbackData,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="Move"/> methods.
        /// </summary>
        public static unsafe class MoveMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedMove Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedMove(GISharp.Lib.Gio.File.UnmanagedStruct* source_, GISharp.Lib.Gio.File.UnmanagedStruct* destination_, GISharp.Lib.Gio.FileCopyFlags flags_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, System.IntPtr progressCallback_, System.IntPtr progressCallbackData_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var source = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)source_, GISharp.Runtime.Transfer.None)!; var destination = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)destination_, GISharp.Runtime.Transfer.None)!; var flags = (GISharp.Lib.Gio.FileCopyFlags)flags_; var progressCallback = progressCallback_ == System.IntPtr.Zero ? default(GISharp.Lib.Gio.FileProgressCallback) : GISharp.Lib.Gio.FileProgressCallbackMarshal.FromPointer(progressCallback_, progressCallbackData_); var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doMove = (Move)methodInfo.CreateDelegate(typeof(Move), source); doMove(destination, flags, progressCallback, cancellable); return GISharp.Runtime.Boolean.True; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(GISharp.Runtime.Boolean); }

                return unmanagedMove;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='MountMountableFinish']/*" />
        public delegate GISharp.Lib.Gio.IFile MountMountableFinish(GISharp.Lib.Gio.IAsyncResult result);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate GISharp.Lib.Gio.File.UnmanagedStruct* UnmanagedMountMountableFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="MountMountableFinish"/> methods.
        /// </summary>
        public static unsafe class MountMountableFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedMountMountableFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Lib.Gio.File.UnmanagedStruct* unmanagedMountMountableFinish(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)result_, GISharp.Runtime.Transfer.None)!; var doMountMountableFinish = (MountMountableFinish)methodInfo.CreateDelegate(typeof(MountMountableFinish), file); var ret = doMountMountableFinish(result); var ret_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)ret.Take(); return ret_; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(GISharp.Lib.Gio.File.UnmanagedStruct*); }

                return unmanagedMountMountableFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmountMountableFinish']/*" />
        public delegate void UnmountMountableFinish(GISharp.Lib.Gio.IAsyncResult result);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedUnmountMountableFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="UnmountMountableFinish"/> methods.
        /// </summary>
        public static unsafe class UnmountMountableFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedUnmountMountableFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedUnmountMountableFinish(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)result_, GISharp.Runtime.Transfer.None)!; var doUnmountMountableFinish = (UnmountMountableFinish)methodInfo.CreateDelegate(typeof(UnmountMountableFinish), file); doUnmountMountableFinish(result); return GISharp.Runtime.Boolean.True; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(GISharp.Runtime.Boolean); }

                return unmanagedUnmountMountableFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='EjectMountableFinish']/*" />
        public delegate void EjectMountableFinish(GISharp.Lib.Gio.IAsyncResult result);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedEjectMountableFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="EjectMountableFinish"/> methods.
        /// </summary>
        public static unsafe class EjectMountableFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedEjectMountableFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedEjectMountableFinish(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)result_, GISharp.Runtime.Transfer.None)!; var doEjectMountableFinish = (EjectMountableFinish)methodInfo.CreateDelegate(typeof(EjectMountableFinish), file); doEjectMountableFinish(result); return GISharp.Runtime.Boolean.True; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(GISharp.Runtime.Boolean); }

                return unmanagedEjectMountableFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='MountEnclosingVolumeFinish']/*" />
        public delegate void MountEnclosingVolumeFinish(GISharp.Lib.Gio.IAsyncResult result);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedMountEnclosingVolumeFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* location,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="MountEnclosingVolumeFinish"/> methods.
        /// </summary>
        public static unsafe class MountEnclosingVolumeFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedMountEnclosingVolumeFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedMountEnclosingVolumeFinish(GISharp.Lib.Gio.File.UnmanagedStruct* location_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var location = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)location_, GISharp.Runtime.Transfer.None)!; var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)result_, GISharp.Runtime.Transfer.None)!; var doMountEnclosingVolumeFinish = (MountEnclosingVolumeFinish)methodInfo.CreateDelegate(typeof(MountEnclosingVolumeFinish), location); doMountEnclosingVolumeFinish(result); return GISharp.Runtime.Boolean.True; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(GISharp.Runtime.Boolean); }

                return unmanagedMountEnclosingVolumeFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='OpenReadwrite']/*" />
        public delegate GISharp.Lib.Gio.FileIOStream OpenReadwrite(GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileIOStream" type="GFileIOStream*" managed-name="FileIOStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate GISharp.Lib.Gio.FileIOStream.UnmanagedStruct* UnmanagedOpenReadwrite(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="OpenReadwrite"/> methods.
        /// </summary>
        public static unsafe class OpenReadwriteMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedOpenReadwrite Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Lib.Gio.FileIOStream.UnmanagedStruct* unmanagedOpenReadwrite(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doOpenReadwrite = (OpenReadwrite)methodInfo.CreateDelegate(typeof(OpenReadwrite), file); var ret = doOpenReadwrite(cancellable); var ret_ = (GISharp.Lib.Gio.FileIOStream.UnmanagedStruct*)ret.Take(); return ret_; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(GISharp.Lib.Gio.FileIOStream.UnmanagedStruct*); }

                return unmanagedOpenReadwrite;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='OpenReadwriteAsync']/*" />
        public delegate void OpenReadwriteAsync(System.Int32 ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        public unsafe delegate void UnmanagedOpenReadwriteAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
System.Int32 ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="AsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:4 direction:in */
System.IntPtr callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:4 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Class for marshalling <see cref="OpenReadwriteAsync"/> methods.
        /// </summary>
        public static unsafe class OpenReadwriteAsyncMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedOpenReadwriteAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedOpenReadwriteAsync(GISharp.Lib.Gio.File.UnmanagedStruct* file_, System.Int32 ioPriority_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, System.IntPtr callback_, System.IntPtr userData_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var ioPriority = (System.Int32)ioPriority_; var callback = callback_ == System.IntPtr.Zero ? default(GISharp.Lib.Gio.AsyncReadyCallback) : GISharp.Lib.Gio.AsyncReadyCallbackMarshal.FromPointer(callback_, userData_); var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doOpenReadwriteAsync = (OpenReadwriteAsync)methodInfo.CreateDelegate(typeof(OpenReadwriteAsync), file); doOpenReadwriteAsync(ioPriority, callback, cancellable); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } }

                return unmanagedOpenReadwriteAsync;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='OpenReadwriteFinish']/*" />
        public delegate GISharp.Lib.Gio.FileIOStream OpenReadwriteFinish(GISharp.Lib.Gio.IAsyncResult res);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileIOStream" type="GFileIOStream*" managed-name="FileIOStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate GISharp.Lib.Gio.FileIOStream.UnmanagedStruct* UnmanagedOpenReadwriteFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="OpenReadwriteFinish"/> methods.
        /// </summary>
        public static unsafe class OpenReadwriteFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedOpenReadwriteFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Lib.Gio.FileIOStream.UnmanagedStruct* unmanagedOpenReadwriteFinish(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var res = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)res_, GISharp.Runtime.Transfer.None)!; var doOpenReadwriteFinish = (OpenReadwriteFinish)methodInfo.CreateDelegate(typeof(OpenReadwriteFinish), file); var ret = doOpenReadwriteFinish(res); var ret_ = (GISharp.Lib.Gio.FileIOStream.UnmanagedStruct*)ret.Take(); return ret_; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(GISharp.Lib.Gio.FileIOStream.UnmanagedStruct*); }

                return unmanagedOpenReadwriteFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='CreateReadwrite']/*" />
        public delegate GISharp.Lib.Gio.FileIOStream CreateReadwrite(GISharp.Lib.Gio.FileCreateFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileIOStream" type="GFileIOStream*" managed-name="FileIOStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate GISharp.Lib.Gio.FileIOStream.UnmanagedStruct* UnmanagedCreateReadwrite(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="FileCreateFlags" type="GFileCreateFlags" managed-name="FileCreateFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileCreateFlags flags,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="CreateReadwrite"/> methods.
        /// </summary>
        public static unsafe class CreateReadwriteMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedCreateReadwrite Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Lib.Gio.FileIOStream.UnmanagedStruct* unmanagedCreateReadwrite(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.FileCreateFlags flags_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var flags = (GISharp.Lib.Gio.FileCreateFlags)flags_; var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doCreateReadwrite = (CreateReadwrite)methodInfo.CreateDelegate(typeof(CreateReadwrite), file); var ret = doCreateReadwrite(flags, cancellable); var ret_ = (GISharp.Lib.Gio.FileIOStream.UnmanagedStruct*)ret.Take(); return ret_; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(GISharp.Lib.Gio.FileIOStream.UnmanagedStruct*); }

                return unmanagedCreateReadwrite;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='CreateReadwriteAsync']/*" />
        public delegate void CreateReadwriteAsync(GISharp.Lib.Gio.FileCreateFlags flags, System.Int32 ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        public unsafe delegate void UnmanagedCreateReadwriteAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="FileCreateFlags" type="GFileCreateFlags" managed-name="FileCreateFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileCreateFlags flags,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
System.Int32 ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="AsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:5 direction:in */
System.IntPtr callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:5 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Class for marshalling <see cref="CreateReadwriteAsync"/> methods.
        /// </summary>
        public static unsafe class CreateReadwriteAsyncMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedCreateReadwriteAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedCreateReadwriteAsync(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.FileCreateFlags flags_, System.Int32 ioPriority_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, System.IntPtr callback_, System.IntPtr userData_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var flags = (GISharp.Lib.Gio.FileCreateFlags)flags_; var ioPriority = (System.Int32)ioPriority_; var callback = callback_ == System.IntPtr.Zero ? default(GISharp.Lib.Gio.AsyncReadyCallback) : GISharp.Lib.Gio.AsyncReadyCallbackMarshal.FromPointer(callback_, userData_); var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doCreateReadwriteAsync = (CreateReadwriteAsync)methodInfo.CreateDelegate(typeof(CreateReadwriteAsync), file); doCreateReadwriteAsync(flags, ioPriority, callback, cancellable); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } }

                return unmanagedCreateReadwriteAsync;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='CreateReadwriteFinish']/*" />
        public delegate GISharp.Lib.Gio.FileIOStream CreateReadwriteFinish(GISharp.Lib.Gio.IAsyncResult res);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileIOStream" type="GFileIOStream*" managed-name="FileIOStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate GISharp.Lib.Gio.FileIOStream.UnmanagedStruct* UnmanagedCreateReadwriteFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="CreateReadwriteFinish"/> methods.
        /// </summary>
        public static unsafe class CreateReadwriteFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedCreateReadwriteFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Lib.Gio.FileIOStream.UnmanagedStruct* unmanagedCreateReadwriteFinish(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var res = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)res_, GISharp.Runtime.Transfer.None)!; var doCreateReadwriteFinish = (CreateReadwriteFinish)methodInfo.CreateDelegate(typeof(CreateReadwriteFinish), file); var ret = doCreateReadwriteFinish(res); var ret_ = (GISharp.Lib.Gio.FileIOStream.UnmanagedStruct*)ret.Take(); return ret_; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(GISharp.Lib.Gio.FileIOStream.UnmanagedStruct*); }

                return unmanagedCreateReadwriteFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='ReplaceReadwrite']/*" />
        public delegate GISharp.Lib.Gio.FileIOStream ReplaceReadwrite(GISharp.Lib.GLib.NullableUnownedUtf8 etag, System.Boolean makeBackup, GISharp.Lib.Gio.FileCreateFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileIOStream" type="GFileIOStream*" managed-name="FileIOStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate GISharp.Lib.Gio.FileIOStream.UnmanagedStruct* UnmanagedReplaceReadwrite(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.Byte* etag,
/* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
/* transfer-ownership:none direction:in */
GISharp.Runtime.Boolean makeBackup,
/* <type name="FileCreateFlags" type="GFileCreateFlags" managed-name="FileCreateFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileCreateFlags flags,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="ReplaceReadwrite"/> methods.
        /// </summary>
        public static unsafe class ReplaceReadwriteMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedReplaceReadwrite Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Lib.Gio.FileIOStream.UnmanagedStruct* unmanagedReplaceReadwrite(GISharp.Lib.Gio.File.UnmanagedStruct* file_, System.Byte* etag_, GISharp.Runtime.Boolean makeBackup_, GISharp.Lib.Gio.FileCreateFlags flags_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var etag = new GISharp.Lib.GLib.NullableUnownedUtf8(etag_); var makeBackup = GISharp.Runtime.BooleanExtensions.IsTrue(makeBackup_); var flags = (GISharp.Lib.Gio.FileCreateFlags)flags_; var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doReplaceReadwrite = (ReplaceReadwrite)methodInfo.CreateDelegate(typeof(ReplaceReadwrite), file); var ret = doReplaceReadwrite(etag, makeBackup, flags, cancellable); var ret_ = (GISharp.Lib.Gio.FileIOStream.UnmanagedStruct*)ret.Take(); return ret_; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(GISharp.Lib.Gio.FileIOStream.UnmanagedStruct*); }

                return unmanagedReplaceReadwrite;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='ReplaceReadwriteAsync']/*" />
        public delegate void ReplaceReadwriteAsync(GISharp.Lib.GLib.NullableUnownedUtf8 etag, System.Boolean makeBackup, GISharp.Lib.Gio.FileCreateFlags flags, System.Int32 ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        public unsafe delegate void UnmanagedReplaceReadwriteAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.Byte* etag,
/* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
/* transfer-ownership:none direction:in */
GISharp.Runtime.Boolean makeBackup,
/* <type name="FileCreateFlags" type="GFileCreateFlags" managed-name="FileCreateFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileCreateFlags flags,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
System.Int32 ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="AsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:7 direction:in */
System.IntPtr callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:7 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Class for marshalling <see cref="ReplaceReadwriteAsync"/> methods.
        /// </summary>
        public static unsafe class ReplaceReadwriteAsyncMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedReplaceReadwriteAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedReplaceReadwriteAsync(GISharp.Lib.Gio.File.UnmanagedStruct* file_, System.Byte* etag_, GISharp.Runtime.Boolean makeBackup_, GISharp.Lib.Gio.FileCreateFlags flags_, System.Int32 ioPriority_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, System.IntPtr callback_, System.IntPtr userData_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var etag = new GISharp.Lib.GLib.NullableUnownedUtf8(etag_); var makeBackup = GISharp.Runtime.BooleanExtensions.IsTrue(makeBackup_); var flags = (GISharp.Lib.Gio.FileCreateFlags)flags_; var ioPriority = (System.Int32)ioPriority_; var callback = callback_ == System.IntPtr.Zero ? default(GISharp.Lib.Gio.AsyncReadyCallback) : GISharp.Lib.Gio.AsyncReadyCallbackMarshal.FromPointer(callback_, userData_); var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doReplaceReadwriteAsync = (ReplaceReadwriteAsync)methodInfo.CreateDelegate(typeof(ReplaceReadwriteAsync), file); doReplaceReadwriteAsync(etag, makeBackup, flags, ioPriority, callback, cancellable); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } }

                return unmanagedReplaceReadwriteAsync;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='ReplaceReadwriteFinish']/*" />
        public delegate GISharp.Lib.Gio.FileIOStream ReplaceReadwriteFinish(GISharp.Lib.Gio.IAsyncResult res);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileIOStream" type="GFileIOStream*" managed-name="FileIOStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        public unsafe delegate GISharp.Lib.Gio.FileIOStream.UnmanagedStruct* UnmanagedReplaceReadwriteFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="ReplaceReadwriteFinish"/> methods.
        /// </summary>
        public static unsafe class ReplaceReadwriteFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedReplaceReadwriteFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Lib.Gio.FileIOStream.UnmanagedStruct* unmanagedReplaceReadwriteFinish(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var res = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)res_, GISharp.Runtime.Transfer.None)!; var doReplaceReadwriteFinish = (ReplaceReadwriteFinish)methodInfo.CreateDelegate(typeof(ReplaceReadwriteFinish), file); var ret = doReplaceReadwriteFinish(res); var ret_ = (GISharp.Lib.Gio.FileIOStream.UnmanagedStruct*)ret.Take(); return ret_; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(GISharp.Lib.Gio.FileIOStream.UnmanagedStruct*); }

                return unmanagedReplaceReadwriteFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='StartMountableFinish']/*" />
        public delegate void StartMountableFinish(GISharp.Lib.Gio.IAsyncResult result);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedStartMountableFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="StartMountableFinish"/> methods.
        /// </summary>
        public static unsafe class StartMountableFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedStartMountableFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedStartMountableFinish(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)result_, GISharp.Runtime.Transfer.None)!; var doStartMountableFinish = (StartMountableFinish)methodInfo.CreateDelegate(typeof(StartMountableFinish), file); doStartMountableFinish(result); return GISharp.Runtime.Boolean.True; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(GISharp.Runtime.Boolean); }

                return unmanagedStartMountableFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='StopMountableFinish']/*" />
        public delegate void StopMountableFinish(GISharp.Lib.Gio.IAsyncResult result);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedStopMountableFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="StopMountableFinish"/> methods.
        /// </summary>
        public static unsafe class StopMountableFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedStopMountableFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedStopMountableFinish(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)result_, GISharp.Runtime.Transfer.None)!; var doStopMountableFinish = (StopMountableFinish)methodInfo.CreateDelegate(typeof(StopMountableFinish), file); doStopMountableFinish(result); return GISharp.Runtime.Boolean.True; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(GISharp.Runtime.Boolean); }

                return unmanagedStopMountableFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmountMountableWithOperationFinish']/*" />
        public delegate void UnmountMountableWithOperationFinish(GISharp.Lib.Gio.IAsyncResult result);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedUnmountMountableWithOperationFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="UnmountMountableWithOperationFinish"/> methods.
        /// </summary>
        public static unsafe class UnmountMountableWithOperationFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedUnmountMountableWithOperationFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedUnmountMountableWithOperationFinish(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)result_, GISharp.Runtime.Transfer.None)!; var doUnmountMountableWithOperationFinish = (UnmountMountableWithOperationFinish)methodInfo.CreateDelegate(typeof(UnmountMountableWithOperationFinish), file); doUnmountMountableWithOperationFinish(result); return GISharp.Runtime.Boolean.True; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(GISharp.Runtime.Boolean); }

                return unmanagedUnmountMountableWithOperationFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='EjectMountableWithOperationFinish']/*" />
        public delegate void EjectMountableWithOperationFinish(GISharp.Lib.Gio.IAsyncResult result);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedEjectMountableWithOperationFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="EjectMountableWithOperationFinish"/> methods.
        /// </summary>
        public static unsafe class EjectMountableWithOperationFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedEjectMountableWithOperationFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedEjectMountableWithOperationFinish(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)result_, GISharp.Runtime.Transfer.None)!; var doEjectMountableWithOperationFinish = (EjectMountableWithOperationFinish)methodInfo.CreateDelegate(typeof(EjectMountableWithOperationFinish), file); doEjectMountableWithOperationFinish(result); return GISharp.Runtime.Boolean.True; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(GISharp.Runtime.Boolean); }

                return unmanagedEjectMountableWithOperationFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='PollMountable']/*" />
        public delegate void PollMountable(GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        public unsafe delegate void UnmanagedPollMountable(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="AsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:3 direction:in */
System.IntPtr callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:3 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Class for marshalling <see cref="PollMountable"/> methods.
        /// </summary>
        public static unsafe class PollMountableMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedPollMountable Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedPollMountable(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable_, System.IntPtr callback_, System.IntPtr userData_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var callback = callback_ == System.IntPtr.Zero ? default(GISharp.Lib.Gio.AsyncReadyCallback) : GISharp.Lib.Gio.AsyncReadyCallbackMarshal.FromPointer(callback_, userData_); var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)cancellable_, GISharp.Runtime.Transfer.None); var doPollMountable = (PollMountable)methodInfo.CreateDelegate(typeof(PollMountable), file); doPollMountable(callback, cancellable); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } }

                return unmanagedPollMountable;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='PollMountableFinish']/*" />
        public delegate void PollMountableFinish(GISharp.Lib.Gio.IAsyncResult result);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedPollMountableFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="PollMountableFinish"/> methods.
        /// </summary>
        public static unsafe class PollMountableFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedPollMountableFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedPollMountableFinish(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)result_, GISharp.Runtime.Transfer.None)!; var doPollMountableFinish = (PollMountableFinish)methodInfo.CreateDelegate(typeof(PollMountableFinish), file); doPollMountableFinish(result); return GISharp.Runtime.Boolean.True; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(GISharp.Runtime.Boolean); }

                return unmanagedPollMountableFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='MeasureDiskUsageFinish']/*" />
        public delegate void MeasureDiskUsageFinish(GISharp.Lib.Gio.IAsyncResult result, out System.UInt64 diskUsage, out System.UInt64 numDirs, out System.UInt64 numFiles);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedMeasureDiskUsageFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.File.UnmanagedStruct* file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result,
/* <type name="guint64" type="guint64*" managed-name="System.UInt64" /> */
/* direction:out caller-allocates:0 transfer-ownership:full optional:1 allow-none:1 */
System.UInt64* diskUsage,
/* <type name="guint64" type="guint64*" managed-name="System.UInt64" /> */
/* direction:out caller-allocates:0 transfer-ownership:full optional:1 allow-none:1 */
System.UInt64* numDirs,
/* <type name="guint64" type="guint64*" managed-name="System.UInt64" /> */
/* direction:out caller-allocates:0 transfer-ownership:full optional:1 allow-none:1 */
System.UInt64* numFiles,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Class for marshalling <see cref="MeasureDiskUsageFinish"/> methods.
        /// </summary>
        public static unsafe class MeasureDiskUsageFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static UnmanagedMeasureDiskUsageFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedMeasureDiskUsageFinish(GISharp.Lib.Gio.File.UnmanagedStruct* file_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result_, System.UInt64* diskUsage_, System.UInt64* numDirs_, System.UInt64* numFiles_, GISharp.Lib.GLib.Error.UnmanagedStruct** error_) { try { var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)file_, GISharp.Runtime.Transfer.None)!; var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)result_, GISharp.Runtime.Transfer.None)!; var doMeasureDiskUsageFinish = (MeasureDiskUsageFinish)methodInfo.CreateDelegate(typeof(MeasureDiskUsageFinish), file); doMeasureDiskUsageFinish(result,out var diskUsage,out var numDirs,out var numFiles); *diskUsage_ = (System.UInt64)diskUsage; *numDirs_ = (System.UInt64)numDirs; *numFiles_ = (System.UInt64)numFiles; return GISharp.Runtime.Boolean.True; } catch (GISharp.Runtime.GErrorException ex) { GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error); } catch (System.Exception ex) { GISharp.Lib.GLib.Log.LogUnhandledException(ex); } return default(GISharp.Runtime.Boolean); }

                return unmanagedMeasureDiskUsageFinish;
            }
        }

        /// <summary>
        /// For internal runtime use only.
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        public FileIface(System.IntPtr handle, GISharp.Runtime.Transfer ownership) : base(handle, ownership)
        {
        }
    }
}