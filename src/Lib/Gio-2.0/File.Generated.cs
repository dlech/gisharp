// SPDX-License-Identifier: MIT
// ATTENTION: This file is automatically generated. Do not edit manually.
#nullable enable
namespace GISharp.Lib.Gio
{
    /// <include file="File.xmldoc" path="declaration/member[@name='IFile']/*" />
    [GISharp.Runtime.GTypeAttribute("GFile", IsProxyForUnmanagedType = true)]
    [GISharp.Runtime.GTypeStructAttribute(typeof(FileIface))]
    public unsafe partial interface IFile : GISharp.Lib.GObject.GInterface<GISharp.Lib.GObject.Object>
    {
        private static readonly GISharp.Runtime.GType _GType = g_file_get_type();

        /// <summary>
        /// Creates a #GFile with the given argument from the command line.
        /// The value of @arg can be either a URI, an absolute path or a
        /// relative path resolved relative to the current working directory.
        /// This operation never fails, but the returned object might not
        /// support any I/O operation if @arg points to a malformed path.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Note that on Windows, this function expects its argument to be in
        /// UTF-8 -- not the system code page.  This means that you
        /// should not use this function with string from argv as it is passed
        /// to main().  g_win32_get_command_line() will return a UTF-8 version of
        /// the commandline.  #GApplication also uses UTF-8 but
        /// g_application_command_line_create_file_for_arg() may be more useful
        /// for you there.  It is also always possible to use this function with
        /// #GOptionContext arguments of type %G_OPTION_ARG_FILENAME.
        /// </para>
        /// </remarks>
        /// <param name="arg">
        /// a command line string
        /// </param>
        /// <returns>
        /// a new #GFile.
        ///    Free the returned object with g_object_unref().
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.Gio.File.UnmanagedStruct* g_file_new_for_commandline_arg(
        /* <type name="filename" type="const char*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* arg);
        static partial void CheckNewForCommandlineArgArgs(GISharp.Lib.GLib.Filename arg);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.NewForCommandlineArg(GISharp.Lib.GLib.Filename)']/*" />
        public static GISharp.Lib.Gio.IFile NewForCommandlineArg(GISharp.Lib.GLib.Filename arg)
        {
            CheckNewForCommandlineArgArgs(arg);
            var arg_ = (byte*)arg.UnsafeHandle;
            var ret_ = g_file_new_for_commandline_arg(arg_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Creates a #GFile with the given argument from the command line.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This function is similar to g_file_new_for_commandline_arg() except
        /// that it allows for passing the current working directory as an
        /// argument instead of using the current working directory of the
        /// process.
        /// </para>
        /// <para>
        /// This is useful if the commandline argument was given in a context
        /// other than the invocation of the current process.
        /// </para>
        /// <para>
        /// See also g_application_command_line_create_file_for_arg().
        /// </para>
        /// </remarks>
        /// <param name="arg">
        /// a command line string
        /// </param>
        /// <param name="cwd">
        /// the current working directory of the commandline
        /// </param>
        /// <returns>
        /// a new #GFile
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.Gio.File.UnmanagedStruct* g_file_new_for_commandline_arg_and_cwd(
        /* <type name="filename" type="const gchar*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* arg,
        /* <type name="filename" type="const gchar*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* cwd);
        static partial void CheckNewForCommandlineArgAndCwdArgs(GISharp.Lib.GLib.Filename arg, GISharp.Lib.GLib.Filename cwd);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.NewForCommandlineArgAndCwd(GISharp.Lib.GLib.Filename,GISharp.Lib.GLib.Filename)']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        public static GISharp.Lib.Gio.IFile NewForCommandlineArgAndCwd(GISharp.Lib.GLib.Filename arg, GISharp.Lib.GLib.Filename cwd)
        {
            CheckNewForCommandlineArgAndCwdArgs(arg, cwd);
            var arg_ = (byte*)arg.UnsafeHandle;
            var cwd_ = (byte*)cwd.UnsafeHandle;
            var ret_ = g_file_new_for_commandline_arg_and_cwd(arg_,cwd_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Constructs a #GFile for a given path. This operation never
        /// fails, but the returned object might not support any I/O
        /// operation if @path is malformed.
        /// </summary>
        /// <param name="path">
        /// a string containing a relative or absolute path.
        ///     The string must be encoded in the glib filename encoding.
        /// </param>
        /// <returns>
        /// a new #GFile for the given @path.
        ///   Free the returned object with g_object_unref().
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.Gio.File.UnmanagedStruct* g_file_new_for_path(
        /* <type name="filename" type="const char*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* path);
        static partial void CheckNewForPathArgs(GISharp.Lib.GLib.Filename path);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.NewForPath(GISharp.Lib.GLib.Filename)']/*" />
        public static GISharp.Lib.Gio.IFile NewForPath(GISharp.Lib.GLib.Filename path)
        {
            CheckNewForPathArgs(path);
            var path_ = (byte*)path.UnsafeHandle;
            var ret_ = g_file_new_for_path(path_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Constructs a #GFile for a given URI. This operation never
        /// fails, but the returned object might not support any I/O
        /// operation if @uri is malformed or if the uri type is
        /// not supported.
        /// </summary>
        /// <param name="uri">
        /// a UTF-8 string containing a URI
        /// </param>
        /// <returns>
        /// a new #GFile for the given @uri.
        ///     Free the returned object with g_object_unref().
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.Gio.File.UnmanagedStruct* g_file_new_for_uri(
        /* <type name="utf8" type="const char*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* uri);
        static partial void CheckNewForUriArgs(GISharp.Lib.GLib.UnownedUtf8 uri);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.NewForUri(GISharp.Lib.GLib.UnownedUtf8)']/*" />
        public static GISharp.Lib.Gio.IFile NewForUri(GISharp.Lib.GLib.UnownedUtf8 uri)
        {
            CheckNewForUriArgs(uri);
            var uri_ = (byte*)uri.UnsafeHandle;
            var ret_ = g_file_new_for_uri(uri_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Opens a file in the preferred directory for temporary files (as
        /// returned by g_get_tmp_dir()) and returns a #GFile and
        /// #GFileIOStream pointing to it.
        /// </summary>
        /// <remarks>
        /// <para>
        /// @tmpl should be a string in the GLib file name encoding
        /// containing a sequence of six 'X' characters, and containing no
        /// directory components. If it is %NULL, a default template is used.
        /// </para>
        /// <para>
        /// Unlike the other #GFile constructors, this will return %NULL if
        /// a temporary file could not be created.
        /// </para>
        /// </remarks>
        /// <param name="tmpl">
        /// Template for the file
        ///   name, as in g_file_open_tmp(), or %NULL for a default template
        /// </param>
        /// <param name="iostream">
        /// on return, a #GFileIOStream for the created file
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// a new #GFile.
        ///     Free the returned object with g_object_unref().
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.32")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.Gio.File.UnmanagedStruct* g_file_new_tmp(
        /* <type name="filename" type="const char*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        byte* tmpl,
        /* <type name="FileIOStream" type="GFileIOStream**" is-pointer="1" /> */
        /* direction:out caller-allocates:0 transfer-ownership:full */
        GISharp.Lib.Gio.FileIOStream.UnmanagedStruct** iostream,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        static partial void CheckNewTmpArgs(GISharp.Lib.GLib.Filename? tmpl);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.NewTmp(GISharp.Lib.GLib.Filename?,GISharp.Lib.Gio.FileIOStream)']/*" />
        [GISharp.Runtime.SinceAttribute("2.32")]
        public static GISharp.Lib.Gio.IFile NewTmp(GISharp.Lib.GLib.Filename? tmpl, out GISharp.Lib.Gio.FileIOStream iostream)
        {
            CheckNewTmpArgs(tmpl);
            var tmpl_ = (byte*)(tmpl?.UnsafeHandle ?? System.IntPtr.Zero);
            GISharp.Lib.Gio.FileIOStream.UnmanagedStruct* iostream_;
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            var ret_ = g_file_new_tmp(tmpl_,&iostream_,&error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Runtime.GErrorException(error);
            }

            iostream = GISharp.Lib.Gio.FileIOStream.GetInstance<GISharp.Lib.Gio.FileIOStream>((System.IntPtr)iostream_, GISharp.Runtime.Transfer.Full)!;
            var ret = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Constructs a #GFile with the given @parse_name (i.e. something
        /// given by g_file_get_parse_name()). This operation never fails,
        /// but the returned object might not support any I/O operation if
        /// the @parse_name cannot be parsed.
        /// </summary>
        /// <param name="parseName">
        /// a file name or path to be parsed
        /// </param>
        /// <returns>
        /// a new #GFile.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.Gio.File.UnmanagedStruct* g_file_parse_name(
        /* <type name="utf8" type="const char*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* parseName);
        static partial void CheckParseNameArgs(GISharp.Lib.GLib.UnownedUtf8 parseName);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.ParseName(GISharp.Lib.GLib.UnownedUtf8)']/*" />
        public static GISharp.Lib.Gio.IFile ParseName(GISharp.Lib.GLib.UnownedUtf8 parseName)
        {
            CheckParseNameArgs(parseName);
            var parseName_ = (byte*)parseName.UnsafeHandle;
            var ret_ = g_file_parse_name(parseName_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="GType" type="GType" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Runtime.GType g_file_get_type();

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoAppendTo(GISharp.Lib.Gio.FileCreateFlags,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedAppendTo))]
        GISharp.Lib.Gio.FileOutputStream DoAppendTo(GISharp.Lib.Gio.FileCreateFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoAppendToAsync(GISharp.Lib.Gio.FileCreateFlags,int,GISharp.Lib.Gio.AsyncReadyCallback?,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedAppendToAsync))]
        void DoAppendToAsync(GISharp.Lib.Gio.FileCreateFlags flags, int ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoAppendToFinish(GISharp.Lib.Gio.IAsyncResult)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedAppendToFinish))]
        GISharp.Lib.Gio.FileOutputStream DoAppendToFinish(GISharp.Lib.Gio.IAsyncResult res);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoCopy(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.FileCopyFlags,GISharp.Lib.Gio.FileProgressCallback?,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedCopy))]
        void DoCopy(GISharp.Lib.Gio.IFile destination, GISharp.Lib.Gio.FileCopyFlags flags, GISharp.Lib.Gio.FileProgressCallback? progressCallback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoCopyAsync(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.FileCopyFlags,int,GISharp.Lib.Gio.FileProgressCallback?,GISharp.Lib.Gio.AsyncReadyCallback?,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedCopyAsync))]
        void DoCopyAsync(GISharp.Lib.Gio.IFile destination, GISharp.Lib.Gio.FileCopyFlags flags, int ioPriority, GISharp.Lib.Gio.FileProgressCallback? progressCallback, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoCopyFinish(GISharp.Lib.Gio.IAsyncResult)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedCopyFinish))]
        void DoCopyFinish(GISharp.Lib.Gio.IAsyncResult res);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoCreate(GISharp.Lib.Gio.FileCreateFlags,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedCreate))]
        GISharp.Lib.Gio.FileOutputStream DoCreate(GISharp.Lib.Gio.FileCreateFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoCreateAsync(GISharp.Lib.Gio.FileCreateFlags,int,GISharp.Lib.Gio.AsyncReadyCallback?,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedCreateAsync))]
        void DoCreateAsync(GISharp.Lib.Gio.FileCreateFlags flags, int ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoCreateFinish(GISharp.Lib.Gio.IAsyncResult)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedCreateFinish))]
        GISharp.Lib.Gio.FileOutputStream DoCreateFinish(GISharp.Lib.Gio.IAsyncResult res);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoCreateReadwrite(GISharp.Lib.Gio.FileCreateFlags,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.SinceAttribute("2.22")]
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedCreateReadwrite))]
        GISharp.Lib.Gio.FileIOStream DoCreateReadwrite(GISharp.Lib.Gio.FileCreateFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoCreateReadwriteAsync(GISharp.Lib.Gio.FileCreateFlags,int,GISharp.Lib.Gio.AsyncReadyCallback?,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.SinceAttribute("2.22")]
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedCreateReadwriteAsync))]
        void DoCreateReadwriteAsync(GISharp.Lib.Gio.FileCreateFlags flags, int ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoCreateReadwriteFinish(GISharp.Lib.Gio.IAsyncResult)']/*" />
        [GISharp.Runtime.SinceAttribute("2.22")]
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedCreateReadwriteFinish))]
        GISharp.Lib.Gio.FileIOStream DoCreateReadwriteFinish(GISharp.Lib.Gio.IAsyncResult res);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoDeleteFile(GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedDeleteFile))]
        void DoDeleteFile(GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoDeleteFileAsync(int,GISharp.Lib.Gio.AsyncReadyCallback?,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.SinceAttribute("2.34")]
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedDeleteFileAsync))]
        void DoDeleteFileAsync(int ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoDeleteFileFinish(GISharp.Lib.Gio.IAsyncResult)']/*" />
        [GISharp.Runtime.SinceAttribute("2.34")]
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedDeleteFileFinish))]
        void DoDeleteFileFinish(GISharp.Lib.Gio.IAsyncResult result);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoDup()']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedDup))]
        GISharp.Lib.Gio.IFile DoDup();

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoEjectMountableFinish(GISharp.Lib.Gio.IAsyncResult)']/*" />
        [System.ObsoleteAttribute("Use g_file_eject_mountable_with_operation_finish()\n    instead.")]
        [GISharp.Runtime.DeprecatedSinceAttribute("2.22")]
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedEjectMountableFinish))]
        void DoEjectMountableFinish(GISharp.Lib.Gio.IAsyncResult result);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoEjectMountableWithOperationFinish(GISharp.Lib.Gio.IAsyncResult)']/*" />
        [GISharp.Runtime.SinceAttribute("2.22")]
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedEjectMountableWithOperationFinish))]
        void DoEjectMountableWithOperationFinish(GISharp.Lib.Gio.IAsyncResult result);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoEnumerateChildrenAsync(GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.Gio.FileQueryInfoFlags,int,GISharp.Lib.Gio.AsyncReadyCallback?,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedEnumerateChildrenAsync))]
        void DoEnumerateChildrenAsync(GISharp.Lib.GLib.UnownedUtf8 attributes, GISharp.Lib.Gio.FileQueryInfoFlags flags, int ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoEqual(GISharp.Lib.Gio.IFile)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedEqual))]
        bool DoEqual(GISharp.Lib.Gio.IFile file2);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoGetBasename()']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedGetBasename))]
        GISharp.Lib.GLib.Utf8 DoGetBasename();

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoGetChildForDisplayName(GISharp.Lib.GLib.UnownedUtf8)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedGetChildForDisplayName))]
        GISharp.Lib.Gio.IFile DoGetChildForDisplayName(GISharp.Lib.GLib.UnownedUtf8 displayName);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoGetParent()']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedGetParent))]
        GISharp.Lib.Gio.IFile? DoGetParent();

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoGetParseName()']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedGetParseName))]
        GISharp.Lib.GLib.Utf8 DoGetParseName();

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoGetPath()']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedGetPath))]
        GISharp.Lib.GLib.Utf8 DoGetPath();

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoGetRelativePath(GISharp.Lib.Gio.IFile)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedGetRelativePath))]
        GISharp.Lib.GLib.Utf8 DoGetRelativePath(GISharp.Lib.Gio.IFile descendant);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoGetUri()']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedGetUri))]
        GISharp.Lib.GLib.Utf8 DoGetUri();

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoGetUriScheme()']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedGetUriScheme))]
        GISharp.Lib.GLib.Utf8 DoGetUriScheme();

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoHasUriScheme(GISharp.Lib.GLib.UnownedUtf8)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedHasUriScheme))]
        bool DoHasUriScheme(GISharp.Lib.GLib.UnownedUtf8 uriScheme);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoHash()']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedHash))]
        uint DoHash();

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoIsNative()']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedIsNative))]
        bool DoIsNative();

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoMakeDirectory(GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedMakeDirectory))]
        void DoMakeDirectory(GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoMakeDirectoryAsync(int,GISharp.Lib.Gio.AsyncReadyCallback?,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.SinceAttribute("2.38")]
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedMakeDirectoryAsync))]
        void DoMakeDirectoryAsync(int ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoMakeDirectoryFinish(GISharp.Lib.Gio.IAsyncResult)']/*" />
        [GISharp.Runtime.SinceAttribute("2.38")]
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedMakeDirectoryFinish))]
        void DoMakeDirectoryFinish(GISharp.Lib.Gio.IAsyncResult result);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoMakeSymbolicLink(GISharp.Lib.GLib.Filename,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedMakeSymbolicLink))]
        void DoMakeSymbolicLink(GISharp.Lib.GLib.Filename symlinkValue, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoMeasureDiskUsageFinish(GISharp.Lib.Gio.IAsyncResult,ulong,ulong,ulong)']/*" />
        [GISharp.Runtime.SinceAttribute("2.38")]
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedMeasureDiskUsageFinish))]
        void DoMeasureDiskUsageFinish(GISharp.Lib.Gio.IAsyncResult result, out ulong diskUsage, out ulong numDirs, out ulong numFiles);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoMountEnclosingVolumeFinish(GISharp.Lib.Gio.IAsyncResult)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedMountEnclosingVolumeFinish))]
        void DoMountEnclosingVolumeFinish(GISharp.Lib.Gio.IAsyncResult result);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoMountMountableFinish(GISharp.Lib.Gio.IAsyncResult)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedMountMountableFinish))]
        GISharp.Lib.Gio.IFile DoMountMountableFinish(GISharp.Lib.Gio.IAsyncResult result);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoMove(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.FileCopyFlags,GISharp.Lib.Gio.FileProgressCallback?,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedMove))]
        void DoMove(GISharp.Lib.Gio.IFile destination, GISharp.Lib.Gio.FileCopyFlags flags, GISharp.Lib.Gio.FileProgressCallback? progressCallback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoOpenReadwrite(GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.SinceAttribute("2.22")]
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedOpenReadwrite))]
        GISharp.Lib.Gio.FileIOStream DoOpenReadwrite(GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoOpenReadwriteAsync(int,GISharp.Lib.Gio.AsyncReadyCallback?,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.SinceAttribute("2.22")]
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedOpenReadwriteAsync))]
        void DoOpenReadwriteAsync(int ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoOpenReadwriteFinish(GISharp.Lib.Gio.IAsyncResult)']/*" />
        [GISharp.Runtime.SinceAttribute("2.22")]
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedOpenReadwriteFinish))]
        GISharp.Lib.Gio.FileIOStream DoOpenReadwriteFinish(GISharp.Lib.Gio.IAsyncResult res);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoPollMountable(GISharp.Lib.Gio.AsyncReadyCallback?,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.SinceAttribute("2.22")]
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedPollMountable))]
        void DoPollMountable(GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoPollMountableFinish(GISharp.Lib.Gio.IAsyncResult)']/*" />
        [GISharp.Runtime.SinceAttribute("2.22")]
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedPollMountableFinish))]
        void DoPollMountableFinish(GISharp.Lib.Gio.IAsyncResult result);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoPrefixMatches(GISharp.Lib.Gio.IFile)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedPrefixMatches))]
        bool DoPrefixMatches(GISharp.Lib.Gio.IFile file);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoQueryFilesystemInfo(GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedQueryFilesystemInfo))]
        GISharp.Lib.Gio.FileInfo DoQueryFilesystemInfo(GISharp.Lib.GLib.UnownedUtf8 attributes, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoQueryFilesystemInfoAsync(GISharp.Lib.GLib.UnownedUtf8,int,GISharp.Lib.Gio.AsyncReadyCallback?,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedQueryFilesystemInfoAsync))]
        void DoQueryFilesystemInfoAsync(GISharp.Lib.GLib.UnownedUtf8 attributes, int ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoQueryFilesystemInfoFinish(GISharp.Lib.Gio.IAsyncResult)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedQueryFilesystemInfoFinish))]
        GISharp.Lib.Gio.FileInfo DoQueryFilesystemInfoFinish(GISharp.Lib.Gio.IAsyncResult res);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoQueryInfo(GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.Gio.FileQueryInfoFlags,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedQueryInfo))]
        GISharp.Lib.Gio.FileInfo DoQueryInfo(GISharp.Lib.GLib.UnownedUtf8 attributes, GISharp.Lib.Gio.FileQueryInfoFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoQueryInfoAsync(GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.Gio.FileQueryInfoFlags,int,GISharp.Lib.Gio.AsyncReadyCallback?,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedQueryInfoAsync))]
        void DoQueryInfoAsync(GISharp.Lib.GLib.UnownedUtf8 attributes, GISharp.Lib.Gio.FileQueryInfoFlags flags, int ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoQueryInfoFinish(GISharp.Lib.Gio.IAsyncResult)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedQueryInfoFinish))]
        GISharp.Lib.Gio.FileInfo DoQueryInfoFinish(GISharp.Lib.Gio.IAsyncResult res);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoQuerySettableAttributes(GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedQuerySettableAttributes))]
        GISharp.Lib.Gio.FileAttributeInfoList DoQuerySettableAttributes(GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoQueryWritableNamespaces(GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedQueryWritableNamespaces))]
        GISharp.Lib.Gio.FileAttributeInfoList DoQueryWritableNamespaces(GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoReadAsync(int,GISharp.Lib.Gio.AsyncReadyCallback?,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedReadAsync))]
        void DoReadAsync(int ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoReadFinish(GISharp.Lib.Gio.IAsyncResult)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedReadFinish))]
        GISharp.Lib.Gio.FileInputStream DoReadFinish(GISharp.Lib.Gio.IAsyncResult res);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoReadFn(GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedReadFn))]
        GISharp.Lib.Gio.FileInputStream DoReadFn(GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoReplace(GISharp.Lib.GLib.NullableUnownedUtf8,bool,GISharp.Lib.Gio.FileCreateFlags,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedReplace))]
        GISharp.Lib.Gio.FileOutputStream DoReplace(GISharp.Lib.GLib.NullableUnownedUtf8 etag, bool makeBackup, GISharp.Lib.Gio.FileCreateFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoReplaceAsync(GISharp.Lib.GLib.NullableUnownedUtf8,bool,GISharp.Lib.Gio.FileCreateFlags,int,GISharp.Lib.Gio.AsyncReadyCallback?,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedReplaceAsync))]
        void DoReplaceAsync(GISharp.Lib.GLib.NullableUnownedUtf8 etag, bool makeBackup, GISharp.Lib.Gio.FileCreateFlags flags, int ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoReplaceFinish(GISharp.Lib.Gio.IAsyncResult)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedReplaceFinish))]
        GISharp.Lib.Gio.FileOutputStream DoReplaceFinish(GISharp.Lib.Gio.IAsyncResult res);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoReplaceReadwrite(GISharp.Lib.GLib.NullableUnownedUtf8,bool,GISharp.Lib.Gio.FileCreateFlags,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.SinceAttribute("2.22")]
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedReplaceReadwrite))]
        GISharp.Lib.Gio.FileIOStream DoReplaceReadwrite(GISharp.Lib.GLib.NullableUnownedUtf8 etag, bool makeBackup, GISharp.Lib.Gio.FileCreateFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoReplaceReadwriteAsync(GISharp.Lib.GLib.NullableUnownedUtf8,bool,GISharp.Lib.Gio.FileCreateFlags,int,GISharp.Lib.Gio.AsyncReadyCallback?,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.SinceAttribute("2.22")]
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedReplaceReadwriteAsync))]
        void DoReplaceReadwriteAsync(GISharp.Lib.GLib.NullableUnownedUtf8 etag, bool makeBackup, GISharp.Lib.Gio.FileCreateFlags flags, int ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoReplaceReadwriteFinish(GISharp.Lib.Gio.IAsyncResult)']/*" />
        [GISharp.Runtime.SinceAttribute("2.22")]
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedReplaceReadwriteFinish))]
        GISharp.Lib.Gio.FileIOStream DoReplaceReadwriteFinish(GISharp.Lib.Gio.IAsyncResult res);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoResolveRelativePath(GISharp.Lib.GLib.Filename)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedResolveRelativePath))]
        GISharp.Lib.Gio.IFile DoResolveRelativePath(GISharp.Lib.GLib.Filename relativePath);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoSetAttribute(GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.Gio.FileAttributeType,System.IntPtr,GISharp.Lib.Gio.FileQueryInfoFlags,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedSetAttribute))]
        void DoSetAttribute(GISharp.Lib.GLib.UnownedUtf8 attribute, GISharp.Lib.Gio.FileAttributeType type, System.IntPtr valueP, GISharp.Lib.Gio.FileQueryInfoFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoSetAttributesAsync(GISharp.Lib.Gio.FileInfo,GISharp.Lib.Gio.FileQueryInfoFlags,int,GISharp.Lib.Gio.AsyncReadyCallback?,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedSetAttributesAsync))]
        void DoSetAttributesAsync(GISharp.Lib.Gio.FileInfo info, GISharp.Lib.Gio.FileQueryInfoFlags flags, int ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoSetAttributesFinish(GISharp.Lib.Gio.IAsyncResult,GISharp.Lib.Gio.FileInfo)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedSetAttributesFinish))]
        void DoSetAttributesFinish(GISharp.Lib.Gio.IAsyncResult result, out GISharp.Lib.Gio.FileInfo info);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoSetAttributesFromInfo(GISharp.Lib.Gio.FileInfo,GISharp.Lib.Gio.FileQueryInfoFlags,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedSetAttributesFromInfo))]
        void DoSetAttributesFromInfo(GISharp.Lib.Gio.FileInfo info, GISharp.Lib.Gio.FileQueryInfoFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoSetDisplayName(GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedSetDisplayName))]
        GISharp.Lib.Gio.IFile DoSetDisplayName(GISharp.Lib.GLib.UnownedUtf8 displayName, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoSetDisplayNameAsync(GISharp.Lib.GLib.UnownedUtf8,int,GISharp.Lib.Gio.AsyncReadyCallback?,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedSetDisplayNameAsync))]
        void DoSetDisplayNameAsync(GISharp.Lib.GLib.UnownedUtf8 displayName, int ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoSetDisplayNameFinish(GISharp.Lib.Gio.IAsyncResult)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedSetDisplayNameFinish))]
        GISharp.Lib.Gio.IFile DoSetDisplayNameFinish(GISharp.Lib.Gio.IAsyncResult res);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoStartMountableFinish(GISharp.Lib.Gio.IAsyncResult)']/*" />
        [GISharp.Runtime.SinceAttribute("2.22")]
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedStartMountableFinish))]
        void DoStartMountableFinish(GISharp.Lib.Gio.IAsyncResult result);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoStopMountableFinish(GISharp.Lib.Gio.IAsyncResult)']/*" />
        [GISharp.Runtime.SinceAttribute("2.22")]
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedStopMountableFinish))]
        void DoStopMountableFinish(GISharp.Lib.Gio.IAsyncResult result);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoTrash(GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedTrash))]
        void DoTrash(GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoTrashAsync(int,GISharp.Lib.Gio.AsyncReadyCallback?,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.SinceAttribute("2.38")]
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedTrashAsync))]
        void DoTrashAsync(int ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoTrashFinish(GISharp.Lib.Gio.IAsyncResult)']/*" />
        [GISharp.Runtime.SinceAttribute("2.38")]
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedTrashFinish))]
        void DoTrashFinish(GISharp.Lib.Gio.IAsyncResult result);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoUnmountMountableFinish(GISharp.Lib.Gio.IAsyncResult)']/*" />
        [System.ObsoleteAttribute("Use g_file_unmount_mountable_with_operation_finish()\n    instead.")]
        [GISharp.Runtime.DeprecatedSinceAttribute("2.22")]
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedUnmountMountableFinish))]
        void DoUnmountMountableFinish(GISharp.Lib.Gio.IAsyncResult result);

        /// <include file="File.xmldoc" path="declaration/member[@name='IFile.DoUnmountMountableWithOperationFinish(GISharp.Lib.Gio.IAsyncResult)']/*" />
        [GISharp.Runtime.SinceAttribute("2.22")]
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(FileIface.UnmanagedUnmountMountableWithOperationFinish))]
        void DoUnmountMountableWithOperationFinish(GISharp.Lib.Gio.IAsyncResult result);
    }

    /// <summary>
    /// Extension methods for <see cref="IFile"/>
    /// </summary>
    public static unsafe partial class File
    {
        /// <summary>
        /// The unmanaged data structure.
        /// </summary>
        public struct UnmanagedStruct
        {
        }

        /// <summary>
        /// Gets an output stream for appending data to the file.
        /// If the file doesn't already exist it is created.
        /// </summary>
        /// <remarks>
        /// <para>
        /// By default files created are generally readable by everyone,
        /// but if you pass #G_FILE_CREATE_PRIVATE in @flags the file
        /// will be made readable only to the current user, to the level that
        /// is supported on the target filesystem.
        /// </para>
        /// <para>
        /// If @cancellable is not %NULL, then the operation can be cancelled
        /// by triggering the cancellable object from another thread. If the
        /// operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
        /// returned.
        /// </para>
        /// <para>
        /// Some file systems don't allow all file names, and may return an
        /// %G_IO_ERROR_INVALID_FILENAME error. If the file is a directory the
        /// %G_IO_ERROR_IS_DIRECTORY error will be returned. Other errors are
        /// possible too, and depend on what kind of filesystem the file is on.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="flags">
        /// a set of #GFileCreateFlags
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object,
        ///     %NULL to ignore
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// a #GFileOutputStream, or %NULL on error.
        ///     Free the returned object with g_object_unref().
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileOutputStream" type="GFileOutputStream*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct* g_file_append_to(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="FileCreateFlags" type="GFileCreateFlags" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.FileCreateFlags flags,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        static partial void CheckAppendToArgs(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.FileCreateFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.AppendTo(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.FileCreateFlags,GISharp.Lib.Gio.Cancellable?)']/*" />
        public static GISharp.Lib.Gio.FileOutputStream AppendTo(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.FileCreateFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckAppendToArgs(file, flags, cancellable);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var flags_ = (GISharp.Lib.Gio.FileCreateFlags)flags;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            var ret_ = g_file_append_to(file_,flags_,cancellable_,&error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Runtime.GErrorException(error);
            }

            var ret = GISharp.Lib.Gio.FileOutputStream.GetInstance<GISharp.Lib.Gio.FileOutputStream>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Asynchronously opens @file for appending.
        /// </summary>
        /// <remarks>
        /// <para>
        /// For more details, see g_file_append_to() which is
        /// the synchronous version of this call.
        /// </para>
        /// <para>
        /// When the operation is finished, @callback will be called.
        /// You can then call g_file_append_to_finish() to get the result
        /// of the operation.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="flags">
        /// a set of #GFileCreateFlags
        /// </param>
        /// <param name="ioPriority">
        /// the [I/O priority][io-priority] of the request
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object,
        ///     %NULL to ignore
        /// </param>
        /// <param name="callback">
        /// a #GAsyncReadyCallback to call
        ///     when the request is satisfied
        /// </param>
        /// <param name="userData">
        /// the data to pass to callback function
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Threading.Tasks.Task">
*   <type name="FileOutputStream" type="GFileOutputStream*" is-pointer="1" />
* </type> */
        /* transfer-ownership:none direction:in */
        private static extern void g_file_append_to_async(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="FileCreateFlags" type="GFileCreateFlags" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.FileCreateFlags flags,
        /* <type name="gint" type="int" /> */
        /* transfer-ownership:none direction:in */
        int ioPriority,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:4 direction:in */
        delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback,
        /* <type name="gpointer" type="gpointer" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr userData);
        static partial void CheckAppendToAsyncArgs(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.FileCreateFlags flags, int ioPriority = GISharp.Lib.GLib.Priority.Default, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.AppendToAsync(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.FileCreateFlags,int,GISharp.Lib.Gio.Cancellable?)']/*" />
        public static System.Threading.Tasks.Task<GISharp.Lib.Gio.FileOutputStream> AppendToAsync(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.FileCreateFlags flags, int ioPriority = GISharp.Lib.GLib.Priority.Default, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckAppendToAsyncArgs(file, flags, ioPriority, cancellable);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var flags_ = (GISharp.Lib.Gio.FileCreateFlags)flags;
            var ioPriority_ = (int)ioPriority;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var completionSource = new System.Threading.Tasks.TaskCompletionSource<GISharp.Lib.Gio.FileOutputStream>();
            var callback_ = (delegate* unmanaged[Cdecl] <GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void>)&AppendToFinish;
            var userData_ = (System.IntPtr)System.Runtime.InteropServices.GCHandle.Alloc(completionSource);
            g_file_append_to_async(file_, flags_, ioPriority_, cancellable_, callback_, userData_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            return completionSource.Task;
        }

        /// <summary>
        /// Finishes an asynchronous file append operation started with
        /// g_file_append_to_async().
        /// </summary>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="res">
        /// #GAsyncResult
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// a valid #GFileOutputStream
        ///     or %NULL on error.
        ///     Free the returned object with g_object_unref().
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileOutputStream" type="GFileOutputStream*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct* g_file_append_to_finish(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="AsyncResult" type="GAsyncResult*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        [System.Runtime.InteropServices.UnmanagedCallersOnlyAttribute(CallConvs = new[] { typeof(System.Runtime.CompilerServices.CallConvCdecl) })]
        private static void AppendToFinish(GISharp.Lib.GObject.Object.UnmanagedStruct* sourceObject_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res_, System.IntPtr userData_)
        {
            try
            {
                var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)sourceObject_;
                var userData = (System.Runtime.InteropServices.GCHandle)userData_;
                var completionSource = (System.Threading.Tasks.TaskCompletionSource<GISharp.Lib.Gio.FileOutputStream>)userData.Target!;
                userData.Free();
                var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
                var ret_ = g_file_append_to_finish(file_,res_,&error_);
                if (error_ is not null)
                {
                    var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                    completionSource.SetException(new GISharp.Runtime.GErrorException(error));
                    return;
                }
                var ret = GISharp.Lib.Gio.FileOutputStream.GetInstance<GISharp.Lib.Gio.FileOutputStream>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
                completionSource.SetResult((ret));
            }
            catch (System.Exception ex)
            {
                GISharp.Runtime.GMarshal.PushUnhandledException(ex);
            }
        }

        /// <summary>
        /// Copies the file @source to the location specified by @destination.
        /// Can not handle recursive copies of directories.
        /// </summary>
        /// <remarks>
        /// <para>
        /// If the flag #G_FILE_COPY_OVERWRITE is specified an already
        /// existing @destination file is overwritten.
        /// </para>
        /// <para>
        /// If the flag #G_FILE_COPY_NOFOLLOW_SYMLINKS is specified then symlinks
        /// will be copied as symlinks, otherwise the target of the
        /// @source symlink will be copied.
        /// </para>
        /// <para>
        /// If the flag #G_FILE_COPY_ALL_METADATA is specified then all the metadata
        /// that is possible to copy is copied, not just the default subset (which,
        /// for instance, does not include the owner, see #GFileInfo).
        /// </para>
        /// <para>
        /// If @cancellable is not %NULL, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
        /// </para>
        /// <para>
        /// If @progress_callback is not %NULL, then the operation can be monitored
        /// by setting this to a #GFileProgressCallback function.
        /// @progress_callback_data will be passed to this function. It is guaranteed
        /// that this callback will be called after all data has been transferred with
        /// the total number of bytes copied during the operation.
        /// </para>
        /// <para>
        /// If the @source file does not exist, then the %G_IO_ERROR_NOT_FOUND error
        /// is returned, independent on the status of the @destination.
        /// </para>
        /// <para>
        /// If #G_FILE_COPY_OVERWRITE is not specified and the target exists, then
        /// the error %G_IO_ERROR_EXISTS is returned.
        /// </para>
        /// <para>
        /// If trying to overwrite a file over a directory, the %G_IO_ERROR_IS_DIRECTORY
        /// error is returned. If trying to overwrite a directory with a directory the
        /// %G_IO_ERROR_WOULD_MERGE error is returned.
        /// </para>
        /// <para>
        /// If the source is a directory and the target does not exist, or
        /// #G_FILE_COPY_OVERWRITE is specified and the target is a file, then the
        /// %G_IO_ERROR_WOULD_RECURSE error is returned.
        /// </para>
        /// <para>
        /// If you are interested in copying the #GFile object itself (not the on-disk
        /// file), see g_file_dup().
        /// </para>
        /// </remarks>
        /// <param name="source">
        /// input #GFile
        /// </param>
        /// <param name="destination">
        /// destination #GFile
        /// </param>
        /// <param name="flags">
        /// set of #GFileCopyFlags
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object,
        ///     %NULL to ignore
        /// </param>
        /// <param name="progressCallback">
        /// function to callback with
        ///     progress information, or %NULL if progress information is not needed
        /// </param>
        /// <param name="progressCallbackData">
        /// user data to pass to @progress_callback
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// %TRUE on success, %FALSE otherwise.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        private static extern GISharp.Runtime.Boolean g_file_copy(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* source,
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* destination,
        /* <type name="FileCopyFlags" type="GFileCopyFlags" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.FileCopyFlags flags,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="FileProgressCallback" type="GFileProgressCallback" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:call closure:4 direction:in */
        delegate* unmanaged[Cdecl]<long, long, System.IntPtr, void> progressCallback,
        /* <type name="gpointer" type="gpointer" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr progressCallbackData,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        static partial void CheckCopyArgs(this GISharp.Lib.Gio.IFile source, GISharp.Lib.Gio.IFile destination, GISharp.Lib.Gio.FileCopyFlags flags, GISharp.Lib.Gio.FileProgressCallback? progressCallback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.Copy(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.FileCopyFlags,GISharp.Lib.Gio.FileProgressCallback?,GISharp.Lib.Gio.Cancellable?)']/*" />
        public static void Copy(this GISharp.Lib.Gio.IFile source, GISharp.Lib.Gio.IFile destination, GISharp.Lib.Gio.FileCopyFlags flags, GISharp.Lib.Gio.FileProgressCallback? progressCallback, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckCopyArgs(source, destination, flags, progressCallback, cancellable);
            var source_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)source.UnsafeHandle;
            var destination_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)destination.UnsafeHandle;
            var flags_ = (GISharp.Lib.Gio.FileCopyFlags)flags;
            var progressCallback_ = progressCallback is null ? default : (delegate* unmanaged[Cdecl]<long, long, System.IntPtr, void>)&GISharp.Lib.Gio.FileProgressCallbackMarshal.Callback;
            var progressCallbackHandle = progressCallback is null ? default : System.Runtime.InteropServices.GCHandle.Alloc((progressCallback, GISharp.Runtime.CallbackScope.Call));
            var progressCallbackData_ = (System.IntPtr)progressCallbackHandle;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            g_file_copy(source_, destination_, flags_, cancellable_, progressCallback_, progressCallbackData_, &error_);
            if (progressCallback is not null)
            {
                progressCallbackHandle.Free();
            }

            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Runtime.GErrorException(error);
            }
        }

        /// <summary>
        /// Copies the file @source to the location specified by @destination
        /// asynchronously. For details of the behaviour, see g_file_copy().
        /// </summary>
        /// <remarks>
        /// <para>
        /// If @progress_callback is not %NULL, then that function that will be called
        /// just like in g_file_copy(). The callback will run in the default main context
        /// of the thread calling g_file_copy_async() — the same context as @callback is
        /// run in.
        /// </para>
        /// <para>
        /// When the operation is finished, @callback will be called. You can then call
        /// g_file_copy_finish() to get the result of the operation.
        /// </para>
        /// </remarks>
        /// <param name="source">
        /// input #GFile
        /// </param>
        /// <param name="destination">
        /// destination #GFile
        /// </param>
        /// <param name="flags">
        /// set of #GFileCopyFlags
        /// </param>
        /// <param name="ioPriority">
        /// the [I/O priority][io-priority] of the request
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object,
        ///     %NULL to ignore
        /// </param>
        /// <param name="progressCallback">
        /// function to callback with progress
        ///     information, or %NULL if progress information is not needed
        /// </param>
        /// <param name="progressCallbackData">
        /// user data to pass to @progress_callback
        /// </param>
        /// <param name="callback">
        /// a #GAsyncReadyCallback to call when the request is satisfied
        /// </param>
        /// <param name="userData">
        /// the data to pass to callback function
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Threading.Tasks.Task" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_file_copy_async(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* source,
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* destination,
        /* <type name="FileCopyFlags" type="GFileCopyFlags" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.FileCopyFlags flags,
        /* <type name="gint" type="int" /> */
        /* transfer-ownership:none direction:in */
        int ioPriority,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="FileProgressCallback" type="GFileProgressCallback" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:5 direction:in */
        delegate* unmanaged[Cdecl]<long, long, System.IntPtr, void> progressCallback,
        /* <type name="gpointer" type="gpointer" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr progressCallbackData,
        /* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:7 direction:in */
        delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback,
        /* <type name="gpointer" type="gpointer" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr userData);
        static partial void CheckCopyAsyncArgs(this GISharp.Lib.Gio.IFile source, GISharp.Lib.Gio.IFile destination, GISharp.Lib.Gio.FileCopyFlags flags, int ioPriority = GISharp.Lib.GLib.Priority.Default, GISharp.Lib.Gio.Cancellable? cancellable = null, GISharp.Lib.Gio.FileProgressCallback? progressCallback = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.CopyAsync(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.FileCopyFlags,int,GISharp.Lib.Gio.Cancellable?,GISharp.Lib.Gio.FileProgressCallback?)']/*" />
        public static System.Threading.Tasks.Task CopyAsync(this GISharp.Lib.Gio.IFile source, GISharp.Lib.Gio.IFile destination, GISharp.Lib.Gio.FileCopyFlags flags, int ioPriority = GISharp.Lib.GLib.Priority.Default, GISharp.Lib.Gio.Cancellable? cancellable = null, GISharp.Lib.Gio.FileProgressCallback? progressCallback = null)
        {
            CheckCopyAsyncArgs(source, destination, flags, ioPriority, cancellable, progressCallback);
            var source_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)source.UnsafeHandle;
            var destination_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)destination.UnsafeHandle;
            var flags_ = (GISharp.Lib.Gio.FileCopyFlags)flags;
            var ioPriority_ = (int)ioPriority;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var progressCallback_ = progressCallback is null ? default : (delegate* unmanaged[Cdecl]<long, long, System.IntPtr, void>)&GISharp.Lib.Gio.FileProgressCallbackMarshal.Callback;
            var progressCallbackHandle = progressCallback is null ? default : System.Runtime.InteropServices.GCHandle.Alloc((progressCallback, GISharp.Runtime.CallbackScope.Async));
            var progressCallbackData_ = (System.IntPtr)progressCallbackHandle;
            var completionSource = new System.Threading.Tasks.TaskCompletionSource<GISharp.Runtime.Void>();
            var callback_ = (delegate* unmanaged[Cdecl] <GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void>)&CopyFinish;
            var userData_ = (System.IntPtr)System.Runtime.InteropServices.GCHandle.Alloc(completionSource);
            g_file_copy_async(source_, destination_, flags_, ioPriority_, cancellable_, progressCallback_, progressCallbackData_, callback_, userData_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            return completionSource.Task;
        }

        /// <summary>
        /// Copies the file attributes from @source to @destination.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Normally only a subset of the file attributes are copied,
        /// those that are copies in a normal file copy operation
        /// (which for instance does not include e.g. owner). However
        /// if #G_FILE_COPY_ALL_METADATA is specified in @flags, then
        /// all the metadata that is possible to copy is copied. This
        /// is useful when implementing move by copy + delete source.
        /// </para>
        /// </remarks>
        /// <param name="source">
        /// a #GFile with attributes
        /// </param>
        /// <param name="destination">
        /// a #GFile to copy attributes to
        /// </param>
        /// <param name="flags">
        /// a set of #GFileCopyFlags
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object,
        ///     %NULL to ignore
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// %TRUE if the attributes were copied successfully,
        ///     %FALSE otherwise.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        private static extern GISharp.Runtime.Boolean g_file_copy_attributes(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* source,
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* destination,
        /* <type name="FileCopyFlags" type="GFileCopyFlags" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.FileCopyFlags flags,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        static partial void CheckCopyAttributesArgs(this GISharp.Lib.Gio.IFile source, GISharp.Lib.Gio.IFile destination, GISharp.Lib.Gio.FileCopyFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.CopyAttributes(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.FileCopyFlags,GISharp.Lib.Gio.Cancellable?)']/*" />
        public static void CopyAttributes(this GISharp.Lib.Gio.IFile source, GISharp.Lib.Gio.IFile destination, GISharp.Lib.Gio.FileCopyFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckCopyAttributesArgs(source, destination, flags, cancellable);
            var source_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)source.UnsafeHandle;
            var destination_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)destination.UnsafeHandle;
            var flags_ = (GISharp.Lib.Gio.FileCopyFlags)flags;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            g_file_copy_attributes(source_, destination_, flags_, cancellable_, &error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Runtime.GErrorException(error);
            }
        }

        /// <summary>
        /// Finishes copying the file started with g_file_copy_async().
        /// </summary>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="res">
        /// a #GAsyncResult
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// a %TRUE on success, %FALSE on error.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        private static extern GISharp.Runtime.Boolean g_file_copy_finish(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="AsyncResult" type="GAsyncResult*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        [System.Runtime.InteropServices.UnmanagedCallersOnlyAttribute(CallConvs = new[] { typeof(System.Runtime.CompilerServices.CallConvCdecl) })]
        private static void CopyFinish(GISharp.Lib.GObject.Object.UnmanagedStruct* sourceObject_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res_, System.IntPtr userData_)
        {
            try
            {
                var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)sourceObject_;
                var userData = (System.Runtime.InteropServices.GCHandle)userData_;
                var completionSource = (System.Threading.Tasks.TaskCompletionSource<GISharp.Runtime.Void>)userData.Target!;
                userData.Free();
                var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
                g_file_copy_finish(file_, res_, &error_);
                if (error_ is not null)
                {
                    var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                    completionSource.SetException(new GISharp.Runtime.GErrorException(error));
                    return;
                }
                completionSource.SetResult(GISharp.Runtime.Void.Default);
            }
            catch (System.Exception ex)
            {
                GISharp.Runtime.GMarshal.PushUnhandledException(ex);
            }
        }

        /// <summary>
        /// Creates a new file and returns an output stream for writing to it.
        /// The file must not already exist.
        /// </summary>
        /// <remarks>
        /// <para>
        /// By default files created are generally readable by everyone,
        /// but if you pass #G_FILE_CREATE_PRIVATE in @flags the file
        /// will be made readable only to the current user, to the level
        /// that is supported on the target filesystem.
        /// </para>
        /// <para>
        /// If @cancellable is not %NULL, then the operation can be cancelled
        /// by triggering the cancellable object from another thread. If the
        /// operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
        /// returned.
        /// </para>
        /// <para>
        /// If a file or directory with this name already exists the
        /// %G_IO_ERROR_EXISTS error will be returned. Some file systems don't
        /// allow all file names, and may return an %G_IO_ERROR_INVALID_FILENAME
        /// error, and if the name is to long %G_IO_ERROR_FILENAME_TOO_LONG will
        /// be returned. Other errors are possible too, and depend on what kind
        /// of filesystem the file is on.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="flags">
        /// a set of #GFileCreateFlags
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object,
        ///     %NULL to ignore
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// a #GFileOutputStream for the newly created
        ///     file, or %NULL on error.
        ///     Free the returned object with g_object_unref().
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileOutputStream" type="GFileOutputStream*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct* g_file_create(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="FileCreateFlags" type="GFileCreateFlags" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.FileCreateFlags flags,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        static partial void CheckCreateArgs(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.FileCreateFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.Create(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.FileCreateFlags,GISharp.Lib.Gio.Cancellable?)']/*" />
        public static GISharp.Lib.Gio.FileOutputStream Create(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.FileCreateFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckCreateArgs(file, flags, cancellable);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var flags_ = (GISharp.Lib.Gio.FileCreateFlags)flags;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            var ret_ = g_file_create(file_,flags_,cancellable_,&error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Runtime.GErrorException(error);
            }

            var ret = GISharp.Lib.Gio.FileOutputStream.GetInstance<GISharp.Lib.Gio.FileOutputStream>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Asynchronously creates a new file and returns an output stream
        /// for writing to it. The file must not already exist.
        /// </summary>
        /// <remarks>
        /// <para>
        /// For more details, see g_file_create() which is
        /// the synchronous version of this call.
        /// </para>
        /// <para>
        /// When the operation is finished, @callback will be called.
        /// You can then call g_file_create_finish() to get the result
        /// of the operation.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="flags">
        /// a set of #GFileCreateFlags
        /// </param>
        /// <param name="ioPriority">
        /// the [I/O priority][io-priority] of the request
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object,
        ///     %NULL to ignore
        /// </param>
        /// <param name="callback">
        /// a #GAsyncReadyCallback to call
        ///     when the request is satisfied
        /// </param>
        /// <param name="userData">
        /// the data to pass to callback function
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Threading.Tasks.Task">
*   <type name="FileOutputStream" type="GFileOutputStream*" is-pointer="1" />
* </type> */
        /* transfer-ownership:none direction:in */
        private static extern void g_file_create_async(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="FileCreateFlags" type="GFileCreateFlags" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.FileCreateFlags flags,
        /* <type name="gint" type="int" /> */
        /* transfer-ownership:none direction:in */
        int ioPriority,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:4 direction:in */
        delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback,
        /* <type name="gpointer" type="gpointer" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr userData);
        static partial void CheckCreateAsyncArgs(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.FileCreateFlags flags, int ioPriority = GISharp.Lib.GLib.Priority.Default, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.CreateAsync(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.FileCreateFlags,int,GISharp.Lib.Gio.Cancellable?)']/*" />
        public static System.Threading.Tasks.Task<GISharp.Lib.Gio.FileOutputStream> CreateAsync(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.FileCreateFlags flags, int ioPriority = GISharp.Lib.GLib.Priority.Default, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckCreateAsyncArgs(file, flags, ioPriority, cancellable);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var flags_ = (GISharp.Lib.Gio.FileCreateFlags)flags;
            var ioPriority_ = (int)ioPriority;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var completionSource = new System.Threading.Tasks.TaskCompletionSource<GISharp.Lib.Gio.FileOutputStream>();
            var callback_ = (delegate* unmanaged[Cdecl] <GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void>)&CreateFinish;
            var userData_ = (System.IntPtr)System.Runtime.InteropServices.GCHandle.Alloc(completionSource);
            g_file_create_async(file_, flags_, ioPriority_, cancellable_, callback_, userData_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            return completionSource.Task;
        }

        /// <summary>
        /// Finishes an asynchronous file create operation started with
        /// g_file_create_async().
        /// </summary>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="res">
        /// a #GAsyncResult
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// a #GFileOutputStream or %NULL on error.
        ///     Free the returned object with g_object_unref().
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileOutputStream" type="GFileOutputStream*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct* g_file_create_finish(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="AsyncResult" type="GAsyncResult*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        [System.Runtime.InteropServices.UnmanagedCallersOnlyAttribute(CallConvs = new[] { typeof(System.Runtime.CompilerServices.CallConvCdecl) })]
        private static void CreateFinish(GISharp.Lib.GObject.Object.UnmanagedStruct* sourceObject_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res_, System.IntPtr userData_)
        {
            try
            {
                var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)sourceObject_;
                var userData = (System.Runtime.InteropServices.GCHandle)userData_;
                var completionSource = (System.Threading.Tasks.TaskCompletionSource<GISharp.Lib.Gio.FileOutputStream>)userData.Target!;
                userData.Free();
                var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
                var ret_ = g_file_create_finish(file_,res_,&error_);
                if (error_ is not null)
                {
                    var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                    completionSource.SetException(new GISharp.Runtime.GErrorException(error));
                    return;
                }
                var ret = GISharp.Lib.Gio.FileOutputStream.GetInstance<GISharp.Lib.Gio.FileOutputStream>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
                completionSource.SetResult((ret));
            }
            catch (System.Exception ex)
            {
                GISharp.Runtime.GMarshal.PushUnhandledException(ex);
            }
        }

        /// <summary>
        /// Creates a new file and returns a stream for reading and
        /// writing to it. The file must not already exist.
        /// </summary>
        /// <remarks>
        /// <para>
        /// By default files created are generally readable by everyone,
        /// but if you pass #G_FILE_CREATE_PRIVATE in @flags the file
        /// will be made readable only to the current user, to the level
        /// that is supported on the target filesystem.
        /// </para>
        /// <para>
        /// If @cancellable is not %NULL, then the operation can be cancelled
        /// by triggering the cancellable object from another thread. If the
        /// operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
        /// returned.
        /// </para>
        /// <para>
        /// If a file or directory with this name already exists, the
        /// %G_IO_ERROR_EXISTS error will be returned. Some file systems don't
        /// allow all file names, and may return an %G_IO_ERROR_INVALID_FILENAME
        /// error, and if the name is too long, %G_IO_ERROR_FILENAME_TOO_LONG
        /// will be returned. Other errors are possible too, and depend on what
        /// kind of filesystem the file is on.
        /// </para>
        /// <para>
        /// Note that in many non-local file cases read and write streams are
        /// not supported, so make sure you really need to do read and write
        /// streaming, rather than just opening for reading or writing.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// a #GFile
        /// </param>
        /// <param name="flags">
        /// a set of #GFileCreateFlags
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object,
        ///     %NULL to ignore
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// a #GFileIOStream for the newly created
        ///     file, or %NULL on error.
        ///     Free the returned object with g_object_unref().
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.22")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileIOStream" type="GFileIOStream*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.Gio.FileIOStream.UnmanagedStruct* g_file_create_readwrite(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="FileCreateFlags" type="GFileCreateFlags" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.FileCreateFlags flags,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        static partial void CheckCreateReadwriteArgs(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.FileCreateFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.CreateReadwrite(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.FileCreateFlags,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.SinceAttribute("2.22")]
        public static GISharp.Lib.Gio.FileIOStream CreateReadwrite(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.FileCreateFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckCreateReadwriteArgs(file, flags, cancellable);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var flags_ = (GISharp.Lib.Gio.FileCreateFlags)flags;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            var ret_ = g_file_create_readwrite(file_,flags_,cancellable_,&error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Runtime.GErrorException(error);
            }

            var ret = GISharp.Lib.Gio.FileIOStream.GetInstance<GISharp.Lib.Gio.FileIOStream>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Asynchronously creates a new file and returns a stream
        /// for reading and writing to it. The file must not already exist.
        /// </summary>
        /// <remarks>
        /// <para>
        /// For more details, see g_file_create_readwrite() which is
        /// the synchronous version of this call.
        /// </para>
        /// <para>
        /// When the operation is finished, @callback will be called.
        /// You can then call g_file_create_readwrite_finish() to get
        /// the result of the operation.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="flags">
        /// a set of #GFileCreateFlags
        /// </param>
        /// <param name="ioPriority">
        /// the [I/O priority][io-priority] of the request
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object,
        ///     %NULL to ignore
        /// </param>
        /// <param name="callback">
        /// a #GAsyncReadyCallback to call
        ///     when the request is satisfied
        /// </param>
        /// <param name="userData">
        /// the data to pass to callback function
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.22")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Threading.Tasks.Task">
*   <type name="FileIOStream" type="GFileIOStream*" is-pointer="1" />
* </type> */
        /* transfer-ownership:none direction:in */
        private static extern void g_file_create_readwrite_async(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="FileCreateFlags" type="GFileCreateFlags" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.FileCreateFlags flags,
        /* <type name="gint" type="int" /> */
        /* transfer-ownership:none direction:in */
        int ioPriority,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:4 direction:in */
        delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback,
        /* <type name="gpointer" type="gpointer" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr userData);
        static partial void CheckCreateReadwriteAsyncArgs(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.FileCreateFlags flags, int ioPriority = GISharp.Lib.GLib.Priority.Default, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.CreateReadwriteAsync(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.FileCreateFlags,int,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.SinceAttribute("2.22")]
        public static System.Threading.Tasks.Task<GISharp.Lib.Gio.FileIOStream> CreateReadwriteAsync(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.FileCreateFlags flags, int ioPriority = GISharp.Lib.GLib.Priority.Default, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckCreateReadwriteAsyncArgs(file, flags, ioPriority, cancellable);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var flags_ = (GISharp.Lib.Gio.FileCreateFlags)flags;
            var ioPriority_ = (int)ioPriority;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var completionSource = new System.Threading.Tasks.TaskCompletionSource<GISharp.Lib.Gio.FileIOStream>();
            var callback_ = (delegate* unmanaged[Cdecl] <GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void>)&CreateReadwriteFinish;
            var userData_ = (System.IntPtr)System.Runtime.InteropServices.GCHandle.Alloc(completionSource);
            g_file_create_readwrite_async(file_, flags_, ioPriority_, cancellable_, callback_, userData_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            return completionSource.Task;
        }

        /// <summary>
        /// Finishes an asynchronous file create operation started with
        /// g_file_create_readwrite_async().
        /// </summary>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="res">
        /// a #GAsyncResult
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// a #GFileIOStream or %NULL on error.
        ///     Free the returned object with g_object_unref().
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.22")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileIOStream" type="GFileIOStream*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.Gio.FileIOStream.UnmanagedStruct* g_file_create_readwrite_finish(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="AsyncResult" type="GAsyncResult*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        [System.Runtime.InteropServices.UnmanagedCallersOnlyAttribute(CallConvs = new[] { typeof(System.Runtime.CompilerServices.CallConvCdecl) })]
        private static void CreateReadwriteFinish(GISharp.Lib.GObject.Object.UnmanagedStruct* sourceObject_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res_, System.IntPtr userData_)
        {
            try
            {
                var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)sourceObject_;
                var userData = (System.Runtime.InteropServices.GCHandle)userData_;
                var completionSource = (System.Threading.Tasks.TaskCompletionSource<GISharp.Lib.Gio.FileIOStream>)userData.Target!;
                userData.Free();
                var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
                var ret_ = g_file_create_readwrite_finish(file_,res_,&error_);
                if (error_ is not null)
                {
                    var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                    completionSource.SetException(new GISharp.Runtime.GErrorException(error));
                    return;
                }
                var ret = GISharp.Lib.Gio.FileIOStream.GetInstance<GISharp.Lib.Gio.FileIOStream>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
                completionSource.SetResult((ret));
            }
            catch (System.Exception ex)
            {
                GISharp.Runtime.GMarshal.PushUnhandledException(ex);
            }
        }

        /// <summary>
        /// Deletes a file. If the @file is a directory, it will only be
        /// deleted if it is empty. This has the same semantics as g_unlink().
        /// </summary>
        /// <remarks>
        /// <para>
        /// If @file doesn’t exist, %G_IO_ERROR_NOT_FOUND will be returned. This allows
        /// for deletion to be implemented avoiding
        /// [time-of-check to time-of-use races](https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use):
        /// |[
        /// g_autoptr(GError) local_error = NULL;
        /// if (!g_file_delete (my_file, my_cancellable, &amp;local_error) &amp;&amp;
        ///     !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))
        ///   {
        ///     // deletion failed for some reason other than the file not existing:
        ///     // so report the error
        ///     g_warning ("Failed to delete %s: %s",
        ///                g_file_peek_path (my_file), local_error-&gt;message);
        ///   }
        /// ]|
        /// </para>
        /// <para>
        /// If @cancellable is not %NULL, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object,
        ///     %NULL to ignore
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// %TRUE if the file was deleted. %FALSE otherwise.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        private static extern GISharp.Runtime.Boolean g_file_delete(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        static partial void CheckDeleteArgs(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.Delete(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.Cancellable?)']/*" />
        public static void Delete(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckDeleteArgs(file, cancellable);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            g_file_delete(file_, cancellable_, &error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Runtime.GErrorException(error);
            }
        }

        /// <summary>
        /// Asynchronously delete a file. If the @file is a directory, it will
        /// only be deleted if it is empty.  This has the same semantics as
        /// g_unlink().
        /// </summary>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="ioPriority">
        /// the [I/O priority][io-priority] of the request
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object,
        ///     %NULL to ignore
        /// </param>
        /// <param name="callback">
        /// a #GAsyncReadyCallback to call
        ///     when the request is satisfied
        /// </param>
        /// <param name="userData">
        /// the data to pass to callback function
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.34")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Threading.Tasks.Task" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_file_delete_async(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="gint" type="int" /> */
        /* transfer-ownership:none direction:in */
        int ioPriority,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:3 direction:in */
        delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback,
        /* <type name="gpointer" type="gpointer" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr userData);
        static partial void CheckDeleteAsyncArgs(this GISharp.Lib.Gio.IFile file, int ioPriority = GISharp.Lib.GLib.Priority.Default, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.DeleteAsync(GISharp.Lib.Gio.IFile,int,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.SinceAttribute("2.34")]
        public static System.Threading.Tasks.Task DeleteAsync(this GISharp.Lib.Gio.IFile file, int ioPriority = GISharp.Lib.GLib.Priority.Default, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckDeleteAsyncArgs(file, ioPriority, cancellable);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var ioPriority_ = (int)ioPriority;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var completionSource = new System.Threading.Tasks.TaskCompletionSource<GISharp.Runtime.Void>();
            var callback_ = (delegate* unmanaged[Cdecl] <GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void>)&DeleteFinish;
            var userData_ = (System.IntPtr)System.Runtime.InteropServices.GCHandle.Alloc(completionSource);
            g_file_delete_async(file_, ioPriority_, cancellable_, callback_, userData_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            return completionSource.Task;
        }

        /// <summary>
        /// Finishes deleting a file started with g_file_delete_async().
        /// </summary>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="result">
        /// a #GAsyncResult
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// %TRUE if the file was deleted. %FALSE otherwise.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.34")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        private static extern GISharp.Runtime.Boolean g_file_delete_finish(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="AsyncResult" type="GAsyncResult*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        [System.Runtime.InteropServices.UnmanagedCallersOnlyAttribute(CallConvs = new[] { typeof(System.Runtime.CompilerServices.CallConvCdecl) })]
        private static void DeleteFinish(GISharp.Lib.GObject.Object.UnmanagedStruct* sourceObject_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result_, System.IntPtr userData_)
        {
            try
            {
                var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)sourceObject_;
                var userData = (System.Runtime.InteropServices.GCHandle)userData_;
                var completionSource = (System.Threading.Tasks.TaskCompletionSource<GISharp.Runtime.Void>)userData.Target!;
                userData.Free();
                var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
                g_file_delete_finish(file_, result_, &error_);
                if (error_ is not null)
                {
                    var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                    completionSource.SetException(new GISharp.Runtime.GErrorException(error));
                    return;
                }
                completionSource.SetResult(GISharp.Runtime.Void.Default);
            }
            catch (System.Exception ex)
            {
                GISharp.Runtime.GMarshal.PushUnhandledException(ex);
            }
        }

        /// <summary>
        /// Duplicates a #GFile handle. This operation does not duplicate
        /// the actual file or directory represented by the #GFile; see
        /// g_file_copy() if attempting to copy a file.
        /// </summary>
        /// <remarks>
        /// <para>
        /// g_file_dup() is useful when a second handle is needed to the same underlying
        /// file, for use in a separate thread (#GFile is not thread-safe). For use
        /// within the same thread, use g_object_ref() to increment the existing object’s
        /// reference count.
        /// </para>
        /// <para>
        /// This call does no blocking I/O.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <returns>
        /// a new #GFile that is a duplicate
        ///     of the given #GFile.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.Gio.File.UnmanagedStruct* g_file_dup(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file);
        static partial void CheckDupArgs(this GISharp.Lib.Gio.IFile file);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.Dup(GISharp.Lib.Gio.IFile)']/*" />
        public static GISharp.Lib.Gio.IFile Dup(this GISharp.Lib.Gio.IFile file)
        {
            CheckDupArgs(file);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var ret_ = g_file_dup(file_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Finishes an asynchronous eject operation started by
        /// g_file_eject_mountable().
        /// </summary>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="result">
        /// a #GAsyncResult
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// %TRUE if the @file was ejected successfully.
        ///     %FALSE otherwise.
        /// </returns>
        [System.ObsoleteAttribute("Use g_file_eject_mountable_with_operation_finish()\n    instead.")]
        [GISharp.Runtime.DeprecatedSinceAttribute("2.22")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        private static extern GISharp.Runtime.Boolean g_file_eject_mountable_finish(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="AsyncResult" type="GAsyncResult*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        static partial void CheckEjectMountableFinishArgs(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.IAsyncResult result);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.EjectMountableFinish(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.IAsyncResult)']/*" />
        [System.ObsoleteAttribute("Use g_file_eject_mountable_with_operation_finish()\n    instead.")]
        [GISharp.Runtime.DeprecatedSinceAttribute("2.22")]
        public static void EjectMountableFinish(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.IAsyncResult result)
        {
            CheckEjectMountableFinishArgs(file, result);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var result_ = (GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*)result.UnsafeHandle;
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            g_file_eject_mountable_finish(file_, result_, &error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Runtime.GErrorException(error);
            }
        }

        /// <summary>
        /// Finishes an asynchronous eject operation started by
        /// g_file_eject_mountable_with_operation().
        /// </summary>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="result">
        /// a #GAsyncResult
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// %TRUE if the @file was ejected successfully.
        ///     %FALSE otherwise.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.22")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        private static extern GISharp.Runtime.Boolean g_file_eject_mountable_with_operation_finish(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="AsyncResult" type="GAsyncResult*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        static partial void CheckEjectMountableWithOperationFinishArgs(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.IAsyncResult result);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.EjectMountableWithOperationFinish(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.IAsyncResult)']/*" />
        [GISharp.Runtime.SinceAttribute("2.22")]
        public static void EjectMountableWithOperationFinish(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.IAsyncResult result)
        {
            CheckEjectMountableWithOperationFinishArgs(file, result);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var result_ = (GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*)result.UnsafeHandle;
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            g_file_eject_mountable_with_operation_finish(file_, result_, &error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Runtime.GErrorException(error);
            }
        }

        /// <summary>
        /// Checks if the two given #GFiles refer to the same file.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Note that two #GFiles that differ can still refer to the same
        /// file on the filesystem due to various forms of filename
        /// aliasing.
        /// </para>
        /// <para>
        /// This call does no blocking I/O.
        /// </para>
        /// </remarks>
        /// <param name="file1">
        /// the first #GFile
        /// </param>
        /// <param name="file2">
        /// the second #GFile
        /// </param>
        /// <returns>
        /// %TRUE if @file1 and @file2 are equal.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_file_equal(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file1,
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file2);
        static partial void CheckEqualsArgs(this GISharp.Lib.Gio.IFile file1, GISharp.Lib.Gio.IFile file2);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.Equals(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.IFile)']/*" />
        public static bool Equals(this GISharp.Lib.Gio.IFile file1, GISharp.Lib.Gio.IFile file2)
        {
            CheckEqualsArgs(file1, file2);
            var file1_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file1.UnsafeHandle;
            var file2_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file2.UnsafeHandle;
            var ret_ = g_file_equal(file1_,file2_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Gets the base name (the last component of the path) for a given #GFile.
        /// </summary>
        /// <remarks>
        /// <para>
        /// If called for the top level of a system (such as the filesystem root
        /// or a uri like sftp://host/) it will return a single directory separator
        /// (and on Windows, possibly a drive letter).
        /// </para>
        /// <para>
        /// The base name is a byte string (not UTF-8). It has no defined encoding
        /// or rules other than it may not contain zero bytes.  If you want to use
        /// filenames in a user interface you should use the display name that you
        /// can get by requesting the %G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME
        /// attribute with g_file_query_info().
        /// </para>
        /// <para>
        /// This call does no blocking I/O.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <returns>
        /// string containing the #GFile's
        ///     base name, or %NULL if given #GFile is invalid. The returned string
        ///     should be freed with g_free() when no longer needed.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="filename" type="char*" is-pointer="1" /> */
        /* transfer-ownership:full nullable:1 direction:in */
        private static extern byte* g_file_get_basename(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file);
        static partial void CheckGetBasenameArgs(this GISharp.Lib.Gio.IFile file);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.GetBasename(GISharp.Lib.Gio.IFile)']/*" />
        public static GISharp.Lib.GLib.Filename? GetBasename(this GISharp.Lib.Gio.IFile file)
        {
            CheckGetBasenameArgs(file);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var ret_ = g_file_get_basename(file_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Lib.GLib.Filename.GetInstance<GISharp.Lib.GLib.Filename>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full);
            return ret;
        }

        /// <summary>
        /// Gets a child of @file with basename equal to @name.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Note that the file with that specific name might not exist, but
        /// you can still have a #GFile that points to it. You can use this
        /// for instance to create that file.
        /// </para>
        /// <para>
        /// This call does no blocking I/O.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="name">
        /// string containing the child's basename
        /// </param>
        /// <returns>
        /// a #GFile to a child specified by @name.
        ///     Free the returned object with g_object_unref().
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.Gio.File.UnmanagedStruct* g_file_get_child(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="filename" type="const char*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* name);
        static partial void CheckGetChildArgs(this GISharp.Lib.Gio.IFile file, GISharp.Lib.GLib.Filename name);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.GetChild(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.Filename)']/*" />
        public static GISharp.Lib.Gio.IFile GetChild(this GISharp.Lib.Gio.IFile file, GISharp.Lib.GLib.Filename name)
        {
            CheckGetChildArgs(file, name);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var name_ = (byte*)name.UnsafeHandle;
            var ret_ = g_file_get_child(file_,name_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Gets the child of @file for a given @display_name (i.e. a UTF-8
        /// version of the name). If this function fails, it returns %NULL
        /// and @error will be set. This is very useful when constructing a
        /// #GFile for a new file and the user entered the filename in the
        /// user interface, for instance when you select a directory and
        /// type a filename in the file selector.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This call does no blocking I/O.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="displayName">
        /// string to a possible child
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// a #GFile to the specified child, or
        ///     %NULL if the display name couldn't be converted.
        ///     Free the returned object with g_object_unref().
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.Gio.File.UnmanagedStruct* g_file_get_child_for_display_name(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="utf8" type="const char*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* displayName,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        static partial void CheckGetChildForDisplayNameArgs(this GISharp.Lib.Gio.IFile file, GISharp.Lib.GLib.UnownedUtf8 displayName);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.GetChildForDisplayName(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.UnownedUtf8)']/*" />
        public static GISharp.Lib.Gio.IFile GetChildForDisplayName(this GISharp.Lib.Gio.IFile file, GISharp.Lib.GLib.UnownedUtf8 displayName)
        {
            CheckGetChildForDisplayNameArgs(file, displayName);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var displayName_ = (byte*)displayName.UnsafeHandle;
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            var ret_ = g_file_get_child_for_display_name(file_,displayName_,&error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Runtime.GErrorException(error);
            }

            var ret = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Gets the parent directory for the @file.
        /// If the @file represents the root directory of the
        /// file system, then %NULL will be returned.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This call does no blocking I/O.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <returns>
        /// a #GFile structure to the
        ///     parent of the given #GFile or %NULL if there is no parent. Free
        ///     the returned object with g_object_unref().
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:full nullable:1 direction:in */
        private static extern GISharp.Lib.Gio.File.UnmanagedStruct* g_file_get_parent(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file);
        static partial void CheckGetParentArgs(this GISharp.Lib.Gio.IFile file);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.GetParent(GISharp.Lib.Gio.IFile)']/*" />
        public static GISharp.Lib.Gio.IFile? GetParent(this GISharp.Lib.Gio.IFile file)
        {
            CheckGetParentArgs(file);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var ret_ = g_file_get_parent(file_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = (GISharp.Lib.Gio.IFile?)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full);
            return ret;
        }

        /// <summary>
        /// Gets the parse name of the @file.
        /// A parse name is a UTF-8 string that describes the
        /// file such that one can get the #GFile back using
        /// g_file_parse_name().
        /// </summary>
        /// <remarks>
        /// <para>
        /// This is generally used to show the #GFile as a nice
        /// full-pathname kind of string in a user interface,
        /// like in a location entry.
        /// </para>
        /// <para>
        /// For local files with names that can safely be converted
        /// to UTF-8 the pathname is used, otherwise the IRI is used
        /// (a form of URI that allows UTF-8 characters unescaped).
        /// </para>
        /// <para>
        /// This call does no blocking I/O.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <returns>
        /// a string containing the #GFile's parse name.
        ///     The returned string should be freed with g_free()
        ///     when no longer needed.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="char*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern byte* g_file_get_parse_name(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file);
        static partial void CheckGetParseNameArgs(this GISharp.Lib.Gio.IFile file);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.GetParseName(GISharp.Lib.Gio.IFile)']/*" />
        public static GISharp.Lib.GLib.Utf8 GetParseName(this GISharp.Lib.Gio.IFile file)
        {
            CheckGetParseNameArgs(file);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var ret_ = g_file_get_parse_name(file_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Lib.GLib.Utf8.GetInstance<GISharp.Lib.GLib.Utf8>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Gets the local pathname for #GFile, if one exists. If non-%NULL, this is
        /// guaranteed to be an absolute, canonical path. It might contain symlinks.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This call does no blocking I/O.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <returns>
        /// string containing the #GFile's path,
        ///     or %NULL if no such path exists. The returned string should be freed
        ///     with g_free() when no longer needed.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="filename" type="char*" is-pointer="1" /> */
        /* transfer-ownership:full nullable:1 direction:in */
        private static extern byte* g_file_get_path(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file);
        static partial void CheckGetPathArgs(this GISharp.Lib.Gio.IFile file);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.GetPath(GISharp.Lib.Gio.IFile)']/*" />
        public static GISharp.Lib.GLib.Filename? GetPath(this GISharp.Lib.Gio.IFile file)
        {
            CheckGetPathArgs(file);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var ret_ = g_file_get_path(file_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Lib.GLib.Filename.GetInstance<GISharp.Lib.GLib.Filename>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full);
            return ret;
        }

        /// <summary>
        /// Gets the path for @descendant relative to @parent.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This call does no blocking I/O.
        /// </para>
        /// </remarks>
        /// <param name="parent">
        /// input #GFile
        /// </param>
        /// <param name="descendant">
        /// input #GFile
        /// </param>
        /// <returns>
        /// string with the relative path from
        ///     @descendant to @parent, or %NULL if @descendant doesn't have @parent as
        ///     prefix. The returned string should be freed with g_free() when
        ///     no longer needed.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="filename" type="char*" is-pointer="1" /> */
        /* transfer-ownership:full nullable:1 direction:in */
        private static extern byte* g_file_get_relative_path(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* parent,
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* descendant);
        static partial void CheckGetRelativePathArgs(this GISharp.Lib.Gio.IFile parent, GISharp.Lib.Gio.IFile descendant);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.GetRelativePath(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.IFile)']/*" />
        public static GISharp.Lib.GLib.Filename? GetRelativePath(this GISharp.Lib.Gio.IFile parent, GISharp.Lib.Gio.IFile descendant)
        {
            CheckGetRelativePathArgs(parent, descendant);
            var parent_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)parent.UnsafeHandle;
            var descendant_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)descendant.UnsafeHandle;
            var ret_ = g_file_get_relative_path(parent_,descendant_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Lib.GLib.Filename.GetInstance<GISharp.Lib.GLib.Filename>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full);
            return ret;
        }

        /// <summary>
        /// Gets the URI for the @file.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This call does no blocking I/O.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <returns>
        /// a string containing the #GFile's URI.
        ///     The returned string should be freed with g_free()
        ///     when no longer needed.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="char*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern byte* g_file_get_uri(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file);
        static partial void CheckGetUriArgs(this GISharp.Lib.Gio.IFile file);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.GetUri(GISharp.Lib.Gio.IFile)']/*" />
        public static GISharp.Lib.GLib.Utf8 GetUri(this GISharp.Lib.Gio.IFile file)
        {
            CheckGetUriArgs(file);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var ret_ = g_file_get_uri(file_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Lib.GLib.Utf8.GetInstance<GISharp.Lib.GLib.Utf8>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Gets the URI scheme for a #GFile.
        /// RFC 3986 decodes the scheme as:
        /// |[
        /// URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
        /// ]|
        /// Common schemes include "file", "http", "ftp", etc.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This call does no blocking I/O.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <returns>
        /// a string containing the URI scheme for the given
        ///     #GFile. The returned string should be freed with g_free()
        ///     when no longer needed.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="char*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern byte* g_file_get_uri_scheme(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file);
        static partial void CheckGetUriSchemeArgs(this GISharp.Lib.Gio.IFile file);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.GetUriScheme(GISharp.Lib.Gio.IFile)']/*" />
        public static GISharp.Lib.GLib.Utf8 GetUriScheme(this GISharp.Lib.Gio.IFile file)
        {
            CheckGetUriSchemeArgs(file);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var ret_ = g_file_get_uri_scheme(file_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Lib.GLib.Utf8.GetInstance<GISharp.Lib.GLib.Utf8>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Checks if @file has a parent, and optionally, if it is @parent.
        /// </summary>
        /// <remarks>
        /// <para>
        /// If @parent is %NULL then this function returns %TRUE if @file has any
        /// parent at all.  If @parent is non-%NULL then %TRUE is only returned
        /// if @file is an immediate child of @parent.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="parent">
        /// the parent to check for, or %NULL
        /// </param>
        /// <returns>
        /// %TRUE if @file is an immediate child of @parent (or any parent in
        ///          the case that @parent is %NULL).
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_file_has_parent(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* parent);
        static partial void CheckHasParentArgs(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.IFile? parent);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.HasParent(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.IFile?)']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public static bool HasParent(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.IFile? parent)
        {
            CheckHasParentArgs(file, parent);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var parent_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)(parent?.UnsafeHandle ?? System.IntPtr.Zero);
            var ret_ = g_file_has_parent(file_,parent_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Checks whether @file has the prefix specified by @prefix.
        /// </summary>
        /// <remarks>
        /// <para>
        /// In other words, if the names of initial elements of @file's
        /// pathname match @prefix. Only full pathname elements are matched,
        /// so a path like /foo is not considered a prefix of /foobar, only
        /// of /foo/bar.
        /// </para>
        /// <para>
        /// A #GFile is not a prefix of itself. If you want to check for
        /// equality, use g_file_equal().
        /// </para>
        /// <para>
        /// This call does no I/O, as it works purely on names. As such it can
        /// sometimes return %FALSE even if @file is inside a @prefix (from a
        /// filesystem point of view), because the prefix of @file is an alias
        /// of @prefix.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="prefix">
        /// input #GFile
        /// </param>
        /// <returns>
        /// %TRUE if the @file's parent, grandparent, etc is @prefix,
        ///     %FALSE otherwise.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_file_has_prefix(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* prefix);
        static partial void CheckHasPrefixArgs(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.IFile prefix);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.HasPrefix(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.IFile)']/*" />
        public static bool HasPrefix(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.IFile prefix)
        {
            CheckHasPrefixArgs(file, prefix);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var prefix_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)prefix.UnsafeHandle;
            var ret_ = g_file_has_prefix(file_,prefix_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Checks to see if a #GFile has a given URI scheme.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This call does no blocking I/O.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="uriScheme">
        /// a string containing a URI scheme
        /// </param>
        /// <returns>
        /// %TRUE if #GFile's backend supports the
        ///     given URI scheme, %FALSE if URI scheme is %NULL,
        ///     not supported, or #GFile is invalid.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_file_has_uri_scheme(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="utf8" type="const char*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* uriScheme);
        static partial void CheckHasUriSchemeArgs(this GISharp.Lib.Gio.IFile file, GISharp.Lib.GLib.UnownedUtf8 uriScheme);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.HasUriScheme(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.UnownedUtf8)']/*" />
        public static bool HasUriScheme(this GISharp.Lib.Gio.IFile file, GISharp.Lib.GLib.UnownedUtf8 uriScheme)
        {
            CheckHasUriSchemeArgs(file, uriScheme);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var uriScheme_ = (byte*)uriScheme.UnsafeHandle;
            var ret_ = g_file_has_uri_scheme(file_,uriScheme_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Creates a hash value for a #GFile.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This call does no blocking I/O.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// #gconstpointer to a #GFile
        /// </param>
        /// <returns>
        /// 0 if @file is not a valid #GFile, otherwise an
        ///     integer that can be used as hash value for the #GFile.
        ///     This function is intended for easily hashing a #GFile to
        ///     add to a #GHashTable or similar data structure.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="guint" type="guint" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        private static extern uint g_file_hash(
        /* <type name="File" type="gconstpointer" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file);
        static partial void CheckGetHashCodeArgs(this GISharp.Lib.Gio.IFile file);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.GetHashCode(GISharp.Lib.Gio.IFile)']/*" />
        public static System.Int32 GetHashCode(this GISharp.Lib.Gio.IFile file)
        {
            CheckGetHashCodeArgs(file);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var ret_ = g_file_hash(file_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = (System.Int32)ret_;
            return ret;
        }

        /// <summary>
        /// Checks to see if a file is native to the platform.
        /// </summary>
        /// <remarks>
        /// <para>
        /// A native file is one expressed in the platform-native filename format,
        /// e.g. "C:\Windows" or "/usr/bin/". This does not mean the file is local,
        /// as it might be on a locally mounted remote filesystem.
        /// </para>
        /// <para>
        /// On some systems non-native files may be available using the native
        /// filesystem via a userspace filesystem (FUSE), in these cases this call
        /// will return %FALSE, but g_file_get_path() will still return a native path.
        /// </para>
        /// <para>
        /// This call does no blocking I/O.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <returns>
        /// %TRUE if @file is native
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_file_is_native(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file);
        static partial void CheckIsNativeArgs(this GISharp.Lib.Gio.IFile file);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.IsNative(GISharp.Lib.Gio.IFile)']/*" />
        public static bool IsNative(this GISharp.Lib.Gio.IFile file)
        {
            CheckIsNativeArgs(file);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var ret_ = g_file_is_native(file_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Loads the contents of @file and returns it as #GBytes.
        /// </summary>
        /// <remarks>
        /// <para>
        /// If @file is a resource:// based URI, the resulting bytes will reference the
        /// embedded resource instead of a copy. Otherwise, this is equivalent to calling
        /// g_file_load_contents() and g_bytes_new_take().
        /// </para>
        /// <para>
        /// For resources, @etag_out will be set to %NULL.
        /// </para>
        /// <para>
        /// The data contained in the resulting #GBytes is always zero-terminated, but
        /// this is not included in the #GBytes length. The resulting #GBytes should be
        /// freed with g_bytes_unref() when no longer in use.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// a #GFile
        /// </param>
        /// <param name="cancellable">
        /// a #GCancellable or %NULL
        /// </param>
        /// <param name="etagOut">
        /// a location to place the current
        ///     entity tag for the file, or %NULL if the entity tag is not needed
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// a #GBytes or %NULL and @error is set
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.56")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="GLib.Bytes" type="GBytes*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GLib.Bytes.UnmanagedStruct* g_file_load_bytes(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="utf8" type="gchar**" is-pointer="1" /> */
        /* direction:out caller-allocates:0 transfer-ownership:full nullable:1 optional:1 allow-none:1 */
        byte** etagOut,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        static partial void CheckLoadBytesArgs(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.LoadBytes(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.Utf8?,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.SinceAttribute("2.56")]
        public static GISharp.Lib.GLib.Bytes LoadBytes(this GISharp.Lib.Gio.IFile file, out GISharp.Lib.GLib.Utf8? etagOut, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckLoadBytesArgs(file, cancellable);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            byte* etagOut_;
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            var ret_ = g_file_load_bytes(file_,cancellable_,&etagOut_,&error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Runtime.GErrorException(error);
            }

            etagOut = GISharp.Lib.GLib.Utf8.GetInstance<GISharp.Lib.GLib.Utf8>((System.IntPtr)etagOut_, GISharp.Runtime.Transfer.Full);
            var ret = GISharp.Lib.GLib.Bytes.GetInstance<GISharp.Lib.GLib.Bytes>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Asynchronously loads the contents of @file as #GBytes.
        /// </summary>
        /// <remarks>
        /// <para>
        /// If @file is a resource:// based URI, the resulting bytes will reference the
        /// embedded resource instead of a copy. Otherwise, this is equivalent to calling
        /// g_file_load_contents_async() and g_bytes_new_take().
        /// </para>
        /// <para>
        /// @callback should call g_file_load_bytes_finish() to get the result of this
        /// asynchronous operation.
        /// </para>
        /// <para>
        /// See g_file_load_bytes() for more information.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// a #GFile
        /// </param>
        /// <param name="cancellable">
        /// a #GCancellable or %NULL
        /// </param>
        /// <param name="callback">
        /// a #GAsyncReadyCallback to call when the
        ///     request is satisfied
        /// </param>
        /// <param name="userData">
        /// the data to pass to callback function
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.56")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Threading.Tasks.Task">
*   <type name="GLib.Bytes" type="GBytes*" is-pointer="1" />
*   <type name="utf8" type="gchar**" is-pointer="1" />
* </type> */
        /* transfer-ownership:none direction:in */
        private static extern void g_file_load_bytes_async(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:2 direction:in */
        delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback,
        /* <type name="gpointer" type="gpointer" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr userData);
        static partial void CheckLoadBytesAsyncArgs(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.LoadBytesAsync(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.SinceAttribute("2.56")]
        public static System.Threading.Tasks.Task<System.ValueTuple<GISharp.Lib.GLib.Bytes, GISharp.Lib.GLib.Utf8>> LoadBytesAsync(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckLoadBytesAsyncArgs(file, cancellable);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var completionSource = new System.Threading.Tasks.TaskCompletionSource<System.ValueTuple<GISharp.Lib.GLib.Bytes, GISharp.Lib.GLib.Utf8>>();
            var callback_ = (delegate* unmanaged[Cdecl] <GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void>)&LoadBytesFinish;
            var userData_ = (System.IntPtr)System.Runtime.InteropServices.GCHandle.Alloc(completionSource);
            g_file_load_bytes_async(file_, cancellable_, callback_, userData_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            return completionSource.Task;
        }

        /// <summary>
        /// Completes an asynchronous request to g_file_load_bytes_async().
        /// </summary>
        /// <remarks>
        /// <para>
        /// For resources, @etag_out will be set to %NULL.
        /// </para>
        /// <para>
        /// The data contained in the resulting #GBytes is always zero-terminated, but
        /// this is not included in the #GBytes length. The resulting #GBytes should be
        /// freed with g_bytes_unref() when no longer in use.
        /// </para>
        /// <para>
        /// See g_file_load_bytes() for more information.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// a #GFile
        /// </param>
        /// <param name="result">
        /// a #GAsyncResult provided to the callback
        /// </param>
        /// <param name="etagOut">
        /// a location to place the current
        ///     entity tag for the file, or %NULL if the entity tag is not needed
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// a #GBytes or %NULL and @error is set
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.56")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="GLib.Bytes" type="GBytes*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GLib.Bytes.UnmanagedStruct* g_file_load_bytes_finish(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="AsyncResult" type="GAsyncResult*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result,
        /* <type name="utf8" type="gchar**" is-pointer="1" /> */
        /* direction:out caller-allocates:0 transfer-ownership:full nullable:1 optional:1 allow-none:1 */
        byte** etagOut,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        [System.Runtime.InteropServices.UnmanagedCallersOnlyAttribute(CallConvs = new[] { typeof(System.Runtime.CompilerServices.CallConvCdecl) })]
        private static void LoadBytesFinish(GISharp.Lib.GObject.Object.UnmanagedStruct* sourceObject_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result_, System.IntPtr userData_)
        {
            try
            {
                var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)sourceObject_;
                var userData = (System.Runtime.InteropServices.GCHandle)userData_;
                var completionSource = (System.Threading.Tasks.TaskCompletionSource<System.ValueTuple<GISharp.Lib.GLib.Bytes, GISharp.Lib.GLib.Utf8>>)userData.Target!;
                userData.Free();
                byte* etagOut_;
                var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
                var ret_ = g_file_load_bytes_finish(file_,result_,&etagOut_,&error_);
                if (error_ is not null)
                {
                    var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                    completionSource.SetException(new GISharp.Runtime.GErrorException(error));
                    return;
                }
                var etagOut = GISharp.Lib.GLib.Utf8.GetInstance<GISharp.Lib.GLib.Utf8>((System.IntPtr)etagOut_, GISharp.Runtime.Transfer.Full);
                var ret = GISharp.Lib.GLib.Bytes.GetInstance<GISharp.Lib.GLib.Bytes>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
                completionSource.SetResult((ret, etagOut));
            }
            catch (System.Exception ex)
            {
                GISharp.Runtime.GMarshal.PushUnhandledException(ex);
            }
        }

        /// <summary>
        /// Loads the content of the file into memory. The data is always
        /// zero-terminated, but this is not included in the resultant @length.
        /// The returned @contents should be freed with g_free() when no longer
        /// needed.
        /// </summary>
        /// <remarks>
        /// <para>
        /// If @cancellable is not %NULL, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object, %NULL to ignore
        /// </param>
        /// <param name="contents">
        /// a location to place the contents of the file
        /// </param>
        /// <param name="length">
        /// a location to place the length of the contents of the file,
        ///    or %NULL if the length is not needed
        /// </param>
        /// <param name="etagOut">
        /// a location to place the current entity tag for the file,
        ///    or %NULL if the entity tag is not needed
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// %TRUE if the @file's contents were successfully loaded.
        ///     %FALSE if there were errors.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        private static extern GISharp.Runtime.Boolean g_file_load_contents(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <array length="2" zero-terminated="0" type="char**" is-pointer="1">
*   <type name="guint8" />
* </array> */
        /* direction:out caller-allocates:0 transfer-ownership:full */
        byte** contents,
        /* <type name="gsize" type="gsize*" /> */
        /* direction:out caller-allocates:0 transfer-ownership:full optional:1 allow-none:1 */
        nuint* length,
        /* <type name="utf8" type="char**" is-pointer="1" /> */
        /* direction:out caller-allocates:0 transfer-ownership:full optional:1 allow-none:1 */
        byte** etagOut,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        static partial void CheckLoadContentsArgs(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.LoadContents(GISharp.Lib.Gio.IFile,GISharp.Runtime.CArray&lt;byte&gt;,GISharp.Lib.GLib.Utf8,GISharp.Lib.Gio.Cancellable?)']/*" />
        public static void LoadContents(this GISharp.Lib.Gio.IFile file, out GISharp.Runtime.CArray<byte> contents, out GISharp.Lib.GLib.Utf8 etagOut, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckLoadContentsArgs(file, cancellable);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            byte* contents_;
            nuint length_;
            byte* etagOut_;
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            g_file_load_contents(file_, cancellable_, &contents_, &length_, &etagOut_, &error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Runtime.GErrorException(error);
            }

            contents = new GISharp.Runtime.CArray<byte>((System.IntPtr)contents_, (int)length_, GISharp.Runtime.Transfer.Full);
            etagOut = GISharp.Lib.GLib.Utf8.GetInstance<GISharp.Lib.GLib.Utf8>((System.IntPtr)etagOut_, GISharp.Runtime.Transfer.Full)!;
        }

        /// <summary>
        /// Starts an asynchronous load of the @file's contents.
        /// </summary>
        /// <remarks>
        /// <para>
        /// For more details, see g_file_load_contents() which is
        /// the synchronous version of this call.
        /// </para>
        /// <para>
        /// When the load operation has completed, @callback will be called
        /// with @user data. To finish the operation, call
        /// g_file_load_contents_finish() with the #GAsyncResult returned by
        /// the @callback.
        /// </para>
        /// <para>
        /// If @cancellable is not %NULL, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object, %NULL to ignore
        /// </param>
        /// <param name="callback">
        /// a #GAsyncReadyCallback to call when the request is satisfied
        /// </param>
        /// <param name="userData">
        /// the data to pass to callback function
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Threading.Tasks.Task">
*   <array length="2" zero-terminated="0" type="char**" is-pointer="1">
*     <type name="guint8" />
*   </array>
*   <type name="utf8" type="char**" is-pointer="1" />
* </type> */
        /* transfer-ownership:none direction:in */
        private static extern void g_file_load_contents_async(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:2 direction:in */
        delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback,
        /* <type name="gpointer" type="gpointer" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr userData);
        static partial void CheckLoadContentsAsyncArgs(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.LoadContentsAsync(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.Cancellable?)']/*" />
        public static System.Threading.Tasks.Task<System.ValueTuple<GISharp.Runtime.CArray<byte>, GISharp.Lib.GLib.Utf8>> LoadContentsAsync(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckLoadContentsAsyncArgs(file, cancellable);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var completionSource = new System.Threading.Tasks.TaskCompletionSource<System.ValueTuple<GISharp.Runtime.CArray<byte>, GISharp.Lib.GLib.Utf8>>();
            var callback_ = (delegate* unmanaged[Cdecl] <GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void>)&LoadContentsFinish;
            var userData_ = (System.IntPtr)System.Runtime.InteropServices.GCHandle.Alloc(completionSource);
            g_file_load_contents_async(file_, cancellable_, callback_, userData_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            return completionSource.Task;
        }

        /// <summary>
        /// Finishes an asynchronous load of the @file's contents.
        /// The contents are placed in @contents, and @length is set to the
        /// size of the @contents string. The @contents should be freed with
        /// g_free() when no longer needed. If @etag_out is present, it will be
        /// set to the new entity tag for the @file.
        /// </summary>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="res">
        /// a #GAsyncResult
        /// </param>
        /// <param name="contents">
        /// a location to place the contents of the file
        /// </param>
        /// <param name="length">
        /// a location to place the length of the contents of the file,
        ///     or %NULL if the length is not needed
        /// </param>
        /// <param name="etagOut">
        /// a location to place the current entity tag for the file,
        ///     or %NULL if the entity tag is not needed
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// %TRUE if the load was successful. If %FALSE and @error is
        ///     present, it will be set appropriately.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        private static extern GISharp.Runtime.Boolean g_file_load_contents_finish(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="AsyncResult" type="GAsyncResult*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res,
        /* <array length="2" zero-terminated="0" type="char**" is-pointer="1">
*   <type name="guint8" />
* </array> */
        /* direction:out caller-allocates:0 transfer-ownership:full */
        byte** contents,
        /* <type name="gsize" type="gsize*" /> */
        /* direction:out caller-allocates:0 transfer-ownership:full optional:1 allow-none:1 */
        nuint* length,
        /* <type name="utf8" type="char**" is-pointer="1" /> */
        /* direction:out caller-allocates:0 transfer-ownership:full optional:1 allow-none:1 */
        byte** etagOut,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        [System.Runtime.InteropServices.UnmanagedCallersOnlyAttribute(CallConvs = new[] { typeof(System.Runtime.CompilerServices.CallConvCdecl) })]
        private static void LoadContentsFinish(GISharp.Lib.GObject.Object.UnmanagedStruct* sourceObject_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res_, System.IntPtr userData_)
        {
            try
            {
                var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)sourceObject_;
                var userData = (System.Runtime.InteropServices.GCHandle)userData_;
                var completionSource = (System.Threading.Tasks.TaskCompletionSource<System.ValueTuple<GISharp.Runtime.CArray<byte>, GISharp.Lib.GLib.Utf8>>)userData.Target!;
                userData.Free();
                byte* contents_;
                nuint length_;
                byte* etagOut_;
                var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
                g_file_load_contents_finish(file_, res_, &contents_, &length_, &etagOut_, &error_);
                if (error_ is not null)
                {
                    var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                    completionSource.SetException(new GISharp.Runtime.GErrorException(error));
                    return;
                }
                var contents = new GISharp.Runtime.CArray<byte>((System.IntPtr)contents_, (int)length_, GISharp.Runtime.Transfer.Full);
                var etagOut = GISharp.Lib.GLib.Utf8.GetInstance<GISharp.Lib.GLib.Utf8>((System.IntPtr)etagOut_, GISharp.Runtime.Transfer.Full)!;
                completionSource.SetResult((contents, etagOut));
            }
            catch (System.Exception ex)
            {
                GISharp.Runtime.GMarshal.PushUnhandledException(ex);
            }
        }

        /// <summary>
        /// Finishes an asynchronous partial load operation that was started
        /// with g_file_load_partial_contents_async(). The data is always
        /// zero-terminated, but this is not included in the resultant @length.
        /// The returned @contents should be freed with g_free() when no longer
        /// needed.
        /// </summary>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="res">
        /// a #GAsyncResult
        /// </param>
        /// <param name="contents">
        /// a location to place the contents of the file
        /// </param>
        /// <param name="length">
        /// a location to place the length of the contents of the file,
        ///     or %NULL if the length is not needed
        /// </param>
        /// <param name="etagOut">
        /// a location to place the current entity tag for the file,
        ///     or %NULL if the entity tag is not needed
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// %TRUE if the load was successful. If %FALSE and @error is
        ///     present, it will be set appropriately.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        private static extern GISharp.Runtime.Boolean g_file_load_partial_contents_finish(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="AsyncResult" type="GAsyncResult*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res,
        /* <array length="2" zero-terminated="0" type="char**" is-pointer="1">
*   <type name="guint8" />
* </array> */
        /* direction:out caller-allocates:0 transfer-ownership:full */
        byte** contents,
        /* <type name="gsize" type="gsize*" /> */
        /* direction:out caller-allocates:0 transfer-ownership:full optional:1 allow-none:1 */
        nuint* length,
        /* <type name="utf8" type="char**" is-pointer="1" /> */
        /* direction:out caller-allocates:0 transfer-ownership:full optional:1 allow-none:1 */
        byte** etagOut,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        static partial void CheckLoadPartialContentsFinishArgs(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.IAsyncResult res);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.LoadPartialContentsFinish(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.IAsyncResult,GISharp.Runtime.CArray&lt;byte&gt;,GISharp.Lib.GLib.Utf8)']/*" />
        public static void LoadPartialContentsFinish(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.IAsyncResult res, out GISharp.Runtime.CArray<byte> contents, out GISharp.Lib.GLib.Utf8 etagOut)
        {
            CheckLoadPartialContentsFinishArgs(file, res);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var res_ = (GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*)res.UnsafeHandle;
            byte* contents_;
            nuint length_;
            byte* etagOut_;
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            g_file_load_partial_contents_finish(file_, res_, &contents_, &length_, &etagOut_, &error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Runtime.GErrorException(error);
            }

            contents = new GISharp.Runtime.CArray<byte>((System.IntPtr)contents_, (int)length_, GISharp.Runtime.Transfer.Full);
            etagOut = GISharp.Lib.GLib.Utf8.GetInstance<GISharp.Lib.GLib.Utf8>((System.IntPtr)etagOut_, GISharp.Runtime.Transfer.Full)!;
        }

        /// <summary>
        /// Creates a directory. Note that this will only create a child directory
        /// of the immediate parent directory of the path or URI given by the #GFile.
        /// To recursively create directories, see g_file_make_directory_with_parents().
        /// This function will fail if the parent directory does not exist, setting
        /// @error to %G_IO_ERROR_NOT_FOUND. If the file system doesn't support
        /// creating directories, this function will fail, setting @error to
        /// %G_IO_ERROR_NOT_SUPPORTED.
        /// </summary>
        /// <remarks>
        /// <para>
        /// For a local #GFile the newly created directory will have the default
        /// (current) ownership and permissions of the current process.
        /// </para>
        /// <para>
        /// If @cancellable is not %NULL, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object,
        ///     %NULL to ignore
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// %TRUE on successful creation, %FALSE otherwise.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        private static extern GISharp.Runtime.Boolean g_file_make_directory(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        static partial void CheckMakeDirectoryArgs(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.MakeDirectory(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.Cancellable?)']/*" />
        public static void MakeDirectory(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckMakeDirectoryArgs(file, cancellable);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            g_file_make_directory(file_, cancellable_, &error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Runtime.GErrorException(error);
            }
        }

        /// <summary>
        /// Asynchronously creates a directory.
        /// </summary>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="ioPriority">
        /// the [I/O priority][io-priority] of the request
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object,
        ///     %NULL to ignore
        /// </param>
        /// <param name="callback">
        /// a #GAsyncReadyCallback to call
        ///     when the request is satisfied
        /// </param>
        /// <param name="userData">
        /// the data to pass to callback function
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.38")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Threading.Tasks.Task" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_file_make_directory_async(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="gint" type="int" /> */
        /* transfer-ownership:none direction:in */
        int ioPriority,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:3 direction:in */
        delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback,
        /* <type name="gpointer" type="gpointer" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr userData);
        static partial void CheckMakeDirectoryAsyncArgs(this GISharp.Lib.Gio.IFile file, int ioPriority = GISharp.Lib.GLib.Priority.Default, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.MakeDirectoryAsync(GISharp.Lib.Gio.IFile,int,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.SinceAttribute("2.38")]
        public static System.Threading.Tasks.Task MakeDirectoryAsync(this GISharp.Lib.Gio.IFile file, int ioPriority = GISharp.Lib.GLib.Priority.Default, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckMakeDirectoryAsyncArgs(file, ioPriority, cancellable);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var ioPriority_ = (int)ioPriority;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var completionSource = new System.Threading.Tasks.TaskCompletionSource<GISharp.Runtime.Void>();
            var callback_ = (delegate* unmanaged[Cdecl] <GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void>)&MakeDirectoryFinish;
            var userData_ = (System.IntPtr)System.Runtime.InteropServices.GCHandle.Alloc(completionSource);
            g_file_make_directory_async(file_, ioPriority_, cancellable_, callback_, userData_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            return completionSource.Task;
        }

        /// <summary>
        /// Finishes an asynchronous directory creation, started with
        /// g_file_make_directory_async().
        /// </summary>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="result">
        /// a #GAsyncResult
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// %TRUE on successful directory creation, %FALSE otherwise.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.38")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        private static extern GISharp.Runtime.Boolean g_file_make_directory_finish(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="AsyncResult" type="GAsyncResult*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        [System.Runtime.InteropServices.UnmanagedCallersOnlyAttribute(CallConvs = new[] { typeof(System.Runtime.CompilerServices.CallConvCdecl) })]
        private static void MakeDirectoryFinish(GISharp.Lib.GObject.Object.UnmanagedStruct* sourceObject_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result_, System.IntPtr userData_)
        {
            try
            {
                var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)sourceObject_;
                var userData = (System.Runtime.InteropServices.GCHandle)userData_;
                var completionSource = (System.Threading.Tasks.TaskCompletionSource<GISharp.Runtime.Void>)userData.Target!;
                userData.Free();
                var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
                g_file_make_directory_finish(file_, result_, &error_);
                if (error_ is not null)
                {
                    var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                    completionSource.SetException(new GISharp.Runtime.GErrorException(error));
                    return;
                }
                completionSource.SetResult(GISharp.Runtime.Void.Default);
            }
            catch (System.Exception ex)
            {
                GISharp.Runtime.GMarshal.PushUnhandledException(ex);
            }
        }

        /// <summary>
        /// Creates a directory and any parent directories that may not
        /// exist similar to 'mkdir -p'. If the file system does not support
        /// creating directories, this function will fail, setting @error to
        /// %G_IO_ERROR_NOT_SUPPORTED. If the directory itself already exists,
        /// this function will fail setting @error to %G_IO_ERROR_EXISTS, unlike
        /// the similar g_mkdir_with_parents().
        /// </summary>
        /// <remarks>
        /// <para>
        /// For a local #GFile the newly created directories will have the default
        /// (current) ownership and permissions of the current process.
        /// </para>
        /// <para>
        /// If @cancellable is not %NULL, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object,
        ///     %NULL to ignore
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// %TRUE if all directories have been successfully created, %FALSE
        /// otherwise.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.18")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        private static extern GISharp.Runtime.Boolean g_file_make_directory_with_parents(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        static partial void CheckMakeDirectoryWithParentsArgs(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.MakeDirectoryWithParents(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.SinceAttribute("2.18")]
        public static void MakeDirectoryWithParents(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckMakeDirectoryWithParentsArgs(file, cancellable);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            g_file_make_directory_with_parents(file_, cancellable_, &error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Runtime.GErrorException(error);
            }
        }

        /// <summary>
        /// Creates a symbolic link named @file which contains the string
        /// @symlink_value.
        /// </summary>
        /// <remarks>
        /// <para>
        /// If @cancellable is not %NULL, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// a #GFile with the name of the symlink to create
        /// </param>
        /// <param name="symlinkValue">
        /// a string with the path for the target
        ///     of the new symlink
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object,
        ///     %NULL to ignore
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// %TRUE on the creation of a new symlink, %FALSE otherwise.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        private static extern GISharp.Runtime.Boolean g_file_make_symbolic_link(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="filename" type="const char*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* symlinkValue,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        static partial void CheckMakeSymbolicLinkArgs(this GISharp.Lib.Gio.IFile file, GISharp.Lib.GLib.Filename symlinkValue, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.MakeSymbolicLink(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.Filename,GISharp.Lib.Gio.Cancellable?)']/*" />
        public static void MakeSymbolicLink(this GISharp.Lib.Gio.IFile file, GISharp.Lib.GLib.Filename symlinkValue, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckMakeSymbolicLinkArgs(file, symlinkValue, cancellable);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var symlinkValue_ = (byte*)symlinkValue.UnsafeHandle;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            g_file_make_symbolic_link(file_, symlinkValue_, cancellable_, &error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Runtime.GErrorException(error);
            }
        }

        /// <summary>
        /// Collects the results from an earlier call to
        /// g_file_measure_disk_usage_async().  See g_file_measure_disk_usage() for
        /// more information.
        /// </summary>
        /// <param name="file">
        /// a #GFile
        /// </param>
        /// <param name="result">
        /// the #GAsyncResult passed to your #GAsyncReadyCallback
        /// </param>
        /// <param name="diskUsage">
        /// the number of bytes of disk space used
        /// </param>
        /// <param name="numDirs">
        /// the number of directories encountered
        /// </param>
        /// <param name="numFiles">
        /// the number of non-directories encountered
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// %TRUE if successful, with the out parameters set.
        ///          %FALSE otherwise, with @error set.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.38")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        private static extern GISharp.Runtime.Boolean g_file_measure_disk_usage_finish(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="AsyncResult" type="GAsyncResult*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result,
        /* <type name="guint64" type="guint64*" /> */
        /* direction:out caller-allocates:0 transfer-ownership:full optional:1 allow-none:1 */
        ulong* diskUsage,
        /* <type name="guint64" type="guint64*" /> */
        /* direction:out caller-allocates:0 transfer-ownership:full optional:1 allow-none:1 */
        ulong* numDirs,
        /* <type name="guint64" type="guint64*" /> */
        /* direction:out caller-allocates:0 transfer-ownership:full optional:1 allow-none:1 */
        ulong* numFiles,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        static partial void CheckMeasureDiskUsageFinishArgs(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.IAsyncResult result);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.MeasureDiskUsageFinish(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.IAsyncResult,ulong,ulong,ulong)']/*" />
        [GISharp.Runtime.SinceAttribute("2.38")]
        public static void MeasureDiskUsageFinish(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.IAsyncResult result, out ulong diskUsage, out ulong numDirs, out ulong numFiles)
        {
            CheckMeasureDiskUsageFinishArgs(file, result);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var result_ = (GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*)result.UnsafeHandle;
            ulong diskUsage_;
            ulong numDirs_;
            ulong numFiles_;
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            g_file_measure_disk_usage_finish(file_, result_, &diskUsage_, &numDirs_, &numFiles_, &error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Runtime.GErrorException(error);
            }

            diskUsage = (ulong)diskUsage_;
            numDirs = (ulong)numDirs_;
            numFiles = (ulong)numFiles_;
        }

        /// <summary>
        /// Finishes a mount operation started by g_file_mount_enclosing_volume().
        /// </summary>
        /// <param name="location">
        /// input #GFile
        /// </param>
        /// <param name="result">
        /// a #GAsyncResult
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// %TRUE if successful. If an error has occurred,
        ///     this function will return %FALSE and set @error
        ///     appropriately if present.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        private static extern GISharp.Runtime.Boolean g_file_mount_enclosing_volume_finish(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* location,
        /* <type name="AsyncResult" type="GAsyncResult*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        static partial void CheckMountEnclosingVolumeFinishArgs(this GISharp.Lib.Gio.IFile location, GISharp.Lib.Gio.IAsyncResult result);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.MountEnclosingVolumeFinish(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.IAsyncResult)']/*" />
        public static void MountEnclosingVolumeFinish(this GISharp.Lib.Gio.IFile location, GISharp.Lib.Gio.IAsyncResult result)
        {
            CheckMountEnclosingVolumeFinishArgs(location, result);
            var location_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)location.UnsafeHandle;
            var result_ = (GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*)result.UnsafeHandle;
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            g_file_mount_enclosing_volume_finish(location_, result_, &error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Runtime.GErrorException(error);
            }
        }

        /// <summary>
        /// Finishes a mount operation. See g_file_mount_mountable() for details.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Finish an asynchronous mount operation that was started
        /// with g_file_mount_mountable().
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="result">
        /// a #GAsyncResult
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// a #GFile or %NULL on error.
        ///     Free the returned object with g_object_unref().
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.Gio.File.UnmanagedStruct* g_file_mount_mountable_finish(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="AsyncResult" type="GAsyncResult*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        static partial void CheckMountMountableFinishArgs(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.IAsyncResult result);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.MountMountableFinish(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.IAsyncResult)']/*" />
        public static GISharp.Lib.Gio.IFile MountMountableFinish(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.IAsyncResult result)
        {
            CheckMountMountableFinishArgs(file, result);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var result_ = (GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*)result.UnsafeHandle;
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            var ret_ = g_file_mount_mountable_finish(file_,result_,&error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Runtime.GErrorException(error);
            }

            var ret = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Tries to move the file or directory @source to the location specified
        /// by @destination. If native move operations are supported then this is
        /// used, otherwise a copy + delete fallback is used. The native
        /// implementation may support moving directories (for instance on moves
        /// inside the same filesystem), but the fallback code does not.
        /// </summary>
        /// <remarks>
        /// <para>
        /// If the flag #G_FILE_COPY_OVERWRITE is specified an already
        /// existing @destination file is overwritten.
        /// </para>
        /// <para>
        /// If @cancellable is not %NULL, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
        /// </para>
        /// <para>
        /// If @progress_callback is not %NULL, then the operation can be monitored
        /// by setting this to a #GFileProgressCallback function.
        /// @progress_callback_data will be passed to this function. It is
        /// guaranteed that this callback will be called after all data has been
        /// transferred with the total number of bytes copied during the operation.
        /// </para>
        /// <para>
        /// If the @source file does not exist, then the %G_IO_ERROR_NOT_FOUND
        /// error is returned, independent on the status of the @destination.
        /// </para>
        /// <para>
        /// If #G_FILE_COPY_OVERWRITE is not specified and the target exists,
        /// then the error %G_IO_ERROR_EXISTS is returned.
        /// </para>
        /// <para>
        /// If trying to overwrite a file over a directory, the %G_IO_ERROR_IS_DIRECTORY
        /// error is returned. If trying to overwrite a directory with a directory the
        /// %G_IO_ERROR_WOULD_MERGE error is returned.
        /// </para>
        /// <para>
        /// If the source is a directory and the target does not exist, or
        /// #G_FILE_COPY_OVERWRITE is specified and the target is a file, then
        /// the %G_IO_ERROR_WOULD_RECURSE error may be returned (if the native
        /// move operation isn't available).
        /// </para>
        /// </remarks>
        /// <param name="source">
        /// #GFile pointing to the source location
        /// </param>
        /// <param name="destination">
        /// #GFile pointing to the destination location
        /// </param>
        /// <param name="flags">
        /// set of #GFileCopyFlags
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object,
        ///     %NULL to ignore
        /// </param>
        /// <param name="progressCallback">
        /// #GFileProgressCallback
        ///     function for updates
        /// </param>
        /// <param name="progressCallbackData">
        /// gpointer to user data for
        ///     the callback function
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// %TRUE on successful move, %FALSE otherwise.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        private static extern GISharp.Runtime.Boolean g_file_move(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* source,
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* destination,
        /* <type name="FileCopyFlags" type="GFileCopyFlags" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.FileCopyFlags flags,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="FileProgressCallback" type="GFileProgressCallback" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:call closure:4 direction:in */
        delegate* unmanaged[Cdecl]<long, long, System.IntPtr, void> progressCallback,
        /* <type name="gpointer" type="gpointer" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr progressCallbackData,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        static partial void CheckMoveArgs(this GISharp.Lib.Gio.IFile source, GISharp.Lib.Gio.IFile destination, GISharp.Lib.Gio.FileCopyFlags flags, GISharp.Lib.Gio.FileProgressCallback? progressCallback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.Move(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.FileCopyFlags,GISharp.Lib.Gio.FileProgressCallback?,GISharp.Lib.Gio.Cancellable?)']/*" />
        public static void Move(this GISharp.Lib.Gio.IFile source, GISharp.Lib.Gio.IFile destination, GISharp.Lib.Gio.FileCopyFlags flags, GISharp.Lib.Gio.FileProgressCallback? progressCallback, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckMoveArgs(source, destination, flags, progressCallback, cancellable);
            var source_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)source.UnsafeHandle;
            var destination_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)destination.UnsafeHandle;
            var flags_ = (GISharp.Lib.Gio.FileCopyFlags)flags;
            var progressCallback_ = progressCallback is null ? default : (delegate* unmanaged[Cdecl]<long, long, System.IntPtr, void>)&GISharp.Lib.Gio.FileProgressCallbackMarshal.Callback;
            var progressCallbackHandle = progressCallback is null ? default : System.Runtime.InteropServices.GCHandle.Alloc((progressCallback, GISharp.Runtime.CallbackScope.Call));
            var progressCallbackData_ = (System.IntPtr)progressCallbackHandle;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            g_file_move(source_, destination_, flags_, cancellable_, progressCallback_, progressCallbackData_, &error_);
            if (progressCallback is not null)
            {
                progressCallbackHandle.Free();
            }

            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Runtime.GErrorException(error);
            }
        }

        /// <summary>
        /// Opens an existing file for reading and writing. The result is
        /// a #GFileIOStream that can be used to read and write the contents
        /// of the file.
        /// </summary>
        /// <remarks>
        /// <para>
        /// If @cancellable is not %NULL, then the operation can be cancelled
        /// by triggering the cancellable object from another thread. If the
        /// operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
        /// returned.
        /// </para>
        /// <para>
        /// If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will
        /// be returned. If the file is a directory, the %G_IO_ERROR_IS_DIRECTORY
        /// error will be returned. Other errors are possible too, and depend on
        /// what kind of filesystem the file is on. Note that in many non-local
        /// file cases read and write streams are not supported, so make sure you
        /// really need to do read and write streaming, rather than just opening
        /// for reading or writing.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// #GFile to open
        /// </param>
        /// <param name="cancellable">
        /// a #GCancellable
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// #GFileIOStream or %NULL on error.
        ///     Free the returned object with g_object_unref().
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.22")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileIOStream" type="GFileIOStream*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.Gio.FileIOStream.UnmanagedStruct* g_file_open_readwrite(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        static partial void CheckOpenReadwriteArgs(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.OpenReadwrite(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.SinceAttribute("2.22")]
        public static GISharp.Lib.Gio.FileIOStream OpenReadwrite(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckOpenReadwriteArgs(file, cancellable);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            var ret_ = g_file_open_readwrite(file_,cancellable_,&error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Runtime.GErrorException(error);
            }

            var ret = GISharp.Lib.Gio.FileIOStream.GetInstance<GISharp.Lib.Gio.FileIOStream>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Asynchronously opens @file for reading and writing.
        /// </summary>
        /// <remarks>
        /// <para>
        /// For more details, see g_file_open_readwrite() which is
        /// the synchronous version of this call.
        /// </para>
        /// <para>
        /// When the operation is finished, @callback will be called.
        /// You can then call g_file_open_readwrite_finish() to get
        /// the result of the operation.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="ioPriority">
        /// the [I/O priority][io-priority] of the request
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object,
        ///     %NULL to ignore
        /// </param>
        /// <param name="callback">
        /// a #GAsyncReadyCallback to call
        ///     when the request is satisfied
        /// </param>
        /// <param name="userData">
        /// the data to pass to callback function
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.22")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Threading.Tasks.Task">
*   <type name="FileIOStream" type="GFileIOStream*" is-pointer="1" />
* </type> */
        /* transfer-ownership:none direction:in */
        private static extern void g_file_open_readwrite_async(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="gint" type="int" /> */
        /* transfer-ownership:none direction:in */
        int ioPriority,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:3 direction:in */
        delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback,
        /* <type name="gpointer" type="gpointer" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr userData);
        static partial void CheckOpenReadwriteAsyncArgs(this GISharp.Lib.Gio.IFile file, int ioPriority = GISharp.Lib.GLib.Priority.Default, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.OpenReadwriteAsync(GISharp.Lib.Gio.IFile,int,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.SinceAttribute("2.22")]
        public static System.Threading.Tasks.Task<GISharp.Lib.Gio.FileIOStream> OpenReadwriteAsync(this GISharp.Lib.Gio.IFile file, int ioPriority = GISharp.Lib.GLib.Priority.Default, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckOpenReadwriteAsyncArgs(file, ioPriority, cancellable);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var ioPriority_ = (int)ioPriority;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var completionSource = new System.Threading.Tasks.TaskCompletionSource<GISharp.Lib.Gio.FileIOStream>();
            var callback_ = (delegate* unmanaged[Cdecl] <GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void>)&OpenReadwriteFinish;
            var userData_ = (System.IntPtr)System.Runtime.InteropServices.GCHandle.Alloc(completionSource);
            g_file_open_readwrite_async(file_, ioPriority_, cancellable_, callback_, userData_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            return completionSource.Task;
        }

        /// <summary>
        /// Finishes an asynchronous file read operation started with
        /// g_file_open_readwrite_async().
        /// </summary>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="res">
        /// a #GAsyncResult
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// a #GFileIOStream or %NULL on error.
        ///     Free the returned object with g_object_unref().
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.22")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileIOStream" type="GFileIOStream*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.Gio.FileIOStream.UnmanagedStruct* g_file_open_readwrite_finish(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="AsyncResult" type="GAsyncResult*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        [System.Runtime.InteropServices.UnmanagedCallersOnlyAttribute(CallConvs = new[] { typeof(System.Runtime.CompilerServices.CallConvCdecl) })]
        private static void OpenReadwriteFinish(GISharp.Lib.GObject.Object.UnmanagedStruct* sourceObject_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res_, System.IntPtr userData_)
        {
            try
            {
                var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)sourceObject_;
                var userData = (System.Runtime.InteropServices.GCHandle)userData_;
                var completionSource = (System.Threading.Tasks.TaskCompletionSource<GISharp.Lib.Gio.FileIOStream>)userData.Target!;
                userData.Free();
                var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
                var ret_ = g_file_open_readwrite_finish(file_,res_,&error_);
                if (error_ is not null)
                {
                    var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                    completionSource.SetException(new GISharp.Runtime.GErrorException(error));
                    return;
                }
                var ret = GISharp.Lib.Gio.FileIOStream.GetInstance<GISharp.Lib.Gio.FileIOStream>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
                completionSource.SetResult((ret));
            }
            catch (System.Exception ex)
            {
                GISharp.Runtime.GMarshal.PushUnhandledException(ex);
            }
        }

        /// <summary>
        /// Exactly like g_file_get_path(), but caches the result via
        /// g_object_set_qdata_full().  This is useful for example in C
        /// applications which mix `g_file_*` APIs with native ones.  It
        /// also avoids an extra duplicated string when possible, so will be
        /// generally more efficient.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This call does no blocking I/O.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <returns>
        /// string containing the #GFile's path,
        ///     or %NULL if no such path exists. The returned string is owned by @file.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.56")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="filename" type="const char*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 direction:in */
        private static extern byte* g_file_peek_path(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file);
        static partial void CheckPeekPathArgs(this GISharp.Lib.Gio.IFile file);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.PeekPath(GISharp.Lib.Gio.IFile)']/*" />
        [GISharp.Runtime.SinceAttribute("2.56")]
        public static GISharp.Lib.GLib.Filename? PeekPath(this GISharp.Lib.Gio.IFile file)
        {
            CheckPeekPathArgs(file);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var ret_ = g_file_peek_path(file_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Lib.GLib.Filename.GetInstance<GISharp.Lib.GLib.Filename>((System.IntPtr)ret_, GISharp.Runtime.Transfer.None);
            return ret;
        }

        /// <summary>
        /// Polls a file of type #G_FILE_TYPE_MOUNTABLE.
        /// </summary>
        /// <remarks>
        /// <para>
        /// If @cancellable is not %NULL, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
        /// </para>
        /// <para>
        /// When the operation is finished, @callback will be called.
        /// You can then call g_file_mount_mountable_finish() to get
        /// the result of the operation.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object, %NULL to ignore
        /// </param>
        /// <param name="callback">
        /// a #GAsyncReadyCallback to call
        ///     when the request is satisfied, or %NULL
        /// </param>
        /// <param name="userData">
        /// the data to pass to callback function
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.22")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_file_poll_mountable(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:2 direction:in */
        delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback,
        /* <type name="gpointer" type="gpointer" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr userData);
        static partial void CheckPollMountableArgs(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.PollMountable(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.AsyncReadyCallback?,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.SinceAttribute("2.22")]
        public static void PollMountable(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckPollMountableArgs(file, callback, cancellable);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var callback_ = callback is null ? default : (delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void>)&GISharp.Lib.Gio.AsyncReadyCallbackMarshal.Callback;
            var callbackHandle = callback is null ? default : System.Runtime.InteropServices.GCHandle.Alloc((callback, GISharp.Runtime.CallbackScope.Async));
            var userData_ = (System.IntPtr)callbackHandle;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            g_file_poll_mountable(file_, cancellable_, callback_, userData_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
        }

        /// <summary>
        /// Finishes a poll operation. See g_file_poll_mountable() for details.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Finish an asynchronous poll operation that was polled
        /// with g_file_poll_mountable().
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="result">
        /// a #GAsyncResult
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// %TRUE if the operation finished successfully. %FALSE
        /// otherwise.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.22")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        private static extern GISharp.Runtime.Boolean g_file_poll_mountable_finish(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="AsyncResult" type="GAsyncResult*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        static partial void CheckPollMountableFinishArgs(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.IAsyncResult result);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.PollMountableFinish(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.IAsyncResult)']/*" />
        [GISharp.Runtime.SinceAttribute("2.22")]
        public static void PollMountableFinish(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.IAsyncResult result)
        {
            CheckPollMountableFinishArgs(file, result);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var result_ = (GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*)result.UnsafeHandle;
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            g_file_poll_mountable_finish(file_, result_, &error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Runtime.GErrorException(error);
            }
        }

        /// <summary>
        /// Utility function to check if a particular file exists. This is
        /// implemented using g_file_query_info() and as such does blocking I/O.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Note that in many cases it is [racy to first check for file existence](https://en.wikipedia.org/wiki/Time_of_check_to_time_of_use)
        /// and then execute something based on the outcome of that, because the
        /// file might have been created or removed in between the operations. The
        /// general approach to handling that is to not check, but just do the
        /// operation and handle the errors as they come.
        /// </para>
        /// <para>
        /// As an example of race-free checking, take the case of reading a file,
        /// and if it doesn't exist, creating it. There are two racy versions: read
        /// it, and on error create it; and: check if it exists, if not create it.
        /// These can both result in two processes creating the file (with perhaps
        /// a partially written file as the result). The correct approach is to
        /// always try to create the file with g_file_create() which will either
        /// atomically create the file or fail with a %G_IO_ERROR_EXISTS error.
        /// </para>
        /// <para>
        /// However, in many cases an existence check is useful in a user interface,
        /// for instance to make a menu item sensitive/insensitive, so that you don't
        /// have to fool users that something is possible and then just show an error
        /// dialog. If you do this, you should make sure to also handle the errors
        /// that can happen due to races when you execute the operation.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object,
        ///     %NULL to ignore
        /// </param>
        /// <returns>
        /// %TRUE if the file exists (and can be detected without error),
        ///     %FALSE otherwise (or if cancelled).
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_file_query_exists(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable);
        static partial void CheckQueryExistsArgs(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.QueryExists(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.Cancellable?)']/*" />
        public static bool QueryExists(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckQueryExistsArgs(file, cancellable);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var ret_ = g_file_query_exists(file_,cancellable_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Utility function to inspect the #GFileType of a file. This is
        /// implemented using g_file_query_info() and as such does blocking I/O.
        /// </summary>
        /// <remarks>
        /// <para>
        /// The primary use case of this method is to check if a file is
        /// a regular file, directory, or symlink.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="flags">
        /// a set of #GFileQueryInfoFlags passed to g_file_query_info()
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object,
        ///     %NULL to ignore
        /// </param>
        /// <returns>
        /// The #GFileType of the file and #G_FILE_TYPE_UNKNOWN
        ///     if the file does not exist
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.18")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileType" type="GFileType" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.Gio.FileType g_file_query_file_type(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="FileQueryInfoFlags" type="GFileQueryInfoFlags" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.FileQueryInfoFlags flags,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable);
        static partial void CheckQueryFileTypeArgs(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.FileQueryInfoFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.QueryFileType(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.FileQueryInfoFlags,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.SinceAttribute("2.18")]
        public static GISharp.Lib.Gio.FileType QueryFileType(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.FileQueryInfoFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckQueryFileTypeArgs(file, flags, cancellable);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var flags_ = (GISharp.Lib.Gio.FileQueryInfoFlags)flags;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var ret_ = g_file_query_file_type(file_,flags_,cancellable_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = (GISharp.Lib.Gio.FileType)ret_;
            return ret;
        }

        /// <summary>
        /// Similar to g_file_query_info(), but obtains information
        /// about the filesystem the @file is on, rather than the file itself.
        /// For instance the amount of space available and the type of
        /// the filesystem.
        /// </summary>
        /// <remarks>
        /// <para>
        /// The @attributes value is a string that specifies the attributes
        /// that should be gathered. It is not an error if it's not possible
        /// to read a particular requested attribute from a file - it just
        /// won't be set. @attributes should be a comma-separated list of
        /// attributes or attribute wildcards. The wildcard "*" means all
        /// attributes, and a wildcard like "filesystem::*" means all attributes
        /// in the filesystem namespace. The standard namespace for filesystem
        /// attributes is "filesystem". Common attributes of interest are
        /// #G_FILE_ATTRIBUTE_FILESYSTEM_SIZE (the total size of the filesystem
        /// in bytes), #G_FILE_ATTRIBUTE_FILESYSTEM_FREE (number of bytes available),
        /// and #G_FILE_ATTRIBUTE_FILESYSTEM_TYPE (type of the filesystem).
        /// </para>
        /// <para>
        /// If @cancellable is not %NULL, then the operation can be cancelled
        /// by triggering the cancellable object from another thread. If the
        /// operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
        /// returned.
        /// </para>
        /// <para>
        /// If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will
        /// be returned. Other errors are possible too, and depend on what
        /// kind of filesystem the file is on.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="attributes">
        /// an attribute query string
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object,
        ///     %NULL to ignore
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// a #GFileInfo or %NULL if there was an error.
        ///     Free the returned object with g_object_unref().
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileInfo" type="GFileInfo*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.Gio.FileInfo.UnmanagedStruct* g_file_query_filesystem_info(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="utf8" type="const char*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* attributes,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        static partial void CheckQueryFilesystemInfoArgs(this GISharp.Lib.Gio.IFile file, GISharp.Lib.GLib.UnownedUtf8 attributes, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.QueryFilesystemInfo(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.Gio.Cancellable?)']/*" />
        public static GISharp.Lib.Gio.FileInfo QueryFilesystemInfo(this GISharp.Lib.Gio.IFile file, GISharp.Lib.GLib.UnownedUtf8 attributes, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckQueryFilesystemInfoArgs(file, attributes, cancellable);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var attributes_ = (byte*)attributes.UnsafeHandle;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            var ret_ = g_file_query_filesystem_info(file_,attributes_,cancellable_,&error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Runtime.GErrorException(error);
            }

            var ret = GISharp.Lib.Gio.FileInfo.GetInstance<GISharp.Lib.Gio.FileInfo>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Asynchronously gets the requested information about the filesystem
        /// that the specified @file is on. The result is a #GFileInfo object
        /// that contains key-value attributes (such as type or size for the
        /// file).
        /// </summary>
        /// <remarks>
        /// <para>
        /// For more details, see g_file_query_filesystem_info() which is the
        /// synchronous version of this call.
        /// </para>
        /// <para>
        /// When the operation is finished, @callback will be called. You can
        /// then call g_file_query_info_finish() to get the result of the
        /// operation.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="attributes">
        /// an attribute query string
        /// </param>
        /// <param name="ioPriority">
        /// the [I/O priority][io-priority] of the request
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object,
        ///     %NULL to ignore
        /// </param>
        /// <param name="callback">
        /// a #GAsyncReadyCallback to call
        ///     when the request is satisfied
        /// </param>
        /// <param name="userData">
        /// the data to pass to callback function
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Threading.Tasks.Task">
*   <type name="FileInfo" type="GFileInfo*" is-pointer="1" />
* </type> */
        /* transfer-ownership:none direction:in */
        private static extern void g_file_query_filesystem_info_async(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="utf8" type="const char*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* attributes,
        /* <type name="gint" type="int" /> */
        /* transfer-ownership:none direction:in */
        int ioPriority,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:4 direction:in */
        delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback,
        /* <type name="gpointer" type="gpointer" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr userData);
        static partial void CheckQueryFilesystemInfoAsyncArgs(this GISharp.Lib.Gio.IFile file, GISharp.Lib.GLib.UnownedUtf8 attributes, int ioPriority = GISharp.Lib.GLib.Priority.Default, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.QueryFilesystemInfoAsync(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.UnownedUtf8,int,GISharp.Lib.Gio.Cancellable?)']/*" />
        public static System.Threading.Tasks.Task<GISharp.Lib.Gio.FileInfo> QueryFilesystemInfoAsync(this GISharp.Lib.Gio.IFile file, GISharp.Lib.GLib.UnownedUtf8 attributes, int ioPriority = GISharp.Lib.GLib.Priority.Default, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckQueryFilesystemInfoAsyncArgs(file, attributes, ioPriority, cancellable);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var attributes_ = (byte*)attributes.UnsafeHandle;
            var ioPriority_ = (int)ioPriority;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var completionSource = new System.Threading.Tasks.TaskCompletionSource<GISharp.Lib.Gio.FileInfo>();
            var callback_ = (delegate* unmanaged[Cdecl] <GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void>)&QueryFilesystemInfoFinish;
            var userData_ = (System.IntPtr)System.Runtime.InteropServices.GCHandle.Alloc(completionSource);
            g_file_query_filesystem_info_async(file_, attributes_, ioPriority_, cancellable_, callback_, userData_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            return completionSource.Task;
        }

        /// <summary>
        /// Finishes an asynchronous filesystem info query.
        /// See g_file_query_filesystem_info_async().
        /// </summary>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="res">
        /// a #GAsyncResult
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// #GFileInfo for given @file
        ///     or %NULL on error.
        ///     Free the returned object with g_object_unref().
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileInfo" type="GFileInfo*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.Gio.FileInfo.UnmanagedStruct* g_file_query_filesystem_info_finish(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="AsyncResult" type="GAsyncResult*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        [System.Runtime.InteropServices.UnmanagedCallersOnlyAttribute(CallConvs = new[] { typeof(System.Runtime.CompilerServices.CallConvCdecl) })]
        private static void QueryFilesystemInfoFinish(GISharp.Lib.GObject.Object.UnmanagedStruct* sourceObject_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res_, System.IntPtr userData_)
        {
            try
            {
                var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)sourceObject_;
                var userData = (System.Runtime.InteropServices.GCHandle)userData_;
                var completionSource = (System.Threading.Tasks.TaskCompletionSource<GISharp.Lib.Gio.FileInfo>)userData.Target!;
                userData.Free();
                var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
                var ret_ = g_file_query_filesystem_info_finish(file_,res_,&error_);
                if (error_ is not null)
                {
                    var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                    completionSource.SetException(new GISharp.Runtime.GErrorException(error));
                    return;
                }
                var ret = GISharp.Lib.Gio.FileInfo.GetInstance<GISharp.Lib.Gio.FileInfo>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
                completionSource.SetResult((ret));
            }
            catch (System.Exception ex)
            {
                GISharp.Runtime.GMarshal.PushUnhandledException(ex);
            }
        }

        /// <summary>
        /// Gets the requested information about specified @file.
        /// The result is a #GFileInfo object that contains key-value
        /// attributes (such as the type or size of the file).
        /// </summary>
        /// <remarks>
        /// <para>
        /// The @attributes value is a string that specifies the file
        /// attributes that should be gathered. It is not an error if
        /// it's not possible to read a particular requested attribute
        /// from a file - it just won't be set. @attributes should be a
        /// comma-separated list of attributes or attribute wildcards.
        /// The wildcard "*" means all attributes, and a wildcard like
        /// "standard::*" means all attributes in the standard namespace.
        /// An example attribute query be "standard::*,owner::user".
        /// The standard attributes are available as defines, like
        /// #G_FILE_ATTRIBUTE_STANDARD_NAME.
        /// </para>
        /// <para>
        /// If @cancellable is not %NULL, then the operation can be cancelled
        /// by triggering the cancellable object from another thread. If the
        /// operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
        /// returned.
        /// </para>
        /// <para>
        /// For symlinks, normally the information about the target of the
        /// symlink is returned, rather than information about the symlink
        /// itself. However if you pass #G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS
        /// in @flags the information about the symlink itself will be returned.
        /// Also, for symlinks that point to non-existing files the information
        /// about the symlink itself will be returned.
        /// </para>
        /// <para>
        /// If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will be
        /// returned. Other errors are possible too, and depend on what kind of
        /// filesystem the file is on.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="attributes">
        /// an attribute query string
        /// </param>
        /// <param name="flags">
        /// a set of #GFileQueryInfoFlags
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object,
        ///     %NULL to ignore
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// a #GFileInfo for the given @file, or %NULL
        ///     on error. Free the returned object with g_object_unref().
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileInfo" type="GFileInfo*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.Gio.FileInfo.UnmanagedStruct* g_file_query_info(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="utf8" type="const char*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* attributes,
        /* <type name="FileQueryInfoFlags" type="GFileQueryInfoFlags" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.FileQueryInfoFlags flags,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        static partial void CheckQueryInfoArgs(this GISharp.Lib.Gio.IFile file, GISharp.Lib.GLib.UnownedUtf8 attributes, GISharp.Lib.Gio.FileQueryInfoFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.QueryInfo(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.Gio.FileQueryInfoFlags,GISharp.Lib.Gio.Cancellable?)']/*" />
        public static GISharp.Lib.Gio.FileInfo QueryInfo(this GISharp.Lib.Gio.IFile file, GISharp.Lib.GLib.UnownedUtf8 attributes, GISharp.Lib.Gio.FileQueryInfoFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckQueryInfoArgs(file, attributes, flags, cancellable);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var attributes_ = (byte*)attributes.UnsafeHandle;
            var flags_ = (GISharp.Lib.Gio.FileQueryInfoFlags)flags;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            var ret_ = g_file_query_info(file_,attributes_,flags_,cancellable_,&error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Runtime.GErrorException(error);
            }

            var ret = GISharp.Lib.Gio.FileInfo.GetInstance<GISharp.Lib.Gio.FileInfo>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Asynchronously gets the requested information about specified @file.
        /// The result is a #GFileInfo object that contains key-value attributes
        /// (such as type or size for the file).
        /// </summary>
        /// <remarks>
        /// <para>
        /// For more details, see g_file_query_info() which is the synchronous
        /// version of this call.
        /// </para>
        /// <para>
        /// When the operation is finished, @callback will be called. You can
        /// then call g_file_query_info_finish() to get the result of the operation.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="attributes">
        /// an attribute query string
        /// </param>
        /// <param name="flags">
        /// a set of #GFileQueryInfoFlags
        /// </param>
        /// <param name="ioPriority">
        /// the [I/O priority][io-priority] of the request
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object,
        ///     %NULL to ignore
        /// </param>
        /// <param name="callback">
        /// a #GAsyncReadyCallback to call when the
        ///     request is satisfied
        /// </param>
        /// <param name="userData">
        /// the data to pass to callback function
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Threading.Tasks.Task">
*   <type name="FileInfo" type="GFileInfo*" is-pointer="1" />
* </type> */
        /* transfer-ownership:none direction:in */
        private static extern void g_file_query_info_async(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="utf8" type="const char*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* attributes,
        /* <type name="FileQueryInfoFlags" type="GFileQueryInfoFlags" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.FileQueryInfoFlags flags,
        /* <type name="gint" type="int" /> */
        /* transfer-ownership:none direction:in */
        int ioPriority,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:5 direction:in */
        delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback,
        /* <type name="gpointer" type="gpointer" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr userData);
        static partial void CheckQueryInfoAsyncArgs(this GISharp.Lib.Gio.IFile file, GISharp.Lib.GLib.UnownedUtf8 attributes, GISharp.Lib.Gio.FileQueryInfoFlags flags, int ioPriority = GISharp.Lib.GLib.Priority.Default, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.QueryInfoAsync(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.Gio.FileQueryInfoFlags,int,GISharp.Lib.Gio.Cancellable?)']/*" />
        public static System.Threading.Tasks.Task<GISharp.Lib.Gio.FileInfo> QueryInfoAsync(this GISharp.Lib.Gio.IFile file, GISharp.Lib.GLib.UnownedUtf8 attributes, GISharp.Lib.Gio.FileQueryInfoFlags flags, int ioPriority = GISharp.Lib.GLib.Priority.Default, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckQueryInfoAsyncArgs(file, attributes, flags, ioPriority, cancellable);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var attributes_ = (byte*)attributes.UnsafeHandle;
            var flags_ = (GISharp.Lib.Gio.FileQueryInfoFlags)flags;
            var ioPriority_ = (int)ioPriority;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var completionSource = new System.Threading.Tasks.TaskCompletionSource<GISharp.Lib.Gio.FileInfo>();
            var callback_ = (delegate* unmanaged[Cdecl] <GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void>)&QueryInfoFinish;
            var userData_ = (System.IntPtr)System.Runtime.InteropServices.GCHandle.Alloc(completionSource);
            g_file_query_info_async(file_, attributes_, flags_, ioPriority_, cancellable_, callback_, userData_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            return completionSource.Task;
        }

        /// <summary>
        /// Finishes an asynchronous file info query.
        /// See g_file_query_info_async().
        /// </summary>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="res">
        /// a #GAsyncResult
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// #GFileInfo for given @file
        ///     or %NULL on error. Free the returned object with
        ///     g_object_unref().
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileInfo" type="GFileInfo*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.Gio.FileInfo.UnmanagedStruct* g_file_query_info_finish(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="AsyncResult" type="GAsyncResult*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        [System.Runtime.InteropServices.UnmanagedCallersOnlyAttribute(CallConvs = new[] { typeof(System.Runtime.CompilerServices.CallConvCdecl) })]
        private static void QueryInfoFinish(GISharp.Lib.GObject.Object.UnmanagedStruct* sourceObject_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res_, System.IntPtr userData_)
        {
            try
            {
                var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)sourceObject_;
                var userData = (System.Runtime.InteropServices.GCHandle)userData_;
                var completionSource = (System.Threading.Tasks.TaskCompletionSource<GISharp.Lib.Gio.FileInfo>)userData.Target!;
                userData.Free();
                var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
                var ret_ = g_file_query_info_finish(file_,res_,&error_);
                if (error_ is not null)
                {
                    var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                    completionSource.SetException(new GISharp.Runtime.GErrorException(error));
                    return;
                }
                var ret = GISharp.Lib.Gio.FileInfo.GetInstance<GISharp.Lib.Gio.FileInfo>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
                completionSource.SetResult((ret));
            }
            catch (System.Exception ex)
            {
                GISharp.Runtime.GMarshal.PushUnhandledException(ex);
            }
        }

        /// <summary>
        /// Obtain the list of settable attributes for the file.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Returns the type and full attribute name of all the attributes
        /// that can be set on this file. This doesn't mean setting it will
        /// always succeed though, you might get an access failure, or some
        /// specific file may not support a specific attribute.
        /// </para>
        /// <para>
        /// If @cancellable is not %NULL, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object,
        ///     %NULL to ignore
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// a #GFileAttributeInfoList describing the settable attributes.
        ///     When you are done with it, release it with
        ///     g_file_attribute_info_list_unref()
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileAttributeInfoList" type="GFileAttributeInfoList*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.Gio.FileAttributeInfoList.UnmanagedStruct* g_file_query_settable_attributes(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        static partial void CheckQuerySettableAttributesArgs(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.QuerySettableAttributes(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.Cancellable?)']/*" />
        public static GISharp.Lib.Gio.FileAttributeInfoList QuerySettableAttributes(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckQuerySettableAttributesArgs(file, cancellable);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            var ret_ = g_file_query_settable_attributes(file_,cancellable_,&error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Runtime.GErrorException(error);
            }

            var ret = GISharp.Lib.Gio.FileAttributeInfoList.GetInstance<GISharp.Lib.Gio.FileAttributeInfoList>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Obtain the list of attribute namespaces where new attributes
        /// can be created by a user. An example of this is extended
        /// attributes (in the "xattr" namespace).
        /// </summary>
        /// <remarks>
        /// <para>
        /// If @cancellable is not %NULL, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object,
        ///     %NULL to ignore
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// a #GFileAttributeInfoList describing the writable namespaces.
        ///     When you are done with it, release it with
        ///     g_file_attribute_info_list_unref()
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileAttributeInfoList" type="GFileAttributeInfoList*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.Gio.FileAttributeInfoList.UnmanagedStruct* g_file_query_writable_namespaces(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        static partial void CheckQueryWritableNamespacesArgs(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.QueryWritableNamespaces(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.Cancellable?)']/*" />
        public static GISharp.Lib.Gio.FileAttributeInfoList QueryWritableNamespaces(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckQueryWritableNamespacesArgs(file, cancellable);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            var ret_ = g_file_query_writable_namespaces(file_,cancellable_,&error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Runtime.GErrorException(error);
            }

            var ret = GISharp.Lib.Gio.FileAttributeInfoList.GetInstance<GISharp.Lib.Gio.FileAttributeInfoList>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Opens a file for reading. The result is a #GFileInputStream that
        /// can be used to read the contents of the file.
        /// </summary>
        /// <remarks>
        /// <para>
        /// If @cancellable is not %NULL, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
        /// </para>
        /// <para>
        /// If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will be
        /// returned. If the file is a directory, the %G_IO_ERROR_IS_DIRECTORY
        /// error will be returned. Other errors are possible too, and depend
        /// on what kind of filesystem the file is on.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// #GFile to read
        /// </param>
        /// <param name="cancellable">
        /// a #GCancellable
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// #GFileInputStream or %NULL on error.
        ///     Free the returned object with g_object_unref().
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileInputStream" type="GFileInputStream*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.Gio.FileInputStream.UnmanagedStruct* g_file_read(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        static partial void CheckReadArgs(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.Read(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.Cancellable?)']/*" />
        public static GISharp.Lib.Gio.FileInputStream Read(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckReadArgs(file, cancellable);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            var ret_ = g_file_read(file_,cancellable_,&error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Runtime.GErrorException(error);
            }

            var ret = GISharp.Lib.Gio.FileInputStream.GetInstance<GISharp.Lib.Gio.FileInputStream>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Asynchronously opens @file for reading.
        /// </summary>
        /// <remarks>
        /// <para>
        /// For more details, see g_file_read() which is
        /// the synchronous version of this call.
        /// </para>
        /// <para>
        /// When the operation is finished, @callback will be called.
        /// You can then call g_file_read_finish() to get the result
        /// of the operation.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="ioPriority">
        /// the [I/O priority][io-priority] of the request
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object,
        ///     %NULL to ignore
        /// </param>
        /// <param name="callback">
        /// a #GAsyncReadyCallback to call
        ///     when the request is satisfied
        /// </param>
        /// <param name="userData">
        /// the data to pass to callback function
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Threading.Tasks.Task">
*   <type name="FileInputStream" type="GFileInputStream*" is-pointer="1" />
* </type> */
        /* transfer-ownership:none direction:in */
        private static extern void g_file_read_async(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="gint" type="int" /> */
        /* transfer-ownership:none direction:in */
        int ioPriority,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:3 direction:in */
        delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback,
        /* <type name="gpointer" type="gpointer" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr userData);
        static partial void CheckReadAsyncArgs(this GISharp.Lib.Gio.IFile file, int ioPriority = GISharp.Lib.GLib.Priority.Default, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.ReadAsync(GISharp.Lib.Gio.IFile,int,GISharp.Lib.Gio.Cancellable?)']/*" />
        public static System.Threading.Tasks.Task<GISharp.Lib.Gio.FileInputStream> ReadAsync(this GISharp.Lib.Gio.IFile file, int ioPriority = GISharp.Lib.GLib.Priority.Default, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckReadAsyncArgs(file, ioPriority, cancellable);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var ioPriority_ = (int)ioPriority;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var completionSource = new System.Threading.Tasks.TaskCompletionSource<GISharp.Lib.Gio.FileInputStream>();
            var callback_ = (delegate* unmanaged[Cdecl] <GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void>)&ReadFinish;
            var userData_ = (System.IntPtr)System.Runtime.InteropServices.GCHandle.Alloc(completionSource);
            g_file_read_async(file_, ioPriority_, cancellable_, callback_, userData_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            return completionSource.Task;
        }

        /// <summary>
        /// Finishes an asynchronous file read operation started with
        /// g_file_read_async().
        /// </summary>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="res">
        /// a #GAsyncResult
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// a #GFileInputStream or %NULL on error.
        ///     Free the returned object with g_object_unref().
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileInputStream" type="GFileInputStream*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.Gio.FileInputStream.UnmanagedStruct* g_file_read_finish(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="AsyncResult" type="GAsyncResult*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        [System.Runtime.InteropServices.UnmanagedCallersOnlyAttribute(CallConvs = new[] { typeof(System.Runtime.CompilerServices.CallConvCdecl) })]
        private static void ReadFinish(GISharp.Lib.GObject.Object.UnmanagedStruct* sourceObject_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res_, System.IntPtr userData_)
        {
            try
            {
                var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)sourceObject_;
                var userData = (System.Runtime.InteropServices.GCHandle)userData_;
                var completionSource = (System.Threading.Tasks.TaskCompletionSource<GISharp.Lib.Gio.FileInputStream>)userData.Target!;
                userData.Free();
                var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
                var ret_ = g_file_read_finish(file_,res_,&error_);
                if (error_ is not null)
                {
                    var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                    completionSource.SetException(new GISharp.Runtime.GErrorException(error));
                    return;
                }
                var ret = GISharp.Lib.Gio.FileInputStream.GetInstance<GISharp.Lib.Gio.FileInputStream>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
                completionSource.SetResult((ret));
            }
            catch (System.Exception ex)
            {
                GISharp.Runtime.GMarshal.PushUnhandledException(ex);
            }
        }

        /// <summary>
        /// Returns an output stream for overwriting the file, possibly
        /// creating a backup copy of the file first. If the file doesn't exist,
        /// it will be created.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This will try to replace the file in the safest way possible so
        /// that any errors during the writing will not affect an already
        /// existing copy of the file. For instance, for local files it
        /// may write to a temporary file and then atomically rename over
        /// the destination when the stream is closed.
        /// </para>
        /// <para>
        /// By default files created are generally readable by everyone,
        /// but if you pass #G_FILE_CREATE_PRIVATE in @flags the file
        /// will be made readable only to the current user, to the level that
        /// is supported on the target filesystem.
        /// </para>
        /// <para>
        /// If @cancellable is not %NULL, then the operation can be cancelled
        /// by triggering the cancellable object from another thread. If the
        /// operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
        /// returned.
        /// </para>
        /// <para>
        /// If you pass in a non-%NULL @etag value and @file already exists, then
        /// this value is compared to the current entity tag of the file, and if
        /// they differ an %G_IO_ERROR_WRONG_ETAG error is returned. This
        /// generally means that the file has been changed since you last read
        /// it. You can get the new etag from g_file_output_stream_get_etag()
        /// after you've finished writing and closed the #GFileOutputStream. When
        /// you load a new file you can use g_file_input_stream_query_info() to
        /// get the etag of the file.
        /// </para>
        /// <para>
        /// If @make_backup is %TRUE, this function will attempt to make a
        /// backup of the current file before overwriting it. If this fails
        /// a %G_IO_ERROR_CANT_CREATE_BACKUP error will be returned. If you
        /// want to replace anyway, try again with @make_backup set to %FALSE.
        /// </para>
        /// <para>
        /// If the file is a directory the %G_IO_ERROR_IS_DIRECTORY error will
        /// be returned, and if the file is some other form of non-regular file
        /// then a %G_IO_ERROR_NOT_REGULAR_FILE error will be returned. Some
        /// file systems don't allow all file names, and may return an
        /// %G_IO_ERROR_INVALID_FILENAME error, and if the name is to long
        /// %G_IO_ERROR_FILENAME_TOO_LONG will be returned. Other errors are
        /// possible too, and depend on what kind of filesystem the file is on.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="etag">
        /// an optional [entity tag][gfile-etag]
        ///     for the current #GFile, or #NULL to ignore
        /// </param>
        /// <param name="makeBackup">
        /// %TRUE if a backup should be created
        /// </param>
        /// <param name="flags">
        /// a set of #GFileCreateFlags
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object,
        ///     %NULL to ignore
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// a #GFileOutputStream or %NULL on error.
        ///     Free the returned object with g_object_unref().
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileOutputStream" type="GFileOutputStream*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct* g_file_replace(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="utf8" type="const char*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        byte* etag,
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.Boolean makeBackup,
        /* <type name="FileCreateFlags" type="GFileCreateFlags" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.FileCreateFlags flags,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        static partial void CheckReplaceArgs(this GISharp.Lib.Gio.IFile file, GISharp.Lib.GLib.NullableUnownedUtf8 etag, bool makeBackup, GISharp.Lib.Gio.FileCreateFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.Replace(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.NullableUnownedUtf8,bool,GISharp.Lib.Gio.FileCreateFlags,GISharp.Lib.Gio.Cancellable?)']/*" />
        public static GISharp.Lib.Gio.FileOutputStream Replace(this GISharp.Lib.Gio.IFile file, GISharp.Lib.GLib.NullableUnownedUtf8 etag, bool makeBackup, GISharp.Lib.Gio.FileCreateFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckReplaceArgs(file, etag, makeBackup, flags, cancellable);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var etag_ = (byte*)etag.UnsafeHandle;
            var makeBackup_ = GISharp.Runtime.BooleanExtensions.ToBoolean(makeBackup);
            var flags_ = (GISharp.Lib.Gio.FileCreateFlags)flags;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            var ret_ = g_file_replace(file_,etag_,makeBackup_,flags_,cancellable_,&error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Runtime.GErrorException(error);
            }

            var ret = GISharp.Lib.Gio.FileOutputStream.GetInstance<GISharp.Lib.Gio.FileOutputStream>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Asynchronously overwrites the file, replacing the contents,
        /// possibly creating a backup copy of the file first.
        /// </summary>
        /// <remarks>
        /// <para>
        /// For more details, see g_file_replace() which is
        /// the synchronous version of this call.
        /// </para>
        /// <para>
        /// When the operation is finished, @callback will be called.
        /// You can then call g_file_replace_finish() to get the result
        /// of the operation.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="etag">
        /// an [entity tag][gfile-etag] for the current #GFile,
        ///     or %NULL to ignore
        /// </param>
        /// <param name="makeBackup">
        /// %TRUE if a backup should be created
        /// </param>
        /// <param name="flags">
        /// a set of #GFileCreateFlags
        /// </param>
        /// <param name="ioPriority">
        /// the [I/O priority][io-priority] of the request
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object,
        ///     %NULL to ignore
        /// </param>
        /// <param name="callback">
        /// a #GAsyncReadyCallback to call
        ///     when the request is satisfied
        /// </param>
        /// <param name="userData">
        /// the data to pass to callback function
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Threading.Tasks.Task">
*   <type name="FileOutputStream" type="GFileOutputStream*" is-pointer="1" />
* </type> */
        /* transfer-ownership:none direction:in */
        private static extern void g_file_replace_async(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="utf8" type="const char*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        byte* etag,
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.Boolean makeBackup,
        /* <type name="FileCreateFlags" type="GFileCreateFlags" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.FileCreateFlags flags,
        /* <type name="gint" type="int" /> */
        /* transfer-ownership:none direction:in */
        int ioPriority,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:6 direction:in */
        delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback,
        /* <type name="gpointer" type="gpointer" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr userData);
        static partial void CheckReplaceAsyncArgs(this GISharp.Lib.Gio.IFile file, GISharp.Lib.GLib.NullableUnownedUtf8 etag, bool makeBackup, GISharp.Lib.Gio.FileCreateFlags flags, int ioPriority = GISharp.Lib.GLib.Priority.Default, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.ReplaceAsync(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.NullableUnownedUtf8,bool,GISharp.Lib.Gio.FileCreateFlags,int,GISharp.Lib.Gio.Cancellable?)']/*" />
        public static System.Threading.Tasks.Task<GISharp.Lib.Gio.FileOutputStream> ReplaceAsync(this GISharp.Lib.Gio.IFile file, GISharp.Lib.GLib.NullableUnownedUtf8 etag, bool makeBackup, GISharp.Lib.Gio.FileCreateFlags flags, int ioPriority = GISharp.Lib.GLib.Priority.Default, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckReplaceAsyncArgs(file, etag, makeBackup, flags, ioPriority, cancellable);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var etag_ = (byte*)etag.UnsafeHandle;
            var makeBackup_ = GISharp.Runtime.BooleanExtensions.ToBoolean(makeBackup);
            var flags_ = (GISharp.Lib.Gio.FileCreateFlags)flags;
            var ioPriority_ = (int)ioPriority;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var completionSource = new System.Threading.Tasks.TaskCompletionSource<GISharp.Lib.Gio.FileOutputStream>();
            var callback_ = (delegate* unmanaged[Cdecl] <GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void>)&ReplaceFinish;
            var userData_ = (System.IntPtr)System.Runtime.InteropServices.GCHandle.Alloc(completionSource);
            g_file_replace_async(file_, etag_, makeBackup_, flags_, ioPriority_, cancellable_, callback_, userData_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            return completionSource.Task;
        }

        /// <summary>
        /// Replaces the contents of @file with @contents of @length bytes.
        /// </summary>
        /// <remarks>
        /// <para>
        /// If @etag is specified (not %NULL), any existing file must have that etag,
        /// or the error %G_IO_ERROR_WRONG_ETAG will be returned.
        /// </para>
        /// <para>
        /// If @make_backup is %TRUE, this function will attempt to make a backup
        /// of @file. Internally, it uses g_file_replace(), so will try to replace the
        /// file contents in the safest way possible. For example, atomic renames are
        /// used when replacing local files’ contents.
        /// </para>
        /// <para>
        /// If @cancellable is not %NULL, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
        /// </para>
        /// <para>
        /// The returned @new_etag can be used to verify that the file hasn't
        /// changed the next time it is saved over.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="contents">
        /// a string containing the new contents for @file
        /// </param>
        /// <param name="length">
        /// the length of @contents in bytes
        /// </param>
        /// <param name="etag">
        /// the old [entity-tag][gfile-etag] for the document,
        ///     or %NULL
        /// </param>
        /// <param name="makeBackup">
        /// %TRUE if a backup should be created
        /// </param>
        /// <param name="flags">
        /// a set of #GFileCreateFlags
        /// </param>
        /// <param name="newEtag">
        /// a location to a new [entity tag][gfile-etag]
        ///      for the document. This should be freed with g_free() when no longer
        ///      needed, or %NULL
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object, %NULL to ignore
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// %TRUE if successful. If an error has occurred, this function
        ///     will return %FALSE and set @error appropriately if present.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        private static extern GISharp.Runtime.Boolean g_file_replace_contents(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <array length="1" zero-terminated="0" type="const char*" is-pointer="1">
*   <type name="guint8" />
* </array> */
        /* transfer-ownership:none direction:in */
        byte* contents,
        /* <type name="gsize" type="gsize" /> */
        /* transfer-ownership:none direction:in */
        nuint length,
        /* <type name="utf8" type="const char*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        byte* etag,
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.Boolean makeBackup,
        /* <type name="FileCreateFlags" type="GFileCreateFlags" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.FileCreateFlags flags,
        /* <type name="utf8" type="char**" is-pointer="1" /> */
        /* direction:out caller-allocates:0 transfer-ownership:full optional:1 allow-none:1 */
        byte** newEtag,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        static partial void CheckReplaceContentsArgs(this GISharp.Lib.Gio.IFile file, System.ReadOnlySpan<byte> contents, GISharp.Lib.GLib.NullableUnownedUtf8 etag, bool makeBackup, GISharp.Lib.Gio.FileCreateFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.ReplaceContents(GISharp.Lib.Gio.IFile,System.ReadOnlySpan&lt;byte&gt;,GISharp.Lib.GLib.NullableUnownedUtf8,bool,GISharp.Lib.Gio.FileCreateFlags,GISharp.Lib.GLib.Utf8,GISharp.Lib.Gio.Cancellable?)']/*" />
        public static void ReplaceContents(this GISharp.Lib.Gio.IFile file, System.ReadOnlySpan<byte> contents, GISharp.Lib.GLib.NullableUnownedUtf8 etag, bool makeBackup, GISharp.Lib.Gio.FileCreateFlags flags, out GISharp.Lib.GLib.Utf8 newEtag, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            fixed (byte* contentsData_ = contents)
            {
                CheckReplaceContentsArgs(file, contents, etag, makeBackup, flags, cancellable);
                var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
                var contents_ = (byte*)contentsData_;
                var length_ = (nuint)contents.Length;
                var etag_ = (byte*)etag.UnsafeHandle;
                var makeBackup_ = GISharp.Runtime.BooleanExtensions.ToBoolean(makeBackup);
                var flags_ = (GISharp.Lib.Gio.FileCreateFlags)flags;
                var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
                byte* newEtag_;
                var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
                g_file_replace_contents(file_, contents_, length_, etag_, makeBackup_, flags_, &newEtag_, cancellable_, &error_);
                GISharp.Runtime.GMarshal.PopUnhandledException();
                if (error_ is not null)
                {
                    var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                    throw new GISharp.Runtime.GErrorException(error);
                }

                newEtag = GISharp.Lib.GLib.Utf8.GetInstance<GISharp.Lib.GLib.Utf8>((System.IntPtr)newEtag_, GISharp.Runtime.Transfer.Full)!;
            }
        }

        /// <summary>
        /// Starts an asynchronous replacement of @file with the given
        /// @contents of @length bytes. @etag will replace the document's
        /// current entity tag.
        /// </summary>
        /// <remarks>
        /// <para>
        /// When this operation has completed, @callback will be called with
        /// @user_user data, and the operation can be finalized with
        /// g_file_replace_contents_finish().
        /// </para>
        /// <para>
        /// If @cancellable is not %NULL, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
        /// </para>
        /// <para>
        /// If @make_backup is %TRUE, this function will attempt to
        /// make a backup of @file.
        /// </para>
        /// <para>
        /// Note that no copy of @contents will be made, so it must stay valid
        /// until @callback is called. See g_file_replace_contents_bytes_async()
        /// for a #GBytes version that will automatically hold a reference to the
        /// contents (without copying) for the duration of the call.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="contents">
        /// string of contents to replace the file with
        /// </param>
        /// <param name="length">
        /// the length of @contents in bytes
        /// </param>
        /// <param name="etag">
        /// a new [entity tag][gfile-etag] for the @file, or %NULL
        /// </param>
        /// <param name="makeBackup">
        /// %TRUE if a backup should be created
        /// </param>
        /// <param name="flags">
        /// a set of #GFileCreateFlags
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object, %NULL to ignore
        /// </param>
        /// <param name="callback">
        /// a #GAsyncReadyCallback to call when the request is satisfied
        /// </param>
        /// <param name="userData">
        /// the data to pass to callback function
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Threading.Tasks.Task">
*   <type name="utf8" type="char**" is-pointer="1" />
* </type> */
        /* transfer-ownership:none direction:in */
        private static extern void g_file_replace_contents_async(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <array length="1" zero-terminated="0" type="const char*" is-pointer="1">
*   <type name="guint8" />
* </array> */
        /* transfer-ownership:none direction:in */
        byte* contents,
        /* <type name="gsize" type="gsize" /> */
        /* transfer-ownership:none direction:in */
        nuint length,
        /* <type name="utf8" type="const char*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        byte* etag,
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.Boolean makeBackup,
        /* <type name="FileCreateFlags" type="GFileCreateFlags" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.FileCreateFlags flags,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:7 direction:in */
        delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback,
        /* <type name="gpointer" type="gpointer" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr userData);
        static partial void CheckReplaceContentsAsyncArgs(this GISharp.Lib.Gio.IFile file, System.ReadOnlyMemory<byte> contents, GISharp.Lib.GLib.NullableUnownedUtf8 etag, bool makeBackup, GISharp.Lib.Gio.FileCreateFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.ReplaceContentsAsync(GISharp.Lib.Gio.IFile,System.ReadOnlyMemory&lt;byte&gt;,GISharp.Lib.GLib.NullableUnownedUtf8,bool,GISharp.Lib.Gio.FileCreateFlags,GISharp.Lib.Gio.Cancellable?)']/*" />
        public static System.Threading.Tasks.Task<GISharp.Lib.GLib.Utf8> ReplaceContentsAsync(this GISharp.Lib.Gio.IFile file, System.ReadOnlyMemory<byte> contents, GISharp.Lib.GLib.NullableUnownedUtf8 etag, bool makeBackup, GISharp.Lib.Gio.FileCreateFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckReplaceContentsAsyncArgs(file, contents, etag, makeBackup, flags, cancellable);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var contents_ = (byte*)contents.Pin().Pointer;
            var length_ = (nuint)contents.Length;
            var etag_ = (byte*)etag.UnsafeHandle;
            var makeBackup_ = GISharp.Runtime.BooleanExtensions.ToBoolean(makeBackup);
            var flags_ = (GISharp.Lib.Gio.FileCreateFlags)flags;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var completionSource = new System.Threading.Tasks.TaskCompletionSource<GISharp.Lib.GLib.Utf8>();
            var callback_ = (delegate* unmanaged[Cdecl] <GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void>)&ReplaceContentsFinish;
            var userData_ = (System.IntPtr)System.Runtime.InteropServices.GCHandle.Alloc(completionSource);
            g_file_replace_contents_async(file_, contents_, length_, etag_, makeBackup_, flags_, cancellable_, callback_, userData_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            return completionSource.Task;
        }

        /// <summary>
        /// Same as g_file_replace_contents_async() but takes a #GBytes input instead.
        /// This function will keep a ref on @contents until the operation is done.
        /// Unlike g_file_replace_contents_async() this allows forgetting about the
        /// content without waiting for the callback.
        /// </summary>
        /// <remarks>
        /// <para>
        /// When this operation has completed, @callback will be called with
        /// @user_user data, and the operation can be finalized with
        /// g_file_replace_contents_finish().
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="contents">
        /// a #GBytes
        /// </param>
        /// <param name="etag">
        /// a new [entity tag][gfile-etag] for the @file, or %NULL
        /// </param>
        /// <param name="makeBackup">
        /// %TRUE if a backup should be created
        /// </param>
        /// <param name="flags">
        /// a set of #GFileCreateFlags
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object, %NULL to ignore
        /// </param>
        /// <param name="callback">
        /// a #GAsyncReadyCallback to call when the request is satisfied
        /// </param>
        /// <param name="userData">
        /// the data to pass to callback function
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.40")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Threading.Tasks.Task">
*   <type name="utf8" type="char**" is-pointer="1" />
* </type> */
        /* transfer-ownership:none direction:in */
        private static extern void g_file_replace_contents_bytes_async(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="GLib.Bytes" type="GBytes*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Bytes.UnmanagedStruct* contents,
        /* <type name="utf8" type="const char*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        byte* etag,
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.Boolean makeBackup,
        /* <type name="FileCreateFlags" type="GFileCreateFlags" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.FileCreateFlags flags,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:6 direction:in */
        delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback,
        /* <type name="gpointer" type="gpointer" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr userData);
        static partial void CheckReplaceContentsAsyncArgs(this GISharp.Lib.Gio.IFile file, GISharp.Lib.GLib.Bytes contents, GISharp.Lib.GLib.NullableUnownedUtf8 etag, bool makeBackup, GISharp.Lib.Gio.FileCreateFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.ReplaceContentsAsync(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.Bytes,GISharp.Lib.GLib.NullableUnownedUtf8,bool,GISharp.Lib.Gio.FileCreateFlags,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.SinceAttribute("2.40")]
        public static System.Threading.Tasks.Task<GISharp.Lib.GLib.Utf8> ReplaceContentsAsync(this GISharp.Lib.Gio.IFile file, GISharp.Lib.GLib.Bytes contents, GISharp.Lib.GLib.NullableUnownedUtf8 etag, bool makeBackup, GISharp.Lib.Gio.FileCreateFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckReplaceContentsAsyncArgs(file, contents, etag, makeBackup, flags, cancellable);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var contents_ = (GISharp.Lib.GLib.Bytes.UnmanagedStruct*)contents.UnsafeHandle;
            var etag_ = (byte*)etag.UnsafeHandle;
            var makeBackup_ = GISharp.Runtime.BooleanExtensions.ToBoolean(makeBackup);
            var flags_ = (GISharp.Lib.Gio.FileCreateFlags)flags;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var completionSource = new System.Threading.Tasks.TaskCompletionSource<GISharp.Lib.GLib.Utf8>();
            var callback_ = (delegate* unmanaged[Cdecl] <GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void>)&ReplaceContentsFinish;
            var userData_ = (System.IntPtr)System.Runtime.InteropServices.GCHandle.Alloc(completionSource);
            g_file_replace_contents_bytes_async(file_, contents_, etag_, makeBackup_, flags_, cancellable_, callback_, userData_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            return completionSource.Task;
        }

        /// <summary>
        /// Finishes an asynchronous replace of the given @file. See
        /// g_file_replace_contents_async(). Sets @new_etag to the new entity
        /// tag for the document, if present.
        /// </summary>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="res">
        /// a #GAsyncResult
        /// </param>
        /// <param name="newEtag">
        /// a location of a new [entity tag][gfile-etag]
        ///     for the document. This should be freed with g_free() when it is no
        ///     longer needed, or %NULL
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// %TRUE on success, %FALSE on failure.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        private static extern GISharp.Runtime.Boolean g_file_replace_contents_finish(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="AsyncResult" type="GAsyncResult*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res,
        /* <type name="utf8" type="char**" is-pointer="1" /> */
        /* direction:out caller-allocates:0 transfer-ownership:full optional:1 allow-none:1 */
        byte** newEtag,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        [System.Runtime.InteropServices.UnmanagedCallersOnlyAttribute(CallConvs = new[] { typeof(System.Runtime.CompilerServices.CallConvCdecl) })]
        private static void ReplaceContentsFinish(GISharp.Lib.GObject.Object.UnmanagedStruct* sourceObject_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res_, System.IntPtr userData_)
        {
            try
            {
                var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)sourceObject_;
                var userData = (System.Runtime.InteropServices.GCHandle)userData_;
                var completionSource = (System.Threading.Tasks.TaskCompletionSource<GISharp.Lib.GLib.Utf8>)userData.Target!;
                userData.Free();
                byte* newEtag_;
                var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
                g_file_replace_contents_finish(file_, res_, &newEtag_, &error_);
                if (error_ is not null)
                {
                    var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                    completionSource.SetException(new GISharp.Runtime.GErrorException(error));
                    return;
                }
                var newEtag = GISharp.Lib.GLib.Utf8.GetInstance<GISharp.Lib.GLib.Utf8>((System.IntPtr)newEtag_, GISharp.Runtime.Transfer.Full)!;
                completionSource.SetResult((newEtag));
            }
            catch (System.Exception ex)
            {
                GISharp.Runtime.GMarshal.PushUnhandledException(ex);
            }
        }

        /// <summary>
        /// Finishes an asynchronous file replace operation started with
        /// g_file_replace_async().
        /// </summary>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="res">
        /// a #GAsyncResult
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// a #GFileOutputStream, or %NULL on error.
        ///     Free the returned object with g_object_unref().
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileOutputStream" type="GFileOutputStream*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.Gio.FileOutputStream.UnmanagedStruct* g_file_replace_finish(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="AsyncResult" type="GAsyncResult*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        [System.Runtime.InteropServices.UnmanagedCallersOnlyAttribute(CallConvs = new[] { typeof(System.Runtime.CompilerServices.CallConvCdecl) })]
        private static void ReplaceFinish(GISharp.Lib.GObject.Object.UnmanagedStruct* sourceObject_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res_, System.IntPtr userData_)
        {
            try
            {
                var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)sourceObject_;
                var userData = (System.Runtime.InteropServices.GCHandle)userData_;
                var completionSource = (System.Threading.Tasks.TaskCompletionSource<GISharp.Lib.Gio.FileOutputStream>)userData.Target!;
                userData.Free();
                var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
                var ret_ = g_file_replace_finish(file_,res_,&error_);
                if (error_ is not null)
                {
                    var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                    completionSource.SetException(new GISharp.Runtime.GErrorException(error));
                    return;
                }
                var ret = GISharp.Lib.Gio.FileOutputStream.GetInstance<GISharp.Lib.Gio.FileOutputStream>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
                completionSource.SetResult((ret));
            }
            catch (System.Exception ex)
            {
                GISharp.Runtime.GMarshal.PushUnhandledException(ex);
            }
        }

        /// <summary>
        /// Returns an output stream for overwriting the file in readwrite mode,
        /// possibly creating a backup copy of the file first. If the file doesn't
        /// exist, it will be created.
        /// </summary>
        /// <remarks>
        /// <para>
        /// For details about the behaviour, see g_file_replace() which does the
        /// same thing but returns an output stream only.
        /// </para>
        /// <para>
        /// Note that in many non-local file cases read and write streams are not
        /// supported, so make sure you really need to do read and write streaming,
        /// rather than just opening for reading or writing.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// a #GFile
        /// </param>
        /// <param name="etag">
        /// an optional [entity tag][gfile-etag]
        ///     for the current #GFile, or #NULL to ignore
        /// </param>
        /// <param name="makeBackup">
        /// %TRUE if a backup should be created
        /// </param>
        /// <param name="flags">
        /// a set of #GFileCreateFlags
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object,
        ///     %NULL to ignore
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// a #GFileIOStream or %NULL on error.
        ///     Free the returned object with g_object_unref().
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.22")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileIOStream" type="GFileIOStream*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.Gio.FileIOStream.UnmanagedStruct* g_file_replace_readwrite(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="utf8" type="const char*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        byte* etag,
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.Boolean makeBackup,
        /* <type name="FileCreateFlags" type="GFileCreateFlags" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.FileCreateFlags flags,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        static partial void CheckReplaceReadwriteArgs(this GISharp.Lib.Gio.IFile file, GISharp.Lib.GLib.NullableUnownedUtf8 etag, bool makeBackup, GISharp.Lib.Gio.FileCreateFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.ReplaceReadwrite(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.NullableUnownedUtf8,bool,GISharp.Lib.Gio.FileCreateFlags,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.SinceAttribute("2.22")]
        public static GISharp.Lib.Gio.FileIOStream ReplaceReadwrite(this GISharp.Lib.Gio.IFile file, GISharp.Lib.GLib.NullableUnownedUtf8 etag, bool makeBackup, GISharp.Lib.Gio.FileCreateFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckReplaceReadwriteArgs(file, etag, makeBackup, flags, cancellable);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var etag_ = (byte*)etag.UnsafeHandle;
            var makeBackup_ = GISharp.Runtime.BooleanExtensions.ToBoolean(makeBackup);
            var flags_ = (GISharp.Lib.Gio.FileCreateFlags)flags;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            var ret_ = g_file_replace_readwrite(file_,etag_,makeBackup_,flags_,cancellable_,&error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Runtime.GErrorException(error);
            }

            var ret = GISharp.Lib.Gio.FileIOStream.GetInstance<GISharp.Lib.Gio.FileIOStream>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Asynchronously overwrites the file in read-write mode,
        /// replacing the contents, possibly creating a backup copy
        /// of the file first.
        /// </summary>
        /// <remarks>
        /// <para>
        /// For more details, see g_file_replace_readwrite() which is
        /// the synchronous version of this call.
        /// </para>
        /// <para>
        /// When the operation is finished, @callback will be called.
        /// You can then call g_file_replace_readwrite_finish() to get
        /// the result of the operation.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="etag">
        /// an [entity tag][gfile-etag] for the current #GFile,
        ///     or %NULL to ignore
        /// </param>
        /// <param name="makeBackup">
        /// %TRUE if a backup should be created
        /// </param>
        /// <param name="flags">
        /// a set of #GFileCreateFlags
        /// </param>
        /// <param name="ioPriority">
        /// the [I/O priority][io-priority] of the request
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object,
        ///     %NULL to ignore
        /// </param>
        /// <param name="callback">
        /// a #GAsyncReadyCallback to call
        ///     when the request is satisfied
        /// </param>
        /// <param name="userData">
        /// the data to pass to callback function
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.22")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Threading.Tasks.Task">
*   <type name="FileIOStream" type="GFileIOStream*" is-pointer="1" />
* </type> */
        /* transfer-ownership:none direction:in */
        private static extern void g_file_replace_readwrite_async(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="utf8" type="const char*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        byte* etag,
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.Boolean makeBackup,
        /* <type name="FileCreateFlags" type="GFileCreateFlags" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.FileCreateFlags flags,
        /* <type name="gint" type="int" /> */
        /* transfer-ownership:none direction:in */
        int ioPriority,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:6 direction:in */
        delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback,
        /* <type name="gpointer" type="gpointer" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr userData);
        static partial void CheckReplaceReadwriteAsyncArgs(this GISharp.Lib.Gio.IFile file, GISharp.Lib.GLib.NullableUnownedUtf8 etag, bool makeBackup, GISharp.Lib.Gio.FileCreateFlags flags, int ioPriority = GISharp.Lib.GLib.Priority.Default, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.ReplaceReadwriteAsync(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.NullableUnownedUtf8,bool,GISharp.Lib.Gio.FileCreateFlags,int,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.SinceAttribute("2.22")]
        public static System.Threading.Tasks.Task<GISharp.Lib.Gio.FileIOStream> ReplaceReadwriteAsync(this GISharp.Lib.Gio.IFile file, GISharp.Lib.GLib.NullableUnownedUtf8 etag, bool makeBackup, GISharp.Lib.Gio.FileCreateFlags flags, int ioPriority = GISharp.Lib.GLib.Priority.Default, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckReplaceReadwriteAsyncArgs(file, etag, makeBackup, flags, ioPriority, cancellable);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var etag_ = (byte*)etag.UnsafeHandle;
            var makeBackup_ = GISharp.Runtime.BooleanExtensions.ToBoolean(makeBackup);
            var flags_ = (GISharp.Lib.Gio.FileCreateFlags)flags;
            var ioPriority_ = (int)ioPriority;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var completionSource = new System.Threading.Tasks.TaskCompletionSource<GISharp.Lib.Gio.FileIOStream>();
            var callback_ = (delegate* unmanaged[Cdecl] <GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void>)&ReplaceReadwriteFinish;
            var userData_ = (System.IntPtr)System.Runtime.InteropServices.GCHandle.Alloc(completionSource);
            g_file_replace_readwrite_async(file_, etag_, makeBackup_, flags_, ioPriority_, cancellable_, callback_, userData_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            return completionSource.Task;
        }

        /// <summary>
        /// Finishes an asynchronous file replace operation started with
        /// g_file_replace_readwrite_async().
        /// </summary>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="res">
        /// a #GAsyncResult
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// a #GFileIOStream, or %NULL on error.
        ///     Free the returned object with g_object_unref().
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.22")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileIOStream" type="GFileIOStream*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.Gio.FileIOStream.UnmanagedStruct* g_file_replace_readwrite_finish(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="AsyncResult" type="GAsyncResult*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        [System.Runtime.InteropServices.UnmanagedCallersOnlyAttribute(CallConvs = new[] { typeof(System.Runtime.CompilerServices.CallConvCdecl) })]
        private static void ReplaceReadwriteFinish(GISharp.Lib.GObject.Object.UnmanagedStruct* sourceObject_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res_, System.IntPtr userData_)
        {
            try
            {
                var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)sourceObject_;
                var userData = (System.Runtime.InteropServices.GCHandle)userData_;
                var completionSource = (System.Threading.Tasks.TaskCompletionSource<GISharp.Lib.Gio.FileIOStream>)userData.Target!;
                userData.Free();
                var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
                var ret_ = g_file_replace_readwrite_finish(file_,res_,&error_);
                if (error_ is not null)
                {
                    var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                    completionSource.SetException(new GISharp.Runtime.GErrorException(error));
                    return;
                }
                var ret = GISharp.Lib.Gio.FileIOStream.GetInstance<GISharp.Lib.Gio.FileIOStream>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
                completionSource.SetResult((ret));
            }
            catch (System.Exception ex)
            {
                GISharp.Runtime.GMarshal.PushUnhandledException(ex);
            }
        }

        /// <summary>
        /// Resolves a relative path for @file to an absolute path.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This call does no blocking I/O.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="relativePath">
        /// a given relative path string
        /// </param>
        /// <returns>
        /// #GFile to the resolved path.
        ///     %NULL if @relative_path is %NULL or if @file is invalid.
        ///     Free the returned object with g_object_unref().
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.Gio.File.UnmanagedStruct* g_file_resolve_relative_path(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="filename" type="const char*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* relativePath);
        static partial void CheckResolveRelativePathArgs(this GISharp.Lib.Gio.IFile file, GISharp.Lib.GLib.Filename relativePath);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.ResolveRelativePath(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.Filename)']/*" />
        public static GISharp.Lib.Gio.IFile ResolveRelativePath(this GISharp.Lib.Gio.IFile file, GISharp.Lib.GLib.Filename relativePath)
        {
            CheckResolveRelativePathArgs(file, relativePath);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var relativePath_ = (byte*)relativePath.UnsafeHandle;
            var ret_ = g_file_resolve_relative_path(file_,relativePath_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Sets an attribute in the file with attribute name @attribute to @value_p.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Some attributes can be unset by setting @type to
        /// %G_FILE_ATTRIBUTE_TYPE_INVALID and @value_p to %NULL.
        /// </para>
        /// <para>
        /// If @cancellable is not %NULL, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="attribute">
        /// a string containing the attribute's name
        /// </param>
        /// <param name="type">
        /// The type of the attribute
        /// </param>
        /// <param name="valueP">
        /// a pointer to the value (or the pointer
        ///     itself if the type is a pointer type)
        /// </param>
        /// <param name="flags">
        /// a set of #GFileQueryInfoFlags
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object,
        ///     %NULL to ignore
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// %TRUE if the attribute was set, %FALSE otherwise.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        private static extern GISharp.Runtime.Boolean g_file_set_attribute(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="utf8" type="const char*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* attribute,
        /* <type name="FileAttributeType" type="GFileAttributeType" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.FileAttributeType type,
        /* <type name="gpointer" type="gpointer" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr valueP,
        /* <type name="FileQueryInfoFlags" type="GFileQueryInfoFlags" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.FileQueryInfoFlags flags,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        static partial void CheckSetAttributeArgs(this GISharp.Lib.Gio.IFile file, GISharp.Lib.GLib.UnownedUtf8 attribute, GISharp.Lib.Gio.FileAttributeType type, System.IntPtr valueP, GISharp.Lib.Gio.FileQueryInfoFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.SetAttribute(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.Gio.FileAttributeType,System.IntPtr,GISharp.Lib.Gio.FileQueryInfoFlags,GISharp.Lib.Gio.Cancellable?)']/*" />
        public static void SetAttribute(this GISharp.Lib.Gio.IFile file, GISharp.Lib.GLib.UnownedUtf8 attribute, GISharp.Lib.Gio.FileAttributeType type, System.IntPtr valueP, GISharp.Lib.Gio.FileQueryInfoFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckSetAttributeArgs(file, attribute, type, valueP, flags, cancellable);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var attribute_ = (byte*)attribute.UnsafeHandle;
            var type_ = (GISharp.Lib.Gio.FileAttributeType)type;
            var valueP_ = (System.IntPtr)valueP;
            var flags_ = (GISharp.Lib.Gio.FileQueryInfoFlags)flags;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            g_file_set_attribute(file_, attribute_, type_, valueP_, flags_, cancellable_, &error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Runtime.GErrorException(error);
            }
        }

        /// <summary>
        /// Sets @attribute of type %G_FILE_ATTRIBUTE_TYPE_BYTE_STRING to @value.
        /// If @attribute is of a different type, this operation will fail,
        /// returning %FALSE.
        /// </summary>
        /// <remarks>
        /// <para>
        /// If @cancellable is not %NULL, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="attribute">
        /// a string containing the attribute's name
        /// </param>
        /// <param name="value">
        /// a string containing the attribute's new value
        /// </param>
        /// <param name="flags">
        /// a #GFileQueryInfoFlags
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object,
        ///     %NULL to ignore
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// %TRUE if the @attribute was successfully set to @value
        ///     in the @file, %FALSE otherwise.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        private static extern GISharp.Runtime.Boolean g_file_set_attribute_byte_string(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="utf8" type="const char*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* attribute,
        /* <type name="utf8" type="const char*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* value,
        /* <type name="FileQueryInfoFlags" type="GFileQueryInfoFlags" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.FileQueryInfoFlags flags,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        static partial void CheckSetAttributeByteStringArgs(this GISharp.Lib.Gio.IFile file, GISharp.Lib.GLib.UnownedUtf8 attribute, GISharp.Lib.GLib.UnownedUtf8 value, GISharp.Lib.Gio.FileQueryInfoFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.SetAttributeByteString(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.Gio.FileQueryInfoFlags,GISharp.Lib.Gio.Cancellable?)']/*" />
        public static void SetAttributeByteString(this GISharp.Lib.Gio.IFile file, GISharp.Lib.GLib.UnownedUtf8 attribute, GISharp.Lib.GLib.UnownedUtf8 value, GISharp.Lib.Gio.FileQueryInfoFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckSetAttributeByteStringArgs(file, attribute, value, flags, cancellable);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var attribute_ = (byte*)attribute.UnsafeHandle;
            var value_ = (byte*)value.UnsafeHandle;
            var flags_ = (GISharp.Lib.Gio.FileQueryInfoFlags)flags;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            g_file_set_attribute_byte_string(file_, attribute_, value_, flags_, cancellable_, &error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Runtime.GErrorException(error);
            }
        }

        /// <summary>
        /// Sets @attribute of type %G_FILE_ATTRIBUTE_TYPE_INT32 to @value.
        /// If @attribute is of a different type, this operation will fail.
        /// </summary>
        /// <remarks>
        /// <para>
        /// If @cancellable is not %NULL, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="attribute">
        /// a string containing the attribute's name
        /// </param>
        /// <param name="value">
        /// a #gint32 containing the attribute's new value
        /// </param>
        /// <param name="flags">
        /// a #GFileQueryInfoFlags
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object,
        ///     %NULL to ignore
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// %TRUE if the @attribute was successfully set to @value
        ///     in the @file, %FALSE otherwise.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        private static extern GISharp.Runtime.Boolean g_file_set_attribute_int32(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="utf8" type="const char*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* attribute,
        /* <type name="gint32" type="gint32" /> */
        /* transfer-ownership:none direction:in */
        int value,
        /* <type name="FileQueryInfoFlags" type="GFileQueryInfoFlags" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.FileQueryInfoFlags flags,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        static partial void CheckSetAttributeInt32Args(this GISharp.Lib.Gio.IFile file, GISharp.Lib.GLib.UnownedUtf8 attribute, int value, GISharp.Lib.Gio.FileQueryInfoFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.SetAttributeInt32(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.UnownedUtf8,int,GISharp.Lib.Gio.FileQueryInfoFlags,GISharp.Lib.Gio.Cancellable?)']/*" />
        public static void SetAttributeInt32(this GISharp.Lib.Gio.IFile file, GISharp.Lib.GLib.UnownedUtf8 attribute, int value, GISharp.Lib.Gio.FileQueryInfoFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckSetAttributeInt32Args(file, attribute, value, flags, cancellable);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var attribute_ = (byte*)attribute.UnsafeHandle;
            var value_ = (int)value;
            var flags_ = (GISharp.Lib.Gio.FileQueryInfoFlags)flags;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            g_file_set_attribute_int32(file_, attribute_, value_, flags_, cancellable_, &error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Runtime.GErrorException(error);
            }
        }

        /// <summary>
        /// Sets @attribute of type %G_FILE_ATTRIBUTE_TYPE_INT64 to @value.
        /// If @attribute is of a different type, this operation will fail.
        /// </summary>
        /// <remarks>
        /// <para>
        /// If @cancellable is not %NULL, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="attribute">
        /// a string containing the attribute's name
        /// </param>
        /// <param name="value">
        /// a #guint64 containing the attribute's new value
        /// </param>
        /// <param name="flags">
        /// a #GFileQueryInfoFlags
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object,
        ///     %NULL to ignore
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// %TRUE if the @attribute was successfully set, %FALSE otherwise.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        private static extern GISharp.Runtime.Boolean g_file_set_attribute_int64(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="utf8" type="const char*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* attribute,
        /* <type name="gint64" type="gint64" /> */
        /* transfer-ownership:none direction:in */
        long value,
        /* <type name="FileQueryInfoFlags" type="GFileQueryInfoFlags" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.FileQueryInfoFlags flags,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        static partial void CheckSetAttributeInt64Args(this GISharp.Lib.Gio.IFile file, GISharp.Lib.GLib.UnownedUtf8 attribute, long value, GISharp.Lib.Gio.FileQueryInfoFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.SetAttributeInt64(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.UnownedUtf8,long,GISharp.Lib.Gio.FileQueryInfoFlags,GISharp.Lib.Gio.Cancellable?)']/*" />
        public static void SetAttributeInt64(this GISharp.Lib.Gio.IFile file, GISharp.Lib.GLib.UnownedUtf8 attribute, long value, GISharp.Lib.Gio.FileQueryInfoFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckSetAttributeInt64Args(file, attribute, value, flags, cancellable);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var attribute_ = (byte*)attribute.UnsafeHandle;
            var value_ = (long)value;
            var flags_ = (GISharp.Lib.Gio.FileQueryInfoFlags)flags;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            g_file_set_attribute_int64(file_, attribute_, value_, flags_, cancellable_, &error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Runtime.GErrorException(error);
            }
        }

        /// <summary>
        /// Sets @attribute of type %G_FILE_ATTRIBUTE_TYPE_STRING to @value.
        /// If @attribute is of a different type, this operation will fail.
        /// </summary>
        /// <remarks>
        /// <para>
        /// If @cancellable is not %NULL, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="attribute">
        /// a string containing the attribute's name
        /// </param>
        /// <param name="value">
        /// a string containing the attribute's value
        /// </param>
        /// <param name="flags">
        /// #GFileQueryInfoFlags
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object,
        ///     %NULL to ignore
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// %TRUE if the @attribute was successfully set, %FALSE otherwise.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        private static extern GISharp.Runtime.Boolean g_file_set_attribute_string(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="utf8" type="const char*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* attribute,
        /* <type name="utf8" type="const char*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* value,
        /* <type name="FileQueryInfoFlags" type="GFileQueryInfoFlags" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.FileQueryInfoFlags flags,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        static partial void CheckSetAttributeStringArgs(this GISharp.Lib.Gio.IFile file, GISharp.Lib.GLib.UnownedUtf8 attribute, GISharp.Lib.GLib.UnownedUtf8 value, GISharp.Lib.Gio.FileQueryInfoFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.SetAttributeString(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.Gio.FileQueryInfoFlags,GISharp.Lib.Gio.Cancellable?)']/*" />
        public static void SetAttributeString(this GISharp.Lib.Gio.IFile file, GISharp.Lib.GLib.UnownedUtf8 attribute, GISharp.Lib.GLib.UnownedUtf8 value, GISharp.Lib.Gio.FileQueryInfoFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckSetAttributeStringArgs(file, attribute, value, flags, cancellable);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var attribute_ = (byte*)attribute.UnsafeHandle;
            var value_ = (byte*)value.UnsafeHandle;
            var flags_ = (GISharp.Lib.Gio.FileQueryInfoFlags)flags;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            g_file_set_attribute_string(file_, attribute_, value_, flags_, cancellable_, &error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Runtime.GErrorException(error);
            }
        }

        /// <summary>
        /// Sets @attribute of type %G_FILE_ATTRIBUTE_TYPE_UINT32 to @value.
        /// If @attribute is of a different type, this operation will fail.
        /// </summary>
        /// <remarks>
        /// <para>
        /// If @cancellable is not %NULL, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="attribute">
        /// a string containing the attribute's name
        /// </param>
        /// <param name="value">
        /// a #guint32 containing the attribute's new value
        /// </param>
        /// <param name="flags">
        /// a #GFileQueryInfoFlags
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object,
        ///     %NULL to ignore
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// %TRUE if the @attribute was successfully set to @value
        ///     in the @file, %FALSE otherwise.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        private static extern GISharp.Runtime.Boolean g_file_set_attribute_uint32(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="utf8" type="const char*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* attribute,
        /* <type name="guint32" type="guint32" /> */
        /* transfer-ownership:none direction:in */
        uint value,
        /* <type name="FileQueryInfoFlags" type="GFileQueryInfoFlags" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.FileQueryInfoFlags flags,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        static partial void CheckSetAttributeUint32Args(this GISharp.Lib.Gio.IFile file, GISharp.Lib.GLib.UnownedUtf8 attribute, uint value, GISharp.Lib.Gio.FileQueryInfoFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.SetAttributeUint32(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.UnownedUtf8,uint,GISharp.Lib.Gio.FileQueryInfoFlags,GISharp.Lib.Gio.Cancellable?)']/*" />
        public static void SetAttributeUint32(this GISharp.Lib.Gio.IFile file, GISharp.Lib.GLib.UnownedUtf8 attribute, uint value, GISharp.Lib.Gio.FileQueryInfoFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckSetAttributeUint32Args(file, attribute, value, flags, cancellable);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var attribute_ = (byte*)attribute.UnsafeHandle;
            var value_ = (uint)value;
            var flags_ = (GISharp.Lib.Gio.FileQueryInfoFlags)flags;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            g_file_set_attribute_uint32(file_, attribute_, value_, flags_, cancellable_, &error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Runtime.GErrorException(error);
            }
        }

        /// <summary>
        /// Sets @attribute of type %G_FILE_ATTRIBUTE_TYPE_UINT64 to @value.
        /// If @attribute is of a different type, this operation will fail.
        /// </summary>
        /// <remarks>
        /// <para>
        /// If @cancellable is not %NULL, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="attribute">
        /// a string containing the attribute's name
        /// </param>
        /// <param name="value">
        /// a #guint64 containing the attribute's new value
        /// </param>
        /// <param name="flags">
        /// a #GFileQueryInfoFlags
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object,
        ///     %NULL to ignore
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// %TRUE if the @attribute was successfully set to @value
        ///     in the @file, %FALSE otherwise.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        private static extern GISharp.Runtime.Boolean g_file_set_attribute_uint64(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="utf8" type="const char*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* attribute,
        /* <type name="guint64" type="guint64" /> */
        /* transfer-ownership:none direction:in */
        ulong value,
        /* <type name="FileQueryInfoFlags" type="GFileQueryInfoFlags" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.FileQueryInfoFlags flags,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        static partial void CheckSetAttributeUint64Args(this GISharp.Lib.Gio.IFile file, GISharp.Lib.GLib.UnownedUtf8 attribute, ulong value, GISharp.Lib.Gio.FileQueryInfoFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.SetAttributeUint64(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.UnownedUtf8,ulong,GISharp.Lib.Gio.FileQueryInfoFlags,GISharp.Lib.Gio.Cancellable?)']/*" />
        public static void SetAttributeUint64(this GISharp.Lib.Gio.IFile file, GISharp.Lib.GLib.UnownedUtf8 attribute, ulong value, GISharp.Lib.Gio.FileQueryInfoFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckSetAttributeUint64Args(file, attribute, value, flags, cancellable);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var attribute_ = (byte*)attribute.UnsafeHandle;
            var value_ = (ulong)value;
            var flags_ = (GISharp.Lib.Gio.FileQueryInfoFlags)flags;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            g_file_set_attribute_uint64(file_, attribute_, value_, flags_, cancellable_, &error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Runtime.GErrorException(error);
            }
        }

        /// <summary>
        /// Asynchronously sets the attributes of @file with @info.
        /// </summary>
        /// <remarks>
        /// <para>
        /// For more details, see g_file_set_attributes_from_info(),
        /// which is the synchronous version of this call.
        /// </para>
        /// <para>
        /// When the operation is finished, @callback will be called.
        /// You can then call g_file_set_attributes_finish() to get
        /// the result of the operation.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="info">
        /// a #GFileInfo
        /// </param>
        /// <param name="flags">
        /// a #GFileQueryInfoFlags
        /// </param>
        /// <param name="ioPriority">
        /// the [I/O priority][io-priority] of the request
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object,
        ///     %NULL to ignore
        /// </param>
        /// <param name="callback">
        /// a #GAsyncReadyCallback
        /// </param>
        /// <param name="userData">
        /// a #gpointer
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Threading.Tasks.Task">
*   <type name="FileInfo" type="GFileInfo**" is-pointer="1" />
* </type> */
        /* transfer-ownership:none direction:in */
        private static extern void g_file_set_attributes_async(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="FileInfo" type="GFileInfo*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.FileInfo.UnmanagedStruct* info,
        /* <type name="FileQueryInfoFlags" type="GFileQueryInfoFlags" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.FileQueryInfoFlags flags,
        /* <type name="gint" type="int" /> */
        /* transfer-ownership:none direction:in */
        int ioPriority,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:5 direction:in */
        delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback,
        /* <type name="gpointer" type="gpointer" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr userData);
        static partial void CheckSetAttributesAsyncArgs(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.FileInfo info, GISharp.Lib.Gio.FileQueryInfoFlags flags, int ioPriority = GISharp.Lib.GLib.Priority.Default, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.SetAttributesAsync(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.FileInfo,GISharp.Lib.Gio.FileQueryInfoFlags,int,GISharp.Lib.Gio.Cancellable?)']/*" />
        public static System.Threading.Tasks.Task<GISharp.Lib.Gio.FileInfo> SetAttributesAsync(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.FileInfo info, GISharp.Lib.Gio.FileQueryInfoFlags flags, int ioPriority = GISharp.Lib.GLib.Priority.Default, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckSetAttributesAsyncArgs(file, info, flags, ioPriority, cancellable);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var info_ = (GISharp.Lib.Gio.FileInfo.UnmanagedStruct*)info.UnsafeHandle;
            var flags_ = (GISharp.Lib.Gio.FileQueryInfoFlags)flags;
            var ioPriority_ = (int)ioPriority;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var completionSource = new System.Threading.Tasks.TaskCompletionSource<GISharp.Lib.Gio.FileInfo>();
            var callback_ = (delegate* unmanaged[Cdecl] <GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void>)&SetAttributesFinish;
            var userData_ = (System.IntPtr)System.Runtime.InteropServices.GCHandle.Alloc(completionSource);
            g_file_set_attributes_async(file_, info_, flags_, ioPriority_, cancellable_, callback_, userData_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            return completionSource.Task;
        }

        /// <summary>
        /// Finishes setting an attribute started in g_file_set_attributes_async().
        /// </summary>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="result">
        /// a #GAsyncResult
        /// </param>
        /// <param name="info">
        /// a #GFileInfo
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// %TRUE if the attributes were set correctly, %FALSE otherwise.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        private static extern GISharp.Runtime.Boolean g_file_set_attributes_finish(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="AsyncResult" type="GAsyncResult*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result,
        /* <type name="FileInfo" type="GFileInfo**" is-pointer="1" /> */
        /* direction:out caller-allocates:0 transfer-ownership:full */
        GISharp.Lib.Gio.FileInfo.UnmanagedStruct** info,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        [System.Runtime.InteropServices.UnmanagedCallersOnlyAttribute(CallConvs = new[] { typeof(System.Runtime.CompilerServices.CallConvCdecl) })]
        private static void SetAttributesFinish(GISharp.Lib.GObject.Object.UnmanagedStruct* sourceObject_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result_, System.IntPtr userData_)
        {
            try
            {
                var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)sourceObject_;
                var userData = (System.Runtime.InteropServices.GCHandle)userData_;
                var completionSource = (System.Threading.Tasks.TaskCompletionSource<GISharp.Lib.Gio.FileInfo>)userData.Target!;
                userData.Free();
                GISharp.Lib.Gio.FileInfo.UnmanagedStruct* info_;
                var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
                g_file_set_attributes_finish(file_, result_, &info_, &error_);
                if (error_ is not null)
                {
                    var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                    completionSource.SetException(new GISharp.Runtime.GErrorException(error));
                    return;
                }
                var info = GISharp.Lib.Gio.FileInfo.GetInstance<GISharp.Lib.Gio.FileInfo>((System.IntPtr)info_, GISharp.Runtime.Transfer.Full)!;
                completionSource.SetResult((info));
            }
            catch (System.Exception ex)
            {
                GISharp.Runtime.GMarshal.PushUnhandledException(ex);
            }
        }

        /// <summary>
        /// Tries to set all attributes in the #GFileInfo on the target
        /// values, not stopping on the first error.
        /// </summary>
        /// <remarks>
        /// <para>
        /// If there is any error during this operation then @error will
        /// be set to the first error. Error on particular fields are flagged
        /// by setting the "status" field in the attribute value to
        /// %G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING, which means you can
        /// also detect further errors.
        /// </para>
        /// <para>
        /// If @cancellable is not %NULL, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="info">
        /// a #GFileInfo
        /// </param>
        /// <param name="flags">
        /// #GFileQueryInfoFlags
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object,
        ///     %NULL to ignore
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// %FALSE if there was any error, %TRUE otherwise.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        private static extern GISharp.Runtime.Boolean g_file_set_attributes_from_info(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="FileInfo" type="GFileInfo*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.FileInfo.UnmanagedStruct* info,
        /* <type name="FileQueryInfoFlags" type="GFileQueryInfoFlags" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.FileQueryInfoFlags flags,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        static partial void CheckSetAttributesFromInfoArgs(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.FileInfo info, GISharp.Lib.Gio.FileQueryInfoFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.SetAttributesFromInfo(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.FileInfo,GISharp.Lib.Gio.FileQueryInfoFlags,GISharp.Lib.Gio.Cancellable?)']/*" />
        public static void SetAttributesFromInfo(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.FileInfo info, GISharp.Lib.Gio.FileQueryInfoFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckSetAttributesFromInfoArgs(file, info, flags, cancellable);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var info_ = (GISharp.Lib.Gio.FileInfo.UnmanagedStruct*)info.UnsafeHandle;
            var flags_ = (GISharp.Lib.Gio.FileQueryInfoFlags)flags;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            g_file_set_attributes_from_info(file_, info_, flags_, cancellable_, &error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Runtime.GErrorException(error);
            }
        }

        /// <summary>
        /// Renames @file to the specified display name.
        /// </summary>
        /// <remarks>
        /// <para>
        /// The display name is converted from UTF-8 to the correct encoding
        /// for the target filesystem if possible and the @file is renamed to this.
        /// </para>
        /// <para>
        /// If you want to implement a rename operation in the user interface the
        /// edit name (#G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME) should be used as the
        /// initial value in the rename widget, and then the result after editing
        /// should be passed to g_file_set_display_name().
        /// </para>
        /// <para>
        /// On success the resulting converted filename is returned.
        /// </para>
        /// <para>
        /// If @cancellable is not %NULL, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="displayName">
        /// a string
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object,
        ///     %NULL to ignore
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// a #GFile specifying what @file was renamed to,
        ///     or %NULL if there was an error.
        ///     Free the returned object with g_object_unref().
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.Gio.File.UnmanagedStruct* g_file_set_display_name(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="utf8" type="const char*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* displayName,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        static partial void CheckSetDisplayNameArgs(this GISharp.Lib.Gio.IFile file, GISharp.Lib.GLib.UnownedUtf8 displayName, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.SetDisplayName(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.Gio.Cancellable?)']/*" />
        public static GISharp.Lib.Gio.IFile SetDisplayName(this GISharp.Lib.Gio.IFile file, GISharp.Lib.GLib.UnownedUtf8 displayName, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckSetDisplayNameArgs(file, displayName, cancellable);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var displayName_ = (byte*)displayName.UnsafeHandle;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            var ret_ = g_file_set_display_name(file_,displayName_,cancellable_,&error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Runtime.GErrorException(error);
            }

            var ret = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Asynchronously sets the display name for a given #GFile.
        /// </summary>
        /// <remarks>
        /// <para>
        /// For more details, see g_file_set_display_name() which is
        /// the synchronous version of this call.
        /// </para>
        /// <para>
        /// When the operation is finished, @callback will be called.
        /// You can then call g_file_set_display_name_finish() to get
        /// the result of the operation.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="displayName">
        /// a string
        /// </param>
        /// <param name="ioPriority">
        /// the [I/O priority][io-priority] of the request
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object,
        ///     %NULL to ignore
        /// </param>
        /// <param name="callback">
        /// a #GAsyncReadyCallback to call
        ///     when the request is satisfied
        /// </param>
        /// <param name="userData">
        /// the data to pass to callback function
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Threading.Tasks.Task">
*   <type name="File" type="GFile*" is-pointer="1" />
* </type> */
        /* transfer-ownership:none direction:in */
        private static extern void g_file_set_display_name_async(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="utf8" type="const char*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* displayName,
        /* <type name="gint" type="int" /> */
        /* transfer-ownership:none direction:in */
        int ioPriority,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:4 direction:in */
        delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback,
        /* <type name="gpointer" type="gpointer" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr userData);
        static partial void CheckSetDisplayNameAsyncArgs(this GISharp.Lib.Gio.IFile file, GISharp.Lib.GLib.UnownedUtf8 displayName, int ioPriority = GISharp.Lib.GLib.Priority.Default, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.SetDisplayNameAsync(GISharp.Lib.Gio.IFile,GISharp.Lib.GLib.UnownedUtf8,int,GISharp.Lib.Gio.Cancellable?)']/*" />
        public static System.Threading.Tasks.Task<GISharp.Lib.Gio.IFile> SetDisplayNameAsync(this GISharp.Lib.Gio.IFile file, GISharp.Lib.GLib.UnownedUtf8 displayName, int ioPriority = GISharp.Lib.GLib.Priority.Default, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckSetDisplayNameAsyncArgs(file, displayName, ioPriority, cancellable);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var displayName_ = (byte*)displayName.UnsafeHandle;
            var ioPriority_ = (int)ioPriority;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var completionSource = new System.Threading.Tasks.TaskCompletionSource<GISharp.Lib.Gio.IFile>();
            var callback_ = (delegate* unmanaged[Cdecl] <GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void>)&SetDisplayNameFinish;
            var userData_ = (System.IntPtr)System.Runtime.InteropServices.GCHandle.Alloc(completionSource);
            g_file_set_display_name_async(file_, displayName_, ioPriority_, cancellable_, callback_, userData_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            return completionSource.Task;
        }

        /// <summary>
        /// Finishes setting a display name started with
        /// g_file_set_display_name_async().
        /// </summary>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="res">
        /// a #GAsyncResult
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// a #GFile or %NULL on error.
        ///     Free the returned object with g_object_unref().
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.Gio.File.UnmanagedStruct* g_file_set_display_name_finish(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="AsyncResult" type="GAsyncResult*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        [System.Runtime.InteropServices.UnmanagedCallersOnlyAttribute(CallConvs = new[] { typeof(System.Runtime.CompilerServices.CallConvCdecl) })]
        private static void SetDisplayNameFinish(GISharp.Lib.GObject.Object.UnmanagedStruct* sourceObject_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res_, System.IntPtr userData_)
        {
            try
            {
                var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)sourceObject_;
                var userData = (System.Runtime.InteropServices.GCHandle)userData_;
                var completionSource = (System.Threading.Tasks.TaskCompletionSource<GISharp.Lib.Gio.IFile>)userData.Target!;
                userData.Free();
                var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
                var ret_ = g_file_set_display_name_finish(file_,res_,&error_);
                if (error_ is not null)
                {
                    var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                    completionSource.SetException(new GISharp.Runtime.GErrorException(error));
                    return;
                }
                var ret = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
                completionSource.SetResult((ret));
            }
            catch (System.Exception ex)
            {
                GISharp.Runtime.GMarshal.PushUnhandledException(ex);
            }
        }

        /// <summary>
        /// Finishes a start operation. See g_file_start_mountable() for details.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Finish an asynchronous start operation that was started
        /// with g_file_start_mountable().
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="result">
        /// a #GAsyncResult
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// %TRUE if the operation finished successfully. %FALSE
        /// otherwise.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.22")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        private static extern GISharp.Runtime.Boolean g_file_start_mountable_finish(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="AsyncResult" type="GAsyncResult*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        static partial void CheckStartMountableFinishArgs(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.IAsyncResult result);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.StartMountableFinish(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.IAsyncResult)']/*" />
        [GISharp.Runtime.SinceAttribute("2.22")]
        public static void StartMountableFinish(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.IAsyncResult result)
        {
            CheckStartMountableFinishArgs(file, result);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var result_ = (GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*)result.UnsafeHandle;
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            g_file_start_mountable_finish(file_, result_, &error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Runtime.GErrorException(error);
            }
        }

        /// <summary>
        /// Finishes a stop operation, see g_file_stop_mountable() for details.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Finish an asynchronous stop operation that was started
        /// with g_file_stop_mountable().
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="result">
        /// a #GAsyncResult
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// %TRUE if the operation finished successfully.
        ///     %FALSE otherwise.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.22")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        private static extern GISharp.Runtime.Boolean g_file_stop_mountable_finish(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="AsyncResult" type="GAsyncResult*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        static partial void CheckStopMountableFinishArgs(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.IAsyncResult result);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.StopMountableFinish(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.IAsyncResult)']/*" />
        [GISharp.Runtime.SinceAttribute("2.22")]
        public static void StopMountableFinish(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.IAsyncResult result)
        {
            CheckStopMountableFinishArgs(file, result);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var result_ = (GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*)result.UnsafeHandle;
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            g_file_stop_mountable_finish(file_, result_, &error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Runtime.GErrorException(error);
            }
        }

        /// <summary>
        /// Checks if @file supports
        /// [thread-default contexts][g-main-context-push-thread-default-context].
        /// If this returns %FALSE, you cannot perform asynchronous operations on
        /// @file in a thread that has a thread-default context.
        /// </summary>
        /// <param name="file">
        /// a #GFile
        /// </param>
        /// <returns>
        /// Whether or not @file supports thread-default contexts.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.22")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_file_supports_thread_contexts(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file);
        static partial void CheckSupportsThreadContextsArgs(this GISharp.Lib.Gio.IFile file);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.SupportsThreadContexts(GISharp.Lib.Gio.IFile)']/*" />
        [GISharp.Runtime.SinceAttribute("2.22")]
        public static bool SupportsThreadContexts(this GISharp.Lib.Gio.IFile file)
        {
            CheckSupportsThreadContextsArgs(file);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var ret_ = g_file_supports_thread_contexts(file_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Sends @file to the "Trashcan", if possible. This is similar to
        /// deleting it, but the user can recover it before emptying the trashcan.
        /// Not all file systems support trashing, so this call can return the
        /// %G_IO_ERROR_NOT_SUPPORTED error. Since GLib 2.66, the `x-gvfs-notrash` unix
        /// mount option can be used to disable g_file_trash() support for certain
        /// mounts, the %G_IO_ERROR_NOT_SUPPORTED error will be returned in that case.
        /// </summary>
        /// <remarks>
        /// <para>
        /// If @cancellable is not %NULL, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// #GFile to send to trash
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object,
        ///     %NULL to ignore
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// %TRUE on successful trash, %FALSE otherwise.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        private static extern GISharp.Runtime.Boolean g_file_trash(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        static partial void CheckTrashArgs(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.Trash(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.Cancellable?)']/*" />
        public static void Trash(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckTrashArgs(file, cancellable);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            g_file_trash(file_, cancellable_, &error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Runtime.GErrorException(error);
            }
        }

        /// <summary>
        /// Asynchronously sends @file to the Trash location, if possible.
        /// </summary>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="ioPriority">
        /// the [I/O priority][io-priority] of the request
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object,
        ///     %NULL to ignore
        /// </param>
        /// <param name="callback">
        /// a #GAsyncReadyCallback to call
        ///     when the request is satisfied
        /// </param>
        /// <param name="userData">
        /// the data to pass to callback function
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.38")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Threading.Tasks.Task" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_file_trash_async(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="gint" type="int" /> */
        /* transfer-ownership:none direction:in */
        int ioPriority,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:3 direction:in */
        delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback,
        /* <type name="gpointer" type="gpointer" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr userData);
        static partial void CheckTrashAsyncArgs(this GISharp.Lib.Gio.IFile file, int ioPriority = GISharp.Lib.GLib.Priority.Default, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.TrashAsync(GISharp.Lib.Gio.IFile,int,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.SinceAttribute("2.38")]
        public static System.Threading.Tasks.Task TrashAsync(this GISharp.Lib.Gio.IFile file, int ioPriority = GISharp.Lib.GLib.Priority.Default, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckTrashAsyncArgs(file, ioPriority, cancellable);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var ioPriority_ = (int)ioPriority;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var completionSource = new System.Threading.Tasks.TaskCompletionSource<GISharp.Runtime.Void>();
            var callback_ = (delegate* unmanaged[Cdecl] <GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void>)&TrashFinish;
            var userData_ = (System.IntPtr)System.Runtime.InteropServices.GCHandle.Alloc(completionSource);
            g_file_trash_async(file_, ioPriority_, cancellable_, callback_, userData_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            return completionSource.Task;
        }

        /// <summary>
        /// Finishes an asynchronous file trashing operation, started with
        /// g_file_trash_async().
        /// </summary>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="result">
        /// a #GAsyncResult
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// %TRUE on successful trash, %FALSE otherwise.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.38")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        private static extern GISharp.Runtime.Boolean g_file_trash_finish(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="AsyncResult" type="GAsyncResult*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        [System.Runtime.InteropServices.UnmanagedCallersOnlyAttribute(CallConvs = new[] { typeof(System.Runtime.CompilerServices.CallConvCdecl) })]
        private static void TrashFinish(GISharp.Lib.GObject.Object.UnmanagedStruct* sourceObject_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result_, System.IntPtr userData_)
        {
            try
            {
                var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)sourceObject_;
                var userData = (System.Runtime.InteropServices.GCHandle)userData_;
                var completionSource = (System.Threading.Tasks.TaskCompletionSource<GISharp.Runtime.Void>)userData.Target!;
                userData.Free();
                var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
                g_file_trash_finish(file_, result_, &error_);
                if (error_ is not null)
                {
                    var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                    completionSource.SetException(new GISharp.Runtime.GErrorException(error));
                    return;
                }
                completionSource.SetResult(GISharp.Runtime.Void.Default);
            }
            catch (System.Exception ex)
            {
                GISharp.Runtime.GMarshal.PushUnhandledException(ex);
            }
        }

        /// <summary>
        /// Finishes an unmount operation, see g_file_unmount_mountable() for details.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Finish an asynchronous unmount operation that was started
        /// with g_file_unmount_mountable().
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="result">
        /// a #GAsyncResult
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// %TRUE if the operation finished successfully.
        ///     %FALSE otherwise.
        /// </returns>
        [System.ObsoleteAttribute("Use g_file_unmount_mountable_with_operation_finish()\n    instead.")]
        [GISharp.Runtime.DeprecatedSinceAttribute("2.22")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        private static extern GISharp.Runtime.Boolean g_file_unmount_mountable_finish(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="AsyncResult" type="GAsyncResult*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        static partial void CheckUnmountMountableFinishArgs(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.IAsyncResult result);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.UnmountMountableFinish(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.IAsyncResult)']/*" />
        [System.ObsoleteAttribute("Use g_file_unmount_mountable_with_operation_finish()\n    instead.")]
        [GISharp.Runtime.DeprecatedSinceAttribute("2.22")]
        public static void UnmountMountableFinish(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.IAsyncResult result)
        {
            CheckUnmountMountableFinishArgs(file, result);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var result_ = (GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*)result.UnsafeHandle;
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            g_file_unmount_mountable_finish(file_, result_, &error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Runtime.GErrorException(error);
            }
        }

        /// <summary>
        /// Finishes an unmount operation,
        /// see g_file_unmount_mountable_with_operation() for details.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Finish an asynchronous unmount operation that was started
        /// with g_file_unmount_mountable_with_operation().
        /// </para>
        /// </remarks>
        /// <param name="file">
        /// input #GFile
        /// </param>
        /// <param name="result">
        /// a #GAsyncResult
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// %TRUE if the operation finished successfully.
        ///     %FALSE otherwise.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.22")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        private static extern GISharp.Runtime.Boolean g_file_unmount_mountable_with_operation_finish(
        /* <type name="File" type="GFile*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.File.UnmanagedStruct* file,
        /* <type name="AsyncResult" type="GAsyncResult*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        static partial void CheckUnmountMountableWithOperationFinishArgs(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.IAsyncResult result);

        /// <include file="File.xmldoc" path="declaration/member[@name='File.UnmountMountableWithOperationFinish(GISharp.Lib.Gio.IFile,GISharp.Lib.Gio.IAsyncResult)']/*" />
        [GISharp.Runtime.SinceAttribute("2.22")]
        public static void UnmountMountableWithOperationFinish(this GISharp.Lib.Gio.IFile file, GISharp.Lib.Gio.IAsyncResult result)
        {
            CheckUnmountMountableWithOperationFinishArgs(file, result);
            var file_ = (GISharp.Lib.Gio.File.UnmanagedStruct*)file.UnsafeHandle;
            var result_ = (GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*)result.UnsafeHandle;
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            g_file_unmount_mountable_with_operation_finish(file_, result_, &error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Runtime.GErrorException(error);
            }
        }
    }
}