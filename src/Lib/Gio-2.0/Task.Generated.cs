// SPDX-License-Identifier: MIT
// ATTENTION: This file is automatically generated. Do not edit manually.
#nullable enable
namespace GISharp.Lib.Gio
{
    /// <include file="Task.xmldoc" path="declaration/member[@name='Task']/*" />
    [GISharp.Runtime.GTypeAttribute("GTask", IsProxyForUnmanagedType = true)]
    [GISharp.Runtime.GTypeStructAttribute(typeof(TaskClass))]
    public unsafe partial class Task : GISharp.Lib.GObject.Object, GISharp.Lib.Gio.IAsyncResult
    {
        private static readonly GISharp.Runtime.GType _GType = g_task_get_type();

        /// <summary>
        /// The unmanaged data structure.
        /// </summary>
        public new struct UnmanagedStruct
        {
        }

        /// <include file="Task.xmldoc" path="declaration/member[@name='Task.Completed_']/*" />
        [GISharp.Runtime.SinceAttribute("2.44")]
        [GISharp.Runtime.GPropertyAttribute("completed")]
        public bool Completed_ { get => (bool)GetProperty("completed")!; }

        /// <include file="Task.xmldoc" path="declaration/member[@name='Task.Cancellable']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        public GISharp.Lib.Gio.Cancellable Cancellable { get => GetCancellable(); }

        /// <include file="Task.xmldoc" path="declaration/member[@name='Task.CheckCancellable']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        public bool CheckCancellable { get => GetCheckCancellable(); set => SetCheckCancellable(value); }

        /// <include file="Task.xmldoc" path="declaration/member[@name='Task.Completed']/*" />
        [GISharp.Runtime.SinceAttribute("2.44")]
        public bool Completed { get => GetCompleted(); }

        /// <include file="Task.xmldoc" path="declaration/member[@name='Task.Context']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        public GISharp.Lib.GLib.MainContext Context { get => GetContext(); }

        /// <include file="Task.xmldoc" path="declaration/member[@name='Task.Name']/*" />
        [GISharp.Runtime.SinceAttribute("2.60")]
        public GISharp.Runtime.NullableUnownedUtf8 Name { get => GetName(); set => SetName(value); }

        /// <include file="Task.xmldoc" path="declaration/member[@name='Task.Priority']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        public int Priority { get => GetPriority(); set => SetPriority(value); }

        /// <include file="Task.xmldoc" path="declaration/member[@name='Task.ReturnOnCancel']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        public bool ReturnOnCancel { get => GetReturnOnCancel(); }

        /// <include file="Task.xmldoc" path="declaration/member[@name='Task.SourceObject']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        public GISharp.Lib.GObject.Object? SourceObject { get => GetSourceObject(); }

        /// <include file="Task.xmldoc" path="declaration/member[@name='Task.SourceTag']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        public System.IntPtr SourceTag { get => GetSourceTag(); set => SetSourceTag(value); }

        /// <include file="Task.xmldoc" path="declaration/member[@name='Task.TaskData']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        public System.IntPtr TaskData { get => GetTaskData(); }

        /// <summary>
        /// For internal runtime use only.
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        public Task(System.IntPtr handle, GISharp.Runtime.Transfer ownership) : base(handle, ownership)
        {
        }

        /// <summary>
        /// Creates a #GTask acting on @source_object, which will eventually be
        /// used to invoke @callback in the current
        /// [thread-default main context][g-main-context-push-thread-default].
        /// </summary>
        /// <remarks>
        /// <para>
        /// Call this in the "start" method of your asynchronous method, and
        /// pass the #GTask around throughout the asynchronous operation. You
        /// can use g_task_set_task_data() to attach task-specific data to the
        /// object, which you can retrieve later via g_task_get_task_data().
        /// </para>
        /// <para>
        /// By default, if @cancellable is cancelled, then the return value of
        /// the task will always be %G_IO_ERROR_CANCELLED, even if the task had
        /// already completed before the cancellation. This allows for
        /// simplified handling in cases where cancellation may imply that
        /// other objects that the task depends on have been destroyed. If you
        /// do not want this behavior, you can use
        /// g_task_set_check_cancellable() to change it.
        /// </para>
        /// </remarks>
        /// <param name="sourceObject">
        /// the #GObject that owns
        ///   this task, or %NULL.
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object, %NULL to ignore.
        /// </param>
        /// <param name="callback">
        /// a #GAsyncReadyCallback.
        /// </param>
        /// <param name="callbackData">
        /// user data passed to @callback.
        /// </param>
        /// <returns>
        /// a #GTask.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Task" type="GTask*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.Gio.Task.UnmanagedStruct* g_task_new(
        /* <type name="GObject.Object" type="gpointer" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* sourceObject,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:3 direction:in */
        delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback,
        /* <type name="gpointer" type="gpointer" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr callbackData);
        static partial void CheckNewArgs(GISharp.Lib.GObject.Object? sourceObject, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        [GISharp.Runtime.SinceAttribute("2.36")]
        static GISharp.Lib.Gio.Task.UnmanagedStruct* New(GISharp.Lib.GObject.Object? sourceObject, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckNewArgs(sourceObject, callback, cancellable);
            var sourceObject_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)(sourceObject?.UnsafeHandle ?? System.IntPtr.Zero);
            var callback_ = callback is null ? default : (delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void>)&GISharp.Lib.Gio.AsyncReadyCallbackMarshal.Callback;
            var callbackHandle = callback is null ? default : System.Runtime.InteropServices.GCHandle.Alloc((callback, GISharp.Runtime.CallbackScope.Async));
            var callbackData_ = (System.IntPtr)callbackHandle;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var ret_ = g_task_new(sourceObject_,cancellable_,callback_,callbackData_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            return ret_;
        }

        /// <include file="Task.xmldoc" path="declaration/member[@name='Task.Task(GISharp.Lib.GObject.Object?,GISharp.Lib.Gio.AsyncReadyCallback?,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        public Task(GISharp.Lib.GObject.Object? sourceObject, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null) : this((System.IntPtr)New(sourceObject, callback, cancellable), GISharp.Runtime.Transfer.Full)
        {
        }

        /// <summary>
        /// Checks that @result is a #GTask, and that @source_object is its
        /// source object (or that @source_object is %NULL and @result has no
        /// source object). This can be used in g_return_if_fail() checks.
        /// </summary>
        /// <param name="result">
        /// A #GAsyncResult
        /// </param>
        /// <param name="sourceObject">
        /// the source object
        ///   expected to be associated with the task
        /// </param>
        /// <returns>
        /// %TRUE if @result and @source_object are valid, %FALSE
        /// if not
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_task_is_valid(
        /* <type name="AsyncResult" type="gpointer" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result,
        /* <type name="GObject.Object" type="gpointer" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* sourceObject);
        static partial void CheckIsValidArgs(GISharp.Lib.Gio.IAsyncResult result, GISharp.Lib.GObject.Object? sourceObject);

        /// <include file="Task.xmldoc" path="declaration/member[@name='Task.IsValid(GISharp.Lib.Gio.IAsyncResult,GISharp.Lib.GObject.Object?)']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        public static bool IsValid(GISharp.Lib.Gio.IAsyncResult result, GISharp.Lib.GObject.Object? sourceObject)
        {
            CheckIsValidArgs(result, sourceObject);
            var result_ = (GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*)result.UnsafeHandle;
            var sourceObject_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)(sourceObject?.UnsafeHandle ?? System.IntPtr.Zero);
            var ret_ = g_task_is_valid(result_,sourceObject_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Creates a #GTask and then immediately calls g_task_return_error()
        /// on it. Use this in the wrapper function of an asynchronous method
        /// when you want to avoid even calling the virtual method. You can
        /// then use g_async_result_is_tagged() in the finish method wrapper to
        /// check if the result there is tagged as having been created by the
        /// wrapper method, and deal with it appropriately if so.
        /// </summary>
        /// <remarks>
        /// <para>
        /// See also g_task_report_new_error().
        /// </para>
        /// </remarks>
        /// <param name="sourceObject">
        /// the #GObject that owns
        ///   this task, or %NULL.
        /// </param>
        /// <param name="callback">
        /// a #GAsyncReadyCallback.
        /// </param>
        /// <param name="callbackData">
        /// user data passed to @callback.
        /// </param>
        /// <param name="sourceTag">
        /// an opaque pointer indicating the source of this task
        /// </param>
        /// <param name="error">
        /// error to report
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_task_report_error(
        /* <type name="GObject.Object" type="gpointer" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* sourceObject,
        /* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:2 direction:in */
        delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback,
        /* <type name="gpointer" type="gpointer" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr callbackData,
        /* <type name="gpointer" type="gpointer" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr sourceTag,
        /* <type name="GLib.Error" type="GError*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        GISharp.Lib.GLib.Error.UnmanagedStruct* error);
        static partial void CheckReportErrorArgs(GISharp.Lib.GObject.Object? sourceObject, GISharp.Lib.Gio.AsyncReadyCallback? callback, System.IntPtr sourceTag, GISharp.Lib.GLib.Error error);

        /// <include file="Task.xmldoc" path="declaration/member[@name='Task.ReportError(GISharp.Lib.GObject.Object?,GISharp.Lib.Gio.AsyncReadyCallback?,System.IntPtr,GISharp.Lib.GLib.Error)']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        public static void ReportError(GISharp.Lib.GObject.Object? sourceObject, GISharp.Lib.Gio.AsyncReadyCallback? callback, System.IntPtr sourceTag, GISharp.Lib.GLib.Error error)
        {
            CheckReportErrorArgs(sourceObject, callback, sourceTag, error);
            var sourceObject_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)(sourceObject?.UnsafeHandle ?? System.IntPtr.Zero);
            var callback_ = callback is null ? default : (delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void>)&GISharp.Lib.Gio.AsyncReadyCallbackMarshal.Callback;
            var callbackHandle = callback is null ? default : System.Runtime.InteropServices.GCHandle.Alloc((callback, GISharp.Runtime.CallbackScope.Async));
            var callbackData_ = (System.IntPtr)callbackHandle;
            var sourceTag_ = (System.IntPtr)sourceTag;
            var error_ = (GISharp.Lib.GLib.Error.UnmanagedStruct*)error.Take();
            g_task_report_error(sourceObject_, callback_, callbackData_, sourceTag_, error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
        }

        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="GType" type="GType" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Runtime.GType g_task_get_type();

        /// <summary>
        /// Gets @task's #GCancellable
        /// </summary>
        /// <param name="task">
        /// a #GTask
        /// </param>
        /// <returns>
        /// @task's #GCancellable
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.Gio.Cancellable.UnmanagedStruct* g_task_get_cancellable(
        /* <type name="Task" type="GTask*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.Task.UnmanagedStruct* task);
        partial void CheckGetCancellableArgs();

        [GISharp.Runtime.SinceAttribute("2.36")]
        private GISharp.Lib.Gio.Cancellable GetCancellable()
        {
            CheckGetCancellableArgs();
            var task_ = (GISharp.Lib.Gio.Task.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_task_get_cancellable(task_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Lib.Gio.Cancellable.GetInstance<GISharp.Lib.Gio.Cancellable>((System.IntPtr)ret_, GISharp.Runtime.Transfer.None)!;
            return ret;
        }

        /// <summary>
        /// Gets @task's check-cancellable flag. See
        /// g_task_set_check_cancellable() for more details.
        /// </summary>
        /// <param name="task">
        /// the #GTask
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_task_get_check_cancellable(
        /* <type name="Task" type="GTask*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.Task.UnmanagedStruct* task);
        partial void CheckGetCheckCancellableArgs();

        [GISharp.Runtime.SinceAttribute("2.36")]
        private bool GetCheckCancellable()
        {
            CheckGetCheckCancellableArgs();
            var task_ = (GISharp.Lib.Gio.Task.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_task_get_check_cancellable(task_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Gets the value of #GTask:completed. This changes from %FALSE to %TRUE after
        /// the task’s callback is invoked, and will return %FALSE if called from inside
        /// the callback.
        /// </summary>
        /// <param name="task">
        /// a #GTask.
        /// </param>
        /// <returns>
        /// %TRUE if the task has completed, %FALSE otherwise.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.44")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_task_get_completed(
        /* <type name="Task" type="GTask*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.Task.UnmanagedStruct* task);
        partial void CheckGetCompletedArgs();

        [GISharp.Runtime.SinceAttribute("2.44")]
        private bool GetCompleted()
        {
            CheckGetCompletedArgs();
            var task_ = (GISharp.Lib.Gio.Task.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_task_get_completed(task_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Gets the #GMainContext that @task will return its result in (that
        /// is, the context that was the
        /// [thread-default main context][g-main-context-push-thread-default]
        /// at the point when @task was created).
        /// </summary>
        /// <remarks>
        /// <para>
        /// This will always return a non-%NULL value, even if the task's
        /// context is the default #GMainContext.
        /// </para>
        /// </remarks>
        /// <param name="task">
        /// a #GTask
        /// </param>
        /// <returns>
        /// @task's #GMainContext
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="GLib.MainContext" type="GMainContext*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GLib.MainContext.UnmanagedStruct* g_task_get_context(
        /* <type name="Task" type="GTask*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.Task.UnmanagedStruct* task);
        partial void CheckGetContextArgs();

        [GISharp.Runtime.SinceAttribute("2.36")]
        private GISharp.Lib.GLib.MainContext GetContext()
        {
            CheckGetContextArgs();
            var task_ = (GISharp.Lib.Gio.Task.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_task_get_context(task_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Lib.GLib.MainContext.GetInstance<GISharp.Lib.GLib.MainContext>((System.IntPtr)ret_, GISharp.Runtime.Transfer.None)!;
            return ret;
        }

        /// <summary>
        /// Gets @task’s name. See g_task_set_name().
        /// </summary>
        /// <param name="task">
        /// a #GTask
        /// </param>
        /// <returns>
        /// @task’s name, or %NULL
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.60")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="const gchar*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 direction:in */
        private static extern byte* g_task_get_name(
        /* <type name="Task" type="GTask*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.Task.UnmanagedStruct* task);
        partial void CheckGetNameArgs();

        [GISharp.Runtime.SinceAttribute("2.60")]
        private GISharp.Runtime.NullableUnownedUtf8 GetName()
        {
            CheckGetNameArgs();
            var task_ = (GISharp.Lib.Gio.Task.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_task_get_name(task_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = new GISharp.Runtime.NullableUnownedUtf8(ret_);
            return ret;
        }

        /// <summary>
        /// Gets @task's priority
        /// </summary>
        /// <param name="task">
        /// a #GTask
        /// </param>
        /// <returns>
        /// @task's priority
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gint" type="gint" /> */
        /* transfer-ownership:none direction:in */
        private static extern int g_task_get_priority(
        /* <type name="Task" type="GTask*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.Task.UnmanagedStruct* task);
        partial void CheckGetPriorityArgs();

        [GISharp.Runtime.SinceAttribute("2.36")]
        private int GetPriority()
        {
            CheckGetPriorityArgs();
            var task_ = (GISharp.Lib.Gio.Task.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_task_get_priority(task_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = (int)ret_;
            return ret;
        }

        /// <summary>
        /// Gets @task's return-on-cancel flag. See
        /// g_task_set_return_on_cancel() for more details.
        /// </summary>
        /// <param name="task">
        /// the #GTask
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_task_get_return_on_cancel(
        /* <type name="Task" type="GTask*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.Task.UnmanagedStruct* task);
        partial void CheckGetReturnOnCancelArgs();

        [GISharp.Runtime.SinceAttribute("2.36")]
        private bool GetReturnOnCancel()
        {
            CheckGetReturnOnCancelArgs();
            var task_ = (GISharp.Lib.Gio.Task.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_task_get_return_on_cancel(task_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Gets the source object from @task. Like
        /// g_async_result_get_source_object(), but does not ref the object.
        /// </summary>
        /// <param name="task">
        /// a #GTask
        /// </param>
        /// <returns>
        /// @task's source object, or %NULL
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="GObject.Object" type="gpointer" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 direction:in */
        private static extern GISharp.Lib.GObject.Object.UnmanagedStruct* g_task_get_source_object(
        /* <type name="Task" type="GTask*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.Task.UnmanagedStruct* task);
        partial void CheckGetSourceObjectArgs();

        [GISharp.Runtime.SinceAttribute("2.36")]
        private GISharp.Lib.GObject.Object? GetSourceObject()
        {
            CheckGetSourceObjectArgs();
            var task_ = (GISharp.Lib.Gio.Task.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_task_get_source_object(task_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Lib.GObject.Object.GetInstance<GISharp.Lib.GObject.Object>((System.IntPtr)ret_, GISharp.Runtime.Transfer.None);
            return ret;
        }

        /// <summary>
        /// Gets @task's source tag. See g_task_set_source_tag().
        /// </summary>
        /// <param name="task">
        /// a #GTask
        /// </param>
        /// <returns>
        /// @task's source tag
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gpointer" type="gpointer" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 direction:in */
        private static extern System.IntPtr g_task_get_source_tag(
        /* <type name="Task" type="GTask*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.Task.UnmanagedStruct* task);
        partial void CheckGetSourceTagArgs();

        [GISharp.Runtime.SinceAttribute("2.36")]
        private System.IntPtr GetSourceTag()
        {
            CheckGetSourceTagArgs();
            var task_ = (GISharp.Lib.Gio.Task.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_task_get_source_tag(task_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = (System.IntPtr)ret_;
            return ret;
        }

        /// <summary>
        /// Gets @task's `task_data`.
        /// </summary>
        /// <param name="task">
        /// a #GTask
        /// </param>
        /// <returns>
        /// @task's `task_data`.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gpointer" type="gpointer" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 direction:in */
        private static extern System.IntPtr g_task_get_task_data(
        /* <type name="Task" type="GTask*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.Task.UnmanagedStruct* task);
        partial void CheckGetTaskDataArgs();

        [GISharp.Runtime.SinceAttribute("2.36")]
        private System.IntPtr GetTaskData()
        {
            CheckGetTaskDataArgs();
            var task_ = (GISharp.Lib.Gio.Task.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_task_get_task_data(task_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = (System.IntPtr)ret_;
            return ret;
        }

        /// <summary>
        /// Tests if @task resulted in an error.
        /// </summary>
        /// <param name="task">
        /// a #GTask.
        /// </param>
        /// <returns>
        /// %TRUE if the task resulted in an error, %FALSE otherwise.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_task_had_error(
        /* <type name="Task" type="GTask*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.Task.UnmanagedStruct* task);
        partial void CheckHadErrorArgs();

        /// <include file="Task.xmldoc" path="declaration/member[@name='Task.HadError()']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        public bool HadError()
        {
            CheckHadErrorArgs();
            var task_ = (GISharp.Lib.Gio.Task.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_task_had_error(task_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Gets the result of @task as a #gboolean.
        /// </summary>
        /// <remarks>
        /// <para>
        /// If the task resulted in an error, or was cancelled, then this will
        /// instead return %FALSE and set @error.
        /// </para>
        /// <para>
        /// Since this method transfers ownership of the return value (or
        /// error) to the caller, you may only call it once.
        /// </para>
        /// </remarks>
        /// <param name="task">
        /// a #GTask.
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// the task result, or %FALSE on error
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        private static extern GISharp.Runtime.Boolean g_task_propagate_boolean(
        /* <type name="Task" type="GTask*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.Task.UnmanagedStruct* task,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        partial void CheckPropagateBooleanArgs();

        /// <include file="Task.xmldoc" path="declaration/member[@name='Task.PropagateBoolean()']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        public void PropagateBoolean()
        {
            CheckPropagateBooleanArgs();
            var task_ = (GISharp.Lib.Gio.Task.UnmanagedStruct*)UnsafeHandle;
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            g_task_propagate_boolean(task_, &error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Lib.GLib.Error.Exception(error);
            }
        }

        /// <summary>
        /// Gets the result of @task as an integer (#gssize).
        /// </summary>
        /// <remarks>
        /// <para>
        /// If the task resulted in an error, or was cancelled, then this will
        /// instead return -1 and set @error.
        /// </para>
        /// <para>
        /// Since this method transfers ownership of the return value (or
        /// error) to the caller, you may only call it once.
        /// </para>
        /// </remarks>
        /// <param name="task">
        /// a #GTask.
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// the task result, or -1 on error
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gssize" type="gssize" /> */
        /* transfer-ownership:none direction:in */
        private static extern nint g_task_propagate_int(
        /* <type name="Task" type="GTask*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.Task.UnmanagedStruct* task,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        partial void CheckPropagateIntArgs();

        /// <include file="Task.xmldoc" path="declaration/member[@name='Task.PropagateInt()']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        public int PropagateInt()
        {
            CheckPropagateIntArgs();
            var task_ = (GISharp.Lib.Gio.Task.UnmanagedStruct*)UnsafeHandle;
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            var ret_ = g_task_propagate_int(task_,&error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Lib.GLib.Error.Exception(error);
            }

            var ret = (int)ret_;
            return ret;
        }

        /// <summary>
        /// Gets the result of @task as a pointer, and transfers ownership
        /// of that value to the caller.
        /// </summary>
        /// <remarks>
        /// <para>
        /// If the task resulted in an error, or was cancelled, then this will
        /// instead return %NULL and set @error.
        /// </para>
        /// <para>
        /// Since this method transfers ownership of the return value (or
        /// error) to the caller, you may only call it once.
        /// </para>
        /// </remarks>
        /// <param name="task">
        /// a #GTask
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// the task result, or %NULL on error
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gpointer" type="gpointer" is-pointer="1" /> */
        /* transfer-ownership:full nullable:1 direction:in */
        private static extern System.IntPtr g_task_propagate_pointer(
        /* <type name="Task" type="GTask*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.Task.UnmanagedStruct* task,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        partial void CheckPropagatePointerArgs();

        /// <include file="Task.xmldoc" path="declaration/member[@name='Task.PropagatePointer()']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        public System.IntPtr PropagatePointer()
        {
            CheckPropagatePointerArgs();
            var task_ = (GISharp.Lib.Gio.Task.UnmanagedStruct*)UnsafeHandle;
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            var ret_ = g_task_propagate_pointer(task_,&error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Lib.GLib.Error.Exception(error);
            }

            var ret = (System.IntPtr)ret_;
            return ret;
        }

        /// <summary>
        /// Gets the result of @task as a #GValue, and transfers ownership of
        /// that value to the caller. As with g_task_return_value(), this is
        /// a generic low-level method; g_task_propagate_pointer() and the like
        /// will usually be more useful for C code.
        /// </summary>
        /// <remarks>
        /// <para>
        /// If the task resulted in an error, or was cancelled, then this will
        /// instead set @error and return %FALSE.
        /// </para>
        /// <para>
        /// Since this method transfers ownership of the return value (or
        /// error) to the caller, you may only call it once.
        /// </para>
        /// </remarks>
        /// <param name="task">
        /// a #GTask
        /// </param>
        /// <param name="value">
        /// return location for the #GValue
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// %TRUE if @task succeeded, %FALSE on error.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.64")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        private static extern GISharp.Runtime.Boolean g_task_propagate_value(
        /* <type name="Task" type="GTask*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.Task.UnmanagedStruct* task,
        /* <type name="GObject.Value" type="GValue*" /> */
        /* direction:out caller-allocates:1 transfer-ownership:none */
        GISharp.Lib.GObject.Value* value,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        partial void CheckPropagateValueArgs();

        /// <include file="Task.xmldoc" path="declaration/member[@name='Task.PropagateValue(GISharp.Lib.GObject.Value)']/*" />
        [GISharp.Runtime.SinceAttribute("2.64")]
        public void PropagateValue(out GISharp.Lib.GObject.Value value)
        {
            fixed (GISharp.Lib.GObject.Value* value_ = &value)
            {
                CheckPropagateValueArgs();
                var task_ = (GISharp.Lib.Gio.Task.UnmanagedStruct*)UnsafeHandle;
                var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
                g_task_propagate_value(task_, value_, &error_);
                GISharp.Runtime.GMarshal.PopUnhandledException();
                if (error_ is not null)
                {
                    var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                    throw new GISharp.Lib.GLib.Error.Exception(error);
                }
            }
        }

        /// <summary>
        /// Sets @task's result to @result and completes the task (see
        /// g_task_return_pointer() for more discussion of exactly what this
        /// means).
        /// </summary>
        /// <param name="task">
        /// a #GTask.
        /// </param>
        /// <param name="result">
        /// the #gboolean result of a task function.
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_task_return_boolean(
        /* <type name="Task" type="GTask*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.Task.UnmanagedStruct* task,
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.Boolean result);
        partial void CheckReturnBooleanArgs(bool result);

        /// <include file="Task.xmldoc" path="declaration/member[@name='Task.ReturnBoolean(bool)']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        public void ReturnBoolean(bool result)
        {
            CheckReturnBooleanArgs(result);
            var task_ = (GISharp.Lib.Gio.Task.UnmanagedStruct*)UnsafeHandle;
            var result_ = GISharp.Runtime.BooleanExtensions.ToBoolean(result);
            g_task_return_boolean(task_, result_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
        }

        /// <summary>
        /// Sets @task's result to @error (which @task assumes ownership of)
        /// and completes the task (see g_task_return_pointer() for more
        /// discussion of exactly what this means).
        /// </summary>
        /// <remarks>
        /// <para>
        /// Note that since the task takes ownership of @error, and since the
        /// task may be completed before returning from g_task_return_error(),
        /// you cannot assume that @error is still valid after calling this.
        /// Call g_error_copy() on the error if you need to keep a local copy
        /// as well.
        /// </para>
        /// <para>
        /// See also g_task_return_new_error().
        /// </para>
        /// </remarks>
        /// <param name="task">
        /// a #GTask.
        /// </param>
        /// <param name="error">
        /// the #GError result of a task function.
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_task_return_error(
        /* <type name="Task" type="GTask*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.Task.UnmanagedStruct* task,
        /* <type name="GLib.Error" type="GError*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        GISharp.Lib.GLib.Error.UnmanagedStruct* error);
        partial void CheckReturnErrorArgs(GISharp.Lib.GLib.Error error);

        /// <include file="Task.xmldoc" path="declaration/member[@name='Task.ReturnError(GISharp.Lib.GLib.Error)']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        public void ReturnError(GISharp.Lib.GLib.Error error)
        {
            CheckReturnErrorArgs(error);
            var task_ = (GISharp.Lib.Gio.Task.UnmanagedStruct*)UnsafeHandle;
            var error_ = (GISharp.Lib.GLib.Error.UnmanagedStruct*)error.Take();
            g_task_return_error(task_, error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
        }

        /// <summary>
        /// Checks if @task's #GCancellable has been cancelled, and if so, sets
        /// @task's error accordingly and completes the task (see
        /// g_task_return_pointer() for more discussion of exactly what this
        /// means).
        /// </summary>
        /// <param name="task">
        /// a #GTask
        /// </param>
        /// <returns>
        /// %TRUE if @task has been cancelled, %FALSE if not
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_task_return_error_if_cancelled(
        /* <type name="Task" type="GTask*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.Task.UnmanagedStruct* task);
        partial void CheckReturnErrorIfCancelledArgs();

        /// <include file="Task.xmldoc" path="declaration/member[@name='Task.ReturnErrorIfCancelled()']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        public bool ReturnErrorIfCancelled()
        {
            CheckReturnErrorIfCancelledArgs();
            var task_ = (GISharp.Lib.Gio.Task.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_task_return_error_if_cancelled(task_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Sets @task's result to @result and completes the task (see
        /// g_task_return_pointer() for more discussion of exactly what this
        /// means).
        /// </summary>
        /// <param name="task">
        /// a #GTask.
        /// </param>
        /// <param name="result">
        /// the integer (#gssize) result of a task function.
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_task_return_int(
        /* <type name="Task" type="GTask*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.Task.UnmanagedStruct* task,
        /* <type name="gssize" type="gssize" /> */
        /* transfer-ownership:none direction:in */
        nint result);
        partial void CheckReturnIntArgs(int result);

        /// <include file="Task.xmldoc" path="declaration/member[@name='Task.ReturnInt(int)']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        public void ReturnInt(int result)
        {
            CheckReturnIntArgs(result);
            var task_ = (GISharp.Lib.Gio.Task.UnmanagedStruct*)UnsafeHandle;
            var result_ = (nint)result;
            g_task_return_int(task_, result_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
        }

        /// <summary>
        /// Sets @task's result to @result and completes the task. If @result
        /// is not %NULL, then @result_destroy will be used to free @result if
        /// the caller does not take ownership of it with
        /// g_task_propagate_pointer().
        /// </summary>
        /// <remarks>
        /// <para>
        /// "Completes the task" means that for an ordinary asynchronous task
        /// it will either invoke the task's callback, or else queue that
        /// callback to be invoked in the proper #GMainContext, or in the next
        /// iteration of the current #GMainContext. For a task run via
        /// g_task_run_in_thread() or g_task_run_in_thread_sync(), calling this
        /// method will save @result to be returned to the caller later, but
        /// the task will not actually be completed until the #GTaskThreadFunc
        /// exits.
        /// </para>
        /// <para>
        /// Note that since the task may be completed before returning from
        /// g_task_return_pointer(), you cannot assume that @result is still
        /// valid after calling this, unless you are still holding another
        /// reference on it.
        /// </para>
        /// </remarks>
        /// <param name="task">
        /// a #GTask
        /// </param>
        /// <param name="result">
        /// the pointer result of a task
        ///     function
        /// </param>
        /// <param name="resultDestroy">
        /// a #GDestroyNotify function.
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_task_return_pointer(
        /* <type name="Task" type="GTask*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.Task.UnmanagedStruct* task,
        /* <type name="gpointer" type="gpointer" is-pointer="1" /> */
        /* transfer-ownership:full nullable:1 allow-none:1 direction:in */
        System.IntPtr result,
        /* <type name="GLib.DestroyNotify" type="GDestroyNotify" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:async direction:in */
        delegate* unmanaged[Cdecl]<System.IntPtr, void> resultDestroy);

        /// <summary>
        /// Sets @task's result to @result (by copying it) and completes the task.
        /// </summary>
        /// <remarks>
        /// <para>
        /// If @result is %NULL then a #GValue of type %G_TYPE_POINTER
        /// with a value of %NULL will be used for the result.
        /// </para>
        /// <para>
        /// This is a very generic low-level method intended primarily for use
        /// by language bindings; for C code, g_task_return_pointer() and the
        /// like will normally be much easier to use.
        /// </para>
        /// </remarks>
        /// <param name="task">
        /// a #GTask
        /// </param>
        /// <param name="result">
        /// the #GValue result of
        ///                                      a task function
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.64")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_task_return_value(
        /* <type name="Task" type="GTask*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.Task.UnmanagedStruct* task,
        /* <type name="GObject.Value" type="GValue*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.GObject.Value* result);
        partial void CheckReturnValueArgs(ref GISharp.Lib.GObject.Value result);

        /// <include file="Task.xmldoc" path="declaration/member[@name='Task.ReturnValue(GISharp.Lib.GObject.Value)']/*" />
        [GISharp.Runtime.SinceAttribute("2.64")]
        public void ReturnValue(ref GISharp.Lib.GObject.Value result)
        {
            fixed (GISharp.Lib.GObject.Value* result_ = &result)
            {
                CheckReturnValueArgs(ref result);
                var task_ = (GISharp.Lib.Gio.Task.UnmanagedStruct*)UnsafeHandle;
                g_task_return_value(task_, result_);
                GISharp.Runtime.GMarshal.PopUnhandledException();
            }
        }

        /// <summary>
        /// Runs @task_func in another thread. When @task_func returns, @task's
        /// #GAsyncReadyCallback will be invoked in @task's #GMainContext.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This takes a ref on @task until the task completes.
        /// </para>
        /// <para>
        /// See #GTaskThreadFunc for more details about how @task_func is handled.
        /// </para>
        /// <para>
        /// Although GLib currently rate-limits the tasks queued via
        /// g_task_run_in_thread(), you should not assume that it will always
        /// do this. If you have a very large number of tasks to run (several tens of
        /// tasks), but don't want them to all run at once, you should only queue a
        /// limited number of them (around ten) at a time.
        /// </para>
        /// </remarks>
        /// <param name="task">
        /// a #GTask
        /// </param>
        /// <param name="taskFunc">
        /// a #GTaskThreadFunc
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_task_run_in_thread(
        /* <type name="Task" type="GTask*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.Task.UnmanagedStruct* task,
        /* <type name="TaskThreadFunc" type="GTaskThreadFunc" /> */
        /* transfer-ownership:none scope:async direction:in */
        delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.Task.UnmanagedStruct*, GISharp.Lib.GObject.Object.UnmanagedStruct*, System.IntPtr, GISharp.Lib.Gio.Cancellable.UnmanagedStruct*, void> taskFunc);

        /// <summary>
        /// Runs @task_func in another thread, and waits for it to return or be
        /// cancelled. You can use g_task_propagate_pointer(), etc, afterward
        /// to get the result of @task_func.
        /// </summary>
        /// <remarks>
        /// <para>
        /// See #GTaskThreadFunc for more details about how @task_func is handled.
        /// </para>
        /// <para>
        /// Normally this is used with tasks created with a %NULL
        /// `callback`, but note that even if the task does
        /// have a callback, it will not be invoked when @task_func returns.
        /// #GTask:completed will be set to %TRUE just before this function returns.
        /// </para>
        /// <para>
        /// Although GLib currently rate-limits the tasks queued via
        /// g_task_run_in_thread_sync(), you should not assume that it will
        /// always do this. If you have a very large number of tasks to run,
        /// but don't want them to all run at once, you should only queue a
        /// limited number of them at a time.
        /// </para>
        /// </remarks>
        /// <param name="task">
        /// a #GTask
        /// </param>
        /// <param name="taskFunc">
        /// a #GTaskThreadFunc
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_task_run_in_thread_sync(
        /* <type name="Task" type="GTask*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.Task.UnmanagedStruct* task,
        /* <type name="TaskThreadFunc" type="GTaskThreadFunc" /> */
        /* transfer-ownership:none scope:async direction:in */
        delegate* unmanaged[Cdecl]<GISharp.Lib.Gio.Task.UnmanagedStruct*, GISharp.Lib.GObject.Object.UnmanagedStruct*, System.IntPtr, GISharp.Lib.Gio.Cancellable.UnmanagedStruct*, void> taskFunc);

        /// <summary>
        /// Sets or clears @task's check-cancellable flag. If this is %TRUE
        /// (the default), then g_task_propagate_pointer(), etc, and
        /// g_task_had_error() will check the task's #GCancellable first, and
        /// if it has been cancelled, then they will consider the task to have
        /// returned an "Operation was cancelled" error
        /// (%G_IO_ERROR_CANCELLED), regardless of any other error or return
        /// value the task may have had.
        /// </summary>
        /// <remarks>
        /// <para>
        /// If @check_cancellable is %FALSE, then the #GTask will not check the
        /// cancellable itself, and it is up to @task's owner to do this (eg,
        /// via g_task_return_error_if_cancelled()).
        /// </para>
        /// <para>
        /// If you are using g_task_set_return_on_cancel() as well, then
        /// you must leave check-cancellable set %TRUE.
        /// </para>
        /// </remarks>
        /// <param name="task">
        /// the #GTask
        /// </param>
        /// <param name="checkCancellable">
        /// whether #GTask will check the state of
        ///   its #GCancellable for you.
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_task_set_check_cancellable(
        /* <type name="Task" type="GTask*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.Task.UnmanagedStruct* task,
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.Boolean checkCancellable);
        partial void CheckSetCheckCancellableArgs(bool checkCancellable);

        [GISharp.Runtime.SinceAttribute("2.36")]
        private void SetCheckCancellable(bool checkCancellable)
        {
            CheckSetCheckCancellableArgs(checkCancellable);
            var task_ = (GISharp.Lib.Gio.Task.UnmanagedStruct*)UnsafeHandle;
            var checkCancellable_ = GISharp.Runtime.BooleanExtensions.ToBoolean(checkCancellable);
            g_task_set_check_cancellable(task_, checkCancellable_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
        }

        /// <summary>
        /// Sets @task’s name, used in debugging and profiling. The name defaults to
        /// %NULL.
        /// </summary>
        /// <remarks>
        /// <para>
        /// The task name should describe in a human readable way what the task does.
        /// For example, ‘Open file’ or ‘Connect to network host’. It is used to set the
        /// name of the #GSource used for idle completion of the task.
        /// </para>
        /// <para>
        /// This function may only be called before the @task is first used in a thread
        /// other than the one it was constructed in. It is called automatically by
        /// g_task_set_source_tag() if not called already.
        /// </para>
        /// </remarks>
        /// <param name="task">
        /// a #GTask
        /// </param>
        /// <param name="name">
        /// a human readable name for the task, or %NULL to unset it
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.60")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_task_set_name(
        /* <type name="Task" type="GTask*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.Task.UnmanagedStruct* task,
        /* <type name="utf8" type="const gchar*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        byte* name);
        partial void CheckSetNameArgs(GISharp.Runtime.NullableUnownedUtf8 name);

        [GISharp.Runtime.SinceAttribute("2.60")]
        private void SetName(GISharp.Runtime.NullableUnownedUtf8 name)
        {
            CheckSetNameArgs(name);
            var task_ = (GISharp.Lib.Gio.Task.UnmanagedStruct*)UnsafeHandle;
            var name_ = (byte*)name.UnsafeHandle;
            g_task_set_name(task_, name_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
        }

        /// <summary>
        /// Sets @task's priority. If you do not call this, it will default to
        /// %G_PRIORITY_DEFAULT.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This will affect the priority of #GSources created with
        /// g_task_attach_source() and the scheduling of tasks run in threads,
        /// and can also be explicitly retrieved later via
        /// g_task_get_priority().
        /// </para>
        /// </remarks>
        /// <param name="task">
        /// the #GTask
        /// </param>
        /// <param name="priority">
        /// the [priority][io-priority] of the request
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_task_set_priority(
        /* <type name="Task" type="GTask*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.Task.UnmanagedStruct* task,
        /* <type name="gint" type="gint" /> */
        /* transfer-ownership:none direction:in */
        int priority);
        partial void CheckSetPriorityArgs(int priority);

        [GISharp.Runtime.SinceAttribute("2.36")]
        private void SetPriority(int priority)
        {
            CheckSetPriorityArgs(priority);
            var task_ = (GISharp.Lib.Gio.Task.UnmanagedStruct*)UnsafeHandle;
            var priority_ = (int)priority;
            g_task_set_priority(task_, priority_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
        }

        /// <summary>
        /// Sets or clears @task's return-on-cancel flag. This is only
        /// meaningful for tasks run via g_task_run_in_thread() or
        /// g_task_run_in_thread_sync().
        /// </summary>
        /// <remarks>
        /// <para>
        /// If @return_on_cancel is %TRUE, then cancelling @task's
        /// #GCancellable will immediately cause it to return, as though the
        /// task's #GTaskThreadFunc had called
        /// g_task_return_error_if_cancelled() and then returned.
        /// </para>
        /// <para>
        /// This allows you to create a cancellable wrapper around an
        /// uninterruptible function. The #GTaskThreadFunc just needs to be
        /// careful that it does not modify any externally-visible state after
        /// it has been cancelled. To do that, the thread should call
        /// g_task_set_return_on_cancel() again to (atomically) set
        /// return-on-cancel %FALSE before making externally-visible changes;
        /// if the task gets cancelled before the return-on-cancel flag could
        /// be changed, g_task_set_return_on_cancel() will indicate this by
        /// returning %FALSE.
        /// </para>
        /// <para>
        /// You can disable and re-enable this flag multiple times if you wish.
        /// If the task's #GCancellable is cancelled while return-on-cancel is
        /// %FALSE, then calling g_task_set_return_on_cancel() to set it %TRUE
        /// again will cause the task to be cancelled at that point.
        /// </para>
        /// <para>
        /// If the task's #GCancellable is already cancelled before you call
        /// g_task_run_in_thread()/g_task_run_in_thread_sync(), then the
        /// #GTaskThreadFunc will still be run (for consistency), but the task
        /// will also be completed right away.
        /// </para>
        /// </remarks>
        /// <param name="task">
        /// the #GTask
        /// </param>
        /// <param name="returnOnCancel">
        /// whether the task returns automatically when
        ///   it is cancelled.
        /// </param>
        /// <returns>
        /// %TRUE if @task's return-on-cancel flag was changed to
        ///   match @return_on_cancel. %FALSE if @task has already been
        ///   cancelled.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_task_set_return_on_cancel(
        /* <type name="Task" type="GTask*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.Task.UnmanagedStruct* task,
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.Boolean returnOnCancel);
        partial void CheckSetReturnOnCancelArgs(bool returnOnCancel);

        /// <include file="Task.xmldoc" path="declaration/member[@name='Task.SetReturnOnCancel(bool)']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        public bool SetReturnOnCancel(bool returnOnCancel)
        {
            CheckSetReturnOnCancelArgs(returnOnCancel);
            var task_ = (GISharp.Lib.Gio.Task.UnmanagedStruct*)UnsafeHandle;
            var returnOnCancel_ = GISharp.Runtime.BooleanExtensions.ToBoolean(returnOnCancel);
            var ret_ = g_task_set_return_on_cancel(task_,returnOnCancel_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Sets @task's source tag.
        /// </summary>
        /// <remarks>
        /// <para>
        /// You can use this to tag a task return
        /// value with a particular pointer (usually a pointer to the function
        /// doing the tagging) and then later check it using
        /// g_task_get_source_tag() (or g_async_result_is_tagged()) in the
        /// task's "finish" function, to figure out if the response came from a
        /// particular place.
        /// </para>
        /// <para>
        /// A macro wrapper around this function will automatically set the
        /// task’s name to the string form of @source_tag if it’s not already
        /// set, for convenience.
        /// </para>
        /// </remarks>
        /// <param name="task">
        /// the #GTask
        /// </param>
        /// <param name="sourceTag">
        /// an opaque pointer indicating the source of this task
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_task_set_source_tag(
        /* <type name="Task" type="GTask*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.Task.UnmanagedStruct* task,
        /* <type name="gpointer" type="gpointer" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr sourceTag);
        partial void CheckSetSourceTagArgs(System.IntPtr sourceTag);

        [GISharp.Runtime.SinceAttribute("2.36")]
        private void SetSourceTag(System.IntPtr sourceTag)
        {
            CheckSetSourceTagArgs(sourceTag);
            var task_ = (GISharp.Lib.Gio.Task.UnmanagedStruct*)UnsafeHandle;
            var sourceTag_ = (System.IntPtr)sourceTag;
            g_task_set_source_tag(task_, sourceTag_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
        }

        /// <summary>
        /// Sets @task's task data (freeing the existing task data, if any).
        /// </summary>
        /// <param name="task">
        /// the #GTask
        /// </param>
        /// <param name="taskData">
        /// task-specific data
        /// </param>
        /// <param name="taskDataDestroy">
        /// #GDestroyNotify for @task_data
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_task_set_task_data(
        /* <type name="Task" type="GTask*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.Task.UnmanagedStruct* task,
        /* <type name="gpointer" type="gpointer" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr taskData,
        /* <type name="GLib.DestroyNotify" type="GDestroyNotify" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:async direction:in */
        delegate* unmanaged[Cdecl]<System.IntPtr, void> taskDataDestroy);

        GISharp.Lib.GObject.Object? GISharp.Lib.Gio.IAsyncResult.DoGetSourceObject()
        {
            throw new System.NotImplementedException();
        }

        System.IntPtr GISharp.Lib.Gio.IAsyncResult.DoGetUserData()
        {
            throw new System.NotImplementedException();
        }

        bool GISharp.Lib.Gio.IAsyncResult.DoIsTagged(System.IntPtr sourceTag)
        {
            throw new System.NotImplementedException();
        }
    }
}