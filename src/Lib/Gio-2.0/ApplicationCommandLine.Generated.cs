// SPDX-License-Identifier: MIT
// ATTENTION: This file is automatically generated. Do not edit manually.
#nullable enable
namespace GISharp.Lib.Gio
{
    /// <include file="ApplicationCommandLine.xmldoc" path="declaration/member[@name='ApplicationCommandLine']/*" />
    [GISharp.Runtime.GTypeAttribute("GApplicationCommandLine", IsProxyForUnmanagedType = true)]
    [GISharp.Runtime.GTypeStructAttribute(typeof(ApplicationCommandLineClass))]
    public unsafe partial class ApplicationCommandLine : GISharp.Lib.GObject.Object
    {
        private static readonly GISharp.Runtime.GType _GType = g_application_command_line_get_type();

        /// <summary>
        /// The unmanaged data structure.
        /// </summary>
        public new struct UnmanagedStruct
        {
#pragma warning disable CS0169, CS0414, CS0649
            /// <include file="ApplicationCommandLine.xmldoc" path="declaration/member[@name='UnmanagedStruct.ParentInstance']/*" />
            internal readonly GISharp.Lib.GObject.Object.UnmanagedStruct ParentInstance;

            /// <include file="ApplicationCommandLine.xmldoc" path="declaration/member[@name='UnmanagedStruct.Priv']/*" />
            internal readonly System.IntPtr Priv;
#pragma warning restore CS0169, CS0414, CS0649
        }

        /// <include file="ApplicationCommandLine.xmldoc" path="declaration/member[@name='ApplicationCommandLine.Arguments_']/*" />
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [GISharp.Runtime.GPropertyAttribute("arguments", Construct = GISharp.Runtime.GPropertyConstruct.Only)]
        public GISharp.Lib.GLib.Variant? Arguments_ { set => SetProperty("arguments", value); }

        /// <include file="ApplicationCommandLine.xmldoc" path="declaration/member[@name='ApplicationCommandLine.IsRemote_']/*" />
        [GISharp.Runtime.GPropertyAttribute("is-remote")]
        public bool IsRemote_ { get => (bool)GetProperty("is-remote")!; }

        /// <include file="ApplicationCommandLine.xmldoc" path="declaration/member[@name='ApplicationCommandLine.Options_']/*" />
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [GISharp.Runtime.GPropertyAttribute("options", Construct = GISharp.Runtime.GPropertyConstruct.Only)]
        public GISharp.Lib.GLib.Variant? Options_ { set => SetProperty("options", value); }

        /// <include file="ApplicationCommandLine.xmldoc" path="declaration/member[@name='ApplicationCommandLine.PlatformData_']/*" />
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [GISharp.Runtime.GPropertyAttribute("platform-data", Construct = GISharp.Runtime.GPropertyConstruct.Only)]
        public GISharp.Lib.GLib.Variant? PlatformData_ { set => SetProperty("platform-data", value); }

        /// <include file="ApplicationCommandLine.xmldoc" path="declaration/member[@name='ApplicationCommandLine.Arguments']/*" />
        [GISharp.Runtime.SinceAttribute("2.28")]
        public GISharp.Runtime.CPtrArray<GISharp.Lib.GLib.Filename> Arguments { get => GetArguments(); }

        /// <include file="ApplicationCommandLine.xmldoc" path="declaration/member[@name='ApplicationCommandLine.Cwd']/*" />
        [GISharp.Runtime.SinceAttribute("2.28")]
        public GISharp.Lib.GLib.Filename? Cwd { get => GetCwd(); }

        /// <include file="ApplicationCommandLine.xmldoc" path="declaration/member[@name='ApplicationCommandLine.Environment']/*" />
        [GISharp.Runtime.SinceAttribute("2.28")]
        public GISharp.Runtime.FilenameArray Environment { get => GetEnvironment(); }

        /// <include file="ApplicationCommandLine.xmldoc" path="declaration/member[@name='ApplicationCommandLine.ExitStatus']/*" />
        [GISharp.Runtime.SinceAttribute("2.28")]
        public int ExitStatus { get => GetExitStatus(); set => SetExitStatus(value); }

        /// <include file="ApplicationCommandLine.xmldoc" path="declaration/member[@name='ApplicationCommandLine.IsRemote']/*" />
        [GISharp.Runtime.SinceAttribute("2.28")]
        public bool IsRemote { get => GetIsRemote(); }

        /// <include file="ApplicationCommandLine.xmldoc" path="declaration/member[@name='ApplicationCommandLine.Options']/*" />
        [GISharp.Runtime.SinceAttribute("2.40")]
        public GISharp.Lib.GLib.VariantDict Options { get => GetOptions(); }

        /// <include file="ApplicationCommandLine.xmldoc" path="declaration/member[@name='ApplicationCommandLine.PlatformData']/*" />
        [GISharp.Runtime.SinceAttribute("2.28")]
        public GISharp.Lib.GLib.Variant? PlatformData { get => GetPlatformData(); }

        /// <include file="ApplicationCommandLine.xmldoc" path="declaration/member[@name='ApplicationCommandLine.Stdin']/*" />
        [GISharp.Runtime.SinceAttribute("2.34")]
        public GISharp.Lib.Gio.InputStream Stdin { get => GetStdin(); }

        /// <summary>
        /// For internal runtime use only.
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        public ApplicationCommandLine(System.IntPtr handle, GISharp.Runtime.Transfer ownership) : base(handle, ownership)
        {
        }

        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="GType" type="GType" managed-name="GISharp.Runtime.GType" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Runtime.GType g_application_command_line_get_type();

        /// <summary>
        /// Creates a #GFile corresponding to a filename that was given as part
        /// of the invocation of @cmdline.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This differs from g_file_new_for_commandline_arg() in that it
        /// resolves relative pathnames using the current working directory of
        /// the invoking process rather than the local process.
        /// </para>
        /// </remarks>
        /// <param name="cmdline">
        /// a #GApplicationCommandLine
        /// </param>
        /// <param name="arg">
        /// an argument from @cmdline
        /// </param>
        /// <returns>
        /// a new #GFile
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.Gio.File.UnmanagedStruct* g_application_command_line_create_file_for_arg(
        /* <type name="ApplicationCommandLine" type="GApplicationCommandLine*" managed-name="ApplicationCommandLine" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.ApplicationCommandLine.UnmanagedStruct* cmdline,
        /* <type name="filename" type="const gchar*" managed-name="GISharp.Lib.GLib.Filename" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* arg);
        partial void CheckCreateFileForArgArgs(GISharp.Lib.GLib.Filename arg);

        /// <include file="ApplicationCommandLine.xmldoc" path="declaration/member[@name='ApplicationCommandLine.CreateFileForArg(GISharp.Lib.GLib.Filename)']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        public GISharp.Lib.Gio.IFile CreateFileForArg(GISharp.Lib.GLib.Filename arg)
        {
            CheckCreateFileForArgArgs(arg);
            var cmdline_ = (GISharp.Lib.Gio.ApplicationCommandLine.UnmanagedStruct*)UnsafeHandle;
            var arg_ = (byte*)arg.UnsafeHandle;
            var ret_ = g_application_command_line_create_file_for_arg(cmdline_,arg_);
            var ret = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Gets the list of arguments that was passed on the command line.
        /// </summary>
        /// <remarks>
        /// <para>
        /// The strings in the array may contain non-UTF-8 data on UNIX (such as
        /// filenames or arguments given in the system locale) but are always in
        /// UTF-8 on Windows.
        /// </para>
        /// <para>
        /// If you wish to use the return value with #GOptionContext, you must
        /// use g_option_context_parse_strv().
        /// </para>
        /// <para>
        /// The return value is %NULL-terminated and should be freed using
        /// g_strfreev().
        /// </para>
        /// </remarks>
        /// <param name="cmdline">
        /// a #GApplicationCommandLine
        /// </param>
        /// <param name="argc">
        /// the length of the arguments array, or %NULL
        /// </param>
        /// <returns>
        /// 
        ///      the string array containing the arguments (the argv)
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.28")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <array length="0" zero-terminated="0" type="gchar**" null-terminated="1" managed-name="GISharp.Runtime.CArray" is-pointer="1">
*   <type name="filename" managed-name="GISharp.Lib.GLib.Filename" is-pointer="1" />
* </array> */
        /* transfer-ownership:full direction:in */
        private static extern byte** g_application_command_line_get_arguments(
        /* <type name="ApplicationCommandLine" type="GApplicationCommandLine*" managed-name="ApplicationCommandLine" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.ApplicationCommandLine.UnmanagedStruct* cmdline,
        /* <type name="gint" type="int*" managed-name="System.Int32" /> */
        /* direction:out caller-allocates:0 transfer-ownership:full optional:1 allow-none:1 */
        int* argc);
        partial void CheckGetArgumentsArgs();

        [GISharp.Runtime.SinceAttribute("2.28")]
        private GISharp.Runtime.CPtrArray<GISharp.Lib.GLib.Filename> GetArguments()
        {
            CheckGetArgumentsArgs();
            var cmdline_ = (GISharp.Lib.Gio.ApplicationCommandLine.UnmanagedStruct*)UnsafeHandle;
            int argc_;
            var ret_ = g_application_command_line_get_arguments(cmdline_,&argc_);
            var ret = new GISharp.Runtime.CPtrArray<GISharp.Lib.GLib.Filename>((System.IntPtr)ret_, (int)argc_, GISharp.Runtime.Transfer.Full);
            return ret;
        }

        /// <summary>
        /// Gets the working directory of the command line invocation.
        /// The string may contain non-utf8 data.
        /// </summary>
        /// <remarks>
        /// <para>
        /// It is possible that the remote application did not send a working
        /// directory, so this may be %NULL.
        /// </para>
        /// <para>
        /// The return value should not be modified or freed and is valid for as
        /// long as @cmdline exists.
        /// </para>
        /// </remarks>
        /// <param name="cmdline">
        /// a #GApplicationCommandLine
        /// </param>
        /// <returns>
        /// the current directory, or %NULL
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.28")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="filename" type="const gchar*" managed-name="GISharp.Lib.GLib.Filename" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 direction:in */
        private static extern byte* g_application_command_line_get_cwd(
        /* <type name="ApplicationCommandLine" type="GApplicationCommandLine*" managed-name="ApplicationCommandLine" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.ApplicationCommandLine.UnmanagedStruct* cmdline);
        partial void CheckGetCwdArgs();

        [GISharp.Runtime.SinceAttribute("2.28")]
        private GISharp.Lib.GLib.Filename? GetCwd()
        {
            CheckGetCwdArgs();
            var cmdline_ = (GISharp.Lib.Gio.ApplicationCommandLine.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_application_command_line_get_cwd(cmdline_);
            var ret = GISharp.Lib.GLib.Filename.GetInstance<GISharp.Lib.GLib.Filename>((System.IntPtr)ret_, GISharp.Runtime.Transfer.None);
            return ret;
        }

        /// <summary>
        /// Gets the contents of the 'environ' variable of the command line
        /// invocation, as would be returned by g_get_environ(), ie as a
        /// %NULL-terminated list of strings in the form 'NAME=VALUE'.
        /// The strings may contain non-utf8 data.
        /// </summary>
        /// <remarks>
        /// <para>
        /// The remote application usually does not send an environment.  Use
        /// %G_APPLICATION_SEND_ENVIRONMENT to affect that.  Even with this flag
        /// set it is possible that the environment is still not available (due
        /// to invocation messages from other applications).
        /// </para>
        /// <para>
        /// The return value should not be modified or freed and is valid for as
        /// long as @cmdline exists.
        /// </para>
        /// <para>
        /// See g_application_command_line_getenv() if you are only interested
        /// in the value of a single environment variable.
        /// </para>
        /// </remarks>
        /// <param name="cmdline">
        /// a #GApplicationCommandLine
        /// </param>
        /// <returns>
        /// 
        ///     the environment strings, or %NULL if they were not sent
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.28")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <array type="const gchar* const*" zero-terminated="1" managed-name="GISharp.Runtime.FilenameArray" is-pointer="1">
*   <type name="filename" managed-name="GISharp.Lib.GLib.Filename" is-pointer="1" />
* </array> */
        /* transfer-ownership:none direction:in */
        private static extern byte** g_application_command_line_get_environ(
        /* <type name="ApplicationCommandLine" type="GApplicationCommandLine*" managed-name="ApplicationCommandLine" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.ApplicationCommandLine.UnmanagedStruct* cmdline);
        partial void CheckGetEnvironmentArgs();

        [GISharp.Runtime.SinceAttribute("2.28")]
        private GISharp.Runtime.FilenameArray GetEnvironment()
        {
            CheckGetEnvironmentArgs();
            var cmdline_ = (GISharp.Lib.Gio.ApplicationCommandLine.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_application_command_line_get_environ(cmdline_);
            var ret = new GISharp.Runtime.FilenameArray((System.IntPtr)ret_, -1, GISharp.Runtime.Transfer.None);
            return ret;
        }

        /// <summary>
        /// Gets the exit status of @cmdline.  See
        /// g_application_command_line_set_exit_status() for more information.
        /// </summary>
        /// <param name="cmdline">
        /// a #GApplicationCommandLine
        /// </param>
        /// <returns>
        /// the exit status
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.28")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gint" type="int" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        private static extern int g_application_command_line_get_exit_status(
        /* <type name="ApplicationCommandLine" type="GApplicationCommandLine*" managed-name="ApplicationCommandLine" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.ApplicationCommandLine.UnmanagedStruct* cmdline);
        partial void CheckGetExitStatusArgs();

        [GISharp.Runtime.SinceAttribute("2.28")]
        private int GetExitStatus()
        {
            CheckGetExitStatusArgs();
            var cmdline_ = (GISharp.Lib.Gio.ApplicationCommandLine.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_application_command_line_get_exit_status(cmdline_);
            var ret = (int)ret_;
            return ret;
        }

        /// <summary>
        /// Determines if @cmdline represents a remote invocation.
        /// </summary>
        /// <param name="cmdline">
        /// a #GApplicationCommandLine
        /// </param>
        /// <returns>
        /// %TRUE if the invocation was remote
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.28")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_application_command_line_get_is_remote(
        /* <type name="ApplicationCommandLine" type="GApplicationCommandLine*" managed-name="ApplicationCommandLine" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.ApplicationCommandLine.UnmanagedStruct* cmdline);
        partial void CheckGetIsRemoteArgs();

        [GISharp.Runtime.SinceAttribute("2.28")]
        private bool GetIsRemote()
        {
            CheckGetIsRemoteArgs();
            var cmdline_ = (GISharp.Lib.Gio.ApplicationCommandLine.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_application_command_line_get_is_remote(cmdline_);
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Gets the options there were passed to g_application_command_line().
        /// </summary>
        /// <remarks>
        /// <para>
        /// If you did not override local_command_line() then these are the same
        /// options that were parsed according to the #GOptionEntrys added to the
        /// application with g_application_add_main_option_entries() and possibly
        /// modified from your GApplication::handle-local-options handler.
        /// </para>
        /// <para>
        /// If no options were sent then an empty dictionary is returned so that
        /// you don't need to check for %NULL.
        /// </para>
        /// </remarks>
        /// <param name="cmdline">
        /// a #GApplicationCommandLine
        /// </param>
        /// <returns>
        /// a #GVariantDict with the options
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.40")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="GLib.VariantDict" type="GVariantDict*" managed-name="GISharp.Lib.GLib.VariantDict" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GLib.VariantDict.UnmanagedStruct* g_application_command_line_get_options_dict(
        /* <type name="ApplicationCommandLine" type="GApplicationCommandLine*" managed-name="ApplicationCommandLine" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.ApplicationCommandLine.UnmanagedStruct* cmdline);
        partial void CheckGetOptionsArgs();

        [GISharp.Runtime.SinceAttribute("2.40")]
        private GISharp.Lib.GLib.VariantDict GetOptions()
        {
            CheckGetOptionsArgs();
            var cmdline_ = (GISharp.Lib.Gio.ApplicationCommandLine.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_application_command_line_get_options_dict(cmdline_);
            var ret = GISharp.Lib.GLib.VariantDict.GetInstance<GISharp.Lib.GLib.VariantDict>((System.IntPtr)ret_, GISharp.Runtime.Transfer.None)!;
            return ret;
        }

        /// <summary>
        /// Gets the platform data associated with the invocation of @cmdline.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This is a #GVariant dictionary containing information about the
        /// context in which the invocation occurred.  It typically contains
        /// information like the current working directory and the startup
        /// notification ID.
        /// </para>
        /// <para>
        /// For local invocation, it will be %NULL.
        /// </para>
        /// </remarks>
        /// <param name="cmdline">
        /// #GApplicationCommandLine
        /// </param>
        /// <returns>
        /// the platform data, or %NULL
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.28")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="GLib.Variant" type="GVariant*" managed-name="GISharp.Lib.GLib.Variant" is-pointer="1" /> */
        /* transfer-ownership:full nullable:1 direction:in */
        private static extern GISharp.Lib.GLib.Variant.UnmanagedStruct* g_application_command_line_get_platform_data(
        /* <type name="ApplicationCommandLine" type="GApplicationCommandLine*" managed-name="ApplicationCommandLine" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.ApplicationCommandLine.UnmanagedStruct* cmdline);
        partial void CheckGetPlatformDataArgs();

        [GISharp.Runtime.SinceAttribute("2.28")]
        private GISharp.Lib.GLib.Variant? GetPlatformData()
        {
            CheckGetPlatformDataArgs();
            var cmdline_ = (GISharp.Lib.Gio.ApplicationCommandLine.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_application_command_line_get_platform_data(cmdline_);
            var ret = GISharp.Lib.GLib.Variant.GetInstance<GISharp.Lib.GLib.Variant>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full);
            return ret;
        }

        /// <summary>
        /// Gets the stdin of the invoking process.
        /// </summary>
        /// <remarks>
        /// <para>
        /// The #GInputStream can be used to read data passed to the standard
        /// input of the invoking process.
        /// This doesn't work on all platforms.  Presently, it is only available
        /// on UNIX when using a DBus daemon capable of passing file descriptors.
        /// If stdin is not available then %NULL will be returned.  In the
        /// future, support may be expanded to other platforms.
        /// </para>
        /// <para>
        /// You must only call this function once per commandline invocation.
        /// </para>
        /// </remarks>
        /// <param name="cmdline">
        /// a #GApplicationCommandLine
        /// </param>
        /// <returns>
        /// a #GInputStream for stdin
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.34")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="InputStream" type="GInputStream*" managed-name="InputStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.Gio.InputStream.UnmanagedStruct* g_application_command_line_get_stdin(
        /* <type name="ApplicationCommandLine" type="GApplicationCommandLine*" managed-name="ApplicationCommandLine" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.ApplicationCommandLine.UnmanagedStruct* cmdline);
        partial void CheckGetStdinArgs();

        [GISharp.Runtime.SinceAttribute("2.34")]
        private GISharp.Lib.Gio.InputStream GetStdin()
        {
            CheckGetStdinArgs();
            var cmdline_ = (GISharp.Lib.Gio.ApplicationCommandLine.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_application_command_line_get_stdin(cmdline_);
            var ret = GISharp.Lib.Gio.InputStream.GetInstance<GISharp.Lib.Gio.InputStream>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Gets the value of a particular environment variable of the command
        /// line invocation, as would be returned by g_getenv().  The strings may
        /// contain non-utf8 data.
        /// </summary>
        /// <remarks>
        /// <para>
        /// The remote application usually does not send an environment.  Use
        /// %G_APPLICATION_SEND_ENVIRONMENT to affect that.  Even with this flag
        /// set it is possible that the environment is still not available (due
        /// to invocation messages from other applications).
        /// </para>
        /// <para>
        /// The return value should not be modified or freed and is valid for as
        /// long as @cmdline exists.
        /// </para>
        /// </remarks>
        /// <param name="cmdline">
        /// a #GApplicationCommandLine
        /// </param>
        /// <param name="name">
        /// the environment variable to get
        /// </param>
        /// <returns>
        /// the value of the variable, or %NULL if unset or unsent
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.28")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern byte* g_application_command_line_getenv(
        /* <type name="ApplicationCommandLine" type="GApplicationCommandLine*" managed-name="ApplicationCommandLine" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.ApplicationCommandLine.UnmanagedStruct* cmdline,
        /* <type name="filename" type="const gchar*" managed-name="GISharp.Lib.GLib.Filename" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* name);
        partial void CheckGetEnvironmentVariableArgs(GISharp.Lib.GLib.Filename name);

        /// <include file="ApplicationCommandLine.xmldoc" path="declaration/member[@name='ApplicationCommandLine.GetEnvironmentVariable(GISharp.Lib.GLib.Filename)']/*" />
        [GISharp.Runtime.SinceAttribute("2.28")]
        public GISharp.Lib.GLib.UnownedUtf8 GetEnvironmentVariable(GISharp.Lib.GLib.Filename name)
        {
            CheckGetEnvironmentVariableArgs(name);
            var cmdline_ = (GISharp.Lib.Gio.ApplicationCommandLine.UnmanagedStruct*)UnsafeHandle;
            var name_ = (byte*)name.UnsafeHandle;
            var ret_ = g_application_command_line_getenv(cmdline_,name_);
            var ret = new GISharp.Lib.GLib.UnownedUtf8(ret_);
            return ret;
        }

        /// <summary>
        /// Sets the exit status that will be used when the invoking process
        /// exits.
        /// </summary>
        /// <remarks>
        /// <para>
        /// The return value of the #GApplication::command-line signal is
        /// passed to this function when the handler returns.  This is the usual
        /// way of setting the exit status.
        /// </para>
        /// <para>
        /// In the event that you want the remote invocation to continue running
        /// and want to decide on the exit status in the future, you can use this
        /// call.  For the case of a remote invocation, the remote process will
        /// typically exit when the last reference is dropped on @cmdline.  The
        /// exit status of the remote process will be equal to the last value
        /// that was set with this function.
        /// </para>
        /// <para>
        /// In the case that the commandline invocation is local, the situation
        /// is slightly more complicated.  If the commandline invocation results
        /// in the mainloop running (ie: because the use-count of the application
        /// increased to a non-zero value) then the application is considered to
        /// have been 'successful' in a certain sense, and the exit status is
        /// always zero.  If the application use count is zero, though, the exit
        /// status of the local #GApplicationCommandLine is used.
        /// </para>
        /// </remarks>
        /// <param name="cmdline">
        /// a #GApplicationCommandLine
        /// </param>
        /// <param name="exitStatus">
        /// the exit status
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.28")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_application_command_line_set_exit_status(
        /* <type name="ApplicationCommandLine" type="GApplicationCommandLine*" managed-name="ApplicationCommandLine" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.ApplicationCommandLine.UnmanagedStruct* cmdline,
        /* <type name="gint" type="int" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        int exitStatus);
        partial void CheckSetExitStatusArgs(int exitStatus);

        [GISharp.Runtime.SinceAttribute("2.28")]
        private void SetExitStatus(int exitStatus)
        {
            CheckSetExitStatusArgs(exitStatus);
            var cmdline_ = (GISharp.Lib.Gio.ApplicationCommandLine.UnmanagedStruct*)UnsafeHandle;
            var exitStatus_ = (int)exitStatus;
            g_application_command_line_set_exit_status(cmdline_, exitStatus_);
        }

        /// <include file="ApplicationCommandLine.xmldoc" path="declaration/member[@name='ApplicationCommandLine.DoGetStdin()']/*" />
        [GISharp.Runtime.SinceAttribute("2.34")]
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(ApplicationCommandLineClass.UnmanagedGetStdin))]
        protected virtual GISharp.Lib.Gio.InputStream DoGetStdin()
        {
            var cmdline_ = (GISharp.Lib.Gio.ApplicationCommandLine.UnmanagedStruct*)UnsafeHandle;
            var ret_ = GISharp.Lib.GObject.TypeClass.GetUnmanagedVirtualMethod<ApplicationCommandLineClass.UnmanagedGetStdin>(_GType)!(cmdline_);
            var ret = GISharp.Lib.Gio.InputStream.GetInstance<GISharp.Lib.Gio.InputStream>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <include file="ApplicationCommandLine.xmldoc" path="declaration/member[@name='ApplicationCommandLine.DoPrintLiteral(GISharp.Lib.GLib.UnownedUtf8)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(ApplicationCommandLineClass.UnmanagedPrintLiteral))]
        protected virtual void DoPrintLiteral(GISharp.Lib.GLib.UnownedUtf8 message)
        {
            var cmdline_ = (GISharp.Lib.Gio.ApplicationCommandLine.UnmanagedStruct*)UnsafeHandle;
            var message_ = (byte*)message.UnsafeHandle;
            GISharp.Lib.GObject.TypeClass.GetUnmanagedVirtualMethod<ApplicationCommandLineClass.UnmanagedPrintLiteral>(_GType)!(cmdline_, message_);
        }

        /// <include file="ApplicationCommandLine.xmldoc" path="declaration/member[@name='ApplicationCommandLine.DoPrinterrLiteral(GISharp.Lib.GLib.UnownedUtf8)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(ApplicationCommandLineClass.UnmanagedPrinterrLiteral))]
        protected virtual void DoPrinterrLiteral(GISharp.Lib.GLib.UnownedUtf8 message)
        {
            var cmdline_ = (GISharp.Lib.Gio.ApplicationCommandLine.UnmanagedStruct*)UnsafeHandle;
            var message_ = (byte*)message.UnsafeHandle;
            GISharp.Lib.GObject.TypeClass.GetUnmanagedVirtualMethod<ApplicationCommandLineClass.UnmanagedPrinterrLiteral>(_GType)!(cmdline_, message_);
        }
    }
}