// SPDX-License-Identifier: MIT
// ATTENTION: This file is automatically generated. Do not edit manually.
#nullable enable
namespace GISharp.Lib.Gio
{
    /// <include file="LoadableIcon.xmldoc" path="declaration/member[@name='ILoadableIcon']/*" />
    [GISharp.Runtime.GTypeAttribute("GLoadableIcon", IsProxyForUnmanagedType = true)]
    [GISharp.Runtime.GTypeStructAttribute(typeof(LoadableIconIface))]
    public unsafe partial interface ILoadableIcon : GISharp.Lib.Gio.IIcon, GISharp.Lib.GObject.GInterface<GISharp.Lib.GObject.Object>
    {
        private static readonly GISharp.Runtime.GType _GType = g_loadable_icon_get_type();

        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="GType" type="GType" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Runtime.GType g_loadable_icon_get_type();

        /// <include file="LoadableIcon.xmldoc" path="declaration/member[@name='ILoadableIcon.DoLoad(int,GISharp.Runtime.Utf8,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(LoadableIconIface.UnmanagedLoad))]
        GISharp.Lib.Gio.InputStream DoLoad(int size, out GISharp.Runtime.Utf8 type, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="LoadableIcon.xmldoc" path="declaration/member[@name='ILoadableIcon.DoLoadAsync(int,GISharp.Lib.Gio.AsyncReadyCallback?,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(LoadableIconIface.UnmanagedLoadAsync))]
        void DoLoadAsync(int size, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="LoadableIcon.xmldoc" path="declaration/member[@name='ILoadableIcon.DoLoadFinish(GISharp.Lib.Gio.IAsyncResult,GISharp.Runtime.Utf8)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(LoadableIconIface.UnmanagedLoadFinish))]
        GISharp.Lib.Gio.InputStream DoLoadFinish(GISharp.Lib.Gio.IAsyncResult res, out GISharp.Runtime.Utf8 type);
    }

    /// <summary>
    /// Extension methods for <see cref="ILoadableIcon"/>
    /// </summary>
    public static unsafe partial class LoadableIcon
    {
        /// <summary>
        /// The unmanaged data structure.
        /// </summary>
        public struct UnmanagedStruct
        {
        }

        /// <summary>
        /// Loads a loadable icon. For the asynchronous version of this function,
        /// see g_loadable_icon_load_async().
        /// </summary>
        /// <param name="icon">
        /// a #GLoadableIcon.
        /// </param>
        /// <param name="size">
        /// an integer.
        /// </param>
        /// <param name="type">
        /// a location to store the type of the loaded
        /// icon, %NULL to ignore.
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object, %NULL to
        /// ignore.
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// a #GInputStream to read the icon from.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="InputStream" type="GInputStream*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.Gio.InputStream.UnmanagedStruct* g_loadable_icon_load(
        /* <type name="LoadableIcon" type="GLoadableIcon*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.LoadableIcon.UnmanagedStruct* icon,
        /* <type name="gint" type="int" /> */
        /* transfer-ownership:none direction:in */
        int size,
        /* <type name="utf8" type="char**" is-pointer="1" /> */
        /* direction:out caller-allocates:0 transfer-ownership:full optional:1 allow-none:1 */
        byte** type,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        static partial void CheckLoadArgs(this GISharp.Lib.Gio.ILoadableIcon icon, int size, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="LoadableIcon.xmldoc" path="declaration/member[@name='LoadableIcon.Load(GISharp.Lib.Gio.ILoadableIcon,int,GISharp.Runtime.Utf8,GISharp.Lib.Gio.Cancellable?)']/*" />
        public static GISharp.Lib.Gio.InputStream Load(this GISharp.Lib.Gio.ILoadableIcon icon, int size, out GISharp.Runtime.Utf8 type, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckLoadArgs(icon, size, cancellable);
            var icon_ = (GISharp.Lib.Gio.LoadableIcon.UnmanagedStruct*)icon.UnsafeHandle;
            var size_ = (int)size;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            byte* type_;
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            var ret_ = g_loadable_icon_load(icon_,size_,&type_,cancellable_,&error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Lib.GLib.Error.Exception(error);
            }

            type = GISharp.Runtime.Utf8.GetInstance<GISharp.Runtime.Utf8>((System.IntPtr)type_, GISharp.Runtime.Transfer.Full)!;
            var ret = GISharp.Lib.Gio.InputStream.GetInstance<GISharp.Lib.Gio.InputStream>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Loads an icon asynchronously. To finish this function, see
        /// g_loadable_icon_load_finish(). For the synchronous, blocking
        /// version of this function, see g_loadable_icon_load().
        /// </summary>
        /// <param name="icon">
        /// a #GLoadableIcon.
        /// </param>
        /// <param name="size">
        /// an integer.
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object, %NULL to ignore.
        /// </param>
        /// <param name="callback">
        /// a #GAsyncReadyCallback to call when the
        ///            request is satisfied
        /// </param>
        /// <param name="userData">
        /// the data to pass to callback function
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_loadable_icon_load_async(
        /* <type name="LoadableIcon" type="GLoadableIcon*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.LoadableIcon.UnmanagedStruct* icon,
        /* <type name="gint" type="int" /> */
        /* transfer-ownership:none direction:in */
        int size,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:3 direction:in */
        delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback,
        /* <type name="gpointer" type="gpointer" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr userData);
        static partial void CheckLoadAsyncArgs(this GISharp.Lib.Gio.ILoadableIcon icon, int size, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="LoadableIcon.xmldoc" path="declaration/member[@name='LoadableIcon.LoadAsync(GISharp.Lib.Gio.ILoadableIcon,int,GISharp.Lib.Gio.Cancellable?)']/*" />
        public static System.Threading.Tasks.Task<System.ValueTuple<GISharp.Lib.Gio.InputStream, GISharp.Runtime.Utf8>> LoadAsync(this GISharp.Lib.Gio.ILoadableIcon icon, int size, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckLoadAsyncArgs(icon, size, cancellable);
            var icon_ = (GISharp.Lib.Gio.LoadableIcon.UnmanagedStruct*)icon.UnsafeHandle;
            var size_ = (int)size;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var completionSource = new System.Threading.Tasks.TaskCompletionSource<System.ValueTuple<GISharp.Lib.Gio.InputStream, GISharp.Runtime.Utf8>>();
            var callback_ = (delegate* unmanaged[Cdecl] <GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void>)&LoadFinish;
            var userData_ = (System.IntPtr)System.Runtime.InteropServices.GCHandle.Alloc(completionSource);
            g_loadable_icon_load_async(icon_, size_, cancellable_, callback_, userData_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            return completionSource.Task;
        }

        /// <summary>
        /// Finishes an asynchronous icon load started in g_loadable_icon_load_async().
        /// </summary>
        /// <param name="icon">
        /// a #GLoadableIcon.
        /// </param>
        /// <param name="res">
        /// a #GAsyncResult.
        /// </param>
        /// <param name="type">
        /// a location to store the type of the loaded
        ///        icon, %NULL to ignore.
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// a #GInputStream to read the icon from.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="InputStream" type="GInputStream*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.Gio.InputStream.UnmanagedStruct* g_loadable_icon_load_finish(
        /* <type name="LoadableIcon" type="GLoadableIcon*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.LoadableIcon.UnmanagedStruct* icon,
        /* <type name="AsyncResult" type="GAsyncResult*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res,
        /* <type name="utf8" type="char**" is-pointer="1" /> */
        /* direction:out caller-allocates:0 transfer-ownership:full optional:1 allow-none:1 */
        byte** type,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        [System.Runtime.InteropServices.UnmanagedCallersOnlyAttribute(CallConvs = new[] { typeof(System.Runtime.CompilerServices.CallConvCdecl) })]
        private static void LoadFinish(GISharp.Lib.GObject.Object.UnmanagedStruct* sourceObject_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* res_, System.IntPtr userData_)
        {
            try
            {
                var icon_ = (GISharp.Lib.Gio.LoadableIcon.UnmanagedStruct*)sourceObject_;
                var userData = (System.Runtime.InteropServices.GCHandle)userData_;
                var completionSource = (System.Threading.Tasks.TaskCompletionSource<System.ValueTuple<GISharp.Lib.Gio.InputStream, GISharp.Runtime.Utf8>>)userData.Target!;
                userData.Free();
                byte* type_;
                var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
                var ret_ = g_loadable_icon_load_finish(icon_,res_,&type_,&error_);
                if (error_ is not null)
                {
                    var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                    completionSource.SetException(new GISharp.Lib.GLib.Error.Exception(error));
                    return;
                }
                var type = GISharp.Runtime.Utf8.GetInstance<GISharp.Runtime.Utf8>((System.IntPtr)type_, GISharp.Runtime.Transfer.Full)!;
                var ret = GISharp.Lib.Gio.InputStream.GetInstance<GISharp.Lib.Gio.InputStream>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
                completionSource.SetResult((ret, type));
            }
            catch (System.Exception ex)
            {
                GISharp.Runtime.GMarshal.PushUnhandledException(ex);
            }
        }
    }
}