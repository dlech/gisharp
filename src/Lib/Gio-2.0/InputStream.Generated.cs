// SPDX-License-Identifier: MIT
// ATTENTION: This file is automatically generated. Do not edit manually.
#nullable enable
namespace GISharp.Lib.Gio
{
    /// <include file="InputStream.xmldoc" path="declaration/member[@name='InputStream']/*" />
    [GISharp.Runtime.GTypeAttribute("GInputStream", IsProxyForUnmanagedType = true)]
    [GISharp.Runtime.GTypeStructAttribute(typeof(InputStreamClass))]
    public abstract unsafe partial class InputStream : GISharp.Lib.GObject.Object
    {
        private static readonly GISharp.Runtime.GType _GType = g_input_stream_get_type();

        /// <summary>
        /// The unmanaged data structure.
        /// </summary>
        public new struct UnmanagedStruct
        {
#pragma warning disable CS0169, CS0414, CS0649
            /// <include file="InputStream.xmldoc" path="declaration/member[@name='UnmanagedStruct.ParentInstance']/*" />
            public readonly GISharp.Lib.GObject.Object.UnmanagedStruct ParentInstance;

            /// <include file="InputStream.xmldoc" path="declaration/member[@name='UnmanagedStruct.Priv']/*" />
            internal readonly System.IntPtr Priv;
#pragma warning restore CS0169, CS0414, CS0649
        }

        /// <include file="InputStream.xmldoc" path="declaration/member[@name='InputStream.IsClosed']/*" />
        public bool IsClosed { get => GetIsClosed(); }

        /// <summary>
        /// For internal runtime use only.
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        protected InputStream(System.IntPtr handle, GISharp.Runtime.Transfer ownership) : base(handle, ownership)
        {
        }

        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="GType" type="GType" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Runtime.GType g_input_stream_get_type();

        /// <summary>
        /// Clears the pending flag on @stream.
        /// </summary>
        /// <param name="stream">
        /// input stream
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_input_stream_clear_pending(
        /* <type name="InputStream" type="GInputStream*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.InputStream.UnmanagedStruct* stream);
        partial void CheckClearPendingArgs();

        /// <include file="InputStream.xmldoc" path="declaration/member[@name='InputStream.ClearPending()']/*" />
        public void ClearPending()
        {
            CheckClearPendingArgs();
            var stream_ = (GISharp.Lib.Gio.InputStream.UnmanagedStruct*)UnsafeHandle;
            g_input_stream_clear_pending(stream_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
        }

        /// <summary>
        /// Closes the stream, releasing resources related to it.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Once the stream is closed, all other operations will return %G_IO_ERROR_CLOSED.
        /// Closing a stream multiple times will not return an error.
        /// </para>
        /// <para>
        /// Streams will be automatically closed when the last reference
        /// is dropped, but you might want to call this function to make sure
        /// resources are released as early as possible.
        /// </para>
        /// <para>
        /// Some streams might keep the backing store of the stream (e.g. a file descriptor)
        /// open after the stream is closed. See the documentation for the individual
        /// stream for details.
        /// </para>
        /// <para>
        /// On failure the first error that happened will be reported, but the close
        /// operation will finish as much as possible. A stream that failed to
        /// close will still return %G_IO_ERROR_CLOSED for all operations. Still, it
        /// is important to check and report the error to the user.
        /// </para>
        /// <para>
        /// If @cancellable is not %NULL, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
        /// Cancelling a close will still leave the stream closed, but some streams
        /// can use a faster close that doesn't block to e.g. check errors.
        /// </para>
        /// </remarks>
        /// <param name="stream">
        /// A #GInputStream.
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object, %NULL to ignore.
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// %TRUE on success, %FALSE on failure
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        private static extern GISharp.Runtime.Boolean g_input_stream_close(
        /* <type name="InputStream" type="GInputStream*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.InputStream.UnmanagedStruct* stream,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        partial void CheckCloseArgs(GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="InputStream.xmldoc" path="declaration/member[@name='InputStream.Close(GISharp.Lib.Gio.Cancellable?)']/*" />
        public void Close(GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckCloseArgs(cancellable);
            var stream_ = (GISharp.Lib.Gio.InputStream.UnmanagedStruct*)UnsafeHandle;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            g_input_stream_close(stream_, cancellable_, &error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Lib.GLib.Error.Exception(error);
            }
        }

        /// <summary>
        /// Requests an asynchronous closes of the stream, releasing resources related to it.
        /// When the operation is finished @callback will be called.
        /// You can then call g_input_stream_close_finish() to get the result of the
        /// operation.
        /// </summary>
        /// <remarks>
        /// <para>
        /// For behaviour details see g_input_stream_close().
        /// </para>
        /// <para>
        /// The asynchronous methods have a default fallback that uses threads to implement
        /// asynchronicity, so they are optional for inheriting classes. However, if you
        /// override one you must override all.
        /// </para>
        /// </remarks>
        /// <param name="stream">
        /// A #GInputStream.
        /// </param>
        /// <param name="ioPriority">
        /// the [I/O priority][io-priority] of the request
        /// </param>
        /// <param name="cancellable">
        /// optional cancellable object
        /// </param>
        /// <param name="callback">
        /// callback to call when the request is satisfied
        /// </param>
        /// <param name="userData">
        /// the data to pass to callback function
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Threading.Tasks.Task" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_input_stream_close_async(
        /* <type name="InputStream" type="GInputStream*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.InputStream.UnmanagedStruct* stream,
        /* <type name="gint" type="int" /> */
        /* transfer-ownership:none direction:in */
        int ioPriority,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:3 direction:in */
        delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback,
        /* <type name="gpointer" type="gpointer" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr userData);
        partial void CheckCloseAsyncArgs(int ioPriority = GISharp.Lib.GLib.Priority.Default, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="InputStream.xmldoc" path="declaration/member[@name='InputStream.CloseAsync(int,GISharp.Lib.Gio.Cancellable?)']/*" />
        public System.Threading.Tasks.Task CloseAsync(int ioPriority = GISharp.Lib.GLib.Priority.Default, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckCloseAsyncArgs(ioPriority, cancellable);
            var stream_ = (GISharp.Lib.Gio.InputStream.UnmanagedStruct*)UnsafeHandle;
            var ioPriority_ = (int)ioPriority;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var completionSource = new System.Threading.Tasks.TaskCompletionSource<System.ValueTuple>();
            var callback_ = (delegate* unmanaged[Cdecl] <GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void>)&CloseFinish;
            var userData_ = (System.IntPtr)System.Runtime.InteropServices.GCHandle.Alloc(completionSource);
            g_input_stream_close_async(stream_, ioPriority_, cancellable_, callback_, userData_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            return completionSource.Task;
        }

        /// <summary>
        /// Finishes closing a stream asynchronously, started from g_input_stream_close_async().
        /// </summary>
        /// <param name="stream">
        /// a #GInputStream.
        /// </param>
        /// <param name="result">
        /// a #GAsyncResult.
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// %TRUE if the stream was closed successfully.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        private static extern GISharp.Runtime.Boolean g_input_stream_close_finish(
        /* <type name="InputStream" type="GInputStream*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.InputStream.UnmanagedStruct* stream,
        /* <type name="AsyncResult" type="GAsyncResult*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        [System.Runtime.InteropServices.UnmanagedCallersOnlyAttribute(CallConvs = new[] { typeof(System.Runtime.CompilerServices.CallConvCdecl) })]
        private static void CloseFinish(GISharp.Lib.GObject.Object.UnmanagedStruct* sourceObject_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result_, System.IntPtr userData_)
        {
            try
            {
                var stream_ = (GISharp.Lib.Gio.InputStream.UnmanagedStruct*)sourceObject_;
                var userData = (System.Runtime.InteropServices.GCHandle)userData_;
                var completionSource = (System.Threading.Tasks.TaskCompletionSource<System.ValueTuple>)userData.Target!;
                userData.Free();
                var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
                g_input_stream_close_finish(stream_, result_, &error_);
                if (error_ is not null)
                {
                    var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                    completionSource.SetException(new GISharp.Lib.GLib.Error.Exception(error));
                    return;
                }
                completionSource.SetResult(default(System.ValueTuple));
            }
            catch (System.Exception ex)
            {
                GISharp.Runtime.GMarshal.PushUnhandledException(ex);
            }
        }

        /// <summary>
        /// Checks if an input stream has pending actions.
        /// </summary>
        /// <param name="stream">
        /// input stream.
        /// </param>
        /// <returns>
        /// %TRUE if @stream has pending actions.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_input_stream_has_pending(
        /* <type name="InputStream" type="GInputStream*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.InputStream.UnmanagedStruct* stream);
        partial void CheckHasPendingArgs();

        /// <include file="InputStream.xmldoc" path="declaration/member[@name='InputStream.HasPending()']/*" />
        public bool HasPending()
        {
            CheckHasPendingArgs();
            var stream_ = (GISharp.Lib.Gio.InputStream.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_input_stream_has_pending(stream_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Checks if an input stream is closed.
        /// </summary>
        /// <param name="stream">
        /// input stream.
        /// </param>
        /// <returns>
        /// %TRUE if the stream is closed.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_input_stream_is_closed(
        /* <type name="InputStream" type="GInputStream*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.InputStream.UnmanagedStruct* stream);
        partial void CheckGetIsClosedArgs();

        private bool GetIsClosed()
        {
            CheckGetIsClosedArgs();
            var stream_ = (GISharp.Lib.Gio.InputStream.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_input_stream_is_closed(stream_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Tries to read @count bytes from the stream into the buffer starting at
        /// @buffer. Will block during this read.
        /// </summary>
        /// <remarks>
        /// <para>
        /// If count is zero returns zero and does nothing. A value of @count
        /// larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
        /// </para>
        /// <para>
        /// On success, the number of bytes read into the buffer is returned.
        /// It is not an error if this is not the same as the requested size, as it
        /// can happen e.g. near the end of a file. Zero is returned on end of file
        /// (or if @count is zero),  but never otherwise.
        /// </para>
        /// <para>
        /// The returned @buffer is not a nul-terminated string, it can contain nul bytes
        /// at any position, and this function doesn't nul-terminate the @buffer.
        /// </para>
        /// <para>
        /// If @cancellable is not %NULL, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
        /// operation was partially finished when the operation was cancelled the
        /// partial result will be returned, without an error.
        /// </para>
        /// <para>
        /// On error -1 is returned and @error is set accordingly.
        /// </para>
        /// </remarks>
        /// <param name="stream">
        /// a #GInputStream.
        /// </param>
        /// <param name="buffer">
        /// 
        ///     a buffer to read data into (which should be at least count bytes long).
        /// </param>
        /// <param name="count">
        /// the number of bytes that will be read from the stream
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object, %NULL to ignore.
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// Number of bytes read, or -1 on error, or 0 on end of file.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gssize" type="gssize" /> */
        /* transfer-ownership:none direction:in */
        private static extern nint g_input_stream_read(
        /* <type name="InputStream" type="GInputStream*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.InputStream.UnmanagedStruct* stream,
        /* <array length="1" zero-terminated="0" type="void*" is-pointer="1">
*   <type name="guint8" />
* </array> */
        /* direction:out caller-allocates:1 transfer-ownership:none */
        byte* buffer,
        /* <type name="gsize" type="gsize" /> */
        /* direction:in caller-allocates:0 transfer-ownership:full */
        nuint count,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        partial void CheckReadArgs(GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="InputStream.xmldoc" path="declaration/member[@name='InputStream.Read(System.Span&lt;byte&gt;,GISharp.Lib.Gio.Cancellable?)']/*" />
        public int Read(System.Span<byte> buffer, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            fixed (byte* bufferData_ = buffer)
            {
                CheckReadArgs(cancellable);
                var stream_ = (GISharp.Lib.Gio.InputStream.UnmanagedStruct*)UnsafeHandle;
                var buffer_ = (byte*)bufferData_;
                var count_ = (nuint)buffer.Length;
                var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
                var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
                var ret_ = g_input_stream_read(stream_,buffer_,count_,cancellable_,&error_);
                GISharp.Runtime.GMarshal.PopUnhandledException();
                if (error_ is not null)
                {
                    var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                    throw new GISharp.Lib.GLib.Error.Exception(error);
                }

                var ret = (int)ret_;
                return ret;
            }
        }

        /// <summary>
        /// Tries to read @count bytes from the stream into the buffer starting at
        /// @buffer. Will block during this read.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This function is similar to g_input_stream_read(), except it tries to
        /// read as many bytes as requested, only stopping on an error or end of stream.
        /// </para>
        /// <para>
        /// On a successful read of @count bytes, or if we reached the end of the
        /// stream,  %TRUE is returned, and @bytes_read is set to the number of bytes
        /// read into @buffer.
        /// </para>
        /// <para>
        /// If there is an error during the operation %FALSE is returned and @error
        /// is set to indicate the error status.
        /// </para>
        /// <para>
        /// As a special exception to the normal conventions for functions that
        /// use #GError, if this function returns %FALSE (and sets @error) then
        /// @bytes_read will be set to the number of bytes that were successfully
        /// read before the error was encountered.  This functionality is only
        /// available from C.  If you need it from another language then you must
        /// write your own loop around g_input_stream_read().
        /// </para>
        /// </remarks>
        /// <param name="stream">
        /// a #GInputStream.
        /// </param>
        /// <param name="buffer">
        /// 
        ///     a buffer to read data into (which should be at least count bytes long).
        /// </param>
        /// <param name="count">
        /// the number of bytes that will be read from the stream
        /// </param>
        /// <param name="bytesRead">
        /// location to store the number of bytes that was read from the stream
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object, %NULL to ignore.
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// %TRUE on success, %FALSE if there was an error
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        private static extern GISharp.Runtime.Boolean g_input_stream_read_all(
        /* <type name="InputStream" type="GInputStream*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.InputStream.UnmanagedStruct* stream,
        /* <array length="1" zero-terminated="0" type="void*" is-pointer="1">
*   <type name="guint8" />
* </array> */
        /* direction:out caller-allocates:1 transfer-ownership:none */
        byte* buffer,
        /* <type name="gsize" type="gsize" /> */
        /* direction:in caller-allocates:0 transfer-ownership:full */
        nuint count,
        /* <type name="gsize" type="gsize*" /> */
        /* direction:out caller-allocates:0 transfer-ownership:full */
        nuint* bytesRead,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        partial void CheckReadAllArgs(GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="InputStream.xmldoc" path="declaration/member[@name='InputStream.ReadAll(System.Span&lt;byte&gt;,int,GISharp.Lib.Gio.Cancellable?)']/*" />
        public void ReadAll(System.Span<byte> buffer, out int bytesRead, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            fixed (byte* bufferData_ = buffer)
            {
                CheckReadAllArgs(cancellable);
                var stream_ = (GISharp.Lib.Gio.InputStream.UnmanagedStruct*)UnsafeHandle;
                var buffer_ = (byte*)bufferData_;
                var count_ = (nuint)buffer.Length;
                var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
                nuint bytesRead_;
                var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
                g_input_stream_read_all(stream_, buffer_, count_, &bytesRead_, cancellable_, &error_);
                GISharp.Runtime.GMarshal.PopUnhandledException();
                if (error_ is not null)
                {
                    var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                    throw new GISharp.Lib.GLib.Error.Exception(error);
                }

                bytesRead = (int)bytesRead_;
            }
        }

        /// <summary>
        /// Request an asynchronous read of @count bytes from the stream into the
        /// buffer starting at @buffer.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This is the asynchronous equivalent of g_input_stream_read_all().
        /// </para>
        /// <para>
        /// Call g_input_stream_read_all_finish() to collect the result.
        /// </para>
        /// <para>
        /// Any outstanding I/O request with higher priority (lower numerical
        /// value) will be executed before an outstanding request with lower
        /// priority. Default priority is %G_PRIORITY_DEFAULT.
        /// </para>
        /// </remarks>
        /// <param name="stream">
        /// A #GInputStream
        /// </param>
        /// <param name="buffer">
        /// 
        ///     a buffer to read data into (which should be at least count bytes long)
        /// </param>
        /// <param name="count">
        /// the number of bytes that will be read from the stream
        /// </param>
        /// <param name="ioPriority">
        /// the [I/O priority][io-priority] of the request
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object, %NULL to ignore
        /// </param>
        /// <param name="callback">
        /// callback to call when the request is satisfied
        /// </param>
        /// <param name="userData">
        /// the data to pass to callback function
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.44")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Threading.Tasks.Task">
*   <type name="gsize" type="gsize*" />
* </type> */
        /* transfer-ownership:none direction:in */
        private static extern void g_input_stream_read_all_async(
        /* <type name="InputStream" type="GInputStream*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.InputStream.UnmanagedStruct* stream,
        /* <array length="1" zero-terminated="0" type="void*" is-pointer="1">
*   <type name="guint8" />
* </array> */
        /* direction:out caller-allocates:1 transfer-ownership:none */
        byte* buffer,
        /* <type name="gsize" type="gsize" /> */
        /* direction:in caller-allocates:0 transfer-ownership:full */
        nuint count,
        /* <type name="gint" type="int" /> */
        /* transfer-ownership:none direction:in */
        int ioPriority,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:5 direction:in */
        delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback,
        /* <type name="gpointer" type="gpointer" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr userData);
        partial void CheckReadAllAsyncArgs(int ioPriority = GISharp.Lib.GLib.Priority.Default, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="InputStream.xmldoc" path="declaration/member[@name='InputStream.ReadAllAsync(System.Memory&lt;byte&gt;,int,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.SinceAttribute("2.44")]
        public System.Threading.Tasks.Task<int> ReadAllAsync(System.Memory<byte> buffer, int ioPriority = GISharp.Lib.GLib.Priority.Default, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckReadAllAsyncArgs(ioPriority, cancellable);
            var stream_ = (GISharp.Lib.Gio.InputStream.UnmanagedStruct*)UnsafeHandle;
            var buffer_ = (byte*)buffer.Pin().Pointer;
            var count_ = (nuint)buffer.Length;
            var ioPriority_ = (int)ioPriority;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var completionSource = new System.Threading.Tasks.TaskCompletionSource<int>();
            var callback_ = (delegate* unmanaged[Cdecl] <GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void>)&ReadAllFinish;
            var userData_ = (System.IntPtr)System.Runtime.InteropServices.GCHandle.Alloc(completionSource);
            g_input_stream_read_all_async(stream_, buffer_, count_, ioPriority_, cancellable_, callback_, userData_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            return completionSource.Task;
        }

        /// <summary>
        /// Finishes an asynchronous stream read operation started with
        /// g_input_stream_read_all_async().
        /// </summary>
        /// <remarks>
        /// <para>
        /// As a special exception to the normal conventions for functions that
        /// use #GError, if this function returns %FALSE (and sets @error) then
        /// @bytes_read will be set to the number of bytes that were successfully
        /// read before the error was encountered.  This functionality is only
        /// available from C.  If you need it from another language then you must
        /// write your own loop around g_input_stream_read_async().
        /// </para>
        /// </remarks>
        /// <param name="stream">
        /// a #GInputStream
        /// </param>
        /// <param name="result">
        /// a #GAsyncResult
        /// </param>
        /// <param name="bytesRead">
        /// location to store the number of bytes that was read from the stream
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// %TRUE on success, %FALSE if there was an error
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.44")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        private static extern GISharp.Runtime.Boolean g_input_stream_read_all_finish(
        /* <type name="InputStream" type="GInputStream*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.InputStream.UnmanagedStruct* stream,
        /* <type name="AsyncResult" type="GAsyncResult*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result,
        /* <type name="gsize" type="gsize*" /> */
        /* direction:out caller-allocates:0 transfer-ownership:full */
        nuint* bytesRead,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        [System.Runtime.InteropServices.UnmanagedCallersOnlyAttribute(CallConvs = new[] { typeof(System.Runtime.CompilerServices.CallConvCdecl) })]
        private static void ReadAllFinish(GISharp.Lib.GObject.Object.UnmanagedStruct* sourceObject_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result_, System.IntPtr userData_)
        {
            try
            {
                var stream_ = (GISharp.Lib.Gio.InputStream.UnmanagedStruct*)sourceObject_;
                var userData = (System.Runtime.InteropServices.GCHandle)userData_;
                var completionSource = (System.Threading.Tasks.TaskCompletionSource<int>)userData.Target!;
                userData.Free();
                nuint bytesRead_;
                var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
                g_input_stream_read_all_finish(stream_, result_, &bytesRead_, &error_);
                if (error_ is not null)
                {
                    var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                    completionSource.SetException(new GISharp.Lib.GLib.Error.Exception(error));
                    return;
                }
                var bytesRead = (int)bytesRead_;
                completionSource.SetResult((bytesRead));
            }
            catch (System.Exception ex)
            {
                GISharp.Runtime.GMarshal.PushUnhandledException(ex);
            }
        }

        /// <summary>
        /// Request an asynchronous read of @count bytes from the stream into the buffer
        /// starting at @buffer. When the operation is finished @callback will be called.
        /// You can then call g_input_stream_read_finish() to get the result of the
        /// operation.
        /// </summary>
        /// <remarks>
        /// <para>
        /// During an async request no other sync and async calls are allowed on @stream, and will
        /// result in %G_IO_ERROR_PENDING errors.
        /// </para>
        /// <para>
        /// A value of @count larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
        /// </para>
        /// <para>
        /// On success, the number of bytes read into the buffer will be passed to the
        /// callback. It is not an error if this is not the same as the requested size, as it
        /// can happen e.g. near the end of a file, but generally we try to read
        /// as many bytes as requested. Zero is returned on end of file
        /// (or if @count is zero),  but never otherwise.
        /// </para>
        /// <para>
        /// Any outstanding i/o request with higher priority (lower numerical value) will
        /// be executed before an outstanding request with lower priority. Default
        /// priority is %G_PRIORITY_DEFAULT.
        /// </para>
        /// <para>
        /// The asynchronous methods have a default fallback that uses threads to implement
        /// asynchronicity, so they are optional for inheriting classes. However, if you
        /// override one you must override all.
        /// </para>
        /// </remarks>
        /// <param name="stream">
        /// A #GInputStream.
        /// </param>
        /// <param name="buffer">
        /// 
        ///     a buffer to read data into (which should be at least count bytes long).
        /// </param>
        /// <param name="count">
        /// the number of bytes that will be read from the stream
        /// </param>
        /// <param name="ioPriority">
        /// the [I/O priority][io-priority]
        /// of the request.
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object, %NULL to ignore.
        /// </param>
        /// <param name="callback">
        /// callback to call when the request is satisfied
        /// </param>
        /// <param name="userData">
        /// the data to pass to callback function
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Threading.Tasks.Task">
*   <type name="gssize" type="gssize" />
* </type> */
        /* transfer-ownership:none direction:in */
        private static extern void g_input_stream_read_async(
        /* <type name="InputStream" type="GInputStream*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.InputStream.UnmanagedStruct* stream,
        /* <array length="1" zero-terminated="0" type="void*" is-pointer="1">
*   <type name="guint8" />
* </array> */
        /* direction:out caller-allocates:1 transfer-ownership:none */
        byte* buffer,
        /* <type name="gsize" type="gsize" /> */
        /* direction:in caller-allocates:0 transfer-ownership:full */
        nuint count,
        /* <type name="gint" type="int" /> */
        /* transfer-ownership:none direction:in */
        int ioPriority,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:5 direction:in */
        delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback,
        /* <type name="gpointer" type="gpointer" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr userData);
        partial void CheckReadAsyncArgs(int ioPriority = GISharp.Lib.GLib.Priority.Default, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="InputStream.xmldoc" path="declaration/member[@name='InputStream.ReadAsync(System.Memory&lt;byte&gt;,int,GISharp.Lib.Gio.Cancellable?)']/*" />
        public System.Threading.Tasks.Task<int> ReadAsync(System.Memory<byte> buffer, int ioPriority = GISharp.Lib.GLib.Priority.Default, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckReadAsyncArgs(ioPriority, cancellable);
            var stream_ = (GISharp.Lib.Gio.InputStream.UnmanagedStruct*)UnsafeHandle;
            var buffer_ = (byte*)buffer.Pin().Pointer;
            var count_ = (nuint)buffer.Length;
            var ioPriority_ = (int)ioPriority;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var completionSource = new System.Threading.Tasks.TaskCompletionSource<int>();
            var callback_ = (delegate* unmanaged[Cdecl] <GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void>)&ReadFinish;
            var userData_ = (System.IntPtr)System.Runtime.InteropServices.GCHandle.Alloc(completionSource);
            g_input_stream_read_async(stream_, buffer_, count_, ioPriority_, cancellable_, callback_, userData_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            return completionSource.Task;
        }

        /// <summary>
        /// Like g_input_stream_read(), this tries to read @count bytes from
        /// the stream in a blocking fashion. However, rather than reading into
        /// a user-supplied buffer, this will create a new #GBytes containing
        /// the data that was read. This may be easier to use from language
        /// bindings.
        /// </summary>
        /// <remarks>
        /// <para>
        /// If count is zero, returns a zero-length #GBytes and does nothing. A
        /// value of @count larger than %G_MAXSSIZE will cause a
        /// %G_IO_ERROR_INVALID_ARGUMENT error.
        /// </para>
        /// <para>
        /// On success, a new #GBytes is returned. It is not an error if the
        /// size of this object is not the same as the requested size, as it
        /// can happen e.g. near the end of a file. A zero-length #GBytes is
        /// returned on end of file (or if @count is zero), but never
        /// otherwise.
        /// </para>
        /// <para>
        /// If @cancellable is not %NULL, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
        /// operation was partially finished when the operation was cancelled the
        /// partial result will be returned, without an error.
        /// </para>
        /// <para>
        /// On error %NULL is returned and @error is set accordingly.
        /// </para>
        /// </remarks>
        /// <param name="stream">
        /// a #GInputStream.
        /// </param>
        /// <param name="count">
        /// maximum number of bytes that will be read from the stream. Common
        /// values include 4096 and 8192.
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object, %NULL to ignore.
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// a new #GBytes, or %NULL on error
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.34")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="GLib.Bytes" type="GBytes*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GLib.Bytes.UnmanagedStruct* g_input_stream_read_bytes(
        /* <type name="InputStream" type="GInputStream*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.InputStream.UnmanagedStruct* stream,
        /* <type name="gsize" type="gsize" /> */
        /* transfer-ownership:none direction:in */
        nuint count,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        partial void CheckReadBytesArgs(int count, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="InputStream.xmldoc" path="declaration/member[@name='InputStream.ReadBytes(int,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.SinceAttribute("2.34")]
        public GISharp.Lib.GLib.Bytes ReadBytes(int count, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckReadBytesArgs(count, cancellable);
            var stream_ = (GISharp.Lib.Gio.InputStream.UnmanagedStruct*)UnsafeHandle;
            var count_ = (nuint)count;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            var ret_ = g_input_stream_read_bytes(stream_,count_,cancellable_,&error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Lib.GLib.Error.Exception(error);
            }

            var ret = GISharp.Lib.GLib.Bytes.GetInstance<GISharp.Lib.GLib.Bytes>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Request an asynchronous read of @count bytes from the stream into a
        /// new #GBytes. When the operation is finished @callback will be
        /// called. You can then call g_input_stream_read_bytes_finish() to get the
        /// result of the operation.
        /// </summary>
        /// <remarks>
        /// <para>
        /// During an async request no other sync and async calls are allowed
        /// on @stream, and will result in %G_IO_ERROR_PENDING errors.
        /// </para>
        /// <para>
        /// A value of @count larger than %G_MAXSSIZE will cause a
        /// %G_IO_ERROR_INVALID_ARGUMENT error.
        /// </para>
        /// <para>
        /// On success, the new #GBytes will be passed to the callback. It is
        /// not an error if this is smaller than the requested size, as it can
        /// happen e.g. near the end of a file, but generally we try to read as
        /// many bytes as requested. Zero is returned on end of file (or if
        /// @count is zero), but never otherwise.
        /// </para>
        /// <para>
        /// Any outstanding I/O request with higher priority (lower numerical
        /// value) will be executed before an outstanding request with lower
        /// priority. Default priority is %G_PRIORITY_DEFAULT.
        /// </para>
        /// </remarks>
        /// <param name="stream">
        /// A #GInputStream.
        /// </param>
        /// <param name="count">
        /// the number of bytes that will be read from the stream
        /// </param>
        /// <param name="ioPriority">
        /// the [I/O priority][io-priority] of the request
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object, %NULL to ignore.
        /// </param>
        /// <param name="callback">
        /// callback to call when the request is satisfied
        /// </param>
        /// <param name="userData">
        /// the data to pass to callback function
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.34")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Threading.Tasks.Task">
*   <type name="GLib.Bytes" type="GBytes*" is-pointer="1" />
* </type> */
        /* transfer-ownership:none direction:in */
        private static extern void g_input_stream_read_bytes_async(
        /* <type name="InputStream" type="GInputStream*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.InputStream.UnmanagedStruct* stream,
        /* <type name="gsize" type="gsize" /> */
        /* transfer-ownership:none direction:in */
        nuint count,
        /* <type name="gint" type="int" /> */
        /* transfer-ownership:none direction:in */
        int ioPriority,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:4 direction:in */
        delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback,
        /* <type name="gpointer" type="gpointer" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr userData);
        partial void CheckReadBytesAsyncArgs(int count, int ioPriority = GISharp.Lib.GLib.Priority.Default, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="InputStream.xmldoc" path="declaration/member[@name='InputStream.ReadBytesAsync(int,int,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.SinceAttribute("2.34")]
        public System.Threading.Tasks.Task<GISharp.Lib.GLib.Bytes> ReadBytesAsync(int count, int ioPriority = GISharp.Lib.GLib.Priority.Default, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckReadBytesAsyncArgs(count, ioPriority, cancellable);
            var stream_ = (GISharp.Lib.Gio.InputStream.UnmanagedStruct*)UnsafeHandle;
            var count_ = (nuint)count;
            var ioPriority_ = (int)ioPriority;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var completionSource = new System.Threading.Tasks.TaskCompletionSource<GISharp.Lib.GLib.Bytes>();
            var callback_ = (delegate* unmanaged[Cdecl] <GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void>)&ReadBytesFinish;
            var userData_ = (System.IntPtr)System.Runtime.InteropServices.GCHandle.Alloc(completionSource);
            g_input_stream_read_bytes_async(stream_, count_, ioPriority_, cancellable_, callback_, userData_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            return completionSource.Task;
        }

        /// <summary>
        /// Finishes an asynchronous stream read-into-#GBytes operation.
        /// </summary>
        /// <param name="stream">
        /// a #GInputStream.
        /// </param>
        /// <param name="result">
        /// a #GAsyncResult.
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// the newly-allocated #GBytes, or %NULL on error
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.34")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="GLib.Bytes" type="GBytes*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GLib.Bytes.UnmanagedStruct* g_input_stream_read_bytes_finish(
        /* <type name="InputStream" type="GInputStream*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.InputStream.UnmanagedStruct* stream,
        /* <type name="AsyncResult" type="GAsyncResult*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        [System.Runtime.InteropServices.UnmanagedCallersOnlyAttribute(CallConvs = new[] { typeof(System.Runtime.CompilerServices.CallConvCdecl) })]
        private static void ReadBytesFinish(GISharp.Lib.GObject.Object.UnmanagedStruct* sourceObject_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result_, System.IntPtr userData_)
        {
            try
            {
                var stream_ = (GISharp.Lib.Gio.InputStream.UnmanagedStruct*)sourceObject_;
                var userData = (System.Runtime.InteropServices.GCHandle)userData_;
                var completionSource = (System.Threading.Tasks.TaskCompletionSource<GISharp.Lib.GLib.Bytes>)userData.Target!;
                userData.Free();
                var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
                var ret_ = g_input_stream_read_bytes_finish(stream_,result_,&error_);
                if (error_ is not null)
                {
                    var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                    completionSource.SetException(new GISharp.Lib.GLib.Error.Exception(error));
                    return;
                }
                var ret = GISharp.Lib.GLib.Bytes.GetInstance<GISharp.Lib.GLib.Bytes>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
                completionSource.SetResult((ret));
            }
            catch (System.Exception ex)
            {
                GISharp.Runtime.GMarshal.PushUnhandledException(ex);
            }
        }

        /// <summary>
        /// Finishes an asynchronous stream read operation.
        /// </summary>
        /// <param name="stream">
        /// a #GInputStream.
        /// </param>
        /// <param name="result">
        /// a #GAsyncResult.
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// number of bytes read in, or -1 on error, or 0 on end of file.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gssize" type="gssize" /> */
        /* transfer-ownership:none direction:in */
        private static extern nint g_input_stream_read_finish(
        /* <type name="InputStream" type="GInputStream*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.InputStream.UnmanagedStruct* stream,
        /* <type name="AsyncResult" type="GAsyncResult*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        [System.Runtime.InteropServices.UnmanagedCallersOnlyAttribute(CallConvs = new[] { typeof(System.Runtime.CompilerServices.CallConvCdecl) })]
        private static void ReadFinish(GISharp.Lib.GObject.Object.UnmanagedStruct* sourceObject_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result_, System.IntPtr userData_)
        {
            try
            {
                var stream_ = (GISharp.Lib.Gio.InputStream.UnmanagedStruct*)sourceObject_;
                var userData = (System.Runtime.InteropServices.GCHandle)userData_;
                var completionSource = (System.Threading.Tasks.TaskCompletionSource<int>)userData.Target!;
                userData.Free();
                var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
                var ret_ = g_input_stream_read_finish(stream_,result_,&error_);
                if (error_ is not null)
                {
                    var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                    completionSource.SetException(new GISharp.Lib.GLib.Error.Exception(error));
                    return;
                }
                var ret = (int)ret_;
                completionSource.SetResult((ret));
            }
            catch (System.Exception ex)
            {
                GISharp.Runtime.GMarshal.PushUnhandledException(ex);
            }
        }

        /// <summary>
        /// Sets @stream to have actions pending. If the pending flag is
        /// already set or @stream is closed, it will return %FALSE and set
        /// @error.
        /// </summary>
        /// <param name="stream">
        /// input stream
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// %TRUE if pending was previously unset and is now set.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none skip:1 direction:in */
        private static extern GISharp.Runtime.Boolean g_input_stream_set_pending(
        /* <type name="InputStream" type="GInputStream*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.InputStream.UnmanagedStruct* stream,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        partial void CheckSetPendingArgs();

        /// <include file="InputStream.xmldoc" path="declaration/member[@name='InputStream.SetPending()']/*" />
        public void SetPending()
        {
            CheckSetPendingArgs();
            var stream_ = (GISharp.Lib.Gio.InputStream.UnmanagedStruct*)UnsafeHandle;
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            g_input_stream_set_pending(stream_, &error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Lib.GLib.Error.Exception(error);
            }
        }

        /// <summary>
        /// Tries to skip @count bytes from the stream. Will block during the operation.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This is identical to g_input_stream_read(), from a behaviour standpoint,
        /// but the bytes that are skipped are not returned to the user. Some
        /// streams have an implementation that is more efficient than reading the data.
        /// </para>
        /// <para>
        /// This function is optional for inherited classes, as the default implementation
        /// emulates it using read.
        /// </para>
        /// <para>
        /// If @cancellable is not %NULL, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
        /// operation was partially finished when the operation was cancelled the
        /// partial result will be returned, without an error.
        /// </para>
        /// </remarks>
        /// <param name="stream">
        /// a #GInputStream.
        /// </param>
        /// <param name="count">
        /// the number of bytes that will be skipped from the stream
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object, %NULL to ignore.
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// Number of bytes skipped, or -1 on error
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gssize" type="gssize" /> */
        /* transfer-ownership:none direction:in */
        private static extern nint g_input_stream_skip(
        /* <type name="InputStream" type="GInputStream*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.InputStream.UnmanagedStruct* stream,
        /* <type name="gsize" type="gsize" /> */
        /* transfer-ownership:none direction:in */
        nuint count,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        partial void CheckSkipArgs(int count, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="InputStream.xmldoc" path="declaration/member[@name='InputStream.Skip(int,GISharp.Lib.Gio.Cancellable?)']/*" />
        public int Skip(int count, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckSkipArgs(count, cancellable);
            var stream_ = (GISharp.Lib.Gio.InputStream.UnmanagedStruct*)UnsafeHandle;
            var count_ = (nuint)count;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            var ret_ = g_input_stream_skip(stream_,count_,cancellable_,&error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Lib.GLib.Error.Exception(error);
            }

            var ret = (int)ret_;
            return ret;
        }

        /// <summary>
        /// Request an asynchronous skip of @count bytes from the stream.
        /// When the operation is finished @callback will be called.
        /// You can then call g_input_stream_skip_finish() to get the result
        /// of the operation.
        /// </summary>
        /// <remarks>
        /// <para>
        /// During an async request no other sync and async calls are allowed,
        /// and will result in %G_IO_ERROR_PENDING errors.
        /// </para>
        /// <para>
        /// A value of @count larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.
        /// </para>
        /// <para>
        /// On success, the number of bytes skipped will be passed to the callback.
        /// It is not an error if this is not the same as the requested size, as it
        /// can happen e.g. near the end of a file, but generally we try to skip
        /// as many bytes as requested. Zero is returned on end of file
        /// (or if @count is zero), but never otherwise.
        /// </para>
        /// <para>
        /// Any outstanding i/o request with higher priority (lower numerical value)
        /// will be executed before an outstanding request with lower priority.
        /// Default priority is %G_PRIORITY_DEFAULT.
        /// </para>
        /// <para>
        /// The asynchronous methods have a default fallback that uses threads to
        /// implement asynchronicity, so they are optional for inheriting classes.
        /// However, if you override one, you must override all.
        /// </para>
        /// </remarks>
        /// <param name="stream">
        /// A #GInputStream.
        /// </param>
        /// <param name="count">
        /// the number of bytes that will be skipped from the stream
        /// </param>
        /// <param name="ioPriority">
        /// the [I/O priority][io-priority] of the request
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object, %NULL to ignore.
        /// </param>
        /// <param name="callback">
        /// callback to call when the request is satisfied
        /// </param>
        /// <param name="userData">
        /// the data to pass to callback function
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Threading.Tasks.Task">
*   <type name="gssize" type="gssize" />
* </type> */
        /* transfer-ownership:none direction:in */
        private static extern void g_input_stream_skip_async(
        /* <type name="InputStream" type="GInputStream*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.InputStream.UnmanagedStruct* stream,
        /* <type name="gsize" type="gsize" /> */
        /* transfer-ownership:none direction:in */
        nuint count,
        /* <type name="gint" type="int" /> */
        /* transfer-ownership:none direction:in */
        int ioPriority,
        /* <type name="Cancellable" type="GCancellable*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.Gio.Cancellable.UnmanagedStruct* cancellable,
        /* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:4 direction:in */
        delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void> callback,
        /* <type name="gpointer" type="gpointer" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr userData);
        partial void CheckSkipAsyncArgs(int count, int ioPriority = GISharp.Lib.GLib.Priority.Default, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <include file="InputStream.xmldoc" path="declaration/member[@name='InputStream.SkipAsync(int,int,GISharp.Lib.Gio.Cancellable?)']/*" />
        public System.Threading.Tasks.Task<int> SkipAsync(int count, int ioPriority = GISharp.Lib.GLib.Priority.Default, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            CheckSkipAsyncArgs(count, ioPriority, cancellable);
            var stream_ = (GISharp.Lib.Gio.InputStream.UnmanagedStruct*)UnsafeHandle;
            var count_ = (nuint)count;
            var ioPriority_ = (int)ioPriority;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var completionSource = new System.Threading.Tasks.TaskCompletionSource<int>();
            var callback_ = (delegate* unmanaged[Cdecl] <GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void>)&SkipFinish;
            var userData_ = (System.IntPtr)System.Runtime.InteropServices.GCHandle.Alloc(completionSource);
            g_input_stream_skip_async(stream_, count_, ioPriority_, cancellable_, callback_, userData_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            return completionSource.Task;
        }

        /// <summary>
        /// Finishes a stream skip operation.
        /// </summary>
        /// <param name="stream">
        /// a #GInputStream.
        /// </param>
        /// <param name="result">
        /// a #GAsyncResult.
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// the size of the bytes skipped, or `-1` on error.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gssize" type="gssize" /> */
        /* transfer-ownership:none direction:in */
        private static extern nint g_input_stream_skip_finish(
        /* <type name="InputStream" type="GInputStream*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.InputStream.UnmanagedStruct* stream,
        /* <type name="AsyncResult" type="GAsyncResult*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result,
        /* <type name="GLib.Error" type="GError**" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        [System.Runtime.InteropServices.UnmanagedCallersOnlyAttribute(CallConvs = new[] { typeof(System.Runtime.CompilerServices.CallConvCdecl) })]
        private static void SkipFinish(GISharp.Lib.GObject.Object.UnmanagedStruct* sourceObject_, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct* result_, System.IntPtr userData_)
        {
            try
            {
                var stream_ = (GISharp.Lib.Gio.InputStream.UnmanagedStruct*)sourceObject_;
                var userData = (System.Runtime.InteropServices.GCHandle)userData_;
                var completionSource = (System.Threading.Tasks.TaskCompletionSource<int>)userData.Target!;
                userData.Free();
                var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
                var ret_ = g_input_stream_skip_finish(stream_,result_,&error_);
                if (error_ is not null)
                {
                    var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                    completionSource.SetException(new GISharp.Lib.GLib.Error.Exception(error));
                    return;
                }
                var ret = (int)ret_;
                completionSource.SetResult((ret));
            }
            catch (System.Exception ex)
            {
                GISharp.Runtime.GMarshal.PushUnhandledException(ex);
            }
        }

        /// <include file="InputStream.xmldoc" path="declaration/member[@name='InputStream.DoCloseAsync(int,GISharp.Lib.Gio.AsyncReadyCallback?,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(InputStreamClass.UnmanagedCloseAsync))]
        protected virtual void DoCloseAsync(int ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            var stream_ = (GISharp.Lib.Gio.InputStream.UnmanagedStruct*)UnsafeHandle;
            var ioPriority_ = (int)ioPriority;
            var callback_ = callback is null ? default : (delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void>)&GISharp.Lib.Gio.AsyncReadyCallbackMarshal.Callback;
            var callbackHandle = callback is null ? default : System.Runtime.InteropServices.GCHandle.Alloc((callback, GISharp.Runtime.CallbackScope.Async));
            var userData_ = (System.IntPtr)callbackHandle;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            GISharp.Lib.GObject.TypeClass.GetUnmanagedVirtualMethod<InputStreamClass.UnmanagedCloseAsync>(_GType)!(stream_, ioPriority_, cancellable_, callback_, userData_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
        }

        /// <include file="InputStream.xmldoc" path="declaration/member[@name='InputStream.DoCloseFinish(GISharp.Lib.Gio.IAsyncResult)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(InputStreamClass.UnmanagedCloseFinish))]
        protected virtual void DoCloseFinish(GISharp.Lib.Gio.IAsyncResult result)
        {
            var stream_ = (GISharp.Lib.Gio.InputStream.UnmanagedStruct*)UnsafeHandle;
            var result_ = (GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*)result.UnsafeHandle;
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            GISharp.Lib.GObject.TypeClass.GetUnmanagedVirtualMethod<InputStreamClass.UnmanagedCloseFinish>(_GType)!(stream_, result_, &error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Lib.GLib.Error.Exception(error);
            }
        }

        /// <include file="InputStream.xmldoc" path="declaration/member[@name='InputStream.DoCloseFn(GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(InputStreamClass.UnmanagedCloseFn))]
        protected virtual void DoCloseFn(GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            var stream_ = (GISharp.Lib.Gio.InputStream.UnmanagedStruct*)UnsafeHandle;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            GISharp.Lib.GObject.TypeClass.GetUnmanagedVirtualMethod<InputStreamClass.UnmanagedCloseFn>(_GType)!(stream_, cancellable_, &error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Lib.GLib.Error.Exception(error);
            }
        }

        /// <include file="InputStream.xmldoc" path="declaration/member[@name='InputStream.DoReadAsync(System.Span&lt;byte&gt;,int,GISharp.Lib.Gio.AsyncReadyCallback?,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(InputStreamClass.UnmanagedReadAsync))]
        protected virtual void DoReadAsync(System.Span<byte> buffer, int ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            fixed (byte* bufferData_ = buffer)
            {
                var stream_ = (GISharp.Lib.Gio.InputStream.UnmanagedStruct*)UnsafeHandle;
                var buffer_ = (byte*)bufferData_;
                var count_ = (nuint)buffer.Length;
                var ioPriority_ = (int)ioPriority;
                var callback_ = callback is null ? default : (delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void>)&GISharp.Lib.Gio.AsyncReadyCallbackMarshal.Callback;
                var callbackHandle = callback is null ? default : System.Runtime.InteropServices.GCHandle.Alloc((callback, GISharp.Runtime.CallbackScope.Async));
                var userData_ = (System.IntPtr)callbackHandle;
                var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
                GISharp.Lib.GObject.TypeClass.GetUnmanagedVirtualMethod<InputStreamClass.UnmanagedReadAsync>(_GType)!(stream_, buffer_, count_, ioPriority_, cancellable_, callback_, userData_);
                GISharp.Runtime.GMarshal.PopUnhandledException();
            }
        }

        /// <include file="InputStream.xmldoc" path="declaration/member[@name='InputStream.DoReadFinish(GISharp.Lib.Gio.IAsyncResult)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(InputStreamClass.UnmanagedReadFinish))]
        protected virtual int DoReadFinish(GISharp.Lib.Gio.IAsyncResult result)
        {
            var stream_ = (GISharp.Lib.Gio.InputStream.UnmanagedStruct*)UnsafeHandle;
            var result_ = (GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*)result.UnsafeHandle;
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            var ret_ = GISharp.Lib.GObject.TypeClass.GetUnmanagedVirtualMethod<InputStreamClass.UnmanagedReadFinish>(_GType)!(stream_,result_,&error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Lib.GLib.Error.Exception(error);
            }

            var ret = (int)ret_;
            return ret;
        }

        /// <include file="InputStream.xmldoc" path="declaration/member[@name='InputStream.DoReadFn(System.IntPtr,int,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(InputStreamClass.UnmanagedReadFn))]
        protected virtual int DoReadFn(System.IntPtr buffer, int count, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            var stream_ = (GISharp.Lib.Gio.InputStream.UnmanagedStruct*)UnsafeHandle;
            var buffer_ = (System.IntPtr)buffer;
            var count_ = (nuint)count;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            var ret_ = GISharp.Lib.GObject.TypeClass.GetUnmanagedVirtualMethod<InputStreamClass.UnmanagedReadFn>(_GType)!(stream_,buffer_,count_,cancellable_,&error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Lib.GLib.Error.Exception(error);
            }

            var ret = (int)ret_;
            return ret;
        }

        /// <include file="InputStream.xmldoc" path="declaration/member[@name='InputStream.DoSkip(int,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(InputStreamClass.UnmanagedSkip))]
        protected virtual int DoSkip(int count, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            var stream_ = (GISharp.Lib.Gio.InputStream.UnmanagedStruct*)UnsafeHandle;
            var count_ = (nuint)count;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            var ret_ = GISharp.Lib.GObject.TypeClass.GetUnmanagedVirtualMethod<InputStreamClass.UnmanagedSkip>(_GType)!(stream_,count_,cancellable_,&error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Lib.GLib.Error.Exception(error);
            }

            var ret = (int)ret_;
            return ret;
        }

        /// <include file="InputStream.xmldoc" path="declaration/member[@name='InputStream.DoSkipAsync(int,int,GISharp.Lib.Gio.AsyncReadyCallback?,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(InputStreamClass.UnmanagedSkipAsync))]
        protected virtual void DoSkipAsync(int count, int ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            var stream_ = (GISharp.Lib.Gio.InputStream.UnmanagedStruct*)UnsafeHandle;
            var count_ = (nuint)count;
            var ioPriority_ = (int)ioPriority;
            var callback_ = callback is null ? default : (delegate* unmanaged[Cdecl]<GISharp.Lib.GObject.Object.UnmanagedStruct*, GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*, System.IntPtr, void>)&GISharp.Lib.Gio.AsyncReadyCallbackMarshal.Callback;
            var callbackHandle = callback is null ? default : System.Runtime.InteropServices.GCHandle.Alloc((callback, GISharp.Runtime.CallbackScope.Async));
            var userData_ = (System.IntPtr)callbackHandle;
            var cancellable_ = (GISharp.Lib.Gio.Cancellable.UnmanagedStruct*)(cancellable?.UnsafeHandle ?? System.IntPtr.Zero);
            GISharp.Lib.GObject.TypeClass.GetUnmanagedVirtualMethod<InputStreamClass.UnmanagedSkipAsync>(_GType)!(stream_, count_, ioPriority_, cancellable_, callback_, userData_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
        }

        /// <include file="InputStream.xmldoc" path="declaration/member[@name='InputStream.DoSkipFinish(GISharp.Lib.Gio.IAsyncResult)']/*" />
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(InputStreamClass.UnmanagedSkipFinish))]
        protected virtual int DoSkipFinish(GISharp.Lib.Gio.IAsyncResult result)
        {
            var stream_ = (GISharp.Lib.Gio.InputStream.UnmanagedStruct*)UnsafeHandle;
            var result_ = (GISharp.Lib.Gio.AsyncResult.UnmanagedStruct*)result.UnsafeHandle;
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            var ret_ = GISharp.Lib.GObject.TypeClass.GetUnmanagedVirtualMethod<InputStreamClass.UnmanagedSkipFinish>(_GType)!(stream_,result_,&error_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Lib.GLib.Error.Exception(error);
            }

            var ret = (int)ret_;
            return ret;
        }
    }
}