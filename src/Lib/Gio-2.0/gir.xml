<?xml version="1.0" encoding="utf-8"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2" xmlns="http://www.gtk.org/introspection/core/1.0" xmlns:c="http://www.gtk.org/introspection/c/1.0" xmlns:glib="http://www.gtk.org/introspection/glib/1.0" xmlns:gs="http://gisharp.org/introspection/gisharp/1.0">
  <include name="GObject" version="2.0" gs:managed-name="GObject" />
  <package name="gio-2.0" gs:managed-name="Gio2.0" />
  <package name="gio-unix-2.0" gs:managed-name="GioUnix2.0" />
  <c:include name="gio/gfiledescriptorbased.h" gs:managed-name="Gio/gfiledescriptorbased.h" />
  <c:include name="gio/gio.h" gs:managed-name="Gio/gio.h" />
  <c:include name="gio/gunixconnection.h" gs:managed-name="Gio/gunixconnection.h" />
  <c:include name="gio/gunixcredentialsmessage.h" gs:managed-name="Gio/gunixcredentialsmessage.h" />
  <c:include name="gio/gunixfdlist.h" gs:managed-name="Gio/gunixfdlist.h" />
  <c:include name="gio/gunixfdmessage.h" gs:managed-name="Gio/gunixfdmessage.h" />
  <c:include name="gio/gunixinputstream.h" gs:managed-name="Gio/gunixinputstream.h" />
  <c:include name="gio/gunixmounts.h" gs:managed-name="Gio/gunixmounts.h" />
  <c:include name="gio/gunixoutputstream.h" gs:managed-name="Gio/gunixoutputstream.h" />
  <c:include name="gio/gunixsocketaddress.h" gs:managed-name="Gio/gunixsocketaddress.h" />
  <namespace name="Gio" version="2.0" shared-library="/usr/local/opt/glib/lib/libgio-2.0.0.dylib" c:identifier-prefixes="G" c:symbol-prefixes="g" gs:managed-name="Gio">
    <interface name="Action" c:symbol-prefix="action" c:type="GAction" glib:type-name="GAction" glib:get-type="g_action_get_type" glib:type-struct="ActionInterface" gs:managed-name="IAction">
      <doc xml:space="preserve" filename="gio-2.0.c" line="4519">#GAction represents a single named action.

The main interface to an action is that it can be activated with
g_action_activate().  This results in the 'activate' signal being
emitted.  An activation has a #GVariant parameter (which may be
%NULL).  The correct type for the parameter is determined by a static
parameter type (which is given at construction time).

An action may optionally have a state, in which case the state may be
set with g_action_change_state().  This call takes a #GVariant.  The
correct type for the state is determined by a static state type
(which is given at construction time).

The state may have a hint associated with it, specifying its valid
range.

#GAction is merely the interface to the concept of an action, as
described above.  Various implementations of actions exist, including
#GSimpleAction.

In all cases, the implementing class is responsible for storing the
name of the action, the parameter type, the enabled state, the
optional state type and the state and emitting the appropriate
signals when these change.  The implementor is responsible for filtering
calls to g_action_activate() and g_action_change_state() for type
safety and for the state being enabled.

Probably the only useful thing to do with a #GAction is to put it
inside of a #GSimpleActionGroup.</doc>
      <source-position filename="gaction.h" line="57" />
      <function name="name_is_valid" c:identifier="g_action_name_is_valid" version="2.38" gs:dll-name="gio-2.0" gs:managed-name="NameIsValid">
        <doc xml:space="preserve" filename="gio-2.0.c" line="10839">Checks if @action_name is valid.

@action_name is valid if it consists only of alphanumeric characters,
plus '-' and '.'.  The empty string is not a valid action name.

It is an error to call this function with a non-utf8 @action_name.
@action_name must not be %NULL.</doc>
        <source-position filename="gaction.h" line="84" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="10851">%TRUE if @action_name is valid</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10841">a potential action name</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10841">a potential action name</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="parse_detailed_name" c:identifier="g_action_parse_detailed_name" version="2.38" throws="1" gs:dll-name="gio-2.0" gs:managed-name="ParseDetailedName">
        <doc xml:space="preserve" filename="gio-2.0.c" line="10856">Parses a detailed action name into its separate name and target
components.

Detailed action names can have three formats.

The first format is used to represent an action name with no target
value and consists of just an action name containing no whitespace
nor the characters ':', '(' or ')'.  For example: "app.action".

The second format is used to represent an action with a target value
that is a non-empty string consisting only of alphanumerics, plus '-'
and '.'.  In that case, the action name and target value are
separated by a double colon ("::").  For example:
"app.action::target".

The third format is used to represent an action with any type of
target value, including strings.  The target value follows the action
name, surrounded in parens.  For example: "app.action(42)".  The
target value is parsed using g_variant_parse().  If a tuple-typed
value is desired, it must be specified in the same way, resulting in
two sets of parens, for example: "app.action((1,2,3))".  A string
target can be specified this way as well: "app.action('target')".
For strings, this third format must be used if * target value is
empty or contains characters other than alphanumerics, '-' and '.'.</doc>
        <source-position filename="gaction.h" line="87" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="10888">%TRUE if successful, else %FALSE with @error set</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <parameter name="detailed_name" transfer-ownership="none" gs:managed-name="detailedName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10858">a detailed action name</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="action_name" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="actionName">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10859">the action name</doc>
            <type name="utf8" c:type="gchar**" gs:is-pointer="1" />
          </parameter>
          <parameter name="target_value" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="targetValue">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10860">the target value, or %NULL for no target</doc>
            <type name="GLib.Variant" c:type="GVariant**" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="detailed_name" transfer-ownership="none" gs:managed-name="detailedName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10858">a detailed action name</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="action_name" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="actionName">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10859">the action name</doc>
            <type name="utf8" c:type="gchar**" gs:is-pointer="1" />
          </parameter>
          <parameter name="target_value" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="targetValue">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10860">the target value, or %NULL for no target</doc>
            <type name="GLib.Variant" c:type="GVariant**" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="print_detailed_name" c:identifier="g_action_print_detailed_name" version="2.38" gs:dll-name="gio-2.0" gs:managed-name="PrintDetailedName">
        <doc xml:space="preserve" filename="gio-2.0.c" line="10893">Formats a detailed action name from @action_name and @target_value.

It is an error to call this function with an invalid action name.

This function is the opposite of g_action_parse_detailed_name().
It will produce a string that can be parsed back to the @action_name
and @target_value by that function.

See that function for the types of strings that will be printed by
this function.</doc>
        <source-position filename="gaction.h" line="93" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="10909">a detailed format string</doc>
          <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10895">a valid action name</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="target_value" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="targetValue" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10896">a #GVariant target value, or %NULL</doc>
            <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10895">a valid action name</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="target_value" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="targetValue" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10896">a #GVariant target value, or %NULL</doc>
            <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <virtual-method name="activate" invoker="activate" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="DoActivate">
        <doc xml:space="preserve" filename="gio-2.0.c" line="10294">Activates the action.

@parameter must be the correct type of parameter for the action (ie:
the parameter type given at construction time).  If the parameter
type was %NULL then @parameter must also be %NULL.

If the @parameter GVariant is floating, it is consumed.</doc>
        <source-position filename="gaction.h" line="55" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="action" transfer-ownership="none" gs:managed-name="action" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10296">a #GAction</doc>
            <type name="Action" c:type="GAction*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="parameter" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="parameter" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10297">the parameter to the activation</doc>
            <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="parameter" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="parameter" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10297">the parameter to the activation</doc>
            <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="change_state" invoker="change_state" version="2.30" gs:dll-name="gio-2.0" gs:managed-name="DoChangeState">
        <doc xml:space="preserve" filename="gio-2.0.c" line="10311">Request for the state of @action to be changed to @value.

The action must be stateful and @value must be of the correct type.
See g_action_get_state_type().

This call merely requests a change.  The action may refuse to change
its state or may change its state to something other than @value.
See g_action_get_state_hint().

If the @value GVariant is floating, it is consumed.</doc>
        <source-position filename="gaction.h" line="53" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="action" transfer-ownership="none" gs:managed-name="action" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10313">a #GAction</doc>
            <type name="Action" c:type="GAction*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10314">the new state</doc>
            <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10314">the new state</doc>
            <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="get_enabled" invoker="get_enabled" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="DoGetEnabled">
        <doc xml:space="preserve" filename="gio-2.0.c" line="10331">Checks if @action is currently enabled.

An action must be enabled in order to be activated or in order to
have its state changed from outside callers.</doc>
        <source-position filename="gaction.h" line="50" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="10340">whether the action is enabled</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="action" transfer-ownership="none" gs:managed-name="action" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10333">a #GAction</doc>
            <type name="Action" c:type="GAction*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </virtual-method>
      <virtual-method name="get_name" invoker="get_name" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="DoGetName">
        <doc xml:space="preserve" filename="gio-2.0.c" line="10345">Queries the name of @action.</doc>
        <source-position filename="gaction.h" line="45" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="10351">the name of the action</doc>
          <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="action" transfer-ownership="none" gs:managed-name="action" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10347">a #GAction</doc>
            <type name="Action" c:type="GAction*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </virtual-method>
      <virtual-method name="get_parameter_type" invoker="get_parameter_type" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="DoGetParameterType">
        <doc xml:space="preserve" filename="gio-2.0.c" line="10356">Queries the type of the parameter that must be given when activating
@action.

When activating the action using g_action_activate(), the #GVariant
given to that function must be of the type returned by this function.

In the case that this function returns %NULL, you must not give any
#GVariant, but %NULL instead.</doc>
        <source-position filename="gaction.h" line="46" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="10369">the parameter type</doc>
          <type name="GLib.VariantType" c:type="const GVariantType*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="action" transfer-ownership="none" gs:managed-name="action" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10358">a #GAction</doc>
            <type name="Action" c:type="GAction*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </virtual-method>
      <virtual-method name="get_state" invoker="get_state" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="DoGetState">
        <doc xml:space="preserve" filename="gio-2.0.c" line="10374">Queries the current state of @action.

If the action is not stateful then %NULL will be returned.  If the
action is stateful then the type of the return value is the type
given by g_action_get_state_type().

The return value (if non-%NULL) should be freed with
g_variant_unref() when it is no longer required.</doc>
        <source-position filename="gaction.h" line="51" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="10387">the current state of the action</doc>
          <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="action" transfer-ownership="none" gs:managed-name="action" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10376">a #GAction</doc>
            <type name="Action" c:type="GAction*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </virtual-method>
      <virtual-method name="get_state_hint" invoker="get_state_hint" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="DoGetStateHint">
        <doc xml:space="preserve" filename="gio-2.0.c" line="10392">Requests a hint about the valid range of values for the state of
@action.

If %NULL is returned it either means that the action is not stateful
or that there is no hint about the valid range of values for the
state of the action.

If a #GVariant array is returned then each item in the array is a
possible value for the state.  If a #GVariant pair (ie: two-tuple) is
returned then the tuple specifies the inclusive lower and upper bound
of valid values for the state.

In any case, the information is merely a hint.  It may be possible to
have a state value outside of the hinted range and setting a value
within the range may fail.

The return value (if non-%NULL) should be freed with
g_variant_unref() when it is no longer required.</doc>
        <source-position filename="gaction.h" line="48" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="10415">the state range hint</doc>
          <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="action" transfer-ownership="none" gs:managed-name="action" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10394">a #GAction</doc>
            <type name="Action" c:type="GAction*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </virtual-method>
      <virtual-method name="get_state_type" invoker="get_state_type" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="DoGetStateType">
        <doc xml:space="preserve" filename="gio-2.0.c" line="10420">Queries the type of the state of @action.

If the action is stateful (e.g. created with
g_simple_action_new_stateful()) then this function returns the
#GVariantType of the state.  This is the type of the initial value
given as the state. All calls to g_action_change_state() must give a
#GVariant of this type and g_action_get_state() will return a
#GVariant of the same type.

If the action is not stateful (e.g. created with g_simple_action_new())
then this function will return %NULL. In that case, g_action_get_state()
will return %NULL and you must not call g_action_change_state().</doc>
        <source-position filename="gaction.h" line="47" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="10437">the state type, if the action is stateful</doc>
          <type name="GLib.VariantType" c:type="const GVariantType*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="action" transfer-ownership="none" gs:managed-name="action" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10422">a #GAction</doc>
            <type name="Action" c:type="GAction*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </virtual-method>
      <method name="activate" c:identifier="g_action_activate" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="Activate" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="10294">Activates the action.

@parameter must be the correct type of parameter for the action (ie:
the parameter type given at construction time).  If the parameter
type was %NULL then @parameter must also be %NULL.

If the @parameter GVariant is floating, it is consumed.</doc>
        <source-position filename="gaction.h" line="80" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="action" transfer-ownership="none" gs:managed-name="action" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10296">a #GAction</doc>
            <type name="Action" c:type="GAction*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="parameter" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="parameter" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10297">the parameter to the activation</doc>
            <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="action" transfer-ownership="none" gs:managed-name="action" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10296">a #GAction</doc>
            <type name="Action" c:type="GAction*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="parameter" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="parameter" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10297">the parameter to the activation</doc>
            <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="change_state" c:identifier="g_action_change_state" version="2.30" gs:dll-name="gio-2.0" gs:managed-name="ChangeState" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="10311">Request for the state of @action to be changed to @value.

The action must be stateful and @value must be of the correct type.
See g_action_get_state_type().

This call merely requests a change.  The action may refuse to change
its state or may change its state to something other than @value.
See g_action_get_state_hint().

If the @value GVariant is floating, it is consumed.</doc>
        <source-position filename="gaction.h" line="77" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="action" transfer-ownership="none" gs:managed-name="action" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10313">a #GAction</doc>
            <type name="Action" c:type="GAction*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10314">the new state</doc>
            <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="action" transfer-ownership="none" gs:managed-name="action" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10313">a #GAction</doc>
            <type name="Action" c:type="GAction*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10314">the new state</doc>
            <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_enabled" c:identifier="g_action_get_enabled" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="GetEnabled" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="10331">Checks if @action is currently enabled.

An action must be enabled in order to be activated or in order to
have its state changed from outside callers.</doc>
        <source-position filename="gaction.h" line="72" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="10340">whether the action is enabled</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="action" transfer-ownership="none" gs:managed-name="action" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10333">a #GAction</doc>
            <type name="Action" c:type="GAction*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="action" transfer-ownership="none" gs:managed-name="action" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10333">a #GAction</doc>
            <type name="Action" c:type="GAction*" gs:is-pointer="1" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_name" c:identifier="g_action_get_name" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="GetName" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="10345">Queries the name of @action.</doc>
        <source-position filename="gaction.h" line="63" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="10351">the name of the action</doc>
          <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="action" transfer-ownership="none" gs:managed-name="action" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10347">a #GAction</doc>
            <type name="Action" c:type="GAction*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="action" transfer-ownership="none" gs:managed-name="action" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10347">a #GAction</doc>
            <type name="Action" c:type="GAction*" gs:is-pointer="1" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_parameter_type" c:identifier="g_action_get_parameter_type" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="GetParameterType" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="10356">Queries the type of the parameter that must be given when activating
@action.

When activating the action using g_action_activate(), the #GVariant
given to that function must be of the type returned by this function.

In the case that this function returns %NULL, you must not give any
#GVariant, but %NULL instead.</doc>
        <source-position filename="gaction.h" line="65" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="10369">the parameter type</doc>
          <type name="GLib.VariantType" c:type="const GVariantType*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="action" transfer-ownership="none" gs:managed-name="action" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10358">a #GAction</doc>
            <type name="Action" c:type="GAction*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="action" transfer-ownership="none" gs:managed-name="action" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10358">a #GAction</doc>
            <type name="Action" c:type="GAction*" gs:is-pointer="1" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_state" c:identifier="g_action_get_state" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="GetState" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="10374">Queries the current state of @action.

If the action is not stateful then %NULL will be returned.  If the
action is stateful then the type of the return value is the type
given by g_action_get_state_type().

The return value (if non-%NULL) should be freed with
g_variant_unref() when it is no longer required.</doc>
        <source-position filename="gaction.h" line="74" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="10387">the current state of the action</doc>
          <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="action" transfer-ownership="none" gs:managed-name="action" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10376">a #GAction</doc>
            <type name="Action" c:type="GAction*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="action" transfer-ownership="none" gs:managed-name="action" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10376">a #GAction</doc>
            <type name="Action" c:type="GAction*" gs:is-pointer="1" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_state_hint" c:identifier="g_action_get_state_hint" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="GetStateHint" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="10392">Requests a hint about the valid range of values for the state of
@action.

If %NULL is returned it either means that the action is not stateful
or that there is no hint about the valid range of values for the
state of the action.

If a #GVariant array is returned then each item in the array is a
possible value for the state.  If a #GVariant pair (ie: two-tuple) is
returned then the tuple specifies the inclusive lower and upper bound
of valid values for the state.

In any case, the information is merely a hint.  It may be possible to
have a state value outside of the hinted range and setting a value
within the range may fail.

The return value (if non-%NULL) should be freed with
g_variant_unref() when it is no longer required.</doc>
        <source-position filename="gaction.h" line="69" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="10415">the state range hint</doc>
          <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="action" transfer-ownership="none" gs:managed-name="action" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10394">a #GAction</doc>
            <type name="Action" c:type="GAction*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="action" transfer-ownership="none" gs:managed-name="action" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10394">a #GAction</doc>
            <type name="Action" c:type="GAction*" gs:is-pointer="1" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_state_type" c:identifier="g_action_get_state_type" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="GetStateType" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="10420">Queries the type of the state of @action.

If the action is stateful (e.g. created with
g_simple_action_new_stateful()) then this function returns the
#GVariantType of the state.  This is the type of the initial value
given as the state. All calls to g_action_change_state() must give a
#GVariant of this type and g_action_get_state() will return a
#GVariant of the same type.

If the action is not stateful (e.g. created with g_simple_action_new())
then this function will return %NULL. In that case, g_action_get_state()
will return %NULL and you must not call g_action_change_state().</doc>
        <source-position filename="gaction.h" line="67" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="10437">the state type, if the action is stateful</doc>
          <type name="GLib.VariantType" c:type="const GVariantType*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="action" transfer-ownership="none" gs:managed-name="action" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10422">a #GAction</doc>
            <type name="Action" c:type="GAction*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="action" transfer-ownership="none" gs:managed-name="action" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10422">a #GAction</doc>
            <type name="Action" c:type="GAction*" gs:is-pointer="1" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <property name="enabled" version="2.28" transfer-ownership="none" gs:managed-name="Enabled">
        <doc xml:space="preserve" filename="gio-2.0.c" line="13">If @action is currently enabled.

If the action is disabled then calls to g_action_activate() and
g_action_change_state() have no effect.</doc>
        <type name="gboolean" c:type="gboolean" />
      </property>
      <property name="name" version="2.28" transfer-ownership="none" gs:managed-name="Name">
        <doc xml:space="preserve" filename="gio-2.0.c" line="25">The name of the action.  This is mostly meaningful for identifying
the action once it has been added to a #GActionGroup. It is immutable.</doc>
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </property>
      <property name="parameter-type" version="2.28" transfer-ownership="none" gs:managed-name="ParameterType">
        <doc xml:space="preserve" filename="gio-2.0.c" line="35">The type of the parameter that must be given when activating the
action. This is immutable, and may be %NULL if no parameter is needed when
activating the action.</doc>
        <type name="GLib.VariantType" />
      </property>
      <property name="state" version="2.28" transfer-ownership="none" gs:managed-name="State">
        <doc xml:space="preserve" filename="gio-2.0.c" line="46">The state of the action, or %NULL if the action is stateless.</doc>
        <type name="GLib.Variant" />
      </property>
      <property name="state-type" version="2.28" transfer-ownership="none" gs:managed-name="StateType">
        <doc xml:space="preserve" filename="gio-2.0.c" line="55">The #GVariantType of the state that the action has, or %NULL if the
action is stateless. This is immutable.</doc>
        <type name="GLib.VariantType" />
      </property>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_action_get_type" gs:access-modifiers="private" gs:dll-name="gio-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </interface>
    <interface name="ActionGroup" c:symbol-prefix="action_group" c:type="GActionGroup" glib:type-name="GActionGroup" glib:get-type="g_action_group_get_type" glib:type-struct="ActionGroupInterface" gs:managed-name="IActionGroup">
      <doc xml:space="preserve" filename="gio-2.0.c" line="4557">#GActionGroup represents a group of actions. Actions can be used to
expose functionality in a structured way, either from one part of a
program to another, or to the outside world. Action groups are often
used together with a #GMenuModel that provides additional
representation data for displaying the actions to the user, e.g. in
a menu.

The main way to interact with the actions in a GActionGroup is to
activate them with g_action_group_activate_action(). Activating an
action may require a #GVariant parameter. The required type of the
parameter can be inquired with g_action_group_get_action_parameter_type().
Actions may be disabled, see g_action_group_get_action_enabled().
Activating a disabled action has no effect.

Actions may optionally have a state in the form of a #GVariant. The
current state of an action can be inquired with
g_action_group_get_action_state(). Activating a stateful action may
change its state, but it is also possible to set the state by calling
g_action_group_change_action_state().

As typical example, consider a text editing application which has an
option to change the current font to 'bold'. A good way to represent
this would be a stateful action, with a boolean state. Activating the
action would toggle the state.

Each action in the group has a unique name (which is a string).  All
method calls, except g_action_group_list_actions() take the name of
an action as an argument.

The #GActionGroup API is meant to be the 'public' API to the action
group.  The calls here are exactly the interaction that 'external
forces' (eg: UI, incoming D-Bus messages, etc.) are supposed to have
with actions.  'Internal' APIs (ie: ones meant only to be accessed by
the action group implementation) are found on subclasses.  This is
why you will find - for example - g_action_group_get_action_enabled()
but not an equivalent set() call.

Signals are emitted on the action group in response to state changes
on individual actions.

Implementations of #GActionGroup should provide implementations for
the virtual functions g_action_group_list_actions() and
g_action_group_query_action().  The other virtual functions should
not be implemented - their "wrappers" are actually implemented with
calls to g_action_group_query_action().</doc>
      <source-position filename="gactiongroup.h" line="95" />
      <virtual-method name="action_added" invoker="action_added" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="DoActionAdded">
        <doc xml:space="preserve" filename="gio-2.0.c" line="10442">Emits the #GActionGroup::action-added signal on @action_group.

This function should only be called by #GActionGroup implementations.</doc>
        <source-position filename="gactiongroup.h" line="76" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10444">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10445">the name of an action in the group</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10445">the name of an action in the group</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="action_enabled_changed" invoker="action_enabled_changed" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="DoActionEnabledChanged">
        <doc xml:space="preserve" filename="gio-2.0.c" line="10455">Emits the #GActionGroup::action-enabled-changed signal on @action_group.

This function should only be called by #GActionGroup implementations.</doc>
        <source-position filename="gactiongroup.h" line="80" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10457">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10458">the name of an action in the group</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="enabled" transfer-ownership="none" gs:managed-name="enabled" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10459">whether or not the action is now enabled</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10458">the name of an action in the group</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="enabled" transfer-ownership="none" gs:managed-name="enabled" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10459">whether or not the action is now enabled</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="action_removed" invoker="action_removed" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="DoActionRemoved">
        <doc xml:space="preserve" filename="gio-2.0.c" line="10469">Emits the #GActionGroup::action-removed signal on @action_group.

This function should only be called by #GActionGroup implementations.</doc>
        <source-position filename="gactiongroup.h" line="78" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10471">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10472">the name of an action in the group</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10472">the name of an action in the group</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="action_state_changed" invoker="action_state_changed" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="DoActionStateChanged">
        <doc xml:space="preserve" filename="gio-2.0.c" line="10482">Emits the #GActionGroup::action-state-changed signal on @action_group.

This function should only be called by #GActionGroup implementations.</doc>
        <source-position filename="gactiongroup.h" line="83" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10484">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10485">the name of an action in the group</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="state" transfer-ownership="none" gs:managed-name="state" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10486">the new state of the named action</doc>
            <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10485">the name of an action in the group</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="state" transfer-ownership="none" gs:managed-name="state" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10486">the new state of the named action</doc>
            <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="activate_action" invoker="activate_action" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="DoActivateAction">
        <doc xml:space="preserve" filename="gio-2.0.c" line="10496">Activate the named action within @action_group.

If the action is expecting a parameter, then the correct type of
parameter must be given as @parameter.  If the action is expecting no
parameters then @parameter must be %NULL.  See
g_action_group_get_action_parameter_type().

If the #GActionGroup implementation supports asynchronous remote
activation over D-Bus, this call may return before the relevant
D-Bus traffic has been sent, or any replies have been received. In
order to block on such asynchronous activation calls,
g_dbus_connection_flush() should be called prior to the code, which
depends on the result of the action activation. Without flushing
the D-Bus connection, there is no guarantee that the action would
have been activated.

The following code which runs in a remote app instance, shows an
example of a "quit" action being activated on the primary app
instance over D-Bus. Here g_dbus_connection_flush() is called
before `exit()`. Without g_dbus_connection_flush(), the "quit" action
may fail to be activated on the primary instance.

|[&lt;!-- language="C" --&gt;
// call "quit" action on primary instance
g_action_group_activate_action (G_ACTION_GROUP (app), "quit", NULL);

// make sure the action is activated now
g_dbus_connection_flush (...);

g_debug ("application has been terminated. exiting.");

exit (0);
]|</doc>
        <source-position filename="gactiongroup.h" line="71" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10498">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10499">the name of the action to activate</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="parameter" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="parameter" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10500">parameters to the activation</doc>
            <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10499">the name of the action to activate</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="parameter" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="parameter" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10500">parameters to the activation</doc>
            <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="change_action_state" invoker="change_action_state" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="DoChangeActionState">
        <doc xml:space="preserve" filename="gio-2.0.c" line="10540">Request for the state of the named action within @action_group to be
changed to @value.

The action must be stateful and @value must be of the correct type.
See g_action_group_get_action_state_type().

This call merely requests a change.  The action may refuse to change
its state or may change its state to something other than @value.
See g_action_group_get_action_state_hint().

If the @value GVariant is floating, it is consumed.</doc>
        <source-position filename="gactiongroup.h" line="67" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10542">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10543">the name of the action to request the change on</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10544">the new state</doc>
            <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10543">the name of the action to request the change on</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10544">the new state</doc>
            <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="get_action_enabled" invoker="get_action_enabled" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="DoGetActionEnabled">
        <doc xml:space="preserve" filename="gio-2.0.c" line="10562">Checks if the named action within @action_group is currently enabled.

An action must be enabled in order to be activated or in order to
have its state changed from outside callers.</doc>
        <source-position filename="gactiongroup.h" line="52" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="10572">whether or not the action is currently enabled</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10564">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10565">the name of the action to query</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10565">the name of the action to query</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="get_action_parameter_type" invoker="get_action_parameter_type" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="DoGetActionParameterType">
        <doc xml:space="preserve" filename="gio-2.0.c" line="10577">Queries the type of the parameter that must be given when activating
the named action within @action_group.

When activating the action using g_action_group_activate_action(),
the #GVariant given to that function must be of the type returned
by this function.

In the case that this function returns %NULL, you must not give any
#GVariant, but %NULL instead.

The parameter type of a particular action will never change but it is
possible for an action to be removed and for a new action to be added
with the same name but a different parameter type.</doc>
        <source-position filename="gactiongroup.h" line="55" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="10596">the parameter type</doc>
          <type name="GLib.VariantType" c:type="const GVariantType*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10579">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10580">the name of the action to query</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10580">the name of the action to query</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="get_action_state" invoker="get_action_state" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="DoGetActionState">
        <doc xml:space="preserve" filename="gio-2.0.c" line="10601">Queries the current state of the named action within @action_group.

If the action is not stateful then %NULL will be returned.  If the
action is stateful then the type of the return value is the type
given by g_action_group_get_action_state_type().

The return value (if non-%NULL) should be freed with
g_variant_unref() when it is no longer required.</doc>
        <source-position filename="gactiongroup.h" line="64" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="10615">the current state of the action</doc>
          <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10603">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10604">the name of the action to query</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10604">the name of the action to query</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="get_action_state_hint" invoker="get_action_state_hint" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="DoGetActionStateHint">
        <doc xml:space="preserve" filename="gio-2.0.c" line="10620">Requests a hint about the valid range of values for the state of the
named action within @action_group.

If %NULL is returned it either means that the action is not stateful
or that there is no hint about the valid range of values for the
state of the action.

If a #GVariant array is returned then each item in the array is a
possible value for the state.  If a #GVariant pair (ie: two-tuple) is
returned then the tuple specifies the inclusive lower and upper bound
of valid values for the state.

In any case, the information is merely a hint.  It may be possible to
have a state value outside of the hinted range and setting a value
within the range may fail.

The return value (if non-%NULL) should be freed with
g_variant_unref() when it is no longer required.</doc>
        <source-position filename="gactiongroup.h" line="61" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="10644">the state range hint</doc>
          <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10622">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10623">the name of the action to query</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10623">the name of the action to query</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="get_action_state_type" invoker="get_action_state_type" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="DoGetActionStateType">
        <doc xml:space="preserve" filename="gio-2.0.c" line="10649">Queries the type of the state of the named action within
@action_group.

If the action is stateful then this function returns the
#GVariantType of the state.  All calls to
g_action_group_change_action_state() must give a #GVariant of this
type and g_action_group_get_action_state() will return a #GVariant
of the same type.

If the action is not stateful then this function will return %NULL.
In that case, g_action_group_get_action_state() will return %NULL
and you must not call g_action_group_change_action_state().

The state type of a particular action will never change but it is
possible for an action to be removed and for a new action to be added
with the same name but a different state type.</doc>
        <source-position filename="gactiongroup.h" line="58" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="10671">the state type, if the action is stateful</doc>
          <type name="GLib.VariantType" c:type="const GVariantType*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10651">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10652">the name of the action to query</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10652">the name of the action to query</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="has_action" invoker="has_action" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="DoHasAction">
        <doc xml:space="preserve" filename="gio-2.0.c" line="10676">Checks if the named action exists within @action_group.</doc>
        <source-position filename="gactiongroup.h" line="47" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="10683">whether the named action exists</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10678">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10679">the name of the action to check for</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10679">the name of the action to check for</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="list_actions" invoker="list_actions" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="DoListActions">
        <doc xml:space="preserve" filename="gio-2.0.c" line="10688">Lists the actions contained within @action_group.

The caller is responsible for freeing the list with g_strfreev() when
it is no longer required.</doc>
        <source-position filename="gactiongroup.h" line="50" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="10697">a %NULL-terminated array of the names of the
actions in the group</doc>
          <array c:type="gchar**" zero-terminated="1" gs:is-pointer="1">
            <type name="utf8" gs:is-pointer="1" />
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10690">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </virtual-method>
      <method name="action_added" c:identifier="g_action_group_action_added" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="ActionAdded" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="10442">Emits the #GActionGroup::action-added signal on @action_group.

This function should only be called by #GActionGroup implementations.</doc>
        <source-position filename="gactiongroup.h" line="135" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10444">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10445">the name of an action in the group</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10444">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10445">the name of an action in the group</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="action_enabled_changed" c:identifier="g_action_group_action_enabled_changed" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="ActionEnabledChanged" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="10455">Emits the #GActionGroup::action-enabled-changed signal on @action_group.

This function should only be called by #GActionGroup implementations.</doc>
        <source-position filename="gactiongroup.h" line="141" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10457">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10458">the name of an action in the group</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="enabled" transfer-ownership="none" gs:managed-name="enabled" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10459">whether or not the action is now enabled</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10457">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10458">the name of an action in the group</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="enabled" transfer-ownership="none" gs:managed-name="enabled" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10459">whether or not the action is now enabled</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="action_removed" c:identifier="g_action_group_action_removed" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="ActionRemoved" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="10469">Emits the #GActionGroup::action-removed signal on @action_group.

This function should only be called by #GActionGroup implementations.</doc>
        <source-position filename="gactiongroup.h" line="138" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10471">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10472">the name of an action in the group</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10471">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10472">the name of an action in the group</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="action_state_changed" c:identifier="g_action_group_action_state_changed" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="ActionStateChanged" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="10482">Emits the #GActionGroup::action-state-changed signal on @action_group.

This function should only be called by #GActionGroup implementations.</doc>
        <source-position filename="gactiongroup.h" line="146" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10484">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10485">the name of an action in the group</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="state" transfer-ownership="none" gs:managed-name="state" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10486">the new state of the named action</doc>
            <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10484">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10485">the name of an action in the group</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="state" transfer-ownership="none" gs:managed-name="state" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10486">the new state of the named action</doc>
            <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="activate_action" c:identifier="g_action_group_activate_action" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="ActivateAction" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="10496">Activate the named action within @action_group.

If the action is expecting a parameter, then the correct type of
parameter must be given as @parameter.  If the action is expecting no
parameters then @parameter must be %NULL.  See
g_action_group_get_action_parameter_type().

If the #GActionGroup implementation supports asynchronous remote
activation over D-Bus, this call may return before the relevant
D-Bus traffic has been sent, or any replies have been received. In
order to block on such asynchronous activation calls,
g_dbus_connection_flush() should be called prior to the code, which
depends on the result of the action activation. Without flushing
the D-Bus connection, there is no guarantee that the action would
have been activated.

The following code which runs in a remote app instance, shows an
example of a "quit" action being activated on the primary app
instance over D-Bus. Here g_dbus_connection_flush() is called
before `exit()`. Without g_dbus_connection_flush(), the "quit" action
may fail to be activated on the primary instance.

|[&lt;!-- language="C" --&gt;
// call "quit" action on primary instance
g_action_group_activate_action (G_ACTION_GROUP (app), "quit", NULL);

// make sure the action is activated now
g_dbus_connection_flush (...);

g_debug ("application has been terminated. exiting.");

exit (0);
]|</doc>
        <source-position filename="gactiongroup.h" line="129" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10498">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10499">the name of the action to activate</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="parameter" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="parameter" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10500">parameters to the activation</doc>
            <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10498">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10499">the name of the action to activate</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="parameter" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="parameter" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10500">parameters to the activation</doc>
            <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="change_action_state" c:identifier="g_action_group_change_action_state" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="ChangeActionState" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="10540">Request for the state of the named action within @action_group to be
changed to @value.

The action must be stateful and @value must be of the correct type.
See g_action_group_get_action_state_type().

This call merely requests a change.  The action may refuse to change
its state or may change its state to something other than @value.
See g_action_group_get_action_state_hint().

If the @value GVariant is floating, it is consumed.</doc>
        <source-position filename="gactiongroup.h" line="124" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10542">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10543">the name of the action to request the change on</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10544">the new state</doc>
            <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10542">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10543">the name of the action to request the change on</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10544">the new state</doc>
            <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_action_enabled" c:identifier="g_action_group_get_action_enabled" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="GetActionEnabled" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="10562">Checks if the named action within @action_group is currently enabled.

An action must be enabled in order to be activated or in order to
have its state changed from outside callers.</doc>
        <source-position filename="gactiongroup.h" line="117" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="10572">whether or not the action is currently enabled</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10564">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10565">the name of the action to query</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10564">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10565">the name of the action to query</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_action_parameter_type" c:identifier="g_action_group_get_action_parameter_type" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="GetActionParameterType" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="10577">Queries the type of the parameter that must be given when activating
the named action within @action_group.

When activating the action using g_action_group_activate_action(),
the #GVariant given to that function must be of the type returned
by this function.

In the case that this function returns %NULL, you must not give any
#GVariant, but %NULL instead.

The parameter type of a particular action will never change but it is
possible for an action to be removed and for a new action to be added
with the same name but a different parameter type.</doc>
        <source-position filename="gactiongroup.h" line="107" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="10596">the parameter type</doc>
          <type name="GLib.VariantType" c:type="const GVariantType*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10579">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10580">the name of the action to query</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10579">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10580">the name of the action to query</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_action_state" c:identifier="g_action_group_get_action_state" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="GetActionState" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="10601">Queries the current state of the named action within @action_group.

If the action is not stateful then %NULL will be returned.  If the
action is stateful then the type of the return value is the type
given by g_action_group_get_action_state_type().

The return value (if non-%NULL) should be freed with
g_variant_unref() when it is no longer required.</doc>
        <source-position filename="gactiongroup.h" line="121" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="10615">the current state of the action</doc>
          <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10603">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10604">the name of the action to query</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10603">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10604">the name of the action to query</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_action_state_hint" c:identifier="g_action_group_get_action_state_hint" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="GetActionStateHint" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="10620">Requests a hint about the valid range of values for the state of the
named action within @action_group.

If %NULL is returned it either means that the action is not stateful
or that there is no hint about the valid range of values for the
state of the action.

If a #GVariant array is returned then each item in the array is a
possible value for the state.  If a #GVariant pair (ie: two-tuple) is
returned then the tuple specifies the inclusive lower and upper bound
of valid values for the state.

In any case, the information is merely a hint.  It may be possible to
have a state value outside of the hinted range and setting a value
within the range may fail.

The return value (if non-%NULL) should be freed with
g_variant_unref() when it is no longer required.</doc>
        <source-position filename="gactiongroup.h" line="113" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="10644">the state range hint</doc>
          <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10622">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10623">the name of the action to query</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10622">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10623">the name of the action to query</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_action_state_type" c:identifier="g_action_group_get_action_state_type" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="GetActionStateType" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="10649">Queries the type of the state of the named action within
@action_group.

If the action is stateful then this function returns the
#GVariantType of the state.  All calls to
g_action_group_change_action_state() must give a #GVariant of this
type and g_action_group_get_action_state() will return a #GVariant
of the same type.

If the action is not stateful then this function will return %NULL.
In that case, g_action_group_get_action_state() will return %NULL
and you must not call g_action_group_change_action_state().

The state type of a particular action will never change but it is
possible for an action to be removed and for a new action to be added
with the same name but a different state type.</doc>
        <source-position filename="gactiongroup.h" line="110" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="10671">the state type, if the action is stateful</doc>
          <type name="GLib.VariantType" c:type="const GVariantType*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10651">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10652">the name of the action to query</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10651">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10652">the name of the action to query</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="has_action" c:identifier="g_action_group_has_action" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="HasAction" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="10676">Checks if the named action exists within @action_group.</doc>
        <source-position filename="gactiongroup.h" line="101" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="10683">whether the named action exists</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10678">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10679">the name of the action to check for</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10678">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10679">the name of the action to check for</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="list_actions" c:identifier="g_action_group_list_actions" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="ListActions" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="10688">Lists the actions contained within @action_group.

The caller is responsible for freeing the list with g_strfreev() when
it is no longer required.</doc>
        <source-position filename="gactiongroup.h" line="104" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="10697">a %NULL-terminated array of the names of the
actions in the group</doc>
          <array c:type="gchar**" zero-terminated="1" gs:is-pointer="1">
            <type name="utf8" gs:is-pointer="1" />
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10690">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10690">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="query_action" c:identifier="g_action_group_query_action" version="2.32" gs:dll-name="gio-2.0" gs:managed-name="TryQueryAction" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="10703">Queries all aspects of the named action within an @action_group.

This function acquires the information available from
g_action_group_has_action(), g_action_group_get_action_enabled(),
g_action_group_get_action_parameter_type(),
g_action_group_get_action_state_type(),
g_action_group_get_action_state_hint() and
g_action_group_get_action_state() with a single function call.

This provides two main benefits.

The first is the improvement in efficiency that comes with not having
to perform repeated lookups of the action in order to discover
different things about it.  The second is that implementing
#GActionGroup can now be done by only overriding this one virtual
function.

The interface provides a default implementation of this function that
calls the individual functions, as required, to fetch the
information.  The interface also provides default implementations of
those functions that call this function.  All implementations,
therefore, must override either this function or all of the others.

If the action exists, %TRUE is returned and any of the requested
fields (as indicated by having a non-%NULL reference passed in) are
filled.  If the action doesn't exist, %FALSE is returned and the
fields may or may not have been modified.</doc>
        <source-position filename="gactiongroup.h" line="151" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="10741">%TRUE if the action exists, else %FALSE</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10705">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10706">the name of an action in the group</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="enabled" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="enabled">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10707">if the action is presently enabled</doc>
            <type name="gboolean" c:type="gboolean*" />
          </parameter>
          <parameter name="parameter_type" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="parameterType">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10708">the parameter type, or %NULL if none needed</doc>
            <type name="GLib.VariantType" c:type="const GVariantType**" gs:is-pointer="1" />
          </parameter>
          <parameter name="state_type" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="stateType">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10709">the state type, or %NULL if stateless</doc>
            <type name="GLib.VariantType" c:type="const GVariantType**" gs:is-pointer="1" />
          </parameter>
          <parameter name="state_hint" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="stateHint">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10710">the state hint, or %NULL if none</doc>
            <type name="GLib.Variant" c:type="GVariant**" gs:is-pointer="1" />
          </parameter>
          <parameter name="state" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="state">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10711">the current state, or %NULL if stateless</doc>
            <type name="GLib.Variant" c:type="GVariant**" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10705">a #GActionGroup</doc>
            <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10706">the name of an action in the group</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="enabled" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="enabled">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10707">if the action is presently enabled</doc>
            <type name="gboolean" c:type="gboolean*" />
          </parameter>
          <parameter name="parameter_type" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="parameterType">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10708">the parameter type, or %NULL if none needed</doc>
            <type name="GLib.VariantType" c:type="const GVariantType**" gs:is-pointer="1" />
          </parameter>
          <parameter name="state_type" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="stateType">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10709">the state type, or %NULL if stateless</doc>
            <type name="GLib.VariantType" c:type="const GVariantType**" gs:is-pointer="1" />
          </parameter>
          <parameter name="state_hint" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="stateHint">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10710">the state hint, or %NULL if none</doc>
            <type name="GLib.Variant" c:type="GVariant**" gs:is-pointer="1" />
          </parameter>
          <parameter name="state" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="state">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10711">the current state, or %NULL if stateless</doc>
            <type name="GLib.Variant" c:type="GVariant**" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <glib:signal name="action-added" when="last" detailed="1" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="ActionAddedSignal">
        <doc xml:space="preserve" filename="gio-2.0.c" line="108">Signals that a new action was just added to the group.
This signal is emitted after the action has been added
and is now visible.</doc>
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
            <doc>the instance on which the signal was invoked</doc>
            <type name="ActionGroup" c:name="gpointer" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="111">the name of the action in @action_group</doc>
            <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="1" gs:managed-name="userData" direction="in">
            <type name="gpointer" c:name="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
            <doc>the instance on which the signal was invoked</doc>
            <type name="ActionGroup" c:name="gpointer" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="111">the name of the action in @action_group</doc>
            <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </glib:signal>
      <glib:signal name="action-enabled-changed" when="last" detailed="1" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="ActionEnabledChangedSignal">
        <doc xml:space="preserve" filename="gio-2.0.c" line="121">Signals that the enabled status of the named action has changed.</doc>
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
            <doc>the instance on which the signal was invoked</doc>
            <type name="ActionGroup" c:name="gpointer" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="124">the name of the action in @action_group</doc>
            <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="enabled" transfer-ownership="none" gs:managed-name="enabled" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="125">whether the action is enabled or not</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="2" gs:managed-name="userData" direction="in">
            <type name="gpointer" c:name="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
            <doc>the instance on which the signal was invoked</doc>
            <type name="ActionGroup" c:name="gpointer" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="124">the name of the action in @action_group</doc>
            <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="enabled" transfer-ownership="none" gs:managed-name="enabled" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="125">whether the action is enabled or not</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
        </gs:managed-parameters>
      </glib:signal>
      <glib:signal name="action-removed" when="last" detailed="1" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="ActionRemovedSignal">
        <doc xml:space="preserve" filename="gio-2.0.c" line="133">Signals that an action is just about to be removed from the group.
This signal is emitted before the action is removed, so the action
is still visible and can be queried from the signal handler.</doc>
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
            <doc>the instance on which the signal was invoked</doc>
            <type name="ActionGroup" c:name="gpointer" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="136">the name of the action in @action_group</doc>
            <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="1" gs:managed-name="userData" direction="in">
            <type name="gpointer" c:name="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
            <doc>the instance on which the signal was invoked</doc>
            <type name="ActionGroup" c:name="gpointer" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="136">the name of the action in @action_group</doc>
            <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </glib:signal>
      <glib:signal name="action-state-changed" when="last" detailed="1" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="ActionStateChangedSignal">
        <doc xml:space="preserve" filename="gio-2.0.c" line="146">Signals that the state of the named action has changed.</doc>
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
            <doc>the instance on which the signal was invoked</doc>
            <type name="ActionGroup" c:name="gpointer" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="149">the name of the action in @action_group</doc>
            <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="150">the new value of the state</doc>
            <type name="GLib.Variant" gs:is-pointer="1" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="2" gs:managed-name="userData" direction="in">
            <type name="gpointer" c:name="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
            <doc>the instance on which the signal was invoked</doc>
            <type name="ActionGroup" c:name="gpointer" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="149">the name of the action in @action_group</doc>
            <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="150">the new value of the state</doc>
            <type name="GLib.Variant" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </glib:signal>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_action_group_get_type" gs:access-modifiers="private" gs:dll-name="gio-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </interface>
    <record name="ActionGroupInterface" c:type="GActionGroupInterface" glib:is-gtype-struct-for="ActionGroup" version="2.28" gs:managed-name="ActionGroupInterface">
      <doc xml:space="preserve" filename="gio-2.0.c" line="158">The virtual function table for #GActionGroup.</doc>
      <source-position filename="gactiongroup.h" line="95" />
      <field name="g_iface" gs:managed-name="GIface">
        <type name="GObject.TypeInterface" c:type="GTypeInterface" />
      </field>
      <field name="has_action" gs:managed-name="HasAction">
        <callback name="has_action" gs:dll-name="gio-2.0" gs:managed-name="HasAction">
          <source-position filename="gactiongroup.h" line="47" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10683">whether the named action exists</doc>
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10678">a #GActionGroup</doc>
              <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
            </parameter>
            <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10679">the name of the action to check for</doc>
              <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10678">a #GActionGroup</doc>
              <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
            </parameter>
            <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10679">the name of the action to check for</doc>
              <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="list_actions" gs:managed-name="ListActions">
        <callback name="list_actions" gs:dll-name="gio-2.0" gs:managed-name="ListActions">
          <source-position filename="gactiongroup.h" line="50" />
          <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10697">a %NULL-terminated array of the names of the
actions in the group</doc>
            <array c:type="gchar**" zero-terminated="1" gs:is-pointer="1">
              <type name="utf8" gs:is-pointer="1" />
            </array>
          </return-value>
          <parameters>
            <parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10690">a #GActionGroup</doc>
              <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10690">a #GActionGroup</doc>
              <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="get_action_enabled" gs:managed-name="GetActionEnabled">
        <callback name="get_action_enabled" gs:dll-name="gio-2.0" gs:managed-name="GetActionEnabled">
          <source-position filename="gactiongroup.h" line="52" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10572">whether or not the action is currently enabled</doc>
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10564">a #GActionGroup</doc>
              <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
            </parameter>
            <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10565">the name of the action to query</doc>
              <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10564">a #GActionGroup</doc>
              <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
            </parameter>
            <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10565">the name of the action to query</doc>
              <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="get_action_parameter_type" gs:managed-name="GetActionParameterType">
        <callback name="get_action_parameter_type" gs:dll-name="gio-2.0" gs:managed-name="GetActionParameterType">
          <source-position filename="gactiongroup.h" line="55" />
          <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10596">the parameter type</doc>
            <type name="GLib.VariantType" c:type="const GVariantType*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10579">a #GActionGroup</doc>
              <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
            </parameter>
            <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10580">the name of the action to query</doc>
              <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10579">a #GActionGroup</doc>
              <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
            </parameter>
            <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10580">the name of the action to query</doc>
              <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="get_action_state_type" gs:managed-name="GetActionStateType">
        <callback name="get_action_state_type" gs:dll-name="gio-2.0" gs:managed-name="GetActionStateType">
          <source-position filename="gactiongroup.h" line="58" />
          <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10671">the state type, if the action is stateful</doc>
            <type name="GLib.VariantType" c:type="const GVariantType*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10651">a #GActionGroup</doc>
              <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
            </parameter>
            <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10652">the name of the action to query</doc>
              <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10651">a #GActionGroup</doc>
              <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
            </parameter>
            <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10652">the name of the action to query</doc>
              <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="get_action_state_hint" gs:managed-name="GetActionStateHint">
        <callback name="get_action_state_hint" gs:dll-name="gio-2.0" gs:managed-name="GetActionStateHint">
          <source-position filename="gactiongroup.h" line="61" />
          <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10644">the state range hint</doc>
            <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10622">a #GActionGroup</doc>
              <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
            </parameter>
            <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10623">the name of the action to query</doc>
              <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10622">a #GActionGroup</doc>
              <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
            </parameter>
            <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10623">the name of the action to query</doc>
              <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="get_action_state" gs:managed-name="GetActionState">
        <callback name="get_action_state" gs:dll-name="gio-2.0" gs:managed-name="GetActionState">
          <source-position filename="gactiongroup.h" line="64" />
          <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10615">the current state of the action</doc>
            <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10603">a #GActionGroup</doc>
              <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
            </parameter>
            <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10604">the name of the action to query</doc>
              <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10603">a #GActionGroup</doc>
              <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
            </parameter>
            <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10604">the name of the action to query</doc>
              <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="change_action_state" gs:managed-name="ChangeActionState">
        <callback name="change_action_state" gs:dll-name="gio-2.0" gs:managed-name="ChangeActionState">
          <source-position filename="gactiongroup.h" line="67" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10542">a #GActionGroup</doc>
              <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
            </parameter>
            <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10543">the name of the action to request the change on</doc>
              <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
            </parameter>
            <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10544">the new state</doc>
              <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10542">a #GActionGroup</doc>
              <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
            </parameter>
            <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10543">the name of the action to request the change on</doc>
              <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
            </parameter>
            <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10544">the new state</doc>
              <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="activate_action" gs:managed-name="ActivateAction">
        <callback name="activate_action" gs:dll-name="gio-2.0" gs:managed-name="ActivateAction">
          <source-position filename="gactiongroup.h" line="71" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10498">a #GActionGroup</doc>
              <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
            </parameter>
            <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10499">the name of the action to activate</doc>
              <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
            </parameter>
            <parameter name="parameter" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="parameter" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10500">parameters to the activation</doc>
              <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10498">a #GActionGroup</doc>
              <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
            </parameter>
            <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10499">the name of the action to activate</doc>
              <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
            </parameter>
            <parameter name="parameter" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="parameter" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10500">parameters to the activation</doc>
              <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="action_added" gs:managed-name="ActionAdded">
        <callback name="action_added" gs:dll-name="gio-2.0" gs:managed-name="ActionAdded">
          <source-position filename="gactiongroup.h" line="76" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10444">a #GActionGroup</doc>
              <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
            </parameter>
            <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10445">the name of an action in the group</doc>
              <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10444">a #GActionGroup</doc>
              <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
            </parameter>
            <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10445">the name of an action in the group</doc>
              <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="action_removed" gs:managed-name="ActionRemoved">
        <callback name="action_removed" gs:dll-name="gio-2.0" gs:managed-name="ActionRemoved">
          <source-position filename="gactiongroup.h" line="78" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10471">a #GActionGroup</doc>
              <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
            </parameter>
            <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10472">the name of an action in the group</doc>
              <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10471">a #GActionGroup</doc>
              <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
            </parameter>
            <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10472">the name of an action in the group</doc>
              <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="action_enabled_changed" gs:managed-name="ActionEnabledChanged">
        <callback name="action_enabled_changed" gs:dll-name="gio-2.0" gs:managed-name="ActionEnabledChanged">
          <source-position filename="gactiongroup.h" line="80" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10457">a #GActionGroup</doc>
              <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
            </parameter>
            <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10458">the name of an action in the group</doc>
              <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
            </parameter>
            <parameter name="enabled" transfer-ownership="none" gs:managed-name="enabled" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10459">whether or not the action is now enabled</doc>
              <type name="gboolean" c:type="gboolean" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10457">a #GActionGroup</doc>
              <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
            </parameter>
            <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10458">the name of an action in the group</doc>
              <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
            </parameter>
            <parameter name="enabled" transfer-ownership="none" gs:managed-name="enabled" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10459">whether or not the action is now enabled</doc>
              <type name="gboolean" c:type="gboolean" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="action_state_changed" gs:managed-name="ActionStateChanged">
        <callback name="action_state_changed" gs:dll-name="gio-2.0" gs:managed-name="ActionStateChanged">
          <source-position filename="gactiongroup.h" line="83" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10484">a #GActionGroup</doc>
              <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
            </parameter>
            <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10485">the name of an action in the group</doc>
              <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
            </parameter>
            <parameter name="state" transfer-ownership="none" gs:managed-name="state" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10486">the new state of the named action</doc>
              <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="action_group" transfer-ownership="none" gs:managed-name="actionGroup" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10484">a #GActionGroup</doc>
              <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
            </parameter>
            <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10485">the name of an action in the group</doc>
              <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
            </parameter>
            <parameter name="state" transfer-ownership="none" gs:managed-name="state" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10486">the new state of the named action</doc>
              <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="query_action" gs:managed-name="QueryAction">
        <type name="gpointer" />
      </field>
    </record>
    <record name="ActionInterface" c:type="GActionInterface" glib:is-gtype-struct-for="Action" version="2.28" gs:managed-name="ActionInterface">
      <doc xml:space="preserve" filename="gio-2.0.c" line="181">The virtual function table for #GAction.</doc>
      <source-position filename="gaction.h" line="57" />
      <field name="g_iface" gs:managed-name="GIface">
        <type name="GObject.TypeInterface" c:type="GTypeInterface" />
      </field>
      <field name="get_name" gs:managed-name="GetName">
        <callback name="get_name" gs:dll-name="gio-2.0" gs:managed-name="GetName">
          <source-position filename="gaction.h" line="45" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10351">the name of the action</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="action" transfer-ownership="none" gs:managed-name="action" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10347">a #GAction</doc>
              <type name="Action" c:type="GAction*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="action" transfer-ownership="none" gs:managed-name="action" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10347">a #GAction</doc>
              <type name="Action" c:type="GAction*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="get_parameter_type" gs:managed-name="GetParameterType">
        <callback name="get_parameter_type" gs:dll-name="gio-2.0" gs:managed-name="GetParameterType">
          <source-position filename="gaction.h" line="46" />
          <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10369">the parameter type</doc>
            <type name="GLib.VariantType" c:type="const GVariantType*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="action" transfer-ownership="none" gs:managed-name="action" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10358">a #GAction</doc>
              <type name="Action" c:type="GAction*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="action" transfer-ownership="none" gs:managed-name="action" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10358">a #GAction</doc>
              <type name="Action" c:type="GAction*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="get_state_type" gs:managed-name="GetStateType">
        <callback name="get_state_type" gs:dll-name="gio-2.0" gs:managed-name="GetStateType">
          <source-position filename="gaction.h" line="47" />
          <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10437">the state type, if the action is stateful</doc>
            <type name="GLib.VariantType" c:type="const GVariantType*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="action" transfer-ownership="none" gs:managed-name="action" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10422">a #GAction</doc>
              <type name="Action" c:type="GAction*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="action" transfer-ownership="none" gs:managed-name="action" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10422">a #GAction</doc>
              <type name="Action" c:type="GAction*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="get_state_hint" gs:managed-name="GetStateHint">
        <callback name="get_state_hint" gs:dll-name="gio-2.0" gs:managed-name="GetStateHint">
          <source-position filename="gaction.h" line="48" />
          <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10415">the state range hint</doc>
            <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="action" transfer-ownership="none" gs:managed-name="action" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10394">a #GAction</doc>
              <type name="Action" c:type="GAction*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="action" transfer-ownership="none" gs:managed-name="action" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10394">a #GAction</doc>
              <type name="Action" c:type="GAction*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="get_enabled" gs:managed-name="GetEnabled">
        <callback name="get_enabled" gs:dll-name="gio-2.0" gs:managed-name="GetEnabled">
          <source-position filename="gaction.h" line="50" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10340">whether the action is enabled</doc>
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="action" transfer-ownership="none" gs:managed-name="action" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10333">a #GAction</doc>
              <type name="Action" c:type="GAction*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="action" transfer-ownership="none" gs:managed-name="action" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10333">a #GAction</doc>
              <type name="Action" c:type="GAction*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="get_state" gs:managed-name="GetState">
        <callback name="get_state" gs:dll-name="gio-2.0" gs:managed-name="GetState">
          <source-position filename="gaction.h" line="51" />
          <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10387">the current state of the action</doc>
            <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="action" transfer-ownership="none" gs:managed-name="action" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10376">a #GAction</doc>
              <type name="Action" c:type="GAction*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="action" transfer-ownership="none" gs:managed-name="action" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10376">a #GAction</doc>
              <type name="Action" c:type="GAction*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="change_state" gs:managed-name="ChangeState">
        <callback name="change_state" gs:dll-name="gio-2.0" gs:managed-name="ChangeState">
          <source-position filename="gaction.h" line="53" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="action" transfer-ownership="none" gs:managed-name="action" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10313">a #GAction</doc>
              <type name="Action" c:type="GAction*" gs:is-pointer="1" />
            </parameter>
            <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10314">the new state</doc>
              <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="action" transfer-ownership="none" gs:managed-name="action" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10313">a #GAction</doc>
              <type name="Action" c:type="GAction*" gs:is-pointer="1" />
            </parameter>
            <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10314">the new state</doc>
              <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="activate" gs:managed-name="Activate">
        <callback name="activate" gs:dll-name="gio-2.0" gs:managed-name="Activate">
          <source-position filename="gaction.h" line="55" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="action" transfer-ownership="none" gs:managed-name="action" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10296">a #GAction</doc>
              <type name="Action" c:type="GAction*" gs:is-pointer="1" />
            </parameter>
            <parameter name="parameter" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="parameter" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10297">the parameter to the activation</doc>
              <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="action" transfer-ownership="none" gs:managed-name="action" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10296">a #GAction</doc>
              <type name="Action" c:type="GAction*" gs:is-pointer="1" />
            </parameter>
            <parameter name="parameter" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="parameter" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10297">the parameter to the activation</doc>
              <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
    </record>
    <interface name="ActionMap" c:symbol-prefix="action_map" c:type="GActionMap" version="2.32" glib:type-name="GActionMap" glib:get-type="g_action_map_get_type" glib:type-struct="ActionMapInterface" gs:managed-name="IActionMap">
      <doc xml:space="preserve" filename="gio-2.0.c" line="4628">The GActionMap interface is implemented by #GActionGroup
implementations that operate by containing a number of
named #GAction instances, such as #GSimpleActionGroup.

One useful application of this interface is to map the
names of actions from various action groups to unique,
prefixed names (e.g. by prepending "app." or "win.").
This is the motivation for the 'Map' part of the interface
name.</doc>
      <source-position filename="gactionmap.h" line="53" />
      <virtual-method name="add_action" invoker="add_action" version="2.32" gs:dll-name="gio-2.0" gs:managed-name="DoAddAction">
        <doc xml:space="preserve" filename="gio-2.0.c" line="10746">Adds an action to the @action_map.

If the action map already contains an action with the same name
as @action then the old action is dropped from the action map.

The action map takes its own reference on @action.</doc>
        <source-position filename="gactionmap.h" line="49" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="action_map" transfer-ownership="none" gs:managed-name="actionMap" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10748">a #GActionMap</doc>
            <type name="ActionMap" c:type="GActionMap*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action" transfer-ownership="none" gs:managed-name="action" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10749">a #GAction</doc>
            <type name="Action" c:type="GAction*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="action" transfer-ownership="none" gs:managed-name="action" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10749">a #GAction</doc>
            <type name="Action" c:type="GAction*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="lookup_action" invoker="lookup_action" version="2.32" gs:dll-name="gio-2.0" gs:managed-name="DoLookupAction">
        <doc xml:space="preserve" filename="gio-2.0.c" line="10812">Looks up the action with the name @action_name in @action_map.

If no such action exists, returns %NULL.</doc>
        <source-position filename="gactionmap.h" line="47" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="10821">a #GAction, or %NULL</doc>
          <type name="Action" c:type="GAction*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="action_map" transfer-ownership="none" gs:managed-name="actionMap" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10814">a #GActionMap</doc>
            <type name="ActionMap" c:type="GActionMap*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10815">the name of an action</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10815">the name of an action</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="remove_action" invoker="remove_action" version="2.32" gs:dll-name="gio-2.0" gs:managed-name="DoRemoveAction">
        <doc xml:space="preserve" filename="gio-2.0.c" line="10826">Removes the named action from the action map.

If no action of this name is in the map then nothing happens.</doc>
        <source-position filename="gactionmap.h" line="51" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="action_map" transfer-ownership="none" gs:managed-name="actionMap" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10828">a #GActionMap</doc>
            <type name="ActionMap" c:type="GActionMap*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10829">the name of the action</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10829">the name of the action</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <method name="add_action" c:identifier="g_action_map_add_action" version="2.32" gs:dll-name="gio-2.0" gs:managed-name="AddAction" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="10746">Adds an action to the @action_map.

If the action map already contains an action with the same name
as @action then the old action is dropped from the action map.

The action map takes its own reference on @action.</doc>
        <source-position filename="gactionmap.h" line="82" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="action_map" transfer-ownership="none" gs:managed-name="actionMap" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10748">a #GActionMap</doc>
            <type name="ActionMap" c:type="GActionMap*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action" transfer-ownership="none" gs:managed-name="action" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10749">a #GAction</doc>
            <type name="Action" c:type="GAction*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="action_map" transfer-ownership="none" gs:managed-name="actionMap" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10748">a #GActionMap</doc>
            <type name="ActionMap" c:type="GActionMap*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action" transfer-ownership="none" gs:managed-name="action" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10749">a #GAction</doc>
            <type name="Action" c:type="GAction*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="lookup_action" c:identifier="g_action_map_lookup_action" version="2.32" gs:dll-name="gio-2.0" gs:managed-name="LookupAction" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="10812">Looks up the action with the name @action_name in @action_map.

If no such action exists, returns %NULL.</doc>
        <source-position filename="gactionmap.h" line="79" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="10821">a #GAction, or %NULL</doc>
          <type name="Action" c:type="GAction*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="action_map" transfer-ownership="none" gs:managed-name="actionMap" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10814">a #GActionMap</doc>
            <type name="ActionMap" c:type="GActionMap*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10815">the name of an action</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="action_map" transfer-ownership="none" gs:managed-name="actionMap" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10814">a #GActionMap</doc>
            <type name="ActionMap" c:type="GActionMap*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10815">the name of an action</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="remove_action" c:identifier="g_action_map_remove_action" version="2.32" gs:dll-name="gio-2.0" gs:managed-name="RemoveAction" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="10826">Removes the named action from the action map.

If no action of this name is in the map then nothing happens.</doc>
        <source-position filename="gactionmap.h" line="85" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="action_map" transfer-ownership="none" gs:managed-name="actionMap" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10828">a #GActionMap</doc>
            <type name="ActionMap" c:type="GActionMap*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10829">the name of the action</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="action_map" transfer-ownership="none" gs:managed-name="actionMap" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10828">a #GActionMap</doc>
            <type name="ActionMap" c:type="GActionMap*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10829">the name of the action</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_action_map_get_type" gs:access-modifiers="private" gs:dll-name="gio-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </interface>
    <record name="ActionMapInterface" c:type="GActionMapInterface" glib:is-gtype-struct-for="ActionMap" version="2.32" gs:managed-name="ActionMapInterface">
      <doc xml:space="preserve" filename="gio-2.0.c" line="207">The virtual function table for #GActionMap.</doc>
      <source-position filename="gactionmap.h" line="53" />
      <field name="g_iface" gs:managed-name="GIface">
        <type name="GObject.TypeInterface" c:type="GTypeInterface" />
      </field>
      <field name="lookup_action" gs:managed-name="LookupAction">
        <callback name="lookup_action" gs:dll-name="gio-2.0" gs:managed-name="LookupAction">
          <source-position filename="gactionmap.h" line="47" />
          <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="10821">a #GAction, or %NULL</doc>
            <type name="Action" c:type="GAction*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="action_map" transfer-ownership="none" gs:managed-name="actionMap" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10814">a #GActionMap</doc>
              <type name="ActionMap" c:type="GActionMap*" gs:is-pointer="1" />
            </parameter>
            <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10815">the name of an action</doc>
              <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="action_map" transfer-ownership="none" gs:managed-name="actionMap" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10814">a #GActionMap</doc>
              <type name="ActionMap" c:type="GActionMap*" gs:is-pointer="1" />
            </parameter>
            <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10815">the name of an action</doc>
              <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="add_action" gs:managed-name="AddAction">
        <callback name="add_action" gs:dll-name="gio-2.0" gs:managed-name="AddAction">
          <source-position filename="gactionmap.h" line="49" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="action_map" transfer-ownership="none" gs:managed-name="actionMap" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10748">a #GActionMap</doc>
              <type name="ActionMap" c:type="GActionMap*" gs:is-pointer="1" />
            </parameter>
            <parameter name="action" transfer-ownership="none" gs:managed-name="action" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10749">a #GAction</doc>
              <type name="Action" c:type="GAction*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="action_map" transfer-ownership="none" gs:managed-name="actionMap" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10748">a #GActionMap</doc>
              <type name="ActionMap" c:type="GActionMap*" gs:is-pointer="1" />
            </parameter>
            <parameter name="action" transfer-ownership="none" gs:managed-name="action" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10749">a #GAction</doc>
              <type name="Action" c:type="GAction*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="remove_action" gs:managed-name="RemoveAction">
        <callback name="remove_action" gs:dll-name="gio-2.0" gs:managed-name="RemoveAction">
          <source-position filename="gactionmap.h" line="51" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="action_map" transfer-ownership="none" gs:managed-name="actionMap" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10828">a #GActionMap</doc>
              <type name="ActionMap" c:type="GActionMap*" gs:is-pointer="1" />
            </parameter>
            <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10829">the name of the action</doc>
              <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="action_map" transfer-ownership="none" gs:managed-name="actionMap" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10828">a #GActionMap</doc>
              <type name="ActionMap" c:type="GActionMap*" gs:is-pointer="1" />
            </parameter>
            <parameter name="action_name" transfer-ownership="none" gs:managed-name="actionName" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="10829">the name of the action</doc>
              <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
    </record>
    <class name="Application" c:symbol-prefix="application" c:type="GApplication" version="2.28" parent="GObject.Object" glib:type-name="GApplication" glib:get-type="g_application_get_type" glib:type-struct="ApplicationClass" gs:managed-name="Application">
      <doc xml:space="preserve" filename="gio-2.0.c" line="4731">A #GApplication is the foundation of an application.  It wraps some
low-level platform-specific services and is intended to act as the
foundation for higher-level application classes such as
#GtkApplication or #MxApplication.  In general, you should not use
this class outside of a higher level framework.

GApplication provides convenient life cycle management by maintaining
a "use count" for the primary application instance. The use count can
be changed using g_application_hold() and g_application_release(). If
it drops to zero, the application exits. Higher-level classes such as
#GtkApplication employ the use count to ensure that the application
stays alive as long as it has any opened windows.

Another feature that GApplication (optionally) provides is process
uniqueness. Applications can make use of this functionality by
providing a unique application ID. If given, only one application
with this ID can be running at a time per session. The session
concept is platform-dependent, but corresponds roughly to a graphical
desktop login. When your application is launched again, its
arguments are passed through platform communication to the already
running program. The already running instance of the program is
called the "primary instance"; for non-unique applications this is
always the current instance. On Linux, the D-Bus session bus
is used for communication.

The use of #GApplication differs from some other commonly-used
uniqueness libraries (such as libunique) in important ways. The
application is not expected to manually register itself and check
if it is the primary instance. Instead, the main() function of a
#GApplication should do very little more than instantiating the
application instance, possibly connecting signal handlers, then
calling g_application_run(). All checks for uniqueness are done
internally. If the application is the primary instance then the
startup signal is emitted and the mainloop runs. If the application
is not the primary instance then a signal is sent to the primary
instance and g_application_run() promptly returns. See the code
examples below.

If used, the expected form of an application identifier is the same as
that of of a
[D-Bus well-known bus name](https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-names-bus).
Examples include: `com.example.MyApp`, `org.example.internal_apps.Calculator`,
`org._7_zip.Archiver`.
For details on valid application identifiers, see g_application_id_is_valid().

On Linux, the application identifier is claimed as a well-known bus name
on the user's session bus.  This means that the uniqueness of your
application is scoped to the current session.  It also means that your
application may provide additional services (through registration of other
object paths) at that bus name.  The registration of these object paths
should be done with the shared GDBus session bus.  Note that due to the
internal architecture of GDBus, method calls can be dispatched at any time
(even if a main loop is not running).  For this reason, you must ensure that
any object paths that you wish to register are registered before #GApplication
attempts to acquire the bus name of your application (which happens in
g_application_register()).  Unfortunately, this means that you cannot use
g_application_get_is_remote() to decide if you want to register object paths.

GApplication also implements the #GActionGroup and #GActionMap
interfaces and lets you easily export actions by adding them with
g_action_map_add_action(). When invoking an action by calling
g_action_group_activate_action() on the application, it is always
invoked in the primary instance. The actions are also exported on
the session bus, and GIO provides the #GDBusActionGroup wrapper to
conveniently access them remotely. GIO provides a #GDBusMenuModel wrapper
for remote access to exported #GMenuModels.

There is a number of different entry points into a GApplication:

- via 'Activate' (i.e. just starting the application)

- via 'Open' (i.e. opening some files)

- by handling a command-line

- via activating an action

The #GApplication::startup signal lets you handle the application
initialization for all of these in a single place.

Regardless of which of these entry points is used to start the
application, GApplication passes some ‘platform data’ from the
launching instance to the primary instance, in the form of a
#GVariant dictionary mapping strings to variants. To use platform
data, override the @before_emit or @after_emit virtual functions
in your #GApplication subclass. When dealing with
#GApplicationCommandLine objects, the platform data is
directly available via g_application_command_line_get_cwd(),
g_application_command_line_get_environ() and
g_application_command_line_get_platform_data().

As the name indicates, the platform data may vary depending on the
operating system, but it always includes the current directory (key
"cwd"), and optionally the environment (ie the set of environment
variables and their values) of the calling process (key "environ").
The environment is only added to the platform data if the
%G_APPLICATION_SEND_ENVIRONMENT flag is set. #GApplication subclasses
can add their own platform data by overriding the @add_platform_data
virtual function. For instance, #GtkApplication adds startup notification
data in this way.

To parse commandline arguments you may handle the
#GApplication::command-line signal or override the local_command_line()
vfunc, to parse them in either the primary instance or the local instance,
respectively.

For an example of opening files with a GApplication, see
[gapplication-example-open.c](https://git.gnome.org/browse/glib/tree/gio/tests/gapplication-example-open.c).

For an example of using actions with GApplication, see
[gapplication-example-actions.c](https://git.gnome.org/browse/glib/tree/gio/tests/gapplication-example-actions.c).

For an example of using extra D-Bus hooks with GApplication, see
[gapplication-example-dbushooks.c](https://git.gnome.org/browse/glib/tree/gio/tests/gapplication-example-dbushooks.c).</doc>
      <source-position filename="gapplication.h" line="119" />
      <implements name="ActionGroup" gs:managed-name="ActionGroup" />
      <implements name="ActionMap" gs:managed-name="ActionMap" />
      <constructor name="new" c:identifier="g_application_new" gs:dll-name="gio-2.0" gs:managed-name="New">
        <doc xml:space="preserve" filename="gio-2.0.c" line="12212">Creates a new #GApplication instance.

If non-%NULL, the application id must be valid.  See
g_application_id_is_valid().

If no application ID is given then some features of #GApplication
(most notably application uniqueness) will be disabled.</doc>
        <source-position filename="gapplication.h" line="128" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="12225">a new #GApplication instance</doc>
          <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="application_id" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="applicationId" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12214">the application id</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12215">the application flags</doc>
            <type name="ApplicationFlags" c:type="GApplicationFlags" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="application_id" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="applicationId" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12214">the application id</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12215">the application flags</doc>
            <type name="ApplicationFlags" c:type="GApplicationFlags" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <gs:managed-property name="get_default" version="2.32" gs:dll-name="gio-2.0" gs:managed-name="Default">
        <doc xml:space="preserve" filename="gio-2.0.c" line="12023">Returns the default #GApplication instance for this process.

Normally there is only one #GApplication per process and it becomes
the default when it is created.  You can exercise more control over
this by using g_application_set_default().

If there is no default application then %NULL is returned.</doc>
        <source-position filename="gapplication.h" line="221" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="12034">the default application for this process, or %NULL</doc>
          <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </gs:managed-property>
      <function name="get_default" c:identifier="g_application_get_default" version="2.32" gs:dll-name="gio-2.0" gs:managed-name="GetDefault" gs:property-getter-for="Default" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="12023">Returns the default #GApplication instance for this process.

Normally there is only one #GApplication per process and it becomes
the default when it is created.  You can exercise more control over
this by using g_application_set_default().

If there is no default application then %NULL is returned.</doc>
        <source-position filename="gapplication.h" line="221" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="12034">the default application for this process, or %NULL</doc>
          <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
      <function name="id_is_valid" c:identifier="g_application_id_is_valid" gs:dll-name="gio-2.0" gs:managed-name="IdIsValid">
        <doc xml:space="preserve" filename="gio-2.0.c" line="12139">Checks if @application_id is a valid application identifier.

A valid ID is required for calls to g_application_new() and
g_application_set_application_id().

Application identifiers follow the same format as
[D-Bus well-known bus names](https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-names-bus).
For convenience, the restrictions on application identifiers are
reproduced here:

- Application identifiers are composed of 1 or more elements separated by a
  period (`.`) character. All elements must contain at least one character.

- Each element must only contain the ASCII characters `[A-Z][a-z][0-9]_-`,
  with `-` discouraged in new application identifiers. Each element must not
  begin with a digit.

- Application identifiers must contain at least one `.` (period) character
  (and thus at least two elements).

- Application identifiers must not begin with a `.` (period) character.

- Application identifiers must not exceed 255 characters.

Note that the hyphen (`-`) character is allowed in application identifiers,
but is problematic or not allowed in various specifications and APIs that
refer to D-Bus, such as
[Flatpak application IDs](http://docs.flatpak.org/en/latest/introduction.html#identifiers),
the
[`DBusActivatable` interface in the Desktop Entry Specification](https://specifications.freedesktop.org/desktop-entry-spec/desktop-entry-spec-latest.html#dbus),
and the convention that an application's "main" interface and object path
resemble its application identifier and bus name. To avoid situations that
require special-case handling, it is recommended that new application
identifiers consistently replace hyphens with underscores.

Like D-Bus interface names, application identifiers should start with the
reversed DNS domain name of the author of the interface (in lower-case), and
it is conventional for the rest of the application identifier to consist of
words run together, with initial capital letters.

As with D-Bus interface names, if the author's DNS domain name contains
hyphen/minus characters they should be replaced by underscores, and if it
contains leading digits they should be escaped by prepending an underscore.
For example, if the owner of 7-zip.org used an application identifier for an
archiving application, it might be named `org._7_zip.Archiver`.</doc>
        <source-position filename="gapplication.h" line="125" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="12189">%TRUE if @application_id is valid</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <parameter name="application_id" transfer-ownership="none" gs:managed-name="applicationId" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12141">a potential application identifier</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="application_id" transfer-ownership="none" gs:managed-name="applicationId" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12141">a potential application identifier</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <virtual-method name="activate" invoker="activate" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="DoActivate">
        <doc xml:space="preserve" filename="gio-2.0.c" line="11553">Activates the application.

In essence, this results in the #GApplication::activate signal being
emitted in the primary instance.

The application must be registered before calling this function.</doc>
        <source-position filename="gapplication.h" line="61" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11555">a #GApplication</doc>
            <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </virtual-method>
      <virtual-method name="add_platform_data" gs:dll-name="gio-2.0" gs:managed-name="DoAddPlatformData">
        <source-position filename="gapplication.h" line="100" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="builder" transfer-ownership="none" gs:managed-name="builder" direction="in">
            <type name="GLib.VariantBuilder" c:type="GVariantBuilder*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="builder" transfer-ownership="none" gs:managed-name="builder" direction="in">
            <type name="GLib.VariantBuilder" c:type="GVariantBuilder*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="after_emit" gs:dll-name="gio-2.0" gs:managed-name="DoAfterEmit">
        <source-position filename="gapplication.h" line="98" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="platform_data" transfer-ownership="none" gs:managed-name="platformData" direction="in">
            <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="platform_data" transfer-ownership="none" gs:managed-name="platformData" direction="in">
            <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="before_emit" gs:dll-name="gio-2.0" gs:managed-name="DoBeforeEmit">
        <source-position filename="gapplication.h" line="96" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="platform_data" transfer-ownership="none" gs:managed-name="platformData" direction="in">
            <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="platform_data" transfer-ownership="none" gs:managed-name="platformData" direction="in">
            <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="command_line" gs:dll-name="gio-2.0" gs:managed-name="DoCommandLine">
        <source-position filename="gapplication.h" line="68" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="gint" c:type="int" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="command_line" transfer-ownership="none" gs:managed-name="commandLine" direction="in">
            <type name="ApplicationCommandLine" c:type="GApplicationCommandLine*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="command_line" transfer-ownership="none" gs:managed-name="commandLine" direction="in">
            <type name="ApplicationCommandLine" c:type="GApplicationCommandLine*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="handle_local_options" gs:dll-name="gio-2.0" gs:managed-name="DoHandleLocalOptions">
        <source-position filename="gapplication.h" line="113" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="gint" c:type="gint" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="options" transfer-ownership="none" gs:managed-name="options" direction="in">
            <type name="GLib.VariantDict" c:type="GVariantDict*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="options" transfer-ownership="none" gs:managed-name="options" direction="in">
            <type name="GLib.VariantDict" c:type="GVariantDict*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="local_command_line" gs:dll-name="gio-2.0" gs:managed-name="DoTryLocalCommandLine">
        <doc xml:space="preserve" filename="gapplication.h" line="73">This virtual function is always invoked in the local instance. It
gets passed a pointer to a %NULL-terminated copy of @argv and is
expected to remove arguments that it handled (shifting up remaining
arguments).

The last argument to local_command_line() is a pointer to the @status
variable which can used to set the exit status that is returned from
g_application_run().

See g_application_run() for more details on #GApplication startup.</doc>
        <source-position filename="gapplication.h" line="92" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gapplication.h" line="90">%TRUE if the commandline has been completely handled</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc xml:space="preserve" filename="gapplication.h" line="75">a #GApplication</doc>
            <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="arguments" direction="inout" caller-allocates="0" transfer-ownership="full" gs:managed-name="arguments">
            <doc xml:space="preserve" filename="gapplication.h" line="76">array of command line arguments</doc>
            <array c:type="gchar***" zero-terminated="1" gs:is-pointer="1">
              <type name="utf8" c:type="gchar**" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="exit_status" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="exitStatus">
            <doc xml:space="preserve" filename="gapplication.h" line="77">exit status to fill after processing the command line.</doc>
            <type name="gint" c:type="int*" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="arguments" direction="inout" caller-allocates="0" transfer-ownership="full" gs:managed-name="arguments">
            <doc xml:space="preserve" filename="gapplication.h" line="76">array of command line arguments</doc>
            <array c:type="gchar***" zero-terminated="1" gs:is-pointer="1">
              <type name="utf8" c:type="gchar**" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="exit_status" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="exitStatus">
            <doc xml:space="preserve" filename="gapplication.h" line="77">exit status to fill after processing the command line.</doc>
            <type name="gint" c:type="int*" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="name_lost" gs:dll-name="gio-2.0" gs:managed-name="DoNameLost">
        <source-position filename="gapplication.h" line="115" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </virtual-method>
      <virtual-method name="open" invoker="open" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="DoOpen">
        <doc xml:space="preserve" filename="gio-2.0.c" line="12229">Opens the given files.

In essence, this results in the #GApplication::open signal being emitted
in the primary instance.

@n_files must be greater than zero.

@hint is simply passed through to the ::open signal.  It is
intended to be used by applications that have multiple modes for
opening files (eg: "view" vs "edit", etc).  Unless you have a need
for this functionality, you should use "".

The application must be registered before calling this function
and it must have the %G_APPLICATION_HANDLES_OPEN flag set.</doc>
        <source-position filename="gapplication.h" line="63" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12231">a #GApplication</doc>
            <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="files" transfer-ownership="none" gs:managed-name="files" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12232">an array of #GFiles to open</doc>
            <array length="1" zero-terminated="0" c:type="GFile**" gs:is-pointer="1">
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="n_files" transfer-ownership="none" gs:managed-name="nFiles" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12233">the length of the @files array</doc>
            <type name="gint" c:type="gint" />
          </parameter>
          <parameter name="hint" transfer-ownership="none" gs:managed-name="hint" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12234">a hint (or ""), but never %NULL</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="files" transfer-ownership="none" gs:managed-name="files" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12232">an array of #GFiles to open</doc>
            <array length="1" zero-terminated="0" c:type="GFile**" gs:is-pointer="1">
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="hint" transfer-ownership="none" gs:managed-name="hint" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12234">a hint (or ""), but never %NULL</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="quit_mainloop" gs:dll-name="gio-2.0" gs:managed-name="DoQuitMainloop">
        <source-position filename="gapplication.h" line="102" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </virtual-method>
      <virtual-method name="run_mainloop" gs:dll-name="gio-2.0" gs:managed-name="DoRunMainloop">
        <source-position filename="gapplication.h" line="103" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </virtual-method>
      <virtual-method name="shutdown" gs:dll-name="gio-2.0" gs:managed-name="DoShutdown">
        <source-position filename="gapplication.h" line="104" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </virtual-method>
      <virtual-method name="startup" gs:dll-name="gio-2.0" gs:managed-name="DoStartup">
        <source-position filename="gapplication.h" line="59" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </virtual-method>
      <method name="activate" c:identifier="g_application_activate" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="Activate">
        <doc xml:space="preserve" filename="gio-2.0.c" line="11553">Activates the application.

In essence, this results in the #GApplication::activate signal being
emitted in the primary instance.

The application must be registered before calling this function.</doc>
        <source-position filename="gapplication.h" line="204" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11555">a #GApplication</doc>
            <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="add_main_option" c:identifier="g_application_add_main_option" version="2.42" gs:dll-name="gio-2.0" gs:managed-name="AddMainOption">
        <doc xml:space="preserve" filename="gio-2.0.c" line="11568">Add an option to be handled by @application.

Calling this function is the equivalent of calling
g_application_add_main_option_entries() with a single #GOptionEntry
that has its arg_data member set to %NULL.

The parsed arguments will be packed into a #GVariantDict which
is passed to #GApplication::handle-local-options. If
%G_APPLICATION_HANDLES_COMMAND_LINE is set, then it will also
be sent to the primary instance. See
g_application_add_main_option_entries() for more details.

See #GOptionEntry for more documentation of the arguments.</doc>
        <source-position filename="gapplication.h" line="169" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11570">the #GApplication</doc>
            <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="long_name" transfer-ownership="none" gs:managed-name="longName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11571">the long name of an option used to specify it in a commandline</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="short_name" transfer-ownership="none" gs:managed-name="shortName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11572">the short name of an option</doc>
            <type name="gchar" c:type="char" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11573">flags from #GOptionFlags</doc>
            <type name="GLib.OptionFlags" c:type="GOptionFlags" />
          </parameter>
          <parameter name="arg" transfer-ownership="none" gs:managed-name="arg" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11574">the type of the option, as a #GOptionArg</doc>
            <type name="GLib.OptionArg" c:type="GOptionArg" />
          </parameter>
          <parameter name="description" transfer-ownership="none" gs:managed-name="description" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11575">the description for the option in `--help` output</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="arg_description" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="argDescription" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11576">the placeholder to use for the extra argument
   parsed by the option in `--help` output</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="long_name" transfer-ownership="none" gs:managed-name="longName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11571">the long name of an option used to specify it in a commandline</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="short_name" transfer-ownership="none" gs:managed-name="shortName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11572">the short name of an option</doc>
            <type name="gchar" c:type="char" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11573">flags from #GOptionFlags</doc>
            <type name="GLib.OptionFlags" c:type="GOptionFlags" />
          </parameter>
          <parameter name="arg" transfer-ownership="none" gs:managed-name="arg" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11574">the type of the option, as a #GOptionArg</doc>
            <type name="GLib.OptionArg" c:type="GOptionArg" />
          </parameter>
          <parameter name="description" transfer-ownership="none" gs:managed-name="description" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11575">the description for the option in `--help` output</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="arg_description" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="argDescription" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11576">the placeholder to use for the extra argument
   parsed by the option in `--help` output</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="add_main_option_entries" c:identifier="g_application_add_main_option_entries" version="2.40" gs:dll-name="gio-2.0" gs:managed-name="AddMainOptionEntries">
        <doc xml:space="preserve" filename="gio-2.0.c" line="11597">Adds main option entries to be handled by @application.

This function is comparable to g_option_context_add_main_entries().

After the commandline arguments are parsed, the
#GApplication::handle-local-options signal will be emitted.  At this
point, the application can inspect the values pointed to by @arg_data
in the given #GOptionEntrys.

Unlike #GOptionContext, #GApplication supports giving a %NULL
@arg_data for a non-callback #GOptionEntry.  This results in the
argument in question being packed into a #GVariantDict which is also
passed to #GApplication::handle-local-options, where it can be
inspected and modified.  If %G_APPLICATION_HANDLES_COMMAND_LINE is
set, then the resulting dictionary is sent to the primary instance,
where g_application_command_line_get_options_dict() will return it.
This "packing" is done according to the type of the argument --
booleans for normal flags, strings for strings, bytestrings for
filenames, etc.  The packing only occurs if the flag is given (ie: we
do not pack a "false" #GVariant in the case that a flag is missing).

In general, it is recommended that all commandline arguments are
parsed locally.  The options dictionary should then be used to
transmit the result of the parsing to the primary instance, where
g_variant_dict_lookup() can be used.  For local options, it is
possible to either use @arg_data in the usual way, or to consult (and
potentially remove) the option from the options dictionary.

This function is new in GLib 2.40.  Before then, the only real choice
was to send all of the commandline arguments (options and all) to the
primary instance for handling.  #GApplication ignored them completely
on the local side.  Calling this function "opts in" to the new
behaviour, and in particular, means that unrecognised options will be
treated as errors.  Unrecognised options have never been ignored when
%G_APPLICATION_HANDLES_COMMAND_LINE is unset.

If #GApplication::handle-local-options needs to see the list of
filenames, then the use of %G_OPTION_REMAINING is recommended.  If
@arg_data is %NULL then %G_OPTION_REMAINING can be used as a key into
the options dictionary.  If you do use %G_OPTION_REMAINING then you
need to handle these arguments for yourself because once they are
consumed, they will no longer be visible to the default handling
(which treats them as filenames to be opened).

It is important to use the proper GVariant format when retrieving
the options with g_variant_dict_lookup():
- for %G_OPTION_ARG_NONE, use `b`
- for %G_OPTION_ARG_STRING, use `&amp;s`
- for %G_OPTION_ARG_INT, use `i`
- for %G_OPTION_ARG_INT64, use `x`
- for %G_OPTION_ARG_DOUBLE, use `d`
- for %G_OPTION_ARG_FILENAME, use `^&amp;ay`
- for %G_OPTION_ARG_STRING_ARRAY, use `^a&amp;s`
- for %G_OPTION_ARG_FILENAME_ARRAY, use `^a&amp;ay`</doc>
        <source-position filename="gapplication.h" line="165" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11599">a #GApplication</doc>
            <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="entries" transfer-ownership="none" gs:managed-name="entries" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11600">a
          %NULL-terminated list of #GOptionEntrys</doc>
            <array c:type="const GOptionEntry*" zero-terminated="1" gs:is-pointer="1">
              <type name="GLib.OptionEntry" />
            </array>
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="entries" transfer-ownership="none" gs:managed-name="entries" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11600">a
          %NULL-terminated list of #GOptionEntrys</doc>
            <array c:type="const GOptionEntry*" zero-terminated="1" gs:is-pointer="1">
              <type name="GLib.OptionEntry" />
            </array>
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="add_option_group" c:identifier="g_application_add_option_group" version="2.40" gs:dll-name="gio-2.0" gs:managed-name="AddOptionGroup">
        <doc xml:space="preserve" filename="gio-2.0.c" line="11662">Adds a #GOptionGroup to the commandline handling of @application.

This function is comparable to g_option_context_add_group().

Unlike g_application_add_main_option_entries(), this function does
not deal with %NULL @arg_data and never transmits options to the
primary instance.

The reason for that is because, by the time the options arrive at the
primary instance, it is typically too late to do anything with them.
Taking the GTK option group as an example: GTK will already have been
initialised by the time the #GApplication::command-line handler runs.
In the case that this is not the first-running instance of the
application, the existing instance may already have been running for
a very long time.

This means that the options from #GOptionGroup are only really usable
in the case that the instance of the application being run is the
first instance.  Passing options like `--display=` or `--gdk-debug=`
on future runs will have no effect on the existing primary instance.

Calling this function will cause the options in the supplied option
group to be parsed, but it does not cause you to be "opted in" to the
new functionality whereby unrecognised options are rejected even if
%G_APPLICATION_HANDLES_COMMAND_LINE was given.</doc>
        <source-position filename="gapplication.h" line="177" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11664">the #GApplication</doc>
            <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="group" transfer-ownership="full" gs:managed-name="group" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11665">a #GOptionGroup</doc>
            <type name="GLib.OptionGroup" c:type="GOptionGroup*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="group" transfer-ownership="full" gs:managed-name="group" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11665">a #GOptionGroup</doc>
            <type name="GLib.OptionGroup" c:type="GOptionGroup*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="bind_busy_property" c:identifier="g_application_bind_busy_property" version="2.44" gs:dll-name="gio-2.0" gs:managed-name="BindBusyProperty">
        <doc xml:space="preserve" filename="gio-2.0.c" line="11697">Marks @application as busy (see g_application_mark_busy()) while
@property on @object is %TRUE.

The binding holds a reference to @application while it is active, but
not to @object. Instead, the binding is destroyed when @object is
finalized.</doc>
        <source-position filename="gapplication.h" line="241" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11699">a #GApplication</doc>
            <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11700">a #GObject</doc>
            <type name="GObject.Object" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="property" transfer-ownership="none" gs:managed-name="property" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11701">the name of a boolean property of @object</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11700">a #GObject</doc>
            <type name="GObject.Object" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="property" transfer-ownership="none" gs:managed-name="property" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11701">the name of a boolean property of @object</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <gs:managed-property name="get_application_id" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="ApplicationId">
        <doc xml:space="preserve" filename="gio-2.0.c" line="11965">Gets the unique identifier for @application.</doc>
        <source-position filename="gapplication.h" line="132" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="11971">the identifier for @application, owned by @application</doc>
          <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11967">a #GApplication</doc>
            <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_application_id" c:identifier="g_application_get_application_id" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="GetApplicationId" gs:property-getter-for="ApplicationId" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="11965">Gets the unique identifier for @application.</doc>
        <source-position filename="gapplication.h" line="132" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="11971">the identifier for @application, owned by @application</doc>
          <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11967">a #GApplication</doc>
            <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_dbus_object_path" version="2.34" gs:dll-name="gio-2.0" gs:managed-name="DbusObjectPath">
        <doc xml:space="preserve" filename="gio-2.0.c" line="11999">Gets the D-Bus object path being used by the application, or %NULL.

If #GApplication is using its D-Bus backend then this function will
return the D-Bus object path that #GApplication is using.  If the
application is the primary instance then there is an object published
at this path.  If the application is not the primary instance then
the result of this function is undefined.

If #GApplication is not using D-Bus then this function will return
%NULL.  This includes the situation where the D-Bus backend would
normally be in use but we were unable to connect to the bus.

This function must not be called before the application has been
registered.  See g_application_get_is_registered().</doc>
        <source-position filename="gapplication.h" line="140" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="12018">the object path, or %NULL</doc>
          <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12001">a #GApplication</doc>
            <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_dbus_object_path" c:identifier="g_application_get_dbus_object_path" version="2.34" gs:dll-name="gio-2.0" gs:managed-name="GetDbusObjectPath" gs:property-getter-for="DbusObjectPath" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="11999">Gets the D-Bus object path being used by the application, or %NULL.

If #GApplication is using its D-Bus backend then this function will
return the D-Bus object path that #GApplication is using.  If the
application is the primary instance then there is an object published
at this path.  If the application is not the primary instance then
the result of this function is undefined.

If #GApplication is not using D-Bus then this function will return
%NULL.  This includes the situation where the D-Bus backend would
normally be in use but we were unable to connect to the bus.

This function must not be called before the application has been
registered.  See g_application_get_is_registered().</doc>
        <source-position filename="gapplication.h" line="140" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="12018">the object path, or %NULL</doc>
          <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12001">a #GApplication</doc>
            <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_flags" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="Flags">
        <doc xml:space="preserve" filename="gio-2.0.c" line="12039">Gets the flags for @application.

See #GApplicationFlags.</doc>
        <source-position filename="gapplication.h" line="149" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="12047">the flags for @application</doc>
          <type name="ApplicationFlags" c:type="GApplicationFlags" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12041">a #GApplication</doc>
            <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_flags" c:identifier="g_application_get_flags" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="GetFlags" gs:property-getter-for="Flags" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="12039">Gets the flags for @application.

See #GApplicationFlags.</doc>
        <source-position filename="gapplication.h" line="149" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="12047">the flags for @application</doc>
          <type name="ApplicationFlags" c:type="GApplicationFlags" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12041">a #GApplication</doc>
            <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_inactivity_timeout" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="InactivityTimeout">
        <doc xml:space="preserve" filename="gio-2.0.c" line="12052">Gets the current inactivity timeout for the application.

This is the amount of time (in milliseconds) after the last call to
g_application_release() before the application stops running.</doc>
        <source-position filename="gapplication.h" line="143" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="12061">the timeout, in milliseconds</doc>
          <type name="guint" c:type="guint" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12054">a #GApplication</doc>
            <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_inactivity_timeout" c:identifier="g_application_get_inactivity_timeout" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="GetInactivityTimeout" gs:property-getter-for="InactivityTimeout" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="12052">Gets the current inactivity timeout for the application.

This is the amount of time (in milliseconds) after the last call to
g_application_release() before the application stops running.</doc>
        <source-position filename="gapplication.h" line="143" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="12061">the timeout, in milliseconds</doc>
          <type name="guint" c:type="guint" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12054">a #GApplication</doc>
            <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_is_busy" version="2.44" gs:dll-name="gio-2.0" gs:managed-name="IsBusy">
        <doc xml:space="preserve" filename="gio-2.0.c" line="12066">Gets the application's current busy state, as set through
g_application_mark_busy() or g_application_bind_busy_property().</doc>
        <source-position filename="gapplication.h" line="230" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="12073">%TRUE if @application is currently marked as busy</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12068">a #GApplication</doc>
            <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_is_busy" c:identifier="g_application_get_is_busy" version="2.44" gs:dll-name="gio-2.0" gs:managed-name="GetIsBusy" gs:property-getter-for="IsBusy" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="12066">Gets the application's current busy state, as set through
g_application_mark_busy() or g_application_bind_busy_property().</doc>
        <source-position filename="gapplication.h" line="230" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="12073">%TRUE if @application is currently marked as busy</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12068">a #GApplication</doc>
            <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_is_registered" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="IsRegistered">
        <doc xml:space="preserve" filename="gio-2.0.c" line="12078">Checks if @application is registered.

An application is registered if g_application_register() has been
successfully called.</doc>
        <source-position filename="gapplication.h" line="189" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="12087">%TRUE if @application is registered</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12080">a #GApplication</doc>
            <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_is_registered" c:identifier="g_application_get_is_registered" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="GetIsRegistered" gs:property-getter-for="IsRegistered" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="12078">Checks if @application is registered.

An application is registered if g_application_register() has been
successfully called.</doc>
        <source-position filename="gapplication.h" line="189" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="12087">%TRUE if @application is registered</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12080">a #GApplication</doc>
            <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_is_remote" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="IsRemote">
        <doc xml:space="preserve" filename="gio-2.0.c" line="12092">Checks if @application is remote.

If @application is remote then it means that another instance of
application already exists (the 'primary' instance).  Calls to
perform actions on @application will result in the actions being
performed by the primary instance.

The value of this property cannot be accessed before
g_application_register() has been called.  See
g_application_get_is_registered().</doc>
        <source-position filename="gapplication.h" line="191" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="12107">%TRUE if @application is remote</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12094">a #GApplication</doc>
            <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_is_remote" c:identifier="g_application_get_is_remote" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="GetIsRemote" gs:property-getter-for="IsRemote" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="12092">Checks if @application is remote.

If @application is remote then it means that another instance of
application already exists (the 'primary' instance).  Calls to
perform actions on @application will result in the actions being
performed by the primary instance.

The value of this property cannot be accessed before
g_application_register() has been called.  See
g_application_get_is_registered().</doc>
        <source-position filename="gapplication.h" line="191" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="12107">%TRUE if @application is remote</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12094">a #GApplication</doc>
            <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_resource_base_path" version="2.42" gs:dll-name="gio-2.0" gs:managed-name="ResourceBasePath">
        <doc xml:space="preserve" filename="gio-2.0.c" line="12112">Gets the resource base path of @application.

See g_application_set_resource_base_path() for more information.</doc>
        <source-position filename="gapplication.h" line="155" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="12120">the base resource path, if one is set</doc>
          <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12114">a #GApplication</doc>
            <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_resource_base_path" c:identifier="g_application_get_resource_base_path" version="2.42" gs:dll-name="gio-2.0" gs:managed-name="GetResourceBasePath" gs:property-getter-for="ResourceBasePath" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="12112">Gets the resource base path of @application.

See g_application_set_resource_base_path() for more information.</doc>
        <source-position filename="gapplication.h" line="155" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="12120">the base resource path, if one is set</doc>
          <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12114">a #GApplication</doc>
            <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="hold" c:identifier="g_application_hold" gs:dll-name="gio-2.0" gs:managed-name="Hold">
        <doc xml:space="preserve" filename="gio-2.0.c" line="12125">Increases the use count of @application.

Use this function to indicate that the application has a reason to
continue to run.  For example, g_application_hold() is called by GTK+
when a toplevel window is on the screen.

To cancel the hold, call g_application_release().</doc>
        <source-position filename="gapplication.h" line="199" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12127">a #GApplication</doc>
            <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="mark_busy" c:identifier="g_application_mark_busy" version="2.38" gs:dll-name="gio-2.0" gs:managed-name="MarkBusy">
        <doc xml:space="preserve" filename="gio-2.0.c" line="12193">Increases the busy count of @application.

Use this function to indicate that the application is busy, for instance
while a long running operation is pending.

The busy state will be exposed to other processes, so a session shell will
use that information to indicate the state to the user (e.g. with a
spinner).

To cancel the busy indication, use g_application_unmark_busy().</doc>
        <source-position filename="gapplication.h" line="226" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12195">a #GApplication</doc>
            <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="open" c:identifier="g_application_open" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="Open">
        <doc xml:space="preserve" filename="gio-2.0.c" line="12229">Opens the given files.

In essence, this results in the #GApplication::open signal being emitted
in the primary instance.

@n_files must be greater than zero.

@hint is simply passed through to the ::open signal.  It is
intended to be used by applications that have multiple modes for
opening files (eg: "view" vs "edit", etc).  Unless you have a need
for this functionality, you should use "".

The application must be registered before calling this function
and it must have the %G_APPLICATION_HANDLES_OPEN flag set.</doc>
        <source-position filename="gapplication.h" line="207" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12231">a #GApplication</doc>
            <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="files" transfer-ownership="none" gs:managed-name="files" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12232">an array of #GFiles to open</doc>
            <array length="1" zero-terminated="0" c:type="GFile**" gs:is-pointer="1">
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="n_files" transfer-ownership="none" gs:managed-name="nFiles" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12233">the length of the @files array</doc>
            <type name="gint" c:type="gint" />
          </parameter>
          <parameter name="hint" transfer-ownership="none" gs:managed-name="hint" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12234">a hint (or ""), but never %NULL</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="files" transfer-ownership="none" gs:managed-name="files" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12232">an array of #GFiles to open</doc>
            <array length="1" zero-terminated="0" c:type="GFile**" gs:is-pointer="1">
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="hint" transfer-ownership="none" gs:managed-name="hint" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12234">a hint (or ""), but never %NULL</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="quit" c:identifier="g_application_quit" version="2.32" gs:dll-name="gio-2.0" gs:managed-name="Quit">
        <doc xml:space="preserve" filename="gio-2.0.c" line="12255">Immediately quits the application.

Upon return to the mainloop, g_application_run() will return,
calling only the 'shutdown' function before doing so.

The hold count is ignored.
Take care if your code has called g_application_hold() on the application and
is therefore still expecting it to exist.
(Note that you may have called g_application_hold() indirectly, for example
through gtk_application_add_window().)

The result of calling g_application_run() again after it returns is
unspecified.</doc>
        <source-position filename="gapplication.h" line="218" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12257">a #GApplication</doc>
            <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="register" c:identifier="g_application_register" version="2.28" throws="1" gs:dll-name="gio-2.0" gs:managed-name="Register">
        <doc xml:space="preserve" filename="gio-2.0.c" line="12277">Attempts registration of the application.

This is the point at which the application discovers if it is the
primary instance or merely acting as a remote for an already-existing
primary instance.  This is implemented by attempting to acquire the
application identifier as a unique bus name on the session bus using
GDBus.

If there is no application ID or if %G_APPLICATION_NON_UNIQUE was
given, then this process will always become the primary instance.

Due to the internal architecture of GDBus, method calls can be
dispatched at any time (even if a main loop is not running).  For
this reason, you must ensure that any object paths that you wish to
register are registered before calling this function.

If the application has already been registered then %TRUE is
returned with no work performed.

The #GApplication::startup signal is emitted if registration succeeds
and @application is the primary instance (including the non-unique
case).

In the event of an error (such as @cancellable being cancelled, or a
failure to connect to the session bus), %FALSE is returned and @error
is set appropriately.

Note: the return value of this function is not an indicator that this
instance is or is not the primary instance of the application.  See
g_application_get_is_remote() for that.</doc>
        <source-position filename="gapplication.h" line="194" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="12314">%TRUE if registration succeeded</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12279">a #GApplication</doc>
            <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12280">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12280">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="release" c:identifier="g_application_release" gs:dll-name="gio-2.0" gs:managed-name="Release">
        <doc xml:space="preserve" filename="gio-2.0.c" line="12319">Decrease the use count of @application.

When the use count reaches zero, the application will stop running.

Never call this function except to cancel the effect of a previous
call to g_application_hold().</doc>
        <source-position filename="gapplication.h" line="201" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12321">a #GApplication</doc>
            <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="run" c:identifier="g_application_run" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="Run">
        <doc xml:space="preserve" filename="gio-2.0.c" line="12332">Runs the application.

This function is intended to be run from main() and its return value
is intended to be returned by main(). Although you are expected to pass
the @argc, @argv parameters from main() to this function, it is possible
to pass %NULL if @argv is not available or commandline handling is not
required.  Note that on Windows, @argc and @argv are ignored, and
g_win32_get_command_line() is called internally (for proper support
of Unicode commandline arguments).

#GApplication will attempt to parse the commandline arguments.  You
can add commandline flags to the list of recognised options by way of
g_application_add_main_option_entries().  After this, the
#GApplication::handle-local-options signal is emitted, from which the
application can inspect the values of its #GOptionEntrys.

#GApplication::handle-local-options is a good place to handle options
such as `--version`, where an immediate reply from the local process is
desired (instead of communicating with an already-running instance).
A #GApplication::handle-local-options handler can stop further processing
by returning a non-negative value, which then becomes the exit status of
the process.

What happens next depends on the flags: if
%G_APPLICATION_HANDLES_COMMAND_LINE was specified then the remaining
commandline arguments are sent to the primary instance, where a
#GApplication::command-line signal is emitted.  Otherwise, the
remaining commandline arguments are assumed to be a list of files.
If there are no files listed, the application is activated via the
#GApplication::activate signal.  If there are one or more files, and
%G_APPLICATION_HANDLES_OPEN was specified then the files are opened
via the #GApplication::open signal.

If you are interested in doing more complicated local handling of the
commandline then you should implement your own #GApplication subclass
and override local_command_line(). In this case, you most likely want
to return %TRUE from your local_command_line() implementation to
suppress the default handling. See
[gapplication-example-cmdline2.c][gapplication-example-cmdline2]
for an example.

If, after the above is done, the use count of the application is zero
then the exit status is returned immediately.  If the use count is
non-zero then the default main context is iterated until the use count
falls to zero, at which point 0 is returned.

If the %G_APPLICATION_IS_SERVICE flag is set, then the service will
run for as much as 10 seconds with a use count of zero while waiting
for the message that caused the activation to arrive.  After that,
if the use count falls to zero the application will exit immediately,
except in the case that g_application_set_inactivity_timeout() is in
use.

This function sets the prgname (g_set_prgname()), if not already set,
to the basename of argv[0].

Much like g_main_loop_run(), this function will acquire the main context
for the duration that the application is running.

Since 2.40, applications that are not explicitly flagged as services
or launchers (ie: neither %G_APPLICATION_IS_SERVICE or
%G_APPLICATION_IS_LAUNCHER are given as flags) will check (from the
default handler for local_command_line) if "--gapplication-service"
was given in the command line.  If this flag is present then normal
commandline processing is interrupted and the
%G_APPLICATION_IS_SERVICE flag is set.  This provides a "compromise"
solution whereby running an application directly from the commandline
will invoke it in the normal way (which can be useful for debugging)
while still allowing applications to be D-Bus activated in service
mode.  The D-Bus service file should invoke the executable with
"--gapplication-service" as the sole commandline argument.  This
approach is suitable for use by most graphical applications but
should not be used from applications like editors that need precise
control over when processes invoked via the commandline will exit and
what their exit status will be.</doc>
        <source-position filename="gapplication.h" line="213" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="12415">the exit status</doc>
          <type name="gint" c:type="int" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12334">a #GApplication</doc>
            <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="argc" transfer-ownership="none" gs:managed-name="argc" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12335">the argc from main() (or 0 if @argv is %NULL)</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="argv" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="argv" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12336">
    the argv from main(), or %NULL</doc>
            <array length="0" zero-terminated="0" c:type="char**" gs:is-pointer="1">
              <type name="filename" gs:is-pointer="1" />
            </array>
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="argv" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="argv" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12336">
    the argv from main(), or %NULL</doc>
            <array length="0" zero-terminated="0" c:type="char**" gs:is-pointer="1">
              <type name="filename" gs:is-pointer="1" />
            </array>
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_action_group" c:identifier="g_application_set_action_group" version="2.28" deprecated="1" deprecated-version="2.32" gs:dll-name="gio-2.0" gs:managed-name="SetActionGroup">
        <doc xml:space="preserve" filename="gio-2.0.c" line="12457">This used to be how actions were associated with a #GApplication.
Now there is #GActionMap for that.</doc>
        <doc-deprecated xml:space="preserve">Use the #GActionMap interface instead.  Never ever
mix use of this API with use of #GActionMap on the same @application
or things will go very badly wrong.  This function is known to
introduce buggy behaviour (ie: signals not emitted on changes to the
action group), so you should really use #GActionMap instead.</doc-deprecated>
        <source-position filename="gapplication.h" line="161" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12459">a #GApplication</doc>
            <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="action_group" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="actionGroup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12460">a #GActionGroup, or %NULL</doc>
            <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="action_group" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="actionGroup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12460">a #GActionGroup, or %NULL</doc>
            <type name="ActionGroup" c:type="GActionGroup*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_application_id" c:identifier="g_application_set_application_id" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="SetApplicationId" gs:property-setter-for="ApplicationId" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="12474">Sets the unique identifier for @application.

The application id can only be modified if @application has not yet
been registered.

If non-%NULL, the application id must be valid.  See
g_application_id_is_valid().</doc>
        <source-position filename="gapplication.h" line="134" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12476">a #GApplication</doc>
            <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="application_id" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="applicationId" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12477">the identifier for @application</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="application_id" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="applicationId" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12477">the identifier for @application</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_default" c:identifier="g_application_set_default" version="2.32" gs:dll-name="gio-2.0" gs:managed-name="SetDefault">
        <doc xml:space="preserve" filename="gio-2.0.c" line="12491">Sets or unsets the default application for the process, as returned
by g_application_get_default().

This function does not take its own reference on @application.  If
@application is destroyed then the default application will revert
back to %NULL.</doc>
        <source-position filename="gapplication.h" line="223" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="application" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12493">the application to set as default, or %NULL</doc>
            <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="set_flags" c:identifier="g_application_set_flags" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="SetFlags" gs:property-setter-for="Flags" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="12506">Sets the flags for @application.

The flags can only be modified if @application has not yet been
registered.

See #GApplicationFlags.</doc>
        <source-position filename="gapplication.h" line="151" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12508">a #GApplication</doc>
            <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12509">the flags for @application</doc>
            <type name="ApplicationFlags" c:type="GApplicationFlags" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12509">the flags for @application</doc>
            <type name="ApplicationFlags" c:type="GApplicationFlags" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_inactivity_timeout" c:identifier="g_application_set_inactivity_timeout" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="SetInactivityTimeout" gs:property-setter-for="InactivityTimeout" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="12522">Sets the current inactivity timeout for the application.

This is the amount of time (in milliseconds) after the last call to
g_application_release() before the application stops running.

This call has no side effects of its own.  The value set here is only
used for next time g_application_release() drops the use count to
zero.  Any timeouts currently in progress are not impacted.</doc>
        <source-position filename="gapplication.h" line="145" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12524">a #GApplication</doc>
            <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="inactivity_timeout" transfer-ownership="none" gs:managed-name="inactivityTimeout" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12525">the timeout, in milliseconds</doc>
            <type name="guint" c:type="guint" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="inactivity_timeout" transfer-ownership="none" gs:managed-name="inactivityTimeout" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12525">the timeout, in milliseconds</doc>
            <type name="guint" c:type="guint" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_option_context_description" c:identifier="g_application_set_option_context_description" version="2.56" gs:dll-name="gio-2.0" gs:managed-name="SetOptionContextDescription">
        <doc xml:space="preserve" filename="gio-2.0.c" line="12540">Adds a description to the @application option context.

See g_option_context_set_description() for more information.</doc>
        <source-position filename="gapplication.h" line="186" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12542">the #GApplication</doc>
            <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="description" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="description" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12543">a string to be shown in `--help` output
 after the list of options, or %NULL</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="description" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="description" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12543">a string to be shown in `--help` output
 after the list of options, or %NULL</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_option_context_parameter_string" c:identifier="g_application_set_option_context_parameter_string" version="2.56" gs:dll-name="gio-2.0" gs:managed-name="SetOptionContextParameterString">
        <doc xml:space="preserve" filename="gio-2.0.c" line="12554">Sets the parameter string to be used by the commandline handling of @application.

This function registers the argument to be passed to g_option_context_new()
when the internal #GOptionContext of @application is created.

See g_option_context_new() for more information about @parameter_string.</doc>
        <source-position filename="gapplication.h" line="180" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12556">the #GApplication</doc>
            <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="parameter_string" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="parameterString" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12557">a string which is displayed
  in the first line of `--help` output, after the usage summary `programname [OPTION...]`.</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="parameter_string" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="parameterString" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12557">a string which is displayed
  in the first line of `--help` output, after the usage summary `programname [OPTION...]`.</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_option_context_summary" c:identifier="g_application_set_option_context_summary" version="2.56" gs:dll-name="gio-2.0" gs:managed-name="SetOptionContextSummary">
        <doc xml:space="preserve" filename="gio-2.0.c" line="12571">Adds a summary to the @application option context.

See g_option_context_set_summary() for more information.</doc>
        <source-position filename="gapplication.h" line="183" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12573">the #GApplication</doc>
            <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="summary" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="summary" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12574">a string to be shown in `--help` output
 before the list of options, or %NULL</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="summary" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="summary" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12574">a string to be shown in `--help` output
 before the list of options, or %NULL</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_resource_base_path" c:identifier="g_application_set_resource_base_path" version="2.42" gs:dll-name="gio-2.0" gs:managed-name="SetResourceBasePath" gs:property-setter-for="ResourceBasePath" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="12585">Sets (or unsets) the base resource path of @application.

The path is used to automatically load various [application
resources][gresource] such as menu layouts and action descriptions.
The various types of resources will be found at fixed names relative
to the given base path.

By default, the resource base path is determined from the application
ID by prefixing '/' and replacing each '.' with '/'.  This is done at
the time that the #GApplication object is constructed.  Changes to
the application ID after that point will not have an impact on the
resource base path.

As an example, if the application has an ID of "org.example.app" then
the default resource base path will be "/org/example/app".  If this
is a #GtkApplication (and you have not manually changed the path)
then Gtk will then search for the menus of the application at
"/org/example/app/gtk/menus.ui".

See #GResource for more information about adding resources to your
application.

You can disable automatic resource loading functionality by setting
the path to %NULL.

Changing the resource base path once the application is running is
not recommended.  The point at which the resource path is consulted
for forming paths for various purposes is unspecified.  When writing
a sub-class of #GApplication you should either set the
#GApplication:resource-base-path property at construction time, or call
this function during the instance initialization. Alternatively, you
can call this function in the #GApplicationClass.startup virtual function,
before chaining up to the parent implementation.</doc>
        <source-position filename="gapplication.h" line="157" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12587">a #GApplication</doc>
            <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="resource_path" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="resourcePath" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12588">the resource path to use</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="resource_path" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="resourcePath" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12588">the resource path to use</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="unbind_busy_property" c:identifier="g_application_unbind_busy_property" version="2.44" gs:dll-name="gio-2.0" gs:managed-name="UnbindBusyProperty">
        <doc xml:space="preserve" filename="gio-2.0.c" line="12628">Destroys a binding between @property and the busy state of
@application that was previously created with
g_application_bind_busy_property().</doc>
        <source-position filename="gapplication.h" line="246" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12630">a #GApplication</doc>
            <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12631">a #GObject</doc>
            <type name="GObject.Object" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="property" transfer-ownership="none" gs:managed-name="property" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12632">the name of a boolean property of @object</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12631">a #GObject</doc>
            <type name="GObject.Object" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="property" transfer-ownership="none" gs:managed-name="property" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12632">the name of a boolean property of @object</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="unmark_busy" c:identifier="g_application_unmark_busy" version="2.38" gs:dll-name="gio-2.0" gs:managed-name="UnmarkBusy">
        <doc xml:space="preserve" filename="gio-2.0.c" line="12642">Decreases the busy count of @application.

When the busy count reaches zero, the new state will be propagated
to other processes.

This function must only be called to cancel the effect of a previous
call to g_application_mark_busy().</doc>
        <source-position filename="gapplication.h" line="228" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12644">a #GApplication</doc>
            <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="withdraw_notification" c:identifier="g_application_withdraw_notification" version="2.40" gs:dll-name="gio-2.0" gs:managed-name="WithdrawNotification">
        <doc xml:space="preserve" filename="gio-2.0.c" line="12658">Withdraws a notification that was sent with
g_application_send_notification().

This call does nothing if a notification with @id doesn't exist or
the notification was never sent.

This function works even for notifications sent in previous
executions of this application, as long @id is the same as it was for
the sent notification.

Note that notifications are dismissed when the user clicks on one
of the buttons in a notification or triggers its default action, so
there is no need to explicitly withdraw the notification in that case.</doc>
        <source-position filename="gapplication.h" line="237" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12660">a #GApplication</doc>
            <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="id" transfer-ownership="none" gs:managed-name="id" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12661">id of a previously sent notification</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="id" transfer-ownership="none" gs:managed-name="id" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12661">id of a previously sent notification</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <property name="action-group" readable="0" writable="1" transfer-ownership="none" gs:managed-name="ActionGroup">
        <type name="ActionGroup" />
      </property>
      <property name="application-id" writable="1" construct="1" transfer-ownership="none" gs:managed-name="ApplicationId_">
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </property>
      <property name="flags" writable="1" transfer-ownership="none" gs:managed-name="Flags_">
        <type name="ApplicationFlags" />
      </property>
      <property name="inactivity-timeout" writable="1" transfer-ownership="none" gs:managed-name="InactivityTimeout_">
        <type name="guint" c:type="guint" />
      </property>
      <property name="is-busy" version="2.44" transfer-ownership="none" gs:managed-name="IsBusy_">
        <doc xml:space="preserve" filename="gio-2.0.c" line="400">Whether the application is currently marked as busy through
g_application_mark_busy() or g_application_bind_busy_property().</doc>
        <type name="gboolean" c:type="gboolean" />
      </property>
      <property name="is-registered" transfer-ownership="none" gs:managed-name="IsRegistered_">
        <type name="gboolean" c:type="gboolean" />
      </property>
      <property name="is-remote" transfer-ownership="none" gs:managed-name="IsRemote_">
        <type name="gboolean" c:type="gboolean" />
      </property>
      <property name="resource-base-path" writable="1" transfer-ownership="none" gs:managed-name="ResourceBasePath_">
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </property>
      <field name="parent_instance" readable="0" private="1" gs:managed-name="ParentInstance">
        <type name="GObject.Object" c:type="GObject" />
      </field>
      <field name="priv" readable="0" private="1" gs:managed-name="Priv">
        <type name="ApplicationPrivate" c:type="GApplicationPrivate*" gs:is-pointer="1" />
      </field>
      <glib:signal name="activate" when="last" gs:dll-name="gio-2.0" gs:managed-name="ActivateSignal">
        <doc xml:space="preserve" filename="gio-2.0.c" line="276">The ::activate signal is emitted on the primary instance when an
activation occurs. See g_application_activate().</doc>
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc>the instance on which the signal was invoked</doc>
            <type name="Application" c:name="gpointer" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="user_data" transfer-ownership="none" closure="0" gs:managed-name="userData" direction="in">
            <type name="gpointer" c:name="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc>the instance on which the signal was invoked</doc>
            <type name="Application" c:name="gpointer" gs:is-pointer="1" />
          </instance-parameter>
        </gs:managed-parameters>
      </glib:signal>
      <glib:signal name="command-line" when="last" gs:dll-name="gio-2.0" gs:managed-name="CommandLineSignal">
        <doc xml:space="preserve" filename="gio-2.0.c" line="285">The ::command-line signal is emitted on the primary instance when
a commandline is not handled locally. See g_application_run() and
the #GApplicationCommandLine documentation for more information.</doc>
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="295">An integer that is set as the exit status for the calling
  process. See g_application_command_line_set_exit_status().</doc>
          <type name="gint" c:type="gint" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc>the instance on which the signal was invoked</doc>
            <type name="Application" c:name="gpointer" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="command_line" transfer-ownership="none" gs:managed-name="commandLine" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="288">a #GApplicationCommandLine representing the
    passed commandline</doc>
            <type name="ApplicationCommandLine" gs:is-pointer="1" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="1" gs:managed-name="userData" direction="in">
            <type name="gpointer" c:name="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc>the instance on which the signal was invoked</doc>
            <type name="Application" c:name="gpointer" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="command_line" transfer-ownership="none" gs:managed-name="commandLine" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="288">a #GApplicationCommandLine representing the
    passed commandline</doc>
            <type name="ApplicationCommandLine" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </glib:signal>
      <glib:signal name="handle-local-options" when="last" version="2.40" gs:dll-name="gio-2.0" gs:managed-name="HandleLocalOptionsSignal">
        <doc xml:space="preserve" filename="gio-2.0.c" line="300">The ::handle-local-options signal is emitted on the local instance
after the parsing of the commandline options has occurred.

You can add options to be recognised during commandline option
parsing using g_application_add_main_option_entries() and
g_application_add_option_group().

Signal handlers can inspect @options (along with values pointed to
from the @arg_data of an installed #GOptionEntrys) in order to
decide to perform certain actions, including direct local handling
(which may be useful for options like --version).

In the event that the application is marked
%G_APPLICATION_HANDLES_COMMAND_LINE the "normal processing" will
send the @options dictionary to the primary instance where it can be
read with g_application_command_line_get_options_dict().  The signal
handler can modify the dictionary before returning, and the
modified dictionary will be sent.

In the event that %G_APPLICATION_HANDLES_COMMAND_LINE is not set,
"normal processing" will treat the remaining uncollected command
line arguments as filenames or URIs.  If there are no arguments,
the application is activated by g_application_activate().  One or
more arguments results in a call to g_application_open().

If you want to handle the local commandline arguments for yourself
by converting them to calls to g_application_open() or
g_action_group_activate_action() then you must be sure to register
the application first.  You should probably not call
g_application_activate() for yourself, however: just return -1 and
allow the default handler to do it for you.  This will ensure that
the `--gapplication-service` switch works properly (i.e. no activation
in that case).

Note that this signal is emitted from the default implementation of
local_command_line().  If you override that function and don't
chain up then this signal will never be emitted.

You can override local_command_line() if you need more powerful
capabilities than what is provided here, but this should not
normally be required.</doc>
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="347">an exit code. If you have handled your options and want
to exit the process, return a non-negative option, 0 for success,
and a positive value for failure. To continue, return -1 to let
the default option processing continue.</doc>
          <type name="gint" c:type="gint" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc>the instance on which the signal was invoked</doc>
            <type name="Application" c:name="gpointer" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="options" transfer-ownership="none" gs:managed-name="options" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="303">the options dictionary</doc>
            <type name="GLib.VariantDict" gs:is-pointer="1" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="1" gs:managed-name="userData" direction="in">
            <type name="gpointer" c:name="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc>the instance on which the signal was invoked</doc>
            <type name="Application" c:name="gpointer" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="options" transfer-ownership="none" gs:managed-name="options" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="303">the options dictionary</doc>
            <type name="GLib.VariantDict" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </glib:signal>
      <glib:signal name="name-lost" when="last" version="2.60" gs:dll-name="gio-2.0" gs:managed-name="NameLostSignal">
        <doc xml:space="preserve" filename="gio-2.0.c" line="355">The ::name-lost signal is emitted only on the registered primary instance
when a new instance has taken over. This can only happen if the application
is using the %G_APPLICATION_ALLOW_REPLACEMENT flag.

The default handler for this signal calls g_application_quit().</doc>
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="365">%TRUE if the signal has been handled</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc>the instance on which the signal was invoked</doc>
            <type name="Application" c:name="gpointer" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="user_data" transfer-ownership="none" closure="0" gs:managed-name="userData" direction="in">
            <type name="gpointer" c:name="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc>the instance on which the signal was invoked</doc>
            <type name="Application" c:name="gpointer" gs:is-pointer="1" />
          </instance-parameter>
        </gs:managed-parameters>
      </glib:signal>
      <glib:signal name="open" when="last" gs:dll-name="gio-2.0" gs:managed-name="OpenSignal">
        <doc xml:space="preserve" filename="gio-2.0.c" line="370">The ::open signal is emitted on the primary instance when there are
files to open. See g_application_open() for more information.</doc>
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc>the instance on which the signal was invoked</doc>
            <type name="Application" c:name="gpointer" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="files" transfer-ownership="none" gs:managed-name="files" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="373">an array of #GFiles</doc>
            <array length="1" zero-terminated="0" c:type="gpointer" gs:is-pointer="1">
              <type name="File" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="n_files" transfer-ownership="none" gs:managed-name="nFiles" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="374">the length of @files</doc>
            <type name="gint" c:type="gint" />
          </parameter>
          <parameter name="hint" transfer-ownership="none" gs:managed-name="hint" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="375">a hint provided by the calling instance</doc>
            <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="3" gs:managed-name="userData" direction="in">
            <type name="gpointer" c:name="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc>the instance on which the signal was invoked</doc>
            <type name="Application" c:name="gpointer" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="files" transfer-ownership="none" gs:managed-name="files" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="373">an array of #GFiles</doc>
            <array length="1" zero-terminated="0" c:type="gpointer" gs:is-pointer="1">
              <type name="File" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="hint" transfer-ownership="none" gs:managed-name="hint" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="375">a hint provided by the calling instance</doc>
            <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </glib:signal>
      <glib:signal name="shutdown" when="last" gs:dll-name="gio-2.0" gs:managed-name="ShutdownSignal">
        <doc xml:space="preserve" filename="gio-2.0.c" line="382">The ::shutdown signal is emitted only on the registered primary instance
immediately after the main loop terminates.</doc>
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc>the instance on which the signal was invoked</doc>
            <type name="Application" c:name="gpointer" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="user_data" transfer-ownership="none" closure="0" gs:managed-name="userData" direction="in">
            <type name="gpointer" c:name="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc>the instance on which the signal was invoked</doc>
            <type name="Application" c:name="gpointer" gs:is-pointer="1" />
          </instance-parameter>
        </gs:managed-parameters>
      </glib:signal>
      <glib:signal name="startup" when="first" gs:dll-name="gio-2.0" gs:managed-name="StartupSignal">
        <doc xml:space="preserve" filename="gio-2.0.c" line="391">The ::startup signal is emitted on the primary instance immediately
after registration. See g_application_register().</doc>
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc>the instance on which the signal was invoked</doc>
            <type name="Application" c:name="gpointer" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="user_data" transfer-ownership="none" closure="0" gs:managed-name="userData" direction="in">
            <type name="gpointer" c:name="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
            <doc>the instance on which the signal was invoked</doc>
            <type name="Application" c:name="gpointer" gs:is-pointer="1" />
          </instance-parameter>
        </gs:managed-parameters>
      </glib:signal>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_application_get_type" gs:access-modifiers="private" gs:dll-name="gio-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </class>
    <record name="ApplicationClass" c:type="GApplicationClass" glib:is-gtype-struct-for="Application" version="2.28" gs:managed-name="ApplicationClass">
      <doc xml:space="preserve" filename="gio-2.0.c" line="410">Virtual function table for #GApplication.</doc>
      <source-position filename="gapplication.h" line="119" />
      <field name="parent_class" readable="0" private="1" gs:managed-name="ParentClass">
        <type name="GObject.ObjectClass" c:type="GObjectClass" />
      </field>
      <field name="startup" gs:managed-name="Startup">
        <callback name="startup" gs:dll-name="gio-2.0" gs:managed-name="Startup">
          <source-position filename="gapplication.h" line="59" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
              <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
              <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="activate" gs:managed-name="Activate">
        <callback name="activate" gs:dll-name="gio-2.0" gs:managed-name="Activate">
          <source-position filename="gapplication.h" line="61" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="11555">a #GApplication</doc>
              <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="11555">a #GApplication</doc>
              <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="open" gs:managed-name="Open">
        <callback name="open" gs:dll-name="gio-2.0" gs:managed-name="Open">
          <source-position filename="gapplication.h" line="63" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="12231">a #GApplication</doc>
              <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
            </parameter>
            <parameter name="files" transfer-ownership="none" gs:managed-name="files" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="12232">an array of #GFiles to open</doc>
              <array length="2" zero-terminated="0" c:type="GFile**" gs:is-pointer="1">
                <type name="File" c:type="GFile*" gs:is-pointer="1" />
              </array>
            </parameter>
            <parameter name="n_files" transfer-ownership="none" gs:managed-name="nFiles" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="12233">the length of the @files array</doc>
              <type name="gint" c:type="gint" />
            </parameter>
            <parameter name="hint" transfer-ownership="none" gs:managed-name="hint" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="12234">a hint (or ""), but never %NULL</doc>
              <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="12231">a #GApplication</doc>
              <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
            </parameter>
            <parameter name="files" transfer-ownership="none" gs:managed-name="files" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="12232">an array of #GFiles to open</doc>
              <array length="2" zero-terminated="0" c:type="GFile**" gs:is-pointer="1">
                <type name="File" c:type="GFile*" gs:is-pointer="1" />
              </array>
            </parameter>
            <parameter name="hint" transfer-ownership="none" gs:managed-name="hint" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="12234">a hint (or ""), but never %NULL</doc>
              <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="command_line" gs:managed-name="CommandLine">
        <callback name="command_line" gs:dll-name="gio-2.0" gs:managed-name="CommandLine">
          <source-position filename="gapplication.h" line="68" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="gint" c:type="int" />
          </return-value>
          <parameters>
            <parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
              <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
            </parameter>
            <parameter name="command_line" transfer-ownership="none" gs:managed-name="commandLine" direction="in">
              <type name="ApplicationCommandLine" c:type="GApplicationCommandLine*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
              <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
            </parameter>
            <parameter name="command_line" transfer-ownership="none" gs:managed-name="commandLine" direction="in">
              <type name="ApplicationCommandLine" c:type="GApplicationCommandLine*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="local_command_line" gs:managed-name="LocalCommandLine">
        <callback name="local_command_line" gs:dll-name="gio-2.0" gs:managed-name="TryLocalCommandLine">
          <source-position filename="gapplication.h" line="92" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gapplication.h" line="90">%TRUE if the commandline has been completely handled</doc>
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
              <doc xml:space="preserve" filename="gapplication.h" line="75">a #GApplication</doc>
              <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
            </parameter>
            <parameter name="arguments" direction="inout" caller-allocates="0" transfer-ownership="full" gs:managed-name="arguments">
              <doc xml:space="preserve" filename="gapplication.h" line="76">array of command line arguments</doc>
              <array c:type="gchar***" zero-terminated="1" gs:is-pointer="1">
                <type name="utf8" c:type="gchar**" gs:is-pointer="1" />
              </array>
            </parameter>
            <parameter name="exit_status" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="exitStatus">
              <doc xml:space="preserve" filename="gapplication.h" line="77">exit status to fill after processing the command line.</doc>
              <type name="gint" c:type="int*" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
              <doc xml:space="preserve" filename="gapplication.h" line="75">a #GApplication</doc>
              <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
            </parameter>
            <parameter name="arguments" direction="inout" caller-allocates="0" transfer-ownership="full" gs:managed-name="arguments">
              <doc xml:space="preserve" filename="gapplication.h" line="76">array of command line arguments</doc>
              <array c:type="gchar***" zero-terminated="1" gs:is-pointer="1">
                <type name="utf8" c:type="gchar**" gs:is-pointer="1" />
              </array>
            </parameter>
            <parameter name="exit_status" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="exitStatus">
              <doc xml:space="preserve" filename="gapplication.h" line="77">exit status to fill after processing the command line.</doc>
              <type name="gint" c:type="int*" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="before_emit" gs:managed-name="BeforeEmit">
        <callback name="before_emit" gs:dll-name="gio-2.0" gs:managed-name="BeforeEmit">
          <source-position filename="gapplication.h" line="96" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
              <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
            </parameter>
            <parameter name="platform_data" transfer-ownership="none" gs:managed-name="platformData" direction="in">
              <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
              <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
            </parameter>
            <parameter name="platform_data" transfer-ownership="none" gs:managed-name="platformData" direction="in">
              <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="after_emit" gs:managed-name="AfterEmit">
        <callback name="after_emit" gs:dll-name="gio-2.0" gs:managed-name="AfterEmit">
          <source-position filename="gapplication.h" line="98" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
              <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
            </parameter>
            <parameter name="platform_data" transfer-ownership="none" gs:managed-name="platformData" direction="in">
              <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
              <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
            </parameter>
            <parameter name="platform_data" transfer-ownership="none" gs:managed-name="platformData" direction="in">
              <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="add_platform_data" gs:managed-name="AddPlatformData">
        <callback name="add_platform_data" gs:dll-name="gio-2.0" gs:managed-name="AddPlatformData">
          <source-position filename="gapplication.h" line="100" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
              <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
            </parameter>
            <parameter name="builder" transfer-ownership="none" gs:managed-name="builder" direction="in">
              <type name="GLib.VariantBuilder" c:type="GVariantBuilder*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
              <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
            </parameter>
            <parameter name="builder" transfer-ownership="none" gs:managed-name="builder" direction="in">
              <type name="GLib.VariantBuilder" c:type="GVariantBuilder*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="quit_mainloop" gs:managed-name="QuitMainloop">
        <callback name="quit_mainloop" gs:dll-name="gio-2.0" gs:managed-name="QuitMainloop">
          <source-position filename="gapplication.h" line="102" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
              <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
              <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="run_mainloop" gs:managed-name="RunMainloop">
        <callback name="run_mainloop" gs:dll-name="gio-2.0" gs:managed-name="RunMainloop">
          <source-position filename="gapplication.h" line="103" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
              <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
              <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="shutdown" gs:managed-name="Shutdown">
        <callback name="shutdown" gs:dll-name="gio-2.0" gs:managed-name="Shutdown">
          <source-position filename="gapplication.h" line="104" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
              <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
              <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="dbus_register" introspectable="1" gs:managed-name="DbusRegister">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="dbus_unregister" introspectable="1" gs:managed-name="DbusUnregister">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="handle_local_options" gs:managed-name="HandleLocalOptions">
        <callback name="handle_local_options" gs:dll-name="gio-2.0" gs:managed-name="HandleLocalOptions">
          <source-position filename="gapplication.h" line="113" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="gint" c:type="gint" />
          </return-value>
          <parameters>
            <parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
              <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
            </parameter>
            <parameter name="options" transfer-ownership="none" gs:managed-name="options" direction="in">
              <type name="GLib.VariantDict" c:type="GVariantDict*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
              <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
            </parameter>
            <parameter name="options" transfer-ownership="none" gs:managed-name="options" direction="in">
              <type name="GLib.VariantDict" c:type="GVariantDict*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="name_lost" gs:managed-name="NameLost">
        <callback name="name_lost" gs:dll-name="gio-2.0" gs:managed-name="NameLost">
          <source-position filename="gapplication.h" line="115" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
              <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="application" transfer-ownership="none" gs:managed-name="application" direction="in">
              <type name="Application" c:type="GApplication*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="padding0" readable="0" private="1" gs:managed-name="Padding0">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="padding1" readable="0" private="1" gs:managed-name="Padding1">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="padding2" readable="0" private="1" gs:managed-name="Padding2">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="padding3" readable="0" private="1" gs:managed-name="Padding3">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="padding4" readable="0" private="1" gs:managed-name="Padding4">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="padding5" readable="0" private="1" gs:managed-name="Padding5">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="padding6" readable="0" private="1" gs:managed-name="Padding6">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
    </record>
    <class name="ApplicationCommandLine" c:symbol-prefix="application_command_line" c:type="GApplicationCommandLine" parent="GObject.Object" glib:type-name="GApplicationCommandLine" glib:get-type="g_application_command_line_get_type" glib:type-struct="ApplicationCommandLineClass" gs:managed-name="ApplicationCommandLine">
      <doc xml:space="preserve" filename="gio-2.0.c" line="4854">#GApplicationCommandLine represents a command-line invocation of
an application.  It is created by #GApplication and emitted
in the #GApplication::command-line signal and virtual function.

The class contains the list of arguments that the program was invoked
with.  It is also possible to query if the commandline invocation was
local (ie: the current process is running in direct response to the
invocation) or remote (ie: some other process forwarded the
commandline to this process).

The GApplicationCommandLine object can provide the @argc and @argv
parameters for use with the #GOptionContext command-line parsing API,
with the g_application_command_line_get_arguments() function. See
[gapplication-example-cmdline3.c][gapplication-example-cmdline3]
for an example.

The exit status of the originally-invoked process may be set and
messages can be printed to stdout or stderr of that process.  The
lifecycle of the originally-invoked process is tied to the lifecycle
of this object (ie: the process exits when the last reference is
dropped).

The main use for #GApplicationCommandLine (and the
#GApplication::command-line signal) is 'Emacs server' like use cases:
You can set the `EDITOR` environment variable to have e.g. git use
your favourite editor to edit commit messages, and if you already
have an instance of the editor running, the editing will happen
in the running instance, instead of opening a new one. An important
aspect of this use case is that the process that gets started by git
does not return until the editing is done.

Normally, the commandline is completely handled in the
#GApplication::command-line handler. The launching instance exits
once the signal handler in the primary instance has returned, and
the return value of the signal handler becomes the exit status
of the launching instance.
|[&lt;!-- language="C" --&gt;
static int
command_line (GApplication            *application,
              GApplicationCommandLine *cmdline)
{
  gchar **argv;
  gint argc;
  gint i;

  argv = g_application_command_line_get_arguments (cmdline, &amp;argc);

  g_application_command_line_print (cmdline,
                                    "This text is written back\n"
                                    "to stdout of the caller\n");

  for (i = 0; i &lt; argc; i++)
    g_print ("argument %d: %s\n", i, argv[i]);

  g_strfreev (argv);

  return 0;
}
]|
The complete example can be found here:
[gapplication-example-cmdline.c](https://git.gnome.org/browse/glib/tree/gio/tests/gapplication-example-cmdline.c)

In more complicated cases, the handling of the comandline can be
split between the launcher and the primary instance.
|[&lt;!-- language="C" --&gt;
static gboolean
 test_local_cmdline (GApplication   *application,
                     gchar        ***arguments,
                     gint           *exit_status)
{
  gint i, j;
  gchar **argv;

  argv = *arguments;

  i = 1;
  while (argv[i])
    {
      if (g_str_has_prefix (argv[i], "--local-"))
        {
          g_print ("handling argument %s locally\n", argv[i]);
          g_free (argv[i]);
          for (j = i; argv[j]; j++)
            argv[j] = argv[j + 1];
        }
      else
        {
          g_print ("not handling argument %s locally\n", argv[i]);
          i++;
        }
    }

  *exit_status = 0;

  return FALSE;
}

static void
test_application_class_init (TestApplicationClass *class)
{
  G_APPLICATION_CLASS (class)-&gt;local_command_line = test_local_cmdline;

  ...
}
]|
In this example of split commandline handling, options that start
with `--local-` are handled locally, all other options are passed
to the #GApplication::command-line handler which runs in the primary
instance.

The complete example can be found here:
[gapplication-example-cmdline2.c](https://git.gnome.org/browse/glib/tree/gio/tests/gapplication-example-cmdline2.c)

If handling the commandline requires a lot of work, it may
be better to defer it.
|[&lt;!-- language="C" --&gt;
static gboolean
my_cmdline_handler (gpointer data)
{
  GApplicationCommandLine *cmdline = data;

  // do the heavy lifting in an idle

  g_application_command_line_set_exit_status (cmdline, 0);
  g_object_unref (cmdline); // this releases the application

  return G_SOURCE_REMOVE;
}

static int
command_line (GApplication            *application,
              GApplicationCommandLine *cmdline)
{
  // keep the application running until we are done with this commandline
  g_application_hold (application);

  g_object_set_data_full (G_OBJECT (cmdline),
                          "application", application,
                          (GDestroyNotify)g_application_release);

  g_object_ref (cmdline);
  g_idle_add (my_cmdline_handler, cmdline);

  return 0;
}
]|
In this example the commandline is not completely handled before
the #GApplication::command-line handler returns. Instead, we keep
a reference to the #GApplicationCommandLine object and handle it
later (in this example, in an idle). Note that it is necessary to
hold the application until you are done with the commandline.

The complete example can be found here:
[gapplication-example-cmdline3.c](https://git.gnome.org/browse/glib/tree/gio/tests/gapplication-example-cmdline3.c)</doc>
      <source-position filename="gapplicationcommandline.h" line="70" />
      <virtual-method name="get_stdin" invoker="get_stdin" version="2.34" gs:dll-name="gio-2.0" gs:managed-name="DoGetStdin">
        <doc xml:space="preserve" filename="gio-2.0.c" line="11858">Gets the stdin of the invoking process.

The #GInputStream can be used to read data passed to the standard
input of the invoking process.
This doesn't work on all platforms.  Presently, it is only available
on UNIX when using a D-Bus daemon capable of passing file descriptors.
If stdin is not available then %NULL will be returned.  In the
future, support may be expanded to other platforms.

You must only call this function once per commandline invocation.</doc>
        <source-position filename="gapplicationcommandline.h" line="67" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="11873">a #GInputStream for stdin</doc>
          <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none" gs:managed-name="cmdline" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11860">a #GApplicationCommandLine</doc>
            <type name="ApplicationCommandLine" c:type="GApplicationCommandLine*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </virtual-method>
      <virtual-method name="print_literal" gs:dll-name="gio-2.0" gs:managed-name="DoPrintLiteral">
        <source-position filename="gapplicationcommandline.h" line="63" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none" gs:managed-name="cmdline" direction="in">
            <type name="ApplicationCommandLine" c:type="GApplicationCommandLine*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="message" transfer-ownership="none" gs:managed-name="message" direction="in">
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="message" transfer-ownership="none" gs:managed-name="message" direction="in">
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="printerr_literal" gs:dll-name="gio-2.0" gs:managed-name="DoPrinterrLiteral">
        <source-position filename="gapplicationcommandline.h" line="65" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none" gs:managed-name="cmdline" direction="in">
            <type name="ApplicationCommandLine" c:type="GApplicationCommandLine*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="message" transfer-ownership="none" gs:managed-name="message" direction="in">
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="message" transfer-ownership="none" gs:managed-name="message" direction="in">
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <method name="create_file_for_arg" c:identifier="g_application_command_line_create_file_for_arg" version="2.36" gs:dll-name="gio-2.0" gs:managed-name="CreateFileForArg">
        <doc xml:space="preserve" filename="gio-2.0.c" line="11714">Creates a #GFile corresponding to a filename that was given as part
of the invocation of @cmdline.

This differs from g_file_new_for_commandline_arg() in that it
resolves relative pathnames using the current working directory of
the invoking process rather than the local process.</doc>
        <source-position filename="gapplicationcommandline.h" line="117" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="11726">a new #GFile</doc>
          <type name="File" c:type="GFile*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none" gs:managed-name="cmdline" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11716">a #GApplicationCommandLine</doc>
            <type name="ApplicationCommandLine" c:type="GApplicationCommandLine*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="arg" transfer-ownership="none" gs:managed-name="arg" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11717">an argument from @cmdline</doc>
            <type name="filename" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="arg" transfer-ownership="none" gs:managed-name="arg" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11717">an argument from @cmdline</doc>
            <type name="filename" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <gs:managed-property name="get_arguments" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="Arguments">
        <doc xml:space="preserve" filename="gio-2.0.c" line="11731">Gets the list of arguments that was passed on the command line.

The strings in the array may contain non-UTF-8 data on UNIX (such as
filenames or arguments given in the system locale) but are always in
UTF-8 on Windows.

If you wish to use the return value with #GOptionContext, you must
use g_option_context_parse_strv().

The return value is %NULL-terminated and should be freed using
g_strfreev().</doc>
        <source-position filename="gapplicationcommandline.h" line="76" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="11748">
     the string array containing the arguments (the argv)</doc>
          <array length="0" zero-terminated="0" c:type="gchar**" null-terminated="1" gs:is-pointer="1">
            <type name="filename" gs:is-pointer="1" />
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none" gs:managed-name="cmdline" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11733">a #GApplicationCommandLine</doc>
            <type name="ApplicationCommandLine" c:type="GApplicationCommandLine*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="argc" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="argc">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11734">the length of the arguments array, or %NULL</doc>
            <type name="gint" c:type="int*" />
          </parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_arguments" c:identifier="g_application_command_line_get_arguments" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="GetArguments" gs:property-getter-for="Arguments" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="11731">Gets the list of arguments that was passed on the command line.

The strings in the array may contain non-UTF-8 data on UNIX (such as
filenames or arguments given in the system locale) but are always in
UTF-8 on Windows.

If you wish to use the return value with #GOptionContext, you must
use g_option_context_parse_strv().

The return value is %NULL-terminated and should be freed using
g_strfreev().</doc>
        <source-position filename="gapplicationcommandline.h" line="76" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="11748">
     the string array containing the arguments (the argv)</doc>
          <array length="0" zero-terminated="0" c:type="gchar**" null-terminated="1" gs:is-pointer="1">
            <type name="filename" gs:is-pointer="1" />
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none" gs:managed-name="cmdline" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11733">a #GApplicationCommandLine</doc>
            <type name="ApplicationCommandLine" c:type="GApplicationCommandLine*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="argc" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="argc">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11734">the length of the arguments array, or %NULL</doc>
            <type name="gint" c:type="int*" />
          </parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_cwd" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="Cwd">
        <doc xml:space="preserve" filename="gio-2.0.c" line="11754">Gets the working directory of the command line invocation.
The string may contain non-utf8 data.

It is possible that the remote application did not send a working
directory, so this may be %NULL.

The return value should not be modified or freed and is valid for as
long as @cmdline exists.</doc>
        <source-position filename="gapplicationcommandline.h" line="93" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="11767">the current directory, or %NULL</doc>
          <type name="filename" c:type="const gchar*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none" gs:managed-name="cmdline" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11756">a #GApplicationCommandLine</doc>
            <type name="ApplicationCommandLine" c:type="GApplicationCommandLine*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_cwd" c:identifier="g_application_command_line_get_cwd" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="GetCwd" gs:property-getter-for="Cwd" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="11754">Gets the working directory of the command line invocation.
The string may contain non-utf8 data.

It is possible that the remote application did not send a working
directory, so this may be %NULL.

The return value should not be modified or freed and is valid for as
long as @cmdline exists.</doc>
        <source-position filename="gapplicationcommandline.h" line="93" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="11767">the current directory, or %NULL</doc>
          <type name="filename" c:type="const gchar*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none" gs:managed-name="cmdline" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11756">a #GApplicationCommandLine</doc>
            <type name="ApplicationCommandLine" c:type="GApplicationCommandLine*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_environment" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="Environment">
        <doc xml:space="preserve" filename="gio-2.0.c" line="11772">Gets the contents of the 'environ' variable of the command line
invocation, as would be returned by g_get_environ(), ie as a
%NULL-terminated list of strings in the form 'NAME=VALUE'.
The strings may contain non-utf8 data.

The remote application usually does not send an environment.  Use
%G_APPLICATION_SEND_ENVIRONMENT to affect that.  Even with this flag
set it is possible that the environment is still not available (due
to invocation messages from other applications).

The return value should not be modified or freed and is valid for as
long as @cmdline exists.

See g_application_command_line_getenv() if you are only interested
in the value of a single environment variable.</doc>
        <source-position filename="gapplicationcommandline.h" line="86" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="11792">
    the environment strings, or %NULL if they were not sent</doc>
          <array c:type="const gchar* const*" zero-terminated="1" gs:is-pointer="1">
            <type name="filename" gs:is-pointer="1" />
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none" gs:managed-name="cmdline" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11774">a #GApplicationCommandLine</doc>
            <type name="ApplicationCommandLine" c:type="GApplicationCommandLine*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_environment" c:identifier="g_application_command_line_get_environ" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="GetEnvironment" gs:property-getter-for="Environment" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="11772">Gets the contents of the 'environ' variable of the command line
invocation, as would be returned by g_get_environ(), ie as a
%NULL-terminated list of strings in the form 'NAME=VALUE'.
The strings may contain non-utf8 data.

The remote application usually does not send an environment.  Use
%G_APPLICATION_SEND_ENVIRONMENT to affect that.  Even with this flag
set it is possible that the environment is still not available (due
to invocation messages from other applications).

The return value should not be modified or freed and is valid for as
long as @cmdline exists.

See g_application_command_line_getenv() if you are only interested
in the value of a single environment variable.</doc>
        <source-position filename="gapplicationcommandline.h" line="86" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="11792">
    the environment strings, or %NULL if they were not sent</doc>
          <array c:type="const gchar* const*" zero-terminated="1" gs:is-pointer="1">
            <type name="filename" gs:is-pointer="1" />
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none" gs:managed-name="cmdline" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11774">a #GApplicationCommandLine</doc>
            <type name="ApplicationCommandLine" c:type="GApplicationCommandLine*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_exit_status" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="ExitStatus">
        <doc xml:space="preserve" filename="gio-2.0.c" line="11798">Gets the exit status of @cmdline.  See
g_application_command_line_set_exit_status() for more information.</doc>
        <source-position filename="gapplicationcommandline.h" line="108" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="11805">the exit status</doc>
          <type name="gint" c:type="int" />
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none" gs:managed-name="cmdline" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11800">a #GApplicationCommandLine</doc>
            <type name="ApplicationCommandLine" c:type="GApplicationCommandLine*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_exit_status" c:identifier="g_application_command_line_get_exit_status" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="GetExitStatus" gs:property-getter-for="ExitStatus" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="11798">Gets the exit status of @cmdline.  See
g_application_command_line_set_exit_status() for more information.</doc>
        <source-position filename="gapplicationcommandline.h" line="108" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="11805">the exit status</doc>
          <type name="gint" c:type="int" />
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none" gs:managed-name="cmdline" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11800">a #GApplicationCommandLine</doc>
            <type name="ApplicationCommandLine" c:type="GApplicationCommandLine*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_is_remote" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="IsRemote">
        <doc xml:space="preserve" filename="gio-2.0.c" line="11810">Determines if @cmdline represents a remote invocation.</doc>
        <source-position filename="gapplicationcommandline.h" line="96" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="11816">%TRUE if the invocation was remote</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none" gs:managed-name="cmdline" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11812">a #GApplicationCommandLine</doc>
            <type name="ApplicationCommandLine" c:type="GApplicationCommandLine*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_is_remote" c:identifier="g_application_command_line_get_is_remote" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="GetIsRemote" gs:property-getter-for="IsRemote" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="11810">Determines if @cmdline represents a remote invocation.</doc>
        <source-position filename="gapplicationcommandline.h" line="96" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="11816">%TRUE if the invocation was remote</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none" gs:managed-name="cmdline" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11812">a #GApplicationCommandLine</doc>
            <type name="ApplicationCommandLine" c:type="GApplicationCommandLine*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_options" version="2.40" gs:dll-name="gio-2.0" gs:managed-name="Options">
        <doc xml:space="preserve" filename="gio-2.0.c" line="11821">Gets the options there were passed to g_application_command_line().

If you did not override local_command_line() then these are the same
options that were parsed according to the #GOptionEntrys added to the
application with g_application_add_main_option_entries() and possibly
modified from your GApplication::handle-local-options handler.

If no options were sent then an empty dictionary is returned so that
you don't need to check for %NULL.</doc>
        <source-position filename="gapplicationcommandline.h" line="80" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="11835">a #GVariantDict with the options</doc>
          <type name="GLib.VariantDict" c:type="GVariantDict*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none" gs:managed-name="cmdline" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11823">a #GApplicationCommandLine</doc>
            <type name="ApplicationCommandLine" c:type="GApplicationCommandLine*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_options" c:identifier="g_application_command_line_get_options_dict" version="2.40" gs:dll-name="gio-2.0" gs:managed-name="GetOptions" gs:property-getter-for="Options" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="11821">Gets the options there were passed to g_application_command_line().

If you did not override local_command_line() then these are the same
options that were parsed according to the #GOptionEntrys added to the
application with g_application_add_main_option_entries() and possibly
modified from your GApplication::handle-local-options handler.

If no options were sent then an empty dictionary is returned so that
you don't need to check for %NULL.</doc>
        <source-position filename="gapplicationcommandline.h" line="80" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="11835">a #GVariantDict with the options</doc>
          <type name="GLib.VariantDict" c:type="GVariantDict*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none" gs:managed-name="cmdline" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11823">a #GApplicationCommandLine</doc>
            <type name="ApplicationCommandLine" c:type="GApplicationCommandLine*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_platform_data" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="PlatformData">
        <doc xml:space="preserve" filename="gio-2.0.c" line="11840">Gets the platform data associated with the invocation of @cmdline.

This is a #GVariant dictionary containing information about the
context in which the invocation occurred.  It typically contains
information like the current working directory and the startup
notification ID.

For local invocation, it will be %NULL.</doc>
        <source-position filename="gapplicationcommandline.h" line="114" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="11853">the platform data, or %NULL</doc>
          <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none" gs:managed-name="cmdline" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11842">#GApplicationCommandLine</doc>
            <type name="ApplicationCommandLine" c:type="GApplicationCommandLine*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_platform_data" c:identifier="g_application_command_line_get_platform_data" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="GetPlatformData" gs:property-getter-for="PlatformData" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="11840">Gets the platform data associated with the invocation of @cmdline.

This is a #GVariant dictionary containing information about the
context in which the invocation occurred.  It typically contains
information like the current working directory and the startup
notification ID.

For local invocation, it will be %NULL.</doc>
        <source-position filename="gapplicationcommandline.h" line="114" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="11853">the platform data, or %NULL</doc>
          <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none" gs:managed-name="cmdline" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11842">#GApplicationCommandLine</doc>
            <type name="ApplicationCommandLine" c:type="GApplicationCommandLine*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_stdin" version="2.34" gs:dll-name="gio-2.0" gs:managed-name="Stdin">
        <doc xml:space="preserve" filename="gio-2.0.c" line="11858">Gets the stdin of the invoking process.

The #GInputStream can be used to read data passed to the standard
input of the invoking process.
This doesn't work on all platforms.  Presently, it is only available
on UNIX when using a D-Bus daemon capable of passing file descriptors.
If stdin is not available then %NULL will be returned.  In the
future, support may be expanded to other platforms.

You must only call this function once per commandline invocation.</doc>
        <source-position filename="gapplicationcommandline.h" line="83" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="11873">a #GInputStream for stdin</doc>
          <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none" gs:managed-name="cmdline" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11860">a #GApplicationCommandLine</doc>
            <type name="ApplicationCommandLine" c:type="GApplicationCommandLine*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_stdin" c:identifier="g_application_command_line_get_stdin" version="2.34" gs:dll-name="gio-2.0" gs:managed-name="GetStdin" gs:property-getter-for="Stdin" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="11858">Gets the stdin of the invoking process.

The #GInputStream can be used to read data passed to the standard
input of the invoking process.
This doesn't work on all platforms.  Presently, it is only available
on UNIX when using a D-Bus daemon capable of passing file descriptors.
If stdin is not available then %NULL will be returned.  In the
future, support may be expanded to other platforms.

You must only call this function once per commandline invocation.</doc>
        <source-position filename="gapplicationcommandline.h" line="83" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="11873">a #GInputStream for stdin</doc>
          <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none" gs:managed-name="cmdline" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11860">a #GApplicationCommandLine</doc>
            <type name="ApplicationCommandLine" c:type="GApplicationCommandLine*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="get_environment_variable" c:identifier="g_application_command_line_getenv" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="GetEnvironmentVariable">
        <doc xml:space="preserve" filename="gio-2.0.c" line="11878">Gets the value of a particular environment variable of the command
line invocation, as would be returned by g_getenv().  The strings may
contain non-utf8 data.

The remote application usually does not send an environment.  Use
%G_APPLICATION_SEND_ENVIRONMENT to affect that.  Even with this flag
set it is possible that the environment is still not available (due
to invocation messages from other applications).

The return value should not be modified or freed and is valid for as
long as @cmdline exists.</doc>
        <source-position filename="gapplicationcommandline.h" line="89" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="11895">the value of the variable, or %NULL if unset or unsent</doc>
          <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none" gs:managed-name="cmdline" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11880">a #GApplicationCommandLine</doc>
            <type name="ApplicationCommandLine" c:type="GApplicationCommandLine*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11881">the environment variable to get</doc>
            <type name="filename" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11881">the environment variable to get</doc>
            <type name="filename" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_exit_status" c:identifier="g_application_command_line_set_exit_status" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="SetExitStatus" gs:property-setter-for="ExitStatus" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="11934">Sets the exit status that will be used when the invoking process
exits.

The return value of the #GApplication::command-line signal is
passed to this function when the handler returns.  This is the usual
way of setting the exit status.

In the event that you want the remote invocation to continue running
and want to decide on the exit status in the future, you can use this
call.  For the case of a remote invocation, the remote process will
typically exit when the last reference is dropped on @cmdline.  The
exit status of the remote process will be equal to the last value
that was set with this function.

In the case that the commandline invocation is local, the situation
is slightly more complicated.  If the commandline invocation results
in the mainloop running (ie: because the use-count of the application
increased to a non-zero value) then the application is considered to
have been 'successful' in a certain sense, and the exit status is
always zero.  If the application use count is zero, though, the exit
status of the local #GApplicationCommandLine is used.</doc>
        <source-position filename="gapplicationcommandline.h" line="110" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="cmdline" transfer-ownership="none" gs:managed-name="cmdline" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11936">a #GApplicationCommandLine</doc>
            <type name="ApplicationCommandLine" c:type="GApplicationCommandLine*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="exit_status" transfer-ownership="none" gs:managed-name="exitStatus" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11937">the exit status</doc>
            <type name="gint" c:type="int" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="exit_status" transfer-ownership="none" gs:managed-name="exitStatus" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11937">the exit status</doc>
            <type name="gint" c:type="int" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <property name="arguments" readable="0" writable="1" construct-only="1" transfer-ownership="none" gs:managed-name="Arguments_">
        <type name="GLib.Variant" />
      </property>
      <property name="is-remote" transfer-ownership="none" gs:managed-name="IsRemote_">
        <type name="gboolean" c:type="gboolean" />
      </property>
      <property name="options" readable="0" writable="1" construct-only="1" transfer-ownership="none" gs:managed-name="Options_">
        <type name="GLib.Variant" />
      </property>
      <property name="platform-data" readable="0" writable="1" construct-only="1" transfer-ownership="none" gs:managed-name="PlatformData_">
        <type name="GLib.Variant" />
      </property>
      <field name="parent_instance" readable="0" private="1" gs:managed-name="ParentInstance">
        <type name="GObject.Object" c:type="GObject" />
      </field>
      <field name="priv" readable="0" private="1" gs:managed-name="Priv">
        <type name="ApplicationCommandLinePrivate" c:type="GApplicationCommandLinePrivate*" gs:is-pointer="1" />
      </field>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_application_command_line_get_type" gs:access-modifiers="private" gs:dll-name="gio-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </class>
    <record name="ApplicationCommandLineClass" c:type="GApplicationCommandLineClass" glib:is-gtype-struct-for="ApplicationCommandLine" version="2.28" gs:managed-name="ApplicationCommandLineClass">
      <doc xml:space="preserve" filename="gio-2.0.c" line="467">The #GApplicationCommandLineClass-struct
contains private data only.</doc>
      <source-position filename="gapplicationcommandline.h" line="70" />
      <field name="parent_class" readable="0" private="1" gs:managed-name="ParentClass">
        <type name="GObject.ObjectClass" c:type="GObjectClass" />
      </field>
      <field name="print_literal" gs:managed-name="PrintLiteral">
        <callback name="print_literal" gs:dll-name="gio-2.0" gs:managed-name="PrintLiteral">
          <source-position filename="gapplicationcommandline.h" line="63" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="cmdline" transfer-ownership="none" gs:managed-name="cmdline" direction="in">
              <type name="ApplicationCommandLine" c:type="GApplicationCommandLine*" gs:is-pointer="1" />
            </parameter>
            <parameter name="message" transfer-ownership="none" gs:managed-name="message" direction="in">
              <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="cmdline" transfer-ownership="none" gs:managed-name="cmdline" direction="in">
              <type name="ApplicationCommandLine" c:type="GApplicationCommandLine*" gs:is-pointer="1" />
            </parameter>
            <parameter name="message" transfer-ownership="none" gs:managed-name="message" direction="in">
              <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="printerr_literal" gs:managed-name="PrinterrLiteral">
        <callback name="printerr_literal" gs:dll-name="gio-2.0" gs:managed-name="PrinterrLiteral">
          <source-position filename="gapplicationcommandline.h" line="65" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="cmdline" transfer-ownership="none" gs:managed-name="cmdline" direction="in">
              <type name="ApplicationCommandLine" c:type="GApplicationCommandLine*" gs:is-pointer="1" />
            </parameter>
            <parameter name="message" transfer-ownership="none" gs:managed-name="message" direction="in">
              <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="cmdline" transfer-ownership="none" gs:managed-name="cmdline" direction="in">
              <type name="ApplicationCommandLine" c:type="GApplicationCommandLine*" gs:is-pointer="1" />
            </parameter>
            <parameter name="message" transfer-ownership="none" gs:managed-name="message" direction="in">
              <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="get_stdin" gs:managed-name="GetStdin">
        <callback name="get_stdin" gs:dll-name="gio-2.0" gs:managed-name="GetStdin">
          <source-position filename="gapplicationcommandline.h" line="67" />
          <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="11873">a #GInputStream for stdin</doc>
            <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="cmdline" transfer-ownership="none" gs:managed-name="cmdline" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="11860">a #GApplicationCommandLine</doc>
              <type name="ApplicationCommandLine" c:type="GApplicationCommandLine*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="cmdline" transfer-ownership="none" gs:managed-name="cmdline" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="11860">a #GApplicationCommandLine</doc>
              <type name="ApplicationCommandLine" c:type="GApplicationCommandLine*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="padding0" readable="0" private="1" gs:managed-name="Padding0">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="padding1" readable="0" private="1" gs:managed-name="Padding1">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="padding2" readable="0" private="1" gs:managed-name="Padding2">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="padding3" readable="0" private="1" gs:managed-name="Padding3">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="padding4" readable="0" private="1" gs:managed-name="Padding4">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="padding5" readable="0" private="1" gs:managed-name="Padding5">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="padding6" readable="0" private="1" gs:managed-name="Padding6">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="padding7" readable="0" private="1" gs:managed-name="Padding7">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="padding8" readable="0" private="1" gs:managed-name="Padding8">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="padding9" readable="0" private="1" gs:managed-name="Padding9">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="padding10" readable="0" private="1" gs:managed-name="Padding10">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
    </record>
    <bitfield name="ApplicationFlags" version="2.28" glib:type-name="GApplicationFlags" glib:get-type="g_application_flags_get_type" c:type="GApplicationFlags" gs:managed-name="ApplicationFlags">
      <doc xml:space="preserve" filename="gioenums.h" line="1465">Flags used to define the behaviour of a #GApplication.</doc>
      <member name="flags_none" value="0" c:identifier="G_APPLICATION_FLAGS_NONE" glib:nick="flags-none" gs:managed-name="FlagsNone">
        <doc xml:space="preserve" filename="gioenums.h" line="1467">Default</doc>
      </member>
      <member name="is_service" value="1" c:identifier="G_APPLICATION_IS_SERVICE" glib:nick="is-service" gs:managed-name="IsService">
        <doc xml:space="preserve" filename="gioenums.h" line="1468">Run as a service. In this mode, registration
     fails if the service is already running, and the application
     will initially wait up to 10 seconds for an initial activation
     message to arrive.</doc>
      </member>
      <member name="is_launcher" value="2" c:identifier="G_APPLICATION_IS_LAUNCHER" glib:nick="is-launcher" gs:managed-name="IsLauncher">
        <doc xml:space="preserve" filename="gioenums.h" line="1472">Don't try to become the primary instance.</doc>
      </member>
      <member name="handles_open" value="4" c:identifier="G_APPLICATION_HANDLES_OPEN" glib:nick="handles-open" gs:managed-name="HandlesOpen">
        <doc xml:space="preserve" filename="gioenums.h" line="1473">This application handles opening files (in
    the primary instance). Note that this flag only affects the default
    implementation of local_command_line(), and has no effect if
    %G_APPLICATION_HANDLES_COMMAND_LINE is given.
    See g_application_run() for details.</doc>
      </member>
      <member name="handles_command_line" value="8" c:identifier="G_APPLICATION_HANDLES_COMMAND_LINE" glib:nick="handles-command-line" gs:managed-name="HandlesCommandLine">
        <doc xml:space="preserve" filename="gioenums.h" line="1478">This application handles command line
    arguments (in the primary instance). Note that this flag only affect
    the default implementation of local_command_line().
    See g_application_run() for details.</doc>
      </member>
      <member name="send_environment" value="16" c:identifier="G_APPLICATION_SEND_ENVIRONMENT" glib:nick="send-environment" gs:managed-name="SendEnvironment">
        <doc xml:space="preserve" filename="gioenums.h" line="1482">Send the environment of the
    launching process to the primary instance. Set this flag if your
    application is expected to behave differently depending on certain
    environment variables. For instance, an editor might be expected
    to use the `GIT_COMMITTER_NAME` environment variable
    when editing a git commit message. The environment is available
    to the #GApplication::command-line signal handler, via
    g_application_command_line_getenv().</doc>
      </member>
      <member name="non_unique" value="32" c:identifier="G_APPLICATION_NON_UNIQUE" glib:nick="non-unique" version="2.30" gs:managed-name="NonUnique">
        <doc xml:space="preserve" filename="gioenums.h" line="1490">Make no attempts to do any of the typical
    single-instance application negotiation, even if the application
    ID is given.  The application neither attempts to become the
    owner of the application ID nor does it check if an existing
    owner already exists.  Everything occurs in the local process.</doc>
      </member>
      <member name="can_override_app_id" value="64" c:identifier="G_APPLICATION_CAN_OVERRIDE_APP_ID" glib:nick="can-override-app-id" version="2.48" gs:managed-name="CanOverrideAppId">
        <doc xml:space="preserve" filename="gioenums.h" line="1496">Allow users to override the
    application ID from the command line with `--gapplication-app-id`.</doc>
      </member>
      <member name="allow_replacement" value="128" c:identifier="G_APPLICATION_ALLOW_REPLACEMENT" glib:nick="allow-replacement" version="2.60" gs:managed-name="AllowReplacement">
        <doc xml:space="preserve" filename="gioenums.h" line="1499">Allow another instance to take over
    the bus name.</doc>
      </member>
      <member name="replace" value="256" c:identifier="G_APPLICATION_REPLACE" glib:nick="replace" version="2.60" gs:managed-name="Replace">
        <doc xml:space="preserve" filename="gioenums.h" line="1501">Take over from another instance. This flag is
    usually set by passing `--gapplication-replace` on the commandline.</doc>
      </member>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_application_flags_get_type" gs:access-modifiers="private" gs:dll-name="gio-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </bitfield>
    <interface name="AsyncInitable" c:symbol-prefix="async_initable" c:type="GAsyncInitable" version="2.22" glib:type-name="GAsyncInitable" glib:get-type="g_async_initable_get_type" glib:type-struct="AsyncInitableIface" gs:managed-name="IAsyncInitable">
      <doc xml:space="preserve" filename="gio-2.0.c" line="5018">This is the asynchronous version of #GInitable; it behaves the same
in all ways except that initialization is asynchronous. For more details
see the descriptions on #GInitable.

A class may implement both the #GInitable and #GAsyncInitable interfaces.

Users of objects implementing this are not intended to use the interface
method directly; instead it will be used automatically in various ways.
For C applications you generally just call g_async_initable_new_async()
directly, or indirectly via a foo_thing_new_async() wrapper. This will call
g_async_initable_init_async() under the cover, calling back with %NULL and
a set %GError on failure.

A typical implementation might look something like this:

|[&lt;!-- language="C" --&gt;
enum {
   NOT_INITIALIZED,
   INITIALIZING,
   INITIALIZED
};

static void
_foo_ready_cb (Foo *self)
{
  GList *l;

  self-&gt;priv-&gt;state = INITIALIZED;

  for (l = self-&gt;priv-&gt;init_results; l != NULL; l = l-&gt;next)
    {
      GTask *task = l-&gt;data;

      if (self-&gt;priv-&gt;success)
        g_task_return_boolean (task, TRUE);
      else
        g_task_return_new_error (task, ...);
      g_object_unref (task);
    }

  g_list_free (self-&gt;priv-&gt;init_results);
  self-&gt;priv-&gt;init_results = NULL;
}

static void
foo_init_async (GAsyncInitable       *initable,
                int                   io_priority,
                GCancellable         *cancellable,
                GAsyncReadyCallback   callback,
                gpointer              user_data)
{
  Foo *self = FOO (initable);
  GTask *task;

  task = g_task_new (initable, cancellable, callback, user_data);
  g_task_set_name (task, G_STRFUNC);

  switch (self-&gt;priv-&gt;state)
    {
      case NOT_INITIALIZED:
        _foo_get_ready (self);
        self-&gt;priv-&gt;init_results = g_list_append (self-&gt;priv-&gt;init_results,
                                                  task);
        self-&gt;priv-&gt;state = INITIALIZING;
        break;
      case INITIALIZING:
        self-&gt;priv-&gt;init_results = g_list_append (self-&gt;priv-&gt;init_results,
                                                  task);
        break;
      case INITIALIZED:
        if (!self-&gt;priv-&gt;success)
          g_task_return_new_error (task, ...);
        else
          g_task_return_boolean (task, TRUE);
        g_object_unref (task);
        break;
    }
}

static gboolean
foo_init_finish (GAsyncInitable       *initable,
                 GAsyncResult         *result,
                 GError              **error)
{
  g_return_val_if_fail (g_task_is_valid (result, initable), FALSE);

  return g_task_propagate_boolean (G_TASK (result), error);
}

static void
foo_async_initable_iface_init (gpointer g_iface,
                               gpointer data)
{
  GAsyncInitableIface *iface = g_iface;

  iface-&gt;init_async = foo_init_async;
  iface-&gt;init_finish = foo_init_finish;
}
]|</doc>
      <source-position filename="gasyncinitable.h" line="73" />
      <function name="new_async" c:identifier="g_async_initable_newv_async" version="2.22" deprecated="1" deprecated-version="2.54" gs:dll-name="gio-2.0" gs:managed-name="NewAsync" gs:async="1" gs:async-finish="NewFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="12809">Helper function for constructing #GAsyncInitable object. This is
similar to g_object_newv() but also initializes the object asynchronously.

When the initialization is finished, @callback will be called. You can
then call g_async_initable_new_finish() to get the new object and check
for any errors.</doc>
        <doc-deprecated xml:space="preserve">Use g_object_new_with_properties() and
g_async_initable_init_async() instead. See #GParameter for more information.</doc-deprecated>
        <source-position filename="gasyncinitable.h" line="102" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Threading.Tasks.Task">
            <type name="GObject.Object" c:type="GObject*" gs:is-pointer="1" />
          </type>
        </return-value>
        <parameters>
          <parameter name="object_type" transfer-ownership="none" gs:managed-name="objectType" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12811">a #GType supporting #GAsyncInitable.</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="n_parameters" transfer-ownership="none" gs:managed-name="nParameters" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12812">the number of parameters in @parameters</doc>
            <type name="guint" c:type="guint" />
          </parameter>
          <parameter name="parameters" transfer-ownership="none" gs:managed-name="parameters" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12813">the parameters to use to construct the object</doc>
            <type name="GObject.Parameter" c:type="GParameter*" gs:is-pointer="1" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12814">the [I/O priority][io-priority] of the operation</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12815">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="6" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12816">a #GAsyncReadyCallback to call when the initialization is
    finished</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12818">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="object_type" transfer-ownership="none" gs:managed-name="objectType" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12811">a #GType supporting #GAsyncInitable.</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="n_parameters" transfer-ownership="none" gs:managed-name="nParameters" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12812">the number of parameters in @parameters</doc>
            <type name="guint" c:type="guint" />
          </parameter>
          <parameter name="parameters" transfer-ownership="none" gs:managed-name="parameters" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12813">the parameters to use to construct the object</doc>
            <type name="GObject.Parameter" c:type="GParameter*" gs:is-pointer="1" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12814">the [I/O priority][io-priority] of the operation</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12815">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <virtual-method name="init_async" invoker="init_async" version="2.22" gs:dll-name="gio-2.0" gs:managed-name="DoInitAsync">
        <doc xml:space="preserve" filename="gio-2.0.c" line="12681">Starts asynchronous initialization of the object implementing the
interface. This must be done before any real use of the object after
initial construction. If the object also implements #GInitable you can
optionally call g_initable_init() instead.

This method is intended for language bindings. If writing in C,
g_async_initable_new_async() should typically be used instead.

When the initialization is finished, @callback will be called. You can
then call g_async_initable_init_finish() to get the result of the
initialization.

Implementations may also support cancellation. If @cancellable is not
%NULL, then initialization can be cancelled by triggering the cancellable
object from another thread. If the operation was cancelled, the error
%G_IO_ERROR_CANCELLED will be returned. If @cancellable is not %NULL, and
the object doesn't support cancellable initialization, the error
%G_IO_ERROR_NOT_SUPPORTED will be returned.

As with #GInitable, if the object is not initialized, or initialization
returns with an error, then all operations on the object except
g_object_ref() and g_object_unref() are considered to be invalid, and
have undefined behaviour. They will often fail with g_critical() or
g_warning(), but this must not be relied on.

Callers should not assume that a class which implements #GAsyncInitable can
be initialized multiple times; for more information, see g_initable_init().
If a class explicitly supports being initialized multiple times,
implementation requires yielding all subsequent calls to init_async() on the
results of the first call.

For classes that also support the #GInitable interface, the default
implementation of this method will run the g_initable_init() function
in a thread, so if you want to support asynchronous initialization via
threads, just implement the #GAsyncInitable interface without overriding
any interface methods.</doc>
        <source-position filename="gasyncinitable.h" line="65" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="initable" transfer-ownership="none" gs:managed-name="initable" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12683">a #GAsyncInitable.</doc>
            <type name="AsyncInitable" c:type="GAsyncInitable*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12684">the [I/O priority][io-priority] of the operation</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12685">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12686">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12687">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12684">the [I/O priority][io-priority] of the operation</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12686">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12685">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="init_finish" invoker="init_finish" version="2.22" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoInitFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="12730">Finishes asynchronous initialization and returns the result.
See g_async_initable_init_async().</doc>
        <source-position filename="gasyncinitable.h" line="70" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="12740">%TRUE if successful. If an error has occurred, this function
will return %FALSE and set @error appropriately if present.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="initable" transfer-ownership="none" gs:managed-name="initable" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12732">a #GAsyncInitable.</doc>
            <type name="AsyncInitable" c:type="GAsyncInitable*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12733">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12733">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <method name="init_async" c:identifier="g_async_initable_init_async" version="2.22" gs:dll-name="gio-2.0" gs:managed-name="InitAsync" gs:async="1" gs:async-finish="InitFinish" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="12681">Starts asynchronous initialization of the object implementing the
interface. This must be done before any real use of the object after
initial construction. If the object also implements #GInitable you can
optionally call g_initable_init() instead.

This method is intended for language bindings. If writing in C,
g_async_initable_new_async() should typically be used instead.

When the initialization is finished, @callback will be called. You can
then call g_async_initable_init_finish() to get the result of the
initialization.

Implementations may also support cancellation. If @cancellable is not
%NULL, then initialization can be cancelled by triggering the cancellable
object from another thread. If the operation was cancelled, the error
%G_IO_ERROR_CANCELLED will be returned. If @cancellable is not %NULL, and
the object doesn't support cancellable initialization, the error
%G_IO_ERROR_NOT_SUPPORTED will be returned.

As with #GInitable, if the object is not initialized, or initialization
returns with an error, then all operations on the object except
g_object_ref() and g_object_unref() are considered to be invalid, and
have undefined behaviour. They will often fail with g_critical() or
g_warning(), but this must not be relied on.

Callers should not assume that a class which implements #GAsyncInitable can
be initialized multiple times; for more information, see g_initable_init().
If a class explicitly supports being initialized multiple times,
implementation requires yielding all subsequent calls to init_async() on the
results of the first call.

For classes that also support the #GInitable interface, the default
implementation of this method will run the g_initable_init() function
in a thread, so if you want to support asynchronous initialization via
threads, just implement the #GAsyncInitable interface without overriding
any interface methods.</doc>
        <source-position filename="gasyncinitable.h" line="80" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Threading.Tasks.Task" />
        </return-value>
        <parameters>
          <instance-parameter name="initable" transfer-ownership="none" gs:managed-name="initable" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12683">a #GAsyncInitable.</doc>
            <type name="AsyncInitable" c:type="GAsyncInitable*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12684">the [I/O priority][io-priority] of the operation</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12685">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12686">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12687">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="initable" transfer-ownership="none" gs:managed-name="initable" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12683">a #GAsyncInitable.</doc>
            <type name="AsyncInitable" c:type="GAsyncInitable*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12684">the [I/O priority][io-priority] of the operation</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12685">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="init_finish" c:identifier="g_async_initable_init_finish" version="2.22" throws="1" gs:dll-name="gio-2.0" gs:managed-name="InitFinish" gs:pinvoke-only="1" gs:finish-for="init_async" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="12730">Finishes asynchronous initialization and returns the result.
See g_async_initable_init_async().</doc>
        <source-position filename="gasyncinitable.h" line="86" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="12740">%TRUE if successful. If an error has occurred, this function
will return %FALSE and set @error appropriately if present.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="initable" transfer-ownership="none" gs:managed-name="initable" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12732">a #GAsyncInitable.</doc>
            <type name="AsyncInitable" c:type="GAsyncInitable*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12733">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="initable" transfer-ownership="none" gs:managed-name="initable" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12732">a #GAsyncInitable.</doc>
            <type name="AsyncInitable" c:type="GAsyncInitable*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12733">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <function name="new_finish" c:identifier="g_async_initable_new_finish" version="2.22" throws="1" gs:dll-name="gio-2.0" gs:managed-name="NewFinish" gs:pinvoke-only="1" gs:finish-for="new_async">
        <doc xml:space="preserve" filename="gio-2.0.c" line="12770">Finishes the async construction for the various g_async_initable_new
calls, returning the created object or %NULL on error.</doc>
        <source-position filename="gasyncinitable.h" line="121" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="12779">a newly created #GObject,
     or %NULL on error. Free with g_object_unref().</doc>
          <type name="GObject.Object" c:type="GObject*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="initable" transfer-ownership="none" gs:managed-name="initable" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12772">the #GAsyncInitable from the callback</doc>
            <type name="AsyncInitable" c:type="GAsyncInitable*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12773">the #GAsyncResult from the callback</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12773">the #GAsyncResult from the callback</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_async_initable_get_type" gs:access-modifiers="private" gs:dll-name="gio-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </interface>
    <record name="AsyncInitableIface" c:type="GAsyncInitableIface" glib:is-gtype-struct-for="AsyncInitable" version="2.22" gs:managed-name="AsyncInitableIface">
      <doc xml:space="preserve" filename="gasyncinitable.h" line="48">Provides an interface for asynchronous initializing object such that
initialization may fail.</doc>
      <source-position filename="gasyncinitable.h" line="73" />
      <field name="g_iface" gs:managed-name="GIface">
        <doc xml:space="preserve" filename="gasyncinitable.h" line="50">The parent interface.</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface" />
      </field>
      <field name="init_async" gs:managed-name="InitAsync">
        <callback name="init_async" gs:dll-name="gio-2.0" gs:managed-name="InitAsync">
          <source-position filename="gasyncinitable.h" line="65" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="initable" transfer-ownership="none" gs:managed-name="initable" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="12683">a #GAsyncInitable.</doc>
              <type name="AsyncInitable" c:type="GAsyncInitable*" gs:is-pointer="1" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="12684">the [I/O priority][io-priority] of the operation</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="12685">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="12686">a #GAsyncReadyCallback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4" gs:managed-name="userData" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="12687">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="initable" transfer-ownership="none" gs:managed-name="initable" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="12683">a #GAsyncInitable.</doc>
              <type name="AsyncInitable" c:type="GAsyncInitable*" gs:is-pointer="1" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="12684">the [I/O priority][io-priority] of the operation</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="12686">a #GAsyncReadyCallback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="12685">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="init_finish" gs:managed-name="InitFinish">
        <callback name="init_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="InitFinish">
          <source-position filename="gasyncinitable.h" line="70" />
          <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12740">%TRUE if successful. If an error has occurred, this function
will return %FALSE and set @error appropriately if present.</doc>
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="initable" transfer-ownership="none" gs:managed-name="initable" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="12732">a #GAsyncInitable.</doc>
              <type name="AsyncInitable" c:type="GAsyncInitable*" gs:is-pointer="1" />
            </parameter>
            <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="12733">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="initable" transfer-ownership="none" gs:managed-name="initable" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="12732">a #GAsyncInitable.</doc>
              <type name="AsyncInitable" c:type="GAsyncInitable*" gs:is-pointer="1" />
            </parameter>
            <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="12733">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
    </record>
    <callback name="AsyncReadyCallback" c:type="GAsyncReadyCallback" gs:dll-name="gio-2.0" gs:managed-name="AsyncReadyCallback">
      <doc xml:space="preserve" filename="giotypes.h" line="260">Type definition for a function that will be called back when an asynchronous
operation within GIO has been completed. #GAsyncReadyCallback
callbacks from #GTask are guaranteed to be invoked in a later
iteration of the
[thread-default main context][g-main-context-push-thread-default]
where the #GTask was created. All other users of
#GAsyncReadyCallback must likewise call it asynchronously in a
later iteration of the main context.</doc>
      <source-position filename="giotypes.h" line="275" />
      <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
        <type name="none" c:type="void" />
      </return-value>
      <parameters>
        <parameter name="source_object" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="sourceObject" direction="in">
          <doc xml:space="preserve" filename="giotypes.h" line="262">the object the asynchronous operation was started with.</doc>
          <type name="GObject.Object" c:type="GObject*" gs:is-pointer="1" />
        </parameter>
        <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
          <doc xml:space="preserve" filename="giotypes.h" line="263">a #GAsyncResult.</doc>
          <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="2" gs:managed-name="userData" direction="in">
          <doc xml:space="preserve" filename="giotypes.h" line="264">user data passed to the callback.</doc>
          <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
        </parameter>
      </parameters>
      <gs:managed-parameters>
        <parameter name="source_object" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="sourceObject" direction="in">
          <doc xml:space="preserve" filename="giotypes.h" line="262">the object the asynchronous operation was started with.</doc>
          <type name="GObject.Object" c:type="GObject*" gs:is-pointer="1" />
        </parameter>
        <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
          <doc xml:space="preserve" filename="giotypes.h" line="263">a #GAsyncResult.</doc>
          <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
        </parameter>
      </gs:managed-parameters>
    </callback>
    <interface name="AsyncResult" c:symbol-prefix="async_result" c:type="GAsyncResult" glib:type-name="GAsyncResult" glib:get-type="g_async_result_get_type" glib:type-struct="AsyncResultIface" gs:managed-name="IAsyncResult">
      <doc xml:space="preserve" filename="gio-2.0.c" line="5126">Provides a base class for implementing asynchronous function results.

Asynchronous operations are broken up into two separate operations
which are chained together by a #GAsyncReadyCallback. To begin
an asynchronous operation, provide a #GAsyncReadyCallback to the
asynchronous function. This callback will be triggered when the
operation has completed, and must be run in a later iteration of
the [thread-default main context][g-main-context-push-thread-default]
from where the operation was initiated. It will be passed a
#GAsyncResult instance filled with the details of the operation's
success or failure, the object the asynchronous function was
started for and any error codes returned. The asynchronous callback
function is then expected to call the corresponding "_finish()"
function, passing the object the function was called for, the
#GAsyncResult instance, and (optionally) an @error to grab any
error conditions that may have occurred.

The "_finish()" function for an operation takes the generic result
(of type #GAsyncResult) and returns the specific result that the
operation in question yields (e.g. a #GFileEnumerator for a
"enumerate children" operation). If the result or error status of the
operation is not needed, there is no need to call the "_finish()"
function; GIO will take care of cleaning up the result and error
information after the #GAsyncReadyCallback returns. You can pass
%NULL for the #GAsyncReadyCallback if you don't need to take any
action at all after the operation completes. Applications may also
take a reference to the #GAsyncResult and call "_finish()" later;
however, the "_finish()" function may be called at most once.

Example of a typical asynchronous operation flow:
|[&lt;!-- language="C" --&gt;
void _theoretical_frobnitz_async (Theoretical         *t,
                                  GCancellable        *c,
                                  GAsyncReadyCallback  cb,
                                  gpointer             u);

gboolean _theoretical_frobnitz_finish (Theoretical   *t,
                                       GAsyncResult  *res,
                                       GError       **e);

static void
frobnitz_result_func (GObject      *source_object,
		 GAsyncResult *res,
		 gpointer      user_data)
{
  gboolean success = FALSE;

  success = _theoretical_frobnitz_finish (source_object, res, NULL);

  if (success)
    g_printf ("Hurray!\n");
  else
    g_printf ("Uh oh!\n");

  ...

}

int main (int argc, void *argv[])
{
   ...

   _theoretical_frobnitz_async (theoretical_data,
                                NULL,
                                frobnitz_result_func,
                                NULL);

   ...
}
]|

The callback for an asynchronous operation is called only once, and is
always called, even in the case of a cancelled operation. On cancellation
the result is a %G_IO_ERROR_CANCELLED error.

## I/O Priority # {#io-priority}

Many I/O-related asynchronous operations have a priority parameter,
which is used in certain cases to determine the order in which
operations are executed. They are not used to determine system-wide
I/O scheduling. Priorities are integers, with lower numbers indicating
higher priority. It is recommended to choose priorities between
%G_PRIORITY_LOW and %G_PRIORITY_HIGH, with %G_PRIORITY_DEFAULT
as a default.</doc>
      <source-position filename="gasyncresult.h" line="66" />
      <virtual-method name="get_source_object" invoker="get_source_object" gs:dll-name="gio-2.0" gs:managed-name="DoGetSourceObject">
        <doc xml:space="preserve" filename="gio-2.0.c" line="12833">Gets the source object from a #GAsyncResult.</doc>
        <source-position filename="gasyncresult.h" line="62" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="12839">a new reference to the source
   object for the @res, or %NULL if there is none.</doc>
          <type name="GObject.Object" c:type="GObject*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12835">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </virtual-method>
      <virtual-method name="get_user_data" invoker="get_user_data" gs:dll-name="gio-2.0" gs:managed-name="DoGetUserData">
        <doc xml:space="preserve" filename="gio-2.0.c" line="12844">Gets the user data from a #GAsyncResult.</doc>
        <source-position filename="gasyncresult.h" line="61" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="12850">the user data for @res.</doc>
          <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12846">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </virtual-method>
      <virtual-method name="is_tagged" invoker="is_tagged" version="2.34" gs:dll-name="gio-2.0" gs:managed-name="DoIsTagged">
        <doc xml:space="preserve" filename="gio-2.0.c" line="12854">Checks if @res has the given @source_tag (generally a function
pointer indicating the function @res was created by).</doc>
        <source-position filename="gasyncresult.h" line="64" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="12862">%TRUE if @res has the indicated @source_tag, %FALSE if
  not.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12856">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="source_tag" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="sourceTag" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12857">an application-defined tag</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="source_tag" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="sourceTag" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12857">an application-defined tag</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <method name="get_source_object" c:identifier="g_async_result_get_source_object" gs:dll-name="gio-2.0" gs:managed-name="GetSourceObject" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="12833">Gets the source object from a #GAsyncResult.</doc>
        <source-position filename="gasyncresult.h" line="74" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="12839">a new reference to the source
   object for the @res, or %NULL if there is none.</doc>
          <type name="GObject.Object" c:type="GObject*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12835">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12835">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_user_data" c:identifier="g_async_result_get_user_data" gs:dll-name="gio-2.0" gs:managed-name="GetUserData" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="12844">Gets the user data from a #GAsyncResult.</doc>
        <source-position filename="gasyncresult.h" line="72" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="12850">the user data for @res.</doc>
          <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12846">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12846">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="is_tagged" c:identifier="g_async_result_is_tagged" version="2.34" gs:dll-name="gio-2.0" gs:managed-name="IsTagged" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="12854">Checks if @res has the given @source_tag (generally a function
pointer indicating the function @res was created by).</doc>
        <source-position filename="gasyncresult.h" line="80" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="12862">%TRUE if @res has the indicated @source_tag, %FALSE if
  not.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12856">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="source_tag" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="sourceTag" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12857">an application-defined tag</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12856">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="source_tag" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="sourceTag" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12857">an application-defined tag</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_async_result_get_type" gs:access-modifiers="private" gs:dll-name="gio-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </interface>
    <record name="AsyncResultIface" c:type="GAsyncResultIface" glib:is-gtype-struct-for="AsyncResult" gs:managed-name="AsyncResultIface">
      <doc xml:space="preserve" filename="gasyncresult.h" line="46">Interface definition for #GAsyncResult.</doc>
      <source-position filename="gasyncresult.h" line="66" />
      <field name="g_iface" gs:managed-name="GIface">
        <doc xml:space="preserve" filename="gasyncresult.h" line="48">The parent interface.</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface" />
      </field>
      <field name="get_user_data" gs:managed-name="GetUserData">
        <callback name="get_user_data" gs:dll-name="gio-2.0" gs:managed-name="GetUserData">
          <source-position filename="gasyncresult.h" line="61" />
          <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12850">the user data for @res.</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="12846">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="12846">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="get_source_object" gs:managed-name="GetSourceObject">
        <callback name="get_source_object" gs:dll-name="gio-2.0" gs:managed-name="GetSourceObject">
          <source-position filename="gasyncresult.h" line="62" />
          <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12839">a new reference to the source
   object for the @res, or %NULL if there is none.</doc>
            <type name="GObject.Object" c:type="GObject*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="12835">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="12835">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="is_tagged" gs:managed-name="IsTagged">
        <callback name="is_tagged" gs:dll-name="gio-2.0" gs:managed-name="IsTagged">
          <source-position filename="gasyncresult.h" line="64" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="12862">%TRUE if @res has the indicated @source_tag, %FALSE if
  not.</doc>
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="12856">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
            <parameter name="source_tag" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="sourceTag" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="12857">an application-defined tag</doc>
              <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="12856">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
            <parameter name="source_tag" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="sourceTag" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="12857">an application-defined tag</doc>
              <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
    </record>
    <class name="Cancellable" c:symbol-prefix="cancellable" c:type="GCancellable" parent="GObject.Object" glib:type-name="GCancellable" glib:get-type="g_cancellable_get_type" glib:type-struct="CancellableClass" gs:managed-name="Cancellable">
      <doc xml:space="preserve" filename="gio-2.0.c" line="5278">GCancellable is a thread-safe operation cancellation stack used
throughout GIO to allow for cancellation of synchronous and
asynchronous operations.</doc>
      <source-position filename="gcancellable.h" line="68" />
      <constructor name="new" c:identifier="g_cancellable_new" gs:dll-name="gio-2.0" gs:managed-name="New">
        <doc xml:space="preserve" filename="gio-2.0.c" line="13640">Creates a new #GCancellable object.

Applications that want to start one or more operations
that should be cancellable should create a #GCancellable
and pass it to the operations.

One #GCancellable can be used in multiple consecutive
operations or in multiple concurrent operations.</doc>
        <source-position filename="gcancellable.h" line="74" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="13652">a #GCancellable.</doc>
          <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </constructor>
      <gs:managed-property name="get_current" gs:dll-name="gio-2.0" gs:managed-name="Current">
        <doc xml:space="preserve" filename="gio-2.0.c" line="13566">Gets the top cancellable from the stack.</doc>
        <source-position filename="gcancellable.h" line="95" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="13571">a #GCancellable from the top
of the stack, or %NULL if the stack is empty.</doc>
          <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </gs:managed-property>
      <function name="get_current" c:identifier="g_cancellable_get_current" gs:dll-name="gio-2.0" gs:managed-name="GetCurrent" gs:property-getter-for="Current" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="13566">Gets the top cancellable from the stack.</doc>
        <source-position filename="gcancellable.h" line="95" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="13571">a #GCancellable from the top
of the stack, or %NULL if the stack is empty.</doc>
          <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
      <virtual-method name="cancelled" gs:dll-name="gio-2.0" gs:managed-name="DoCancelled">
        <source-position filename="gcancellable.h" line="59" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in">
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </virtual-method>
      <method name="cancel" c:identifier="g_cancellable_cancel" gs:dll-name="gio-2.0" gs:managed-name="Cancel">
        <doc xml:space="preserve" filename="gio-2.0.c" line="13487">Will set @cancellable to cancelled, and will emit the
#GCancellable::cancelled signal. (However, see the warning about
race conditions in the documentation for that signal if you are
planning to connect to it.)

This function is thread-safe. In other words, you can safely call
it from a thread other than the one running the operation that was
passed the @cancellable.

If @cancellable is %NULL, this function returns immediately for convenience.

The convention within GIO is that cancelling an asynchronous
operation causes it to complete asynchronously. That is, if you
cancel the operation from the same thread in which it is running,
then the operation's #GAsyncReadyCallback will not be invoked until
the application returns to the main loop.</doc>
        <source-position filename="gcancellable.h" line="114" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="13489">a #GCancellable object.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="connect" c:identifier="g_cancellable_connect" version="2.22" gs:dll-name="gio-2.0" gs:managed-name="Connect">
        <doc xml:space="preserve" filename="gio-2.0.c" line="13510">Convenience function to connect to the #GCancellable::cancelled
signal. Also handles the race condition that may happen
if the cancellable is cancelled right before connecting.

@callback is called at most once, either directly at the
time of the connect if @cancellable is already cancelled,
or when @cancellable is cancelled in some thread.

@data_destroy_func will be called when the handler is
disconnected, or immediately if the cancellable is already
cancelled.

See #GCancellable::cancelled for details on how to use this.

Since GLib 2.40, the lock protecting @cancellable is not held when
@callback is invoked.  This lifts a restriction in place for
earlier GLib versions which now makes it easier to write cleanup
code that unconditionally invokes e.g. g_cancellable_cancel().</doc>
        <source-position filename="gcancellable.h" line="103" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="13536">The id of the signal handler or 0 if @cancellable has already
         been cancelled.</doc>
          <type name="gulong" c:type="gulong" />
        </return-value>
        <parameters>
          <instance-parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="13512">A #GCancellable.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="callback" transfer-ownership="none" scope="notified" closure="1" destroy="2" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="13513">The #GCallback to connect.</doc>
            <type name="CancellableSourceFunc" c:type="GCallback" />
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="13514">Data to pass to @callback.</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="data_destroy_func" transfer-ownership="none" nullable="1" allow-none="1" scope="async" gs:managed-name="dataDestroyFunc" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="13515">Free function for @data or %NULL.</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="callback" transfer-ownership="none" scope="notified" closure="1" destroy="2" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="13513">The #GCallback to connect.</doc>
            <type name="CancellableSourceFunc" c:type="GCallback" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="disconnect" c:identifier="g_cancellable_disconnect" version="2.22" gs:dll-name="gio-2.0" gs:managed-name="Disconnect">
        <doc xml:space="preserve" filename="gio-2.0.c" line="13542">Disconnects a handler from a cancellable instance similar to
g_signal_handler_disconnect().  Additionally, in the event that a
signal handler is currently running, this call will block until the
handler has finished.  Calling this function from a
#GCancellable::cancelled signal handler will therefore result in a
deadlock.

This avoids a race condition where a thread cancels at the
same time as the cancellable operation is finished and the
signal handler is removed. See #GCancellable::cancelled for
details on how to use this.

If @cancellable is %NULL or @handler_id is `0` this function does
nothing.</doc>
        <source-position filename="gcancellable.h" line="108" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="13544">A #GCancellable or %NULL.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="handler_id" transfer-ownership="none" gs:managed-name="handlerId" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="13545">Handler id of the handler to be disconnected, or `0`.</doc>
            <type name="gulong" c:type="gulong" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="handler_id" transfer-ownership="none" gs:managed-name="handlerId" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="13545">Handler id of the handler to be disconnected, or `0`.</doc>
            <type name="gulong" c:type="gulong" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <gs:managed-property name="get_fd" gs:dll-name="gio-2.0" gs:managed-name="Fd">
        <doc xml:space="preserve" filename="gio-2.0.c" line="13576">Gets the file descriptor for a cancellable job. This can be used to
implement cancellable operations on Unix systems. The returned fd will
turn readable when @cancellable is cancelled.

You are not supposed to read from the fd yourself, just check for
readable status. Reading to unset the readable status is done
with g_cancellable_reset().

After a successful return from this function, you should use
g_cancellable_release_fd() to free up resources allocated for
the returned file descriptor.

See also g_cancellable_make_pollfd().</doc>
        <source-position filename="gcancellable.h" line="84" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="13594">A valid file descriptor. `-1` if the file descriptor
is not supported, or on errors.</doc>
          <type name="gint" c:type="int" />
        </return-value>
        <parameters>
          <instance-parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="13578">a #GCancellable.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_fd" c:identifier="g_cancellable_get_fd" gs:dll-name="gio-2.0" gs:managed-name="GetFd" gs:property-getter-for="Fd" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="13576">Gets the file descriptor for a cancellable job. This can be used to
implement cancellable operations on Unix systems. The returned fd will
turn readable when @cancellable is cancelled.

You are not supposed to read from the fd yourself, just check for
readable status. Reading to unset the readable status is done
with g_cancellable_reset().

After a successful return from this function, you should use
g_cancellable_release_fd() to free up resources allocated for
the returned file descriptor.

See also g_cancellable_make_pollfd().</doc>
        <source-position filename="gcancellable.h" line="84" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="13594">A valid file descriptor. `-1` if the file descriptor
is not supported, or on errors.</doc>
          <type name="gint" c:type="int" />
        </return-value>
        <parameters>
          <instance-parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="13578">a #GCancellable.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="is_cancelled" gs:dll-name="gio-2.0" gs:managed-name="IsCancelled">
        <doc xml:space="preserve" filename="gio-2.0.c" line="13599">Checks if a cancellable job has been cancelled.</doc>
        <source-position filename="gcancellable.h" line="78" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="13605">%TRUE if @cancellable is cancelled,
FALSE if called with %NULL or if item is not cancelled.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="13601">a #GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="is_cancelled" c:identifier="g_cancellable_is_cancelled" gs:dll-name="gio-2.0" gs:managed-name="GetIsCancelled" gs:property-getter-for="IsCancelled" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="13599">Checks if a cancellable job has been cancelled.</doc>
        <source-position filename="gcancellable.h" line="78" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="13605">%TRUE if @cancellable is cancelled,
FALSE if called with %NULL or if item is not cancelled.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="13601">a #GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="make_pollfd" c:identifier="g_cancellable_make_pollfd" version="2.22" gs:dll-name="gio-2.0" gs:managed-name="TryMakePollfd">
        <doc xml:space="preserve" filename="gio-2.0.c" line="13610">Creates a #GPollFD corresponding to @cancellable; this can be passed
to g_poll() and used to poll for cancellation. This is useful both
for unix systems without a native poll and for portability to
windows.

When this function returns %TRUE, you should use
g_cancellable_release_fd() to free up resources allocated for the
@pollfd. After a %FALSE return, do not call g_cancellable_release_fd().

If this function returns %FALSE, either no @cancellable was given or
resource limits prevent this function from allocating the necessary
structures for polling. (On Linux, you will likely have reached
the maximum number of file descriptors.) The suggested way to handle
these cases is to ignore the @cancellable.

You are not supposed to read from the fd yourself, just check for
readable status. Reading to unset the readable status is done
with g_cancellable_reset().</doc>
        <source-position filename="gcancellable.h" line="86" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="13634">%TRUE if @pollfd was successfully initialized, %FALSE on
         failure to prepare the cancellable.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="13612">a #GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="pollfd" transfer-ownership="none" direction="out" gs:managed-name="pollfd">
            <doc xml:space="preserve" filename="gio-2.0.c" line="13613">a pointer to a #GPollFD</doc>
            <type name="GLib.PollFD" c:type="GPollFD*" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="pollfd" transfer-ownership="none" direction="out" gs:managed-name="pollfd">
            <doc xml:space="preserve" filename="gio-2.0.c" line="13613">a pointer to a #GPollFD</doc>
            <type name="GLib.PollFD" c:type="GPollFD*" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="pop_current" c:identifier="g_cancellable_pop_current" gs:dll-name="gio-2.0" gs:managed-name="PopCurrent">
        <doc xml:space="preserve" filename="gio-2.0.c" line="13656">Pops @cancellable off the cancellable stack (verifying that @cancellable
is on the top of the stack).</doc>
        <source-position filename="gcancellable.h" line="99" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="13658">a #GCancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="push_current" c:identifier="g_cancellable_push_current" gs:dll-name="gio-2.0" gs:managed-name="PushCurrent">
        <doc xml:space="preserve" filename="gio-2.0.c" line="13665">Pushes @cancellable onto the cancellable stack. The current
cancellable can then be received using g_cancellable_get_current().

This is useful when implementing cancellable operations in
code that does not allow you to pass down the cancellable object.

This is typically called automatically by e.g. #GFile operations,
so you rarely have to call this yourself.</doc>
        <source-position filename="gcancellable.h" line="97" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="13667">a #GCancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="release_fd" c:identifier="g_cancellable_release_fd" version="2.22" gs:dll-name="gio-2.0" gs:managed-name="ReleaseFd">
        <doc xml:space="preserve" filename="gio-2.0.c" line="13680">Releases a resources previously allocated by g_cancellable_get_fd()
or g_cancellable_make_pollfd().

For compatibility reasons with older releases, calling this function
is not strictly required, the resources will be automatically freed
when the @cancellable is finalized. However, the @cancellable will
block scarce file descriptors until it is finalized if this function
is not called. This can cause the application to run out of file
descriptors when many #GCancellables are used at the same time.</doc>
        <source-position filename="gcancellable.h" line="89" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="13682">a #GCancellable</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="reset" c:identifier="g_cancellable_reset" gs:dll-name="gio-2.0" gs:managed-name="Reset">
        <doc xml:space="preserve" filename="gio-2.0.c" line="13698">Resets @cancellable to its uncancelled state.

If cancellable is currently in use by any cancellable operation
then the behavior of this function is undefined.

Note that it is generally not a good idea to reuse an existing
cancellable for more operations after it has been cancelled once,
as this function might tempt you to do. The recommended practice
is to drop the reference to a cancellable after cancelling it,
and let it die with the outstanding async operations. You should
create a fresh cancellable for further async operations.</doc>
        <source-position filename="gcancellable.h" line="101" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="13700">a #GCancellable object.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="throw_if_cancelled" c:identifier="g_cancellable_set_error_if_cancelled" throws="1" gs:dll-name="gio-2.0" gs:managed-name="ThrowIfCancelled">
        <doc xml:space="preserve" filename="gio-2.0.c" line="13716">If the @cancellable is cancelled, sets the error to notify
that the operation was cancelled.</doc>
        <source-position filename="gcancellable.h" line="80" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="13724">%TRUE if @cancellable was cancelled, %FALSE if it was not</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="13718">a #GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </instance-parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <field name="parent_instance" gs:managed-name="ParentInstance">
        <type name="GObject.Object" c:type="GObject" />
      </field>
      <field name="priv" readable="0" private="1" gs:managed-name="Priv">
        <type name="CancellablePrivate" c:type="GCancellablePrivate*" gs:is-pointer="1" />
      </field>
      <glib:signal name="cancelled" when="last" gs:dll-name="gio-2.0" gs:managed-name="CancelledSignal">
        <doc xml:space="preserve" filename="gio-2.0.c" line="484">Emitted when the operation has been cancelled.

Can be used by implementations of cancellable operations. If the
operation is cancelled from another thread, the signal will be
emitted in the thread that cancelled the operation, not the
thread that is running the operation.

Note that disconnecting from this signal (or any signal) in a
multi-threaded program is prone to race conditions. For instance
it is possible that a signal handler may be invoked even after
a call to g_signal_handler_disconnect() for that handler has
already returned.

There is also a problem when cancellation happens right before
connecting to the signal. If this happens the signal will
unexpectedly not be emitted, and checking before connecting to
the signal leaves a race condition where this is still happening.

In order to make it safe and easy to connect handlers there
are two helper functions: g_cancellable_connect() and
g_cancellable_disconnect() which protect against problems
like this.

An example of how to us this:
|[&lt;!-- language="C" --&gt;
    // Make sure we don't do unnecessary work if already cancelled
    if (g_cancellable_set_error_if_cancelled (cancellable, error))
      return;

    // Set up all the data needed to be able to handle cancellation
    // of the operation
    my_data = my_data_new (...);

    id = 0;
    if (cancellable)
      id = g_cancellable_connect (cancellable,
    			      G_CALLBACK (cancelled_handler)
    			      data, NULL);

    // cancellable operation here...

    g_cancellable_disconnect (cancellable, id);

    // cancelled_handler is never called after this, it is now safe
    // to free the data
    my_data_free (my_data);
]|

Note that the cancelled signal is emitted in the thread that
the user cancelled from, which may be the main thread. So, the
cancellable signal should not do something that can block.</doc>
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="cancellable" transfer-ownership="none" gs:managed-name="cancellable" direction="in">
            <doc>the instance on which the signal was invoked</doc>
            <type name="Cancellable" c:name="gpointer" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="user_data" transfer-ownership="none" closure="0" gs:managed-name="userData" direction="in">
            <type name="gpointer" c:name="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="cancellable" transfer-ownership="none" gs:managed-name="cancellable" direction="in">
            <doc>the instance on which the signal was invoked</doc>
            <type name="Cancellable" c:name="gpointer" gs:is-pointer="1" />
          </instance-parameter>
        </gs:managed-parameters>
      </glib:signal>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_cancellable_get_type" gs:access-modifiers="private" gs:dll-name="gio-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </class>
    <record name="CancellableClass" c:type="GCancellableClass" glib:is-gtype-struct-for="Cancellable" gs:managed-name="CancellableClass">
      <source-position filename="gcancellable.h" line="68" />
      <field name="parent_class" gs:managed-name="ParentClass">
        <type name="GObject.ObjectClass" c:type="GObjectClass" />
      </field>
      <field name="cancelled" gs:managed-name="Cancelled">
        <callback name="cancelled" gs:dll-name="gio-2.0" gs:managed-name="Cancelled">
          <source-position filename="gcancellable.h" line="59" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="_g_reserved1" introspectable="1" gs:managed-name="GReserved1">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="_g_reserved2" introspectable="1" gs:managed-name="GReserved2">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="_g_reserved3" introspectable="1" gs:managed-name="GReserved3">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="_g_reserved4" introspectable="1" gs:managed-name="GReserved4">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="_g_reserved5" introspectable="1" gs:managed-name="GReserved5">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
    </record>
    <callback name="CancellableSourceFunc" c:type="GCancellableSourceFunc" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="CancellableSourceFunc">
      <doc xml:space="preserve" filename="giotypes.h" line="567">This is the function type of the callback used for the #GSource
returned by g_cancellable_source_new().</doc>
      <source-position filename="giotypes.h" line="579" />
      <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
        <doc xml:space="preserve" filename="giotypes.h" line="575">it should return %FALSE if the source should be removed.</doc>
        <type name="gboolean" c:type="gboolean" />
      </return-value>
      <parameters>
        <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
          <doc xml:space="preserve" filename="giotypes.h" line="569">the #GCancellable</doc>
          <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="1" gs:managed-name="userData" direction="in">
          <doc xml:space="preserve" filename="giotypes.h" line="570">data passed in by the user.</doc>
          <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
        </parameter>
      </parameters>
      <gs:managed-parameters>
        <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
          <doc xml:space="preserve" filename="giotypes.h" line="569">the #GCancellable</doc>
          <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
        </parameter>
      </gs:managed-parameters>
    </callback>
    <interface name="File" c:symbol-prefix="file" c:type="GFile" glib:type-name="GFile" glib:get-type="g_file_get_type" glib:type-struct="FileIface" gs:managed-name="IFile">
      <doc xml:space="preserve" filename="gio-2.0.c" line="6196">#GFile is a high level abstraction for manipulating files on a
virtual file system. #GFiles are lightweight, immutable objects
that do no I/O upon creation. It is necessary to understand that
#GFile objects do not represent files, merely an identifier for a
file. All file content I/O is implemented as streaming operations
(see #GInputStream and #GOutputStream).

To construct a #GFile, you can use:
- g_file_new_for_path() if you have a path.
- g_file_new_for_uri() if you have a URI.
- g_file_new_for_commandline_arg() for a command line argument.
- g_file_new_tmp() to create a temporary file from a template.
- g_file_parse_name() from a UTF-8 string gotten from g_file_get_parse_name().
- g_file_new_build_filename() to create a file from path elements.

One way to think of a #GFile is as an abstraction of a pathname. For
normal files the system pathname is what is stored internally, but as
#GFiles are extensible it could also be something else that corresponds
to a pathname in a userspace implementation of a filesystem.

#GFiles make up hierarchies of directories and files that correspond to
the files on a filesystem. You can move through the file system with
#GFile using g_file_get_parent() to get an identifier for the parent
directory, g_file_get_child() to get a child within a directory,
g_file_resolve_relative_path() to resolve a relative path between two
#GFiles. There can be multiple hierarchies, so you may not end up at
the same root if you repeatedly call g_file_get_parent() on two different
files.

All #GFiles have a basename (get with g_file_get_basename()). These names
are byte strings that are used to identify the file on the filesystem
(relative to its parent directory) and there is no guarantees that they
have any particular charset encoding or even make any sense at all. If
you want to use filenames in a user interface you should use the display
name that you can get by requesting the
%G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME attribute with g_file_query_info().
This is guaranteed to be in UTF-8 and can be used in a user interface.
But always store the real basename or the #GFile to use to actually
access the file, because there is no way to go from a display name to
the actual name.

Using #GFile as an identifier has the same weaknesses as using a path
in that there may be multiple aliases for the same file. For instance,
hard or soft links may cause two different #GFiles to refer to the same
file. Other possible causes for aliases are: case insensitive filesystems,
short and long names on FAT/NTFS, or bind mounts in Linux. If you want to
check if two #GFiles point to the same file you can query for the
%G_FILE_ATTRIBUTE_ID_FILE attribute. Note that #GFile does some trivial
canonicalization of pathnames passed in, so that trivial differences in
the path string used at creation (duplicated slashes, slash at end of
path, "." or ".." path segments, etc) does not create different #GFiles.

Many #GFile operations have both synchronous and asynchronous versions
to suit your application. Asynchronous versions of synchronous functions
simply have _async() appended to their function names. The asynchronous
I/O functions call a #GAsyncReadyCallback which is then used to finalize
the operation, producing a GAsyncResult which is then passed to the
function's matching _finish() operation.

It is highly recommended to use asynchronous calls when running within a
shared main loop, such as in the main thread of an application. This avoids
I/O operations blocking other sources on the main loop from being dispatched.
Synchronous I/O operations should be performed from worker threads. See the
[introduction to asynchronous programming section][async-programming] for
more.

Some #GFile operations almost always take a noticeable amount of time, and
so do not have synchronous analogs. Notable cases include:
- g_file_mount_mountable() to mount a mountable file.
- g_file_unmount_mountable_with_operation() to unmount a mountable file.
- g_file_eject_mountable_with_operation() to eject a mountable file.

## Entity Tags # {#gfile-etag}

One notable feature of #GFiles are entity tags, or "etags" for
short. Entity tags are somewhat like a more abstract version of the
traditional mtime, and can be used to quickly determine if the file
has been modified from the version on the file system. See the
HTTP 1.1
[specification](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html)
for HTTP Etag headers, which are a very similar concept.</doc>
      <source-position filename="gfile.h" line="592" />
      <function name="new_for_commandline_arg" c:identifier="g_file_new_for_commandline_arg" gs:dll-name="gio-2.0" gs:managed-name="NewForCommandlineArg">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24053">Creates a #GFile with the given argument from the command line.
The value of @arg can be either a URI, an absolute path or a
relative path resolved relative to the current working directory.
This operation never fails, but the returned object might not
support any I/O operation if @arg points to a malformed path.

Note that on Windows, this function expects its argument to be in
UTF-8 -- not the system code page.  This means that you
should not use this function with string from argv as it is passed
to main().  g_win32_get_command_line() will return a UTF-8 version of
the commandline.  #GApplication also uses UTF-8 but
g_application_command_line_create_file_for_arg() may be more useful
for you there.  It is also always possible to use this function with
#GOptionContext arguments of type %G_OPTION_ARG_FILENAME.</doc>
        <source-position filename="gfile.h" line="602" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="24072">a new #GFile.
   Free the returned object with g_object_unref().</doc>
          <type name="File" c:type="GFile*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="arg" transfer-ownership="none" gs:managed-name="arg" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24055">a command line string</doc>
            <type name="filename" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="arg" transfer-ownership="none" gs:managed-name="arg" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24055">a command line string</doc>
            <type name="filename" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="new_for_commandline_arg_and_cwd" c:identifier="g_file_new_for_commandline_arg_and_cwd" version="2.36" gs:dll-name="gio-2.0" gs:managed-name="NewForCommandlineArgAndCwd">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24077">Creates a #GFile with the given argument from the command line.

This function is similar to g_file_new_for_commandline_arg() except
that it allows for passing the current working directory as an
argument instead of using the current working directory of the
process.

This is useful if the commandline argument was given in a context
other than the invocation of the current process.

See also g_application_command_line_create_file_for_arg().</doc>
        <source-position filename="gfile.h" line="604" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="24094">a new #GFile</doc>
          <type name="File" c:type="GFile*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="arg" transfer-ownership="none" gs:managed-name="arg" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24079">a command line string</doc>
            <type name="filename" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="cwd" transfer-ownership="none" gs:managed-name="cwd" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24080">the current working directory of the commandline</doc>
            <type name="filename" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="arg" transfer-ownership="none" gs:managed-name="arg" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24079">a command line string</doc>
            <type name="filename" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="cwd" transfer-ownership="none" gs:managed-name="cwd" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24080">the current working directory of the commandline</doc>
            <type name="filename" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="new_for_path" c:identifier="g_file_new_for_path" gs:dll-name="gio-2.0" gs:managed-name="NewForPath">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24099">Constructs a #GFile for a given path. This operation never
fails, but the returned object might not support any I/O
operation if @path is malformed.</doc>
        <source-position filename="gfile.h" line="598" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="24108">a new #GFile for the given @path.
  Free the returned object with g_object_unref().</doc>
          <type name="File" c:type="GFile*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="path" transfer-ownership="none" gs:managed-name="path" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24101">a string containing a relative or absolute path.
    The string must be encoded in the glib filename encoding.</doc>
            <type name="filename" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="path" transfer-ownership="none" gs:managed-name="path" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24101">a string containing a relative or absolute path.
    The string must be encoded in the glib filename encoding.</doc>
            <type name="filename" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="new_for_uri" c:identifier="g_file_new_for_uri" gs:dll-name="gio-2.0" gs:managed-name="NewForUri">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24113">Constructs a #GFile for a given URI. This operation never
fails, but the returned object might not support any I/O
operation if @uri is malformed or if the uri type is
not supported.</doc>
        <source-position filename="gfile.h" line="600" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="24122">a new #GFile for the given @uri.
    Free the returned object with g_object_unref().</doc>
          <type name="File" c:type="GFile*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="uri" transfer-ownership="none" gs:managed-name="uri" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24115">a UTF-8 string containing a URI</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="uri" transfer-ownership="none" gs:managed-name="uri" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24115">a UTF-8 string containing a URI</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="new_tmp" c:identifier="g_file_new_tmp" version="2.32" throws="1" gs:dll-name="gio-2.0" gs:managed-name="NewTmp">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24127">Opens a file in the preferred directory for temporary files (as
returned by g_get_tmp_dir()) and returns a #GFile and
#GFileIOStream pointing to it.

@tmpl should be a string in the GLib file name encoding
containing a sequence of six 'X' characters, and containing no
directory components. If it is %NULL, a default template is used.

Unlike the other #GFile constructors, this will return %NULL if
a temporary file could not be created.</doc>
        <source-position filename="gfile.h" line="607" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="24145">a new #GFile.
    Free the returned object with g_object_unref().</doc>
          <type name="File" c:type="GFile*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="tmpl" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="tmpl" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24129">Template for the file
  name, as in g_file_open_tmp(), or %NULL for a default template</doc>
            <type name="filename" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="iostream" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="iostream">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24131">on return, a #GFileIOStream for the created file</doc>
            <type name="FileIOStream" c:type="GFileIOStream**" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="tmpl" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="tmpl" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24129">Template for the file
  name, as in g_file_open_tmp(), or %NULL for a default template</doc>
            <type name="filename" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="iostream" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="iostream">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24131">on return, a #GFileIOStream for the created file</doc>
            <type name="FileIOStream" c:type="GFileIOStream**" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="parse_name" c:identifier="g_file_parse_name" gs:dll-name="gio-2.0" gs:managed-name="ParseName">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24290">Constructs a #GFile with the given @parse_name (i.e. something
given by g_file_get_parse_name()). This operation never fails,
but the returned object might not support any I/O operation if
the @parse_name cannot be parsed.</doc>
        <source-position filename="gfile.h" line="611" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="24299">a new #GFile.</doc>
          <type name="File" c:type="GFile*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="parse_name" transfer-ownership="none" gs:managed-name="parseName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24292">a file name or path to be parsed</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="parse_name" transfer-ownership="none" gs:managed-name="parseName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24292">a file name or path to be parsed</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <virtual-method name="append_to" invoker="append_to" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoAppendTo">
        <doc xml:space="preserve" filename="gio-2.0.c" line="21108">Gets an output stream for appending data to the file.
If the file doesn't already exist it is created.

By default files created are generally readable by everyone,
but if you pass #G_FILE_CREATE_PRIVATE in @flags the file
will be made readable only to the current user, to the level that
is supported on the target filesystem.

If @cancellable is not %NULL, then the operation can be cancelled
by triggering the cancellable object from another thread. If the
operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
returned.

Some file systems don't allow all file names, and may return an
%G_IO_ERROR_INVALID_FILENAME error. If the file is a directory the
%G_IO_ERROR_IS_DIRECTORY error will be returned. Other errors are
possible too, and depend on what kind of filesystem the file is on.</doc>
        <source-position filename="gfile.h" line="311" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="21134">a #GFileOutputStream, or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileOutputStream" c:type="GFileOutputStream*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21110">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21111">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21112">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21111">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21112">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="append_to_async" invoker="append_to_async" gs:dll-name="gio-2.0" gs:managed-name="DoAppendToAsync">
        <doc xml:space="preserve" filename="gio-2.0.c" line="21139">Asynchronously opens @file for appending.

For more details, see g_file_append_to() which is
the synchronous version of this call.

When the operation is finished, @callback will be called.
You can then call g_file_append_to_finish() to get the result
of the operation.</doc>
        <source-position filename="gfile.h" line="315" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21141">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21142">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21143">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21144">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21146">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21148">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21142">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21143">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21146">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21144">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="append_to_finish" invoker="append_to_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoAppendToFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="21161">Finishes an asynchronous file append operation started with
g_file_append_to_async().</doc>
        <source-position filename="gfile.h" line="321" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="21170">a valid #GFileOutputStream
    or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileOutputStream" c:type="GFileOutputStream*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21163">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21164">#GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21164">#GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="copy" invoker="copy" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoCopy">
        <doc xml:space="preserve" filename="gio-2.0.c" line="21415">Copies the file @source to the location specified by @destination.
Can not handle recursive copies of directories.

If the flag #G_FILE_COPY_OVERWRITE is specified an already
existing @destination file is overwritten.

If the flag #G_FILE_COPY_NOFOLLOW_SYMLINKS is specified then symlinks
will be copied as symlinks, otherwise the target of the
@source symlink will be copied.

If the flag #G_FILE_COPY_ALL_METADATA is specified then all the metadata
that is possible to copy is copied, not just the default subset (which,
for instance, does not include the owner, see #GFileInfo).

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.

If @progress_callback is not %NULL, then the operation can be monitored
by setting this to a #GFileProgressCallback function.
@progress_callback_data will be passed to this function. It is guaranteed
that this callback will be called after all data has been transferred with
the total number of bytes copied during the operation.

If the @source file does not exist, then the %G_IO_ERROR_NOT_FOUND error
is returned, independent on the status of the @destination.

If #G_FILE_COPY_OVERWRITE is not specified and the target exists, then
the error %G_IO_ERROR_EXISTS is returned.

If trying to overwrite a file over a directory, the %G_IO_ERROR_IS_DIRECTORY
error is returned. If trying to overwrite a directory with a directory the
%G_IO_ERROR_WOULD_MERGE error is returned.

If the source is a directory and the target does not exist, or
#G_FILE_COPY_OVERWRITE is specified and the target is a file, then the
%G_IO_ERROR_WOULD_RECURSE error is returned.

If you are interested in copying the #GFile object itself (not the on-disk
file), see g_file_dup().</doc>
        <source-position filename="gfile.h" line="400" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="21468">%TRUE on success, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21417">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="destination" transfer-ownership="none" gs:managed-name="destination" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21418">destination #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21419">set of #GFileCopyFlags</doc>
            <type name="FileCopyFlags" c:type="GFileCopyFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21420">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="progress_callback" transfer-ownership="none" nullable="1" allow-none="1" scope="call" closure="4" gs:managed-name="progressCallback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21422">function to callback with
    progress information, or %NULL if progress information is not needed</doc>
            <type name="FileProgressCallback" c:type="GFileProgressCallback" />
          </parameter>
          <parameter name="progress_callback_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="progressCallbackData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21424">user data to pass to @progress_callback</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="destination" transfer-ownership="none" gs:managed-name="destination" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21418">destination #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21419">set of #GFileCopyFlags</doc>
            <type name="FileCopyFlags" c:type="GFileCopyFlags" />
          </parameter>
          <parameter name="progress_callback" transfer-ownership="none" nullable="1" allow-none="1" scope="call" closure="4" gs:managed-name="progressCallback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21422">function to callback with
    progress information, or %NULL if progress information is not needed</doc>
            <type name="FileProgressCallback" c:type="GFileProgressCallback" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21420">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="copy_async" invoker="copy_async" gs:dll-name="gio-2.0" gs:managed-name="DoCopyAsync">
        <doc xml:space="preserve" filename="gio-2.0.c" line="21472">Copies the file @source to the location specified by @destination
asynchronously. For details of the behaviour, see g_file_copy().

If @progress_callback is not %NULL, then that function that will be called
just like in g_file_copy(). The callback will run in the default main context
of the thread calling g_file_copy_async() — the same context as @callback is
run in.

When the operation is finished, @callback will be called. You can then call
g_file_copy_finish() to get the result of the operation.</doc>
        <source-position filename="gfile.h" line="407" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21474">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="destination" transfer-ownership="none" gs:managed-name="destination" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21475">destination #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21476">set of #GFileCopyFlags</doc>
            <type name="FileCopyFlags" c:type="GFileCopyFlags" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21477">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21478">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="progress_callback" transfer-ownership="none" nullable="1" allow-none="1" scope="notified" closure="5" gs:managed-name="progressCallback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21480">function to callback with progress
    information, or %NULL if progress information is not needed</doc>
            <type name="FileProgressCallback" c:type="GFileProgressCallback" />
          </parameter>
          <parameter name="progress_callback_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4" gs:managed-name="progressCallbackData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21482">user data to pass to @progress_callback</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="7" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21483">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="6" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21484">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="destination" transfer-ownership="none" gs:managed-name="destination" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21475">destination #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21476">set of #GFileCopyFlags</doc>
            <type name="FileCopyFlags" c:type="GFileCopyFlags" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21477">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="progress_callback" transfer-ownership="none" nullable="1" allow-none="1" scope="notified" closure="5" gs:managed-name="progressCallback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21480">function to callback with progress
    information, or %NULL if progress information is not needed</doc>
            <type name="FileProgressCallback" c:type="GFileProgressCallback" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="7" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21483">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21478">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="copy_finish" invoker="copy_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoCopyFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="21522">Finishes copying the file started with g_file_copy_async().</doc>
        <source-position filename="gfile.h" line="416" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="21530">a %TRUE on success, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21524">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21525">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21525">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="create" invoker="create" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoCreate">
        <doc xml:space="preserve" filename="gio-2.0.c" line="21534">Creates a new file and returns an output stream for writing to it.
The file must not already exist.

By default files created are generally readable by everyone,
but if you pass #G_FILE_CREATE_PRIVATE in @flags the file
will be made readable only to the current user, to the level
that is supported on the target filesystem.

If @cancellable is not %NULL, then the operation can be cancelled
by triggering the cancellable object from another thread. If the
operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
returned.

If a file or directory with this name already exists the
%G_IO_ERROR_EXISTS error will be returned. Some file systems don't
allow all file names, and may return an %G_IO_ERROR_INVALID_FILENAME
error, and if the name is to long %G_IO_ERROR_FILENAME_TOO_LONG will
be returned. Other errors are possible too, and depend on what kind
of filesystem the file is on.</doc>
        <source-position filename="gfile.h" line="325" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="21562">a #GFileOutputStream for the newly created
    file, or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileOutputStream" c:type="GFileOutputStream*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21536">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21537">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21538">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21537">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21538">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="create_async" invoker="create_async" gs:dll-name="gio-2.0" gs:managed-name="DoCreateAsync">
        <doc xml:space="preserve" filename="gio-2.0.c" line="21568">Asynchronously creates a new file and returns an output stream
for writing to it. The file must not already exist.

For more details, see g_file_create() which is
the synchronous version of this call.

When the operation is finished, @callback will be called.
You can then call g_file_create_finish() to get the result
of the operation.</doc>
        <source-position filename="gfile.h" line="329" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21570">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21571">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21572">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21573">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21575">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21577">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21571">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21572">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21575">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21573">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="create_finish" invoker="create_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoCreateFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="21591">Finishes an asynchronous file create operation started with
g_file_create_async().</doc>
        <source-position filename="gfile.h" line="335" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="21600">a #GFileOutputStream or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileOutputStream" c:type="GFileOutputStream*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21593">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21594">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21594">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="create_readwrite" invoker="create_readwrite" version="2.22" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoCreateReadwrite">
        <doc xml:space="preserve" filename="gio-2.0.c" line="21605">Creates a new file and returns a stream for reading and
writing to it. The file must not already exist.

By default files created are generally readable by everyone,
but if you pass #G_FILE_CREATE_PRIVATE in @flags the file
will be made readable only to the current user, to the level
that is supported on the target filesystem.

If @cancellable is not %NULL, then the operation can be cancelled
by triggering the cancellable object from another thread. If the
operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
returned.

If a file or directory with this name already exists, the
%G_IO_ERROR_EXISTS error will be returned. Some file systems don't
allow all file names, and may return an %G_IO_ERROR_INVALID_FILENAME
error, and if the name is too long, %G_IO_ERROR_FILENAME_TOO_LONG
will be returned. Other errors are possible too, and depend on what
kind of filesystem the file is on.

Note that in many non-local file cases read and write streams are
not supported, so make sure you really need to do read and write
streaming, rather than just opening for reading or writing.</doc>
        <source-position filename="gfile.h" line="488" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="21637">a #GFileIOStream for the newly created
    file, or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileIOStream" c:type="GFileIOStream*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21607">a #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21608">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21609">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21608">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21609">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="create_readwrite_async" invoker="create_readwrite_async" version="2.22" gs:dll-name="gio-2.0" gs:managed-name="DoCreateReadwriteAsync">
        <doc xml:space="preserve" filename="gio-2.0.c" line="21644">Asynchronously creates a new file and returns a stream
for reading and writing to it. The file must not already exist.

For more details, see g_file_create_readwrite() which is
the synchronous version of this call.

When the operation is finished, @callback will be called.
You can then call g_file_create_readwrite_finish() to get
the result of the operation.</doc>
        <source-position filename="gfile.h" line="492" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21646">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21647">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21648">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21649">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21651">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21653">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21647">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21648">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21651">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21649">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="create_readwrite_finish" invoker="create_readwrite_finish" version="2.22" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoCreateReadwriteFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="21669">Finishes an asynchronous file create operation started with
g_file_create_readwrite_async().</doc>
        <source-position filename="gfile.h" line="498" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="21678">a #GFileIOStream or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileIOStream" c:type="GFileIOStream*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21671">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21672">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21672">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="delete_file" invoker="delete" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoDeleteFile">
        <doc xml:space="preserve" filename="gio-2.0.c" line="21684">Deletes a file. If the @file is a directory, it will only be
deleted if it is empty. This has the same semantics as g_unlink().

If @file doesn’t exist, %G_IO_ERROR_NOT_FOUND will be returned. This allows
for deletion to be implemented avoiding
[time-of-check to time-of-use races](https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use):
|[
g_autoptr(GError) local_error = NULL;
if (!g_file_delete (my_file, my_cancellable, &amp;local_error) &amp;&amp;
    !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))
  {
    // deletion failed for some reason other than the file not existing:
    // so report the error
    g_warning ("Failed to delete %s: %s",
               g_file_peek_path (my_file), local_error-&gt;message);
  }
]|

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <source-position filename="gfile.h" line="357" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="21713">%TRUE if the file was deleted. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21686">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21687">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21687">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="delete_file_async" invoker="delete_async" version="2.34" gs:dll-name="gio-2.0" gs:managed-name="DoDeleteFileAsync">
        <doc xml:space="preserve" filename="gio-2.0.c" line="21717">Asynchronously delete a file. If the @file is a directory, it will
only be deleted if it is empty.  This has the same semantics as
g_unlink().</doc>
        <source-position filename="gfile.h" line="360" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21719">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21720">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21721">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21723">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21725">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21720">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21723">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21721">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="delete_file_finish" invoker="delete_finish" version="2.34" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoDeleteFileFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="21735">Finishes deleting a file started with g_file_delete_async().</doc>
        <source-position filename="gfile.h" line="365" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="21743">%TRUE if the file was deleted. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21737">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21738">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21738">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="dup" invoker="dup" gs:dll-name="gio-2.0" gs:managed-name="DoDup">
        <doc xml:space="preserve" filename="gio-2.0.c" line="21759">Duplicates a #GFile handle. This operation does not duplicate
the actual file or directory represented by the #GFile; see
g_file_copy() if attempting to copy a file.

g_file_dup() is useful when a second handle is needed to the same underlying
file, for use in a separate thread (#GFile is not thread-safe). For use
within the same thread, use g_object_ref() to increment the existing object’s
reference count.

This call does no blocking I/O.</doc>
        <source-position filename="gfile.h" line="168" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="21774">a new #GFile that is a duplicate
    of the given #GFile.</doc>
          <type name="File" c:type="GFile*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21761">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </virtual-method>
      <virtual-method name="eject_mountable_finish" invoker="eject_mountable_finish" deprecated="1" deprecated-version="2.22" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoEjectMountableFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="21802">Finishes an asynchronous eject operation started by
g_file_eject_mountable().</doc>
        <doc-deprecated xml:space="preserve">Use g_file_eject_mountable_with_operation_finish()
    instead.</doc-deprecated>
        <source-position filename="gfile.h" line="454" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="21811">%TRUE if the @file was ejected successfully.
    %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21804">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21805">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21805">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="eject_mountable_with_operation_finish" invoker="eject_mountable_with_operation_finish" version="2.22" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoEjectMountableWithOperationFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="21843">Finishes an asynchronous eject operation started by
g_file_eject_mountable_with_operation().</doc>
        <source-position filename="gfile.h" line="557" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="21852">%TRUE if the @file was ejected successfully.
    %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21845">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21846">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21846">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="enumerate_children_async" invoker="enumerate_children_async" gs:dll-name="gio-2.0" gs:managed-name="DoEnumerateChildrenAsync">
        <doc xml:space="preserve" filename="gio-2.0.c" line="21896">Asynchronously gets the requested information about the files
in a directory. The result is a #GFileEnumerator object that will
give out #GFileInfo objects for all the files in the directory.

For more details, see g_file_enumerate_children() which is
the synchronous version of this call.

When the operation is finished, @callback will be called. You can
then call g_file_enumerate_children_finish() to get the result of
the operation.</doc>
        <source-position filename="gfile.h" line="196" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21898">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21899">an attribute query string</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21900">a set of #GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21901">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21902">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21904">a #GAsyncReadyCallback to call when the
    request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21906">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21899">an attribute query string</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21900">a set of #GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21901">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21904">a #GAsyncReadyCallback to call when the
    request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21902">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="equal" invoker="equal" gs:dll-name="gio-2.0" gs:managed-name="DoEqual">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22175">Checks if the two given #GFiles refer to the same file.

Note that two #GFiles that differ can still refer to the same
file on the filesystem due to various forms of filename
aliasing.

This call does no blocking I/O.</doc>
        <source-position filename="gfile.h" line="170" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22188">%TRUE if @file1 and @file2 are equal.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file1" transfer-ownership="none" gs:managed-name="file1" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22177">the first #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="file2" transfer-ownership="none" gs:managed-name="file2" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22178">the second #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="file2" transfer-ownership="none" gs:managed-name="file2" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22178">the second #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="get_basename" invoker="get_basename" gs:dll-name="gio-2.0" gs:managed-name="DoGetBasename">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22250">Gets the base name (the last component of the path) for a given #GFile.

If called for the top level of a system (such as the filesystem root
or a uri like sftp://host/) it will return a single directory separator
(and on Windows, possibly a drive letter).

The base name is a byte string (not UTF-8). It has no defined encoding
or rules other than it may not contain zero bytes.  If you want to use
filenames in a user interface you should use the display name that you
can get by requesting the %G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME
attribute with g_file_query_info().

This call does no blocking I/O.</doc>
        <source-position filename="gfile.h" line="176" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22268">string containing the #GFile's
    base name, or %NULL if given #GFile is invalid. The returned string
    should be freed with g_free() when no longer needed.</doc>
          <type name="filename" c:type="char*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22252">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </virtual-method>
      <virtual-method name="get_child_for_display_name" invoker="get_child_for_display_name" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoGetChildForDisplayName">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22292">Gets the child of @file for a given @display_name (i.e. a UTF-8
version of the name). If this function fails, it returns %NULL
and @error will be set. This is very useful when constructing a
#GFile for a new file and the user entered the filename in the
user interface, for instance when you select a directory and
type a filename in the file selector.

This call does no blocking I/O.</doc>
        <source-position filename="gfile.h" line="187" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22307">a #GFile to the specified child, or
    %NULL if the display name couldn't be converted.
    Free the returned object with g_object_unref().</doc>
          <type name="File" c:type="GFile*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22294">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="display_name" transfer-ownership="none" gs:managed-name="displayName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22295">string to a possible child</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="display_name" transfer-ownership="none" gs:managed-name="displayName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22295">string to a possible child</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="get_parent" invoker="get_parent" gs:dll-name="gio-2.0" gs:managed-name="DoGetParent">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22313">Gets the parent directory for the @file.
If the @file represents the root directory of the
file system, then %NULL will be returned.

This call does no blocking I/O.</doc>
        <source-position filename="gfile.h" line="180" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22323">a #GFile structure to the
    parent of the given #GFile or %NULL if there is no parent. Free
    the returned object with g_object_unref().</doc>
          <type name="File" c:type="GFile*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22315">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </virtual-method>
      <virtual-method name="get_parse_name" invoker="get_parse_name" gs:dll-name="gio-2.0" gs:managed-name="DoGetParseName">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22329">Gets the parse name of the @file.
A parse name is a UTF-8 string that describes the
file such that one can get the #GFile back using
g_file_parse_name().

This is generally used to show the #GFile as a nice
full-pathname kind of string in a user interface,
like in a location entry.

For local files with names that can safely be converted
to UTF-8 the pathname is used, otherwise the IRI is used
(a form of URI that allows UTF-8 characters unescaped).

This call does no blocking I/O.</doc>
        <source-position filename="gfile.h" line="179" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22348">a string containing the #GFile's parse name.
    The returned string should be freed with g_free()
    when no longer needed.</doc>
          <type name="utf8" c:type="char*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22331">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </virtual-method>
      <virtual-method name="get_path" invoker="get_path" gs:dll-name="gio-2.0" gs:managed-name="DoGetPath">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22354">Gets the local pathname for #GFile, if one exists. If non-%NULL, this is
guaranteed to be an absolute, canonical path. It might contain symlinks.

This call does no blocking I/O.</doc>
        <source-position filename="gfile.h" line="177" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22363">string containing the #GFile's path,
    or %NULL if no such path exists. The returned string should be freed
    with g_free() when no longer needed.</doc>
          <type name="filename" c:type="char*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22356">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </virtual-method>
      <virtual-method name="get_relative_path" invoker="get_relative_path" gs:dll-name="gio-2.0" gs:managed-name="DoGetRelativePath">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22369">Gets the path for @descendant relative to @parent.

This call does no blocking I/O.</doc>
        <source-position filename="gfile.h" line="183" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22378">string with the relative path from
    @descendant to @parent, or %NULL if @descendant doesn't have @parent as
    prefix. The returned string should be freed with g_free() when
    no longer needed.</doc>
          <type name="filename" c:type="char*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="parent" transfer-ownership="none" gs:managed-name="parent" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22371">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="descendant" transfer-ownership="none" gs:managed-name="descendant" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22372">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="descendant" transfer-ownership="none" gs:managed-name="descendant" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22372">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="get_uri" invoker="get_uri" gs:dll-name="gio-2.0" gs:managed-name="DoGetUri">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22385">Gets the URI for the @file.

This call does no blocking I/O.</doc>
        <source-position filename="gfile.h" line="178" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22393">a string containing the #GFile's URI. If the #GFile was constructed
    with an invalid URI, an invalid URI is returned.
    The returned string should be freed with g_free()
    when no longer needed.</doc>
          <type name="utf8" c:type="char*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22387">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </virtual-method>
      <virtual-method name="get_uri_scheme" invoker="get_uri_scheme" gs:dll-name="gio-2.0" gs:managed-name="DoGetUriScheme">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22400">Gets the URI scheme for a #GFile.
RFC 3986 decodes the scheme as:
|[
URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
]|
Common schemes include "file", "http", "ftp", etc.

The scheme can be different from the one used to construct the #GFile,
in that it might be replaced with one that is logically equivalent to the #GFile.

This call does no blocking I/O.</doc>
        <source-position filename="gfile.h" line="175" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22416">a string containing the URI scheme for the given
    #GFile or %NULL if the #GFile was constructed with an invalid URI. The
    returned string should be freed with g_free() when no longer needed.</doc>
          <type name="utf8" c:type="char*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22402">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </virtual-method>
      <virtual-method name="has_uri_scheme" invoker="has_uri_scheme" gs:dll-name="gio-2.0" gs:managed-name="DoHasUriScheme">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22464">Checks to see if a #GFile has a given URI scheme.

This call does no blocking I/O.</doc>
        <source-position filename="gfile.h" line="173" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22473">%TRUE if #GFile's backend supports the
    given URI scheme, %FALSE if URI scheme is %NULL,
    not supported, or #GFile is invalid.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22466">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="uri_scheme" transfer-ownership="none" gs:managed-name="uriScheme" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22467">a string containing a URI scheme</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="uri_scheme" transfer-ownership="none" gs:managed-name="uriScheme" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22467">a string containing a URI scheme</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="hash" invoker="hash" gs:dll-name="gio-2.0" gs:managed-name="DoHash">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22479">Creates a hash value for a #GFile.

This call does no blocking I/O.</doc>
        <source-position filename="gfile.h" line="169" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22487">0 if @file is not a valid #GFile, otherwise an
    integer that can be used as hash value for the #GFile.
    This function is intended for easily hashing a #GFile to
    add to a #GHashTable or similar data structure.</doc>
          <type name="guint" c:type="guint" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22481">#gconstpointer to a #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </virtual-method>
      <virtual-method name="is_native" invoker="is_native" gs:dll-name="gio-2.0" gs:managed-name="DoIsNative">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23392">Checks to see if a file is native to the platform.

A native file is one expressed in the platform-native filename format,
e.g. "C:\Windows" or "/usr/bin/". This does not mean the file is local,
as it might be on a locally mounted remote filesystem.

On some systems non-native files may be available using the native
filesystem via a userspace filesystem (FUSE), in these cases this call
will return %FALSE, but g_file_get_path() will still return a native path.

This call does no blocking I/O.</doc>
        <source-position filename="gfile.h" line="172" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="23408">%TRUE if @file is native</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23394">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </virtual-method>
      <virtual-method name="make_directory" invoker="make_directory" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoMakeDirectory">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23600">Creates a directory. Note that this will only create a child directory
of the immediate parent directory of the path or URI given by the #GFile.
To recursively create directories, see g_file_make_directory_with_parents().
This function will fail if the parent directory does not exist, setting
@error to %G_IO_ERROR_NOT_FOUND. If the file system doesn't support
creating directories, this function will fail, setting @error to
%G_IO_ERROR_NOT_SUPPORTED.

For a local #GFile the newly created directory will have the default
(current) ownership and permissions of the current process.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <source-position filename="gfile.h" line="381" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="23622">%TRUE on successful creation, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23602">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23603">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23603">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="make_directory_async" invoker="make_directory_async" version="2.38" gs:dll-name="gio-2.0" gs:managed-name="DoMakeDirectoryAsync">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23626">Asynchronously creates a directory.</doc>
        <source-position filename="gfile.h" line="384" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23628">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23629">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23630">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23632">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23634">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23629">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23632">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23630">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="make_directory_finish" invoker="make_directory_finish" version="2.38" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoMakeDirectoryFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23642">Finishes an asynchronous directory creation, started with
g_file_make_directory_async().</doc>
        <source-position filename="gfile.h" line="389" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="23651">%TRUE on successful directory creation, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23644">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23645">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23645">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="make_symbolic_link" invoker="make_symbolic_link" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoMakeSymbolicLink">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23683">Creates a symbolic link named @file which contains the string
@symlink_value.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <source-position filename="gfile.h" line="393" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="23699">%TRUE on the creation of a new symlink, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23685">a #GFile with the name of the symlink to create</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="symlink_value" transfer-ownership="none" gs:managed-name="symlinkValue" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23686">a string with the path for the target
    of the new symlink</doc>
            <type name="filename" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23688">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="symlink_value" transfer-ownership="none" gs:managed-name="symlinkValue" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23686">a string with the path for the target
    of the new symlink</doc>
            <type name="filename" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23688">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="measure_disk_usage_finish" invoker="measure_disk_usage_finish" version="2.38" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoMeasureDiskUsageFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23760">Collects the results from an earlier call to
g_file_measure_disk_usage_async().  See g_file_measure_disk_usage() for
more information.</doc>
        <source-position filename="gfile.h" line="586" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="23773">%TRUE if successful, with the out parameters set.
         %FALSE otherwise, with @error set.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23762">a #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23763">the #GAsyncResult passed to your #GAsyncReadyCallback</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <parameter name="disk_usage" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="diskUsage">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23764">the number of bytes of disk space used</doc>
            <type name="guint64" c:type="guint64*" />
          </parameter>
          <parameter name="num_dirs" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="numDirs">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23765">the number of directories encountered</doc>
            <type name="guint64" c:type="guint64*" />
          </parameter>
          <parameter name="num_files" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="numFiles">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23766">the number of non-directories encountered</doc>
            <type name="guint64" c:type="guint64*" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23763">the #GAsyncResult passed to your #GAsyncReadyCallback</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <parameter name="disk_usage" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="diskUsage">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23764">the number of bytes of disk space used</doc>
            <type name="guint64" c:type="guint64*" />
          </parameter>
          <parameter name="num_dirs" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="numDirs">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23765">the number of directories encountered</doc>
            <type name="guint64" c:type="guint64*" />
          </parameter>
          <parameter name="num_files" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="numFiles">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23766">the number of non-directories encountered</doc>
            <type name="guint64" c:type="guint64*" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="mount_enclosing_volume_finish" invoker="mount_enclosing_volume_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoMountEnclosingVolumeFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23930">Finishes a mount operation started by g_file_mount_enclosing_volume().</doc>
        <source-position filename="gfile.h" line="464" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="23938">%TRUE if successful. If an error has occurred,
    this function will return %FALSE and set @error
    appropriately if present.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="location" transfer-ownership="none" gs:managed-name="location" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23932">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23933">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23933">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="mount_mountable_finish" invoker="mount_mountable_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoMountMountableFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23970">Finishes a mount operation. See g_file_mount_mountable() for details.

Finish an asynchronous mount operation that was started
with g_file_mount_mountable().</doc>
        <source-position filename="gfile.h" line="436" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="23981">a #GFile or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="File" c:type="GFile*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23972">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23973">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23973">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="move" invoker="move" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoMove">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23986">Tries to move the file or directory @source to the location specified
by @destination. If native move operations are supported then this is
used, otherwise a copy + delete fallback is used. The native
implementation may support moving directories (for instance on moves
inside the same filesystem), but the fallback code does not.

If the flag #G_FILE_COPY_OVERWRITE is specified an already
existing @destination file is overwritten.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.

If @progress_callback is not %NULL, then the operation can be monitored
by setting this to a #GFileProgressCallback function.
@progress_callback_data will be passed to this function. It is
guaranteed that this callback will be called after all data has been
transferred with the total number of bytes copied during the operation.

If the @source file does not exist, then the %G_IO_ERROR_NOT_FOUND
error is returned, independent on the status of the @destination.

If #G_FILE_COPY_OVERWRITE is not specified and the target exists,
then the error %G_IO_ERROR_EXISTS is returned.

If trying to overwrite a file over a directory, the %G_IO_ERROR_IS_DIRECTORY
error is returned. If trying to overwrite a directory with a directory the
%G_IO_ERROR_WOULD_MERGE error is returned.

If the source is a directory and the target does not exist, or
#G_FILE_COPY_OVERWRITE is specified and the target is a file, then
the %G_IO_ERROR_WOULD_RECURSE error may be returned (if the native
move operation isn't available).</doc>
        <source-position filename="gfile.h" line="420" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="24033">%TRUE on successful move, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23988">#GFile pointing to the source location</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="destination" transfer-ownership="none" gs:managed-name="destination" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23989">#GFile pointing to the destination location</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23990">set of #GFileCopyFlags</doc>
            <type name="FileCopyFlags" c:type="GFileCopyFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23991">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="progress_callback" transfer-ownership="none" nullable="1" allow-none="1" scope="call" closure="4" gs:managed-name="progressCallback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23993">#GFileProgressCallback
    function for updates</doc>
            <type name="FileProgressCallback" c:type="GFileProgressCallback" />
          </parameter>
          <parameter name="progress_callback_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="progressCallbackData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23995">gpointer to user data for
    the callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="destination" transfer-ownership="none" gs:managed-name="destination" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23989">#GFile pointing to the destination location</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23990">set of #GFileCopyFlags</doc>
            <type name="FileCopyFlags" c:type="GFileCopyFlags" />
          </parameter>
          <parameter name="progress_callback" transfer-ownership="none" nullable="1" allow-none="1" scope="call" closure="4" gs:managed-name="progressCallback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23993">#GFileProgressCallback
    function for updates</doc>
            <type name="FileProgressCallback" c:type="GFileProgressCallback" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23991">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="open_readwrite" invoker="open_readwrite" version="2.22" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoOpenReadwrite">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24151">Opens an existing file for reading and writing. The result is
a #GFileIOStream that can be used to read and write the contents
of the file.

If @cancellable is not %NULL, then the operation can be cancelled
by triggering the cancellable object from another thread. If the
operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
returned.

If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will
be returned. If the file is a directory, the %G_IO_ERROR_IS_DIRECTORY
error will be returned. Other errors are possible too, and depend on
what kind of filesystem the file is on. Note that in many non-local
file cases read and write streams are not supported, so make sure you
really need to do read and write streaming, rather than just opening
for reading or writing.</doc>
        <source-position filename="gfile.h" line="477" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="24174">#GFileIOStream or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileIOStream" c:type="GFileIOStream*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24153">#GFile to open</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24154">a #GCancellable</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24154">a #GCancellable</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="open_readwrite_async" invoker="open_readwrite_async" version="2.22" gs:dll-name="gio-2.0" gs:managed-name="DoOpenReadwriteAsync">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24180">Asynchronously opens @file for reading and writing.

For more details, see g_file_open_readwrite() which is
the synchronous version of this call.

When the operation is finished, @callback will be called.
You can then call g_file_open_readwrite_finish() to get
the result of the operation.</doc>
        <source-position filename="gfile.h" line="480" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24182">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24183">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24184">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24186">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24188">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24183">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24186">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24184">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="open_readwrite_finish" invoker="open_readwrite_finish" version="2.22" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoOpenReadwriteFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24203">Finishes an asynchronous file read operation started with
g_file_open_readwrite_async().</doc>
        <source-position filename="gfile.h" line="485" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="24212">a #GFileIOStream or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileIOStream" c:type="GFileIOStream*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24205">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24206">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24206">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="poll_mountable" invoker="poll_mountable" version="2.22" gs:dll-name="gio-2.0" gs:managed-name="DoPollMountable">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24321">Polls a file of type #G_FILE_TYPE_MOUNTABLE.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.

When the operation is finished, @callback will be called.
You can then call g_file_mount_mountable_finish() to get
the result of the operation.</doc>
        <source-position filename="gfile.h" line="561" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24323">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24324">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="2" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24325">a #GAsyncReadyCallback to call
    when the request is satisfied, or %NULL</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="2" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24327">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="2" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24325">a #GAsyncReadyCallback to call
    when the request is satisfied, or %NULL</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24324">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="poll_mountable_finish" invoker="poll_mountable_finish" version="2.22" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoPollMountableFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24343">Finishes a poll operation. See g_file_poll_mountable() for details.

Finish an asynchronous poll operation that was polled
with g_file_poll_mountable().</doc>
        <source-position filename="gfile.h" line="565" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="24354">%TRUE if the operation finished successfully. %FALSE
otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24345">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24346">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24346">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="prefix_matches" invoker="has_prefix" gs:dll-name="gio-2.0" gs:managed-name="DoPrefixMatches">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22439">Checks whether @file has the prefix specified by @prefix.

In other words, if the names of initial elements of @file's
pathname match @prefix. Only full pathname elements are matched,
so a path like /foo is not considered a prefix of /foobar, only
of /foo/bar.

A #GFile is not a prefix of itself. If you want to check for
equality, use g_file_equal().

This call does no I/O, as it works purely on names. As such it can
sometimes return %FALSE even if @file is inside a @prefix (from a
filesystem point of view), because the prefix of @file is an alias
of @prefix.</doc>
        <source-position filename="gfile.h" line="181" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22459">%TRUE if the @file's parent, grandparent, etc is @prefix,
    %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="prefix" transfer-ownership="none" gs:managed-name="prefix" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22442">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22441">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22441">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="query_filesystem_info" invoker="query_filesystem_info" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoQueryFilesystemInfo">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24461">Similar to g_file_query_info(), but obtains information
about the filesystem the @file is on, rather than the file itself.
For instance the amount of space available and the type of
the filesystem.

The @attributes value is a string that specifies the attributes
that should be gathered. It is not an error if it's not possible
to read a particular requested attribute from a file - it just
won't be set. @attributes should be a comma-separated list of
attributes or attribute wildcards. The wildcard "*" means all
attributes, and a wildcard like "filesystem::*" means all attributes
in the filesystem namespace. The standard namespace for filesystem
attributes is "filesystem". Common attributes of interest are
#G_FILE_ATTRIBUTE_FILESYSTEM_SIZE (the total size of the filesystem
in bytes), #G_FILE_ATTRIBUTE_FILESYSTEM_FREE (number of bytes available),
and #G_FILE_ATTRIBUTE_FILESYSTEM_TYPE (type of the filesystem).

If @cancellable is not %NULL, then the operation can be cancelled
by triggering the cancellable object from another thread. If the
operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
returned.

If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will
be returned. Other errors are possible too, and depend on what
kind of filesystem the file is on.</doc>
        <source-position filename="gfile.h" line="223" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="24495">a #GFileInfo or %NULL if there was an error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24463">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24464">an attribute query string</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24465">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24464">an attribute query string</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24465">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="query_filesystem_info_async" invoker="query_filesystem_info_async" gs:dll-name="gio-2.0" gs:managed-name="DoQueryFilesystemInfoAsync">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24500">Asynchronously gets the requested information about the filesystem
that the specified @file is on. The result is a #GFileInfo object
that contains key-value attributes (such as type or size for the
file).

For more details, see g_file_query_filesystem_info() which is the
synchronous version of this call.

When the operation is finished, @callback will be called. You can
then call g_file_query_info_finish() to get the result of the
operation.</doc>
        <source-position filename="gfile.h" line="227" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24502">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24503">an attribute query string</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24504">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24505">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24507">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24509">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24503">an attribute query string</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24504">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24507">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24505">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="query_filesystem_info_finish" invoker="query_filesystem_info_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoQueryFilesystemInfoFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24525">Finishes an asynchronous filesystem info query.
See g_file_query_filesystem_info_async().</doc>
        <source-position filename="gfile.h" line="233" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="24534">#GFileInfo for given @file
    or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24527">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24528">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24528">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="query_info" invoker="query_info" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoQueryInfo">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24540">Gets the requested information about specified @file.
The result is a #GFileInfo object that contains key-value
attributes (such as the type or size of the file).

The @attributes value is a string that specifies the file
attributes that should be gathered. It is not an error if
it's not possible to read a particular requested attribute
from a file - it just won't be set. @attributes should be a
comma-separated list of attributes or attribute wildcards.
The wildcard "*" means all attributes, and a wildcard like
"standard::*" means all attributes in the standard namespace.
An example attribute query be "standard::*,owner::user".
The standard attributes are available as defines, like
#G_FILE_ATTRIBUTE_STANDARD_NAME.

If @cancellable is not %NULL, then the operation can be cancelled
by triggering the cancellable object from another thread. If the
operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
returned.

For symlinks, normally the information about the target of the
symlink is returned, rather than information about the symlink
itself. However if you pass #G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS
in @flags the information about the symlink itself will be returned.
Also, for symlinks that point to non-existing files the information
about the symlink itself will be returned.

If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will be
returned. Other errors are possible too, and depend on what kind of
filesystem the file is on.</doc>
        <source-position filename="gfile.h" line="207" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="24580">a #GFileInfo for the given @file, or %NULL
    on error. Free the returned object with g_object_unref().</doc>
          <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24542">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24543">an attribute query string</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24544">a set of #GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24545">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24543">an attribute query string</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24544">a set of #GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24545">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="query_info_async" invoker="query_info_async" gs:dll-name="gio-2.0" gs:managed-name="DoQueryInfoAsync">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24585">Asynchronously gets the requested information about specified @file.
The result is a #GFileInfo object that contains key-value attributes
(such as type or size for the file).

For more details, see g_file_query_info() which is the synchronous
version of this call.

When the operation is finished, @callback will be called. You can
then call g_file_query_info_finish() to get the result of the operation.</doc>
        <source-position filename="gfile.h" line="212" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24587">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24588">an attribute query string</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24589">a set of #GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24590">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24591">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24593">a #GAsyncReadyCallback to call when the
    request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24595">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24588">an attribute query string</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24589">a set of #GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24590">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24593">a #GAsyncReadyCallback to call when the
    request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24591">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="query_info_finish" invoker="query_info_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoQueryInfoFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24609">Finishes an asynchronous file info query.
See g_file_query_info_async().</doc>
        <source-position filename="gfile.h" line="219" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="24618">#GFileInfo for given @file
    or %NULL on error. Free the returned object with
    g_object_unref().</doc>
          <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24611">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24612">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24612">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="query_settable_attributes" invoker="query_settable_attributes" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoQuerySettableAttributes">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24624">Obtain the list of settable attributes for the file.

Returns the type and full attribute name of all the attributes
that can be set on this file. This doesn't mean setting it will
always succeed though, you might get an access failure, or some
specific file may not support a specific attribute.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <source-position filename="gfile.h" line="263" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="24642">a #GFileAttributeInfoList describing the settable attributes.
    When you are done with it, release it with
    g_file_attribute_info_list_unref()</doc>
          <type name="FileAttributeInfoList" c:type="GFileAttributeInfoList*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24626">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24627">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24627">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="query_writable_namespaces" invoker="query_writable_namespaces" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoQueryWritableNamespaces">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24648">Obtain the list of attribute namespaces where new attributes
can be created by a user. An example of this is extended
attributes (in the "xattr" namespace).

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <source-position filename="gfile.h" line="269" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="24663">a #GFileAttributeInfoList describing the writable namespaces.
    When you are done with it, release it with
    g_file_attribute_info_list_unref()</doc>
          <type name="FileAttributeInfoList" c:type="GFileAttributeInfoList*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24650">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24651">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24651">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="read_async" invoker="read_async" gs:dll-name="gio-2.0" gs:managed-name="DoReadAsync">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24692">Asynchronously opens @file for reading.

For more details, see g_file_read() which is
the synchronous version of this call.

When the operation is finished, @callback will be called.
You can then call g_file_read_finish() to get the result
of the operation.</doc>
        <source-position filename="gfile.h" line="302" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24694">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24695">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24696">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24698">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24700">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24695">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24698">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24696">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="read_finish" invoker="read_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoReadFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24713">Finishes an asynchronous file read operation started with
g_file_read_async().</doc>
        <source-position filename="gfile.h" line="307" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="24722">a #GFileInputStream or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileInputStream" c:type="GFileInputStream*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24715">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24716">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24716">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="read_fn" invoker="read" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoReadFn">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24669">Opens a file for reading. The result is a #GFileInputStream that
can be used to read the contents of the file.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.

If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will be
returned. If the file is a directory, the %G_IO_ERROR_IS_DIRECTORY
error will be returned. Other errors are possible too, and depend
on what kind of filesystem the file is on.</doc>
        <source-position filename="gfile.h" line="299" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="24687">#GFileInputStream or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileInputStream" c:type="GFileInputStream*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24671">#GFile to read</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24672">a #GCancellable</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24672">a #GCancellable</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="replace" invoker="replace" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoReplace">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24727">Returns an output stream for overwriting the file, possibly
creating a backup copy of the file first. If the file doesn't exist,
it will be created.

This will try to replace the file in the safest way possible so
that any errors during the writing will not affect an already
existing copy of the file. For instance, for local files it
may write to a temporary file and then atomically rename over
the destination when the stream is closed.

By default files created are generally readable by everyone,
but if you pass #G_FILE_CREATE_PRIVATE in @flags the file
will be made readable only to the current user, to the level that
is supported on the target filesystem.

If @cancellable is not %NULL, then the operation can be cancelled
by triggering the cancellable object from another thread. If the
operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
returned.

If you pass in a non-%NULL @etag value and @file already exists, then
this value is compared to the current entity tag of the file, and if
they differ an %G_IO_ERROR_WRONG_ETAG error is returned. This
generally means that the file has been changed since you last read
it. You can get the new etag from g_file_output_stream_get_etag()
after you've finished writing and closed the #GFileOutputStream. When
you load a new file you can use g_file_input_stream_query_info() to
get the etag of the file.

If @make_backup is %TRUE, this function will attempt to make a
backup of the current file before overwriting it. If this fails
a %G_IO_ERROR_CANT_CREATE_BACKUP error will be returned. If you
want to replace anyway, try again with @make_backup set to %FALSE.

If the file is a directory the %G_IO_ERROR_IS_DIRECTORY error will
be returned, and if the file is some other form of non-regular file
then a %G_IO_ERROR_NOT_REGULAR_FILE error will be returned. Some
file systems don't allow all file names, and may return an
%G_IO_ERROR_INVALID_FILENAME error, and if the name is to long
%G_IO_ERROR_FILENAME_TOO_LONG will be returned. Other errors are
possible too, and depend on what kind of filesystem the file is on.</doc>
        <source-position filename="gfile.h" line="339" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="24780">a #GFileOutputStream or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileOutputStream" c:type="GFileOutputStream*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24729">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="etag" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="etag" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24730">an optional [entity tag][gfile-etag]
    for the current #GFile, or #NULL to ignore</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="make_backup" transfer-ownership="none" gs:managed-name="makeBackup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24732">%TRUE if a backup should be created</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24733">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24734">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="etag" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="etag" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24730">an optional [entity tag][gfile-etag]
    for the current #GFile, or #NULL to ignore</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="make_backup" transfer-ownership="none" gs:managed-name="makeBackup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24732">%TRUE if a backup should be created</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24733">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24734">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="replace_async" invoker="replace_async" gs:dll-name="gio-2.0" gs:managed-name="DoReplaceAsync">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24785">Asynchronously overwrites the file, replacing the contents,
possibly creating a backup copy of the file first.

For more details, see g_file_replace() which is
the synchronous version of this call.

When the operation is finished, @callback will be called.
You can then call g_file_replace_finish() to get the result
of the operation.</doc>
        <source-position filename="gfile.h" line="345" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24787">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="etag" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="etag" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24788">an [entity tag][gfile-etag] for the current #GFile,
    or %NULL to ignore</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="make_backup" transfer-ownership="none" gs:managed-name="makeBackup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24790">%TRUE if a backup should be created</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24791">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24792">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24793">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="6" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24795">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="6" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24797">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="etag" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="etag" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24788">an [entity tag][gfile-etag] for the current #GFile,
    or %NULL to ignore</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="make_backup" transfer-ownership="none" gs:managed-name="makeBackup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24790">%TRUE if a backup should be created</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24791">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24792">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="6" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24795">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24793">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="replace_finish" invoker="replace_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoReplaceFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24923">Finishes an asynchronous file replace operation started with
g_file_replace_async().</doc>
        <source-position filename="gfile.h" line="353" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="24932">a #GFileOutputStream, or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileOutputStream" c:type="GFileOutputStream*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24925">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24926">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24926">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="replace_readwrite" invoker="replace_readwrite" version="2.22" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoReplaceReadwrite">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24937">Returns an output stream for overwriting the file in readwrite mode,
possibly creating a backup copy of the file first. If the file doesn't
exist, it will be created.

For details about the behaviour, see g_file_replace() which does the
same thing but returns an output stream only.

Note that in many non-local file cases read and write streams are not
supported, so make sure you really need to do read and write streaming,
rather than just opening for reading or writing.</doc>
        <source-position filename="gfile.h" line="501" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="24959">a #GFileIOStream or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileIOStream" c:type="GFileIOStream*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24939">a #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="etag" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="etag" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24940">an optional [entity tag][gfile-etag]
    for the current #GFile, or #NULL to ignore</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="make_backup" transfer-ownership="none" gs:managed-name="makeBackup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24942">%TRUE if a backup should be created</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24943">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24944">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="etag" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="etag" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24940">an optional [entity tag][gfile-etag]
    for the current #GFile, or #NULL to ignore</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="make_backup" transfer-ownership="none" gs:managed-name="makeBackup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24942">%TRUE if a backup should be created</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24943">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24944">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="replace_readwrite_async" invoker="replace_readwrite_async" version="2.22" gs:dll-name="gio-2.0" gs:managed-name="DoReplaceReadwriteAsync">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24965">Asynchronously overwrites the file in read-write mode,
replacing the contents, possibly creating a backup copy
of the file first.

For more details, see g_file_replace_readwrite() which is
the synchronous version of this call.

When the operation is finished, @callback will be called.
You can then call g_file_replace_readwrite_finish() to get
the result of the operation.</doc>
        <source-position filename="gfile.h" line="507" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24967">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="etag" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="etag" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24968">an [entity tag][gfile-etag] for the current #GFile,
    or %NULL to ignore</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="make_backup" transfer-ownership="none" gs:managed-name="makeBackup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24970">%TRUE if a backup should be created</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24971">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24972">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24973">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="6" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24975">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="6" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24977">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="etag" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="etag" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24968">an [entity tag][gfile-etag] for the current #GFile,
    or %NULL to ignore</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="make_backup" transfer-ownership="none" gs:managed-name="makeBackup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24970">%TRUE if a backup should be created</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24971">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24972">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="6" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24975">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24973">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="replace_readwrite_finish" invoker="replace_readwrite_finish" version="2.22" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoReplaceReadwriteFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24994">Finishes an asynchronous file replace operation started with
g_file_replace_readwrite_async().</doc>
        <source-position filename="gfile.h" line="515" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="25003">a #GFileIOStream, or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileIOStream" c:type="GFileIOStream*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24996">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24997">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24997">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="resolve_relative_path" invoker="resolve_relative_path" gs:dll-name="gio-2.0" gs:managed-name="DoResolveRelativePath">
        <doc xml:space="preserve" filename="gio-2.0.c" line="25009">Resolves a relative path for @file to an absolute path.

This call does no blocking I/O.</doc>
        <source-position filename="gfile.h" line="185" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="25018">#GFile to the resolved path.
    %NULL if @relative_path is %NULL or if @file is invalid.
    Free the returned object with g_object_unref().</doc>
          <type name="File" c:type="GFile*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25011">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="relative_path" transfer-ownership="none" gs:managed-name="relativePath" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25012">a given relative path string</doc>
            <type name="filename" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="relative_path" transfer-ownership="none" gs:managed-name="relativePath" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25012">a given relative path string</doc>
            <type name="filename" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="set_attribute" invoker="set_attribute" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoSetAttribute">
        <doc xml:space="preserve" filename="gio-2.0.c" line="25024">Sets an attribute in the file with attribute name @attribute to @value_p.

Some attributes can be unset by setting @type to
%G_FILE_ATTRIBUTE_TYPE_INVALID and @value_p to %NULL.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <source-position filename="gfile.h" line="275" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="25045">%TRUE if the attribute was set, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25026">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25027">a string containing the attribute's name</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25028">The type of the attribute</doc>
            <type name="FileAttributeType" c:type="GFileAttributeType" />
          </parameter>
          <parameter name="value_p" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="valueP" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25029">a pointer to the value (or the pointer
    itself if the type is a pointer type)</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25031">a set of #GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25032">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25027">a string containing the attribute's name</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25028">The type of the attribute</doc>
            <type name="FileAttributeType" c:type="GFileAttributeType" />
          </parameter>
          <parameter name="value_p" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="valueP" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25029">a pointer to the value (or the pointer
    itself if the type is a pointer type)</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25031">a set of #GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25032">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="set_attributes_async" invoker="set_attributes_async" gs:dll-name="gio-2.0" gs:managed-name="DoSetAttributesAsync">
        <doc xml:space="preserve" filename="gio-2.0.c" line="25180">Asynchronously sets the attributes of @file with @info.

For more details, see g_file_set_attributes_from_info(),
which is the synchronous version of this call.

When the operation is finished, @callback will be called.
You can then call g_file_set_attributes_finish() to get
the result of the operation.</doc>
        <source-position filename="gfile.h" line="287" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25182">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25183">a #GFileInfo</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25184">a #GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25185">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25186">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25188">a #GAsyncReadyCallback</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25189">a #gpointer</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25183">a #GFileInfo</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25184">a #GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25185">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25188">a #GAsyncReadyCallback</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25186">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="set_attributes_finish" invoker="set_attributes_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoSetAttributesFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="25202">Finishes setting an attribute started in g_file_set_attributes_async().</doc>
        <source-position filename="gfile.h" line="294" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="25211">%TRUE if the attributes were set correctly, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25204">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25205">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <parameter name="info" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="info">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25206">a #GFileInfo</doc>
            <type name="FileInfo" c:type="GFileInfo**" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25205">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <parameter name="info" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="info">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25206">a #GFileInfo</doc>
            <type name="FileInfo" c:type="GFileInfo**" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="set_attributes_from_info" invoker="set_attributes_from_info" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoSetAttributesFromInfo">
        <doc xml:space="preserve" filename="gio-2.0.c" line="25215">Tries to set all attributes in the #GFileInfo on the target
values, not stopping on the first error.

If there is any error during this operation then @error will
be set to the first error. Error on particular fields are flagged
by setting the "status" field in the attribute value to
%G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING, which means you can
also detect further errors.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <source-position filename="gfile.h" line="282" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="25237">%FALSE if there was any error, %TRUE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25217">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25218">a #GFileInfo</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25219">#GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25220">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25218">a #GFileInfo</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25219">#GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25220">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="set_display_name" invoker="set_display_name" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoSetDisplayName">
        <doc xml:space="preserve" filename="gio-2.0.c" line="25241">Renames @file to the specified display name.

The display name is converted from UTF-8 to the correct encoding
for the target filesystem if possible and the @file is renamed to this.

If you want to implement a rename operation in the user interface the
edit name (#G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME) should be used as the
initial value in the rename widget, and then the result after editing
should be passed to g_file_set_display_name().

On success the resulting converted filename is returned.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <source-position filename="gfile.h" line="249" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="25265">a #GFile specifying what @file was renamed to,
    or %NULL if there was an error.
    Free the returned object with g_object_unref().</doc>
          <type name="File" c:type="GFile*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25243">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="display_name" transfer-ownership="none" gs:managed-name="displayName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25244">a string</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25245">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="display_name" transfer-ownership="none" gs:managed-name="displayName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25244">a string</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25245">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="set_display_name_async" invoker="set_display_name_async" gs:dll-name="gio-2.0" gs:managed-name="DoSetDisplayNameAsync">
        <doc xml:space="preserve" filename="gio-2.0.c" line="25271">Asynchronously sets the display name for a given #GFile.

For more details, see g_file_set_display_name() which is
the synchronous version of this call.

When the operation is finished, @callback will be called.
You can then call g_file_set_display_name_finish() to get
the result of the operation.</doc>
        <source-position filename="gfile.h" line="253" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25273">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="display_name" transfer-ownership="none" gs:managed-name="displayName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25274">a string</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25275">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25276">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25278">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25280">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="display_name" transfer-ownership="none" gs:managed-name="displayName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25274">a string</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25275">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25278">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25276">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="set_display_name_finish" invoker="set_display_name_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoSetDisplayNameFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="25293">Finishes setting a display name started with
g_file_set_display_name_async().</doc>
        <source-position filename="gfile.h" line="259" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="25302">a #GFile or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="File" c:type="GFile*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25295">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25296">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25296">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="start_mountable_finish" invoker="start_mountable_finish" version="2.22" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoStartMountableFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="25332">Finishes a start operation. See g_file_start_mountable() for details.

Finish an asynchronous start operation that was started
with g_file_start_mountable().</doc>
        <source-position filename="gfile.h" line="525" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="25343">%TRUE if the operation finished successfully. %FALSE
otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25334">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25335">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25335">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="stop_mountable_finish" invoker="stop_mountable_finish" version="2.22" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoStopMountableFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="25375">Finishes a stop operation, see g_file_stop_mountable() for details.

Finish an asynchronous stop operation that was started
with g_file_stop_mountable().</doc>
        <source-position filename="gfile.h" line="535" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="25386">%TRUE if the operation finished successfully.
    %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25377">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25378">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25378">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="trash" invoker="trash" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoTrash">
        <doc xml:space="preserve" filename="gio-2.0.c" line="25406">Sends @file to the "Trashcan", if possible. This is similar to
deleting it, but the user can recover it before emptying the trashcan.
Not all file systems support trashing, so this call can return the
%G_IO_ERROR_NOT_SUPPORTED error. Since GLib 2.66, the `x-gvfs-notrash` unix
mount option can be used to disable g_file_trash() support for certain
mounts, the %G_IO_ERROR_NOT_SUPPORTED error will be returned in that case.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <source-position filename="gfile.h" line="369" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="25424">%TRUE on successful trash, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25408">#GFile to send to trash</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25409">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25409">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="trash_async" invoker="trash_async" version="2.38" gs:dll-name="gio-2.0" gs:managed-name="DoTrashAsync">
        <doc xml:space="preserve" filename="gio-2.0.c" line="25428">Asynchronously sends @file to the Trash location, if possible.</doc>
        <source-position filename="gfile.h" line="372" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25430">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25431">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25432">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25434">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25436">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25431">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25434">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25432">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="trash_finish" invoker="trash_finish" version="2.38" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoTrashFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="25444">Finishes an asynchronous file trashing operation, started with
g_file_trash_async().</doc>
        <source-position filename="gfile.h" line="377" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="25453">%TRUE on successful trash, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25446">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25447">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25447">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="unmount_mountable_finish" invoker="unmount_mountable_finish" deprecated="1" deprecated-version="2.22" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoUnmountMountableFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="25482">Finishes an unmount operation, see g_file_unmount_mountable() for details.

Finish an asynchronous unmount operation that was started
with g_file_unmount_mountable().</doc>
        <doc-deprecated xml:space="preserve">Use g_file_unmount_mountable_with_operation_finish()
    instead.</doc-deprecated>
        <source-position filename="gfile.h" line="445" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="25493">%TRUE if the operation finished successfully.
    %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25484">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25485">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25485">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="unmount_mountable_with_operation_finish" invoker="unmount_mountable_with_operation_finish" version="2.22" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoUnmountMountableWithOperationFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="25526">Finishes an unmount operation,
see g_file_unmount_mountable_with_operation() for details.

Finish an asynchronous unmount operation that was started
with g_file_unmount_mountable_with_operation().</doc>
        <source-position filename="gfile.h" line="547" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="25538">%TRUE if the operation finished successfully.
    %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25528">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25529">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25529">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <method name="append_to" c:identifier="g_file_append_to" throws="1" gs:dll-name="gio-2.0" gs:managed-name="AppendTo" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="21108">Gets an output stream for appending data to the file.
If the file doesn't already exist it is created.

By default files created are generally readable by everyone,
but if you pass #G_FILE_CREATE_PRIVATE in @flags the file
will be made readable only to the current user, to the level that
is supported on the target filesystem.

If @cancellable is not %NULL, then the operation can be cancelled
by triggering the cancellable object from another thread. If the
operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
returned.

Some file systems don't allow all file names, and may return an
%G_IO_ERROR_INVALID_FILENAME error. If the file is a directory the
%G_IO_ERROR_IS_DIRECTORY error will be returned. Other errors are
possible too, and depend on what kind of filesystem the file is on.</doc>
        <source-position filename="gfile.h" line="675" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="21134">a #GFileOutputStream, or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileOutputStream" c:type="GFileOutputStream*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21110">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21111">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21112">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21110">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21111">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21112">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="append_to_async" c:identifier="g_file_append_to_async" gs:dll-name="gio-2.0" gs:managed-name="AppendToAsync" gs:async="1" gs:async-finish="AppendToFinish" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="21139">Asynchronously opens @file for appending.

For more details, see g_file_append_to() which is
the synchronous version of this call.

When the operation is finished, @callback will be called.
You can then call g_file_append_to_finish() to get the result
of the operation.</doc>
        <source-position filename="gfile.h" line="692" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Threading.Tasks.Task">
            <type name="FileOutputStream" c:type="GFileOutputStream*" gs:is-pointer="1" />
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21141">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21142">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21143">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21144">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21146">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21148">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21141">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21142">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21143">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21144">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="append_to_finish" c:identifier="g_file_append_to_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="AppendToFinish" gs:pinvoke-only="1" gs:finish-for="append_to_async" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="21161">Finishes an asynchronous file append operation started with
g_file_append_to_async().</doc>
        <source-position filename="gfile.h" line="699" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="21170">a valid #GFileOutputStream
    or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileOutputStream" c:type="GFileOutputStream*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21163">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21164">#GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21163">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21164">#GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="copy" c:identifier="g_file_copy" throws="1" gs:dll-name="gio-2.0" gs:managed-name="Copy" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="21415">Copies the file @source to the location specified by @destination.
Can not handle recursive copies of directories.

If the flag #G_FILE_COPY_OVERWRITE is specified an already
existing @destination file is overwritten.

If the flag #G_FILE_COPY_NOFOLLOW_SYMLINKS is specified then symlinks
will be copied as symlinks, otherwise the target of the
@source symlink will be copied.

If the flag #G_FILE_COPY_ALL_METADATA is specified then all the metadata
that is possible to copy is copied, not just the default subset (which,
for instance, does not include the owner, see #GFileInfo).

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.

If @progress_callback is not %NULL, then the operation can be monitored
by setting this to a #GFileProgressCallback function.
@progress_callback_data will be passed to this function. It is guaranteed
that this callback will be called after all data has been transferred with
the total number of bytes copied during the operation.

If the @source file does not exist, then the %G_IO_ERROR_NOT_FOUND error
is returned, independent on the status of the @destination.

If #G_FILE_COPY_OVERWRITE is not specified and the target exists, then
the error %G_IO_ERROR_EXISTS is returned.

If trying to overwrite a file over a directory, the %G_IO_ERROR_IS_DIRECTORY
error is returned. If trying to overwrite a directory with a directory the
%G_IO_ERROR_WOULD_MERGE error is returned.

If the source is a directory and the target does not exist, or
#G_FILE_COPY_OVERWRITE is specified and the target is a file, then the
%G_IO_ERROR_WOULD_RECURSE error is returned.

If you are interested in copying the #GFile object itself (not the on-disk
file), see g_file_dup().</doc>
        <source-position filename="gfile.h" line="900" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="21468">%TRUE on success, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21417">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="destination" transfer-ownership="none" gs:managed-name="destination" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21418">destination #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21419">set of #GFileCopyFlags</doc>
            <type name="FileCopyFlags" c:type="GFileCopyFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21420">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="progress_callback" transfer-ownership="none" nullable="1" allow-none="1" scope="call" closure="4" gs:managed-name="progressCallback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21422">function to callback with
    progress information, or %NULL if progress information is not needed</doc>
            <type name="FileProgressCallback" c:type="GFileProgressCallback" />
          </parameter>
          <parameter name="progress_callback_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="progressCallbackData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21424">user data to pass to @progress_callback</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21417">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="destination" transfer-ownership="none" gs:managed-name="destination" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21418">destination #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21419">set of #GFileCopyFlags</doc>
            <type name="FileCopyFlags" c:type="GFileCopyFlags" />
          </parameter>
          <parameter name="progress_callback" transfer-ownership="none" nullable="1" allow-none="1" scope="call" closure="4" gs:managed-name="progressCallback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21422">function to callback with
    progress information, or %NULL if progress information is not needed</doc>
            <type name="FileProgressCallback" c:type="GFileProgressCallback" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21420">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="copy_async" c:identifier="g_file_copy_async" gs:dll-name="gio-2.0" gs:managed-name="CopyAsync" gs:async="1" gs:async-finish="CopyFinish" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="21472">Copies the file @source to the location specified by @destination
asynchronously. For details of the behaviour, see g_file_copy().

If @progress_callback is not %NULL, then that function that will be called
just like in g_file_copy(). The callback will run in the default main context
of the thread calling g_file_copy_async() — the same context as @callback is
run in.

When the operation is finished, @callback will be called. You can then call
g_file_copy_finish() to get the result of the operation.</doc>
        <source-position filename="gfile.h" line="908" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Threading.Tasks.Task" />
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21474">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="destination" transfer-ownership="none" gs:managed-name="destination" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21475">destination #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21476">set of #GFileCopyFlags</doc>
            <type name="FileCopyFlags" c:type="GFileCopyFlags" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21477">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21478">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="progress_callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5" gs:default="null" gs:managed-name="progressCallback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21480">function to callback with progress
    information, or %NULL if progress information is not needed</doc>
            <type name="FileProgressCallback" c:type="GFileProgressCallback" />
          </parameter>
          <parameter name="progress_callback_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="progressCallbackData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21482">user data to pass to @progress_callback</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="7" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21483">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21484">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21474">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="destination" transfer-ownership="none" gs:managed-name="destination" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21475">destination #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21476">set of #GFileCopyFlags</doc>
            <type name="FileCopyFlags" c:type="GFileCopyFlags" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21477">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21478">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="progress_callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5" gs:default="null" gs:managed-name="progressCallback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21480">function to callback with progress
    information, or %NULL if progress information is not needed</doc>
            <type name="FileProgressCallback" c:type="GFileProgressCallback" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="copy_attributes" c:identifier="g_file_copy_attributes" throws="1" gs:dll-name="gio-2.0" gs:managed-name="CopyAttributes" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="21499">Copies the file attributes from @source to @destination.

Normally only a subset of the file attributes are copied,
those that are copies in a normal file copy operation
(which for instance does not include e.g. owner). However
if #G_FILE_COPY_ALL_METADATA is specified in @flags, then
all the metadata that is possible to copy is copied. This
is useful when implementing move by copy + delete source.</doc>
        <source-position filename="gfile.h" line="1098" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="21517">%TRUE if the attributes were copied successfully,
    %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21501">a #GFile with attributes</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="destination" transfer-ownership="none" gs:managed-name="destination" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21502">a #GFile to copy attributes to</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21503">a set of #GFileCopyFlags</doc>
            <type name="FileCopyFlags" c:type="GFileCopyFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21504">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21501">a #GFile with attributes</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="destination" transfer-ownership="none" gs:managed-name="destination" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21502">a #GFile to copy attributes to</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21503">a set of #GFileCopyFlags</doc>
            <type name="FileCopyFlags" c:type="GFileCopyFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21504">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="copy_finish" c:identifier="g_file_copy_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="CopyFinish" gs:pinvoke-only="1" gs:finish-for="copy_async" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="21522">Finishes copying the file started with g_file_copy_async().</doc>
        <source-position filename="gfile.h" line="918" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="21530">a %TRUE on success, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21524">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21525">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21524">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21525">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="create" c:identifier="g_file_create" throws="1" gs:dll-name="gio-2.0" gs:managed-name="Create" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="21534">Creates a new file and returns an output stream for writing to it.
The file must not already exist.

By default files created are generally readable by everyone,
but if you pass #G_FILE_CREATE_PRIVATE in @flags the file
will be made readable only to the current user, to the level
that is supported on the target filesystem.

If @cancellable is not %NULL, then the operation can be cancelled
by triggering the cancellable object from another thread. If the
operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
returned.

If a file or directory with this name already exists the
%G_IO_ERROR_EXISTS error will be returned. Some file systems don't
allow all file names, and may return an %G_IO_ERROR_INVALID_FILENAME
error, and if the name is to long %G_IO_ERROR_FILENAME_TOO_LONG will
be returned. Other errors are possible too, and depend on what kind
of filesystem the file is on.</doc>
        <source-position filename="gfile.h" line="680" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="21562">a #GFileOutputStream for the newly created
    file, or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileOutputStream" c:type="GFileOutputStream*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21536">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21537">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21538">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21536">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21537">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21538">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="create_async" c:identifier="g_file_create_async" gs:dll-name="gio-2.0" gs:managed-name="CreateAsync" gs:async="1" gs:async-finish="CreateFinish" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="21568">Asynchronously creates a new file and returns an output stream
for writing to it. The file must not already exist.

For more details, see g_file_create() which is
the synchronous version of this call.

When the operation is finished, @callback will be called.
You can then call g_file_create_finish() to get the result
of the operation.</doc>
        <source-position filename="gfile.h" line="703" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Threading.Tasks.Task">
            <type name="FileOutputStream" c:type="GFileOutputStream*" gs:is-pointer="1" />
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21570">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21571">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21572">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21573">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21575">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21577">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21570">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21571">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21572">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21573">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="create_finish" c:identifier="g_file_create_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="CreateFinish" gs:pinvoke-only="1" gs:finish-for="create_async" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="21591">Finishes an asynchronous file create operation started with
g_file_create_async().</doc>
        <source-position filename="gfile.h" line="710" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="21600">a #GFileOutputStream or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileOutputStream" c:type="GFileOutputStream*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21593">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21594">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21593">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21594">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="create_readwrite" c:identifier="g_file_create_readwrite" version="2.22" throws="1" gs:dll-name="gio-2.0" gs:managed-name="CreateReadwrite" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="21605">Creates a new file and returns a stream for reading and
writing to it. The file must not already exist.

By default files created are generally readable by everyone,
but if you pass #G_FILE_CREATE_PRIVATE in @flags the file
will be made readable only to the current user, to the level
that is supported on the target filesystem.

If @cancellable is not %NULL, then the operation can be cancelled
by triggering the cancellable object from another thread. If the
operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
returned.

If a file or directory with this name already exists, the
%G_IO_ERROR_EXISTS error will be returned. Some file systems don't
allow all file names, and may return an %G_IO_ERROR_INVALID_FILENAME
error, and if the name is too long, %G_IO_ERROR_FILENAME_TOO_LONG
will be returned. Other errors are possible too, and depend on what
kind of filesystem the file is on.

Note that in many non-local file cases read and write streams are
not supported, so make sure you really need to do read and write
streaming, rather than just opening for reading or writing.</doc>
        <source-position filename="gfile.h" line="741" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="21637">a #GFileIOStream for the newly created
    file, or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileIOStream" c:type="GFileIOStream*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21607">a #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21608">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21609">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21607">a #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21608">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21609">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="create_readwrite_async" c:identifier="g_file_create_readwrite_async" version="2.22" gs:dll-name="gio-2.0" gs:managed-name="CreateReadwriteAsync" gs:async="1" gs:async-finish="CreateReadwriteFinish" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="21644">Asynchronously creates a new file and returns a stream
for reading and writing to it. The file must not already exist.

For more details, see g_file_create_readwrite() which is
the synchronous version of this call.

When the operation is finished, @callback will be called.
You can then call g_file_create_readwrite_finish() to get
the result of the operation.</doc>
        <source-position filename="gfile.h" line="746" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Threading.Tasks.Task">
            <type name="FileIOStream" c:type="GFileIOStream*" gs:is-pointer="1" />
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21646">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21647">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21648">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21649">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21651">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21653">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21646">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21647">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21648">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21649">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="create_readwrite_finish" c:identifier="g_file_create_readwrite_finish" version="2.22" throws="1" gs:dll-name="gio-2.0" gs:managed-name="CreateReadwriteFinish" gs:pinvoke-only="1" gs:finish-for="create_readwrite_async" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="21669">Finishes an asynchronous file create operation started with
g_file_create_readwrite_async().</doc>
        <source-position filename="gfile.h" line="753" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="21678">a #GFileIOStream or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileIOStream" c:type="GFileIOStream*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21671">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21672">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21671">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21672">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="delete" c:identifier="g_file_delete" throws="1" gs:dll-name="gio-2.0" gs:managed-name="Delete" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="21684">Deletes a file. If the @file is a directory, it will only be
deleted if it is empty. This has the same semantics as g_unlink().

If @file doesn’t exist, %G_IO_ERROR_NOT_FOUND will be returned. This allows
for deletion to be implemented avoiding
[time-of-check to time-of-use races](https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use):
|[
g_autoptr(GError) local_error = NULL;
if (!g_file_delete (my_file, my_cancellable, &amp;local_error) &amp;&amp;
    !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))
  {
    // deletion failed for some reason other than the file not existing:
    // so report the error
    g_warning ("Failed to delete %s: %s",
               g_file_peek_path (my_file), local_error-&gt;message);
  }
]|

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <source-position filename="gfile.h" line="866" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="21713">%TRUE if the file was deleted. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21686">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21687">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21686">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21687">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="delete_async" c:identifier="g_file_delete_async" version="2.34" gs:dll-name="gio-2.0" gs:managed-name="DeleteAsync" gs:async="1" gs:async-finish="DeleteFinish" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="21717">Asynchronously delete a file. If the @file is a directory, it will
only be deleted if it is empty.  This has the same semantics as
g_unlink().</doc>
        <source-position filename="gfile.h" line="871" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Threading.Tasks.Task" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21719">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21720">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21721">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21723">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21725">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21719">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21720">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21721">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="delete_finish" c:identifier="g_file_delete_finish" version="2.34" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DeleteFinish" gs:pinvoke-only="1" gs:finish-for="delete_async" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="21735">Finishes deleting a file started with g_file_delete_async().</doc>
        <source-position filename="gfile.h" line="878" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="21743">%TRUE if the file was deleted. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21737">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21738">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21737">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21738">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="dup" c:identifier="g_file_dup" gs:dll-name="gio-2.0" gs:managed-name="Dup" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="21759">Duplicates a #GFile handle. This operation does not duplicate
the actual file or directory represented by the #GFile; see
g_file_copy() if attempting to copy a file.

g_file_dup() is useful when a second handle is needed to the same underlying
file, for use in a separate thread (#GFile is not thread-safe). For use
within the same thread, use g_object_ref() to increment the existing object’s
reference count.

This call does no blocking I/O.</doc>
        <source-position filename="gfile.h" line="616" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="21774">a new #GFile that is a duplicate
    of the given #GFile.</doc>
          <type name="File" c:type="GFile*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21761">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21761">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="eject_mountable_finish" c:identifier="g_file_eject_mountable_finish" deprecated="1" deprecated-version="2.22" throws="1" gs:dll-name="gio-2.0" gs:managed-name="EjectMountableFinish" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="21802">Finishes an asynchronous eject operation started by
g_file_eject_mountable().</doc>
        <doc-deprecated xml:space="preserve">Use g_file_eject_mountable_with_operation_finish()
    instead.</doc-deprecated>
        <source-position filename="gfile.h" line="1082" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="21811">%TRUE if the @file was ejected successfully.
    %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21804">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21805">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21804">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21805">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="eject_mountable_with_operation_finish" c:identifier="g_file_eject_mountable_with_operation_finish" version="2.22" throws="1" gs:dll-name="gio-2.0" gs:managed-name="EjectMountableWithOperationFinish" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="21843">Finishes an asynchronous eject operation started by
g_file_eject_mountable_with_operation().</doc>
        <source-position filename="gfile.h" line="1093" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="21852">%TRUE if the @file was ejected successfully.
    %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21845">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21846">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21845">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21846">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="equal" c:identifier="g_file_equal" gs:dll-name="gio-2.0" gs:managed-name="Equals" gs:equal="1" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22175">Checks if the two given #GFiles refer to the same file.

Note that two #GFiles that differ can still refer to the same
file on the filesystem due to various forms of filename
aliasing.

This call does no blocking I/O.</doc>
        <source-position filename="gfile.h" line="620" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22188">%TRUE if @file1 and @file2 are equal.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file1" transfer-ownership="none" gs:managed-name="file1" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22177">the first #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="file2" transfer-ownership="none" gs:managed-name="file2" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22178">the second #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file1" transfer-ownership="none" gs:managed-name="file1" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22177">the first #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="file2" transfer-ownership="none" gs:managed-name="file2" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22178">the second #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_basename" c:identifier="g_file_get_basename" gs:dll-name="gio-2.0" gs:managed-name="GetBasename" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22250">Gets the base name (the last component of the path) for a given #GFile.

If called for the top level of a system (such as the filesystem root
or a uri like sftp://host/) it will return a single directory separator
(and on Windows, possibly a drive letter).

The base name is a byte string (not UTF-8). It has no defined encoding
or rules other than it may not contain zero bytes.  If you want to use
filenames in a user interface you should use the display name that you
can get by requesting the %G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME
attribute with g_file_query_info().

This call does no blocking I/O.</doc>
        <source-position filename="gfile.h" line="623" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22268">string containing the #GFile's
    base name, or %NULL if given #GFile is invalid. The returned string
    should be freed with g_free() when no longer needed.</doc>
          <type name="filename" c:type="char*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22252">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22252">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_child" c:identifier="g_file_get_child" gs:dll-name="gio-2.0" gs:managed-name="GetChild" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22274">Gets a child of @file with basename equal to @name.

Note that the file with that specific name might not exist, but
you can still have a #GFile that points to it. You can use this
for instance to create that file.

This call does no blocking I/O.</doc>
        <source-position filename="gfile.h" line="638" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22287">a #GFile to a child specified by @name.
    Free the returned object with g_object_unref().</doc>
          <type name="File" c:type="GFile*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22276">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22277">string containing the child's basename</doc>
            <type name="filename" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22276">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22277">string containing the child's basename</doc>
            <type name="filename" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_child_for_display_name" c:identifier="g_file_get_child_for_display_name" throws="1" gs:dll-name="gio-2.0" gs:managed-name="GetChildForDisplayName" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22292">Gets the child of @file for a given @display_name (i.e. a UTF-8
version of the name). If this function fails, it returns %NULL
and @error will be set. This is very useful when constructing a
#GFile for a new file and the user entered the filename in the
user interface, for instance when you select a directory and
type a filename in the file selector.

This call does no blocking I/O.</doc>
        <source-position filename="gfile.h" line="641" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22307">a #GFile to the specified child, or
    %NULL if the display name couldn't be converted.
    Free the returned object with g_object_unref().</doc>
          <type name="File" c:type="GFile*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22294">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="display_name" transfer-ownership="none" gs:managed-name="displayName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22295">string to a possible child</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22294">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="display_name" transfer-ownership="none" gs:managed-name="displayName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22295">string to a possible child</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_parent" c:identifier="g_file_get_parent" gs:dll-name="gio-2.0" gs:managed-name="GetParent" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22313">Gets the parent directory for the @file.
If the @file represents the root directory of the
file system, then %NULL will be returned.

This call does no blocking I/O.</doc>
        <source-position filename="gfile.h" line="633" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22323">a #GFile structure to the
    parent of the given #GFile or %NULL if there is no parent. Free
    the returned object with g_object_unref().</doc>
          <type name="File" c:type="GFile*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22315">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22315">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_parse_name" c:identifier="g_file_get_parse_name" gs:dll-name="gio-2.0" gs:managed-name="GetParseName" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22329">Gets the parse name of the @file.
A parse name is a UTF-8 string that describes the
file such that one can get the #GFile back using
g_file_parse_name().

This is generally used to show the #GFile as a nice
full-pathname kind of string in a user interface,
like in a location entry.

For local files with names that can safely be converted
to UTF-8 the pathname is used, otherwise the IRI is used
(a form of URI that allows UTF-8 characters unescaped).

This call does no blocking I/O.</doc>
        <source-position filename="gfile.h" line="631" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22348">a string containing the #GFile's parse name.
    The returned string should be freed with g_free()
    when no longer needed.</doc>
          <type name="utf8" c:type="char*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22331">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22331">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_path" c:identifier="g_file_get_path" gs:dll-name="gio-2.0" gs:managed-name="GetPath" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22354">Gets the local pathname for #GFile, if one exists. If non-%NULL, this is
guaranteed to be an absolute, canonical path. It might contain symlinks.

This call does no blocking I/O.</doc>
        <source-position filename="gfile.h" line="625" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22363">string containing the #GFile's path,
    or %NULL if no such path exists. The returned string should be freed
    with g_free() when no longer needed.</doc>
          <type name="filename" c:type="char*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22356">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22356">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_relative_path" c:identifier="g_file_get_relative_path" gs:dll-name="gio-2.0" gs:managed-name="GetRelativePath" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22369">Gets the path for @descendant relative to @parent.

This call does no blocking I/O.</doc>
        <source-position filename="gfile.h" line="648" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22378">string with the relative path from
    @descendant to @parent, or %NULL if @descendant doesn't have @parent as
    prefix. The returned string should be freed with g_free() when
    no longer needed.</doc>
          <type name="filename" c:type="char*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="parent" transfer-ownership="none" gs:managed-name="parent" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22371">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="descendant" transfer-ownership="none" gs:managed-name="descendant" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22372">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="parent" transfer-ownership="none" gs:managed-name="parent" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22371">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="descendant" transfer-ownership="none" gs:managed-name="descendant" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22372">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_uri" c:identifier="g_file_get_uri" gs:dll-name="gio-2.0" gs:managed-name="GetUri" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22385">Gets the URI for the @file.

This call does no blocking I/O.</doc>
        <source-position filename="gfile.h" line="629" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22393">a string containing the #GFile's URI. If the #GFile was constructed
    with an invalid URI, an invalid URI is returned.
    The returned string should be freed with g_free()
    when no longer needed.</doc>
          <type name="utf8" c:type="char*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22387">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22387">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_uri_scheme" c:identifier="g_file_get_uri_scheme" gs:dll-name="gio-2.0" gs:managed-name="GetUriScheme" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22400">Gets the URI scheme for a #GFile.
RFC 3986 decodes the scheme as:
|[
URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
]|
Common schemes include "file", "http", "ftp", etc.

The scheme can be different from the one used to construct the #GFile,
in that it might be replaced with one that is logically equivalent to the #GFile.

This call does no blocking I/O.</doc>
        <source-position filename="gfile.h" line="659" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22416">a string containing the URI scheme for the given
    #GFile or %NULL if the #GFile was constructed with an invalid URI. The
    returned string should be freed with g_free() when no longer needed.</doc>
          <type name="utf8" c:type="char*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22402">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22402">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="has_parent" c:identifier="g_file_has_parent" version="2.24" gs:dll-name="gio-2.0" gs:managed-name="HasParent" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22422">Checks if @file has a parent, and optionally, if it is @parent.

If @parent is %NULL then this function returns %TRUE if @file has any
parent at all.  If @parent is non-%NULL then %TRUE is only returned
if @file is an immediate child of @parent.</doc>
        <source-position filename="gfile.h" line="635" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22433">%TRUE if @file is an immediate child of @parent (or any parent in
         the case that @parent is %NULL).</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22424">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="parent" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="parent" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22425">the parent to check for, or %NULL</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22424">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="parent" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="parent" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22425">the parent to check for, or %NULL</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="has_prefix" c:identifier="g_file_has_prefix" gs:dll-name="gio-2.0" gs:managed-name="HasPrefix" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22439">Checks whether @file has the prefix specified by @prefix.

In other words, if the names of initial elements of @file's
pathname match @prefix. Only full pathname elements are matched,
so a path like /foo is not considered a prefix of /foobar, only
of /foo/bar.

A #GFile is not a prefix of itself. If you want to check for
equality, use g_file_equal().

This call does no I/O, as it works purely on names. As such it can
sometimes return %FALSE even if @file is inside a @prefix (from a
filesystem point of view), because the prefix of @file is an alias
of @prefix.</doc>
        <source-position filename="gfile.h" line="645" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22459">%TRUE if the @file's parent, grandparent, etc is @prefix,
    %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22441">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="prefix" transfer-ownership="none" gs:managed-name="prefix" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22442">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22441">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="prefix" transfer-ownership="none" gs:managed-name="prefix" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22442">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="has_uri_scheme" c:identifier="g_file_has_uri_scheme" gs:dll-name="gio-2.0" gs:managed-name="HasUriScheme" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22464">Checks to see if a #GFile has a given URI scheme.

This call does no blocking I/O.</doc>
        <source-position filename="gfile.h" line="656" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22473">%TRUE if #GFile's backend supports the
    given URI scheme, %FALSE if URI scheme is %NULL,
    not supported, or #GFile is invalid.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22466">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="uri_scheme" transfer-ownership="none" gs:managed-name="uriScheme" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22467">a string containing a URI scheme</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22466">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="uri_scheme" transfer-ownership="none" gs:managed-name="uriScheme" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22467">a string containing a URI scheme</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="hash" c:identifier="g_file_hash" gs:dll-name="gio-2.0" gs:managed-name="GetHashCode" gs:hash="1" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22479">Creates a hash value for a #GFile.

This call does no blocking I/O.</doc>
        <source-position filename="gfile.h" line="618" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22487">0 if @file is not a valid #GFile, otherwise an
    integer that can be used as hash value for the #GFile.
    This function is intended for easily hashing a #GFile to
    add to a #GHashTable or similar data structure.</doc>
          <type name="guint" c:type="guint" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22481">#gconstpointer to a #GFile</doc>
            <type name="File" c:type="gconstpointer" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22481">#gconstpointer to a #GFile</doc>
            <type name="File" c:type="gconstpointer" gs:is-pointer="1" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="is_native" c:identifier="g_file_is_native" gs:dll-name="gio-2.0" gs:managed-name="IsNative" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23392">Checks to see if a file is native to the platform.

A native file is one expressed in the platform-native filename format,
e.g. "C:\Windows" or "/usr/bin/". This does not mean the file is local,
as it might be on a locally mounted remote filesystem.

On some systems non-native files may be available using the native
filesystem via a userspace filesystem (FUSE), in these cases this call
will return %FALSE, but g_file_get_path() will still return a native path.

This call does no blocking I/O.</doc>
        <source-position filename="gfile.h" line="654" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="23408">%TRUE if @file is native</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23394">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23394">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="load_bytes" c:identifier="g_file_load_bytes" version="2.56" throws="1" gs:dll-name="gio-2.0" gs:managed-name="LoadBytes" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23412">Loads the contents of @file and returns it as #GBytes.

If @file is a resource:// based URI, the resulting bytes will reference the
embedded resource instead of a copy. Otherwise, this is equivalent to calling
g_file_load_contents() and g_bytes_new_take().

For resources, @etag_out will be set to %NULL.

The data contained in the resulting #GBytes is always zero-terminated, but
this is not included in the #GBytes length. The resulting #GBytes should be
freed with g_bytes_unref() when no longer in use.</doc>
        <source-position filename="gfile.h" line="1271" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="23432">a #GBytes or %NULL and @error is set</doc>
          <type name="GLib.Bytes" c:type="GBytes*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23414">a #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23415">a #GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="etag_out" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1" gs:managed-name="etagOut">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23416">a location to place the current
    entity tag for the file, or %NULL if the entity tag is not needed</doc>
            <type name="utf8" c:type="gchar**" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23414">a #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="etag_out" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1" gs:managed-name="etagOut">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23416">a location to place the current
    entity tag for the file, or %NULL if the entity tag is not needed</doc>
            <type name="utf8" c:type="gchar**" gs:is-pointer="1" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23415">a #GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="load_bytes_async" c:identifier="g_file_load_bytes_async" version="2.56" gs:dll-name="gio-2.0" gs:managed-name="LoadBytesAsync" gs:async="1" gs:async-finish="LoadBytesFinish" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23437">Asynchronously loads the contents of @file as #GBytes.

If @file is a resource:// based URI, the resulting bytes will reference the
embedded resource instead of a copy. Otherwise, this is equivalent to calling
g_file_load_contents_async() and g_bytes_new_take().

@callback should call g_file_load_bytes_finish() to get the result of this
asynchronous operation.

See g_file_load_bytes() for more information.</doc>
        <source-position filename="gfile.h" line="1276" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Threading.Tasks.Task">
            <type name="GLib.Bytes" c:type="GBytes*" gs:is-pointer="1" />
            <type name="utf8" c:type="gchar**" gs:is-pointer="1" />
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23439">a #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23440">a #GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="2" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23441">a #GAsyncReadyCallback to call when the
    request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23443">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23439">a #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23440">a #GCancellable or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="load_bytes_finish" c:identifier="g_file_load_bytes_finish" version="2.56" throws="1" gs:dll-name="gio-2.0" gs:managed-name="LoadBytesFinish" gs:pinvoke-only="1" gs:finish-for="load_bytes_async" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23460">Completes an asynchronous request to g_file_load_bytes_async().

For resources, @etag_out will be set to %NULL.

The data contained in the resulting #GBytes is always zero-terminated, but
this is not included in the #GBytes length. The resulting #GBytes should be
freed with g_bytes_unref() when no longer in use.

See g_file_load_bytes() for more information.</doc>
        <source-position filename="gfile.h" line="1281" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="23478">a #GBytes or %NULL and @error is set</doc>
          <type name="GLib.Bytes" c:type="GBytes*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23462">a #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23463">a #GAsyncResult provided to the callback</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <parameter name="etag_out" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1" gs:managed-name="etagOut">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23464">a location to place the current
    entity tag for the file, or %NULL if the entity tag is not needed</doc>
            <type name="utf8" c:type="gchar**" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23462">a #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23463">a #GAsyncResult provided to the callback</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <parameter name="etag_out" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1" gs:managed-name="etagOut">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23464">a location to place the current
    entity tag for the file, or %NULL if the entity tag is not needed</doc>
            <type name="utf8" c:type="gchar**" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="load_contents" c:identifier="g_file_load_contents" throws="1" gs:dll-name="gio-2.0" gs:managed-name="LoadContents" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23483">Loads the content of the file into memory. The data is always
zero-terminated, but this is not included in the resultant @length.
The returned @contents should be freed with g_free() when no longer
needed.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <source-position filename="gfile.h" line="1201" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="23503">%TRUE if the @file's contents were successfully loaded.
    %FALSE if there were errors.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23485">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23486">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="contents" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="contents">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23487">a location to place the contents of the file</doc>
            <array length="2" zero-terminated="0" c:type="char**" gs:is-pointer="1">
              <type name="guint8" />
            </array>
          </parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="length">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23488">a location to place the length of the contents of the file,
   or %NULL if the length is not needed</doc>
            <type name="gsize" c:type="gsize*" />
          </parameter>
          <parameter name="etag_out" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1" gs:managed-name="etagOut">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23490">a location to place the current entity tag for the file,
   or %NULL if the entity tag is not needed</doc>
            <type name="utf8" c:type="char**" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23485">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="contents" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="contents">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23487">a location to place the contents of the file</doc>
            <array length="2" zero-terminated="0" c:type="char**" gs:is-pointer="1">
              <type name="guint8" />
            </array>
          </parameter>
          <parameter name="etag_out" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1" gs:managed-name="etagOut">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23490">a location to place the current entity tag for the file,
   or %NULL if the entity tag is not needed</doc>
            <type name="utf8" c:type="char**" gs:is-pointer="1" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23486">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="load_contents_async" c:identifier="g_file_load_contents_async" gs:dll-name="gio-2.0" gs:managed-name="LoadContentsAsync" gs:async="1" gs:async-finish="LoadContentsFinish" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23508">Starts an asynchronous load of the @file's contents.

For more details, see g_file_load_contents() which is
the synchronous version of this call.

When the load operation has completed, @callback will be called
with @user data. To finish the operation, call
g_file_load_contents_finish() with the #GAsyncResult returned by
the @callback.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <source-position filename="gfile.h" line="1208" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Threading.Tasks.Task">
            <array length="2" zero-terminated="0" c:type="char**" gs:is-pointer="1">
              <type name="guint8" />
            </array>
            <type name="utf8" c:type="char**" gs:is-pointer="1" />
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23510">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23511">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="2" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23512">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23513">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23510">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23511">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="load_contents_finish" c:identifier="g_file_load_contents_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="LoadContentsFinish" gs:pinvoke-only="1" gs:finish-for="load_contents_async" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23531">Finishes an asynchronous load of the @file's contents.
The contents are placed in @contents, and @length is set to the
size of the @contents string. The @contents should be freed with
g_free() when no longer needed. If @etag_out is present, it will be
set to the new entity tag for the @file.</doc>
        <source-position filename="gfile.h" line="1213" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="23548">%TRUE if the load was successful. If %FALSE and @error is
    present, it will be set appropriately.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23533">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23534">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <parameter name="contents" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="contents">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23535">a location to place the contents of the file</doc>
            <array length="2" zero-terminated="0" c:type="char**" gs:is-pointer="1">
              <type name="guint8" />
            </array>
          </parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="length">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23536">a location to place the length of the contents of the file,
    or %NULL if the length is not needed</doc>
            <type name="gsize" c:type="gsize*" />
          </parameter>
          <parameter name="etag_out" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1" gs:managed-name="etagOut">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23538">a location to place the current entity tag for the file,
    or %NULL if the entity tag is not needed</doc>
            <type name="utf8" c:type="char**" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23533">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23534">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <parameter name="contents" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="contents">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23535">a location to place the contents of the file</doc>
            <array length="2" zero-terminated="0" c:type="char**" gs:is-pointer="1">
              <type name="guint8" />
            </array>
          </parameter>
          <parameter name="etag_out" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1" gs:managed-name="etagOut">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23538">a location to place the current entity tag for the file,
    or %NULL if the entity tag is not needed</doc>
            <type name="utf8" c:type="char**" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="load_partial_contents_finish" c:identifier="g_file_load_partial_contents_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="LoadPartialContentsFinish" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23578">Finishes an asynchronous partial load operation that was started
with g_file_load_partial_contents_async(). The data is always
zero-terminated, but this is not included in the resultant @length.
The returned @contents should be freed with g_free() when no longer
needed.</doc>
        <source-position filename="gfile.h" line="1226" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="23595">%TRUE if the load was successful. If %FALSE and @error is
    present, it will be set appropriately.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23580">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23581">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <parameter name="contents" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="contents">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23582">a location to place the contents of the file</doc>
            <array length="2" zero-terminated="0" c:type="char**" gs:is-pointer="1">
              <type name="guint8" />
            </array>
          </parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="length">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23583">a location to place the length of the contents of the file,
    or %NULL if the length is not needed</doc>
            <type name="gsize" c:type="gsize*" />
          </parameter>
          <parameter name="etag_out" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1" gs:managed-name="etagOut">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23585">a location to place the current entity tag for the file,
    or %NULL if the entity tag is not needed</doc>
            <type name="utf8" c:type="char**" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23580">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23581">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <parameter name="contents" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="contents">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23582">a location to place the contents of the file</doc>
            <array length="2" zero-terminated="0" c:type="char**" gs:is-pointer="1">
              <type name="guint8" />
            </array>
          </parameter>
          <parameter name="etag_out" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1" gs:managed-name="etagOut">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23585">a location to place the current entity tag for the file,
    or %NULL if the entity tag is not needed</doc>
            <type name="utf8" c:type="char**" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="make_directory" c:identifier="g_file_make_directory" throws="1" gs:dll-name="gio-2.0" gs:managed-name="MakeDirectory" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23600">Creates a directory. Note that this will only create a child directory
of the immediate parent directory of the path or URI given by the #GFile.
To recursively create directories, see g_file_make_directory_with_parents().
This function will fail if the parent directory does not exist, setting
@error to %G_IO_ERROR_NOT_FOUND. If the file system doesn't support
creating directories, this function will fail, setting @error to
%G_IO_ERROR_NOT_SUPPORTED.

For a local #GFile the newly created directory will have the default
(current) ownership and permissions of the current process.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <source-position filename="gfile.h" line="930" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="23622">%TRUE on successful creation, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23602">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23603">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23602">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23603">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="make_directory_async" c:identifier="g_file_make_directory_async" version="2.38" gs:dll-name="gio-2.0" gs:managed-name="MakeDirectoryAsync" gs:async="1" gs:async-finish="MakeDirectoryFinish" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23626">Asynchronously creates a directory.</doc>
        <source-position filename="gfile.h" line="934" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Threading.Tasks.Task" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23628">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23629">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23630">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23632">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23634">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23628">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23629">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23630">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="make_directory_finish" c:identifier="g_file_make_directory_finish" version="2.38" throws="1" gs:dll-name="gio-2.0" gs:managed-name="MakeDirectoryFinish" gs:pinvoke-only="1" gs:finish-for="make_directory_async" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23642">Finishes an asynchronous directory creation, started with
g_file_make_directory_async().</doc>
        <source-position filename="gfile.h" line="940" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="23651">%TRUE on successful directory creation, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23644">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23645">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23644">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23645">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="make_directory_with_parents" c:identifier="g_file_make_directory_with_parents" version="2.18" throws="1" gs:dll-name="gio-2.0" gs:managed-name="MakeDirectoryWithParents" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23656">Creates a directory and any parent directories that may not
exist similar to 'mkdir -p'. If the file system does not support
creating directories, this function will fail, setting @error to
%G_IO_ERROR_NOT_SUPPORTED. If the directory itself already exists,
this function will fail setting @error to %G_IO_ERROR_EXISTS, unlike
the similar g_mkdir_with_parents().

For a local #GFile the newly created directories will have the default
(current) ownership and permissions of the current process.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <source-position filename="gfile.h" line="945" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="23677">%TRUE if all directories have been successfully created, %FALSE
otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23658">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23659">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23658">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23659">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="make_symbolic_link" c:identifier="g_file_make_symbolic_link" throws="1" gs:dll-name="gio-2.0" gs:managed-name="MakeSymbolicLink" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23683">Creates a symbolic link named @file which contains the string
@symlink_value.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <source-position filename="gfile.h" line="949" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="23699">%TRUE on the creation of a new symlink, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23685">a #GFile with the name of the symlink to create</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="symlink_value" transfer-ownership="none" gs:managed-name="symlinkValue" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23686">a string with the path for the target
    of the new symlink</doc>
            <type name="filename" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23688">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23685">a #GFile with the name of the symlink to create</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="symlink_value" transfer-ownership="none" gs:managed-name="symlinkValue" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23686">a string with the path for the target
    of the new symlink</doc>
            <type name="filename" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23688">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="measure_disk_usage_finish" c:identifier="g_file_measure_disk_usage_finish" version="2.38" throws="1" gs:dll-name="gio-2.0" gs:managed-name="MeasureDiskUsageFinish" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23760">Collects the results from an earlier call to
g_file_measure_disk_usage_async().  See g_file_measure_disk_usage() for
more information.</doc>
        <source-position filename="gfile.h" line="1143" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="23773">%TRUE if successful, with the out parameters set.
         %FALSE otherwise, with @error set.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23762">a #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23763">the #GAsyncResult passed to your #GAsyncReadyCallback</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <parameter name="disk_usage" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="diskUsage">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23764">the number of bytes of disk space used</doc>
            <type name="guint64" c:type="guint64*" />
          </parameter>
          <parameter name="num_dirs" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="numDirs">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23765">the number of directories encountered</doc>
            <type name="guint64" c:type="guint64*" />
          </parameter>
          <parameter name="num_files" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="numFiles">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23766">the number of non-directories encountered</doc>
            <type name="guint64" c:type="guint64*" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23762">a #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23763">the #GAsyncResult passed to your #GAsyncReadyCallback</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <parameter name="disk_usage" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="diskUsage">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23764">the number of bytes of disk space used</doc>
            <type name="guint64" c:type="guint64*" />
          </parameter>
          <parameter name="num_dirs" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="numDirs">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23765">the number of directories encountered</doc>
            <type name="guint64" c:type="guint64*" />
          </parameter>
          <parameter name="num_files" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="numFiles">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23766">the number of non-directories encountered</doc>
            <type name="guint64" c:type="guint64*" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="mount_enclosing_volume_finish" c:identifier="g_file_mount_enclosing_volume_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="MountEnclosingVolumeFinish" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23930">Finishes a mount operation started by g_file_mount_enclosing_volume().</doc>
        <source-position filename="gfile.h" line="1038" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="23938">%TRUE if successful. If an error has occurred,
    this function will return %FALSE and set @error
    appropriately if present.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="location" transfer-ownership="none" gs:managed-name="location" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23932">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23933">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="location" transfer-ownership="none" gs:managed-name="location" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23932">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23933">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="mount_mountable_finish" c:identifier="g_file_mount_mountable_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="MountMountableFinish" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23970">Finishes a mount operation. See g_file_mount_mountable() for details.

Finish an asynchronous mount operation that was started
with g_file_mount_mountable().</doc>
        <source-position filename="gfile.h" line="1049" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="23981">a #GFile or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="File" c:type="GFile*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23972">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23973">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23972">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23973">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="move" c:identifier="g_file_move" throws="1" gs:dll-name="gio-2.0" gs:managed-name="Move" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23986">Tries to move the file or directory @source to the location specified
by @destination. If native move operations are supported then this is
used, otherwise a copy + delete fallback is used. The native
implementation may support moving directories (for instance on moves
inside the same filesystem), but the fallback code does not.

If the flag #G_FILE_COPY_OVERWRITE is specified an already
existing @destination file is overwritten.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.

If @progress_callback is not %NULL, then the operation can be monitored
by setting this to a #GFileProgressCallback function.
@progress_callback_data will be passed to this function. It is
guaranteed that this callback will be called after all data has been
transferred with the total number of bytes copied during the operation.

If the @source file does not exist, then the %G_IO_ERROR_NOT_FOUND
error is returned, independent on the status of the @destination.

If #G_FILE_COPY_OVERWRITE is not specified and the target exists,
then the error %G_IO_ERROR_EXISTS is returned.

If trying to overwrite a file over a directory, the %G_IO_ERROR_IS_DIRECTORY
error is returned. If trying to overwrite a directory with a directory the
%G_IO_ERROR_WOULD_MERGE error is returned.

If the source is a directory and the target does not exist, or
#G_FILE_COPY_OVERWRITE is specified and the target is a file, then
the %G_IO_ERROR_WOULD_RECURSE error may be returned (if the native
move operation isn't available).</doc>
        <source-position filename="gfile.h" line="922" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="24033">%TRUE on successful move, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23988">#GFile pointing to the source location</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="destination" transfer-ownership="none" gs:managed-name="destination" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23989">#GFile pointing to the destination location</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23990">set of #GFileCopyFlags</doc>
            <type name="FileCopyFlags" c:type="GFileCopyFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23991">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="progress_callback" transfer-ownership="none" nullable="1" allow-none="1" scope="call" closure="4" gs:managed-name="progressCallback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23993">#GFileProgressCallback
    function for updates</doc>
            <type name="FileProgressCallback" c:type="GFileProgressCallback" />
          </parameter>
          <parameter name="progress_callback_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="progressCallbackData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23995">gpointer to user data for
    the callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23988">#GFile pointing to the source location</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="destination" transfer-ownership="none" gs:managed-name="destination" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23989">#GFile pointing to the destination location</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23990">set of #GFileCopyFlags</doc>
            <type name="FileCopyFlags" c:type="GFileCopyFlags" />
          </parameter>
          <parameter name="progress_callback" transfer-ownership="none" nullable="1" allow-none="1" scope="call" closure="4" gs:managed-name="progressCallback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23993">#GFileProgressCallback
    function for updates</doc>
            <type name="FileProgressCallback" c:type="GFileProgressCallback" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23991">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="open_readwrite" c:identifier="g_file_open_readwrite" version="2.22" throws="1" gs:dll-name="gio-2.0" gs:managed-name="OpenReadwrite" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24151">Opens an existing file for reading and writing. The result is
a #GFileIOStream that can be used to read and write the contents
of the file.

If @cancellable is not %NULL, then the operation can be cancelled
by triggering the cancellable object from another thread. If the
operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
returned.

If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will
be returned. If the file is a directory, the %G_IO_ERROR_IS_DIRECTORY
error will be returned. Other errors are possible too, and depend on
what kind of filesystem the file is on. Note that in many non-local
file cases read and write streams are not supported, so make sure you
really need to do read and write streaming, rather than just opening
for reading or writing.</doc>
        <source-position filename="gfile.h" line="727" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="24174">#GFileIOStream or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileIOStream" c:type="GFileIOStream*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24153">#GFile to open</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24154">a #GCancellable</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24153">#GFile to open</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24154">a #GCancellable</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="open_readwrite_async" c:identifier="g_file_open_readwrite_async" version="2.22" gs:dll-name="gio-2.0" gs:managed-name="OpenReadwriteAsync" gs:async="1" gs:async-finish="OpenReadwriteFinish" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24180">Asynchronously opens @file for reading and writing.

For more details, see g_file_open_readwrite() which is
the synchronous version of this call.

When the operation is finished, @callback will be called.
You can then call g_file_open_readwrite_finish() to get
the result of the operation.</doc>
        <source-position filename="gfile.h" line="731" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Threading.Tasks.Task">
            <type name="FileIOStream" c:type="GFileIOStream*" gs:is-pointer="1" />
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24182">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24183">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24184">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24186">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24188">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24182">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24183">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24184">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="open_readwrite_finish" c:identifier="g_file_open_readwrite_finish" version="2.22" throws="1" gs:dll-name="gio-2.0" gs:managed-name="OpenReadwriteFinish" gs:pinvoke-only="1" gs:finish-for="open_readwrite_async" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24203">Finishes an asynchronous file read operation started with
g_file_open_readwrite_async().</doc>
        <source-position filename="gfile.h" line="737" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="24212">a #GFileIOStream or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileIOStream" c:type="GFileIOStream*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24205">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24206">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24205">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24206">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="peek_path" c:identifier="g_file_peek_path" version="2.56" gs:dll-name="gio-2.0" gs:managed-name="PeekPath" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24303">Exactly like g_file_get_path(), but caches the result via
g_object_set_qdata_full().  This is useful for example in C
applications which mix `g_file_*` APIs with native ones.  It
also avoids an extra duplicated string when possible, so will be
generally more efficient.

This call does no blocking I/O.</doc>
        <source-position filename="gfile.h" line="627" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="24315">string containing the #GFile's path,
    or %NULL if no such path exists. The returned string is owned by @file.</doc>
          <type name="filename" c:type="const char*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24305">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24305">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="poll_mountable" c:identifier="g_file_poll_mountable" version="2.22" gs:dll-name="gio-2.0" gs:managed-name="PollMountable" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24321">Polls a file of type #G_FILE_TYPE_MOUNTABLE.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.

When the operation is finished, @callback will be called.
You can then call g_file_mount_mountable_finish() to get
the result of the operation.</doc>
        <source-position filename="gfile.h" line="1174" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24323">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24324">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="2" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24325">a #GAsyncReadyCallback to call
    when the request is satisfied, or %NULL</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24327">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24323">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="2" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24325">a #GAsyncReadyCallback to call
    when the request is satisfied, or %NULL</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24324">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="poll_mountable_finish" c:identifier="g_file_poll_mountable_finish" version="2.22" throws="1" gs:dll-name="gio-2.0" gs:managed-name="PollMountableFinish" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24343">Finishes a poll operation. See g_file_poll_mountable() for details.

Finish an asynchronous poll operation that was polled
with g_file_poll_mountable().</doc>
        <source-position filename="gfile.h" line="1179" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="24354">%TRUE if the operation finished successfully. %FALSE
otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24345">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24346">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24345">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24346">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="query_exists" c:identifier="g_file_query_exists" gs:dll-name="gio-2.0" gs:managed-name="QueryExists" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24408">Utility function to check if a particular file exists. This is
implemented using g_file_query_info() and as such does blocking I/O.

Note that in many cases it is [racy to first check for file existence](https://en.wikipedia.org/wiki/Time_of_check_to_time_of_use)
and then execute something based on the outcome of that, because the
file might have been created or removed in between the operations. The
general approach to handling that is to not check, but just do the
operation and handle the errors as they come.

As an example of race-free checking, take the case of reading a file,
and if it doesn't exist, creating it. There are two racy versions: read
it, and on error create it; and: check if it exists, if not create it.
These can both result in two processes creating the file (with perhaps
a partially written file as the result). The correct approach is to
always try to create the file with g_file_create() which will either
atomically create the file or fail with a %G_IO_ERROR_EXISTS error.

However, in many cases an existence check is useful in a user interface,
for instance to make a menu item sensitive/insensitive, so that you don't
have to fool users that something is possible and then just show an error
dialog. If you do this, you should make sure to also handle the errors
that can happen due to races when you execute the operation.</doc>
        <source-position filename="gfile.h" line="777" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="24437">%TRUE if the file exists (and can be detected without error),
    %FALSE otherwise (or if cancelled).</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24410">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24411">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24410">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24411">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="query_file_type" c:identifier="g_file_query_file_type" version="2.18" gs:dll-name="gio-2.0" gs:managed-name="QueryFileType" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24442">Utility function to inspect the #GFileType of a file. This is
implemented using g_file_query_info() and as such does blocking I/O.

The primary use case of this method is to check if a file is
a regular file, directory, or symlink.</doc>
        <source-position filename="gfile.h" line="780" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="24455">The #GFileType of the file and #G_FILE_TYPE_UNKNOWN
    if the file does not exist</doc>
          <type name="FileType" c:type="GFileType" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24444">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24445">a set of #GFileQueryInfoFlags passed to g_file_query_info()</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24446">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24444">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24445">a set of #GFileQueryInfoFlags passed to g_file_query_info()</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24446">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="query_filesystem_info" c:identifier="g_file_query_filesystem_info" throws="1" gs:dll-name="gio-2.0" gs:managed-name="QueryFilesystemInfo" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24461">Similar to g_file_query_info(), but obtains information
about the filesystem the @file is on, rather than the file itself.
For instance the amount of space available and the type of
the filesystem.

The @attributes value is a string that specifies the attributes
that should be gathered. It is not an error if it's not possible
to read a particular requested attribute from a file - it just
won't be set. @attributes should be a comma-separated list of
attributes or attribute wildcards. The wildcard "*" means all
attributes, and a wildcard like "filesystem::*" means all attributes
in the filesystem namespace. The standard namespace for filesystem
attributes is "filesystem". Common attributes of interest are
#G_FILE_ATTRIBUTE_FILESYSTEM_SIZE (the total size of the filesystem
in bytes), #G_FILE_ATTRIBUTE_FILESYSTEM_FREE (number of bytes available),
and #G_FILE_ATTRIBUTE_FILESYSTEM_TYPE (type of the filesystem).

If @cancellable is not %NULL, then the operation can be cancelled
by triggering the cancellable object from another thread. If the
operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
returned.

If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will
be returned. Other errors are possible too, and depend on what
kind of filesystem the file is on.</doc>
        <source-position filename="gfile.h" line="802" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="24495">a #GFileInfo or %NULL if there was an error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24463">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24464">an attribute query string</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24465">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24463">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24464">an attribute query string</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24465">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="query_filesystem_info_async" c:identifier="g_file_query_filesystem_info_async" gs:dll-name="gio-2.0" gs:managed-name="QueryFilesystemInfoAsync" gs:async="1" gs:async-finish="QueryFilesystemInfoFinish" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24500">Asynchronously gets the requested information about the filesystem
that the specified @file is on. The result is a #GFileInfo object
that contains key-value attributes (such as type or size for the
file).

For more details, see g_file_query_filesystem_info() which is the
synchronous version of this call.

When the operation is finished, @callback will be called. You can
then call g_file_query_info_finish() to get the result of the
operation.</doc>
        <source-position filename="gfile.h" line="807" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Threading.Tasks.Task">
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24502">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24503">an attribute query string</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24504">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24505">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24507">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24509">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24502">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24503">an attribute query string</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24504">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24505">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="query_filesystem_info_finish" c:identifier="g_file_query_filesystem_info_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="QueryFilesystemInfoFinish" gs:pinvoke-only="1" gs:finish-for="query_filesystem_info_async" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24525">Finishes an asynchronous filesystem info query.
See g_file_query_filesystem_info_async().</doc>
        <source-position filename="gfile.h" line="814" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="24534">#GFileInfo for given @file
    or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24527">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24528">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24527">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24528">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="query_info" c:identifier="g_file_query_info" throws="1" gs:dll-name="gio-2.0" gs:managed-name="QueryInfo" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24540">Gets the requested information about specified @file.
The result is a #GFileInfo object that contains key-value
attributes (such as the type or size of the file).

The @attributes value is a string that specifies the file
attributes that should be gathered. It is not an error if
it's not possible to read a particular requested attribute
from a file - it just won't be set. @attributes should be a
comma-separated list of attributes or attribute wildcards.
The wildcard "*" means all attributes, and a wildcard like
"standard::*" means all attributes in the standard namespace.
An example attribute query be "standard::*,owner::user".
The standard attributes are available as defines, like
#G_FILE_ATTRIBUTE_STANDARD_NAME.

If @cancellable is not %NULL, then the operation can be cancelled
by triggering the cancellable object from another thread. If the
operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
returned.

For symlinks, normally the information about the target of the
symlink is returned, rather than information about the symlink
itself. However if you pass #G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS
in @flags the information about the symlink itself will be returned.
Also, for symlinks that point to non-existing files the information
about the symlink itself will be returned.

If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will be
returned. Other errors are possible too, and depend on what kind of
filesystem the file is on.</doc>
        <source-position filename="gfile.h" line="784" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="24580">a #GFileInfo for the given @file, or %NULL
    on error. Free the returned object with g_object_unref().</doc>
          <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24542">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24543">an attribute query string</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24544">a set of #GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24545">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24542">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24543">an attribute query string</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24544">a set of #GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24545">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="query_info_async" c:identifier="g_file_query_info_async" gs:dll-name="gio-2.0" gs:managed-name="QueryInfoAsync" gs:async="1" gs:async-finish="QueryInfoFinish" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24585">Asynchronously gets the requested information about specified @file.
The result is a #GFileInfo object that contains key-value attributes
(such as type or size for the file).

For more details, see g_file_query_info() which is the synchronous
version of this call.

When the operation is finished, @callback will be called. You can
then call g_file_query_info_finish() to get the result of the operation.</doc>
        <source-position filename="gfile.h" line="790" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Threading.Tasks.Task">
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24587">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24588">an attribute query string</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24589">a set of #GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24590">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24591">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24593">a #GAsyncReadyCallback to call when the
    request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24595">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24587">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24588">an attribute query string</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24589">a set of #GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24590">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24591">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="query_info_finish" c:identifier="g_file_query_info_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="QueryInfoFinish" gs:pinvoke-only="1" gs:finish-for="query_info_async" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24609">Finishes an asynchronous file info query.
See g_file_query_info_async().</doc>
        <source-position filename="gfile.h" line="798" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="24618">#GFileInfo for given @file
    or %NULL on error. Free the returned object with
    g_object_unref().</doc>
          <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24611">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24612">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24611">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24612">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="query_settable_attributes" c:identifier="g_file_query_settable_attributes" throws="1" gs:dll-name="gio-2.0" gs:managed-name="QuerySettableAttributes" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24624">Obtain the list of settable attributes for the file.

Returns the type and full attribute name of all the attributes
that can be set on this file. This doesn't mean setting it will
always succeed though, you might get an access failure, or some
specific file may not support a specific attribute.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <source-position filename="gfile.h" line="954" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="24642">a #GFileAttributeInfoList describing the settable attributes.
    When you are done with it, release it with
    g_file_attribute_info_list_unref()</doc>
          <type name="FileAttributeInfoList" c:type="GFileAttributeInfoList*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24626">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24627">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24626">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24627">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="query_writable_namespaces" c:identifier="g_file_query_writable_namespaces" throws="1" gs:dll-name="gio-2.0" gs:managed-name="QueryWritableNamespaces" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24648">Obtain the list of attribute namespaces where new attributes
can be created by a user. An example of this is extended
attributes (in the "xattr" namespace).

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <source-position filename="gfile.h" line="958" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="24663">a #GFileAttributeInfoList describing the writable namespaces.
    When you are done with it, release it with
    g_file_attribute_info_list_unref()</doc>
          <type name="FileAttributeInfoList" c:type="GFileAttributeInfoList*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24650">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24651">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24650">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24651">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="read" c:identifier="g_file_read" throws="1" gs:dll-name="gio-2.0" gs:managed-name="Read" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24669">Opens a file for reading. The result is a #GFileInputStream that
can be used to read the contents of the file.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.

If the file does not exist, the %G_IO_ERROR_NOT_FOUND error will be
returned. If the file is a directory, the %G_IO_ERROR_IS_DIRECTORY
error will be returned. Other errors are possible too, and depend
on what kind of filesystem the file is on.</doc>
        <source-position filename="gfile.h" line="661" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="24687">#GFileInputStream or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileInputStream" c:type="GFileInputStream*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24671">#GFile to read</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24672">a #GCancellable</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24671">#GFile to read</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24672">a #GCancellable</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="read_async" c:identifier="g_file_read_async" gs:dll-name="gio-2.0" gs:managed-name="ReadAsync" gs:async="1" gs:async-finish="ReadFinish" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24692">Asynchronously opens @file for reading.

For more details, see g_file_read() which is
the synchronous version of this call.

When the operation is finished, @callback will be called.
You can then call g_file_read_finish() to get the result
of the operation.</doc>
        <source-position filename="gfile.h" line="665" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Threading.Tasks.Task">
            <type name="FileInputStream" c:type="GFileInputStream*" gs:is-pointer="1" />
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24694">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24695">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24696">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24698">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24700">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24694">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24695">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24696">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="read_finish" c:identifier="g_file_read_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="ReadFinish" gs:pinvoke-only="1" gs:finish-for="read_async" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24713">Finishes an asynchronous file read operation started with
g_file_read_async().</doc>
        <source-position filename="gfile.h" line="671" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="24722">a #GFileInputStream or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileInputStream" c:type="GFileInputStream*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24715">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24716">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24715">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24716">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="replace" c:identifier="g_file_replace" throws="1" gs:dll-name="gio-2.0" gs:managed-name="Replace" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24727">Returns an output stream for overwriting the file, possibly
creating a backup copy of the file first. If the file doesn't exist,
it will be created.

This will try to replace the file in the safest way possible so
that any errors during the writing will not affect an already
existing copy of the file. For instance, for local files it
may write to a temporary file and then atomically rename over
the destination when the stream is closed.

By default files created are generally readable by everyone,
but if you pass #G_FILE_CREATE_PRIVATE in @flags the file
will be made readable only to the current user, to the level that
is supported on the target filesystem.

If @cancellable is not %NULL, then the operation can be cancelled
by triggering the cancellable object from another thread. If the
operation was cancelled, the error %G_IO_ERROR_CANCELLED will be
returned.

If you pass in a non-%NULL @etag value and @file already exists, then
this value is compared to the current entity tag of the file, and if
they differ an %G_IO_ERROR_WRONG_ETAG error is returned. This
generally means that the file has been changed since you last read
it. You can get the new etag from g_file_output_stream_get_etag()
after you've finished writing and closed the #GFileOutputStream. When
you load a new file you can use g_file_input_stream_query_info() to
get the etag of the file.

If @make_backup is %TRUE, this function will attempt to make a
backup of the current file before overwriting it. If this fails
a %G_IO_ERROR_CANT_CREATE_BACKUP error will be returned. If you
want to replace anyway, try again with @make_backup set to %FALSE.

If the file is a directory the %G_IO_ERROR_IS_DIRECTORY error will
be returned, and if the file is some other form of non-regular file
then a %G_IO_ERROR_NOT_REGULAR_FILE error will be returned. Some
file systems don't allow all file names, and may return an
%G_IO_ERROR_INVALID_FILENAME error, and if the name is to long
%G_IO_ERROR_FILENAME_TOO_LONG will be returned. Other errors are
possible too, and depend on what kind of filesystem the file is on.</doc>
        <source-position filename="gfile.h" line="685" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="24780">a #GFileOutputStream or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileOutputStream" c:type="GFileOutputStream*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24729">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="etag" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="etag" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24730">an optional [entity tag][gfile-etag]
    for the current #GFile, or #NULL to ignore</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="make_backup" transfer-ownership="none" gs:managed-name="makeBackup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24732">%TRUE if a backup should be created</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24733">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24734">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24729">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="etag" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="etag" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24730">an optional [entity tag][gfile-etag]
    for the current #GFile, or #NULL to ignore</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="make_backup" transfer-ownership="none" gs:managed-name="makeBackup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24732">%TRUE if a backup should be created</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24733">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24734">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="replace_async" c:identifier="g_file_replace_async" gs:dll-name="gio-2.0" gs:managed-name="ReplaceAsync" gs:async="1" gs:async-finish="ReplaceFinish" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24785">Asynchronously overwrites the file, replacing the contents,
possibly creating a backup copy of the file first.

For more details, see g_file_replace() which is
the synchronous version of this call.

When the operation is finished, @callback will be called.
You can then call g_file_replace_finish() to get the result
of the operation.</doc>
        <source-position filename="gfile.h" line="714" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Threading.Tasks.Task">
            <type name="FileOutputStream" c:type="GFileOutputStream*" gs:is-pointer="1" />
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24787">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="etag" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="etag" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24788">an [entity tag][gfile-etag] for the current #GFile,
    or %NULL to ignore</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="make_backup" transfer-ownership="none" gs:managed-name="makeBackup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24790">%TRUE if a backup should be created</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24791">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24792">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24793">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="6" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24795">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24797">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24787">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="etag" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="etag" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24788">an [entity tag][gfile-etag] for the current #GFile,
    or %NULL to ignore</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="make_backup" transfer-ownership="none" gs:managed-name="makeBackup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24790">%TRUE if a backup should be created</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24791">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24792">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24793">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="replace_contents" c:identifier="g_file_replace_contents" throws="1" gs:dll-name="gio-2.0" gs:managed-name="ReplaceContents" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24811">Replaces the contents of @file with @contents of @length bytes.

If @etag is specified (not %NULL), any existing file must have that etag,
or the error %G_IO_ERROR_WRONG_ETAG will be returned.

If @make_backup is %TRUE, this function will attempt to make a backup
of @file. Internally, it uses g_file_replace(), so will try to replace the
file contents in the safest way possible. For example, atomic renames are
used when replacing local files’ contents.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.

The returned @new_etag can be used to verify that the file hasn't
changed the next time it is saved over.</doc>
        <source-position filename="gfile.h" line="1233" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="24843">%TRUE if successful. If an error has occurred, this function
    will return %FALSE and set @error appropriately if present.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24813">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="contents" transfer-ownership="none" gs:managed-name="contents" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24814">a string containing the new contents for @file</doc>
            <array length="1" zero-terminated="0" c:type="const char*" gs:is-pointer="1">
              <type name="guint8" />
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none" gs:managed-name="length" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24815">the length of @contents in bytes</doc>
            <type name="gsize" c:type="gsize" />
          </parameter>
          <parameter name="etag" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="etag" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24816">the old [entity-tag][gfile-etag] for the document,
    or %NULL</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="make_backup" transfer-ownership="none" gs:managed-name="makeBackup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24818">%TRUE if a backup should be created</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24819">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags" />
          </parameter>
          <parameter name="new_etag" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1" gs:managed-name="newEtag">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24820">a location to a new [entity tag][gfile-etag]
     for the document. This should be freed with g_free() when no longer
     needed, or %NULL</doc>
            <type name="utf8" c:type="char**" gs:is-pointer="1" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24823">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24813">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="contents" transfer-ownership="none" gs:managed-name="contents" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24814">a string containing the new contents for @file</doc>
            <array length="1" zero-terminated="0" c:type="const char*" gs:is-pointer="1">
              <type name="guint8" />
            </array>
          </parameter>
          <parameter name="etag" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="etag" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24816">the old [entity-tag][gfile-etag] for the document,
    or %NULL</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="make_backup" transfer-ownership="none" gs:managed-name="makeBackup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24818">%TRUE if a backup should be created</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24819">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags" />
          </parameter>
          <parameter name="new_etag" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1" gs:managed-name="newEtag">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24820">a location to a new [entity tag][gfile-etag]
     for the document. This should be freed with g_free() when no longer
     needed, or %NULL</doc>
            <type name="utf8" c:type="char**" gs:is-pointer="1" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24823">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="replace_contents_async" c:identifier="g_file_replace_contents_async" gs:dll-name="gio-2.0" gs:managed-name="ReplaceContentsAsync" gs:async="1" gs:async-finish="ReplaceContentsFinish" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24848">Starts an asynchronous replacement of @file with the given
@contents of @length bytes. @etag will replace the document's
current entity tag.

When this operation has completed, @callback will be called with
@user_user data, and the operation can be finalized with
g_file_replace_contents_finish().

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.

If @make_backup is %TRUE, this function will attempt to
make a backup of @file.

Note that no copy of @contents will be made, so it must stay valid
until @callback is called. See g_file_replace_contents_bytes_async()
for a #GBytes version that will automatically hold a reference to the
contents (without copying) for the duration of the call.</doc>
        <source-position filename="gfile.h" line="1243" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Threading.Tasks.Task">
            <type name="utf8" c:type="char**" gs:is-pointer="1" />
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24850">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="contents" transfer-ownership="none" gs:managed-name="contents" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24851">string of contents to replace the file with</doc>
            <array length="1" zero-terminated="0" c:type="const char*" gs:is-pointer="1">
              <type name="guint8" />
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none" gs:managed-name="length" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24852">the length of @contents in bytes</doc>
            <type name="gsize" c:type="gsize" />
          </parameter>
          <parameter name="etag" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="etag" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24853">a new [entity tag][gfile-etag] for the @file, or %NULL</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="make_backup" transfer-ownership="none" gs:managed-name="makeBackup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24854">%TRUE if a backup should be created</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24855">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24856">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="7" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24857">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24858">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24850">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="contents" transfer-ownership="none" gs:managed-name="contents" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24851">string of contents to replace the file with</doc>
            <array length="1" zero-terminated="0" c:type="const char*" gs:is-pointer="1">
              <type name="guint8" />
            </array>
          </parameter>
          <parameter name="etag" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="etag" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24853">a new [entity tag][gfile-etag] for the @file, or %NULL</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="make_backup" transfer-ownership="none" gs:managed-name="makeBackup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24854">%TRUE if a backup should be created</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24855">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24856">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="replace_contents_async" c:identifier="g_file_replace_contents_bytes_async" version="2.40" gs:dll-name="gio-2.0" gs:managed-name="ReplaceContentsAsync" gs:async="1" gs:async-finish="ReplaceContentsFinish" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24882">Same as g_file_replace_contents_async() but takes a #GBytes input instead.
This function will keep a ref on @contents until the operation is done.
Unlike g_file_replace_contents_async() this allows forgetting about the
content without waiting for the callback.

When this operation has completed, @callback will be called with
@user_user data, and the operation can be finalized with
g_file_replace_contents_finish().</doc>
        <source-position filename="gfile.h" line="1253" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Threading.Tasks.Task">
            <type name="utf8" c:type="char**" gs:is-pointer="1" />
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24884">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="contents" transfer-ownership="none" gs:managed-name="contents" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24885">a #GBytes</doc>
            <type name="GLib.Bytes" c:type="GBytes*" gs:is-pointer="1" />
          </parameter>
          <parameter name="etag" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="etag" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24886">a new [entity tag][gfile-etag] for the @file, or %NULL</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="make_backup" transfer-ownership="none" gs:managed-name="makeBackup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24887">%TRUE if a backup should be created</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24888">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24889">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="6" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24890">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24891">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24884">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="contents" transfer-ownership="none" gs:managed-name="contents" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24885">a #GBytes</doc>
            <type name="GLib.Bytes" c:type="GBytes*" gs:is-pointer="1" />
          </parameter>
          <parameter name="etag" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="etag" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24886">a new [entity tag][gfile-etag] for the @file, or %NULL</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="make_backup" transfer-ownership="none" gs:managed-name="makeBackup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24887">%TRUE if a backup should be created</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24888">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24889">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="replace_contents_finish" c:identifier="g_file_replace_contents_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="ReplaceContentsFinish" gs:pinvoke-only="1" gs:finish-for="replace_contents_async" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24906">Finishes an asynchronous replace of the given @file. See
g_file_replace_contents_async(). Sets @new_etag to the new entity
tag for the document, if present.</doc>
        <source-position filename="gfile.h" line="1262" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="24919">%TRUE on success, %FALSE on failure.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24908">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24909">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <parameter name="new_etag" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1" gs:managed-name="newEtag">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24910">a location of a new [entity tag][gfile-etag]
    for the document. This should be freed with g_free() when it is no
    longer needed, or %NULL</doc>
            <type name="utf8" c:type="char**" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24908">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24909">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <parameter name="new_etag" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1" gs:managed-name="newEtag">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24910">a location of a new [entity tag][gfile-etag]
    for the document. This should be freed with g_free() when it is no
    longer needed, or %NULL</doc>
            <type name="utf8" c:type="char**" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="replace_finish" c:identifier="g_file_replace_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="ReplaceFinish" gs:pinvoke-only="1" gs:finish-for="replace_async" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24923">Finishes an asynchronous file replace operation started with
g_file_replace_async().</doc>
        <source-position filename="gfile.h" line="723" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="24932">a #GFileOutputStream, or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileOutputStream" c:type="GFileOutputStream*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24925">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24926">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24925">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24926">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="replace_readwrite" c:identifier="g_file_replace_readwrite" version="2.22" throws="1" gs:dll-name="gio-2.0" gs:managed-name="ReplaceReadwrite" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24937">Returns an output stream for overwriting the file in readwrite mode,
possibly creating a backup copy of the file first. If the file doesn't
exist, it will be created.

For details about the behaviour, see g_file_replace() which does the
same thing but returns an output stream only.

Note that in many non-local file cases read and write streams are not
supported, so make sure you really need to do read and write streaming,
rather than just opening for reading or writing.</doc>
        <source-position filename="gfile.h" line="757" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="24959">a #GFileIOStream or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileIOStream" c:type="GFileIOStream*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24939">a #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="etag" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="etag" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24940">an optional [entity tag][gfile-etag]
    for the current #GFile, or #NULL to ignore</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="make_backup" transfer-ownership="none" gs:managed-name="makeBackup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24942">%TRUE if a backup should be created</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24943">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24944">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24939">a #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="etag" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="etag" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24940">an optional [entity tag][gfile-etag]
    for the current #GFile, or #NULL to ignore</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="make_backup" transfer-ownership="none" gs:managed-name="makeBackup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24942">%TRUE if a backup should be created</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24943">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24944">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="replace_readwrite_async" c:identifier="g_file_replace_readwrite_async" version="2.22" gs:dll-name="gio-2.0" gs:managed-name="ReplaceReadwriteAsync" gs:async="1" gs:async-finish="ReplaceReadwriteFinish" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24965">Asynchronously overwrites the file in read-write mode,
replacing the contents, possibly creating a backup copy
of the file first.

For more details, see g_file_replace_readwrite() which is
the synchronous version of this call.

When the operation is finished, @callback will be called.
You can then call g_file_replace_readwrite_finish() to get
the result of the operation.</doc>
        <source-position filename="gfile.h" line="764" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Threading.Tasks.Task">
            <type name="FileIOStream" c:type="GFileIOStream*" gs:is-pointer="1" />
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24967">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="etag" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="etag" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24968">an [entity tag][gfile-etag] for the current #GFile,
    or %NULL to ignore</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="make_backup" transfer-ownership="none" gs:managed-name="makeBackup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24970">%TRUE if a backup should be created</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24971">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24972">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24973">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="6" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24975">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24977">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24967">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="etag" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="etag" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24968">an [entity tag][gfile-etag] for the current #GFile,
    or %NULL to ignore</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="make_backup" transfer-ownership="none" gs:managed-name="makeBackup" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24970">%TRUE if a backup should be created</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24971">a set of #GFileCreateFlags</doc>
            <type name="FileCreateFlags" c:type="GFileCreateFlags" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24972">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24973">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="replace_readwrite_finish" c:identifier="g_file_replace_readwrite_finish" version="2.22" throws="1" gs:dll-name="gio-2.0" gs:managed-name="ReplaceReadwriteFinish" gs:pinvoke-only="1" gs:finish-for="replace_readwrite_async" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24994">Finishes an asynchronous file replace operation started with
g_file_replace_readwrite_async().</doc>
        <source-position filename="gfile.h" line="773" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="25003">a #GFileIOStream, or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="FileIOStream" c:type="GFileIOStream*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24996">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24997">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24996">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24997">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="resolve_relative_path" c:identifier="g_file_resolve_relative_path" gs:dll-name="gio-2.0" gs:managed-name="ResolveRelativePath" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="25009">Resolves a relative path for @file to an absolute path.

This call does no blocking I/O.</doc>
        <source-position filename="gfile.h" line="651" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="25018">#GFile to the resolved path.
    %NULL if @relative_path is %NULL or if @file is invalid.
    Free the returned object with g_object_unref().</doc>
          <type name="File" c:type="GFile*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25011">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="relative_path" transfer-ownership="none" gs:managed-name="relativePath" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25012">a given relative path string</doc>
            <type name="filename" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25011">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="relative_path" transfer-ownership="none" gs:managed-name="relativePath" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25012">a given relative path string</doc>
            <type name="filename" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_attribute" c:identifier="g_file_set_attribute" throws="1" gs:dll-name="gio-2.0" gs:managed-name="SetAttribute" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="25024">Sets an attribute in the file with attribute name @attribute to @value_p.

Some attributes can be unset by setting @type to
%G_FILE_ATTRIBUTE_TYPE_INVALID and @value_p to %NULL.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <source-position filename="gfile.h" line="962" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="25045">%TRUE if the attribute was set, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25026">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25027">a string containing the attribute's name</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25028">The type of the attribute</doc>
            <type name="FileAttributeType" c:type="GFileAttributeType" />
          </parameter>
          <parameter name="value_p" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="valueP" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25029">a pointer to the value (or the pointer
    itself if the type is a pointer type)</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25031">a set of #GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25032">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25026">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25027">a string containing the attribute's name</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25028">The type of the attribute</doc>
            <type name="FileAttributeType" c:type="GFileAttributeType" />
          </parameter>
          <parameter name="value_p" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="valueP" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25029">a pointer to the value (or the pointer
    itself if the type is a pointer type)</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25031">a set of #GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25032">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_attribute_byte_string" c:identifier="g_file_set_attribute_byte_string" throws="1" gs:dll-name="gio-2.0" gs:managed-name="SetAttributeByteString" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="25049">Sets @attribute of type %G_FILE_ATTRIBUTE_TYPE_BYTE_STRING to @value.
If @attribute is of a different type, this operation will fail,
returning %FALSE.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <source-position filename="gfile.h" line="996" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="25067">%TRUE if the @attribute was successfully set to @value
    in the @file, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25051">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25052">a string containing the attribute's name</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25053">a string containing the attribute's new value</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25054">a #GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25055">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25051">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25052">a string containing the attribute's name</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25053">a string containing the attribute's new value</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25054">a #GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25055">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_attribute_int32" c:identifier="g_file_set_attribute_int32" throws="1" gs:dll-name="gio-2.0" gs:managed-name="SetAttributeInt32" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="25072">Sets @attribute of type %G_FILE_ATTRIBUTE_TYPE_INT32 to @value.
If @attribute is of a different type, this operation will fail.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <source-position filename="gfile.h" line="1010" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="25089">%TRUE if the @attribute was successfully set to @value
    in the @file, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25074">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25075">a string containing the attribute's name</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25076">a #gint32 containing the attribute's new value</doc>
            <type name="gint32" c:type="gint32" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25077">a #GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25078">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25074">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25075">a string containing the attribute's name</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25076">a #gint32 containing the attribute's new value</doc>
            <type name="gint32" c:type="gint32" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25077">a #GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25078">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_attribute_int64" c:identifier="g_file_set_attribute_int64" throws="1" gs:dll-name="gio-2.0" gs:managed-name="SetAttributeInt64" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="25094">Sets @attribute of type %G_FILE_ATTRIBUTE_TYPE_INT64 to @value.
If @attribute is of a different type, this operation will fail.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <source-position filename="gfile.h" line="1024" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="25111">%TRUE if the @attribute was successfully set, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25096">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25097">a string containing the attribute's name</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25098">a #guint64 containing the attribute's new value</doc>
            <type name="gint64" c:type="gint64" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25099">a #GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25100">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25096">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25097">a string containing the attribute's name</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25098">a #guint64 containing the attribute's new value</doc>
            <type name="gint64" c:type="gint64" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25099">a #GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25100">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_attribute_string" c:identifier="g_file_set_attribute_string" throws="1" gs:dll-name="gio-2.0" gs:managed-name="SetAttributeString" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="25115">Sets @attribute of type %G_FILE_ATTRIBUTE_TYPE_STRING to @value.
If @attribute is of a different type, this operation will fail.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <source-position filename="gfile.h" line="989" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="25132">%TRUE if the @attribute was successfully set, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25117">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25118">a string containing the attribute's name</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25119">a string containing the attribute's value</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25120">#GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25121">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25117">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25118">a string containing the attribute's name</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25119">a string containing the attribute's value</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25120">#GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25121">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_attribute_uint32" c:identifier="g_file_set_attribute_uint32" throws="1" gs:dll-name="gio-2.0" gs:managed-name="SetAttributeUint32" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="25136">Sets @attribute of type %G_FILE_ATTRIBUTE_TYPE_UINT32 to @value.
If @attribute is of a different type, this operation will fail.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <source-position filename="gfile.h" line="1003" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="25153">%TRUE if the @attribute was successfully set to @value
    in the @file, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25138">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25139">a string containing the attribute's name</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25140">a #guint32 containing the attribute's new value</doc>
            <type name="guint32" c:type="guint32" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25141">a #GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25142">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25138">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25139">a string containing the attribute's name</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25140">a #guint32 containing the attribute's new value</doc>
            <type name="guint32" c:type="guint32" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25141">a #GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25142">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_attribute_uint64" c:identifier="g_file_set_attribute_uint64" throws="1" gs:dll-name="gio-2.0" gs:managed-name="SetAttributeUint64" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="25158">Sets @attribute of type %G_FILE_ATTRIBUTE_TYPE_UINT64 to @value.
If @attribute is of a different type, this operation will fail.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <source-position filename="gfile.h" line="1017" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="25175">%TRUE if the @attribute was successfully set to @value
    in the @file, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25160">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25161">a string containing the attribute's name</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25162">a #guint64 containing the attribute's new value</doc>
            <type name="guint64" c:type="guint64" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25163">a #GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25164">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25160">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25161">a string containing the attribute's name</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25162">a #guint64 containing the attribute's new value</doc>
            <type name="guint64" c:type="guint64" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25163">a #GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25164">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_attributes_async" c:identifier="g_file_set_attributes_async" gs:dll-name="gio-2.0" gs:managed-name="SetAttributesAsync" gs:async="1" gs:async-finish="SetAttributesFinish" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="25180">Asynchronously sets the attributes of @file with @info.

For more details, see g_file_set_attributes_from_info(),
which is the synchronous version of this call.

When the operation is finished, @callback will be called.
You can then call g_file_set_attributes_finish() to get
the result of the operation.</doc>
        <source-position filename="gfile.h" line="976" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Threading.Tasks.Task">
            <type name="FileInfo" c:type="GFileInfo**" gs:is-pointer="1" />
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25182">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25183">a #GFileInfo</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25184">a #GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25185">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25186">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25188">a #GAsyncReadyCallback</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25189">a #gpointer</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25182">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25183">a #GFileInfo</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25184">a #GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25185">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25186">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_attributes_finish" c:identifier="g_file_set_attributes_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="SetAttributesFinish" gs:pinvoke-only="1" gs:finish-for="set_attributes_async" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="25202">Finishes setting an attribute started in g_file_set_attributes_async().</doc>
        <source-position filename="gfile.h" line="984" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="25211">%TRUE if the attributes were set correctly, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25204">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25205">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <parameter name="info" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="info">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25206">a #GFileInfo</doc>
            <type name="FileInfo" c:type="GFileInfo**" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25204">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25205">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <parameter name="info" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="info">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25206">a #GFileInfo</doc>
            <type name="FileInfo" c:type="GFileInfo**" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_attributes_from_info" c:identifier="g_file_set_attributes_from_info" throws="1" gs:dll-name="gio-2.0" gs:managed-name="SetAttributesFromInfo" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="25215">Tries to set all attributes in the #GFileInfo on the target
values, not stopping on the first error.

If there is any error during this operation then @error will
be set to the first error. Error on particular fields are flagged
by setting the "status" field in the attribute value to
%G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING, which means you can
also detect further errors.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <source-position filename="gfile.h" line="970" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="25237">%FALSE if there was any error, %TRUE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25217">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25218">a #GFileInfo</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25219">#GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25220">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25217">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25218">a #GFileInfo</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25219">#GFileQueryInfoFlags</doc>
            <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25220">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_display_name" c:identifier="g_file_set_display_name" throws="1" gs:dll-name="gio-2.0" gs:managed-name="SetDisplayName" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="25241">Renames @file to the specified display name.

The display name is converted from UTF-8 to the correct encoding
for the target filesystem if possible and the @file is renamed to this.

If you want to implement a rename operation in the user interface the
edit name (#G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME) should be used as the
initial value in the rename widget, and then the result after editing
should be passed to g_file_set_display_name().

On success the resulting converted filename is returned.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <source-position filename="gfile.h" line="850" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="25265">a #GFile specifying what @file was renamed to,
    or %NULL if there was an error.
    Free the returned object with g_object_unref().</doc>
          <type name="File" c:type="GFile*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25243">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="display_name" transfer-ownership="none" gs:managed-name="displayName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25244">a string</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25245">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25243">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="display_name" transfer-ownership="none" gs:managed-name="displayName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25244">a string</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25245">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_display_name_async" c:identifier="g_file_set_display_name_async" gs:dll-name="gio-2.0" gs:managed-name="SetDisplayNameAsync" gs:async="1" gs:async-finish="SetDisplayNameFinish" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="25271">Asynchronously sets the display name for a given #GFile.

For more details, see g_file_set_display_name() which is
the synchronous version of this call.

When the operation is finished, @callback will be called.
You can then call g_file_set_display_name_finish() to get
the result of the operation.</doc>
        <source-position filename="gfile.h" line="855" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Threading.Tasks.Task">
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25273">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="display_name" transfer-ownership="none" gs:managed-name="displayName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25274">a string</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25275">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25276">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25278">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25280">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25273">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="display_name" transfer-ownership="none" gs:managed-name="displayName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25274">a string</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25275">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25276">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_display_name_finish" c:identifier="g_file_set_display_name_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="SetDisplayNameFinish" gs:pinvoke-only="1" gs:finish-for="set_display_name_async" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="25293">Finishes setting a display name started with
g_file_set_display_name_async().</doc>
        <source-position filename="gfile.h" line="862" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="25302">a #GFile or %NULL on error.
    Free the returned object with g_object_unref().</doc>
          <type name="File" c:type="GFile*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25295">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25296">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25295">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25296">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="start_mountable_finish" c:identifier="g_file_start_mountable_finish" version="2.22" throws="1" gs:dll-name="gio-2.0" gs:managed-name="StartMountableFinish" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="25332">Finishes a start operation. See g_file_start_mountable() for details.

Finish an asynchronous start operation that was started
with g_file_start_mountable().</doc>
        <source-position filename="gfile.h" line="1158" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="25343">%TRUE if the operation finished successfully. %FALSE
otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25334">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25335">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25334">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25335">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="stop_mountable_finish" c:identifier="g_file_stop_mountable_finish" version="2.22" throws="1" gs:dll-name="gio-2.0" gs:managed-name="StopMountableFinish" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="25375">Finishes a stop operation, see g_file_stop_mountable() for details.

Finish an asynchronous stop operation that was started
with g_file_stop_mountable().</doc>
        <source-position filename="gfile.h" line="1169" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="25386">%TRUE if the operation finished successfully.
    %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25377">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25378">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25377">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25378">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="supports_thread_contexts" c:identifier="g_file_supports_thread_contexts" version="2.22" gs:dll-name="gio-2.0" gs:managed-name="SupportsThreadContexts" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="25392">Checks if @file supports
[thread-default contexts][g-main-context-push-thread-default-context].
If this returns %FALSE, you cannot perform asynchronous operations on
@file in a thread that has a thread-default context.</doc>
        <source-position filename="gfile.h" line="1268" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="25401">Whether or not @file supports thread-default contexts.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25394">a #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25394">a #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="trash" c:identifier="g_file_trash" throws="1" gs:dll-name="gio-2.0" gs:managed-name="Trash" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="25406">Sends @file to the "Trashcan", if possible. This is similar to
deleting it, but the user can recover it before emptying the trashcan.
Not all file systems support trashing, so this call can return the
%G_IO_ERROR_NOT_SUPPORTED error. Since GLib 2.66, the `x-gvfs-notrash` unix
mount option can be used to disable g_file_trash() support for certain
mounts, the %G_IO_ERROR_NOT_SUPPORTED error will be returned in that case.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <source-position filename="gfile.h" line="883" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="25424">%TRUE on successful trash, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25408">#GFile to send to trash</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25409">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25408">#GFile to send to trash</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25409">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="trash_async" c:identifier="g_file_trash_async" version="2.38" gs:dll-name="gio-2.0" gs:managed-name="TrashAsync" gs:async="1" gs:async-finish="TrashFinish" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="25428">Asynchronously sends @file to the Trash location, if possible.</doc>
        <source-position filename="gfile.h" line="888" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Threading.Tasks.Task" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25430">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25431">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25432">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25434">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25436">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25430">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25431">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25432">optional #GCancellable object,
    %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="trash_finish" c:identifier="g_file_trash_finish" version="2.38" throws="1" gs:dll-name="gio-2.0" gs:managed-name="TrashFinish" gs:pinvoke-only="1" gs:finish-for="trash_async" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="25444">Finishes an asynchronous file trashing operation, started with
g_file_trash_async().</doc>
        <source-position filename="gfile.h" line="895" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="25453">%TRUE on successful trash, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25446">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25447">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25446">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25447">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="unmount_mountable_finish" c:identifier="g_file_unmount_mountable_finish" deprecated="1" deprecated-version="2.22" throws="1" gs:dll-name="gio-2.0" gs:managed-name="UnmountMountableFinish" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="25482">Finishes an unmount operation, see g_file_unmount_mountable() for details.

Finish an asynchronous unmount operation that was started
with g_file_unmount_mountable().</doc>
        <doc-deprecated xml:space="preserve">Use g_file_unmount_mountable_with_operation_finish()
    instead.</doc-deprecated>
        <source-position filename="gfile.h" line="1060" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="25493">%TRUE if the operation finished successfully.
    %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25484">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25485">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25484">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25485">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="unmount_mountable_with_operation_finish" c:identifier="g_file_unmount_mountable_with_operation_finish" version="2.22" throws="1" gs:dll-name="gio-2.0" gs:managed-name="UnmountMountableWithOperationFinish" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="25526">Finishes an unmount operation,
see g_file_unmount_mountable_with_operation() for details.

Finish an asynchronous unmount operation that was started
with g_file_unmount_mountable_with_operation().</doc>
        <source-position filename="gfile.h" line="1071" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="25538">%TRUE if the operation finished successfully.
    %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25528">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25529">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25528">input #GFile</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25529">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_file_get_type" gs:access-modifiers="private" gs:dll-name="gio-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </interface>
    <record name="FileAttributeInfo" c:type="GFileAttributeInfo" gs:managed-name="FileAttributeInfo">
      <doc xml:space="preserve" filename="gfileattribute.h" line="32">Information about a specific attribute.</doc>
      <source-position filename="gfileattribute.h" line="45" />
      <field name="name" writable="1" gs:access-modifiers="private" gs:managed-name="name">
        <doc xml:space="preserve" filename="gfileattribute.h" line="34">the name of the attribute.</doc>
        <type name="utf8" c:type="char*" gs:is-pointer="1" />
      </field>
      <field name="type" writable="1" gs:managed-name="Type">
        <doc xml:space="preserve" filename="gfileattribute.h" line="35">the #GFileAttributeType type of the attribute.</doc>
        <type name="FileAttributeType" c:type="GFileAttributeType" />
      </field>
      <field name="flags" writable="1" gs:managed-name="Flags">
        <doc xml:space="preserve" filename="gfileattribute.h" line="36">a set of #GFileAttributeInfoFlags.</doc>
        <type name="FileAttributeInfoFlags" c:type="GFileAttributeInfoFlags" />
      </field>
    </record>
    <bitfield name="FileAttributeInfoFlags" glib:type-name="GFileAttributeInfoFlags" glib:get-type="g_file_attribute_info_flags_get_type" c:type="GFileAttributeInfoFlags" gs:managed-name="FileAttributeInfoFlags">
      <doc xml:space="preserve" filename="gioenums.h" line="147">Flags specifying the behaviour of an attribute.</doc>
      <member name="none" value="0" c:identifier="G_FILE_ATTRIBUTE_INFO_NONE" glib:nick="none" gs:managed-name="None">
        <doc xml:space="preserve" filename="gioenums.h" line="149">no flags set.</doc>
      </member>
      <member name="copy_with_file" value="1" c:identifier="G_FILE_ATTRIBUTE_INFO_COPY_WITH_FILE" glib:nick="copy-with-file" gs:managed-name="CopyWithFile">
        <doc xml:space="preserve" filename="gioenums.h" line="150">copy the attribute values when the file is copied.</doc>
      </member>
      <member name="copy_when_moved" value="2" c:identifier="G_FILE_ATTRIBUTE_INFO_COPY_WHEN_MOVED" glib:nick="copy-when-moved" gs:managed-name="CopyWhenMoved">
        <doc xml:space="preserve" filename="gioenums.h" line="151">copy the attribute values when the file is moved.</doc>
      </member>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_file_attribute_info_flags_get_type" gs:access-modifiers="private" gs:dll-name="gio-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </bitfield>
    <glib:boxed name="FileAttributeInfoList" c:type="GFileAttributeInfoList" glib:type-name="GFileAttributeInfoList" glib:get-type="g_file_attribute_info_list_get_type" c:symbol-prefix="file_attribute_info_list" gs:managed-name="FileAttributeInfoList">
      <doc xml:space="preserve" filename="gfileattribute.h" line="47">Acts as a lightweight registry for possible valid file attributes.
The registry stores Key-Value pair formats as #GFileAttributeInfos.</doc>
      <source-position filename="gfileattribute.h" line="59" />
      <field name="infos" writable="1" gs:managed-name="Infos">
        <doc xml:space="preserve" filename="gfileattribute.h" line="49">an array of #GFileAttributeInfos.</doc>
        <type name="FileAttributeInfo" c:type="GFileAttributeInfo*" gs:is-pointer="1" />
      </field>
      <field name="n_infos" writable="1" gs:managed-name="NInfos">
        <doc xml:space="preserve" filename="gfileattribute.h" line="50">the number of values in the array.</doc>
        <type name="gint" c:type="int" />
      </field>
      <constructor name="new" c:identifier="g_file_attribute_info_list_new" gs:dll-name="gio-2.0" gs:managed-name="New">
        <doc xml:space="preserve" filename="gio-2.0.c" line="21210">Creates a new file attribute info list.</doc>
        <source-position filename="gfileattribute.h" line="66" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="21215">a #GFileAttributeInfoList.</doc>
          <type name="FileAttributeInfoList" c:type="GFileAttributeInfoList*" gs:is-pointer="1" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </constructor>
      <method name="add" c:identifier="g_file_attribute_info_list_add" gs:dll-name="gio-2.0" gs:managed-name="Add">
        <doc xml:space="preserve" filename="gio-2.0.c" line="21176">Adds a new attribute with @name to the @list, setting
its @type and @flags.</doc>
        <source-position filename="gfileattribute.h" line="77" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="list" transfer-ownership="none" gs:managed-name="list" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21178">a #GFileAttributeInfoList.</doc>
            <type name="FileAttributeInfoList" c:type="GFileAttributeInfoList*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21179">the name of the attribute to add.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21180">the #GFileAttributeType for the attribute.</doc>
            <type name="FileAttributeType" c:type="GFileAttributeType" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21181">#GFileAttributeInfoFlags for the attribute.</doc>
            <type name="FileAttributeInfoFlags" c:type="GFileAttributeInfoFlags" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21179">the name of the attribute to add.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21180">the #GFileAttributeType for the attribute.</doc>
            <type name="FileAttributeType" c:type="GFileAttributeType" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21181">#GFileAttributeInfoFlags for the attribute.</doc>
            <type name="FileAttributeInfoFlags" c:type="GFileAttributeInfoFlags" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="dup" c:identifier="g_file_attribute_info_list_dup" gs:dll-name="gio-2.0" gs:managed-name="Dup">
        <doc xml:space="preserve" filename="gio-2.0.c" line="21188">Makes a duplicate of a file attribute info list.</doc>
        <source-position filename="gfileattribute.h" line="72" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="21194">a copy of the given @list.</doc>
          <type name="FileAttributeInfoList" c:type="GFileAttributeInfoList*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="list" transfer-ownership="none" gs:managed-name="list" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21190">a #GFileAttributeInfoList to duplicate.</doc>
            <type name="FileAttributeInfoList" c:type="GFileAttributeInfoList*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="lookup" c:identifier="g_file_attribute_info_list_lookup" gs:dll-name="gio-2.0" gs:managed-name="Lookup">
        <doc xml:space="preserve" filename="gio-2.0.c" line="21198">Gets the file attribute with the name @name from @list.</doc>
        <source-position filename="gfileattribute.h" line="74" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="21205">a #GFileAttributeInfo for the @name, or %NULL if an
attribute isn't found.</doc>
          <type name="FileAttributeInfo" c:type="const GFileAttributeInfo*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="list" transfer-ownership="none" gs:managed-name="list" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21200">a #GFileAttributeInfoList.</doc>
            <type name="FileAttributeInfoList" c:type="GFileAttributeInfoList*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21201">the name of the attribute to look up.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21201">the name of the attribute to look up.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="ref" c:identifier="g_file_attribute_info_list_ref" gs:dll-name="gio-2.0" gs:managed-name="Ref" gs:special-func="ref" gs:pinvoke-only="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="21219">References a file attribute info list.</doc>
        <source-position filename="gfileattribute.h" line="68" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="21225">#GFileAttributeInfoList or %NULL on error.</doc>
          <type name="FileAttributeInfoList" c:type="GFileAttributeInfoList*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="list" transfer-ownership="none" gs:managed-name="list" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21221">a #GFileAttributeInfoList to reference.</doc>
            <type name="FileAttributeInfoList" c:type="GFileAttributeInfoList*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="unref" c:identifier="g_file_attribute_info_list_unref" gs:dll-name="gio-2.0" gs:managed-name="Unref" gs:special-func="unref" gs:pinvoke-only="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="21229">Removes a reference from the given @list. If the reference count
falls to zero, the @list is deleted.</doc>
        <source-position filename="gfileattribute.h" line="70" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="list" transfer-ownership="none" gs:managed-name="list" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21231">The #GFileAttributeInfoList to unreference.</doc>
            <type name="FileAttributeInfoList" c:type="GFileAttributeInfoList*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_file_attribute_info_list_get_type" gs:access-modifiers="private" gs:dll-name="gio-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </glib:boxed>
    <glib:boxed name="FileAttributeMatcher" c:type="GFileAttributeMatcher" glib:type-name="GFileAttributeMatcher" glib:get-type="g_file_attribute_matcher_get_type" c:symbol-prefix="file_attribute_matcher" gs:managed-name="FileAttributeMatcher">
      <doc xml:space="preserve" filename="giotypes.h" line="87">Determines if a string matches a file attribute.</doc>
      <source-position filename="giotypes.h" line="92" />
      <constructor name="new" c:identifier="g_file_attribute_matcher_new" gs:dll-name="gio-2.0" gs:managed-name="New">
        <doc xml:space="preserve" filename="gio-2.0.c" line="21291">Creates a new file attribute matcher, which matches attributes
against a given string. #GFileAttributeMatchers are reference
counted structures, and are created with a reference count of 1. If
the number of references falls to 0, the #GFileAttributeMatcher is
automatically destroyed.

The @attributes string should be formatted with specific keys separated
from namespaces with a double colon. Several "namespace::key" strings may be
concatenated with a single comma (e.g. "standard::type,standard::is-hidden").
The wildcard "*" may be used to match all keys and namespaces, or
"namespace::*" will match all keys in a given namespace.

## Examples of file attribute matcher strings and results

- `"*"`: matches all attributes.
- `"standard::is-hidden"`: matches only the key is-hidden in the
  standard namespace.
- `"standard::type,unix::*"`: matches the type key in the standard
  namespace and all keys in the unix namespace.</doc>
        <source-position filename="gfileinfo.h" line="1124" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="21315">a #GFileAttributeMatcher</doc>
          <type name="FileAttributeMatcher" c:type="GFileAttributeMatcher*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21293">an attribute string to match.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21293">an attribute string to match.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <method name="enumerate_namespace" c:identifier="g_file_attribute_matcher_enumerate_namespace" gs:dll-name="gio-2.0" gs:managed-name="EnumerateNamespace">
        <doc xml:space="preserve" filename="gio-2.0.c" line="21238">Checks if the matcher will match all of the keys in a given namespace.
This will always return %TRUE if a wildcard character is in use (e.g. if
matcher was created with "standard::*" and @ns is "standard", or if matcher was created
using "*" and namespace is anything.)

TODO: this is awkwardly worded.</doc>
        <source-position filename="gfileinfo.h" line="1139" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="21250">%TRUE if the matcher matches all of the entries
in the given @ns, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="matcher" transfer-ownership="none" gs:managed-name="matcher" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21240">a #GFileAttributeMatcher.</doc>
            <type name="FileAttributeMatcher" c:type="GFileAttributeMatcher*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="ns" transfer-ownership="none" gs:managed-name="ns" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21241">a string containing a file attribute namespace.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="ns" transfer-ownership="none" gs:managed-name="ns" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21241">a string containing a file attribute namespace.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="enumerate_next" c:identifier="g_file_attribute_matcher_enumerate_next" gs:dll-name="gio-2.0" gs:managed-name="EnumerateNext">
        <doc xml:space="preserve" filename="gio-2.0.c" line="21255">Gets the next matched attribute from a #GFileAttributeMatcher.</doc>
        <source-position filename="gfileinfo.h" line="1142" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="21261">a string containing the next attribute or, %NULL if
no more attribute exist.</doc>
          <type name="utf8" c:type="const char*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="matcher" transfer-ownership="none" gs:managed-name="matcher" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21257">a #GFileAttributeMatcher.</doc>
            <type name="FileAttributeMatcher" c:type="GFileAttributeMatcher*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="matches" c:identifier="g_file_attribute_matcher_matches" gs:dll-name="gio-2.0" gs:managed-name="Matches">
        <doc xml:space="preserve" filename="gio-2.0.c" line="21266">Checks if an attribute will be matched by an attribute matcher. If
the matcher was created with the "*" matching string, this function
will always return %TRUE.</doc>
        <source-position filename="gfileinfo.h" line="1133" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="21275">%TRUE if @attribute matches @matcher. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="matcher" transfer-ownership="none" gs:managed-name="matcher" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21268">a #GFileAttributeMatcher.</doc>
            <type name="FileAttributeMatcher" c:type="GFileAttributeMatcher*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21269">a file attribute key.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21269">a file attribute key.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="matches_only" c:identifier="g_file_attribute_matcher_matches_only" gs:dll-name="gio-2.0" gs:managed-name="MatchesOnly">
        <doc xml:space="preserve" filename="gio-2.0.c" line="21279">Checks if a attribute matcher only matches a given attribute. Always
returns %FALSE if "*" was used when creating the matcher.</doc>
        <source-position filename="gfileinfo.h" line="1136" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="21287">%TRUE if the matcher only matches @attribute. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="matcher" transfer-ownership="none" gs:managed-name="matcher" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21281">a #GFileAttributeMatcher.</doc>
            <type name="FileAttributeMatcher" c:type="GFileAttributeMatcher*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21282">a file attribute key.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21282">a file attribute key.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="ref" c:identifier="g_file_attribute_matcher_ref" gs:dll-name="gio-2.0" gs:managed-name="Ref" gs:special-func="ref" gs:pinvoke-only="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="21319">References a file attribute matcher.</doc>
        <source-position filename="gfileinfo.h" line="1126" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="21325">a #GFileAttributeMatcher.</doc>
          <type name="FileAttributeMatcher" c:type="GFileAttributeMatcher*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="matcher" transfer-ownership="none" gs:managed-name="matcher" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21321">a #GFileAttributeMatcher.</doc>
            <type name="FileAttributeMatcher" c:type="GFileAttributeMatcher*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="subtract" c:identifier="g_file_attribute_matcher_subtract" gs:dll-name="gio-2.0" gs:managed-name="Subtract">
        <doc xml:space="preserve" filename="gio-2.0.c" line="21329">Subtracts all attributes of @subtract from @matcher and returns
a matcher that supports those attributes.

Note that currently it is not possible to remove a single
attribute when the @matcher matches the whole namespace - or remove
a namespace or attribute when the matcher matches everything. This
is a limitation of the current implementation, but may be fixed
in the future.</doc>
        <source-position filename="gfileinfo.h" line="1130" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="21343">A file attribute matcher matching all attributes of
    @matcher that are not matched by @subtract</doc>
          <type name="FileAttributeMatcher" c:type="GFileAttributeMatcher*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="matcher" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="matcher" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21331">Matcher to subtract from</doc>
            <type name="FileAttributeMatcher" c:type="GFileAttributeMatcher*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="subtract" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="subtract" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21332">The matcher to subtract</doc>
            <type name="FileAttributeMatcher" c:type="GFileAttributeMatcher*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="subtract" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="subtract" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21332">The matcher to subtract</doc>
            <type name="FileAttributeMatcher" c:type="GFileAttributeMatcher*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="to_string" c:identifier="g_file_attribute_matcher_to_string" version="2.32" gs:dll-name="gio-2.0" gs:managed-name="ToString" gs:to-string="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="21348">Prints what the matcher is matching against. The format will be
equal to the format passed to g_file_attribute_matcher_new().
The output however, might not be identical, as the matcher may
decide to use a different order or omit needless parts.</doc>
        <source-position filename="gfileinfo.h" line="1144" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="21357">a string describing the attributes the matcher matches
  against or %NULL if @matcher was %NULL.</doc>
          <type name="utf8" c:type="char*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="matcher" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="matcher" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21350">a #GFileAttributeMatcher.</doc>
            <type name="FileAttributeMatcher" c:type="GFileAttributeMatcher*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="unref" c:identifier="g_file_attribute_matcher_unref" gs:dll-name="gio-2.0" gs:managed-name="Unref" gs:special-func="unref" gs:pinvoke-only="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="21363">Unreferences @matcher. If the reference count falls below 1,
the @matcher is automatically freed.</doc>
        <source-position filename="gfileinfo.h" line="1128" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="matcher" transfer-ownership="none" gs:managed-name="matcher" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21365">a #GFileAttributeMatcher.</doc>
            <type name="FileAttributeMatcher" c:type="GFileAttributeMatcher*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_file_attribute_matcher_get_type" gs:access-modifiers="private" gs:dll-name="gio-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </glib:boxed>
    <enumeration name="FileAttributeStatus" glib:type-name="GFileAttributeStatus" glib:get-type="g_file_attribute_status_get_type" c:type="GFileAttributeStatus" gs:managed-name="FileAttributeStatus">
      <doc xml:space="preserve" filename="gioenums.h" line="162">Used by g_file_set_attributes_from_info() when setting file attributes.</doc>
      <member name="unset" value="0" c:identifier="G_FILE_ATTRIBUTE_STATUS_UNSET" glib:nick="unset" gs:managed-name="Unset">
        <doc xml:space="preserve" filename="gioenums.h" line="164">Attribute value is unset (empty).</doc>
      </member>
      <member name="set" value="1" c:identifier="G_FILE_ATTRIBUTE_STATUS_SET" glib:nick="set" gs:managed-name="Set">
        <doc xml:space="preserve" filename="gioenums.h" line="165">Attribute value is set.</doc>
      </member>
      <member name="error_setting" value="2" c:identifier="G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING" glib:nick="error-setting" gs:managed-name="ErrorSetting">
        <doc xml:space="preserve" filename="gioenums.h" line="166">Indicates an error in setting the value.</doc>
      </member>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_file_attribute_status_get_type" gs:access-modifiers="private" gs:dll-name="gio-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </enumeration>
    <enumeration name="FileAttributeType" glib:type-name="GFileAttributeType" glib:get-type="g_file_attribute_type_get_type" c:type="GFileAttributeType" gs:managed-name="FileAttributeType">
      <doc xml:space="preserve" filename="gioenums.h" line="118">The data types for file attributes.</doc>
      <member name="invalid" value="0" c:identifier="G_FILE_ATTRIBUTE_TYPE_INVALID" glib:nick="invalid" gs:managed-name="Invalid">
        <doc xml:space="preserve" filename="gioenums.h" line="120">indicates an invalid or uninitialized type.</doc>
      </member>
      <member name="string" value="1" c:identifier="G_FILE_ATTRIBUTE_TYPE_STRING" glib:nick="string" gs:managed-name="String">
        <doc xml:space="preserve" filename="gioenums.h" line="121">a null terminated UTF8 string.</doc>
      </member>
      <member name="byte_string" value="2" c:identifier="G_FILE_ATTRIBUTE_TYPE_BYTE_STRING" glib:nick="byte-string" gs:managed-name="ByteString">
        <doc xml:space="preserve" filename="gioenums.h" line="122">a zero terminated string of non-zero bytes.</doc>
      </member>
      <member name="boolean" value="3" c:identifier="G_FILE_ATTRIBUTE_TYPE_BOOLEAN" glib:nick="boolean" gs:managed-name="Boolean">
        <doc xml:space="preserve" filename="gioenums.h" line="123">a boolean value.</doc>
      </member>
      <member name="uint32" value="4" c:identifier="G_FILE_ATTRIBUTE_TYPE_UINT32" glib:nick="uint32" gs:managed-name="Uint32">
        <doc xml:space="preserve" filename="gioenums.h" line="124">an unsigned 4-byte/32-bit integer.</doc>
      </member>
      <member name="int32" value="5" c:identifier="G_FILE_ATTRIBUTE_TYPE_INT32" glib:nick="int32" gs:managed-name="Int32">
        <doc xml:space="preserve" filename="gioenums.h" line="125">a signed 4-byte/32-bit integer.</doc>
      </member>
      <member name="uint64" value="6" c:identifier="G_FILE_ATTRIBUTE_TYPE_UINT64" glib:nick="uint64" gs:managed-name="Uint64">
        <doc xml:space="preserve" filename="gioenums.h" line="126">an unsigned 8-byte/64-bit integer.</doc>
      </member>
      <member name="int64" value="7" c:identifier="G_FILE_ATTRIBUTE_TYPE_INT64" glib:nick="int64" gs:managed-name="Int64">
        <doc xml:space="preserve" filename="gioenums.h" line="127">a signed 8-byte/64-bit integer.</doc>
      </member>
      <member name="object" value="8" c:identifier="G_FILE_ATTRIBUTE_TYPE_OBJECT" glib:nick="object" gs:managed-name="Object">
        <doc xml:space="preserve" filename="gioenums.h" line="128">a #GObject.</doc>
      </member>
      <member name="string_array" value="9" c:identifier="G_FILE_ATTRIBUTE_TYPE_STRINGV" glib:nick="stringv" version="2.22" gs:managed-name="StringArray">
        <doc xml:space="preserve" filename="gioenums.h" line="129">a %NULL terminated char **.</doc>
      </member>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_file_attribute_type_get_type" gs:access-modifiers="private" gs:dll-name="gio-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </enumeration>
    <bitfield name="FileCopyFlags" glib:type-name="GFileCopyFlags" glib:get-type="g_file_copy_flags_get_type" c:type="GFileCopyFlags" gs:managed-name="FileCopyFlags">
      <doc xml:space="preserve" filename="gioenums.h" line="302">Flags used when copying or moving files.</doc>
      <member name="none" value="0" c:identifier="G_FILE_COPY_NONE" glib:nick="none" gs:managed-name="None">
        <doc xml:space="preserve" filename="gioenums.h" line="304">No flags set.</doc>
      </member>
      <member name="overwrite" value="1" c:identifier="G_FILE_COPY_OVERWRITE" glib:nick="overwrite" gs:managed-name="Overwrite">
        <doc xml:space="preserve" filename="gioenums.h" line="305">Overwrite any existing files</doc>
      </member>
      <member name="backup" value="2" c:identifier="G_FILE_COPY_BACKUP" glib:nick="backup" gs:managed-name="Backup">
        <doc xml:space="preserve" filename="gioenums.h" line="306">Make a backup of any existing files.</doc>
      </member>
      <member name="nofollow_symlinks" value="4" c:identifier="G_FILE_COPY_NOFOLLOW_SYMLINKS" glib:nick="nofollow-symlinks" gs:managed-name="NoFollowSymlinks">
        <doc xml:space="preserve" filename="gioenums.h" line="307">Don't follow symlinks.</doc>
      </member>
      <member name="all_metadata" value="8" c:identifier="G_FILE_COPY_ALL_METADATA" glib:nick="all-metadata" gs:managed-name="AllMetadata">
        <doc xml:space="preserve" filename="gioenums.h" line="308">Copy all file metadata instead of just default set used for copy (see #GFileInfo).</doc>
      </member>
      <member name="no_fallback_for_move" value="16" c:identifier="G_FILE_COPY_NO_FALLBACK_FOR_MOVE" glib:nick="no-fallback-for-move" gs:managed-name="NoFallbackForMove">
        <doc xml:space="preserve" filename="gioenums.h" line="309">Don't use copy and delete fallback if native move not supported.</doc>
      </member>
      <member name="target_default_perms" value="32" c:identifier="G_FILE_COPY_TARGET_DEFAULT_PERMS" glib:nick="target-default-perms" gs:managed-name="TargetDefaultPerms">
        <doc xml:space="preserve" filename="gioenums.h" line="310">Leaves target file with default perms, instead of setting the source file perms.</doc>
      </member>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_file_copy_flags_get_type" gs:access-modifiers="private" gs:dll-name="gio-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </bitfield>
    <bitfield name="FileCreateFlags" glib:type-name="GFileCreateFlags" glib:get-type="g_file_create_flags_get_type" c:type="GFileCreateFlags" gs:managed-name="FileCreateFlags">
      <doc xml:space="preserve" filename="gioenums.h" line="190">Flags used when an operation may create a file.</doc>
      <member name="none" value="0" c:identifier="G_FILE_CREATE_NONE" glib:nick="none" gs:managed-name="None">
        <doc xml:space="preserve" filename="gioenums.h" line="192">No flags set.</doc>
      </member>
      <member name="private" value="1" c:identifier="G_FILE_CREATE_PRIVATE" glib:nick="private" gs:managed-name="Private">
        <doc xml:space="preserve" filename="gioenums.h" line="193">Create a file that can only be
   accessed by the current user.</doc>
      </member>
      <member name="replace_destination" value="2" c:identifier="G_FILE_CREATE_REPLACE_DESTINATION" glib:nick="replace-destination" version="2.20" gs:managed-name="ReplaceDestination">
        <doc xml:space="preserve" filename="gioenums.h" line="195">Replace the destination
   as if it didn't exist before. Don't try to keep any old
   permissions, replace instead of following links. This
   is generally useful if you're doing a "copy over"
   rather than a "save new version of" replace operation.
   You can think of it as "unlink destination" before
   writing to it, although the implementation may not
   be exactly like that. This flag can only be used with
   g_file_replace() and its variants, including g_file_replace_contents().</doc>
      </member>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_file_create_flags_get_type" gs:access-modifiers="private" gs:dll-name="gio-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </bitfield>
    <class name="FileIOStream" c:symbol-prefix="file_io_stream" c:type="GFileIOStream" version="2.22" parent="IOStream" glib:type-name="GFileIOStream" glib:get-type="g_file_io_stream_get_type" glib:type-struct="FileIOStreamClass" gs:managed-name="FileIOStream">
      <doc xml:space="preserve" filename="gio-2.0.c" line="6507">GFileIOStream provides io streams that both read and write to the same
file handle.

GFileIOStream implements #GSeekable, which allows the io
stream to jump to arbitrary positions in the file and to truncate
the file, provided the filesystem of the file supports these
operations.

To find the position of a file io stream, use
g_seekable_tell().

To find out if a file io stream supports seeking, use g_seekable_can_seek().
To position a file io stream, use g_seekable_seek().
To find out if a file io stream supports truncating, use
g_seekable_can_truncate(). To truncate a file io
stream, use g_seekable_truncate().

The default implementation of all the #GFileIOStream operations
and the implementation of #GSeekable just call into the same operations
on the output stream.</doc>
      <source-position filename="gfileiostream.h" line="95" />
      <implements name="Seekable" gs:managed-name="Seekable" />
      <virtual-method name="can_seek" gs:dll-name="gio-2.0" gs:managed-name="DoCanSeek">
        <source-position filename="gfileiostream.h" line="63" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <type name="FileIOStream" c:type="GFileIOStream*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </virtual-method>
      <virtual-method name="can_truncate" gs:dll-name="gio-2.0" gs:managed-name="DoCanTruncate">
        <source-position filename="gfileiostream.h" line="69" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <type name="FileIOStream" c:type="GFileIOStream*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </virtual-method>
      <virtual-method name="get_etag" invoker="get_etag" version="2.22" gs:dll-name="gio-2.0" gs:managed-name="DoGetEtag">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23315">Gets the entity tag for the file when it has been written.
This must be called after the stream has been written
and closed, as the etag can change while writing.</doc>
        <source-position filename="gfileiostream.h" line="87" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="23323">the entity tag for the stream.</doc>
          <type name="utf8" c:type="char*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23317">a #GFileIOStream.</doc>
            <type name="FileIOStream" c:type="GFileIOStream*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </virtual-method>
      <virtual-method name="query_info" invoker="query_info" version="2.22" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoQueryInfo">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23328">Queries a file io stream for the given @attributes.
This function blocks while querying the stream. For the asynchronous
version of this function, see g_file_io_stream_query_info_async().
While the stream is blocked, the stream will set the pending flag
internally, and any other operations on the stream will fail with
%G_IO_ERROR_PENDING.

Can fail if the stream was already closed (with @error being set to
%G_IO_ERROR_CLOSED), the stream has pending operations (with @error being
set to %G_IO_ERROR_PENDING), or if querying info is not supported for
the stream's interface (with @error being set to %G_IO_ERROR_NOT_SUPPORTED). I
all cases of failure, %NULL will be returned.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %NULL will
be returned.</doc>
        <source-position filename="gfileiostream.h" line="74" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="23353">a #GFileInfo for the @stream, or %NULL on error.</doc>
          <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23330">a #GFileIOStream.</doc>
            <type name="FileIOStream" c:type="GFileIOStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23331">a file attribute query string.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23332">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23331">a file attribute query string.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23332">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="query_info_async" invoker="query_info_async" version="2.22" gs:dll-name="gio-2.0" gs:managed-name="DoQueryInfoAsync">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23358">Asynchronously queries the @stream for a #GFileInfo. When completed,
@callback will be called with a #GAsyncResult which can be used to
finish the operation with g_file_io_stream_query_info_finish().

For the synchronous version of this function, see
g_file_io_stream_query_info().</doc>
        <source-position filename="gfileiostream.h" line="78" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23360">a #GFileIOStream.</doc>
            <type name="FileIOStream" c:type="GFileIOStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23361">a file attribute query string.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23362">the [I/O priority][gio-GIOScheduler] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23363">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23364">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23365">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23361">a file attribute query string.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23362">the [I/O priority][gio-GIOScheduler] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23364">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23363">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="query_info_finish" invoker="query_info_finish" version="2.22" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoQueryInfoFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23378">Finalizes the asynchronous query started
by g_file_io_stream_query_info_async().</doc>
        <source-position filename="gfileiostream.h" line="84" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="23387">A #GFileInfo for the finished query.</doc>
          <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23380">a #GFileIOStream.</doc>
            <type name="FileIOStream" c:type="GFileIOStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23381">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23381">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="seek" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoSeek">
        <source-position filename="gfileiostream.h" line="64" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <type name="FileIOStream" c:type="GFileIOStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none" gs:managed-name="offset" direction="in">
            <type name="gint64" c:type="goffset" />
          </parameter>
          <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <type name="GLib.SeekType" c:type="GSeekType" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="offset" transfer-ownership="none" gs:managed-name="offset" direction="in">
            <type name="gint64" c:type="goffset" />
          </parameter>
          <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <type name="GLib.SeekType" c:type="GSeekType" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="tell" gs:dll-name="gio-2.0" gs:managed-name="DoTell">
        <source-position filename="gfileiostream.h" line="62" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="gint64" c:type="goffset" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <type name="FileIOStream" c:type="GFileIOStream*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </virtual-method>
      <virtual-method name="truncate_fn" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoTruncateFn">
        <source-position filename="gfileiostream.h" line="70" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <type name="FileIOStream" c:type="GFileIOStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="size" transfer-ownership="none" gs:managed-name="size" direction="in">
            <type name="gint64" c:type="goffset" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="size" transfer-ownership="none" gs:managed-name="size" direction="in">
            <type name="gint64" c:type="goffset" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <gs:managed-property name="get_etag" version="2.22" gs:dll-name="gio-2.0" gs:managed-name="Etag">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23315">Gets the entity tag for the file when it has been written.
This must be called after the stream has been written
and closed, as the etag can change while writing.</doc>
        <source-position filename="gfileiostream.h" line="117" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="23323">the entity tag for the stream.</doc>
          <type name="utf8" c:type="char*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23317">a #GFileIOStream.</doc>
            <type name="FileIOStream" c:type="GFileIOStream*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_etag" c:identifier="g_file_io_stream_get_etag" version="2.22" gs:dll-name="gio-2.0" gs:managed-name="GetEtag" gs:property-getter-for="Etag" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23315">Gets the entity tag for the file when it has been written.
This must be called after the stream has been written
and closed, as the etag can change while writing.</doc>
        <source-position filename="gfileiostream.h" line="117" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="23323">the entity tag for the stream.</doc>
          <type name="utf8" c:type="char*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23317">a #GFileIOStream.</doc>
            <type name="FileIOStream" c:type="GFileIOStream*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="query_info" c:identifier="g_file_io_stream_query_info" version="2.22" throws="1" gs:dll-name="gio-2.0" gs:managed-name="QueryInfo">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23328">Queries a file io stream for the given @attributes.
This function blocks while querying the stream. For the asynchronous
version of this function, see g_file_io_stream_query_info_async().
While the stream is blocked, the stream will set the pending flag
internally, and any other operations on the stream will fail with
%G_IO_ERROR_PENDING.

Can fail if the stream was already closed (with @error being set to
%G_IO_ERROR_CLOSED), the stream has pending operations (with @error being
set to %G_IO_ERROR_PENDING), or if querying info is not supported for
the stream's interface (with @error being set to %G_IO_ERROR_NOT_SUPPORTED). I
all cases of failure, %NULL will be returned.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %NULL will
be returned.</doc>
        <source-position filename="gfileiostream.h" line="101" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="23353">a #GFileInfo for the @stream, or %NULL on error.</doc>
          <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23330">a #GFileIOStream.</doc>
            <type name="FileIOStream" c:type="GFileIOStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23331">a file attribute query string.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23332">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23331">a file attribute query string.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23332">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="query_info_async" c:identifier="g_file_io_stream_query_info_async" version="2.22" gs:dll-name="gio-2.0" gs:managed-name="QueryInfoAsync" gs:async="1" gs:async-finish="QueryInfoFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23358">Asynchronously queries the @stream for a #GFileInfo. When completed,
@callback will be called with a #GAsyncResult which can be used to
finish the operation with g_file_io_stream_query_info_finish().

For the synchronous version of this function, see
g_file_io_stream_query_info().</doc>
        <source-position filename="gfileiostream.h" line="106" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Threading.Tasks.Task">
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23360">a #GFileIOStream.</doc>
            <type name="FileIOStream" c:type="GFileIOStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23361">a file attribute query string.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23362">the [I/O priority][gio-GIOScheduler] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23363">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23364">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23365">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23361">a file attribute query string.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23362">the [I/O priority][gio-GIOScheduler] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23363">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="query_info_finish" c:identifier="g_file_io_stream_query_info_finish" version="2.22" throws="1" gs:dll-name="gio-2.0" gs:managed-name="QueryInfoFinish" gs:pinvoke-only="1" gs:finish-for="query_info_async">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23378">Finalizes the asynchronous query started
by g_file_io_stream_query_info_async().</doc>
        <source-position filename="gfileiostream.h" line="113" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="23387">A #GFileInfo for the finished query.</doc>
          <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23380">a #GFileIOStream.</doc>
            <type name="FileIOStream" c:type="GFileIOStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23381">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23381">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <field name="parent_instance" gs:managed-name="ParentInstance">
        <type name="IOStream" c:type="GIOStream" />
      </field>
      <field name="priv" readable="0" private="1" gs:managed-name="Priv">
        <type name="FileIOStreamPrivate" c:type="GFileIOStreamPrivate*" gs:is-pointer="1" />
      </field>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_file_io_stream_get_type" gs:access-modifiers="private" gs:dll-name="gio-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </class>
    <record name="FileIOStreamClass" c:type="GFileIOStreamClass" glib:is-gtype-struct-for="FileIOStream" gs:managed-name="FileIOStreamClass">
      <source-position filename="gfileiostream.h" line="95" />
      <field name="parent_class" gs:managed-name="ParentClass">
        <type name="IOStreamClass" c:type="GIOStreamClass" />
      </field>
      <field name="tell" gs:managed-name="Tell">
        <callback name="tell" gs:dll-name="gio-2.0" gs:managed-name="Tell">
          <source-position filename="gfileiostream.h" line="62" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="gint64" c:type="goffset" />
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <type name="FileIOStream" c:type="GFileIOStream*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <type name="FileIOStream" c:type="GFileIOStream*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="can_seek" gs:managed-name="CanSeek">
        <callback name="can_seek" gs:dll-name="gio-2.0" gs:managed-name="CanSeek">
          <source-position filename="gfileiostream.h" line="63" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <type name="FileIOStream" c:type="GFileIOStream*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <type name="FileIOStream" c:type="GFileIOStream*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="seek" gs:managed-name="Seek">
        <callback name="seek" throws="1" gs:dll-name="gio-2.0" gs:managed-name="Seek">
          <source-position filename="gfileiostream.h" line="64" />
          <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <type name="FileIOStream" c:type="GFileIOStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="offset" transfer-ownership="none" gs:managed-name="offset" direction="in">
              <type name="gint64" c:type="goffset" />
            </parameter>
            <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
              <type name="GLib.SeekType" c:type="GSeekType" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <type name="FileIOStream" c:type="GFileIOStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="offset" transfer-ownership="none" gs:managed-name="offset" direction="in">
              <type name="gint64" c:type="goffset" />
            </parameter>
            <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
              <type name="GLib.SeekType" c:type="GSeekType" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="can_truncate" gs:managed-name="CanTruncate">
        <callback name="can_truncate" gs:dll-name="gio-2.0" gs:managed-name="CanTruncate">
          <source-position filename="gfileiostream.h" line="69" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <type name="FileIOStream" c:type="GFileIOStream*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <type name="FileIOStream" c:type="GFileIOStream*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="truncate_fn" gs:managed-name="TruncateFn">
        <callback name="truncate_fn" throws="1" gs:dll-name="gio-2.0" gs:managed-name="TruncateFn">
          <source-position filename="gfileiostream.h" line="70" />
          <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <type name="FileIOStream" c:type="GFileIOStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="size" transfer-ownership="none" gs:managed-name="size" direction="in">
              <type name="gint64" c:type="goffset" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <type name="FileIOStream" c:type="GFileIOStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="size" transfer-ownership="none" gs:managed-name="size" direction="in">
              <type name="gint64" c:type="goffset" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="query_info" gs:managed-name="QueryInfo">
        <callback name="query_info" throws="1" gs:dll-name="gio-2.0" gs:managed-name="QueryInfo">
          <source-position filename="gfileiostream.h" line="74" />
          <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23353">a #GFileInfo for the @stream, or %NULL on error.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23330">a #GFileIOStream.</doc>
              <type name="FileIOStream" c:type="GFileIOStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23331">a file attribute query string.</doc>
              <type name="utf8" c:type="const char*" gs:is-pointer="1" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23332">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23330">a #GFileIOStream.</doc>
              <type name="FileIOStream" c:type="GFileIOStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23331">a file attribute query string.</doc>
              <type name="utf8" c:type="const char*" gs:is-pointer="1" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23332">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="query_info_async" gs:managed-name="QueryInfoAsync">
        <callback name="query_info_async" gs:dll-name="gio-2.0" gs:managed-name="QueryInfoAsync">
          <source-position filename="gfileiostream.h" line="78" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23360">a #GFileIOStream.</doc>
              <type name="FileIOStream" c:type="GFileIOStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23361">a file attribute query string.</doc>
              <type name="utf8" c:type="const char*" gs:is-pointer="1" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23362">the [I/O priority][gio-GIOScheduler] of the request</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23363">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23364">callback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5" gs:managed-name="userData" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23365">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23360">a #GFileIOStream.</doc>
              <type name="FileIOStream" c:type="GFileIOStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23361">a file attribute query string.</doc>
              <type name="utf8" c:type="const char*" gs:is-pointer="1" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23362">the [I/O priority][gio-GIOScheduler] of the request</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23364">callback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23363">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="query_info_finish" gs:managed-name="QueryInfoFinish">
        <callback name="query_info_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="QueryInfoFinish">
          <source-position filename="gfileiostream.h" line="84" />
          <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23387">A #GFileInfo for the finished query.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23380">a #GFileIOStream.</doc>
              <type name="FileIOStream" c:type="GFileIOStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23381">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23380">a #GFileIOStream.</doc>
              <type name="FileIOStream" c:type="GFileIOStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23381">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="get_etag" gs:managed-name="GetEtag">
        <callback name="get_etag" gs:dll-name="gio-2.0" gs:managed-name="GetEtag">
          <source-position filename="gfileiostream.h" line="87" />
          <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23323">the entity tag for the stream.</doc>
            <type name="utf8" c:type="char*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23317">a #GFileIOStream.</doc>
              <type name="FileIOStream" c:type="GFileIOStream*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23317">a #GFileIOStream.</doc>
              <type name="FileIOStream" c:type="GFileIOStream*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="_g_reserved1" introspectable="1" gs:managed-name="GReserved1">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="_g_reserved2" introspectable="1" gs:managed-name="GReserved2">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="_g_reserved3" introspectable="1" gs:managed-name="GReserved3">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="_g_reserved4" introspectable="1" gs:managed-name="GReserved4">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="_g_reserved5" introspectable="1" gs:managed-name="GReserved5">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
    </record>
    <record name="FileIface" c:type="GFileIface" glib:is-gtype-struct-for="File" gs:managed-name="FileIface">
      <doc xml:space="preserve" filename="gfile.h" line="50">An interface for writing VFS file handles.</doc>
      <source-position filename="gfile.h" line="592" />
      <field name="g_iface" gs:managed-name="GIface">
        <doc xml:space="preserve" filename="gfile.h" line="52">The parent interface.</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface" />
      </field>
      <field name="dup" gs:managed-name="Dup">
        <callback name="dup" gs:dll-name="gio-2.0" gs:managed-name="Dup">
          <source-position filename="gfile.h" line="168" />
          <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21774">a new #GFile that is a duplicate
    of the given #GFile.</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21761">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21761">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="hash" gs:managed-name="Hash">
        <callback name="hash" gs:dll-name="gio-2.0" gs:managed-name="Hash">
          <source-position filename="gfile.h" line="169" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22487">0 if @file is not a valid #GFile, otherwise an
    integer that can be used as hash value for the #GFile.
    This function is intended for easily hashing a #GFile to
    add to a #GHashTable or similar data structure.</doc>
            <type name="guint" c:type="guint" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="22481">#gconstpointer to a #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="22481">#gconstpointer to a #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="equal" gs:managed-name="Equal">
        <callback name="equal" gs:dll-name="gio-2.0" gs:managed-name="Equal">
          <source-position filename="gfile.h" line="170" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22188">%TRUE if @file1 and @file2 are equal.</doc>
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="file1" transfer-ownership="none" gs:managed-name="file1" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="22177">the first #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="file2" transfer-ownership="none" gs:managed-name="file2" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="22178">the second #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file1" transfer-ownership="none" gs:managed-name="file1" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="22177">the first #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="file2" transfer-ownership="none" gs:managed-name="file2" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="22178">the second #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="is_native" gs:managed-name="IsNative">
        <callback name="is_native" gs:dll-name="gio-2.0" gs:managed-name="IsNative">
          <source-position filename="gfile.h" line="172" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23408">%TRUE if @file is native</doc>
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23394">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23394">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="has_uri_scheme" gs:managed-name="HasUriScheme">
        <callback name="has_uri_scheme" gs:dll-name="gio-2.0" gs:managed-name="HasUriScheme">
          <source-position filename="gfile.h" line="173" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22473">%TRUE if #GFile's backend supports the
    given URI scheme, %FALSE if URI scheme is %NULL,
    not supported, or #GFile is invalid.</doc>
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="22466">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="uri_scheme" transfer-ownership="none" gs:managed-name="uriScheme" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="22467">a string containing a URI scheme</doc>
              <type name="utf8" c:type="const char*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="22466">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="uri_scheme" transfer-ownership="none" gs:managed-name="uriScheme" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="22467">a string containing a URI scheme</doc>
              <type name="utf8" c:type="const char*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="get_uri_scheme" gs:managed-name="GetUriScheme">
        <callback name="get_uri_scheme" gs:dll-name="gio-2.0" gs:managed-name="GetUriScheme">
          <source-position filename="gfile.h" line="175" />
          <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22416">a string containing the URI scheme for the given
    #GFile or %NULL if the #GFile was constructed with an invalid URI. The
    returned string should be freed with g_free() when no longer needed.</doc>
            <type name="utf8" c:type="char*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="22402">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="22402">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="get_basename" gs:managed-name="GetBasename">
        <callback name="get_basename" gs:dll-name="gio-2.0" gs:managed-name="GetBasename">
          <source-position filename="gfile.h" line="176" />
          <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22268">string containing the #GFile's
    base name, or %NULL if given #GFile is invalid. The returned string
    should be freed with g_free() when no longer needed.</doc>
            <type name="filename" c:type="char*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="22252">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="22252">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="get_path" gs:managed-name="GetPath">
        <callback name="get_path" gs:dll-name="gio-2.0" gs:managed-name="GetPath">
          <source-position filename="gfile.h" line="177" />
          <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22363">string containing the #GFile's path,
    or %NULL if no such path exists. The returned string should be freed
    with g_free() when no longer needed.</doc>
            <type name="filename" c:type="char*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="22356">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="22356">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="get_uri" gs:managed-name="GetUri">
        <callback name="get_uri" gs:dll-name="gio-2.0" gs:managed-name="GetUri">
          <source-position filename="gfile.h" line="178" />
          <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22393">a string containing the #GFile's URI. If the #GFile was constructed
    with an invalid URI, an invalid URI is returned.
    The returned string should be freed with g_free()
    when no longer needed.</doc>
            <type name="utf8" c:type="char*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="22387">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="22387">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="get_parse_name" gs:managed-name="GetParseName">
        <callback name="get_parse_name" gs:dll-name="gio-2.0" gs:managed-name="GetParseName">
          <source-position filename="gfile.h" line="179" />
          <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22348">a string containing the #GFile's parse name.
    The returned string should be freed with g_free()
    when no longer needed.</doc>
            <type name="utf8" c:type="char*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="22331">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="22331">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="get_parent" gs:managed-name="GetParent">
        <callback name="get_parent" gs:dll-name="gio-2.0" gs:managed-name="GetParent">
          <source-position filename="gfile.h" line="180" />
          <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22323">a #GFile structure to the
    parent of the given #GFile or %NULL if there is no parent. Free
    the returned object with g_object_unref().</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="22315">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="22315">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="prefix_matches" gs:managed-name="PrefixMatches">
        <callback name="prefix_matches" gs:dll-name="gio-2.0" gs:managed-name="PrefixMatches">
          <source-position filename="gfile.h" line="181" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22459">%TRUE if the @file's parent, grandparent, etc is @prefix,
    %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="prefix" transfer-ownership="none" gs:managed-name="prefix" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="22442">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="22441">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="prefix" transfer-ownership="none" gs:managed-name="prefix" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="22442">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="22441">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="get_relative_path" gs:managed-name="GetRelativePath">
        <callback name="get_relative_path" gs:dll-name="gio-2.0" gs:managed-name="GetRelativePath">
          <source-position filename="gfile.h" line="183" />
          <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22378">string with the relative path from
    @descendant to @parent, or %NULL if @descendant doesn't have @parent as
    prefix. The returned string should be freed with g_free() when
    no longer needed.</doc>
            <type name="filename" c:type="char*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="parent" transfer-ownership="none" gs:managed-name="parent" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="22371">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="descendant" transfer-ownership="none" gs:managed-name="descendant" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="22372">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="parent" transfer-ownership="none" gs:managed-name="parent" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="22371">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="descendant" transfer-ownership="none" gs:managed-name="descendant" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="22372">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="resolve_relative_path" gs:managed-name="ResolveRelativePath">
        <callback name="resolve_relative_path" gs:dll-name="gio-2.0" gs:managed-name="ResolveRelativePath">
          <source-position filename="gfile.h" line="185" />
          <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25018">#GFile to the resolved path.
    %NULL if @relative_path is %NULL or if @file is invalid.
    Free the returned object with g_object_unref().</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25011">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="relative_path" transfer-ownership="none" gs:managed-name="relativePath" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25012">a given relative path string</doc>
              <type name="filename" c:type="const char*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25011">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="relative_path" transfer-ownership="none" gs:managed-name="relativePath" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25012">a given relative path string</doc>
              <type name="filename" c:type="const char*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="get_child_for_display_name" gs:managed-name="GetChildForDisplayName">
        <callback name="get_child_for_display_name" throws="1" gs:dll-name="gio-2.0" gs:managed-name="GetChildForDisplayName">
          <source-position filename="gfile.h" line="187" />
          <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22307">a #GFile to the specified child, or
    %NULL if the display name couldn't be converted.
    Free the returned object with g_object_unref().</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="22294">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="display_name" transfer-ownership="none" gs:managed-name="displayName" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="22295">string to a possible child</doc>
              <type name="utf8" c:type="const char*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="22294">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="display_name" transfer-ownership="none" gs:managed-name="displayName" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="22295">string to a possible child</doc>
              <type name="utf8" c:type="const char*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="enumerate_children" introspectable="1" gs:managed-name="EnumerateChildren">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="enumerate_children_async" gs:managed-name="EnumerateChildrenAsync">
        <callback name="enumerate_children_async" gs:dll-name="gio-2.0" gs:managed-name="EnumerateChildrenAsync">
          <source-position filename="gfile.h" line="196" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21898">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21899">an attribute query string</doc>
              <type name="utf8" c:type="const char*" gs:is-pointer="1" />
            </parameter>
            <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21900">a set of #GFileQueryInfoFlags</doc>
              <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21901">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21902">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="6" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21904">a #GAsyncReadyCallback to call when the
    request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="6" gs:managed-name="userData" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21906">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21898">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21899">an attribute query string</doc>
              <type name="utf8" c:type="const char*" gs:is-pointer="1" />
            </parameter>
            <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21900">a set of #GFileQueryInfoFlags</doc>
              <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21901">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="6" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21904">a #GAsyncReadyCallback to call when the
    request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21902">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="enumerate_children_finish" introspectable="1" gs:managed-name="EnumerateChildrenFinish">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="query_info" gs:managed-name="QueryInfo">
        <callback name="query_info" throws="1" gs:dll-name="gio-2.0" gs:managed-name="QueryInfo">
          <source-position filename="gfile.h" line="207" />
          <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24580">a #GFileInfo for the given @file, or %NULL
    on error. Free the returned object with g_object_unref().</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24542">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24543">an attribute query string</doc>
              <type name="utf8" c:type="const char*" gs:is-pointer="1" />
            </parameter>
            <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24544">a set of #GFileQueryInfoFlags</doc>
              <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24545">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24542">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24543">an attribute query string</doc>
              <type name="utf8" c:type="const char*" gs:is-pointer="1" />
            </parameter>
            <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24544">a set of #GFileQueryInfoFlags</doc>
              <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24545">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="query_info_async" gs:managed-name="QueryInfoAsync">
        <callback name="query_info_async" gs:dll-name="gio-2.0" gs:managed-name="QueryInfoAsync">
          <source-position filename="gfile.h" line="212" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24587">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24588">an attribute query string</doc>
              <type name="utf8" c:type="const char*" gs:is-pointer="1" />
            </parameter>
            <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24589">a set of #GFileQueryInfoFlags</doc>
              <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24590">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24591">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="6" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24593">a #GAsyncReadyCallback to call when the
    request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="6" gs:managed-name="userData" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24595">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24587">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24588">an attribute query string</doc>
              <type name="utf8" c:type="const char*" gs:is-pointer="1" />
            </parameter>
            <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24589">a set of #GFileQueryInfoFlags</doc>
              <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24590">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="6" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24593">a #GAsyncReadyCallback to call when the
    request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24591">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="query_info_finish" gs:managed-name="QueryInfoFinish">
        <callback name="query_info_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="QueryInfoFinish">
          <source-position filename="gfile.h" line="219" />
          <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24618">#GFileInfo for given @file
    or %NULL on error. Free the returned object with
    g_object_unref().</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24611">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24612">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24611">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24612">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="query_filesystem_info" gs:managed-name="QueryFilesystemInfo">
        <callback name="query_filesystem_info" throws="1" gs:dll-name="gio-2.0" gs:managed-name="QueryFilesystemInfo">
          <source-position filename="gfile.h" line="223" />
          <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24495">a #GFileInfo or %NULL if there was an error.
    Free the returned object with g_object_unref().</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24463">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24464">an attribute query string</doc>
              <type name="utf8" c:type="const char*" gs:is-pointer="1" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24465">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24463">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24464">an attribute query string</doc>
              <type name="utf8" c:type="const char*" gs:is-pointer="1" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24465">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="query_filesystem_info_async" gs:managed-name="QueryFilesystemInfoAsync">
        <callback name="query_filesystem_info_async" gs:dll-name="gio-2.0" gs:managed-name="QueryFilesystemInfoAsync">
          <source-position filename="gfile.h" line="227" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24502">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24503">an attribute query string</doc>
              <type name="utf8" c:type="const char*" gs:is-pointer="1" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24504">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24505">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24507">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5" gs:managed-name="userData" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24509">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24502">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24503">an attribute query string</doc>
              <type name="utf8" c:type="const char*" gs:is-pointer="1" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24504">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24507">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24505">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="query_filesystem_info_finish" gs:managed-name="QueryFilesystemInfoFinish">
        <callback name="query_filesystem_info_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="QueryFilesystemInfoFinish">
          <source-position filename="gfile.h" line="233" />
          <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24534">#GFileInfo for given @file
    or %NULL on error.
    Free the returned object with g_object_unref().</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24527">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24528">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24527">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24528">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="find_enclosing_mount" introspectable="1" gs:managed-name="FindEnclosingMount">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="find_enclosing_mount_async" gs:managed-name="FindEnclosingMountAsync">
        <callback name="find_enclosing_mount_async" gs:dll-name="gio-2.0" gs:managed-name="FindEnclosingMountAsync">
          <source-position filename="gfile.h" line="240" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="22217">a #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="22218">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="22219">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="22221">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4" gs:managed-name="userData" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="22223">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="22217">a #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="22218">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="22221">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="22219">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="find_enclosing_mount_finish" introspectable="1" gs:managed-name="FindEnclosingMountFinish">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="set_display_name" gs:managed-name="SetDisplayName">
        <callback name="set_display_name" throws="1" gs:dll-name="gio-2.0" gs:managed-name="SetDisplayName">
          <source-position filename="gfile.h" line="249" />
          <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25265">a #GFile specifying what @file was renamed to,
    or %NULL if there was an error.
    Free the returned object with g_object_unref().</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25243">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="display_name" transfer-ownership="none" gs:managed-name="displayName" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25244">a string</doc>
              <type name="utf8" c:type="const char*" gs:is-pointer="1" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25245">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25243">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="display_name" transfer-ownership="none" gs:managed-name="displayName" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25244">a string</doc>
              <type name="utf8" c:type="const char*" gs:is-pointer="1" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25245">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="set_display_name_async" gs:managed-name="SetDisplayNameAsync">
        <callback name="set_display_name_async" gs:dll-name="gio-2.0" gs:managed-name="SetDisplayNameAsync">
          <source-position filename="gfile.h" line="253" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25273">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="display_name" transfer-ownership="none" gs:managed-name="displayName" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25274">a string</doc>
              <type name="utf8" c:type="const char*" gs:is-pointer="1" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25275">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25276">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25278">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5" gs:managed-name="userData" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25280">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25273">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="display_name" transfer-ownership="none" gs:managed-name="displayName" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25274">a string</doc>
              <type name="utf8" c:type="const char*" gs:is-pointer="1" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25275">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25278">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25276">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="set_display_name_finish" gs:managed-name="SetDisplayNameFinish">
        <callback name="set_display_name_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="SetDisplayNameFinish">
          <source-position filename="gfile.h" line="259" />
          <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25302">a #GFile or %NULL on error.
    Free the returned object with g_object_unref().</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25295">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25296">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25295">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25296">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="query_settable_attributes" gs:managed-name="QuerySettableAttributes">
        <callback name="query_settable_attributes" throws="1" gs:dll-name="gio-2.0" gs:managed-name="QuerySettableAttributes">
          <source-position filename="gfile.h" line="263" />
          <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24642">a #GFileAttributeInfoList describing the settable attributes.
    When you are done with it, release it with
    g_file_attribute_info_list_unref()</doc>
            <type name="FileAttributeInfoList" c:type="GFileAttributeInfoList*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24626">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24627">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24626">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24627">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="_query_settable_attributes_async" introspectable="1" gs:managed-name="QuerySettableAttributesAsync">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="_query_settable_attributes_finish" introspectable="1" gs:managed-name="QuerySettableAttributesFinish">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="query_writable_namespaces" gs:managed-name="QueryWritableNamespaces">
        <callback name="query_writable_namespaces" throws="1" gs:dll-name="gio-2.0" gs:managed-name="QueryWritableNamespaces">
          <source-position filename="gfile.h" line="269" />
          <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24663">a #GFileAttributeInfoList describing the writable namespaces.
    When you are done with it, release it with
    g_file_attribute_info_list_unref()</doc>
            <type name="FileAttributeInfoList" c:type="GFileAttributeInfoList*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24650">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24651">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24650">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24651">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="_query_writable_namespaces_async" introspectable="1" gs:managed-name="QueryWritableNamespacesAsync">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="_query_writable_namespaces_finish" introspectable="1" gs:managed-name="QueryWritableNamespacesFinish">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="set_attribute" gs:managed-name="SetAttribute">
        <callback name="set_attribute" throws="1" gs:dll-name="gio-2.0" gs:managed-name="SetAttribute">
          <source-position filename="gfile.h" line="275" />
          <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25045">%TRUE if the attribute was set, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25026">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25027">a string containing the attribute's name</doc>
              <type name="utf8" c:type="const char*" gs:is-pointer="1" />
            </parameter>
            <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25028">The type of the attribute</doc>
              <type name="FileAttributeType" c:type="GFileAttributeType" />
            </parameter>
            <parameter name="value_p" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="valueP" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25029">a pointer to the value (or the pointer
    itself if the type is a pointer type)</doc>
              <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
            </parameter>
            <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25031">a set of #GFileQueryInfoFlags</doc>
              <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25032">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25026">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25027">a string containing the attribute's name</doc>
              <type name="utf8" c:type="const char*" gs:is-pointer="1" />
            </parameter>
            <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25028">The type of the attribute</doc>
              <type name="FileAttributeType" c:type="GFileAttributeType" />
            </parameter>
            <parameter name="value_p" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="valueP" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25029">a pointer to the value (or the pointer
    itself if the type is a pointer type)</doc>
              <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
            </parameter>
            <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25031">a set of #GFileQueryInfoFlags</doc>
              <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25032">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="set_attributes_from_info" gs:managed-name="SetAttributesFromInfo">
        <callback name="set_attributes_from_info" throws="1" gs:dll-name="gio-2.0" gs:managed-name="SetAttributesFromInfo">
          <source-position filename="gfile.h" line="282" />
          <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25237">%FALSE if there was any error, %TRUE otherwise.</doc>
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25217">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25218">a #GFileInfo</doc>
              <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
            </parameter>
            <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25219">#GFileQueryInfoFlags</doc>
              <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25220">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25217">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25218">a #GFileInfo</doc>
              <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
            </parameter>
            <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25219">#GFileQueryInfoFlags</doc>
              <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25220">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="set_attributes_async" gs:managed-name="SetAttributesAsync">
        <callback name="set_attributes_async" gs:dll-name="gio-2.0" gs:managed-name="SetAttributesAsync">
          <source-position filename="gfile.h" line="287" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25182">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25183">a #GFileInfo</doc>
              <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
            </parameter>
            <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25184">a #GFileQueryInfoFlags</doc>
              <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25185">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25186">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="6" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25188">a #GAsyncReadyCallback</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="6" gs:managed-name="userData" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25189">a #gpointer</doc>
              <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25182">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25183">a #GFileInfo</doc>
              <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
            </parameter>
            <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25184">a #GFileQueryInfoFlags</doc>
              <type name="FileQueryInfoFlags" c:type="GFileQueryInfoFlags" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25185">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="6" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25188">a #GAsyncReadyCallback</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25186">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="set_attributes_finish" gs:managed-name="SetAttributesFinish">
        <callback name="set_attributes_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="SetAttributesFinish">
          <source-position filename="gfile.h" line="294" />
          <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25211">%TRUE if the attributes were set correctly, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25204">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25205">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
            <parameter name="info" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="info">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25206">a #GFileInfo</doc>
              <type name="FileInfo" c:type="GFileInfo**" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25204">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25205">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
            <parameter name="info" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="info">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25206">a #GFileInfo</doc>
              <type name="FileInfo" c:type="GFileInfo**" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="read_fn" gs:managed-name="ReadFn">
        <callback name="read_fn" throws="1" gs:dll-name="gio-2.0" gs:managed-name="ReadFn">
          <source-position filename="gfile.h" line="299" />
          <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24687">#GFileInputStream or %NULL on error.
    Free the returned object with g_object_unref().</doc>
            <type name="FileInputStream" c:type="GFileInputStream*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24671">#GFile to read</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24672">a #GCancellable</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24671">#GFile to read</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24672">a #GCancellable</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="read_async" gs:managed-name="ReadAsync">
        <callback name="read_async" gs:dll-name="gio-2.0" gs:managed-name="ReadAsync">
          <source-position filename="gfile.h" line="302" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24694">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24695">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24696">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24698">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4" gs:managed-name="userData" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24700">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24694">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24695">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24698">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24696">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="read_finish" gs:managed-name="ReadFinish">
        <callback name="read_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="ReadFinish">
          <source-position filename="gfile.h" line="307" />
          <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24722">a #GFileInputStream or %NULL on error.
    Free the returned object with g_object_unref().</doc>
            <type name="FileInputStream" c:type="GFileInputStream*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24715">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24716">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24715">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24716">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="append_to" gs:managed-name="AppendTo">
        <callback name="append_to" throws="1" gs:dll-name="gio-2.0" gs:managed-name="AppendTo">
          <source-position filename="gfile.h" line="311" />
          <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21134">a #GFileOutputStream, or %NULL on error.
    Free the returned object with g_object_unref().</doc>
            <type name="FileOutputStream" c:type="GFileOutputStream*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21110">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21111">a set of #GFileCreateFlags</doc>
              <type name="FileCreateFlags" c:type="GFileCreateFlags" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21112">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21110">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21111">a set of #GFileCreateFlags</doc>
              <type name="FileCreateFlags" c:type="GFileCreateFlags" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21112">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="append_to_async" gs:managed-name="AppendToAsync">
        <callback name="append_to_async" gs:dll-name="gio-2.0" gs:managed-name="AppendToAsync">
          <source-position filename="gfile.h" line="315" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21141">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21142">a set of #GFileCreateFlags</doc>
              <type name="FileCreateFlags" c:type="GFileCreateFlags" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21143">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21144">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21146">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5" gs:managed-name="userData" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21148">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21141">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21142">a set of #GFileCreateFlags</doc>
              <type name="FileCreateFlags" c:type="GFileCreateFlags" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21143">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21146">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21144">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="append_to_finish" gs:managed-name="AppendToFinish">
        <callback name="append_to_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="AppendToFinish">
          <source-position filename="gfile.h" line="321" />
          <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21170">a valid #GFileOutputStream
    or %NULL on error.
    Free the returned object with g_object_unref().</doc>
            <type name="FileOutputStream" c:type="GFileOutputStream*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21163">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21164">#GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21163">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21164">#GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="create" gs:managed-name="Create">
        <callback name="create" throws="1" gs:dll-name="gio-2.0" gs:managed-name="Create">
          <source-position filename="gfile.h" line="325" />
          <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21562">a #GFileOutputStream for the newly created
    file, or %NULL on error.
    Free the returned object with g_object_unref().</doc>
            <type name="FileOutputStream" c:type="GFileOutputStream*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21536">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21537">a set of #GFileCreateFlags</doc>
              <type name="FileCreateFlags" c:type="GFileCreateFlags" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21538">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21536">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21537">a set of #GFileCreateFlags</doc>
              <type name="FileCreateFlags" c:type="GFileCreateFlags" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21538">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="create_async" gs:managed-name="CreateAsync">
        <callback name="create_async" gs:dll-name="gio-2.0" gs:managed-name="CreateAsync">
          <source-position filename="gfile.h" line="329" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21570">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21571">a set of #GFileCreateFlags</doc>
              <type name="FileCreateFlags" c:type="GFileCreateFlags" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21572">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21573">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21575">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5" gs:managed-name="userData" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21577">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21570">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21571">a set of #GFileCreateFlags</doc>
              <type name="FileCreateFlags" c:type="GFileCreateFlags" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21572">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21575">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21573">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="create_finish" gs:managed-name="CreateFinish">
        <callback name="create_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="CreateFinish">
          <source-position filename="gfile.h" line="335" />
          <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21600">a #GFileOutputStream or %NULL on error.
    Free the returned object with g_object_unref().</doc>
            <type name="FileOutputStream" c:type="GFileOutputStream*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21593">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21594">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21593">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21594">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="replace" gs:managed-name="Replace">
        <callback name="replace" throws="1" gs:dll-name="gio-2.0" gs:managed-name="Replace">
          <source-position filename="gfile.h" line="339" />
          <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24780">a #GFileOutputStream or %NULL on error.
    Free the returned object with g_object_unref().</doc>
            <type name="FileOutputStream" c:type="GFileOutputStream*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24729">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="etag" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="etag" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24730">an optional [entity tag][gfile-etag]
    for the current #GFile, or #NULL to ignore</doc>
              <type name="utf8" c:type="const char*" gs:is-pointer="1" />
            </parameter>
            <parameter name="make_backup" transfer-ownership="none" gs:managed-name="makeBackup" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24732">%TRUE if a backup should be created</doc>
              <type name="gboolean" c:type="gboolean" />
            </parameter>
            <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24733">a set of #GFileCreateFlags</doc>
              <type name="FileCreateFlags" c:type="GFileCreateFlags" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24734">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24729">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="etag" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="etag" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24730">an optional [entity tag][gfile-etag]
    for the current #GFile, or #NULL to ignore</doc>
              <type name="utf8" c:type="const char*" gs:is-pointer="1" />
            </parameter>
            <parameter name="make_backup" transfer-ownership="none" gs:managed-name="makeBackup" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24732">%TRUE if a backup should be created</doc>
              <type name="gboolean" c:type="gboolean" />
            </parameter>
            <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24733">a set of #GFileCreateFlags</doc>
              <type name="FileCreateFlags" c:type="GFileCreateFlags" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24734">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="replace_async" gs:managed-name="ReplaceAsync">
        <callback name="replace_async" gs:dll-name="gio-2.0" gs:managed-name="ReplaceAsync">
          <source-position filename="gfile.h" line="345" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24787">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="etag" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="etag" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24788">an [entity tag][gfile-etag] for the current #GFile,
    or %NULL to ignore</doc>
              <type name="utf8" c:type="const char*" gs:is-pointer="1" />
            </parameter>
            <parameter name="make_backup" transfer-ownership="none" gs:managed-name="makeBackup" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24790">%TRUE if a backup should be created</doc>
              <type name="gboolean" c:type="gboolean" />
            </parameter>
            <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24791">a set of #GFileCreateFlags</doc>
              <type name="FileCreateFlags" c:type="GFileCreateFlags" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24792">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24793">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="7" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24795">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="7" gs:managed-name="userData" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24797">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24787">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="etag" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="etag" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24788">an [entity tag][gfile-etag] for the current #GFile,
    or %NULL to ignore</doc>
              <type name="utf8" c:type="const char*" gs:is-pointer="1" />
            </parameter>
            <parameter name="make_backup" transfer-ownership="none" gs:managed-name="makeBackup" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24790">%TRUE if a backup should be created</doc>
              <type name="gboolean" c:type="gboolean" />
            </parameter>
            <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24791">a set of #GFileCreateFlags</doc>
              <type name="FileCreateFlags" c:type="GFileCreateFlags" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24792">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="7" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24795">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24793">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="replace_finish" gs:managed-name="ReplaceFinish">
        <callback name="replace_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="ReplaceFinish">
          <source-position filename="gfile.h" line="353" />
          <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24932">a #GFileOutputStream, or %NULL on error.
    Free the returned object with g_object_unref().</doc>
            <type name="FileOutputStream" c:type="GFileOutputStream*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24925">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24926">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24925">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24926">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="delete_file" gs:managed-name="DeleteFile">
        <callback name="delete_file" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DeleteFile">
          <source-position filename="gfile.h" line="357" />
          <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21713">%TRUE if the file was deleted. %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21686">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21687">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21686">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21687">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="delete_file_async" gs:managed-name="DeleteFileAsync">
        <callback name="delete_file_async" gs:dll-name="gio-2.0" gs:managed-name="DeleteFileAsync">
          <source-position filename="gfile.h" line="360" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21719">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21720">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21721">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21723">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4" gs:managed-name="userData" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21725">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21719">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21720">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21723">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21721">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="delete_file_finish" gs:managed-name="DeleteFileFinish">
        <callback name="delete_file_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DeleteFileFinish">
          <source-position filename="gfile.h" line="365" />
          <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21743">%TRUE if the file was deleted. %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21737">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21738">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21737">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21738">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="trash" gs:managed-name="Trash">
        <callback name="trash" throws="1" gs:dll-name="gio-2.0" gs:managed-name="Trash">
          <source-position filename="gfile.h" line="369" />
          <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25424">%TRUE on successful trash, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25408">#GFile to send to trash</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25409">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25408">#GFile to send to trash</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25409">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="trash_async" gs:managed-name="TrashAsync">
        <callback name="trash_async" gs:dll-name="gio-2.0" gs:managed-name="TrashAsync">
          <source-position filename="gfile.h" line="372" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25430">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25431">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25432">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25434">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4" gs:managed-name="userData" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25436">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25430">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25431">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25434">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25432">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="trash_finish" gs:managed-name="TrashFinish">
        <callback name="trash_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="TrashFinish">
          <source-position filename="gfile.h" line="377" />
          <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25453">%TRUE on successful trash, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25446">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25447">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25446">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25447">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="make_directory" gs:managed-name="MakeDirectory">
        <callback name="make_directory" throws="1" gs:dll-name="gio-2.0" gs:managed-name="MakeDirectory">
          <source-position filename="gfile.h" line="381" />
          <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23622">%TRUE on successful creation, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23602">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23603">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23602">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23603">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="make_directory_async" gs:managed-name="MakeDirectoryAsync">
        <callback name="make_directory_async" gs:dll-name="gio-2.0" gs:managed-name="MakeDirectoryAsync">
          <source-position filename="gfile.h" line="384" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23628">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23629">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23630">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23632">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4" gs:managed-name="userData" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23634">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23628">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23629">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23632">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23630">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="make_directory_finish" gs:managed-name="MakeDirectoryFinish">
        <callback name="make_directory_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="MakeDirectoryFinish">
          <source-position filename="gfile.h" line="389" />
          <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23651">%TRUE on successful directory creation, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23644">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23645">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23644">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23645">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="make_symbolic_link" gs:managed-name="MakeSymbolicLink">
        <callback name="make_symbolic_link" throws="1" gs:dll-name="gio-2.0" gs:managed-name="MakeSymbolicLink">
          <source-position filename="gfile.h" line="393" />
          <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23699">%TRUE on the creation of a new symlink, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23685">a #GFile with the name of the symlink to create</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="symlink_value" transfer-ownership="none" gs:managed-name="symlinkValue" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23686">a string with the path for the target
    of the new symlink</doc>
              <type name="filename" c:type="const char*" gs:is-pointer="1" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23688">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23685">a #GFile with the name of the symlink to create</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="symlink_value" transfer-ownership="none" gs:managed-name="symlinkValue" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23686">a string with the path for the target
    of the new symlink</doc>
              <type name="filename" c:type="const char*" gs:is-pointer="1" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23688">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="_make_symbolic_link_async" introspectable="1" gs:managed-name="MakeSymbolicLinkAsync">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="_make_symbolic_link_finish" introspectable="1" gs:managed-name="MakeSymbolicLinkFinish">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="copy" gs:managed-name="Copy">
        <callback name="copy" throws="1" gs:dll-name="gio-2.0" gs:managed-name="Copy">
          <source-position filename="gfile.h" line="400" />
          <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21468">%TRUE on success, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21417">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="destination" transfer-ownership="none" gs:managed-name="destination" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21418">destination #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21419">set of #GFileCopyFlags</doc>
              <type name="FileCopyFlags" c:type="GFileCopyFlags" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21420">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <parameter name="progress_callback" transfer-ownership="none" nullable="1" allow-none="1" scope="call" closure="5" gs:managed-name="progressCallback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21422">function to callback with
    progress information, or %NULL if progress information is not needed</doc>
              <type name="FileProgressCallback" c:type="GFileProgressCallback" />
            </parameter>
            <parameter name="progress_callback_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="progressCallbackData" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21424">user data to pass to @progress_callback</doc>
              <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21417">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="destination" transfer-ownership="none" gs:managed-name="destination" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21418">destination #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21419">set of #GFileCopyFlags</doc>
              <type name="FileCopyFlags" c:type="GFileCopyFlags" />
            </parameter>
            <parameter name="progress_callback" transfer-ownership="none" nullable="1" allow-none="1" scope="call" closure="5" gs:managed-name="progressCallback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21422">function to callback with
    progress information, or %NULL if progress information is not needed</doc>
              <type name="FileProgressCallback" c:type="GFileProgressCallback" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21420">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="copy_async" gs:managed-name="CopyAsync">
        <callback name="copy_async" gs:dll-name="gio-2.0" gs:managed-name="CopyAsync">
          <source-position filename="gfile.h" line="407" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21474">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="destination" transfer-ownership="none" gs:managed-name="destination" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21475">destination #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21476">set of #GFileCopyFlags</doc>
              <type name="FileCopyFlags" c:type="GFileCopyFlags" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21477">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21478">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <parameter name="progress_callback" transfer-ownership="none" nullable="1" allow-none="1" scope="notified" closure="6" gs:managed-name="progressCallback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21480">function to callback with progress
    information, or %NULL if progress information is not needed</doc>
              <type name="FileProgressCallback" c:type="GFileProgressCallback" />
            </parameter>
            <parameter name="progress_callback_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5" gs:managed-name="progressCallbackData" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21482">user data to pass to @progress_callback</doc>
              <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="8" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21483">a #GAsyncReadyCallback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="7" gs:managed-name="userData" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21484">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21474">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="destination" transfer-ownership="none" gs:managed-name="destination" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21475">destination #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21476">set of #GFileCopyFlags</doc>
              <type name="FileCopyFlags" c:type="GFileCopyFlags" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21477">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="progress_callback" transfer-ownership="none" nullable="1" allow-none="1" scope="notified" closure="6" gs:managed-name="progressCallback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21480">function to callback with progress
    information, or %NULL if progress information is not needed</doc>
              <type name="FileProgressCallback" c:type="GFileProgressCallback" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="8" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21483">a #GAsyncReadyCallback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21478">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="copy_finish" gs:managed-name="CopyFinish">
        <callback name="copy_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="CopyFinish">
          <source-position filename="gfile.h" line="416" />
          <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21530">a %TRUE on success, %FALSE on error.</doc>
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21524">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21525">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21524">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21525">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="move" gs:managed-name="Move">
        <callback name="move" throws="1" gs:dll-name="gio-2.0" gs:managed-name="Move">
          <source-position filename="gfile.h" line="420" />
          <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24033">%TRUE on successful move, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23988">#GFile pointing to the source location</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="destination" transfer-ownership="none" gs:managed-name="destination" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23989">#GFile pointing to the destination location</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23990">set of #GFileCopyFlags</doc>
              <type name="FileCopyFlags" c:type="GFileCopyFlags" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23991">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <parameter name="progress_callback" transfer-ownership="none" nullable="1" allow-none="1" scope="call" closure="5" gs:managed-name="progressCallback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23993">#GFileProgressCallback
    function for updates</doc>
              <type name="FileProgressCallback" c:type="GFileProgressCallback" />
            </parameter>
            <parameter name="progress_callback_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="progressCallbackData" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23995">gpointer to user data for
    the callback function</doc>
              <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23988">#GFile pointing to the source location</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="destination" transfer-ownership="none" gs:managed-name="destination" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23989">#GFile pointing to the destination location</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23990">set of #GFileCopyFlags</doc>
              <type name="FileCopyFlags" c:type="GFileCopyFlags" />
            </parameter>
            <parameter name="progress_callback" transfer-ownership="none" nullable="1" allow-none="1" scope="call" closure="5" gs:managed-name="progressCallback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23993">#GFileProgressCallback
    function for updates</doc>
              <type name="FileProgressCallback" c:type="GFileProgressCallback" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23991">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="_move_async" introspectable="1" gs:managed-name="MoveAsync">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="_move_finish" introspectable="1" gs:managed-name="MoveFinish">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="mount_mountable" introspectable="1" gs:managed-name="MountMountable">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="mount_mountable_finish" gs:managed-name="MountMountableFinish">
        <callback name="mount_mountable_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="MountMountableFinish">
          <source-position filename="gfile.h" line="436" />
          <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23981">a #GFile or %NULL on error.
    Free the returned object with g_object_unref().</doc>
            <type name="File" c:type="GFile*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23972">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23973">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23972">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23973">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="unmount_mountable" introspectable="1" gs:managed-name="UnmountMountable">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="unmount_mountable_finish" gs:managed-name="UnmountMountableFinish">
        <callback name="unmount_mountable_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="UnmountMountableFinish">
          <source-position filename="gfile.h" line="445" />
          <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25493">%TRUE if the operation finished successfully.
    %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25484">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25485">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25484">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25485">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="eject_mountable" introspectable="1" gs:managed-name="EjectMountable">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="eject_mountable_finish" gs:managed-name="EjectMountableFinish">
        <callback name="eject_mountable_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="EjectMountableFinish">
          <source-position filename="gfile.h" line="454" />
          <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21811">%TRUE if the @file was ejected successfully.
    %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21804">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21805">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21804">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21805">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="mount_enclosing_volume" introspectable="1" gs:managed-name="MountEnclosingVolume">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="mount_enclosing_volume_finish" gs:managed-name="MountEnclosingVolumeFinish">
        <callback name="mount_enclosing_volume_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="MountEnclosingVolumeFinish">
          <source-position filename="gfile.h" line="464" />
          <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23938">%TRUE if successful. If an error has occurred,
    this function will return %FALSE and set @error
    appropriately if present.</doc>
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="location" transfer-ownership="none" gs:managed-name="location" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23932">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23933">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="location" transfer-ownership="none" gs:managed-name="location" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23932">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23933">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="monitor_dir" introspectable="1" gs:managed-name="MonitorDir">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="monitor_file" introspectable="1" gs:managed-name="MonitorFile">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="open_readwrite" gs:managed-name="OpenReadwrite">
        <callback name="open_readwrite" throws="1" gs:dll-name="gio-2.0" gs:managed-name="OpenReadwrite">
          <source-position filename="gfile.h" line="477" />
          <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24174">#GFileIOStream or %NULL on error.
    Free the returned object with g_object_unref().</doc>
            <type name="FileIOStream" c:type="GFileIOStream*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24153">#GFile to open</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24154">a #GCancellable</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24153">#GFile to open</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24154">a #GCancellable</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="open_readwrite_async" gs:managed-name="OpenReadwriteAsync">
        <callback name="open_readwrite_async" gs:dll-name="gio-2.0" gs:managed-name="OpenReadwriteAsync">
          <source-position filename="gfile.h" line="480" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24182">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24183">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24184">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24186">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4" gs:managed-name="userData" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24188">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24182">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24183">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24186">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24184">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="open_readwrite_finish" gs:managed-name="OpenReadwriteFinish">
        <callback name="open_readwrite_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="OpenReadwriteFinish">
          <source-position filename="gfile.h" line="485" />
          <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24212">a #GFileIOStream or %NULL on error.
    Free the returned object with g_object_unref().</doc>
            <type name="FileIOStream" c:type="GFileIOStream*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24205">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24206">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24205">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24206">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="create_readwrite" gs:managed-name="CreateReadwrite">
        <callback name="create_readwrite" throws="1" gs:dll-name="gio-2.0" gs:managed-name="CreateReadwrite">
          <source-position filename="gfile.h" line="488" />
          <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21637">a #GFileIOStream for the newly created
    file, or %NULL on error.
    Free the returned object with g_object_unref().</doc>
            <type name="FileIOStream" c:type="GFileIOStream*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21607">a #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21608">a set of #GFileCreateFlags</doc>
              <type name="FileCreateFlags" c:type="GFileCreateFlags" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21609">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21607">a #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21608">a set of #GFileCreateFlags</doc>
              <type name="FileCreateFlags" c:type="GFileCreateFlags" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21609">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="create_readwrite_async" gs:managed-name="CreateReadwriteAsync">
        <callback name="create_readwrite_async" gs:dll-name="gio-2.0" gs:managed-name="CreateReadwriteAsync">
          <source-position filename="gfile.h" line="492" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21646">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21647">a set of #GFileCreateFlags</doc>
              <type name="FileCreateFlags" c:type="GFileCreateFlags" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21648">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21649">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21651">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5" gs:managed-name="userData" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21653">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21646">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21647">a set of #GFileCreateFlags</doc>
              <type name="FileCreateFlags" c:type="GFileCreateFlags" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21648">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21651">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21649">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="create_readwrite_finish" gs:managed-name="CreateReadwriteFinish">
        <callback name="create_readwrite_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="CreateReadwriteFinish">
          <source-position filename="gfile.h" line="498" />
          <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21678">a #GFileIOStream or %NULL on error.
    Free the returned object with g_object_unref().</doc>
            <type name="FileIOStream" c:type="GFileIOStream*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21671">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21672">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21671">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21672">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="replace_readwrite" gs:managed-name="ReplaceReadwrite">
        <callback name="replace_readwrite" throws="1" gs:dll-name="gio-2.0" gs:managed-name="ReplaceReadwrite">
          <source-position filename="gfile.h" line="501" />
          <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24959">a #GFileIOStream or %NULL on error.
    Free the returned object with g_object_unref().</doc>
            <type name="FileIOStream" c:type="GFileIOStream*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24939">a #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="etag" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="etag" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24940">an optional [entity tag][gfile-etag]
    for the current #GFile, or #NULL to ignore</doc>
              <type name="utf8" c:type="const char*" gs:is-pointer="1" />
            </parameter>
            <parameter name="make_backup" transfer-ownership="none" gs:managed-name="makeBackup" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24942">%TRUE if a backup should be created</doc>
              <type name="gboolean" c:type="gboolean" />
            </parameter>
            <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24943">a set of #GFileCreateFlags</doc>
              <type name="FileCreateFlags" c:type="GFileCreateFlags" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24944">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24939">a #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="etag" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="etag" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24940">an optional [entity tag][gfile-etag]
    for the current #GFile, or #NULL to ignore</doc>
              <type name="utf8" c:type="const char*" gs:is-pointer="1" />
            </parameter>
            <parameter name="make_backup" transfer-ownership="none" gs:managed-name="makeBackup" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24942">%TRUE if a backup should be created</doc>
              <type name="gboolean" c:type="gboolean" />
            </parameter>
            <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24943">a set of #GFileCreateFlags</doc>
              <type name="FileCreateFlags" c:type="GFileCreateFlags" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24944">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="replace_readwrite_async" gs:managed-name="ReplaceReadwriteAsync">
        <callback name="replace_readwrite_async" gs:dll-name="gio-2.0" gs:managed-name="ReplaceReadwriteAsync">
          <source-position filename="gfile.h" line="507" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24967">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="etag" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="etag" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24968">an [entity tag][gfile-etag] for the current #GFile,
    or %NULL to ignore</doc>
              <type name="utf8" c:type="const char*" gs:is-pointer="1" />
            </parameter>
            <parameter name="make_backup" transfer-ownership="none" gs:managed-name="makeBackup" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24970">%TRUE if a backup should be created</doc>
              <type name="gboolean" c:type="gboolean" />
            </parameter>
            <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24971">a set of #GFileCreateFlags</doc>
              <type name="FileCreateFlags" c:type="GFileCreateFlags" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24972">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24973">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="7" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24975">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="7" gs:managed-name="userData" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24977">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24967">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="etag" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="etag" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24968">an [entity tag][gfile-etag] for the current #GFile,
    or %NULL to ignore</doc>
              <type name="utf8" c:type="const char*" gs:is-pointer="1" />
            </parameter>
            <parameter name="make_backup" transfer-ownership="none" gs:managed-name="makeBackup" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24970">%TRUE if a backup should be created</doc>
              <type name="gboolean" c:type="gboolean" />
            </parameter>
            <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24971">a set of #GFileCreateFlags</doc>
              <type name="FileCreateFlags" c:type="GFileCreateFlags" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24972">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="7" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24975">a #GAsyncReadyCallback to call
    when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24973">optional #GCancellable object,
    %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="replace_readwrite_finish" gs:managed-name="ReplaceReadwriteFinish">
        <callback name="replace_readwrite_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="ReplaceReadwriteFinish">
          <source-position filename="gfile.h" line="515" />
          <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25003">a #GFileIOStream, or %NULL on error.
    Free the returned object with g_object_unref().</doc>
            <type name="FileIOStream" c:type="GFileIOStream*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24996">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24997">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24996">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24997">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="start_mountable" introspectable="1" gs:managed-name="StartMountable">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="start_mountable_finish" gs:managed-name="StartMountableFinish">
        <callback name="start_mountable_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="StartMountableFinish">
          <source-position filename="gfile.h" line="525" />
          <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25343">%TRUE if the operation finished successfully. %FALSE
otherwise.</doc>
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25334">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25335">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25334">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25335">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="stop_mountable" introspectable="1" gs:managed-name="StopMountable">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="stop_mountable_finish" gs:managed-name="StopMountableFinish">
        <callback name="stop_mountable_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="StopMountableFinish">
          <source-position filename="gfile.h" line="535" />
          <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25386">%TRUE if the operation finished successfully.
    %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25377">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25378">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25377">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25378">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="supports_thread_contexts" gs:managed-name="SupportsThreadContexts">
        <doc xml:space="preserve" filename="gfile.h" line="149">a boolean that indicates whether the #GFile implementation supports thread-default contexts. Since 2.22.</doc>
        <type name="gboolean" c:type="gboolean" />
      </field>
      <field name="unmount_mountable_with_operation" introspectable="1" gs:managed-name="UnmountMountableWithOperation">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="unmount_mountable_with_operation_finish" gs:managed-name="UnmountMountableWithOperationFinish">
        <callback name="unmount_mountable_with_operation_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="UnmountMountableWithOperationFinish">
          <source-position filename="gfile.h" line="547" />
          <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25538">%TRUE if the operation finished successfully.
    %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25528">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25529">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25528">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25529">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="eject_mountable_with_operation" introspectable="1" gs:managed-name="EjectMountableWithOperation">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="eject_mountable_with_operation_finish" gs:managed-name="EjectMountableWithOperationFinish">
        <callback name="eject_mountable_with_operation_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="EjectMountableWithOperationFinish">
          <source-position filename="gfile.h" line="557" />
          <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="21852">%TRUE if the @file was ejected successfully.
    %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21845">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21846">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21845">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="21846">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="poll_mountable" gs:managed-name="PollMountable">
        <callback name="poll_mountable" gs:dll-name="gio-2.0" gs:managed-name="PollMountable">
          <source-position filename="gfile.h" line="561" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24323">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24324">optional #GCancellable object, %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24325">a #GAsyncReadyCallback to call
    when the request is satisfied, or %NULL</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3" gs:managed-name="userData" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24327">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24323">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24325">a #GAsyncReadyCallback to call
    when the request is satisfied, or %NULL</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24324">optional #GCancellable object, %NULL to ignore</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="poll_mountable_finish" gs:managed-name="PollMountableFinish">
        <callback name="poll_mountable_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="PollMountableFinish">
          <source-position filename="gfile.h" line="565" />
          <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24354">%TRUE if the operation finished successfully. %FALSE
otherwise.</doc>
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24345">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24346">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24345">input #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24346">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="measure_disk_usage" introspectable="1" gs:managed-name="MeasureDiskUsage">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="measure_disk_usage_async" introspectable="1" gs:managed-name="MeasureDiskUsageAsync">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="measure_disk_usage_finish" gs:managed-name="MeasureDiskUsageFinish">
        <callback name="measure_disk_usage_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="MeasureDiskUsageFinish">
          <source-position filename="gfile.h" line="586" />
          <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23773">%TRUE if successful, with the out parameters set.
         %FALSE otherwise, with @error set.</doc>
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23762">a #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23763">the #GAsyncResult passed to your #GAsyncReadyCallback</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
            <parameter name="disk_usage" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="diskUsage">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23764">the number of bytes of disk space used</doc>
              <type name="guint64" c:type="guint64*" />
            </parameter>
            <parameter name="num_dirs" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="numDirs">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23765">the number of directories encountered</doc>
              <type name="guint64" c:type="guint64*" />
            </parameter>
            <parameter name="num_files" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="numFiles">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23766">the number of non-directories encountered</doc>
              <type name="guint64" c:type="guint64*" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23762">a #GFile</doc>
              <type name="File" c:type="GFile*" gs:is-pointer="1" />
            </parameter>
            <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23763">the #GAsyncResult passed to your #GAsyncReadyCallback</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
            <parameter name="disk_usage" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="diskUsage">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23764">the number of bytes of disk space used</doc>
              <type name="guint64" c:type="guint64*" />
            </parameter>
            <parameter name="num_dirs" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="numDirs">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23765">the number of directories encountered</doc>
              <type name="guint64" c:type="guint64*" />
            </parameter>
            <parameter name="num_files" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="numFiles">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23766">the number of non-directories encountered</doc>
              <type name="guint64" c:type="guint64*" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
    </record>
    <class name="FileInfo" c:symbol-prefix="file_info" c:type="GFileInfo" parent="GObject.Object" glib:type-name="GFileInfo" glib:get-type="g_file_info_get_type" glib:type-struct="FileInfoClass" gs:managed-name="FileInfo">
      <doc xml:space="preserve" filename="gio-2.0.c" line="6456">Functionality for manipulating basic metadata for files. #GFileInfo
implements methods for getting information that all files should
contain, and allows for manipulation of extended attributes.

See [GFileAttribute][gio-GFileAttribute] for more information on how
GIO handles file attributes.

To obtain a #GFileInfo for a #GFile, use g_file_query_info() (or its
async variant). To obtain a #GFileInfo for a file input or output
stream, use g_file_input_stream_query_info() or
g_file_output_stream_query_info() (or their async variants).

To change the actual attributes of a file, you should then set the
attribute in the #GFileInfo and call g_file_set_attributes_from_info()
or g_file_set_attributes_async() on a GFile.

However, not all attributes can be changed in the file. For instance,
the actual size of a file cannot be changed via g_file_info_set_size().
You may call g_file_query_settable_attributes() and
g_file_query_writable_namespaces() to discover the settable attributes
of a particular file at runtime.

#GFileAttributeMatcher allows for searching through a #GFileInfo for
attributes.</doc>
      <source-position filename="gfileinfo.h" line="44" />
      <constructor name="new" c:identifier="g_file_info_new" gs:dll-name="gio-2.0" gs:managed-name="New">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22944">Creates a new file info structure.</doc>
        <source-position filename="gfileinfo.h" line="918" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22949">a #GFileInfo.</doc>
          <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </constructor>
      <method name="clear_status" c:identifier="g_file_info_clear_status" gs:dll-name="gio-2.0" gs:managed-name="ClearStatus">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22515">Clears the status information from @info.</doc>
        <source-position filename="gfileinfo.h" line="1026" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22517">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="copy_into" c:identifier="g_file_info_copy_into" gs:dll-name="gio-2.0" gs:managed-name="CopyInto">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22523">First clears all of the [GFileAttribute][gio-GFileAttribute] of @dest_info,
and then copies all of the file attributes from @src_info to @dest_info.</doc>
        <source-position filename="gfileinfo.h" line="922" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="src_info" transfer-ownership="none" gs:managed-name="srcInfo" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22525">source to copy attributes from.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="dest_info" transfer-ownership="none" gs:managed-name="destInfo" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22526">destination to copy attributes to.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="dest_info" transfer-ownership="none" gs:managed-name="destInfo" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22526">destination to copy attributes to.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="dup" c:identifier="g_file_info_dup" gs:dll-name="gio-2.0" gs:managed-name="Dup">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22533">Duplicates a file info structure.</doc>
        <source-position filename="gfileinfo.h" line="920" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22539">a duplicate #GFileInfo of @other.</doc>
          <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="other" transfer-ownership="none" gs:managed-name="other" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22535">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="get_attribute_as_string" c:identifier="g_file_info_get_attribute_as_string" gs:dll-name="gio-2.0" gs:managed-name="GetAttributeAsString">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22543">Gets the value of a attribute, formatted as a string.
This escapes things as needed to make the string valid
UTF-8.</doc>
        <source-position filename="gfileinfo.h" line="953" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22552">a UTF-8 string associated with the given @attribute, or
   %NULL if the attribute wasn’t set.
   When you're done with the string it must be freed with g_free().</doc>
          <type name="utf8" c:type="char*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22545">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22546">a file attribute key.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22546">a file attribute key.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_attribute_boolean" c:identifier="g_file_info_get_attribute_boolean" gs:dll-name="gio-2.0" gs:managed-name="GetAttributeBoolean">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22558">Gets the value of a boolean attribute. If the attribute does not
contain a boolean value, %FALSE will be returned.</doc>
        <source-position filename="gfileinfo.h" line="962" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22566">the boolean value contained within the attribute.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22560">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22561">a file attribute key.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22561">a file attribute key.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_attribute_byte_string" c:identifier="g_file_info_get_attribute_byte_string" gs:dll-name="gio-2.0" gs:managed-name="GetAttributeByteString">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22570">Gets the value of a byte string attribute. If the attribute does
not contain a byte string, %NULL will be returned.</doc>
        <source-position filename="gfileinfo.h" line="959" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22578">the contents of the @attribute value as a byte string, or
%NULL otherwise.</doc>
          <type name="utf8" c:type="const char*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22572">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22573">a file attribute key.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22573">a file attribute key.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_attribute_data" c:identifier="g_file_info_get_attribute_data" gs:dll-name="gio-2.0" gs:managed-name="TryGetAttributeData">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22583">Gets the attribute type, value and status for an attribute key.</doc>
        <source-position filename="gfileinfo.h" line="934" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22594">%TRUE if @info has an attribute named @attribute,
     %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22585">a #GFileInfo</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22586">a file attribute key</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="type" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="type">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22587">return location for the attribute type, or %NULL</doc>
            <type name="FileAttributeType" c:type="GFileAttributeType*" />
          </parameter>
          <parameter name="value_pp" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="valuePp">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22588">return location for the
   attribute value, or %NULL; the attribute value will not be %NULL</doc>
            <type name="gpointer" c:type="gpointer*" gs:is-pointer="1" />
          </parameter>
          <parameter name="status" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="status">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22590">return location for the attribute status, or %NULL</doc>
            <type name="FileAttributeStatus" c:type="GFileAttributeStatus*" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22586">a file attribute key</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="type" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="type">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22587">return location for the attribute type, or %NULL</doc>
            <type name="FileAttributeType" c:type="GFileAttributeType*" />
          </parameter>
          <parameter name="value_pp" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="valuePp">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22588">return location for the
   attribute value, or %NULL; the attribute value will not be %NULL</doc>
            <type name="gpointer" c:type="gpointer*" gs:is-pointer="1" />
          </parameter>
          <parameter name="status" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="status">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22590">return location for the attribute status, or %NULL</doc>
            <type name="FileAttributeStatus" c:type="GFileAttributeStatus*" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_attribute_int32" c:identifier="g_file_info_get_attribute_int32" gs:dll-name="gio-2.0" gs:managed-name="GetAttributeInt32">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22599">Gets a signed 32-bit integer contained within the attribute. If the
attribute does not contain a signed 32-bit integer, or is invalid,
0 will be returned.</doc>
        <source-position filename="gfileinfo.h" line="968" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22608">a signed 32-bit integer from the attribute.</doc>
          <type name="gint32" c:type="gint32" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22601">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22602">a file attribute key.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22602">a file attribute key.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_attribute_int64" c:identifier="g_file_info_get_attribute_int64" gs:dll-name="gio-2.0" gs:managed-name="GetAttributeInt64">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22612">Gets a signed 64-bit integer contained within the attribute. If the
attribute does not contain a signed 64-bit integer, or is invalid,
0 will be returned.</doc>
        <source-position filename="gfileinfo.h" line="974" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22621">a signed 64-bit integer from the attribute.</doc>
          <type name="gint64" c:type="gint64" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22614">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22615">a file attribute key.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22615">a file attribute key.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_attribute_object" c:identifier="g_file_info_get_attribute_object" gs:dll-name="gio-2.0" gs:managed-name="GetAttributeObject">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22625">Gets the value of a #GObject attribute. If the attribute does
not contain a #GObject, %NULL will be returned.</doc>
        <source-position filename="gfileinfo.h" line="977" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22633">a #GObject associated with the given @attribute,
or %NULL otherwise.</doc>
          <type name="GObject.Object" c:type="GObject*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22627">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22628">a file attribute key.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22628">a file attribute key.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_attribute_status" c:identifier="g_file_info_get_attribute_status" gs:dll-name="gio-2.0" gs:managed-name="GetAttributeStatus">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22638">Gets the attribute status for an attribute key.</doc>
        <source-position filename="gfileinfo.h" line="946" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22645">a #GFileAttributeStatus for the given @attribute, or
   %G_FILE_ATTRIBUTE_STATUS_UNSET if the key is invalid.</doc>
          <type name="FileAttributeStatus" c:type="GFileAttributeStatus" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22640">a #GFileInfo</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22641">a file attribute key</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22641">a file attribute key</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_attribute_string" c:identifier="g_file_info_get_attribute_string" gs:dll-name="gio-2.0" gs:managed-name="GetAttributeString">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22650">Gets the value of a string attribute. If the attribute does
not contain a string, %NULL will be returned.</doc>
        <source-position filename="gfileinfo.h" line="956" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22658">the contents of the @attribute value as a UTF-8 string,
or %NULL otherwise.</doc>
          <type name="utf8" c:type="const char*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22652">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22653">a file attribute key.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22653">a file attribute key.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_attribute_stringv" c:identifier="g_file_info_get_attribute_stringv" version="2.22" gs:dll-name="gio-2.0" gs:managed-name="GetAttributeStringv">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22663">Gets the value of a stringv attribute. If the attribute does
not contain a stringv, %NULL will be returned.</doc>
        <source-position filename="gfileinfo.h" line="980" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22671">the contents of the @attribute value as a stringv,
or %NULL otherwise. Do not free. These returned strings are UTF-8.</doc>
          <array c:type="char**" zero-terminated="1" gs:is-pointer="1">
            <type name="utf8" gs:is-pointer="1" />
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22665">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22666">a file attribute key.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22666">a file attribute key.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_attribute_type" c:identifier="g_file_info_get_attribute_type" gs:dll-name="gio-2.0" gs:managed-name="GetAttributeType">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22677">Gets the attribute type for an attribute key.</doc>
        <source-position filename="gfileinfo.h" line="940" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22684">a #GFileAttributeType for the given @attribute, or
%G_FILE_ATTRIBUTE_TYPE_INVALID if the key is not set.</doc>
          <type name="FileAttributeType" c:type="GFileAttributeType" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22679">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22680">a file attribute key.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22680">a file attribute key.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_attribute_uint32" c:identifier="g_file_info_get_attribute_uint32" gs:dll-name="gio-2.0" gs:managed-name="GetAttributeUint32">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22689">Gets an unsigned 32-bit integer contained within the attribute. If the
attribute does not contain an unsigned 32-bit integer, or is invalid,
0 will be returned.</doc>
        <source-position filename="gfileinfo.h" line="965" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22698">an unsigned 32-bit integer from the attribute.</doc>
          <type name="guint32" c:type="guint32" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22691">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22692">a file attribute key.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22692">a file attribute key.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_attribute_uint64" c:identifier="g_file_info_get_attribute_uint64" gs:dll-name="gio-2.0" gs:managed-name="GetAttributeUint64">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22702">Gets a unsigned 64-bit integer contained within the attribute. If the
attribute does not contain an unsigned 64-bit integer, or is invalid,
0 will be returned.</doc>
        <source-position filename="gfileinfo.h" line="971" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22711">a unsigned 64-bit integer from the attribute.</doc>
          <type name="guint64" c:type="guint64" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22704">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22705">a file attribute key.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22705">a file attribute key.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <gs:managed-property name="get_content_type" gs:dll-name="gio-2.0" gs:managed-name="ContentType">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22715">Gets the file's content type.</doc>
        <source-position filename="gfileinfo.h" line="1050" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22721">a string containing the file's content type,
or %NULL if unknown.</doc>
          <type name="utf8" c:type="const char*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22717">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_content_type" c:identifier="g_file_info_get_content_type" gs:dll-name="gio-2.0" gs:managed-name="GetContentType" gs:property-getter-for="ContentType" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22715">Gets the file's content type.</doc>
        <source-position filename="gfileinfo.h" line="1050" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22721">a string containing the file's content type,
or %NULL if unknown.</doc>
          <type name="utf8" c:type="const char*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22717">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_deletion_date" version="2.36" gs:dll-name="gio-2.0" gs:managed-name="DeletionDate">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22726">Returns the #GDateTime representing the deletion date of the file, as
available in G_FILE_ATTRIBUTE_TRASH_DELETION_DATE. If the
G_FILE_ATTRIBUTE_TRASH_DELETION_DATE attribute is unset, %NULL is returned.</doc>
        <source-position filename="gfileinfo.h" line="1030" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22734">a #GDateTime, or %NULL.</doc>
          <type name="GLib.DateTime" c:type="GDateTime*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22728">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_deletion_date" c:identifier="g_file_info_get_deletion_date" version="2.36" gs:dll-name="gio-2.0" gs:managed-name="GetDeletionDate" gs:property-getter-for="DeletionDate" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22726">Returns the #GDateTime representing the deletion date of the file, as
available in G_FILE_ATTRIBUTE_TRASH_DELETION_DATE. If the
G_FILE_ATTRIBUTE_TRASH_DELETION_DATE attribute is unset, %NULL is returned.</doc>
        <source-position filename="gfileinfo.h" line="1030" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22734">a #GDateTime, or %NULL.</doc>
          <type name="GLib.DateTime" c:type="GDateTime*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22728">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_display_name" gs:dll-name="gio-2.0" gs:managed-name="DisplayName">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22739">Gets a display name for a file. This is guaranteed to always be set.</doc>
        <source-position filename="gfileinfo.h" line="1042" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22745">a string containing the display name.</doc>
          <type name="utf8" c:type="const char*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22741">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_display_name" c:identifier="g_file_info_get_display_name" gs:dll-name="gio-2.0" gs:managed-name="GetDisplayName" gs:property-getter-for="DisplayName" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22739">Gets a display name for a file. This is guaranteed to always be set.</doc>
        <source-position filename="gfileinfo.h" line="1042" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22745">a string containing the display name.</doc>
          <type name="utf8" c:type="const char*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22741">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_edit_name" gs:dll-name="gio-2.0" gs:managed-name="EditName">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22749">Gets the edit name for a file.</doc>
        <source-position filename="gfileinfo.h" line="1044" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22755">a string containing the edit name.</doc>
          <type name="utf8" c:type="const char*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22751">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_edit_name" c:identifier="g_file_info_get_edit_name" gs:dll-name="gio-2.0" gs:managed-name="GetEditName" gs:property-getter-for="EditName" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22749">Gets the edit name for a file.</doc>
        <source-position filename="gfileinfo.h" line="1044" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22755">a string containing the edit name.</doc>
          <type name="utf8" c:type="const char*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22751">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_etag" gs:dll-name="gio-2.0" gs:managed-name="Etag">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22759">Gets the [entity tag][gfile-etag] for a given
#GFileInfo. See %G_FILE_ATTRIBUTE_ETAG_VALUE.</doc>
        <source-position filename="gfileinfo.h" line="1063" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22766">a string containing the value of the "etag:value" attribute.</doc>
          <type name="utf8" c:type="const char*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22761">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_etag" c:identifier="g_file_info_get_etag" gs:dll-name="gio-2.0" gs:managed-name="GetEtag" gs:property-getter-for="Etag" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22759">Gets the [entity tag][gfile-etag] for a given
#GFileInfo. See %G_FILE_ATTRIBUTE_ETAG_VALUE.</doc>
        <source-position filename="gfileinfo.h" line="1063" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22766">a string containing the value of the "etag:value" attribute.</doc>
          <type name="utf8" c:type="const char*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22761">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_file_type" gs:dll-name="gio-2.0" gs:managed-name="FileType">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22770">Gets a file's type (whether it is a regular file, symlink, etc).
This is different from the file's content type, see g_file_info_get_content_type().</doc>
        <source-position filename="gfileinfo.h" line="1032" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22777">a #GFileType for the given file.</doc>
          <type name="FileType" c:type="GFileType" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22772">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_file_type" c:identifier="g_file_info_get_file_type" gs:dll-name="gio-2.0" gs:managed-name="GetFileType" gs:property-getter-for="FileType" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22770">Gets a file's type (whether it is a regular file, symlink, etc).
This is different from the file's content type, see g_file_info_get_content_type().</doc>
        <source-position filename="gfileinfo.h" line="1032" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22777">a #GFileType for the given file.</doc>
          <type name="FileType" c:type="GFileType" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22772">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_icon" gs:dll-name="gio-2.0" gs:managed-name="Icon">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22781">Gets the icon for a file.</doc>
        <source-position filename="gfileinfo.h" line="1046" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22787">#GIcon for the given @info.</doc>
          <type name="Icon" c:type="GIcon*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22783">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_icon" c:identifier="g_file_info_get_icon" gs:dll-name="gio-2.0" gs:managed-name="GetIcon" gs:property-getter-for="Icon" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22781">Gets the icon for a file.</doc>
        <source-position filename="gfileinfo.h" line="1046" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22787">#GIcon for the given @info.</doc>
          <type name="Icon" c:type="GIcon*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22783">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_is_backup" gs:dll-name="gio-2.0" gs:managed-name="IsBackup">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22791">Checks if a file is a backup file.</doc>
        <source-position filename="gfileinfo.h" line="1036" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22797">%TRUE if file is a backup file, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22793">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_is_backup" c:identifier="g_file_info_get_is_backup" gs:dll-name="gio-2.0" gs:managed-name="GetIsBackup" gs:property-getter-for="IsBackup" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22791">Checks if a file is a backup file.</doc>
        <source-position filename="gfileinfo.h" line="1036" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22797">%TRUE if file is a backup file, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22793">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_is_hidden" gs:dll-name="gio-2.0" gs:managed-name="IsHidden">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22801">Checks if a file is hidden.</doc>
        <source-position filename="gfileinfo.h" line="1034" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22807">%TRUE if the file is a hidden file, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22803">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_is_hidden" c:identifier="g_file_info_get_is_hidden" gs:dll-name="gio-2.0" gs:managed-name="GetIsHidden" gs:property-getter-for="IsHidden" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22801">Checks if a file is hidden.</doc>
        <source-position filename="gfileinfo.h" line="1034" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22807">%TRUE if the file is a hidden file, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22803">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_is_symlink" gs:dll-name="gio-2.0" gs:managed-name="IsSymlink">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22811">Checks if a file is a symlink.</doc>
        <source-position filename="gfileinfo.h" line="1038" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22817">%TRUE if the given @info is a symlink.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22813">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_is_symlink" c:identifier="g_file_info_get_is_symlink" gs:dll-name="gio-2.0" gs:managed-name="GetIsSymlink" gs:property-getter-for="IsSymlink" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22811">Checks if a file is a symlink.</doc>
        <source-position filename="gfileinfo.h" line="1038" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22817">%TRUE if the given @info is a symlink.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22813">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_modification_date_time" version="2.62" gs:dll-name="gio-2.0" gs:managed-name="ModificationDateTime">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22821">Gets the modification time of the current @info and returns it as a
#GDateTime.

This requires the %G_FILE_ATTRIBUTE_TIME_MODIFIED attribute. If
%G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC is provided, the resulting #GDateTime
will have microsecond precision.</doc>
        <source-position filename="gfileinfo.h" line="1059" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22832">modification time, or %NULL if unknown</doc>
          <type name="GLib.DateTime" c:type="GDateTime*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22823">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_modification_date_time" c:identifier="g_file_info_get_modification_date_time" version="2.62" gs:dll-name="gio-2.0" gs:managed-name="GetModificationDateTime" gs:property-getter-for="ModificationDateTime" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22821">Gets the modification time of the current @info and returns it as a
#GDateTime.

This requires the %G_FILE_ATTRIBUTE_TIME_MODIFIED attribute. If
%G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC is provided, the resulting #GDateTime
will have microsecond precision.</doc>
        <source-position filename="gfileinfo.h" line="1059" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22832">modification time, or %NULL if unknown</doc>
          <type name="GLib.DateTime" c:type="GDateTime*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22823">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="get_modification_time" c:identifier="g_file_info_get_modification_time" deprecated="1" deprecated-version="2.62" gs:dll-name="gio-2.0" gs:managed-name="GetModificationTime">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22837">Gets the modification time of the current @info and sets it
in @result.</doc>
        <doc-deprecated xml:space="preserve">Use g_file_info_get_modification_date_time() instead, as
   #GTimeVal is deprecated due to the year 2038 problem.</doc-deprecated>
        <source-position filename="gfileinfo.h" line="1055" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22839">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" direction="out" caller-allocates="1" transfer-ownership="none" gs:managed-name="result">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22840">a #GTimeVal.</doc>
            <type name="GLib.TimeVal" c:type="GTimeVal*" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="result" direction="out" caller-allocates="1" transfer-ownership="none" gs:managed-name="result">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22840">a #GTimeVal.</doc>
            <type name="GLib.TimeVal" c:type="GTimeVal*" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <gs:managed-property name="get_name" gs:dll-name="gio-2.0" gs:managed-name="Name">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22850">Gets the name for a file. This is guaranteed to always be set.</doc>
        <source-position filename="gfileinfo.h" line="1040" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22856">a string containing the file name.</doc>
          <type name="filename" c:type="const char*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22852">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_name" c:identifier="g_file_info_get_name" gs:dll-name="gio-2.0" gs:managed-name="GetName" gs:property-getter-for="Name" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22850">Gets the name for a file. This is guaranteed to always be set.</doc>
        <source-position filename="gfileinfo.h" line="1040" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22856">a string containing the file name.</doc>
          <type name="filename" c:type="const char*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22852">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_size" gs:dll-name="gio-2.0" gs:managed-name="Size">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22860">Gets the file's size (in bytes). The size is retrieved through the value of
the %G_FILE_ATTRIBUTE_STANDARD_SIZE attribute and is converted
from #guint64 to #goffset before returning the result.</doc>
        <source-position filename="gfileinfo.h" line="1052" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22868">a #goffset containing the file's size (in bytes).</doc>
          <type name="gint64" c:type="goffset" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22862">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_size" c:identifier="g_file_info_get_size" gs:dll-name="gio-2.0" gs:managed-name="GetSize" gs:property-getter-for="Size" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22860">Gets the file's size (in bytes). The size is retrieved through the value of
the %G_FILE_ATTRIBUTE_STANDARD_SIZE attribute and is converted
from #guint64 to #goffset before returning the result.</doc>
        <source-position filename="gfileinfo.h" line="1052" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22868">a #goffset containing the file's size (in bytes).</doc>
          <type name="gint64" c:type="goffset" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22862">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_sort_order" gs:dll-name="gio-2.0" gs:managed-name="SortOrder">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22872">Gets the value of the sort_order attribute from the #GFileInfo.
See %G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER.</doc>
        <source-position filename="gfileinfo.h" line="1065" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22879">a #gint32 containing the value of the "standard::sort_order" attribute.</doc>
          <type name="gint32" c:type="gint32" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22874">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_sort_order" c:identifier="g_file_info_get_sort_order" gs:dll-name="gio-2.0" gs:managed-name="GetSortOrder" gs:property-getter-for="SortOrder" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22872">Gets the value of the sort_order attribute from the #GFileInfo.
See %G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER.</doc>
        <source-position filename="gfileinfo.h" line="1065" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22879">a #gint32 containing the value of the "standard::sort_order" attribute.</doc>
          <type name="gint32" c:type="gint32" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22874">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_symbolic_icon" version="2.34" gs:dll-name="gio-2.0" gs:managed-name="SymbolicIcon">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22883">Gets the symbolic icon for a file.</doc>
        <source-position filename="gfileinfo.h" line="1048" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22889">#GIcon for the given @info.</doc>
          <type name="Icon" c:type="GIcon*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22885">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_symbolic_icon" c:identifier="g_file_info_get_symbolic_icon" version="2.34" gs:dll-name="gio-2.0" gs:managed-name="GetSymbolicIcon" gs:property-getter-for="SymbolicIcon" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22883">Gets the symbolic icon for a file.</doc>
        <source-position filename="gfileinfo.h" line="1048" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22889">#GIcon for the given @info.</doc>
          <type name="Icon" c:type="GIcon*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22885">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_symlink_target" gs:dll-name="gio-2.0" gs:managed-name="SymlinkTarget">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22894">Gets the symlink target for a given #GFileInfo.</doc>
        <source-position filename="gfileinfo.h" line="1061" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22900">a string containing the symlink target.</doc>
          <type name="utf8" c:type="const char*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22896">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_symlink_target" c:identifier="g_file_info_get_symlink_target" gs:dll-name="gio-2.0" gs:managed-name="GetSymlinkTarget" gs:property-getter-for="SymlinkTarget" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22894">Gets the symlink target for a given #GFileInfo.</doc>
        <source-position filename="gfileinfo.h" line="1061" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22900">a string containing the symlink target.</doc>
          <type name="utf8" c:type="const char*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22896">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="has_attribute" c:identifier="g_file_info_has_attribute" gs:dll-name="gio-2.0" gs:managed-name="HasAttribute">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22904">Checks if a file info structure has an attribute named @attribute.</doc>
        <source-position filename="gfileinfo.h" line="925" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22911">%TRUE if @info has an attribute named @attribute,
    %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22906">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22907">a file attribute key.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22907">a file attribute key.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="has_namespace" c:identifier="g_file_info_has_namespace" version="2.22" gs:dll-name="gio-2.0" gs:managed-name="HasNamespace">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22916">Checks if a file info structure has an attribute in the
specified @name_space.</doc>
        <source-position filename="gfileinfo.h" line="928" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22924">%TRUE if @info has an attribute in @name_space,
    %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22918">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="name_space" transfer-ownership="none" gs:managed-name="nameSpace" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22919">a file attribute namespace.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="name_space" transfer-ownership="none" gs:managed-name="nameSpace" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22919">a file attribute namespace.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="list_attributes" c:identifier="g_file_info_list_attributes" gs:dll-name="gio-2.0" gs:managed-name="ListAttributes">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22930">Lists the file info structure's attributes.</doc>
        <source-position filename="gfileinfo.h" line="931" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="22938">a
null-terminated array of strings of all of the possible attribute
types for the given @name_space, or %NULL on error.</doc>
          <array c:type="char**" zero-terminated="1" gs:is-pointer="1">
            <type name="utf8" gs:is-pointer="1" />
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22932">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="name_space" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="nameSpace" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22933">a file attribute key's namespace, or %NULL to list
  all attributes.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="name_space" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="nameSpace" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22933">a file attribute key's namespace, or %NULL to list
  all attributes.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="remove_attribute" c:identifier="g_file_info_remove_attribute" gs:dll-name="gio-2.0" gs:managed-name="RemoveAttribute">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22953">Removes all cases of @attribute from @info if it exists.</doc>
        <source-position filename="gfileinfo.h" line="943" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22955">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22956">a file attribute key.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22956">a file attribute key.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_attribute" c:identifier="g_file_info_set_attribute" gs:dll-name="gio-2.0" gs:managed-name="SetAttribute">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22962">Sets the @attribute to contain the given value, if possible. To unset the
attribute, use %G_FILE_ATTRIBUTE_TYPE_INVALID for @type.</doc>
        <source-position filename="gfileinfo.h" line="984" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22964">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22965">a file attribute key.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22966">a #GFileAttributeType</doc>
            <type name="FileAttributeType" c:type="GFileAttributeType" />
          </parameter>
          <parameter name="value_p" transfer-ownership="none" gs:managed-name="valueP" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22967">pointer to the value</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22965">a file attribute key.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22966">a #GFileAttributeType</doc>
            <type name="FileAttributeType" c:type="GFileAttributeType" />
          </parameter>
          <parameter name="value_p" transfer-ownership="none" gs:managed-name="valueP" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22967">pointer to the value</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_attribute_boolean" c:identifier="g_file_info_set_attribute_boolean" gs:dll-name="gio-2.0" gs:managed-name="SetAttributeBoolean">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22974">Sets the @attribute to contain the given @attr_value,
if possible.</doc>
        <source-position filename="gfileinfo.h" line="997" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22976">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22977">a file attribute key.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="attr_value" transfer-ownership="none" gs:managed-name="attrValue" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22978">a boolean value.</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22977">a file attribute key.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="attr_value" transfer-ownership="none" gs:managed-name="attrValue" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22978">a boolean value.</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_attribute_byte_string" c:identifier="g_file_info_set_attribute_byte_string" gs:dll-name="gio-2.0" gs:managed-name="SetAttributeByteString">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22985">Sets the @attribute to contain the given @attr_value,
if possible.</doc>
        <source-position filename="gfileinfo.h" line="993" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22987">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22988">a file attribute key.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="attr_value" transfer-ownership="none" gs:managed-name="attrValue" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22989">a byte string.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22988">a file attribute key.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="attr_value" transfer-ownership="none" gs:managed-name="attrValue" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22989">a byte string.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_attribute_int32" c:identifier="g_file_info_set_attribute_int32" gs:dll-name="gio-2.0" gs:managed-name="SetAttributeInt32">
        <doc xml:space="preserve" filename="gio-2.0.c" line="22996">Sets the @attribute to contain the given @attr_value,
if possible.</doc>
        <source-position filename="gfileinfo.h" line="1005" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22998">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22999">a file attribute key.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="attr_value" transfer-ownership="none" gs:managed-name="attrValue" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23000">a signed 32-bit integer</doc>
            <type name="gint32" c:type="gint32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="22999">a file attribute key.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="attr_value" transfer-ownership="none" gs:managed-name="attrValue" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23000">a signed 32-bit integer</doc>
            <type name="gint32" c:type="gint32" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_attribute_int64" c:identifier="g_file_info_set_attribute_int64" gs:dll-name="gio-2.0" gs:managed-name="SetAttributeInt64">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23007">Sets the @attribute to contain the given @attr_value,
if possible.</doc>
        <source-position filename="gfileinfo.h" line="1013" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23009">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23010">attribute name to set.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="attr_value" transfer-ownership="none" gs:managed-name="attrValue" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23011">int64 value to set attribute to.</doc>
            <type name="gint64" c:type="gint64" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23010">attribute name to set.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="attr_value" transfer-ownership="none" gs:managed-name="attrValue" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23011">int64 value to set attribute to.</doc>
            <type name="gint64" c:type="gint64" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_attribute_mask" c:identifier="g_file_info_set_attribute_mask" gs:dll-name="gio-2.0" gs:managed-name="SetAttributeMask">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23018">Sets @mask on @info to match specific attribute types.</doc>
        <source-position filename="gfileinfo.h" line="1068" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23020">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="mask" transfer-ownership="none" gs:managed-name="mask" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23021">a #GFileAttributeMatcher.</doc>
            <type name="FileAttributeMatcher" c:type="GFileAttributeMatcher*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="mask" transfer-ownership="none" gs:managed-name="mask" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23021">a #GFileAttributeMatcher.</doc>
            <type name="FileAttributeMatcher" c:type="GFileAttributeMatcher*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_attribute_object" c:identifier="g_file_info_set_attribute_object" gs:dll-name="gio-2.0" gs:managed-name="SetAttributeObject">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23027">Sets the @attribute to contain the given @attr_value,
if possible.</doc>
        <source-position filename="gfileinfo.h" line="1017" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23029">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23030">a file attribute key.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="attr_value" transfer-ownership="none" gs:managed-name="attrValue" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23031">a #GObject.</doc>
            <type name="GObject.Object" c:type="GObject*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23030">a file attribute key.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="attr_value" transfer-ownership="none" gs:managed-name="attrValue" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23031">a #GObject.</doc>
            <type name="GObject.Object" c:type="GObject*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_attribute_status" c:identifier="g_file_info_set_attribute_status" version="2.22" gs:dll-name="gio-2.0" gs:managed-name="SetAttributeStatus">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23038">Sets the attribute status for an attribute key. This is only
needed by external code that implement g_file_set_attributes_from_info()
or similar functions.

The attribute must exist in @info for this to work. Otherwise %FALSE
is returned and @info is unchanged.</doc>
        <source-position filename="gfileinfo.h" line="949" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="23051">%TRUE if the status was changed, %FALSE if the key was not set.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23040">a #GFileInfo</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23041">a file attribute key</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="status" transfer-ownership="none" gs:managed-name="status" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23042">a #GFileAttributeStatus</doc>
            <type name="FileAttributeStatus" c:type="GFileAttributeStatus" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23041">a file attribute key</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="status" transfer-ownership="none" gs:managed-name="status" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23042">a #GFileAttributeStatus</doc>
            <type name="FileAttributeStatus" c:type="GFileAttributeStatus" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_attribute_string" c:identifier="g_file_info_set_attribute_string" gs:dll-name="gio-2.0" gs:managed-name="SetAttributeString">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23056">Sets the @attribute to contain the given @attr_value,
if possible.</doc>
        <source-position filename="gfileinfo.h" line="989" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23058">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23059">a file attribute key.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="attr_value" transfer-ownership="none" gs:managed-name="attrValue" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23060">a UTF-8 string.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23059">a file attribute key.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="attr_value" transfer-ownership="none" gs:managed-name="attrValue" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23060">a UTF-8 string.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_attribute_stringv" c:identifier="g_file_info_set_attribute_stringv" gs:dll-name="gio-2.0" gs:managed-name="SetAttributeStringv">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23067">Sets the @attribute to contain the given @attr_value,
if possible.

Sinze: 2.22</doc>
        <source-position filename="gfileinfo.h" line="1021" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23069">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23070">a file attribute key</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="attr_value" transfer-ownership="none" gs:managed-name="attrValue" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23071">a %NULL
  terminated array of UTF-8 strings.</doc>
            <array c:type="char**" zero-terminated="1" gs:is-pointer="1">
              <type name="utf8" gs:is-pointer="1" />
            </array>
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23070">a file attribute key</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="attr_value" transfer-ownership="none" gs:managed-name="attrValue" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23071">a %NULL
  terminated array of UTF-8 strings.</doc>
            <array c:type="char**" zero-terminated="1" gs:is-pointer="1">
              <type name="utf8" gs:is-pointer="1" />
            </array>
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_attribute_uint32" c:identifier="g_file_info_set_attribute_uint32" gs:dll-name="gio-2.0" gs:managed-name="SetAttributeUint32">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23081">Sets the @attribute to contain the given @attr_value,
if possible.</doc>
        <source-position filename="gfileinfo.h" line="1001" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23083">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23084">a file attribute key.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="attr_value" transfer-ownership="none" gs:managed-name="attrValue" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23085">an unsigned 32-bit integer.</doc>
            <type name="guint32" c:type="guint32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23084">a file attribute key.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="attr_value" transfer-ownership="none" gs:managed-name="attrValue" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23085">an unsigned 32-bit integer.</doc>
            <type name="guint32" c:type="guint32" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_attribute_uint64" c:identifier="g_file_info_set_attribute_uint64" gs:dll-name="gio-2.0" gs:managed-name="SetAttributeUint64">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23092">Sets the @attribute to contain the given @attr_value,
if possible.</doc>
        <source-position filename="gfileinfo.h" line="1009" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23094">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23095">a file attribute key.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="attr_value" transfer-ownership="none" gs:managed-name="attrValue" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23096">an unsigned 64-bit integer.</doc>
            <type name="guint64" c:type="guint64" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="attribute" transfer-ownership="none" gs:managed-name="attribute" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23095">a file attribute key.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="attr_value" transfer-ownership="none" gs:managed-name="attrValue" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23096">an unsigned 64-bit integer.</doc>
            <type name="guint64" c:type="guint64" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_content_type" c:identifier="g_file_info_set_content_type" gs:dll-name="gio-2.0" gs:managed-name="SetContentType" gs:property-setter-for="ContentType" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23103">Sets the content type attribute for a given #GFileInfo.
See %G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE.</doc>
        <source-position filename="gfileinfo.h" line="1099" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23105">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="content_type" transfer-ownership="none" gs:managed-name="contentType" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23106">a content type. See [GContentType][gio-GContentType]</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="content_type" transfer-ownership="none" gs:managed-name="contentType" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23106">a content type. See [GContentType][gio-GContentType]</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_display_name" c:identifier="g_file_info_set_display_name" gs:dll-name="gio-2.0" gs:managed-name="SetDisplayName" gs:property-setter-for="DisplayName" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23113">Sets the display name for the current #GFileInfo.
See %G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME.</doc>
        <source-position filename="gfileinfo.h" line="1087" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23115">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="display_name" transfer-ownership="none" gs:managed-name="displayName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23116">a string containing a display name.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="display_name" transfer-ownership="none" gs:managed-name="displayName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23116">a string containing a display name.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_edit_name" c:identifier="g_file_info_set_edit_name" gs:dll-name="gio-2.0" gs:managed-name="SetEditName" gs:property-setter-for="EditName" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23123">Sets the edit name for the current file.
See %G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME.</doc>
        <source-position filename="gfileinfo.h" line="1090" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23125">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="edit_name" transfer-ownership="none" gs:managed-name="editName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23126">a string containing an edit name.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="edit_name" transfer-ownership="none" gs:managed-name="editName" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23126">a string containing an edit name.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_file_type" c:identifier="g_file_info_set_file_type" gs:dll-name="gio-2.0" gs:managed-name="SetFileType" gs:property-setter-for="FileType" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23133">Sets the file type in a #GFileInfo to @type.
See %G_FILE_ATTRIBUTE_STANDARD_TYPE.</doc>
        <source-position filename="gfileinfo.h" line="1075" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23135">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23136">a #GFileType.</doc>
            <type name="FileType" c:type="GFileType" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23136">a #GFileType.</doc>
            <type name="FileType" c:type="GFileType" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_icon" c:identifier="g_file_info_set_icon" gs:dll-name="gio-2.0" gs:managed-name="SetIcon" gs:property-setter-for="Icon" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23143">Sets the icon for a given #GFileInfo.
See %G_FILE_ATTRIBUTE_STANDARD_ICON.</doc>
        <source-position filename="gfileinfo.h" line="1093" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23145">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="icon" transfer-ownership="none" gs:managed-name="icon" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23146">a #GIcon.</doc>
            <type name="Icon" c:type="GIcon*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="icon" transfer-ownership="none" gs:managed-name="icon" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23146">a #GIcon.</doc>
            <type name="Icon" c:type="GIcon*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_is_hidden" c:identifier="g_file_info_set_is_hidden" gs:dll-name="gio-2.0" gs:managed-name="SetIsHidden" gs:property-setter-for="IsHidden" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23153">Sets the "is_hidden" attribute in a #GFileInfo according to @is_hidden.
See %G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN.</doc>
        <source-position filename="gfileinfo.h" line="1078" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23155">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="is_hidden" transfer-ownership="none" gs:managed-name="isHidden" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23156">a #gboolean.</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="is_hidden" transfer-ownership="none" gs:managed-name="isHidden" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23156">a #gboolean.</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_is_symlink" c:identifier="g_file_info_set_is_symlink" gs:dll-name="gio-2.0" gs:managed-name="SetIsSymlink" gs:property-setter-for="IsSymlink" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23163">Sets the "is_symlink" attribute in a #GFileInfo according to @is_symlink.
See %G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK.</doc>
        <source-position filename="gfileinfo.h" line="1081" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23165">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="is_symlink" transfer-ownership="none" gs:managed-name="isSymlink" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23166">a #gboolean.</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="is_symlink" transfer-ownership="none" gs:managed-name="isSymlink" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23166">a #gboolean.</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_modification_date_time" c:identifier="g_file_info_set_modification_date_time" version="2.62" gs:dll-name="gio-2.0" gs:managed-name="SetModificationDateTime" gs:property-setter-for="ModificationDateTime" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23173">Sets the %G_FILE_ATTRIBUTE_TIME_MODIFIED and
%G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC attributes in the file info to the
given date/time value.</doc>
        <source-position filename="gfileinfo.h" line="1110" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23175">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="mtime" transfer-ownership="none" gs:managed-name="mtime" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23176">a #GDateTime.</doc>
            <type name="GLib.DateTime" c:type="GDateTime*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="mtime" transfer-ownership="none" gs:managed-name="mtime" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23176">a #GDateTime.</doc>
            <type name="GLib.DateTime" c:type="GDateTime*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_modification_time" c:identifier="g_file_info_set_modification_time" deprecated="1" deprecated-version="2.62" gs:dll-name="gio-2.0" gs:managed-name="SetModificationTime">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23186">Sets the %G_FILE_ATTRIBUTE_TIME_MODIFIED and
%G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC attributes in the file info to the
given time value.</doc>
        <doc-deprecated xml:space="preserve">Use g_file_info_set_modification_date_time() instead, as
   #GTimeVal is deprecated due to the year 2038 problem.</doc-deprecated>
        <source-position filename="gfileinfo.h" line="1106" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23188">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="mtime" transfer-ownership="none" gs:managed-name="mtime" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23189">a #GTimeVal.</doc>
            <type name="GLib.TimeVal" c:type="GTimeVal*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="mtime" transfer-ownership="none" gs:managed-name="mtime" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23189">a #GTimeVal.</doc>
            <type name="GLib.TimeVal" c:type="GTimeVal*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_name" c:identifier="g_file_info_set_name" gs:dll-name="gio-2.0" gs:managed-name="SetName" gs:property-setter-for="Name" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23200">Sets the name attribute for the current #GFileInfo.
See %G_FILE_ATTRIBUTE_STANDARD_NAME.</doc>
        <source-position filename="gfileinfo.h" line="1084" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23202">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23203">a string containing a name.</doc>
            <type name="filename" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23203">a string containing a name.</doc>
            <type name="filename" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_size" c:identifier="g_file_info_set_size" gs:dll-name="gio-2.0" gs:managed-name="SetSize" gs:property-setter-for="Size" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23210">Sets the %G_FILE_ATTRIBUTE_STANDARD_SIZE attribute in the file info
to the given size.</doc>
        <source-position filename="gfileinfo.h" line="1102" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23212">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="size" transfer-ownership="none" gs:managed-name="size" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23213">a #goffset containing the file's size.</doc>
            <type name="gint64" c:type="goffset" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="size" transfer-ownership="none" gs:managed-name="size" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23213">a #goffset containing the file's size.</doc>
            <type name="gint64" c:type="goffset" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_sort_order" c:identifier="g_file_info_set_sort_order" gs:dll-name="gio-2.0" gs:managed-name="SetSortOrder" gs:property-setter-for="SortOrder" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23220">Sets the sort order attribute in the file info structure. See
%G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER.</doc>
        <source-position filename="gfileinfo.h" line="1116" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23222">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="sort_order" transfer-ownership="none" gs:managed-name="sortOrder" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23223">a sort order integer.</doc>
            <type name="gint32" c:type="gint32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="sort_order" transfer-ownership="none" gs:managed-name="sortOrder" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23223">a sort order integer.</doc>
            <type name="gint32" c:type="gint32" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_symbolic_icon" c:identifier="g_file_info_set_symbolic_icon" version="2.34" gs:dll-name="gio-2.0" gs:managed-name="SetSymbolicIcon" gs:property-setter-for="SymbolicIcon" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23230">Sets the symbolic icon for a given #GFileInfo.
See %G_FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON.</doc>
        <source-position filename="gfileinfo.h" line="1096" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23232">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="icon" transfer-ownership="none" gs:managed-name="icon" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23233">a #GIcon.</doc>
            <type name="Icon" c:type="GIcon*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="icon" transfer-ownership="none" gs:managed-name="icon" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23233">a #GIcon.</doc>
            <type name="Icon" c:type="GIcon*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_symlink_target" c:identifier="g_file_info_set_symlink_target" gs:dll-name="gio-2.0" gs:managed-name="SetSymlinkTarget" gs:property-setter-for="SymlinkTarget" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23242">Sets the %G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET attribute in the file info
to the given symlink target.</doc>
        <source-position filename="gfileinfo.h" line="1113" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23244">a #GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="symlink_target" transfer-ownership="none" gs:managed-name="symlinkTarget" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23245">a static string containing a path to a symlink target.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="symlink_target" transfer-ownership="none" gs:managed-name="symlinkTarget" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23245">a static string containing a path to a symlink target.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="unset_attribute_mask" c:identifier="g_file_info_unset_attribute_mask" gs:dll-name="gio-2.0" gs:managed-name="UnsetAttributeMask">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23252">Unsets a mask set by g_file_info_set_attribute_mask(), if one
is set.</doc>
        <source-position filename="gfileinfo.h" line="1071" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23254">#GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_file_info_get_type" gs:access-modifiers="private" gs:dll-name="gio-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </class>
    <record name="FileInfoClass" c:type="GFileInfoClass" disguised="1" glib:is-gtype-struct-for="FileInfo" gs:managed-name="FileInfoClass">
      <source-position filename="gfileinfo.h" line="44" />
    </record>
    <class name="FileInputStream" c:symbol-prefix="file_input_stream" c:type="GFileInputStream" parent="InputStream" glib:type-name="GFileInputStream" glib:get-type="g_file_input_stream_get_type" glib:type-struct="FileInputStreamClass" gs:managed-name="FileInputStream">
      <doc xml:space="preserve" filename="gio-2.0.c" line="6489">GFileInputStream provides input streams that take their
content from a file.

GFileInputStream implements #GSeekable, which allows the input
stream to jump to arbitrary positions in the file, provided the
filesystem of the file allows it. To find the position of a file
input stream, use g_seekable_tell(). To find out if a file input
stream supports seeking, use g_seekable_can_seek().
To position a file input stream, use g_seekable_seek().</doc>
      <source-position filename="gfileinputstream.h" line="90" />
      <implements name="Seekable" gs:managed-name="Seekable" />
      <virtual-method name="can_seek" gs:dll-name="gio-2.0" gs:managed-name="DoCanSeek">
        <source-position filename="gfileinputstream.h" line="63" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <type name="FileInputStream" c:type="GFileInputStream*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </virtual-method>
      <virtual-method name="query_info" invoker="query_info" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoQueryInfo">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23261">Queries a file input stream the given @attributes. This function blocks
while querying the stream. For the asynchronous (non-blocking) version
of this function, see g_file_input_stream_query_info_async(). While the
stream is blocked, the stream will set the pending flag internally, and
any other operations on the stream will fail with %G_IO_ERROR_PENDING.</doc>
        <source-position filename="gfileinputstream.h" line="69" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="23275">a #GFileInfo, or %NULL on error.</doc>
          <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23263">a #GFileInputStream.</doc>
            <type name="FileInputStream" c:type="GFileInputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23264">a file attribute query string.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23265">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23264">a file attribute query string.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23265">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="query_info_async" invoker="query_info_async" gs:dll-name="gio-2.0" gs:managed-name="DoQueryInfoAsync">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23279">Queries the stream information asynchronously.
When the operation is finished @callback will be called.
You can then call g_file_input_stream_query_info_finish()
to get the result of the operation.

For the synchronous version of this function,
see g_file_input_stream_query_info().

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be set</doc>
        <source-position filename="gfileinputstream.h" line="73" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23281">a #GFileInputStream.</doc>
            <type name="FileInputStream" c:type="GFileInputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23282">a file attribute query string.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23283">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23284">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23285">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23286">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23282">a file attribute query string.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23283">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23285">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23284">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="query_info_finish" invoker="query_info_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoQueryInfoFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23302">Finishes an asynchronous info query operation.</doc>
        <source-position filename="gfileinputstream.h" line="79" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="23311">#GFileInfo.</doc>
          <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23304">a #GFileInputStream.</doc>
            <type name="FileInputStream" c:type="GFileInputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23305">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23305">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="seek" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoSeek">
        <source-position filename="gfileinputstream.h" line="64" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <type name="FileInputStream" c:type="GFileInputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none" gs:managed-name="offset" direction="in">
            <type name="gint64" c:type="goffset" />
          </parameter>
          <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <type name="GLib.SeekType" c:type="GSeekType" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="offset" transfer-ownership="none" gs:managed-name="offset" direction="in">
            <type name="gint64" c:type="goffset" />
          </parameter>
          <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <type name="GLib.SeekType" c:type="GSeekType" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="tell" gs:dll-name="gio-2.0" gs:managed-name="DoTell">
        <source-position filename="gfileinputstream.h" line="62" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="gint64" c:type="goffset" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <type name="FileInputStream" c:type="GFileInputStream*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </virtual-method>
      <method name="query_info" c:identifier="g_file_input_stream_query_info" throws="1" gs:dll-name="gio-2.0" gs:managed-name="QueryInfo">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23261">Queries a file input stream the given @attributes. This function blocks
while querying the stream. For the asynchronous (non-blocking) version
of this function, see g_file_input_stream_query_info_async(). While the
stream is blocked, the stream will set the pending flag internally, and
any other operations on the stream will fail with %G_IO_ERROR_PENDING.</doc>
        <source-position filename="gfileinputstream.h" line="96" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="23275">a #GFileInfo, or %NULL on error.</doc>
          <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23263">a #GFileInputStream.</doc>
            <type name="FileInputStream" c:type="GFileInputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23264">a file attribute query string.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23265">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23264">a file attribute query string.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23265">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="query_info_async" c:identifier="g_file_input_stream_query_info_async" gs:dll-name="gio-2.0" gs:managed-name="QueryInfoAsync" gs:async="1" gs:async-finish="QueryInfoFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23279">Queries the stream information asynchronously.
When the operation is finished @callback will be called.
You can then call g_file_input_stream_query_info_finish()
to get the result of the operation.

For the synchronous version of this function,
see g_file_input_stream_query_info().

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be set</doc>
        <source-position filename="gfileinputstream.h" line="101" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Threading.Tasks.Task">
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23281">a #GFileInputStream.</doc>
            <type name="FileInputStream" c:type="GFileInputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23282">a file attribute query string.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23283">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23284">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23285">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23286">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23282">a file attribute query string.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23283">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23284">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="query_info_finish" c:identifier="g_file_input_stream_query_info_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="QueryInfoFinish" gs:pinvoke-only="1" gs:finish-for="query_info_async">
        <doc xml:space="preserve" filename="gio-2.0.c" line="23302">Finishes an asynchronous info query operation.</doc>
        <source-position filename="gfileinputstream.h" line="108" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="23311">#GFileInfo.</doc>
          <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23304">a #GFileInputStream.</doc>
            <type name="FileInputStream" c:type="GFileInputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23305">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23305">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <field name="parent_instance" gs:managed-name="ParentInstance">
        <type name="InputStream" c:type="GInputStream" />
      </field>
      <field name="priv" readable="0" private="1" gs:managed-name="Priv">
        <type name="FileInputStreamPrivate" c:type="GFileInputStreamPrivate*" gs:is-pointer="1" />
      </field>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_file_input_stream_get_type" gs:access-modifiers="private" gs:dll-name="gio-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </class>
    <record name="FileInputStreamClass" c:type="GFileInputStreamClass" glib:is-gtype-struct-for="FileInputStream" gs:managed-name="FileInputStreamClass">
      <source-position filename="gfileinputstream.h" line="90" />
      <field name="parent_class" gs:managed-name="ParentClass">
        <type name="InputStreamClass" c:type="GInputStreamClass" />
      </field>
      <field name="tell" gs:managed-name="Tell">
        <callback name="tell" gs:dll-name="gio-2.0" gs:managed-name="Tell">
          <source-position filename="gfileinputstream.h" line="62" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="gint64" c:type="goffset" />
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <type name="FileInputStream" c:type="GFileInputStream*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <type name="FileInputStream" c:type="GFileInputStream*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="can_seek" gs:managed-name="CanSeek">
        <callback name="can_seek" gs:dll-name="gio-2.0" gs:managed-name="CanSeek">
          <source-position filename="gfileinputstream.h" line="63" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <type name="FileInputStream" c:type="GFileInputStream*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <type name="FileInputStream" c:type="GFileInputStream*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="seek" gs:managed-name="Seek">
        <callback name="seek" throws="1" gs:dll-name="gio-2.0" gs:managed-name="Seek">
          <source-position filename="gfileinputstream.h" line="64" />
          <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <type name="FileInputStream" c:type="GFileInputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="offset" transfer-ownership="none" gs:managed-name="offset" direction="in">
              <type name="gint64" c:type="goffset" />
            </parameter>
            <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
              <type name="GLib.SeekType" c:type="GSeekType" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <type name="FileInputStream" c:type="GFileInputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="offset" transfer-ownership="none" gs:managed-name="offset" direction="in">
              <type name="gint64" c:type="goffset" />
            </parameter>
            <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
              <type name="GLib.SeekType" c:type="GSeekType" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="query_info" gs:managed-name="QueryInfo">
        <callback name="query_info" throws="1" gs:dll-name="gio-2.0" gs:managed-name="QueryInfo">
          <source-position filename="gfileinputstream.h" line="69" />
          <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23275">a #GFileInfo, or %NULL on error.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23263">a #GFileInputStream.</doc>
              <type name="FileInputStream" c:type="GFileInputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23264">a file attribute query string.</doc>
              <type name="utf8" c:type="const char*" gs:is-pointer="1" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23265">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23263">a #GFileInputStream.</doc>
              <type name="FileInputStream" c:type="GFileInputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23264">a file attribute query string.</doc>
              <type name="utf8" c:type="const char*" gs:is-pointer="1" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23265">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="query_info_async" gs:managed-name="QueryInfoAsync">
        <callback name="query_info_async" gs:dll-name="gio-2.0" gs:managed-name="QueryInfoAsync">
          <source-position filename="gfileinputstream.h" line="73" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23281">a #GFileInputStream.</doc>
              <type name="FileInputStream" c:type="GFileInputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23282">a file attribute query string.</doc>
              <type name="utf8" c:type="const char*" gs:is-pointer="1" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23283">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23284">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23285">callback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5" gs:managed-name="userData" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23286">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23281">a #GFileInputStream.</doc>
              <type name="FileInputStream" c:type="GFileInputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23282">a file attribute query string.</doc>
              <type name="utf8" c:type="const char*" gs:is-pointer="1" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23283">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23285">callback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23284">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="query_info_finish" gs:managed-name="QueryInfoFinish">
        <callback name="query_info_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="QueryInfoFinish">
          <source-position filename="gfileinputstream.h" line="79" />
          <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="23311">#GFileInfo.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23304">a #GFileInputStream.</doc>
              <type name="FileInputStream" c:type="GFileInputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23305">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23304">a #GFileInputStream.</doc>
              <type name="FileInputStream" c:type="GFileInputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="23305">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="_g_reserved1" introspectable="1" gs:managed-name="GReserved1">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="_g_reserved2" introspectable="1" gs:managed-name="GReserved2">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="_g_reserved3" introspectable="1" gs:managed-name="GReserved3">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="_g_reserved4" introspectable="1" gs:managed-name="GReserved4">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="_g_reserved5" introspectable="1" gs:managed-name="GReserved5">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
    </record>
    <bitfield name="FileMeasureFlags" version="2.38" glib:type-name="GFileMeasureFlags" glib:get-type="g_file_measure_flags_get_type" c:type="GFileMeasureFlags" gs:managed-name="FileMeasureFlags">
      <doc xml:space="preserve" filename="gioenums.h" line="214">Flags that can be used with g_file_measure_disk_usage().</doc>
      <member name="none" value="0" c:identifier="G_FILE_MEASURE_NONE" glib:nick="none" gs:managed-name="None">
        <doc xml:space="preserve" filename="gioenums.h" line="216">No flags set.</doc>
      </member>
      <member name="report_any_error" value="2" c:identifier="G_FILE_MEASURE_REPORT_ANY_ERROR" glib:nick="report-any-error" gs:managed-name="ReportAnyError">
        <doc xml:space="preserve" filename="gioenums.h" line="217">Report any error encountered
  while traversing the directory tree.  Normally errors are only
  reported for the toplevel file.</doc>
      </member>
      <member name="apparent_size" value="4" c:identifier="G_FILE_MEASURE_APPARENT_SIZE" glib:nick="apparent-size" gs:managed-name="ApparentSize">
        <doc xml:space="preserve" filename="gioenums.h" line="220">Tally usage based on apparent file
  sizes.  Normally, the block-size is used, if available, as this is a
  more accurate representation of disk space used.
  Compare with `du --apparent-size`.</doc>
      </member>
      <member name="no_xdev" value="8" c:identifier="G_FILE_MEASURE_NO_XDEV" glib:nick="no-xdev" gs:managed-name="NoCrossMountPoint">
        <doc xml:space="preserve" filename="gioenums.h" line="224">Do not cross mount point boundaries.
  Compare with `du -x`.</doc>
      </member>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_file_measure_flags_get_type" gs:access-modifiers="private" gs:dll-name="gio-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </bitfield>
    <callback name="FileMeasureProgressCallback" c:type="GFileMeasureProgressCallback" version="2.38" gs:dll-name="gio-2.0" gs:managed-name="FileMeasureProgressCallback">
      <doc xml:space="preserve" filename="giotypes.h" line="310">This callback type is used by g_file_measure_disk_usage() to make
periodic progress reports when measuring the amount of disk spaced
used by a directory.

These calls are made on a best-effort basis and not all types of
#GFile will support them.  At the minimum, however, one call will
always be made immediately.

In the case that there is no support, @reporting will be set to
%FALSE (and the other values undefined) and no further calls will be
made.  Otherwise, the @reporting will be %TRUE and the other values
all-zeros during the first (immediate) call.  In this way, you can
know which type of progress UI to show without a delay.

For g_file_measure_disk_usage() the callback is made directly.  For
g_file_measure_disk_usage_async() the callback is made via the
default main context of the calling thread (ie: the same way that the
final async result would be reported).

@current_size is in the same units as requested by the operation (see
%G_FILE_MEASURE_APPARENT_SIZE).

The frequency of the updates is implementation defined, but is
ideally about once every 200ms.

The last progress callback may or may not be equal to the final
result.  Always check the async result to get the final value.</doc>
      <source-position filename="giotypes.h" line="348" />
      <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
        <type name="none" c:type="void" />
      </return-value>
      <parameters>
        <parameter name="reporting" transfer-ownership="none" gs:managed-name="reporting" direction="in">
          <doc xml:space="preserve" filename="giotypes.h" line="312">%TRUE if more reports will come</doc>
          <type name="gboolean" c:type="gboolean" />
        </parameter>
        <parameter name="current_size" transfer-ownership="none" gs:managed-name="currentSize" direction="in">
          <doc xml:space="preserve" filename="giotypes.h" line="313">the current cumulative size measurement</doc>
          <type name="guint64" c:type="guint64" />
        </parameter>
        <parameter name="num_dirs" transfer-ownership="none" gs:managed-name="numDirs" direction="in">
          <doc xml:space="preserve" filename="giotypes.h" line="314">the number of directories visited so far</doc>
          <type name="guint64" c:type="guint64" />
        </parameter>
        <parameter name="num_files" transfer-ownership="none" gs:managed-name="numFiles" direction="in">
          <doc xml:space="preserve" filename="giotypes.h" line="315">the number of non-directory files encountered</doc>
          <type name="guint64" c:type="guint64" />
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4" gs:managed-name="userData" direction="in">
          <doc xml:space="preserve" filename="giotypes.h" line="316">the data passed to the original request for this callback</doc>
          <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
        </parameter>
      </parameters>
      <gs:managed-parameters>
        <parameter name="reporting" transfer-ownership="none" gs:managed-name="reporting" direction="in">
          <doc xml:space="preserve" filename="giotypes.h" line="312">%TRUE if more reports will come</doc>
          <type name="gboolean" c:type="gboolean" />
        </parameter>
        <parameter name="current_size" transfer-ownership="none" gs:managed-name="currentSize" direction="in">
          <doc xml:space="preserve" filename="giotypes.h" line="313">the current cumulative size measurement</doc>
          <type name="guint64" c:type="guint64" />
        </parameter>
        <parameter name="num_dirs" transfer-ownership="none" gs:managed-name="numDirs" direction="in">
          <doc xml:space="preserve" filename="giotypes.h" line="314">the number of directories visited so far</doc>
          <type name="guint64" c:type="guint64" />
        </parameter>
        <parameter name="num_files" transfer-ownership="none" gs:managed-name="numFiles" direction="in">
          <doc xml:space="preserve" filename="giotypes.h" line="315">the number of non-directory files encountered</doc>
          <type name="guint64" c:type="guint64" />
        </parameter>
      </gs:managed-parameters>
    </callback>
    <bitfield name="FileMonitorFlags" glib:type-name="GFileMonitorFlags" glib:get-type="g_file_monitor_flags_get_type" c:type="GFileMonitorFlags" gs:managed-name="FileMonitorFlags">
      <doc xml:space="preserve" filename="gioenums.h" line="325">Flags used to set what a #GFileMonitor will watch for.</doc>
      <member name="none" value="0" c:identifier="G_FILE_MONITOR_NONE" glib:nick="none" gs:managed-name="None">
        <doc xml:space="preserve" filename="gioenums.h" line="327">No flags set.</doc>
      </member>
      <member name="watch_mounts" value="1" c:identifier="G_FILE_MONITOR_WATCH_MOUNTS" glib:nick="watch-mounts" gs:managed-name="WatchMounts">
        <doc xml:space="preserve" filename="gioenums.h" line="328">Watch for mount events.</doc>
      </member>
      <member name="send_moved" value="2" c:identifier="G_FILE_MONITOR_SEND_MOVED" glib:nick="send-moved" deprecated="1" deprecated-version="2.46" gs:managed-name="SendMoved">
        <doc xml:space="preserve" filename="gioenums.h" line="329">Pair DELETED and CREATED events caused
  by file renames (moves) and send a single G_FILE_MONITOR_EVENT_MOVED
  event instead (NB: not supported on all backends; the default
  behaviour -without specifying this flag- is to send single DELETED
  and CREATED events). use
  %G_FILE_MONITOR_WATCH_MOVES instead.</doc>
      </member>
      <member name="watch_hard_links" value="4" c:identifier="G_FILE_MONITOR_WATCH_HARD_LINKS" glib:nick="watch-hard-links" version="2.36" gs:managed-name="WatchHardLinks">
        <doc xml:space="preserve" filename="gioenums.h" line="335">Watch for changes to the file made
  via another hard link.</doc>
      </member>
      <member name="watch_moves" value="8" c:identifier="G_FILE_MONITOR_WATCH_MOVES" glib:nick="watch-moves" version="2.46" gs:managed-name="WatchMoves">
        <doc xml:space="preserve" filename="gioenums.h" line="337">Watch for rename operations on a
  monitored directory.  This causes %G_FILE_MONITOR_EVENT_RENAMED,
  %G_FILE_MONITOR_EVENT_MOVED_IN and %G_FILE_MONITOR_EVENT_MOVED_OUT
  events to be emitted when possible.</doc>
      </member>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_file_monitor_flags_get_type" gs:access-modifiers="private" gs:dll-name="gio-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </bitfield>
    <class name="FileOutputStream" c:symbol-prefix="file_output_stream" c:type="GFileOutputStream" parent="OutputStream" glib:type-name="GFileOutputStream" glib:get-type="g_file_output_stream_get_type" glib:type-struct="FileOutputStreamClass" gs:managed-name="FileOutputStream">
      <doc xml:space="preserve" filename="gio-2.0.c" line="6571">GFileOutputStream provides output streams that write their
content to a file.

GFileOutputStream implements #GSeekable, which allows the output
stream to jump to arbitrary positions in the file and to truncate
the file, provided the filesystem of the file supports these
operations.

To find the position of a file output stream, use g_seekable_tell().
To find out if a file output stream supports seeking, use
g_seekable_can_seek().To position a file output stream, use
g_seekable_seek(). To find out if a file output stream supports
truncating, use g_seekable_can_truncate(). To truncate a file output
stream, use g_seekable_truncate().</doc>
      <source-position filename="gfileoutputstream.h" line="95" />
      <implements name="Seekable" gs:managed-name="Seekable" />
      <virtual-method name="can_seek" gs:dll-name="gio-2.0" gs:managed-name="DoCanSeek">
        <source-position filename="gfileoutputstream.h" line="63" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <type name="FileOutputStream" c:type="GFileOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </virtual-method>
      <virtual-method name="can_truncate" gs:dll-name="gio-2.0" gs:managed-name="DoCanTruncate">
        <source-position filename="gfileoutputstream.h" line="69" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <type name="FileOutputStream" c:type="GFileOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </virtual-method>
      <virtual-method name="get_etag" invoker="get_etag" gs:dll-name="gio-2.0" gs:managed-name="DoGetEtag">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24218">Gets the entity tag for the file when it has been written.
This must be called after the stream has been written
and closed, as the etag can change while writing.</doc>
        <source-position filename="gfileoutputstream.h" line="87" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="24226">the entity tag for the stream.</doc>
          <type name="utf8" c:type="char*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24220">a #GFileOutputStream.</doc>
            <type name="FileOutputStream" c:type="GFileOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </virtual-method>
      <virtual-method name="query_info" invoker="query_info" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoQueryInfo">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24230">Queries a file output stream for the given @attributes.
This function blocks while querying the stream. For the asynchronous
version of this function, see g_file_output_stream_query_info_async().
While the stream is blocked, the stream will set the pending flag
internally, and any other operations on the stream will fail with
%G_IO_ERROR_PENDING.

Can fail if the stream was already closed (with @error being set to
%G_IO_ERROR_CLOSED), the stream has pending operations (with @error being
set to %G_IO_ERROR_PENDING), or if querying info is not supported for
the stream's interface (with @error being set to %G_IO_ERROR_NOT_SUPPORTED). In
all cases of failure, %NULL will be returned.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %NULL will
be returned.</doc>
        <source-position filename="gfileoutputstream.h" line="74" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="24255">a #GFileInfo for the @stream, or %NULL on error.</doc>
          <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24232">a #GFileOutputStream.</doc>
            <type name="FileOutputStream" c:type="GFileOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24233">a file attribute query string.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24234">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24233">a file attribute query string.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24234">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="query_info_async" invoker="query_info_async" gs:dll-name="gio-2.0" gs:managed-name="DoQueryInfoAsync">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24259">Asynchronously queries the @stream for a #GFileInfo. When completed,
@callback will be called with a #GAsyncResult which can be used to
finish the operation with g_file_output_stream_query_info_finish().

For the synchronous version of this function, see
g_file_output_stream_query_info().</doc>
        <source-position filename="gfileoutputstream.h" line="78" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24261">a #GFileOutputStream.</doc>
            <type name="FileOutputStream" c:type="GFileOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24262">a file attribute query string.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24263">the [I/O priority][gio-GIOScheduler] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24264">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24265">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24266">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24262">a file attribute query string.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24263">the [I/O priority][gio-GIOScheduler] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24265">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24264">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="query_info_finish" invoker="query_info_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoQueryInfoFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24277">Finalizes the asynchronous query started
by g_file_output_stream_query_info_async().</doc>
        <source-position filename="gfileoutputstream.h" line="84" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="24286">A #GFileInfo for the finished query.</doc>
          <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24279">a #GFileOutputStream.</doc>
            <type name="FileOutputStream" c:type="GFileOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24280">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24280">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="seek" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoSeek">
        <source-position filename="gfileoutputstream.h" line="64" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <type name="FileOutputStream" c:type="GFileOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none" gs:managed-name="offset" direction="in">
            <type name="gint64" c:type="goffset" />
          </parameter>
          <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <type name="GLib.SeekType" c:type="GSeekType" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="offset" transfer-ownership="none" gs:managed-name="offset" direction="in">
            <type name="gint64" c:type="goffset" />
          </parameter>
          <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <type name="GLib.SeekType" c:type="GSeekType" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="tell" gs:dll-name="gio-2.0" gs:managed-name="DoTell">
        <source-position filename="gfileoutputstream.h" line="62" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="gint64" c:type="goffset" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <type name="FileOutputStream" c:type="GFileOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </virtual-method>
      <virtual-method name="truncate_fn" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoTruncateFn">
        <source-position filename="gfileoutputstream.h" line="70" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <type name="FileOutputStream" c:type="GFileOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="size" transfer-ownership="none" gs:managed-name="size" direction="in">
            <type name="gint64" c:type="goffset" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="size" transfer-ownership="none" gs:managed-name="size" direction="in">
            <type name="gint64" c:type="goffset" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <gs:managed-property name="get_etag" gs:dll-name="gio-2.0" gs:managed-name="Etag">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24218">Gets the entity tag for the file when it has been written.
This must be called after the stream has been written
and closed, as the etag can change while writing.</doc>
        <source-position filename="gfileoutputstream.h" line="118" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="24226">the entity tag for the stream.</doc>
          <type name="utf8" c:type="char*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24220">a #GFileOutputStream.</doc>
            <type name="FileOutputStream" c:type="GFileOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_etag" c:identifier="g_file_output_stream_get_etag" gs:dll-name="gio-2.0" gs:managed-name="GetEtag" gs:property-getter-for="Etag" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24218">Gets the entity tag for the file when it has been written.
This must be called after the stream has been written
and closed, as the etag can change while writing.</doc>
        <source-position filename="gfileoutputstream.h" line="118" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="24226">the entity tag for the stream.</doc>
          <type name="utf8" c:type="char*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24220">a #GFileOutputStream.</doc>
            <type name="FileOutputStream" c:type="GFileOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="query_info" c:identifier="g_file_output_stream_query_info" throws="1" gs:dll-name="gio-2.0" gs:managed-name="QueryInfo">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24230">Queries a file output stream for the given @attributes.
This function blocks while querying the stream. For the asynchronous
version of this function, see g_file_output_stream_query_info_async().
While the stream is blocked, the stream will set the pending flag
internally, and any other operations on the stream will fail with
%G_IO_ERROR_PENDING.

Can fail if the stream was already closed (with @error being set to
%G_IO_ERROR_CLOSED), the stream has pending operations (with @error being
set to %G_IO_ERROR_PENDING), or if querying info is not supported for
the stream's interface (with @error being set to %G_IO_ERROR_NOT_SUPPORTED). In
all cases of failure, %NULL will be returned.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be set, and %NULL will
be returned.</doc>
        <source-position filename="gfileoutputstream.h" line="102" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="24255">a #GFileInfo for the @stream, or %NULL on error.</doc>
          <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24232">a #GFileOutputStream.</doc>
            <type name="FileOutputStream" c:type="GFileOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24233">a file attribute query string.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24234">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24233">a file attribute query string.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24234">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="query_info_async" c:identifier="g_file_output_stream_query_info_async" gs:dll-name="gio-2.0" gs:managed-name="QueryInfoAsync" gs:async="1" gs:async-finish="QueryInfoFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24259">Asynchronously queries the @stream for a #GFileInfo. When completed,
@callback will be called with a #GAsyncResult which can be used to
finish the operation with g_file_output_stream_query_info_finish().

For the synchronous version of this function, see
g_file_output_stream_query_info().</doc>
        <source-position filename="gfileoutputstream.h" line="107" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Threading.Tasks.Task">
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24261">a #GFileOutputStream.</doc>
            <type name="FileOutputStream" c:type="GFileOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24262">a file attribute query string.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24263">the [I/O priority][gio-GIOScheduler] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24264">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24265">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24266">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24262">a file attribute query string.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24263">the [I/O priority][gio-GIOScheduler] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24264">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="query_info_finish" c:identifier="g_file_output_stream_query_info_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="QueryInfoFinish" gs:pinvoke-only="1" gs:finish-for="query_info_async">
        <doc xml:space="preserve" filename="gio-2.0.c" line="24277">Finalizes the asynchronous query started
by g_file_output_stream_query_info_async().</doc>
        <source-position filename="gfileoutputstream.h" line="114" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="24286">A #GFileInfo for the finished query.</doc>
          <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24279">a #GFileOutputStream.</doc>
            <type name="FileOutputStream" c:type="GFileOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24280">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24280">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <field name="parent_instance" gs:managed-name="ParentInstance">
        <type name="OutputStream" c:type="GOutputStream" />
      </field>
      <field name="priv" readable="0" private="1" gs:managed-name="Priv">
        <type name="FileOutputStreamPrivate" c:type="GFileOutputStreamPrivate*" gs:is-pointer="1" />
      </field>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_file_output_stream_get_type" gs:access-modifiers="private" gs:dll-name="gio-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </class>
    <record name="FileOutputStreamClass" c:type="GFileOutputStreamClass" glib:is-gtype-struct-for="FileOutputStream" gs:managed-name="FileOutputStreamClass">
      <source-position filename="gfileoutputstream.h" line="95" />
      <field name="parent_class" gs:managed-name="ParentClass">
        <type name="OutputStreamClass" c:type="GOutputStreamClass" />
      </field>
      <field name="tell" gs:managed-name="Tell">
        <callback name="tell" gs:dll-name="gio-2.0" gs:managed-name="Tell">
          <source-position filename="gfileoutputstream.h" line="62" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="gint64" c:type="goffset" />
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <type name="FileOutputStream" c:type="GFileOutputStream*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <type name="FileOutputStream" c:type="GFileOutputStream*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="can_seek" gs:managed-name="CanSeek">
        <callback name="can_seek" gs:dll-name="gio-2.0" gs:managed-name="CanSeek">
          <source-position filename="gfileoutputstream.h" line="63" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <type name="FileOutputStream" c:type="GFileOutputStream*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <type name="FileOutputStream" c:type="GFileOutputStream*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="seek" gs:managed-name="Seek">
        <callback name="seek" throws="1" gs:dll-name="gio-2.0" gs:managed-name="Seek">
          <source-position filename="gfileoutputstream.h" line="64" />
          <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <type name="FileOutputStream" c:type="GFileOutputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="offset" transfer-ownership="none" gs:managed-name="offset" direction="in">
              <type name="gint64" c:type="goffset" />
            </parameter>
            <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
              <type name="GLib.SeekType" c:type="GSeekType" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <type name="FileOutputStream" c:type="GFileOutputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="offset" transfer-ownership="none" gs:managed-name="offset" direction="in">
              <type name="gint64" c:type="goffset" />
            </parameter>
            <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
              <type name="GLib.SeekType" c:type="GSeekType" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="can_truncate" gs:managed-name="CanTruncate">
        <callback name="can_truncate" gs:dll-name="gio-2.0" gs:managed-name="CanTruncate">
          <source-position filename="gfileoutputstream.h" line="69" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <type name="FileOutputStream" c:type="GFileOutputStream*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <type name="FileOutputStream" c:type="GFileOutputStream*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="truncate_fn" gs:managed-name="TruncateFn">
        <callback name="truncate_fn" throws="1" gs:dll-name="gio-2.0" gs:managed-name="TruncateFn">
          <source-position filename="gfileoutputstream.h" line="70" />
          <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <type name="FileOutputStream" c:type="GFileOutputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="size" transfer-ownership="none" gs:managed-name="size" direction="in">
              <type name="gint64" c:type="goffset" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <type name="FileOutputStream" c:type="GFileOutputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="size" transfer-ownership="none" gs:managed-name="size" direction="in">
              <type name="gint64" c:type="goffset" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="query_info" gs:managed-name="QueryInfo">
        <callback name="query_info" throws="1" gs:dll-name="gio-2.0" gs:managed-name="QueryInfo">
          <source-position filename="gfileoutputstream.h" line="74" />
          <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24255">a #GFileInfo for the @stream, or %NULL on error.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24232">a #GFileOutputStream.</doc>
              <type name="FileOutputStream" c:type="GFileOutputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24233">a file attribute query string.</doc>
              <type name="utf8" c:type="const char*" gs:is-pointer="1" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24234">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24232">a #GFileOutputStream.</doc>
              <type name="FileOutputStream" c:type="GFileOutputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24233">a file attribute query string.</doc>
              <type name="utf8" c:type="const char*" gs:is-pointer="1" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24234">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="query_info_async" gs:managed-name="QueryInfoAsync">
        <callback name="query_info_async" gs:dll-name="gio-2.0" gs:managed-name="QueryInfoAsync">
          <source-position filename="gfileoutputstream.h" line="78" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24261">a #GFileOutputStream.</doc>
              <type name="FileOutputStream" c:type="GFileOutputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24262">a file attribute query string.</doc>
              <type name="utf8" c:type="const char*" gs:is-pointer="1" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24263">the [I/O priority][gio-GIOScheduler] of the request</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24264">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24265">callback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5" gs:managed-name="userData" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24266">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24261">a #GFileOutputStream.</doc>
              <type name="FileOutputStream" c:type="GFileOutputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="attributes" transfer-ownership="none" gs:managed-name="attributes" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24262">a file attribute query string.</doc>
              <type name="utf8" c:type="const char*" gs:is-pointer="1" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24263">the [I/O priority][gio-GIOScheduler] of the request</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24265">callback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24264">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="query_info_finish" gs:managed-name="QueryInfoFinish">
        <callback name="query_info_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="QueryInfoFinish">
          <source-position filename="gfileoutputstream.h" line="84" />
          <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24286">A #GFileInfo for the finished query.</doc>
            <type name="FileInfo" c:type="GFileInfo*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24279">a #GFileOutputStream.</doc>
              <type name="FileOutputStream" c:type="GFileOutputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24280">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24279">a #GFileOutputStream.</doc>
              <type name="FileOutputStream" c:type="GFileOutputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24280">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="get_etag" gs:managed-name="GetEtag">
        <callback name="get_etag" gs:dll-name="gio-2.0" gs:managed-name="GetEtag">
          <source-position filename="gfileoutputstream.h" line="87" />
          <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="24226">the entity tag for the stream.</doc>
            <type name="utf8" c:type="char*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24220">a #GFileOutputStream.</doc>
              <type name="FileOutputStream" c:type="GFileOutputStream*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="24220">a #GFileOutputStream.</doc>
              <type name="FileOutputStream" c:type="GFileOutputStream*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="_g_reserved1" introspectable="1" gs:managed-name="GReserved1">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="_g_reserved2" introspectable="1" gs:managed-name="GReserved2">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="_g_reserved3" introspectable="1" gs:managed-name="GReserved3">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="_g_reserved4" introspectable="1" gs:managed-name="GReserved4">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="_g_reserved5" introspectable="1" gs:managed-name="GReserved5">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
    </record>
    <callback name="FileProgressCallback" c:type="GFileProgressCallback" gs:dll-name="gio-2.0" gs:managed-name="FileProgressCallback">
      <doc xml:space="preserve" filename="giotypes.h" line="279">When doing file operations that may take a while, such as moving
a file or copying a file, a progress callback is used to pass how
far along that operation is to the application.</doc>
      <source-position filename="giotypes.h" line="289" />
      <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
        <type name="none" c:type="void" />
      </return-value>
      <parameters>
        <parameter name="current_num_bytes" transfer-ownership="none" gs:managed-name="currentNumBytes" direction="in">
          <doc xml:space="preserve" filename="giotypes.h" line="281">the current number of bytes in the operation.</doc>
          <type name="gint64" c:type="goffset" />
        </parameter>
        <parameter name="total_num_bytes" transfer-ownership="none" gs:managed-name="totalNumBytes" direction="in">
          <doc xml:space="preserve" filename="giotypes.h" line="282">the total number of bytes in the operation.</doc>
          <type name="gint64" c:type="goffset" />
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="2" gs:managed-name="userData" direction="in">
          <doc xml:space="preserve" filename="giotypes.h" line="283">user data passed to the callback.</doc>
          <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
        </parameter>
      </parameters>
      <gs:managed-parameters>
        <parameter name="current_num_bytes" transfer-ownership="none" gs:managed-name="currentNumBytes" direction="in">
          <doc xml:space="preserve" filename="giotypes.h" line="281">the current number of bytes in the operation.</doc>
          <type name="gint64" c:type="goffset" />
        </parameter>
        <parameter name="total_num_bytes" transfer-ownership="none" gs:managed-name="totalNumBytes" direction="in">
          <doc xml:space="preserve" filename="giotypes.h" line="282">the total number of bytes in the operation.</doc>
          <type name="gint64" c:type="goffset" />
        </parameter>
      </gs:managed-parameters>
    </callback>
    <bitfield name="FileQueryInfoFlags" glib:type-name="GFileQueryInfoFlags" glib:get-type="g_file_query_info_flags_get_type" c:type="GFileQueryInfoFlags" gs:managed-name="FileQueryInfoFlags">
      <doc xml:space="preserve" filename="gioenums.h" line="177">Flags used when querying a #GFileInfo.</doc>
      <member name="none" value="0" c:identifier="G_FILE_QUERY_INFO_NONE" glib:nick="none" gs:managed-name="None">
        <doc xml:space="preserve" filename="gioenums.h" line="179">No flags set.</doc>
      </member>
      <member name="nofollow_symlinks" value="1" c:identifier="G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS" glib:nick="nofollow-symlinks" gs:managed-name="NoFollowSymlinks">
        <doc xml:space="preserve" filename="gioenums.h" line="180">Don't follow symlinks.</doc>
      </member>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_file_query_info_flags_get_type" gs:access-modifiers="private" gs:dll-name="gio-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </bitfield>
    <callback name="FileReadMoreCallback" c:type="GFileReadMoreCallback" gs:dll-name="gio-2.0" gs:managed-name="FileReadMoreCallback">
      <doc xml:space="preserve" filename="giotypes.h" line="293">When loading the partial contents of a file with g_file_load_partial_contents_async(),
it may become necessary to determine if any more data from the file should be loaded.
A #GFileReadMoreCallback function facilitates this by returning %TRUE if more data
should be read, or %FALSE otherwise.</doc>
      <source-position filename="giotypes.h" line="306" />
      <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
        <doc xml:space="preserve" filename="giotypes.h" line="304">%TRUE if more data should be read back. %FALSE otherwise.</doc>
        <type name="gboolean" c:type="gboolean" />
      </return-value>
      <parameters>
        <parameter name="file_contents" transfer-ownership="none" gs:managed-name="fileContents" direction="in">
          <doc xml:space="preserve" filename="giotypes.h" line="295">the data as currently read.</doc>
          <type name="utf8" c:type="const char*" gs:is-pointer="1" />
        </parameter>
        <parameter name="file_size" transfer-ownership="none" gs:managed-name="fileSize" direction="in">
          <doc xml:space="preserve" filename="giotypes.h" line="296">the size of the data currently read.</doc>
          <type name="gint64" c:type="goffset" />
        </parameter>
        <parameter name="callback_data" transfer-ownership="none" nullable="1" allow-none="1" closure="2" gs:managed-name="callbackData" direction="in">
          <doc xml:space="preserve" filename="giotypes.h" line="297">data passed to the callback.</doc>
          <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
        </parameter>
      </parameters>
      <gs:managed-parameters>
        <parameter name="file_contents" transfer-ownership="none" gs:managed-name="fileContents" direction="in">
          <doc xml:space="preserve" filename="giotypes.h" line="295">the data as currently read.</doc>
          <type name="utf8" c:type="const char*" gs:is-pointer="1" />
        </parameter>
        <parameter name="file_size" transfer-ownership="none" gs:managed-name="fileSize" direction="in">
          <doc xml:space="preserve" filename="giotypes.h" line="296">the size of the data currently read.</doc>
          <type name="gint64" c:type="goffset" />
        </parameter>
      </gs:managed-parameters>
    </callback>
    <enumeration name="FileType" glib:type-name="GFileType" glib:get-type="g_file_type_get_type" c:type="GFileType" gs:managed-name="FileType">
      <doc xml:space="preserve" filename="gioenums.h" line="353">Indicates the file's on-disk type.

On Windows systems a file will never have %G_FILE_TYPE_SYMBOLIC_LINK type;
use #GFileInfo and %G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK to determine
whether a file is a symlink or not. This is due to the fact that NTFS does
not have a single filesystem object type for symbolic links - it has
files that symlink to files, and directories that symlink to directories.
#GFileType enumeration cannot precisely represent this important distinction,
which is why all Windows symlinks will continue to be reported as
%G_FILE_TYPE_REGULAR or %G_FILE_TYPE_DIRECTORY.</doc>
      <member name="unknown" value="0" c:identifier="G_FILE_TYPE_UNKNOWN" glib:nick="unknown" gs:managed-name="Unknown">
        <doc xml:space="preserve" filename="gioenums.h" line="355">File's type is unknown.</doc>
      </member>
      <member name="regular" value="1" c:identifier="G_FILE_TYPE_REGULAR" glib:nick="regular" gs:managed-name="Regular">
        <doc xml:space="preserve" filename="gioenums.h" line="356">File handle represents a regular file.</doc>
      </member>
      <member name="directory" value="2" c:identifier="G_FILE_TYPE_DIRECTORY" glib:nick="directory" gs:managed-name="Directory">
        <doc xml:space="preserve" filename="gioenums.h" line="357">File handle represents a directory.</doc>
      </member>
      <member name="symbolic_link" value="3" c:identifier="G_FILE_TYPE_SYMBOLIC_LINK" glib:nick="symbolic-link" gs:managed-name="SymbolicLink">
        <doc xml:space="preserve" filename="gioenums.h" line="358">File handle represents a symbolic link
   (Unix systems).</doc>
      </member>
      <member name="special" value="4" c:identifier="G_FILE_TYPE_SPECIAL" glib:nick="special" gs:managed-name="Special">
        <doc xml:space="preserve" filename="gioenums.h" line="360">File is a "special" file, such as a socket, fifo,
   block device, or character device.</doc>
      </member>
      <member name="shortcut" value="5" c:identifier="G_FILE_TYPE_SHORTCUT" glib:nick="shortcut" gs:managed-name="Shortcut">
        <doc xml:space="preserve" filename="gioenums.h" line="362">File is a shortcut (Windows systems).</doc>
      </member>
      <member name="mountable" value="6" c:identifier="G_FILE_TYPE_MOUNTABLE" glib:nick="mountable" gs:managed-name="Mountable">
        <doc xml:space="preserve" filename="gioenums.h" line="363">File is a mountable location.</doc>
      </member>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_file_type_get_type" gs:access-modifiers="private" gs:dll-name="gio-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </enumeration>
    <enumeration name="FilesystemPreviewType" glib:type-name="GFilesystemPreviewType" glib:get-type="g_filesystem_preview_type_get_type" c:type="GFilesystemPreviewType" gs:managed-name="FilesystemPreviewType">
      <doc xml:space="preserve" filename="gioenums.h" line="387">Indicates a hint from the file system whether files should be
previewed in a file manager. Returned as the value of the key
#G_FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW.</doc>
      <member name="if_always" value="0" c:identifier="G_FILESYSTEM_PREVIEW_TYPE_IF_ALWAYS" glib:nick="if-always" gs:managed-name="IfAlways">
        <doc xml:space="preserve" filename="gioenums.h" line="389">Only preview files if user has explicitly requested it.</doc>
      </member>
      <member name="if_local" value="1" c:identifier="G_FILESYSTEM_PREVIEW_TYPE_IF_LOCAL" glib:nick="if-local" gs:managed-name="IfLocal">
        <doc xml:space="preserve" filename="gioenums.h" line="390">Preview files if user has requested preview of "local" files.</doc>
      </member>
      <member name="never" value="2" c:identifier="G_FILESYSTEM_PREVIEW_TYPE_NEVER" glib:nick="never" gs:managed-name="Never">
        <doc xml:space="preserve" filename="gioenums.h" line="391">Never preview files.</doc>
      </member>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_filesystem_preview_type_get_type" gs:access-modifiers="private" gs:dll-name="gio-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </enumeration>
    <enumeration name="IOErrorEnum" glib:type-name="GIOErrorEnum" glib:get-type="g_io_error_enum_get_type" c:type="GIOErrorEnum" glib:error-domain="g-io-error-quark" gs:managed-name="IOErrorEnum">
      <doc xml:space="preserve" filename="gioenums.h" line="447">Error codes returned by GIO functions.

Note that this domain may be extended in future GLib releases. In
general, new error codes either only apply to new APIs, or else
replace %G_IO_ERROR_FAILED in cases that were not explicitly
distinguished before. You should therefore avoid writing code like
|[&lt;!-- language="C" --&gt;
if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_FAILED))
  {
    // Assume that this is EPRINTERONFIRE
    ...
  }
]|
but should instead treat all unrecognized error codes the same as
#G_IO_ERROR_FAILED.

See also #GPollableReturn for a cheaper way of returning
%G_IO_ERROR_WOULD_BLOCK to callers without allocating a #GError.</doc>
      <member name="failed" value="0" c:identifier="G_IO_ERROR_FAILED" glib:nick="failed" gs:managed-name="Failed">
        <doc xml:space="preserve" filename="gioenums.h" line="449">Generic error condition for when an operation fails
    and no more specific #GIOErrorEnum value is defined.</doc>
      </member>
      <member name="not_found" value="1" c:identifier="G_IO_ERROR_NOT_FOUND" glib:nick="not-found" gs:managed-name="NotFound">
        <doc xml:space="preserve" filename="gioenums.h" line="451">File not found.</doc>
      </member>
      <member name="exists" value="2" c:identifier="G_IO_ERROR_EXISTS" glib:nick="exists" gs:managed-name="Exists">
        <doc xml:space="preserve" filename="gioenums.h" line="452">File already exists.</doc>
      </member>
      <member name="is_directory" value="3" c:identifier="G_IO_ERROR_IS_DIRECTORY" glib:nick="is-directory" gs:managed-name="IsDirectory">
        <doc xml:space="preserve" filename="gioenums.h" line="453">File is a directory.</doc>
      </member>
      <member name="not_directory" value="4" c:identifier="G_IO_ERROR_NOT_DIRECTORY" glib:nick="not-directory" gs:managed-name="NotDirectory">
        <doc xml:space="preserve" filename="gioenums.h" line="454">File is not a directory.</doc>
      </member>
      <member name="not_empty" value="5" c:identifier="G_IO_ERROR_NOT_EMPTY" glib:nick="not-empty" gs:managed-name="NotEmpty">
        <doc xml:space="preserve" filename="gioenums.h" line="455">File is a directory that isn't empty.</doc>
      </member>
      <member name="not_regular_file" value="6" c:identifier="G_IO_ERROR_NOT_REGULAR_FILE" glib:nick="not-regular-file" gs:managed-name="NotRegularFile">
        <doc xml:space="preserve" filename="gioenums.h" line="456">File is not a regular file.</doc>
      </member>
      <member name="not_symbolic_link" value="7" c:identifier="G_IO_ERROR_NOT_SYMBOLIC_LINK" glib:nick="not-symbolic-link" gs:managed-name="NotSymbolicLink">
        <doc xml:space="preserve" filename="gioenums.h" line="457">File is not a symbolic link.</doc>
      </member>
      <member name="not_mountable_file" value="8" c:identifier="G_IO_ERROR_NOT_MOUNTABLE_FILE" glib:nick="not-mountable-file" gs:managed-name="NotMountableFile">
        <doc xml:space="preserve" filename="gioenums.h" line="458">File cannot be mounted.</doc>
      </member>
      <member name="filename_too_long" value="9" c:identifier="G_IO_ERROR_FILENAME_TOO_LONG" glib:nick="filename-too-long" gs:managed-name="FilenameTooLong">
        <doc xml:space="preserve" filename="gioenums.h" line="459">Filename is too many characters.</doc>
      </member>
      <member name="invalid_filename" value="10" c:identifier="G_IO_ERROR_INVALID_FILENAME" glib:nick="invalid-filename" gs:managed-name="InvalidFilename">
        <doc xml:space="preserve" filename="gioenums.h" line="460">Filename is invalid or contains invalid characters.</doc>
      </member>
      <member name="too_many_links" value="11" c:identifier="G_IO_ERROR_TOO_MANY_LINKS" glib:nick="too-many-links" gs:managed-name="TooManyLinks">
        <doc xml:space="preserve" filename="gioenums.h" line="461">File contains too many symbolic links.</doc>
      </member>
      <member name="no_space" value="12" c:identifier="G_IO_ERROR_NO_SPACE" glib:nick="no-space" gs:managed-name="NoSpace">
        <doc xml:space="preserve" filename="gioenums.h" line="462">No space left on drive.</doc>
      </member>
      <member name="invalid_argument" value="13" c:identifier="G_IO_ERROR_INVALID_ARGUMENT" glib:nick="invalid-argument" gs:managed-name="InvalidArgument">
        <doc xml:space="preserve" filename="gioenums.h" line="463">Invalid argument.</doc>
      </member>
      <member name="permission_denied" value="14" c:identifier="G_IO_ERROR_PERMISSION_DENIED" glib:nick="permission-denied" gs:managed-name="PermissionDenied">
        <doc xml:space="preserve" filename="gioenums.h" line="464">Permission denied.</doc>
      </member>
      <member name="not_supported" value="15" c:identifier="G_IO_ERROR_NOT_SUPPORTED" glib:nick="not-supported" gs:managed-name="NotSupported">
        <doc xml:space="preserve" filename="gioenums.h" line="465">Operation (or one of its parameters) not supported</doc>
      </member>
      <member name="not_mounted" value="16" c:identifier="G_IO_ERROR_NOT_MOUNTED" glib:nick="not-mounted" gs:managed-name="NotMounted">
        <doc xml:space="preserve" filename="gioenums.h" line="466">File isn't mounted.</doc>
      </member>
      <member name="already_mounted" value="17" c:identifier="G_IO_ERROR_ALREADY_MOUNTED" glib:nick="already-mounted" gs:managed-name="AlreadyMounted">
        <doc xml:space="preserve" filename="gioenums.h" line="467">File is already mounted.</doc>
      </member>
      <member name="closed" value="18" c:identifier="G_IO_ERROR_CLOSED" glib:nick="closed" gs:managed-name="Closed">
        <doc xml:space="preserve" filename="gioenums.h" line="468">File was closed.</doc>
      </member>
      <member name="cancelled" value="19" c:identifier="G_IO_ERROR_CANCELLED" glib:nick="cancelled" gs:managed-name="Cancelled">
        <doc xml:space="preserve" filename="gioenums.h" line="469">Operation was cancelled. See #GCancellable.</doc>
      </member>
      <member name="pending" value="20" c:identifier="G_IO_ERROR_PENDING" glib:nick="pending" gs:managed-name="Pending">
        <doc xml:space="preserve" filename="gioenums.h" line="470">Operations are still pending.</doc>
      </member>
      <member name="read_only" value="21" c:identifier="G_IO_ERROR_READ_ONLY" glib:nick="read-only" gs:managed-name="ReadOnly">
        <doc xml:space="preserve" filename="gioenums.h" line="471">File is read only.</doc>
      </member>
      <member name="cant_create_backup" value="22" c:identifier="G_IO_ERROR_CANT_CREATE_BACKUP" glib:nick="cant-create-backup" gs:managed-name="CantCreateBackup">
        <doc xml:space="preserve" filename="gioenums.h" line="472">Backup couldn't be created.</doc>
      </member>
      <member name="wrong_etag" value="23" c:identifier="G_IO_ERROR_WRONG_ETAG" glib:nick="wrong-etag" gs:managed-name="WrongEtag">
        <doc xml:space="preserve" filename="gioenums.h" line="473">File's Entity Tag was incorrect.</doc>
      </member>
      <member name="timed_out" value="24" c:identifier="G_IO_ERROR_TIMED_OUT" glib:nick="timed-out" gs:managed-name="TimedOut">
        <doc xml:space="preserve" filename="gioenums.h" line="474">Operation timed out.</doc>
      </member>
      <member name="would_recurse" value="25" c:identifier="G_IO_ERROR_WOULD_RECURSE" glib:nick="would-recurse" gs:managed-name="WouldRecurse">
        <doc xml:space="preserve" filename="gioenums.h" line="475">Operation would be recursive.</doc>
      </member>
      <member name="busy" value="26" c:identifier="G_IO_ERROR_BUSY" glib:nick="busy" gs:managed-name="Busy">
        <doc xml:space="preserve" filename="gioenums.h" line="476">File is busy.</doc>
      </member>
      <member name="would_block" value="27" c:identifier="G_IO_ERROR_WOULD_BLOCK" glib:nick="would-block" gs:managed-name="WouldBlock">
        <doc xml:space="preserve" filename="gioenums.h" line="477">Operation would block.</doc>
      </member>
      <member name="host_not_found" value="28" c:identifier="G_IO_ERROR_HOST_NOT_FOUND" glib:nick="host-not-found" gs:managed-name="HostNotFound">
        <doc xml:space="preserve" filename="gioenums.h" line="478">Host couldn't be found (remote operations).</doc>
      </member>
      <member name="would_merge" value="29" c:identifier="G_IO_ERROR_WOULD_MERGE" glib:nick="would-merge" gs:managed-name="WouldMerge">
        <doc xml:space="preserve" filename="gioenums.h" line="479">Operation would merge files.</doc>
      </member>
      <member name="failed_handled" value="30" c:identifier="G_IO_ERROR_FAILED_HANDLED" glib:nick="failed-handled" gs:managed-name="FailedHandled">
        <doc xml:space="preserve" filename="gioenums.h" line="480">Operation failed and a helper program has
    already interacted with the user. Do not display any error dialog.</doc>
      </member>
      <member name="too_many_open_files" value="31" c:identifier="G_IO_ERROR_TOO_MANY_OPEN_FILES" glib:nick="too-many-open-files" version="2.20" gs:managed-name="TooManyOpenFiles">
        <doc xml:space="preserve" filename="gioenums.h" line="482">The current process has too many files
    open and can't open any more. Duplicate descriptors do count toward
    this limit.</doc>
      </member>
      <member name="not_initialized" value="32" c:identifier="G_IO_ERROR_NOT_INITIALIZED" glib:nick="not-initialized" version="2.22" gs:managed-name="NotInitialized">
        <doc xml:space="preserve" filename="gioenums.h" line="485">The object has not been initialized.</doc>
      </member>
      <member name="address_in_use" value="33" c:identifier="G_IO_ERROR_ADDRESS_IN_USE" glib:nick="address-in-use" version="2.22" gs:managed-name="AddressInUse">
        <doc xml:space="preserve" filename="gioenums.h" line="486">The requested address is already in use.</doc>
      </member>
      <member name="partial_input" value="34" c:identifier="G_IO_ERROR_PARTIAL_INPUT" glib:nick="partial-input" version="2.24" gs:managed-name="PartialInput">
        <doc xml:space="preserve" filename="gioenums.h" line="487">Need more input to finish operation.</doc>
      </member>
      <member name="invalid_data" value="35" c:identifier="G_IO_ERROR_INVALID_DATA" glib:nick="invalid-data" version="2.24" gs:managed-name="InvalidData">
        <doc xml:space="preserve" filename="gioenums.h" line="488">The input data was invalid.</doc>
      </member>
      <member name="dbus_error" value="36" c:identifier="G_IO_ERROR_DBUS_ERROR" glib:nick="dbus-error" version="2.26" gs:managed-name="DbusError">
        <doc xml:space="preserve" filename="gioenums.h" line="489">A remote object generated an error that
    doesn't correspond to a locally registered #GError error
    domain. Use g_dbus_error_get_remote_error() to extract the D-Bus
    error name and g_dbus_error_strip_remote_error() to fix up the
    message so it matches what was received on the wire.</doc>
      </member>
      <member name="host_unreachable" value="37" c:identifier="G_IO_ERROR_HOST_UNREACHABLE" glib:nick="host-unreachable" version="2.26" gs:managed-name="HostUnreachable">
        <doc xml:space="preserve" filename="gioenums.h" line="494">Host unreachable.</doc>
      </member>
      <member name="network_unreachable" value="38" c:identifier="G_IO_ERROR_NETWORK_UNREACHABLE" glib:nick="network-unreachable" version="2.26" gs:managed-name="NetworkUnreachable">
        <doc xml:space="preserve" filename="gioenums.h" line="495">Network unreachable.</doc>
      </member>
      <member name="connection_refused" value="39" c:identifier="G_IO_ERROR_CONNECTION_REFUSED" glib:nick="connection-refused" version="2.26" gs:managed-name="ConnectionRefused">
        <doc xml:space="preserve" filename="gioenums.h" line="496">Connection refused.</doc>
      </member>
      <member name="proxy_failed" value="40" c:identifier="G_IO_ERROR_PROXY_FAILED" glib:nick="proxy-failed" version="2.26" gs:managed-name="ProxyFailed">
        <doc xml:space="preserve" filename="gioenums.h" line="497">Connection to proxy server failed.</doc>
      </member>
      <member name="proxy_auth_failed" value="41" c:identifier="G_IO_ERROR_PROXY_AUTH_FAILED" glib:nick="proxy-auth-failed" version="2.26" gs:managed-name="ProxyAuthFailed">
        <doc xml:space="preserve" filename="gioenums.h" line="498">Proxy authentication failed.</doc>
      </member>
      <member name="proxy_need_auth" value="42" c:identifier="G_IO_ERROR_PROXY_NEED_AUTH" glib:nick="proxy-need-auth" version="2.26" gs:managed-name="ProxyNeedAuth">
        <doc xml:space="preserve" filename="gioenums.h" line="499">Proxy server needs authentication.</doc>
      </member>
      <member name="proxy_not_allowed" value="43" c:identifier="G_IO_ERROR_PROXY_NOT_ALLOWED" glib:nick="proxy-not-allowed" version="2.26" gs:managed-name="ProxyNotAllowed">
        <doc xml:space="preserve" filename="gioenums.h" line="500">Proxy connection is not allowed by ruleset.</doc>
      </member>
      <member name="broken_pipe" value="44" c:identifier="G_IO_ERROR_BROKEN_PIPE" glib:nick="broken-pipe" version="2.36" gs:managed-name="BrokenPipe">
        <doc xml:space="preserve" filename="gioenums.h" line="502">Broken pipe.</doc>
      </member>
      <member name="connection_closed" value="44" c:identifier="G_IO_ERROR_CONNECTION_CLOSED" glib:nick="connection-closed" version="2.44" gs:managed-name="ConnectionClosed">
        <doc xml:space="preserve" filename="gioenums.h" line="503">Connection closed by peer. Note that this
    is the same code as %G_IO_ERROR_BROKEN_PIPE; before 2.44 some
    "connection closed" errors returned %G_IO_ERROR_BROKEN_PIPE, but others
    returned %G_IO_ERROR_FAILED. Now they should all return the same
    value, which has this more logical name.</doc>
      </member>
      <member name="not_connected" value="45" c:identifier="G_IO_ERROR_NOT_CONNECTED" glib:nick="not-connected" version="2.44" gs:managed-name="NotConnected">
        <doc xml:space="preserve" filename="gioenums.h" line="508">Transport endpoint is not connected.</doc>
      </member>
      <member name="message_too_large" value="46" c:identifier="G_IO_ERROR_MESSAGE_TOO_LARGE" glib:nick="message-too-large" version="2.48" gs:managed-name="MessageTooLarge">
        <doc xml:space="preserve" filename="gioenums.h" line="509">Message too large.</doc>
      </member>
      <function name="from_errno" c:identifier="g_io_error_from_errno" gs:dll-name="gio-2.0" gs:managed-name="FromErrno">
        <doc xml:space="preserve" filename="gio-2.0.c" line="26696">Converts errno.h error codes into GIO error codes. The fallback
value %G_IO_ERROR_FAILED is returned for error codes not currently
handled (but note that future GLib releases may return a more
specific value instead).

As %errno is global and may be modified by intermediate function
calls, you should save its value as soon as the call which sets it</doc>
        <source-position filename="gioerror.h" line="44" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="26708">#GIOErrorEnum value for the given errno.h error number.</doc>
          <type name="IOErrorEnum" c:type="GIOErrorEnum" />
        </return-value>
        <parameters>
          <parameter name="errno" transfer-ownership="none" gs:managed-name="errno" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26698">Error number as defined in errno.h.</doc>
            <type name="gint" c:type="gint" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="errno" transfer-ownership="none" gs:managed-name="errno" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26698">Error number as defined in errno.h.</doc>
            <type name="gint" c:type="gint" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <gs:managed-property name="get_quark" gs:dll-name="gio-2.0" gs:managed-name="Quark">
        <doc xml:space="preserve" filename="gio-2.0.c" line="26731">Gets the GIO Error Quark.</doc>
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="26736">a #GQuark.</doc>
          <type name="GLib.Quark" c:type="GQuark" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </gs:managed-property>
      <function name="get_quark" c:identifier="g_io_error_quark" gs:dll-name="gio-2.0" gs:managed-name="GetQuark" gs:property-getter-for="Quark" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="26731">Gets the GIO Error Quark.</doc>
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="26736">a #GQuark.</doc>
          <type name="GLib.Quark" c:type="GQuark" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_io_error_enum_get_type" gs:access-modifiers="private" gs:dll-name="gio-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </enumeration>
    <class name="IOStream" c:symbol-prefix="io_stream" c:type="GIOStream" version="2.22" parent="GObject.Object" abstract="1" glib:type-name="GIOStream" glib:get-type="g_io_stream_get_type" glib:type-struct="IOStreamClass" gs:managed-name="IOStream">
      <doc xml:space="preserve" filename="gio-2.0.c" line="6779">GIOStream represents an object that has both read and write streams.
Generally the two streams act as separate input and output streams,
but they share some common resources and state. For instance, for
seekable streams, both streams may use the same position.

Examples of #GIOStream objects are #GSocketConnection, which represents
a two-way network connection; and #GFileIOStream, which represents a
file handle opened in read-write mode.

To do the actual reading and writing you need to get the substreams
with g_io_stream_get_input_stream() and g_io_stream_get_output_stream().

The #GIOStream object owns the input and the output streams, not the other
way around, so keeping the substreams alive will not keep the #GIOStream
object alive. If the #GIOStream object is freed it will be closed, thus
closing the substreams, so even if the substreams stay alive they will
always return %G_IO_ERROR_CLOSED for all operations.

To close a stream use g_io_stream_close() which will close the common
stream object and also the individual substreams. You can also close
the substreams themselves. In most cases this only marks the
substream as closed, so further I/O on it fails but common state in the
#GIOStream may still be open. However, some streams may support
"half-closed" states where one direction of the stream is actually shut down.

Operations on #GIOStreams cannot be started while another operation on the
#GIOStream or its substreams is in progress. Specifically, an application can
read from the #GInputStream and write to the #GOutputStream simultaneously
(either in separate threads, or as asynchronous operations in the same
thread), but an application cannot start any #GIOStream operation while there
is a #GIOStream, #GInputStream or #GOutputStream operation in progress, and
an application can’t start any #GInputStream or #GOutputStream operation
while there is a #GIOStream operation in progress.

This is a product of individual stream operations being associated with a
given #GMainContext (the thread-default context at the time the operation was
started), rather than entire streams being associated with a single
#GMainContext.

GIO may run operations on #GIOStreams from other (worker) threads, and this
may be exposed to application code in the behaviour of wrapper streams, such
as #GBufferedInputStream or #GTlsConnection. With such wrapper APIs,
application code may only run operations on the base (wrapped) stream when
the wrapper stream is idle. Note that the semantics of such operations may
not be well-defined due to the state the wrapper stream leaves the base
stream in (though they are guaranteed not to crash).</doc>
      <source-position filename="giostream.h" line="84" />
      <method name="splice_finish" c:identifier="g_io_stream_splice_finish" version="2.28" throws="1" gs:dll-name="gio-2.0" gs:managed-name="SpliceFinish" gs:pinvoke-only="1" gs:finish-for="splice_async">
        <doc xml:space="preserve" filename="gio-2.0.c" line="27255">Finishes an asynchronous io stream splice operation.</doc>
        <source-position filename="giostream.h" line="104" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="27263">%TRUE on success, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27257">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27257">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <virtual-method name="close_async" invoker="close_async" version="2.22" gs:dll-name="gio-2.0" gs:managed-name="DoCloseAsync">
        <doc xml:space="preserve" filename="gio-2.0.c" line="27133">Requests an asynchronous close of the stream, releasing resources
related to it. When the operation is finished @callback will be
called. You can then call g_io_stream_close_finish() to get
the result of the operation.

For behaviour details see g_io_stream_close().

The asynchronous methods have a default fallback that uses threads
to implement asynchronicity, so they are optional for inheriting
classes. However, if you override one you must override all.</doc>
        <source-position filename="giostream.h" line="64" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27135">a #GIOStream</doc>
            <type name="IOStream" c:type="GIOStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27136">the io priority of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27137">optional cancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27138">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27139">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27136">the io priority of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27138">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27137">optional cancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="close_finish" invoker="close_finish" version="2.22" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoCloseFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="27156">Closes a stream.</doc>
        <source-position filename="giostream.h" line="69" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="27165">%TRUE if stream was successfully closed, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27158">a #GIOStream</doc>
            <type name="IOStream" c:type="GIOStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27159">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27159">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="close_fn" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoCloseFn">
        <source-position filename="giostream.h" line="61" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <type name="IOStream" c:type="GIOStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="get_input_stream" invoker="get_input_stream" version="2.22" gs:dll-name="gio-2.0" gs:managed-name="DoGetInputStream">
        <doc xml:space="preserve" filename="gio-2.0.c" line="27170">Gets the input stream for this object. This is used
for reading.</doc>
        <source-position filename="giostream.h" line="58" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="27177">a #GInputStream, owned by the #GIOStream.
Do not free.</doc>
          <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27172">a #GIOStream</doc>
            <type name="IOStream" c:type="GIOStream*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </virtual-method>
      <virtual-method name="get_output_stream" invoker="get_output_stream" version="2.22" gs:dll-name="gio-2.0" gs:managed-name="DoGetOutputStream">
        <doc xml:space="preserve" filename="gio-2.0.c" line="27183">Gets the output stream for this object. This is used for
writing.</doc>
        <source-position filename="giostream.h" line="59" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="27190">a #GOutputStream, owned by the #GIOStream.
Do not free.</doc>
          <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27185">a #GIOStream</doc>
            <type name="IOStream" c:type="GIOStream*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </virtual-method>
      <method name="clear_pending" c:identifier="g_io_stream_clear_pending" version="2.22" gs:dll-name="gio-2.0" gs:managed-name="ClearPending">
        <doc xml:space="preserve" filename="gio-2.0.c" line="27078">Clears the pending flag on @stream.</doc>
        <source-position filename="giostream.h" line="131" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27080">a #GIOStream</doc>
            <type name="IOStream" c:type="GIOStream*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="close" c:identifier="g_io_stream_close" version="2.22" throws="1" gs:dll-name="gio-2.0" gs:managed-name="Close">
        <doc xml:space="preserve" filename="gio-2.0.c" line="27088">Closes the stream, releasing resources related to it. This will also
close the individual input and output streams, if they are not already
closed.

Once the stream is closed, all other operations will return
%G_IO_ERROR_CLOSED. Closing a stream multiple times will not
return an error.

Closing a stream will automatically flush any outstanding buffers
in the stream.

Streams will be automatically closed when the last reference
is dropped, but you might want to call this function to make sure
resources are released as early as possible.

Some streams might keep the backing store of the stream (e.g. a file
descriptor) open after the stream is closed. See the documentation for
the individual stream for details.

On failure the first error that happened will be reported, but the
close operation will finish as much as possible. A stream that failed
to close will still return %G_IO_ERROR_CLOSED for all operations.
Still, it is important to check and report the error to the user,
otherwise there might be a loss of data as all data might not be written.

If @cancellable is not NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
Cancelling a close will still leave the stream closed, but some streams
can use a faster close that doesn't block to e.g. check errors.

The default implementation of this method just calls close on the
individual input/output streams.</doc>
        <source-position filename="giostream.h" line="108" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="27128">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27090">a #GIOStream</doc>
            <type name="IOStream" c:type="GIOStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27091">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27091">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="close_async" c:identifier="g_io_stream_close_async" version="2.22" gs:dll-name="gio-2.0" gs:managed-name="CloseAsync" gs:async="1" gs:async-finish="CloseFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="27133">Requests an asynchronous close of the stream, releasing resources
related to it. When the operation is finished @callback will be
called. You can then call g_io_stream_close_finish() to get
the result of the operation.

For behaviour details see g_io_stream_close().

The asynchronous methods have a default fallback that uses threads
to implement asynchronicity, so they are optional for inheriting
classes. However, if you override one you must override all.</doc>
        <source-position filename="giostream.h" line="113" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Threading.Tasks.Task" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27135">a #GIOStream</doc>
            <type name="IOStream" c:type="GIOStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27136">the io priority of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27137">optional cancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27138">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27139">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27136">the io priority of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27137">optional cancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="close_finish" c:identifier="g_io_stream_close_finish" version="2.22" throws="1" gs:dll-name="gio-2.0" gs:managed-name="CloseFinish" gs:pinvoke-only="1" gs:finish-for="close_async">
        <doc xml:space="preserve" filename="gio-2.0.c" line="27156">Closes a stream.</doc>
        <source-position filename="giostream.h" line="119" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="27165">%TRUE if stream was successfully closed, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27158">a #GIOStream</doc>
            <type name="IOStream" c:type="GIOStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27159">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27159">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <gs:managed-property name="get_input_stream" version="2.22" gs:dll-name="gio-2.0" gs:managed-name="InputStream">
        <doc xml:space="preserve" filename="gio-2.0.c" line="27170">Gets the input stream for this object. This is used
for reading.</doc>
        <source-position filename="giostream.h" line="90" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="27177">a #GInputStream, owned by the #GIOStream.
Do not free.</doc>
          <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27172">a #GIOStream</doc>
            <type name="IOStream" c:type="GIOStream*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_input_stream" c:identifier="g_io_stream_get_input_stream" version="2.22" gs:dll-name="gio-2.0" gs:managed-name="GetInputStream" gs:property-getter-for="InputStream" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="27170">Gets the input stream for this object. This is used
for reading.</doc>
        <source-position filename="giostream.h" line="90" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="27177">a #GInputStream, owned by the #GIOStream.
Do not free.</doc>
          <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27172">a #GIOStream</doc>
            <type name="IOStream" c:type="GIOStream*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_output_stream" version="2.22" gs:dll-name="gio-2.0" gs:managed-name="OutputStream">
        <doc xml:space="preserve" filename="gio-2.0.c" line="27183">Gets the output stream for this object. This is used for
writing.</doc>
        <source-position filename="giostream.h" line="92" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="27190">a #GOutputStream, owned by the #GIOStream.
Do not free.</doc>
          <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27185">a #GIOStream</doc>
            <type name="IOStream" c:type="GIOStream*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_output_stream" c:identifier="g_io_stream_get_output_stream" version="2.22" gs:dll-name="gio-2.0" gs:managed-name="GetOutputStream" gs:property-getter-for="OutputStream" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="27183">Gets the output stream for this object. This is used for
writing.</doc>
        <source-position filename="giostream.h" line="92" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="27190">a #GOutputStream, owned by the #GIOStream.
Do not free.</doc>
          <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27185">a #GIOStream</doc>
            <type name="IOStream" c:type="GIOStream*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="has_pending" c:identifier="g_io_stream_has_pending" version="2.22" gs:dll-name="gio-2.0" gs:managed-name="HasPending">
        <doc xml:space="preserve" filename="gio-2.0.c" line="27196">Checks if a stream has pending actions.</doc>
        <source-position filename="giostream.h" line="126" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="27202">%TRUE if @stream has pending actions.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27198">a #GIOStream</doc>
            <type name="IOStream" c:type="GIOStream*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="is_closed" version="2.22" gs:dll-name="gio-2.0" gs:managed-name="IsClosed">
        <doc xml:space="preserve" filename="gio-2.0.c" line="27207">Checks if a stream is closed.</doc>
        <source-position filename="giostream.h" line="124" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="27213">%TRUE if the stream is closed.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27209">a #GIOStream</doc>
            <type name="IOStream" c:type="GIOStream*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="is_closed" c:identifier="g_io_stream_is_closed" version="2.22" gs:dll-name="gio-2.0" gs:managed-name="GetIsClosed" gs:property-getter-for="IsClosed" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="27207">Checks if a stream is closed.</doc>
        <source-position filename="giostream.h" line="124" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="27213">%TRUE if the stream is closed.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27209">a #GIOStream</doc>
            <type name="IOStream" c:type="GIOStream*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="set_pending" c:identifier="g_io_stream_set_pending" version="2.22" throws="1" gs:dll-name="gio-2.0" gs:managed-name="SetPending">
        <doc xml:space="preserve" filename="gio-2.0.c" line="27218">Sets @stream to have actions pending. If the pending flag is
already set or @stream is closed, it will return %FALSE and set
@error.</doc>
        <source-position filename="giostream.h" line="128" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="27228">%TRUE if pending was previously unset and is now set.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27220">a #GIOStream</doc>
            <type name="IOStream" c:type="GIOStream*" gs:is-pointer="1" />
          </instance-parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="splice_async" c:identifier="g_io_stream_splice_async" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="SpliceAsync" gs:async="1" gs:async-finish="SpliceFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="27233">Asynchronously splice the output stream of @stream1 to the input stream of
@stream2, and splice the output stream of @stream2 to the input stream of
@stream1.

When the operation is finished @callback will be called.
You can then call g_io_stream_splice_finish() to get the
result of the operation.</doc>
        <source-position filename="giostream.h" line="95" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Threading.Tasks.Task" />
        </return-value>
        <parameters>
          <instance-parameter name="stream1" transfer-ownership="none" gs:managed-name="stream1" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27235">a #GIOStream.</doc>
            <type name="IOStream" c:type="GIOStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="stream2" transfer-ownership="none" gs:managed-name="stream2" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27236">a #GIOStream.</doc>
            <type name="IOStream" c:type="GIOStream*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27237">a set of #GIOStreamSpliceFlags.</doc>
            <type name="IOStreamSpliceFlags" c:type="GIOStreamSpliceFlags" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27238">the io priority of the request.</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27239">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27240">a #GAsyncReadyCallback.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27241">user data passed to @callback.</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="stream2" transfer-ownership="none" gs:managed-name="stream2" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27236">a #GIOStream.</doc>
            <type name="IOStream" c:type="GIOStream*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27237">a set of #GIOStreamSpliceFlags.</doc>
            <type name="IOStreamSpliceFlags" c:type="GIOStreamSpliceFlags" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27238">the io priority of the request.</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27239">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <property name="closed" transfer-ownership="none" gs:managed-name="IsClosed_">
        <type name="gboolean" c:type="gboolean" />
      </property>
      <property name="input-stream" transfer-ownership="none" gs:managed-name="InputStream_">
        <type name="InputStream" />
      </property>
      <property name="output-stream" transfer-ownership="none" gs:managed-name="OutputStream_">
        <type name="OutputStream" />
      </property>
      <field name="parent_instance" gs:managed-name="ParentInstance">
        <type name="GObject.Object" c:type="GObject" />
      </field>
      <field name="priv" readable="0" private="1" gs:managed-name="Priv">
        <type name="IOStreamPrivate" c:type="GIOStreamPrivate*" gs:is-pointer="1" />
      </field>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_io_stream_get_type" gs:access-modifiers="private" gs:dll-name="gio-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </class>
    <record name="IOStreamClass" c:type="GIOStreamClass" glib:is-gtype-struct-for="IOStream" gs:managed-name="IOStreamClass">
      <source-position filename="giostream.h" line="84" />
      <field name="parent_class" gs:managed-name="ParentClass">
        <type name="GObject.ObjectClass" c:type="GObjectClass" />
      </field>
      <field name="get_input_stream" gs:managed-name="GetInputStream">
        <callback name="get_input_stream" gs:dll-name="gio-2.0" gs:managed-name="GetInputStream">
          <source-position filename="giostream.h" line="58" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27177">a #GInputStream, owned by the #GIOStream.
Do not free.</doc>
            <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="27172">a #GIOStream</doc>
              <type name="IOStream" c:type="GIOStream*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="27172">a #GIOStream</doc>
              <type name="IOStream" c:type="GIOStream*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="get_output_stream" gs:managed-name="GetOutputStream">
        <callback name="get_output_stream" gs:dll-name="gio-2.0" gs:managed-name="GetOutputStream">
          <source-position filename="giostream.h" line="59" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27190">a #GOutputStream, owned by the #GIOStream.
Do not free.</doc>
            <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="27185">a #GIOStream</doc>
              <type name="IOStream" c:type="GIOStream*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="27185">a #GIOStream</doc>
              <type name="IOStream" c:type="GIOStream*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="close_fn" gs:managed-name="CloseFn">
        <callback name="close_fn" throws="1" gs:dll-name="gio-2.0" gs:managed-name="CloseFn">
          <source-position filename="giostream.h" line="61" />
          <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <type name="IOStream" c:type="GIOStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <type name="IOStream" c:type="GIOStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="close_async" gs:managed-name="CloseAsync">
        <callback name="close_async" gs:dll-name="gio-2.0" gs:managed-name="CloseAsync">
          <source-position filename="giostream.h" line="64" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="27135">a #GIOStream</doc>
              <type name="IOStream" c:type="GIOStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="27136">the io priority of the request</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="27137">optional cancellable object</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="27138">callback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4" gs:managed-name="userData" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="27139">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="27135">a #GIOStream</doc>
              <type name="IOStream" c:type="GIOStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="27136">the io priority of the request</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="27138">callback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="27137">optional cancellable object</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="close_finish" gs:managed-name="CloseFinish">
        <callback name="close_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="CloseFinish">
          <source-position filename="giostream.h" line="69" />
          <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27165">%TRUE if stream was successfully closed, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="27158">a #GIOStream</doc>
              <type name="IOStream" c:type="GIOStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="27159">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="27158">a #GIOStream</doc>
              <type name="IOStream" c:type="GIOStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="27159">a #GAsyncResult</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="_g_reserved1" introspectable="1" gs:managed-name="GReserved1">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="_g_reserved2" introspectable="1" gs:managed-name="GReserved2">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="_g_reserved3" introspectable="1" gs:managed-name="GReserved3">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="_g_reserved4" introspectable="1" gs:managed-name="GReserved4">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="_g_reserved5" introspectable="1" gs:managed-name="GReserved5">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="_g_reserved6" introspectable="1" gs:managed-name="GReserved6">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="_g_reserved7" introspectable="1" gs:managed-name="GReserved7">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="_g_reserved8" introspectable="1" gs:managed-name="GReserved8">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="_g_reserved9" introspectable="1" gs:managed-name="GReserved9">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="_g_reserved10" introspectable="1" gs:managed-name="GReserved10">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
    </record>
    <bitfield name="IOStreamSpliceFlags" version="2.28" glib:type-name="GIOStreamSpliceFlags" glib:get-type="g_io_stream_splice_flags_get_type" c:type="GIOStreamSpliceFlags" gs:managed-name="IOStreamSpliceFlags">
      <doc xml:space="preserve" filename="gioenums.h" line="659">GIOStreamSpliceFlags determine how streams should be spliced.</doc>
      <member name="none" value="0" c:identifier="G_IO_STREAM_SPLICE_NONE" glib:nick="none" gs:managed-name="None">
        <doc xml:space="preserve" filename="gioenums.h" line="661">Do not close either stream.</doc>
      </member>
      <member name="close_stream1" value="1" c:identifier="G_IO_STREAM_SPLICE_CLOSE_STREAM1" glib:nick="close-stream1" gs:managed-name="CloseStream1">
        <doc xml:space="preserve" filename="gioenums.h" line="662">Close the first stream after
    the splice.</doc>
      </member>
      <member name="close_stream2" value="2" c:identifier="G_IO_STREAM_SPLICE_CLOSE_STREAM2" glib:nick="close-stream2" gs:managed-name="CloseStream2">
        <doc xml:space="preserve" filename="gioenums.h" line="664">Close the second stream after
    the splice.</doc>
      </member>
      <member name="wait_for_both" value="4" c:identifier="G_IO_STREAM_SPLICE_WAIT_FOR_BOTH" glib:nick="wait-for-both" gs:managed-name="WaitForBoth">
        <doc xml:space="preserve" filename="gioenums.h" line="666">Wait for both splice operations to finish
    before calling the callback.</doc>
      </member>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_io_stream_splice_flags_get_type" gs:access-modifiers="private" gs:dll-name="gio-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </bitfield>
    <interface name="Icon" c:symbol-prefix="icon" c:type="GIcon" glib:type-name="GIcon" glib:get-type="g_icon_get_type" glib:type-struct="IconIface" gs:managed-name="IIcon">
      <doc xml:space="preserve" filename="gio-2.0.c" line="6618">#GIcon is a very minimal interface for icons. It provides functions
for checking the equality of two icons, hashing of icons and
serializing an icon to and from strings.

#GIcon does not provide the actual pixmap for the icon as this is out
of GIO's scope, however implementations of #GIcon may contain the name
of an icon (see #GThemedIcon), or the path to an icon (see #GLoadableIcon).

To obtain a hash of a #GIcon, see g_icon_hash().

To check if two #GIcons are equal, see g_icon_equal().

For serializing a #GIcon, use g_icon_serialize() and
g_icon_deserialize().

If you want to consume #GIcon (for example, in a toolkit) you must
be prepared to handle at least the three following cases:
#GLoadableIcon, #GThemedIcon and #GEmblemedIcon.  It may also make
sense to have fast-paths for other cases (like handling #GdkPixbuf
directly, for example) but all compliant #GIcon implementations
outside of GIO must implement #GLoadableIcon.

If your application or library provides one or more #GIcon
implementations you need to ensure that your new implementation also
implements #GLoadableIcon.  Additionally, you must provide an
implementation of g_icon_serialize() that gives a result that is
understood by g_icon_deserialize(), yielding one of the built-in icon
types.</doc>
      <source-position filename="gicon.h" line="79" />
      <function name="deserialize" c:identifier="g_icon_deserialize" version="2.38" gs:dll-name="gio-2.0" gs:managed-name="Deserialize">
        <doc xml:space="preserve" filename="gio-2.0.c" line="25648">Deserializes a #GIcon previously serialized using g_icon_serialize().</doc>
        <source-position filename="gicon.h" line="98" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="25654">a #GIcon, or %NULL when deserialization fails.</doc>
          <type name="Icon" c:type="GIcon*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25650">a #GVariant created with g_icon_serialize()</doc>
            <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25650">a #GVariant created with g_icon_serialize()</doc>
            <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <method name="hash" c:identifier="g_icon_hash" gs:dll-name="gio-2.0" gs:managed-name="GetHashCode" gs:hash="1" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="25670">Gets a hash for an icon.</doc>
        <source-position filename="gicon.h" line="85" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="25676">a #guint containing a hash for the @icon, suitable for
use in a #GHashTable or similar data structure.</doc>
          <type name="guint" c:type="guint" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="icon" transfer-ownership="none" gs:managed-name="icon" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25672">#gconstpointer to an icon object.</doc>
            <type name="Icon" c:type="gconstpointer" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="icon" transfer-ownership="none" gs:managed-name="icon" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25672">#gconstpointer to an icon object.</doc>
            <type name="Icon" c:type="gconstpointer" gs:is-pointer="1" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <function name="new_for_string" c:identifier="g_icon_new_for_string" version="2.20" throws="1" gs:dll-name="gio-2.0" gs:managed-name="NewForString">
        <doc xml:space="preserve" filename="gio-2.0.c" line="25681">Generate a #GIcon instance from @str. This function can fail if
@str is not valid - see g_icon_to_string() for discussion.

If your application or library provides one or more #GIcon
implementations you need to ensure that each #GType is registered
with the type system prior to calling g_icon_new_for_string().</doc>
        <source-position filename="gicon.h" line="92" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="25693">An object implementing the #GIcon
         interface or %NULL if @error is set.</doc>
          <type name="Icon" c:type="GIcon*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="str" transfer-ownership="none" gs:managed-name="str" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25683">A string obtained via g_icon_to_string().</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="str" transfer-ownership="none" gs:managed-name="str" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25683">A string obtained via g_icon_to_string().</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <virtual-method name="equal" invoker="equal" gs:dll-name="gio-2.0" gs:managed-name="DoEqual">
        <doc xml:space="preserve" filename="gio-2.0.c" line="25659">Checks if two icons are equal.</doc>
        <source-position filename="gicon.h" line="68" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="25666">%TRUE if @icon1 is equal to @icon2. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="icon1" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="icon1" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25661">pointer to the first #GIcon.</doc>
            <type name="Icon" c:type="GIcon*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="icon2" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="icon2" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25662">pointer to the second #GIcon.</doc>
            <type name="Icon" c:type="GIcon*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="icon2" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="icon2" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25662">pointer to the second #GIcon.</doc>
            <type name="Icon" c:type="GIcon*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="hash" invoker="hash" gs:dll-name="gio-2.0" gs:managed-name="DoHash">
        <doc xml:space="preserve" filename="gio-2.0.c" line="25670">Gets a hash for an icon.</doc>
        <source-position filename="gicon.h" line="67" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="25676">a #guint containing a hash for the @icon, suitable for
use in a #GHashTable or similar data structure.</doc>
          <type name="guint" c:type="guint" />
        </return-value>
        <parameters>
          <instance-parameter name="icon" transfer-ownership="none" gs:managed-name="icon" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25672">#gconstpointer to an icon object.</doc>
            <type name="Icon" c:type="GIcon*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </virtual-method>
      <virtual-method name="serialize" invoker="serialize" version="2.38" gs:dll-name="gio-2.0" gs:managed-name="DoSerialize">
        <doc xml:space="preserve" filename="gio-2.0.c" line="25699">Serializes a #GIcon into a #GVariant. An equivalent #GIcon can be retrieved
back by calling g_icon_deserialize() on the returned value.
As serialization will avoid using raw icon data when possible, it only
makes sense to transfer the #GVariant between processes on the same machine,
(as opposed to over the network), and within the same file system namespace.</doc>
        <source-position filename="gicon.h" line="78" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="25709">a #GVariant, or %NULL when serialization fails. The #GVariant will not be floating.</doc>
          <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="icon" transfer-ownership="none" gs:managed-name="icon" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25701">a #GIcon</doc>
            <type name="Icon" c:type="GIcon*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </virtual-method>
      <method name="equal" c:identifier="g_icon_equal" gs:dll-name="gio-2.0" gs:managed-name="Equals" gs:equal="1" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="25659">Checks if two icons are equal.</doc>
        <source-position filename="gicon.h" line="87" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="25666">%TRUE if @icon1 is equal to @icon2. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="icon1" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="icon1" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25661">pointer to the first #GIcon.</doc>
            <type name="Icon" c:type="GIcon*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="icon2" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="icon2" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25662">pointer to the second #GIcon.</doc>
            <type name="Icon" c:type="GIcon*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="icon1" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="icon1" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25661">pointer to the first #GIcon.</doc>
            <type name="Icon" c:type="GIcon*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="icon2" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="icon2" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25662">pointer to the second #GIcon.</doc>
            <type name="Icon" c:type="GIcon*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="serialize" c:identifier="g_icon_serialize" version="2.38" gs:dll-name="gio-2.0" gs:managed-name="Serialize" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="25699">Serializes a #GIcon into a #GVariant. An equivalent #GIcon can be retrieved
back by calling g_icon_deserialize() on the returned value.
As serialization will avoid using raw icon data when possible, it only
makes sense to transfer the #GVariant between processes on the same machine,
(as opposed to over the network), and within the same file system namespace.</doc>
        <source-position filename="gicon.h" line="96" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="25709">a #GVariant, or %NULL when serialization fails. The #GVariant will not be floating.</doc>
          <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="icon" transfer-ownership="none" gs:managed-name="icon" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25701">a #GIcon</doc>
            <type name="Icon" c:type="GIcon*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="icon" transfer-ownership="none" gs:managed-name="icon" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25701">a #GIcon</doc>
            <type name="Icon" c:type="GIcon*" gs:is-pointer="1" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="to_string" c:identifier="g_icon_to_string" version="2.20" gs:dll-name="gio-2.0" gs:managed-name="ToString" gs:to-string="1" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="25714">Generates a textual representation of @icon that can be used for
serialization such as when passing @icon to a different process or
saving it to persistent storage. Use g_icon_new_for_string() to
get @icon back from the returned string.

The encoding of the returned string is proprietary to #GIcon except
in the following two cases

- If @icon is a #GFileIcon, the returned string is a native path
  (such as `/path/to/my icon.png`) without escaping
  if the #GFile for @icon is a native file.  If the file is not
  native, the returned string is the result of g_file_get_uri()
  (such as `sftp://path/to/my%20icon.png`).

- If @icon is a #GThemedIcon with exactly one name and no fallbacks,
  the encoding is simply the name (such as `network-server`).</doc>
        <source-position filename="gicon.h" line="90" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="25735">An allocated NUL-terminated UTF8 string or
%NULL if @icon can't be serialized. Use g_free() to free.</doc>
          <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="icon" transfer-ownership="none" gs:managed-name="icon" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25716">a #GIcon.</doc>
            <type name="Icon" c:type="GIcon*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="icon" transfer-ownership="none" gs:managed-name="icon" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25716">a #GIcon.</doc>
            <type name="Icon" c:type="GIcon*" gs:is-pointer="1" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_icon_get_type" gs:access-modifiers="private" gs:dll-name="gio-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </interface>
    <record name="IconIface" c:type="GIconIface" glib:is-gtype-struct-for="Icon" gs:managed-name="IconIface">
      <doc xml:space="preserve" filename="gicon.h" line="44">GIconIface is used to implement GIcon types for various
different systems. See #GThemedIcon and #GLoadableIcon for
examples of how to implement this interface.</doc>
      <source-position filename="gicon.h" line="79" />
      <field name="g_iface" gs:managed-name="GIface">
        <doc xml:space="preserve" filename="gicon.h" line="46">The parent interface.</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface" />
      </field>
      <field name="hash" gs:managed-name="Hash">
        <callback name="hash" gs:dll-name="gio-2.0" gs:managed-name="Hash">
          <source-position filename="gicon.h" line="67" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25676">a #guint containing a hash for the @icon, suitable for
use in a #GHashTable or similar data structure.</doc>
            <type name="guint" c:type="guint" />
          </return-value>
          <parameters>
            <parameter name="icon" transfer-ownership="none" gs:managed-name="icon" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25672">#gconstpointer to an icon object.</doc>
              <type name="Icon" c:type="GIcon*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="icon" transfer-ownership="none" gs:managed-name="icon" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25672">#gconstpointer to an icon object.</doc>
              <type name="Icon" c:type="GIcon*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="equal" gs:managed-name="Equal">
        <callback name="equal" gs:dll-name="gio-2.0" gs:managed-name="Equal">
          <source-position filename="gicon.h" line="68" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25666">%TRUE if @icon1 is equal to @icon2. %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="icon1" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="icon1" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25661">pointer to the first #GIcon.</doc>
              <type name="Icon" c:type="GIcon*" gs:is-pointer="1" />
            </parameter>
            <parameter name="icon2" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="icon2" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25662">pointer to the second #GIcon.</doc>
              <type name="Icon" c:type="GIcon*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="icon1" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="icon1" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25661">pointer to the first #GIcon.</doc>
              <type name="Icon" c:type="GIcon*" gs:is-pointer="1" />
            </parameter>
            <parameter name="icon2" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="icon2" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25662">pointer to the second #GIcon.</doc>
              <type name="Icon" c:type="GIcon*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="to_tokens" introspectable="1" gs:managed-name="ToTokens">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="from_tokens" introspectable="1" gs:managed-name="FromTokens">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="serialize" gs:managed-name="Serialize">
        <callback name="serialize" gs:dll-name="gio-2.0" gs:managed-name="Serialize">
          <source-position filename="gicon.h" line="78" />
          <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="25709">a #GVariant, or %NULL when serialization fails. The #GVariant will not be floating.</doc>
            <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="icon" transfer-ownership="none" gs:managed-name="icon" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25701">a #GIcon</doc>
              <type name="Icon" c:type="GIcon*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="icon" transfer-ownership="none" gs:managed-name="icon" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="25701">a #GIcon</doc>
              <type name="Icon" c:type="GIcon*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
    </record>
    <interface name="Initable" c:symbol-prefix="initable" c:type="GInitable" version="2.22" glib:type-name="GInitable" glib:get-type="g_initable_get_type" glib:type-struct="InitableIface" gs:managed-name="IInitable">
      <doc xml:space="preserve" filename="gio-2.0.c" line="6694">#GInitable is implemented by objects that can fail during
initialization. If an object implements this interface then
it must be initialized as the first thing after construction,
either via g_initable_init() or g_async_initable_init_async()
(the latter is only available if it also implements #GAsyncInitable).

If the object is not initialized, or initialization returns with an
error, then all operations on the object except g_object_ref() and
g_object_unref() are considered to be invalid, and have undefined
behaviour. They will often fail with g_critical() or g_warning(), but
this must not be relied on.

Users of objects implementing this are not intended to use
the interface method directly, instead it will be used automatically
in various ways. For C applications you generally just call
g_initable_new() directly, or indirectly via a foo_thing_new() wrapper.
This will call g_initable_init() under the cover, returning %NULL and
setting a #GError on failure (at which point the instance is
unreferenced).

For bindings in languages where the native constructor supports
exceptions the binding could check for objects implementing %GInitable
during normal construction and automatically initialize them, throwing
an exception on failure.</doc>
      <source-position filename="ginitable.h" line="66" />
      <function name="newv" c:identifier="g_initable_newv" version="2.22" deprecated="1" deprecated-version="2.54" throws="1" gs:managed-name="New" gs:pinvoke-only="1" gs:dll-name="gio-2.0">
        <doc xml:space="preserve" filename="gio-2.0.c" line="26238">Helper function for constructing #GInitable object. This is
similar to g_object_newv() but also initializes the object
and returns %NULL, setting an error on failure.</doc>
        <doc-deprecated xml:space="preserve">Use g_object_new_with_properties() and
g_initable_init() instead. See #GParameter for more information.</doc-deprecated>
        <source-position filename="ginitable.h" line="87" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="26251">a newly allocated
     #GObject, or %NULL on error</doc>
          <type name="GObject.Object" c:type="gpointer" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="object_type" transfer-ownership="none" gs:managed-name="objectType" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26240">a #GType supporting #GInitable.</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="n_parameters" transfer-ownership="none" gs:managed-name="nParameters" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26241">the number of parameters in @parameters</doc>
            <type name="guint" c:type="guint" />
          </parameter>
          <parameter name="parameters" transfer-ownership="none" gs:managed-name="parameters" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26242">the parameters to use to construct the object</doc>
            <array length="1" zero-terminated="0" c:type="GParameter*" gs:is-pointer="1">
              <type name="GObject.Parameter" c:type="GParameter" />
            </array>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26243">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="object_type" transfer-ownership="none" gs:managed-name="objectType" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26240">a #GType supporting #GInitable.</doc>
            <type name="GType" c:type="GType" />
          </parameter>
          <parameter name="parameters" transfer-ownership="none" gs:managed-name="parameters" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26242">the parameters to use to construct the object</doc>
            <array length="1" zero-terminated="0" c:type="GParameter*" gs:is-pointer="1">
              <type name="GObject.Parameter" c:type="GParameter" />
            </array>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26243">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <virtual-method name="init" invoker="init" version="2.22" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoInit">
        <doc xml:space="preserve" filename="gio-2.0.c" line="26145">Initializes the object implementing the interface.

This method is intended for language bindings. If writing in C,
g_initable_new() should typically be used instead.

The object must be initialized before any real use after initial
construction, either with this function or g_async_initable_init_async().

Implementations may also support cancellation. If @cancellable is not %NULL,
then initialization can be cancelled by triggering the cancellable object
from another thread. If the operation was cancelled, the error
%G_IO_ERROR_CANCELLED will be returned. If @cancellable is not %NULL and
the object doesn't support cancellable initialization the error
%G_IO_ERROR_NOT_SUPPORTED will be returned.

If the object is not initialized, or initialization returns with an
error, then all operations on the object except g_object_ref() and
g_object_unref() are considered to be invalid, and have undefined
behaviour. See the [introduction][ginitable] for more details.

Callers should not assume that a class which implements #GInitable can be
initialized multiple times, unless the class explicitly documents itself as
supporting this. Generally, a class’ implementation of init() can assume
(and assert) that it will only be called once. Previously, this documentation
recommended all #GInitable implementations should be idempotent; that
recommendation was relaxed in GLib 2.54.

If a class explicitly supports being initialized multiple times, it is
recommended that the method is idempotent: multiple calls with the same
arguments should return the same results. Only the first call initializes
the object; further calls return the result of the first call.

One reason why a class might need to support idempotent initialization is if
it is designed to be used via the singleton pattern, with a
#GObjectClass.constructor that sometimes returns an existing instance.
In this pattern, a caller would expect to be able to call g_initable_init()
on the result of g_object_new(), regardless of whether it is in fact a new
instance.</doc>
        <source-position filename="ginitable.h" line="63" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="26191">%TRUE if successful. If an error has occurred, this function will
    return %FALSE and set @error appropriately if present.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="initable" transfer-ownership="none" gs:managed-name="initable" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26147">a #GInitable.</doc>
            <type name="Initable" c:type="GInitable*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26148">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26148">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <method name="init" c:identifier="g_initable_init" version="2.22" throws="1" gs:dll-name="gio-2.0" gs:managed-name="Init" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="26145">Initializes the object implementing the interface.

This method is intended for language bindings. If writing in C,
g_initable_new() should typically be used instead.

The object must be initialized before any real use after initial
construction, either with this function or g_async_initable_init_async().

Implementations may also support cancellation. If @cancellable is not %NULL,
then initialization can be cancelled by triggering the cancellable object
from another thread. If the operation was cancelled, the error
%G_IO_ERROR_CANCELLED will be returned. If @cancellable is not %NULL and
the object doesn't support cancellable initialization the error
%G_IO_ERROR_NOT_SUPPORTED will be returned.

If the object is not initialized, or initialization returns with an
error, then all operations on the object except g_object_ref() and
g_object_unref() are considered to be invalid, and have undefined
behaviour. See the [introduction][ginitable] for more details.

Callers should not assume that a class which implements #GInitable can be
initialized multiple times, unless the class explicitly documents itself as
supporting this. Generally, a class’ implementation of init() can assume
(and assert) that it will only be called once. Previously, this documentation
recommended all #GInitable implementations should be idempotent; that
recommendation was relaxed in GLib 2.54.

If a class explicitly supports being initialized multiple times, it is
recommended that the method is idempotent: multiple calls with the same
arguments should return the same results. Only the first call initializes
the object; further calls return the result of the first call.

One reason why a class might need to support idempotent initialization is if
it is designed to be used via the singleton pattern, with a
#GObjectClass.constructor that sometimes returns an existing instance.
In this pattern, a caller would expect to be able to call g_initable_init()
on the result of g_object_new(), regardless of whether it is in fact a new
instance.</doc>
        <source-position filename="ginitable.h" line="73" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="26191">%TRUE if successful. If an error has occurred, this function will
    return %FALSE and set @error appropriately if present.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="initable" transfer-ownership="none" gs:managed-name="initable" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26147">a #GInitable.</doc>
            <type name="Initable" c:type="GInitable*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26148">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="initable" transfer-ownership="none" gs:managed-name="initable" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26147">a #GInitable.</doc>
            <type name="Initable" c:type="GInitable*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26148">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_initable_get_type" gs:access-modifiers="private" gs:dll-name="gio-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </interface>
    <record name="InitableIface" c:type="GInitableIface" glib:is-gtype-struct-for="Initable" version="2.22" gs:managed-name="InitableIface">
      <doc xml:space="preserve" filename="ginitable.h" line="47">Provides an interface for initializing object such that initialization
may fail.</doc>
      <source-position filename="ginitable.h" line="66" />
      <field name="g_iface" gs:managed-name="GIface">
        <doc xml:space="preserve" filename="ginitable.h" line="49">The parent interface.</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface" />
      </field>
      <field name="init" gs:managed-name="Init">
        <callback name="init" throws="1" gs:dll-name="gio-2.0" gs:managed-name="Init">
          <source-position filename="ginitable.h" line="63" />
          <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26191">%TRUE if successful. If an error has occurred, this function will
    return %FALSE and set @error appropriately if present.</doc>
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="initable" transfer-ownership="none" gs:managed-name="initable" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="26147">a #GInitable.</doc>
              <type name="Initable" c:type="GInitable*" gs:is-pointer="1" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="26148">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="initable" transfer-ownership="none" gs:managed-name="initable" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="26147">a #GInitable.</doc>
              <type name="Initable" c:type="GInitable*" gs:is-pointer="1" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="26148">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
    </record>
    <class name="InputStream" c:symbol-prefix="input_stream" c:type="GInputStream" parent="GObject.Object" abstract="1" glib:type-name="GInputStream" glib:get-type="g_input_stream_get_type" glib:type-struct="InputStreamClass" gs:managed-name="InputStream">
      <doc xml:space="preserve" filename="gio-2.0.c" line="6727">#GInputStream has functions to read from a stream (g_input_stream_read()),
to close a stream (g_input_stream_close()) and to skip some content
(g_input_stream_skip()).

To copy the content of an input stream to an output stream without
manually handling the reads and writes, use g_output_stream_splice().

See the documentation for #GIOStream for details of thread safety of
streaming APIs.

All of these functions have async variants too.</doc>
      <source-position filename="ginputstream.h" line="110" />
      <virtual-method name="close_async" invoker="close_async" gs:dll-name="gio-2.0" gs:managed-name="DoCloseAsync">
        <doc xml:space="preserve" filename="gio-2.0.c" line="26301">Requests an asynchronous closes of the stream, releasing resources related to it.
When the operation is finished @callback will be called.
You can then call g_input_stream_close_finish() to get the result of the
operation.

For behaviour details see g_input_stream_close().

The asynchronous methods have a default fallback that uses threads to implement
asynchronicity, so they are optional for inheriting classes. However, if you
override one you must override all.</doc>
        <source-position filename="ginputstream.h" line="94" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26303">A #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26304">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26305">optional cancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26306">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26307">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26304">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26306">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26305">optional cancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="close_finish" invoker="close_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoCloseFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="26322">Finishes closing a stream asynchronously, started from g_input_stream_close_async().</doc>
        <source-position filename="ginputstream.h" line="99" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="26331">%TRUE if the stream was closed successfully.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26324">a #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26325">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26325">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="close_fn" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoCloseFn">
        <source-position filename="ginputstream.h" line="70" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="read_async" invoker="read_async" gs:dll-name="gio-2.0" gs:managed-name="DoReadAsync">
        <doc xml:space="preserve" filename="gio-2.0.c" line="26472">Request an asynchronous read of @count bytes from the stream into the buffer
starting at @buffer. When the operation is finished @callback will be called.
You can then call g_input_stream_read_finish() to get the result of the
operation.

During an async request no other sync and async calls are allowed on @stream, and will
result in %G_IO_ERROR_PENDING errors.

A value of @count larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.

On success, the number of bytes read into the buffer will be passed to the
callback. It is not an error if this is not the same as the requested size, as it
can happen e.g. near the end of a file, but generally we try to read
as many bytes as requested. Zero is returned on end of file
(or if @count is zero),  but never otherwise.

Any outstanding i/o request with higher priority (lower numerical value) will
be executed before an outstanding request with lower priority. Default
priority is %G_PRIORITY_DEFAULT.

The asynchronous methods have a default fallback that uses threads to implement
asynchronicity, so they are optional for inheriting classes. However, if you
override one you must override all.</doc>
        <source-position filename="ginputstream.h" line="75" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26474">A #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="buffer" direction="out" caller-allocates="1" transfer-ownership="none" nullable="1" gs:managed-name="buffer">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26475">
    a buffer to read data into (which should be at least count bytes long).</doc>
            <array length="1" zero-terminated="0" c:type="void*" gs:is-pointer="1">
              <type name="guint8" />
            </array>
          </parameter>
          <parameter name="count" direction="in" caller-allocates="0" transfer-ownership="full" gs:managed-name="count">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26477">the number of bytes that will be read from the stream</doc>
            <type name="gsize" c:type="gsize" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26478">the [I/O priority][io-priority]
of the request.</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26480">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26481">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26482">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="buffer" direction="out" caller-allocates="1" transfer-ownership="none" nullable="1" gs:managed-name="buffer">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26475">
    a buffer to read data into (which should be at least count bytes long).</doc>
            <array length="1" zero-terminated="0" c:type="void*" gs:is-pointer="1">
              <type name="guint8" />
            </array>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26478">the [I/O priority][io-priority]
of the request.</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26481">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26480">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="read_finish" invoker="read_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoReadFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="26595">Finishes an asynchronous stream read operation.</doc>
        <source-position filename="ginputstream.h" line="82" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="26604">number of bytes read in, or -1 on error, or 0 on end of file.</doc>
          <type name="gssize" c:type="gssize" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26597">a #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26598">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26598">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="read_fn" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoReadFn">
        <source-position filename="ginputstream.h" line="61" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="gssize" c:type="gssize" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="buffer" direction="in">
            <type name="gpointer" c:type="void*" gs:is-pointer="1" />
          </parameter>
          <parameter name="count" transfer-ownership="none" direction="in" gs:managed-name="count">
            <type name="gsize" c:type="gsize" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="buffer" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="buffer" direction="in">
            <type name="gpointer" c:type="void*" gs:is-pointer="1" />
          </parameter>
          <parameter name="count" transfer-ownership="none" direction="in" gs:managed-name="count">
            <type name="gsize" c:type="gsize" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="skip" invoker="skip" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoSkip">
        <doc xml:space="preserve" filename="gio-2.0.c" line="26622">Tries to skip @count bytes from the stream. Will block during the operation.

This is identical to g_input_stream_read(), from a behaviour standpoint,
but the bytes that are skipped are not returned to the user. Some
streams have an implementation that is more efficient than reading the data.

This function is optional for inherited classes, as the default implementation
emulates it using read.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
operation was partially finished when the operation was cancelled the
partial result will be returned, without an error.</doc>
        <source-position filename="ginputstream.h" line="66" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="26644">Number of bytes skipped, or -1 on error</doc>
          <type name="gssize" c:type="gssize" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26624">a #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="count" transfer-ownership="none" gs:managed-name="count" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26625">the number of bytes that will be skipped from the stream</doc>
            <type name="gsize" c:type="gsize" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26626">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="count" transfer-ownership="none" gs:managed-name="count" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26625">the number of bytes that will be skipped from the stream</doc>
            <type name="gsize" c:type="gsize" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26626">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="skip_async" invoker="skip_async" gs:dll-name="gio-2.0" gs:managed-name="DoSkipAsync">
        <doc xml:space="preserve" filename="gio-2.0.c" line="26648">Request an asynchronous skip of @count bytes from the stream.
When the operation is finished @callback will be called.
You can then call g_input_stream_skip_finish() to get the result
of the operation.

During an async request no other sync and async calls are allowed,
and will result in %G_IO_ERROR_PENDING errors.

A value of @count larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.

On success, the number of bytes skipped will be passed to the callback.
It is not an error if this is not the same as the requested size, as it
can happen e.g. near the end of a file, but generally we try to skip
as many bytes as requested. Zero is returned on end of file
(or if @count is zero), but never otherwise.

Any outstanding i/o request with higher priority (lower numerical value)
will be executed before an outstanding request with lower priority.
Default priority is %G_PRIORITY_DEFAULT.

The asynchronous methods have a default fallback that uses threads to
implement asynchronicity, so they are optional for inheriting classes.
However, if you override one, you must override all.</doc>
        <source-position filename="ginputstream.h" line="85" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26650">A #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="count" transfer-ownership="none" gs:managed-name="count" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26651">the number of bytes that will be skipped from the stream</doc>
            <type name="gsize" c:type="gsize" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26652">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26653">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26654">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26655">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="count" transfer-ownership="none" gs:managed-name="count" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26651">the number of bytes that will be skipped from the stream</doc>
            <type name="gsize" c:type="gsize" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26652">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26654">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26653">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="skip_finish" invoker="skip_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoSkipFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="26683">Finishes a stream skip operation.</doc>
        <source-position filename="ginputstream.h" line="91" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="26692">the size of the bytes skipped, or `-1` on error.</doc>
          <type name="gssize" c:type="gssize" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26685">a #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26686">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26686">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <method name="clear_pending" c:identifier="g_input_stream_clear_pending" gs:dll-name="gio-2.0" gs:managed-name="ClearPending">
        <doc xml:space="preserve" filename="gio-2.0.c" line="26259">Clears the pending flag on @stream.</doc>
        <source-position filename="ginputstream.h" line="212" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26261">input stream</doc>
            <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="close" c:identifier="g_input_stream_close" throws="1" gs:dll-name="gio-2.0" gs:managed-name="Close">
        <doc xml:space="preserve" filename="gio-2.0.c" line="26267">Closes the stream, releasing resources related to it.

Once the stream is closed, all other operations will return %G_IO_ERROR_CLOSED.
Closing a stream multiple times will not return an error.

Streams will be automatically closed when the last reference
is dropped, but you might want to call this function to make sure
resources are released as early as possible.

Some streams might keep the backing store of the stream (e.g. a file descriptor)
open after the stream is closed. See the documentation for the individual
stream for details.

On failure the first error that happened will be reported, but the close
operation will finish as much as possible. A stream that failed to
close will still return %G_IO_ERROR_CLOSED for all operations. Still, it
is important to check and report the error to the user.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
Cancelling a close will still leave the stream closed, but some streams
can use a faster close that doesn't block to e.g. check errors.</doc>
        <source-position filename="ginputstream.h" line="139" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="26297">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26269">A #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26270">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26270">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="close_async" c:identifier="g_input_stream_close_async" gs:dll-name="gio-2.0" gs:managed-name="CloseAsync" gs:async="1" gs:async-finish="CloseFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="26301">Requests an asynchronous closes of the stream, releasing resources related to it.
When the operation is finished @callback will be called.
You can then call g_input_stream_close_finish() to get the result of the
operation.

For behaviour details see g_input_stream_close().

The asynchronous methods have a default fallback that uses threads to implement
asynchronicity, so they are optional for inheriting classes. However, if you
override one you must override all.</doc>
        <source-position filename="ginputstream.h" line="192" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Threading.Tasks.Task" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26303">A #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26304">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26305">optional cancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26306">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26307">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26304">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26305">optional cancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="close_finish" c:identifier="g_input_stream_close_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="CloseFinish" gs:pinvoke-only="1" gs:finish-for="close_async">
        <doc xml:space="preserve" filename="gio-2.0.c" line="26322">Finishes closing a stream asynchronously, started from g_input_stream_close_async().</doc>
        <source-position filename="ginputstream.h" line="198" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="26331">%TRUE if the stream was closed successfully.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26324">a #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26325">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26325">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="has_pending" c:identifier="g_input_stream_has_pending" gs:dll-name="gio-2.0" gs:managed-name="HasPending">
        <doc xml:space="preserve" filename="gio-2.0.c" line="26335">Checks if an input stream has pending actions.</doc>
        <source-position filename="ginputstream.h" line="207" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="26341">%TRUE if @stream has pending actions.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26337">input stream.</doc>
            <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="is_closed" gs:dll-name="gio-2.0" gs:managed-name="IsClosed">
        <doc xml:space="preserve" filename="gio-2.0.c" line="26345">Checks if an input stream is closed.</doc>
        <source-position filename="ginputstream.h" line="205" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="26351">%TRUE if the stream is closed.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26347">input stream.</doc>
            <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="is_closed" c:identifier="g_input_stream_is_closed" gs:dll-name="gio-2.0" gs:managed-name="GetIsClosed" gs:property-getter-for="IsClosed" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="26345">Checks if an input stream is closed.</doc>
        <source-position filename="ginputstream.h" line="205" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="26351">%TRUE if the stream is closed.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26347">input stream.</doc>
            <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="read" c:identifier="g_input_stream_read" throws="1" gs:dll-name="gio-2.0" gs:managed-name="Read">
        <doc xml:space="preserve" filename="gio-2.0.c" line="26355">Tries to read @count bytes from the stream into the buffer starting at
@buffer. Will block during this read.

If count is zero returns zero and does nothing. A value of @count
larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.

On success, the number of bytes read into the buffer is returned.
It is not an error if this is not the same as the requested size, as it
can happen e.g. near the end of a file. Zero is returned on end of file
(or if @count is zero),  but never otherwise.

The returned @buffer is not a nul-terminated string, it can contain nul bytes
at any position, and this function doesn't nul-terminate the @buffer.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
operation was partially finished when the operation was cancelled the
partial result will be returned, without an error.

On error -1 is returned and @error is set accordingly.</doc>
        <source-position filename="ginputstream.h" line="116" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="26386">Number of bytes read, or -1 on error, or 0 on end of file.</doc>
          <type name="gssize" c:type="gssize" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26357">a #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="buffer" direction="out" caller-allocates="1" transfer-ownership="none" gs:managed-name="buffer">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26358">
    a buffer to read data into (which should be at least count bytes long).</doc>
            <array length="1" zero-terminated="0" c:type="void*" gs:is-pointer="1">
              <type name="guint8" />
            </array>
          </parameter>
          <parameter name="count" direction="in" caller-allocates="0" transfer-ownership="full" gs:managed-name="count">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26360">the number of bytes that will be read from the stream</doc>
            <type name="gsize" c:type="gsize" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26361">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="buffer" direction="out" caller-allocates="1" transfer-ownership="none" gs:managed-name="buffer">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26358">
    a buffer to read data into (which should be at least count bytes long).</doc>
            <array length="1" zero-terminated="0" c:type="void*" gs:is-pointer="1">
              <type name="guint8" />
            </array>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26361">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="read_all" c:identifier="g_input_stream_read_all" throws="1" gs:dll-name="gio-2.0" gs:managed-name="ReadAll">
        <doc xml:space="preserve" filename="gio-2.0.c" line="26390">Tries to read @count bytes from the stream into the buffer starting at
@buffer. Will block during this read.

This function is similar to g_input_stream_read(), except it tries to
read as many bytes as requested, only stopping on an error or end of stream.

On a successful read of @count bytes, or if we reached the end of the
stream,  %TRUE is returned, and @bytes_read is set to the number of bytes
read into @buffer.

If there is an error during the operation %FALSE is returned and @error
is set to indicate the error status.

As a special exception to the normal conventions for functions that
use #GError, if this function returns %FALSE (and sets @error) then
@bytes_read will be set to the number of bytes that were successfully
read before the error was encountered.  This functionality is only
available from C.  If you need it from another language then you must
write your own loop around g_input_stream_read().</doc>
        <source-position filename="ginputstream.h" line="122" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="26420">%TRUE on success, %FALSE if there was an error</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26392">a #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="buffer" direction="out" caller-allocates="1" transfer-ownership="none" gs:managed-name="buffer">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26393">
    a buffer to read data into (which should be at least count bytes long).</doc>
            <array length="1" zero-terminated="0" c:type="void*" gs:is-pointer="1">
              <type name="guint8" />
            </array>
          </parameter>
          <parameter name="count" direction="in" caller-allocates="0" transfer-ownership="full" gs:managed-name="count">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26395">the number of bytes that will be read from the stream</doc>
            <type name="gsize" c:type="gsize" />
          </parameter>
          <parameter name="bytes_read" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="bytesRead">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26396">location to store the number of bytes that was read from the stream</doc>
            <type name="gsize" c:type="gsize*" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26397">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="buffer" direction="out" caller-allocates="1" transfer-ownership="none" gs:managed-name="buffer">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26393">
    a buffer to read data into (which should be at least count bytes long).</doc>
            <array length="1" zero-terminated="0" c:type="void*" gs:is-pointer="1">
              <type name="guint8" />
            </array>
          </parameter>
          <parameter name="bytes_read" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="bytesRead">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26396">location to store the number of bytes that was read from the stream</doc>
            <type name="gsize" c:type="gsize*" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26397">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="read_all_async" c:identifier="g_input_stream_read_all_async" version="2.44" gs:dll-name="gio-2.0" gs:managed-name="ReadAllAsync" gs:async="1" gs:async-finish="ReadAllFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="26424">Request an asynchronous read of @count bytes from the stream into the
buffer starting at @buffer.

This is the asynchronous equivalent of g_input_stream_read_all().

Call g_input_stream_read_all_finish() to collect the result.

Any outstanding I/O request with higher priority (lower numerical
value) will be executed before an outstanding request with lower
priority. Default priority is %G_PRIORITY_DEFAULT.</doc>
        <source-position filename="ginputstream.h" line="156" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Threading.Tasks.Task">
            <type name="gsize" c:type="gsize*" />
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26426">A #GInputStream</doc>
            <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="buffer" direction="out" caller-allocates="1" transfer-ownership="none" gs:managed-name="buffer">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26427">
    a buffer to read data into (which should be at least count bytes long)</doc>
            <array length="1" zero-terminated="0" c:type="void*" gs:is-pointer="1">
              <type name="guint8" />
            </array>
          </parameter>
          <parameter name="count" direction="in" caller-allocates="0" transfer-ownership="full" gs:managed-name="count">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26429">the number of bytes that will be read from the stream</doc>
            <type name="gsize" c:type="gsize" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26430">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26431">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26432">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26433">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="buffer" direction="out" caller-allocates="1" transfer-ownership="none" gs:managed-name="buffer">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26427">
    a buffer to read data into (which should be at least count bytes long)</doc>
            <array length="1" zero-terminated="0" c:type="void*" gs:is-pointer="1">
              <type name="guint8" />
            </array>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26430">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26431">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="read_all_finish" c:identifier="g_input_stream_read_all_finish" version="2.44" throws="1" gs:dll-name="gio-2.0" gs:managed-name="ReadAllFinish" gs:pinvoke-only="1" gs:finish-for="read_all_async">
        <doc xml:space="preserve" filename="gio-2.0.c" line="26450">Finishes an asynchronous stream read operation started with
g_input_stream_read_all_async().

As a special exception to the normal conventions for functions that
use #GError, if this function returns %FALSE (and sets @error) then
@bytes_read will be set to the number of bytes that were successfully
read before the error was encountered.  This functionality is only
available from C.  If you need it from another language then you must
write your own loop around g_input_stream_read_async().</doc>
        <source-position filename="ginputstream.h" line="164" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="26467">%TRUE on success, %FALSE if there was an error</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26452">a #GInputStream</doc>
            <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26453">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <parameter name="bytes_read" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="bytesRead">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26454">location to store the number of bytes that was read from the stream</doc>
            <type name="gsize" c:type="gsize*" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26453">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <parameter name="bytes_read" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="bytesRead">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26454">location to store the number of bytes that was read from the stream</doc>
            <type name="gsize" c:type="gsize*" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="read_async" c:identifier="g_input_stream_read_async" gs:dll-name="gio-2.0" gs:managed-name="ReadAsync" gs:async="1" gs:async-finish="ReadFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="26472">Request an asynchronous read of @count bytes from the stream into the buffer
starting at @buffer. When the operation is finished @callback will be called.
You can then call g_input_stream_read_finish() to get the result of the
operation.

During an async request no other sync and async calls are allowed on @stream, and will
result in %G_IO_ERROR_PENDING errors.

A value of @count larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.

On success, the number of bytes read into the buffer will be passed to the
callback. It is not an error if this is not the same as the requested size, as it
can happen e.g. near the end of a file, but generally we try to read
as many bytes as requested. Zero is returned on end of file
(or if @count is zero),  but never otherwise.

Any outstanding i/o request with higher priority (lower numerical value) will
be executed before an outstanding request with lower priority. Default
priority is %G_PRIORITY_DEFAULT.

The asynchronous methods have a default fallback that uses threads to implement
asynchronicity, so they are optional for inheriting classes. However, if you
override one you must override all.</doc>
        <source-position filename="ginputstream.h" line="143" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Threading.Tasks.Task">
            <type name="gssize" c:type="gssize" />
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26474">A #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="buffer" direction="out" caller-allocates="1" transfer-ownership="none" gs:managed-name="buffer">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26475">
    a buffer to read data into (which should be at least count bytes long).</doc>
            <array length="1" zero-terminated="0" c:type="void*" gs:is-pointer="1">
              <type name="guint8" />
            </array>
          </parameter>
          <parameter name="count" direction="in" caller-allocates="0" transfer-ownership="full" gs:managed-name="count">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26477">the number of bytes that will be read from the stream</doc>
            <type name="gsize" c:type="gsize" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26478">the [I/O priority][io-priority]
of the request.</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26480">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26481">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26482">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="buffer" direction="out" caller-allocates="1" transfer-ownership="none" gs:managed-name="buffer">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26475">
    a buffer to read data into (which should be at least count bytes long).</doc>
            <array length="1" zero-terminated="0" c:type="void*" gs:is-pointer="1">
              <type name="guint8" />
            </array>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26478">the [I/O priority][io-priority]
of the request.</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26480">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="read_bytes" c:identifier="g_input_stream_read_bytes" version="2.34" throws="1" gs:dll-name="gio-2.0" gs:managed-name="ReadBytes">
        <doc xml:space="preserve" filename="gio-2.0.c" line="26510">Like g_input_stream_read(), this tries to read @count bytes from
the stream in a blocking fashion. However, rather than reading into
a user-supplied buffer, this will create a new #GBytes containing
the data that was read. This may be easier to use from language
bindings.

If count is zero, returns a zero-length #GBytes and does nothing. A
value of @count larger than %G_MAXSSIZE will cause a
%G_IO_ERROR_INVALID_ARGUMENT error.

On success, a new #GBytes is returned. It is not an error if the
size of this object is not the same as the requested size, as it
can happen e.g. near the end of a file. A zero-length #GBytes is
returned on end of file (or if @count is zero), but never
otherwise.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
operation was partially finished when the operation was cancelled the
partial result will be returned, without an error.

On error %NULL is returned and @error is set accordingly.</doc>
        <source-position filename="ginputstream.h" line="129" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="26542">a new #GBytes, or %NULL on error</doc>
          <type name="GLib.Bytes" c:type="GBytes*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26512">a #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="count" transfer-ownership="none" direction="in" gs:managed-name="count">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26513">maximum number of bytes that will be read from the stream. Common
values include 4096 and 8192.</doc>
            <type name="gsize" c:type="gsize" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26515">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="count" transfer-ownership="none" direction="in" gs:managed-name="count">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26513">maximum number of bytes that will be read from the stream. Common
values include 4096 and 8192.</doc>
            <type name="gsize" c:type="gsize" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26515">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="read_bytes_async" c:identifier="g_input_stream_read_bytes_async" version="2.34" gs:dll-name="gio-2.0" gs:managed-name="ReadBytesAsync" gs:async="1" gs:async-finish="ReadBytesFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="26547">Request an asynchronous read of @count bytes from the stream into a
new #GBytes. When the operation is finished @callback will be
called. You can then call g_input_stream_read_bytes_finish() to get the
result of the operation.

During an async request no other sync and async calls are allowed
on @stream, and will result in %G_IO_ERROR_PENDING errors.

A value of @count larger than %G_MAXSSIZE will cause a
%G_IO_ERROR_INVALID_ARGUMENT error.

On success, the new #GBytes will be passed to the callback. It is
not an error if this is smaller than the requested size, as it can
happen e.g. near the end of a file, but generally we try to read as
many bytes as requested. Zero is returned on end of file (or if
@count is zero), but never otherwise.

Any outstanding I/O request with higher priority (lower numerical
value) will be executed before an outstanding request with lower
priority. Default priority is %G_PRIORITY_DEFAULT.</doc>
        <source-position filename="ginputstream.h" line="170" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Threading.Tasks.Task">
            <type name="GLib.Bytes" c:type="GBytes*" gs:is-pointer="1" />
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26549">A #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="count" transfer-ownership="none" direction="in" gs:managed-name="count">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26550">the number of bytes that will be read from the stream</doc>
            <type name="gsize" c:type="gsize" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26551">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26552">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26553">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26554">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="count" transfer-ownership="none" direction="in" gs:managed-name="count">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26550">the number of bytes that will be read from the stream</doc>
            <type name="gsize" c:type="gsize" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26551">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26552">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="read_bytes_finish" c:identifier="g_input_stream_read_bytes_finish" version="2.34" throws="1" gs:dll-name="gio-2.0" gs:managed-name="ReadBytesFinish" gs:pinvoke-only="1" gs:finish-for="read_bytes_async">
        <doc xml:space="preserve" filename="gio-2.0.c" line="26581">Finishes an asynchronous stream read-into-#GBytes operation.</doc>
        <source-position filename="ginputstream.h" line="177" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="26590">the newly-allocated #GBytes, or %NULL on error</doc>
          <type name="GLib.Bytes" c:type="GBytes*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26583">a #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26584">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26584">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="read_finish" c:identifier="g_input_stream_read_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="ReadFinish" gs:pinvoke-only="1" gs:finish-for="read_async">
        <doc xml:space="preserve" filename="gio-2.0.c" line="26595">Finishes an asynchronous stream read operation.</doc>
        <source-position filename="ginputstream.h" line="151" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="26604">number of bytes read in, or -1 on error, or 0 on end of file.</doc>
          <type name="gssize" c:type="gssize" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26597">a #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26598">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26598">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_pending" c:identifier="g_input_stream_set_pending" throws="1" gs:dll-name="gio-2.0" gs:managed-name="SetPending">
        <doc xml:space="preserve" filename="gio-2.0.c" line="26608">Sets @stream to have actions pending. If the pending flag is
already set or @stream is closed, it will return %FALSE and set
@error.</doc>
        <source-position filename="ginputstream.h" line="209" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="26618">%TRUE if pending was previously unset and is now set.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26610">input stream</doc>
            <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="skip" c:identifier="g_input_stream_skip" throws="1" gs:dll-name="gio-2.0" gs:managed-name="Skip">
        <doc xml:space="preserve" filename="gio-2.0.c" line="26622">Tries to skip @count bytes from the stream. Will block during the operation.

This is identical to g_input_stream_read(), from a behaviour standpoint,
but the bytes that are skipped are not returned to the user. Some
streams have an implementation that is more efficient than reading the data.

This function is optional for inherited classes, as the default implementation
emulates it using read.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
operation was partially finished when the operation was cancelled the
partial result will be returned, without an error.</doc>
        <source-position filename="ginputstream.h" line="134" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="26644">Number of bytes skipped, or -1 on error</doc>
          <type name="gssize" c:type="gssize" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26624">a #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="count" transfer-ownership="none" gs:managed-name="count" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26625">the number of bytes that will be skipped from the stream</doc>
            <type name="gsize" c:type="gsize" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26626">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="count" transfer-ownership="none" gs:managed-name="count" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26625">the number of bytes that will be skipped from the stream</doc>
            <type name="gsize" c:type="gsize" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26626">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="skip_async" c:identifier="g_input_stream_skip_async" gs:dll-name="gio-2.0" gs:managed-name="SkipAsync" gs:async="1" gs:async-finish="SkipFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="26648">Request an asynchronous skip of @count bytes from the stream.
When the operation is finished @callback will be called.
You can then call g_input_stream_skip_finish() to get the result
of the operation.

During an async request no other sync and async calls are allowed,
and will result in %G_IO_ERROR_PENDING errors.

A value of @count larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.

On success, the number of bytes skipped will be passed to the callback.
It is not an error if this is not the same as the requested size, as it
can happen e.g. near the end of a file, but generally we try to skip
as many bytes as requested. Zero is returned on end of file
(or if @count is zero), but never otherwise.

Any outstanding i/o request with higher priority (lower numerical value)
will be executed before an outstanding request with lower priority.
Default priority is %G_PRIORITY_DEFAULT.

The asynchronous methods have a default fallback that uses threads to
implement asynchronicity, so they are optional for inheriting classes.
However, if you override one, you must override all.</doc>
        <source-position filename="ginputstream.h" line="181" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Threading.Tasks.Task">
            <type name="gssize" c:type="gssize" />
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26650">A #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="count" transfer-ownership="none" gs:managed-name="count" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26651">the number of bytes that will be skipped from the stream</doc>
            <type name="gsize" c:type="gsize" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26652">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26653">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26654">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26655">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="count" transfer-ownership="none" gs:managed-name="count" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26651">the number of bytes that will be skipped from the stream</doc>
            <type name="gsize" c:type="gsize" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26652">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26653">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="skip_finish" c:identifier="g_input_stream_skip_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="SkipFinish" gs:pinvoke-only="1" gs:finish-for="skip_async">
        <doc xml:space="preserve" filename="gio-2.0.c" line="26683">Finishes a stream skip operation.</doc>
        <source-position filename="ginputstream.h" line="188" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="26692">the size of the bytes skipped, or `-1` on error.</doc>
          <type name="gssize" c:type="gssize" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26685">a #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26686">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26686">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <field name="parent_instance" gs:managed-name="ParentInstance">
        <type name="GObject.Object" c:type="GObject" />
      </field>
      <field name="priv" readable="0" private="1" gs:managed-name="Priv">
        <type name="InputStreamPrivate" c:type="GInputStreamPrivate*" gs:is-pointer="1" />
      </field>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_input_stream_get_type" gs:access-modifiers="private" gs:dll-name="gio-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </class>
    <record name="InputStreamClass" c:type="GInputStreamClass" glib:is-gtype-struct-for="InputStream" gs:managed-name="InputStreamClass">
      <source-position filename="ginputstream.h" line="110" />
      <field name="parent_class" gs:managed-name="ParentClass">
        <type name="GObject.ObjectClass" c:type="GObjectClass" />
      </field>
      <field name="read_fn" gs:managed-name="ReadFn">
        <callback name="read_fn" throws="1" gs:dll-name="gio-2.0" gs:managed-name="ReadFn">
          <source-position filename="ginputstream.h" line="61" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="gssize" c:type="gssize" />
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="buffer" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="buffer" direction="in">
              <type name="gpointer" c:type="void*" gs:is-pointer="1" />
            </parameter>
            <parameter name="count" transfer-ownership="none" direction="in" gs:managed-name="count">
              <type name="gsize" c:type="gsize" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="buffer" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="buffer" direction="in">
              <type name="gpointer" c:type="void*" gs:is-pointer="1" />
            </parameter>
            <parameter name="count" transfer-ownership="none" direction="in" gs:managed-name="count">
              <type name="gsize" c:type="gsize" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="skip" gs:managed-name="Skip">
        <callback name="skip" throws="1" gs:dll-name="gio-2.0" gs:managed-name="Skip">
          <source-position filename="ginputstream.h" line="66" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26644">Number of bytes skipped, or -1 on error</doc>
            <type name="gssize" c:type="gssize" />
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="26624">a #GInputStream.</doc>
              <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="count" transfer-ownership="none" gs:managed-name="count" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="26625">the number of bytes that will be skipped from the stream</doc>
              <type name="gsize" c:type="gsize" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="26626">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="26624">a #GInputStream.</doc>
              <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="count" transfer-ownership="none" gs:managed-name="count" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="26625">the number of bytes that will be skipped from the stream</doc>
              <type name="gsize" c:type="gsize" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="26626">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="close_fn" gs:managed-name="CloseFn">
        <callback name="close_fn" throws="1" gs:dll-name="gio-2.0" gs:managed-name="CloseFn">
          <source-position filename="ginputstream.h" line="70" />
          <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="read_async" gs:managed-name="ReadAsync">
        <callback name="read_async" gs:dll-name="gio-2.0" gs:managed-name="ReadAsync">
          <source-position filename="ginputstream.h" line="75" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="26474">A #GInputStream.</doc>
              <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="buffer" direction="out" caller-allocates="1" transfer-ownership="none" nullable="1" gs:managed-name="buffer">
              <doc xml:space="preserve" filename="gio-2.0.c" line="26475">
    a buffer to read data into (which should be at least count bytes long).</doc>
              <array length="2" zero-terminated="0" c:type="void*" gs:is-pointer="1">
                <type name="guint8" />
              </array>
            </parameter>
            <parameter name="count" direction="in" caller-allocates="0" transfer-ownership="full" gs:managed-name="count">
              <doc xml:space="preserve" filename="gio-2.0.c" line="26477">the number of bytes that will be read from the stream</doc>
              <type name="gsize" c:type="gsize" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="26478">the [I/O priority][io-priority]
of the request.</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="26480">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="6" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="26481">callback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="6" gs:managed-name="userData" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="26482">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="26474">A #GInputStream.</doc>
              <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="buffer" direction="out" caller-allocates="1" transfer-ownership="none" nullable="1" gs:managed-name="buffer">
              <doc xml:space="preserve" filename="gio-2.0.c" line="26475">
    a buffer to read data into (which should be at least count bytes long).</doc>
              <array length="2" zero-terminated="0" c:type="void*" gs:is-pointer="1">
                <type name="guint8" />
              </array>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="26478">the [I/O priority][io-priority]
of the request.</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="6" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="26481">callback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="26480">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="read_finish" gs:managed-name="ReadFinish">
        <callback name="read_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="ReadFinish">
          <source-position filename="ginputstream.h" line="82" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26604">number of bytes read in, or -1 on error, or 0 on end of file.</doc>
            <type name="gssize" c:type="gssize" />
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="26597">a #GInputStream.</doc>
              <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="26598">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="26597">a #GInputStream.</doc>
              <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="26598">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="skip_async" gs:managed-name="SkipAsync">
        <callback name="skip_async" gs:dll-name="gio-2.0" gs:managed-name="SkipAsync">
          <source-position filename="ginputstream.h" line="85" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="26650">A #GInputStream.</doc>
              <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="count" transfer-ownership="none" gs:managed-name="count" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="26651">the number of bytes that will be skipped from the stream</doc>
              <type name="gsize" c:type="gsize" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="26652">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="26653">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="26654">callback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5" gs:managed-name="userData" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="26655">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="26650">A #GInputStream.</doc>
              <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="count" transfer-ownership="none" gs:managed-name="count" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="26651">the number of bytes that will be skipped from the stream</doc>
              <type name="gsize" c:type="gsize" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="26652">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="26654">callback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="26653">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="skip_finish" gs:managed-name="SkipFinish">
        <callback name="skip_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="SkipFinish">
          <source-position filename="ginputstream.h" line="91" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26692">the size of the bytes skipped, or `-1` on error.</doc>
            <type name="gssize" c:type="gssize" />
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="26685">a #GInputStream.</doc>
              <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="26686">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="26685">a #GInputStream.</doc>
              <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="26686">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="close_async" gs:managed-name="CloseAsync">
        <callback name="close_async" gs:dll-name="gio-2.0" gs:managed-name="CloseAsync">
          <source-position filename="ginputstream.h" line="94" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="26303">A #GInputStream.</doc>
              <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="26304">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="26305">optional cancellable object</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="26306">callback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4" gs:managed-name="userData" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="26307">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="26303">A #GInputStream.</doc>
              <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="26304">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="26306">callback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="26305">optional cancellable object</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="close_finish" gs:managed-name="CloseFinish">
        <callback name="close_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="CloseFinish">
          <source-position filename="ginputstream.h" line="99" />
          <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="26331">%TRUE if the stream was closed successfully.</doc>
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="26324">a #GInputStream.</doc>
              <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="26325">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="26324">a #GInputStream.</doc>
              <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="26325">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="_g_reserved1" introspectable="1" gs:managed-name="GReserved1">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="_g_reserved2" introspectable="1" gs:managed-name="GReserved2">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="_g_reserved3" introspectable="1" gs:managed-name="GReserved3">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="_g_reserved4" introspectable="1" gs:managed-name="GReserved4">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="_g_reserved5" introspectable="1" gs:managed-name="GReserved5">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
    </record>
    <interface name="LoadableIcon" c:symbol-prefix="loadable_icon" c:type="GLoadableIcon" glib:type-name="GLoadableIcon" glib:get-type="g_loadable_icon_get_type" glib:type-struct="LoadableIconIface" gs:managed-name="ILoadableIcon">
      <doc xml:space="preserve" filename="gio-2.0.c" line="6907">Extends the #GIcon interface and adds the ability to
load icons from streams.</doc>
      <source-position filename="gloadableicon.h" line="74" />
      <prerequisite name="Icon" gs:managed-name="Icon" />
      <virtual-method name="load" invoker="load" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoLoad">
        <doc xml:space="preserve" filename="gio-2.0.c" line="27592">Loads a loadable icon. For the asynchronous version of this function,
see g_loadable_icon_load_async().</doc>
        <source-position filename="gloadableicon.h" line="60" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="27606">a #GInputStream to read the icon from.</doc>
          <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="icon" transfer-ownership="none" gs:managed-name="icon" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27594">a #GLoadableIcon.</doc>
            <type name="LoadableIcon" c:type="GLoadableIcon*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="size" transfer-ownership="none" gs:managed-name="size" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27595">an integer.</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="type" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="type">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27596">a location to store the type of the loaded
icon, %NULL to ignore.</doc>
            <type name="utf8" c:type="char**" gs:is-pointer="1" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27598">optional #GCancellable object, %NULL to
ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="size" transfer-ownership="none" gs:managed-name="size" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27595">an integer.</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="type" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="type">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27596">a location to store the type of the loaded
icon, %NULL to ignore.</doc>
            <type name="utf8" c:type="char**" gs:is-pointer="1" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27598">optional #GCancellable object, %NULL to
ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="load_async" invoker="load_async" gs:dll-name="gio-2.0" gs:managed-name="DoLoadAsync">
        <doc xml:space="preserve" filename="gio-2.0.c" line="27610">Loads an icon asynchronously. To finish this function, see
g_loadable_icon_load_finish(). For the synchronous, blocking
version of this function, see g_loadable_icon_load().</doc>
        <source-position filename="gloadableicon.h" line="65" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="icon" transfer-ownership="none" gs:managed-name="icon" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27612">a #GLoadableIcon.</doc>
            <type name="LoadableIcon" c:type="GLoadableIcon*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="size" transfer-ownership="none" gs:managed-name="size" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27613">an integer.</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27614">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27615">a #GAsyncReadyCallback to call when the
           request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27617">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="size" transfer-ownership="none" gs:managed-name="size" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27613">an integer.</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27615">a #GAsyncReadyCallback to call when the
           request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27614">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="load_finish" invoker="load_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoLoadFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="27625">Finishes an asynchronous icon load started in g_loadable_icon_load_async().</doc>
        <source-position filename="gloadableicon.h" line="70" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="27636">a #GInputStream to read the icon from.</doc>
          <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="icon" transfer-ownership="none" gs:managed-name="icon" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27627">a #GLoadableIcon.</doc>
            <type name="LoadableIcon" c:type="GLoadableIcon*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27628">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <parameter name="type" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="type">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27629">a location to store the type of the loaded
       icon, %NULL to ignore.</doc>
            <type name="utf8" c:type="char**" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27628">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <parameter name="type" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="type">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27629">a location to store the type of the loaded
       icon, %NULL to ignore.</doc>
            <type name="utf8" c:type="char**" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <method name="load" c:identifier="g_loadable_icon_load" throws="1" gs:dll-name="gio-2.0" gs:managed-name="Load" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="27592">Loads a loadable icon. For the asynchronous version of this function,
see g_loadable_icon_load_async().</doc>
        <source-position filename="gloadableicon.h" line="80" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="27606">a #GInputStream to read the icon from.</doc>
          <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="icon" transfer-ownership="none" gs:managed-name="icon" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27594">a #GLoadableIcon.</doc>
            <type name="LoadableIcon" c:type="GLoadableIcon*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="size" transfer-ownership="none" gs:managed-name="size" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27595">an integer.</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="type" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="type">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27596">a location to store the type of the loaded
icon, %NULL to ignore.</doc>
            <type name="utf8" c:type="char**" gs:is-pointer="1" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27598">optional #GCancellable object, %NULL to
ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="icon" transfer-ownership="none" gs:managed-name="icon" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27594">a #GLoadableIcon.</doc>
            <type name="LoadableIcon" c:type="GLoadableIcon*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="size" transfer-ownership="none" gs:managed-name="size" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27595">an integer.</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="type" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="type">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27596">a location to store the type of the loaded
icon, %NULL to ignore.</doc>
            <type name="utf8" c:type="char**" gs:is-pointer="1" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27598">optional #GCancellable object, %NULL to
ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="load_async" c:identifier="g_loadable_icon_load_async" gs:dll-name="gio-2.0" gs:managed-name="LoadAsync" gs:async="1" gs:async-finish="LoadFinish" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="27610">Loads an icon asynchronously. To finish this function, see
g_loadable_icon_load_finish(). For the synchronous, blocking
version of this function, see g_loadable_icon_load().</doc>
        <source-position filename="gloadableicon.h" line="86" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Threading.Tasks.Task">
            <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
            <type name="utf8" c:type="char**" gs:is-pointer="1" />
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="icon" transfer-ownership="none" gs:managed-name="icon" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27612">a #GLoadableIcon.</doc>
            <type name="LoadableIcon" c:type="GLoadableIcon*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="size" transfer-ownership="none" gs:managed-name="size" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27613">an integer.</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27614">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27615">a #GAsyncReadyCallback to call when the
           request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27617">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="icon" transfer-ownership="none" gs:managed-name="icon" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27612">a #GLoadableIcon.</doc>
            <type name="LoadableIcon" c:type="GLoadableIcon*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="size" transfer-ownership="none" gs:managed-name="size" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27613">an integer.</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27614">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="load_finish" c:identifier="g_loadable_icon_load_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="LoadFinish" gs:pinvoke-only="1" gs:finish-for="load_async" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="27625">Finishes an asynchronous icon load started in g_loadable_icon_load_async().</doc>
        <source-position filename="gloadableicon.h" line="92" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="27636">a #GInputStream to read the icon from.</doc>
          <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="icon" transfer-ownership="none" gs:managed-name="icon" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27627">a #GLoadableIcon.</doc>
            <type name="LoadableIcon" c:type="GLoadableIcon*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27628">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <parameter name="type" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="type">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27629">a location to store the type of the loaded
       icon, %NULL to ignore.</doc>
            <type name="utf8" c:type="char**" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="icon" transfer-ownership="none" gs:managed-name="icon" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27627">a #GLoadableIcon.</doc>
            <type name="LoadableIcon" c:type="GLoadableIcon*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27628">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <parameter name="type" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="type">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27629">a location to store the type of the loaded
       icon, %NULL to ignore.</doc>
            <type name="utf8" c:type="char**" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_loadable_icon_get_type" gs:access-modifiers="private" gs:dll-name="gio-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </interface>
    <record name="LoadableIconIface" c:type="GLoadableIconIface" glib:is-gtype-struct-for="LoadableIcon" gs:managed-name="LoadableIconIface">
      <doc xml:space="preserve" filename="gloadableicon.h" line="45">Interface for icons that can be loaded as a stream.</doc>
      <source-position filename="gloadableicon.h" line="74" />
      <field name="g_iface" gs:managed-name="GIface">
        <doc xml:space="preserve" filename="gloadableicon.h" line="47">The parent interface.</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface" />
      </field>
      <field name="load" gs:managed-name="Load">
        <callback name="load" throws="1" gs:dll-name="gio-2.0" gs:managed-name="Load">
          <source-position filename="gloadableicon.h" line="60" />
          <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27606">a #GInputStream to read the icon from.</doc>
            <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="icon" transfer-ownership="none" gs:managed-name="icon" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="27594">a #GLoadableIcon.</doc>
              <type name="LoadableIcon" c:type="GLoadableIcon*" gs:is-pointer="1" />
            </parameter>
            <parameter name="size" transfer-ownership="none" gs:managed-name="size" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="27595">an integer.</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="type" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="type">
              <doc xml:space="preserve" filename="gio-2.0.c" line="27596">a location to store the type of the loaded
icon, %NULL to ignore.</doc>
              <type name="utf8" c:type="char**" gs:is-pointer="1" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="27598">optional #GCancellable object, %NULL to
ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="icon" transfer-ownership="none" gs:managed-name="icon" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="27594">a #GLoadableIcon.</doc>
              <type name="LoadableIcon" c:type="GLoadableIcon*" gs:is-pointer="1" />
            </parameter>
            <parameter name="size" transfer-ownership="none" gs:managed-name="size" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="27595">an integer.</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="type" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="type">
              <doc xml:space="preserve" filename="gio-2.0.c" line="27596">a location to store the type of the loaded
icon, %NULL to ignore.</doc>
              <type name="utf8" c:type="char**" gs:is-pointer="1" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="27598">optional #GCancellable object, %NULL to
ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="load_async" gs:managed-name="LoadAsync">
        <callback name="load_async" gs:dll-name="gio-2.0" gs:managed-name="LoadAsync">
          <source-position filename="gloadableicon.h" line="65" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="icon" transfer-ownership="none" gs:managed-name="icon" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="27612">a #GLoadableIcon.</doc>
              <type name="LoadableIcon" c:type="GLoadableIcon*" gs:is-pointer="1" />
            </parameter>
            <parameter name="size" transfer-ownership="none" gs:managed-name="size" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="27613">an integer.</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="27614">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="27615">a #GAsyncReadyCallback to call when the
           request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4" gs:managed-name="userData" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="27617">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="icon" transfer-ownership="none" gs:managed-name="icon" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="27612">a #GLoadableIcon.</doc>
              <type name="LoadableIcon" c:type="GLoadableIcon*" gs:is-pointer="1" />
            </parameter>
            <parameter name="size" transfer-ownership="none" gs:managed-name="size" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="27613">an integer.</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="27615">a #GAsyncReadyCallback to call when the
           request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="27614">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="load_finish" gs:managed-name="LoadFinish">
        <callback name="load_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="LoadFinish">
          <source-position filename="gloadableicon.h" line="70" />
          <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="27636">a #GInputStream to read the icon from.</doc>
            <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="icon" transfer-ownership="none" gs:managed-name="icon" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="27627">a #GLoadableIcon.</doc>
              <type name="LoadableIcon" c:type="GLoadableIcon*" gs:is-pointer="1" />
            </parameter>
            <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="27628">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
            <parameter name="type" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="type">
              <doc xml:space="preserve" filename="gio-2.0.c" line="27629">a location to store the type of the loaded
       icon, %NULL to ignore.</doc>
              <type name="utf8" c:type="char**" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="icon" transfer-ownership="none" gs:managed-name="icon" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="27627">a #GLoadableIcon.</doc>
              <type name="LoadableIcon" c:type="GLoadableIcon*" gs:is-pointer="1" />
            </parameter>
            <parameter name="res" transfer-ownership="none" gs:managed-name="res" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="27628">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
            <parameter name="type" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="type">
              <doc xml:space="preserve" filename="gio-2.0.c" line="27629">a location to store the type of the loaded
       icon, %NULL to ignore.</doc>
              <type name="utf8" c:type="char**" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
    </record>
    <class name="OutputStream" c:symbol-prefix="output_stream" c:type="GOutputStream" parent="GObject.Object" abstract="1" glib:type-name="GOutputStream" glib:get-type="g_output_stream_get_type" glib:type-struct="OutputStreamClass" gs:managed-name="OutputStream">
      <doc xml:space="preserve" filename="gio-2.0.c" line="7331">#GOutputStream has functions to write to a stream (g_output_stream_write()),
to close a stream (g_output_stream_close()) and to flush pending writes
(g_output_stream_flush()).

To copy the content of an input stream to an output stream without
manually handling the reads and writes, use g_output_stream_splice().

See the documentation for #GIOStream for details of thread safety of
streaming APIs.

All of these functions have async variants too.</doc>
      <source-position filename="goutputstream.h" line="149" />
      <virtual-method name="close_async" invoker="close_async" gs:dll-name="gio-2.0" gs:managed-name="DoCloseAsync">
        <doc xml:space="preserve" filename="gio-2.0.c" line="30109">Requests an asynchronous close of the stream, releasing resources
related to it. When the operation is finished @callback will be
called. You can then call g_output_stream_close_finish() to get
the result of the operation.

For behaviour details see g_output_stream_close().

The asynchronous methods have a default fallback that uses threads
to implement asynchronicity, so they are optional for inheriting
classes. However, if you override one you must override all.</doc>
        <source-position filename="goutputstream.h" line="113" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30111">A #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30112">the io priority of the request.</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30113">optional cancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30114">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30115">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30112">the io priority of the request.</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30114">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30113">optional cancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="close_finish" invoker="close_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoCloseFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="30130">Closes an output stream.</doc>
        <source-position filename="goutputstream.h" line="118" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="30139">%TRUE if stream was successfully closed, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30132">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30133">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30133">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="close_fn" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoCloseFn">
        <source-position filename="goutputstream.h" line="79" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="flush" invoker="flush" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoFlush">
        <doc xml:space="preserve" filename="gio-2.0.c" line="30143">Forces a write of all user-space buffered data for the given
@stream. Will block during the operation. Closing the stream will
implicitly cause a flush.

This function is optional for inherited classes.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <source-position filename="goutputstream.h" line="76" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="30159">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30145">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30146">optional cancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30146">optional cancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="flush_async" invoker="flush_async" gs:dll-name="gio-2.0" gs:managed-name="DoFlushAsync">
        <doc xml:space="preserve" filename="gio-2.0.c" line="30163">Forces an asynchronous write of all user-space buffered data for
the given @stream.
For behaviour details see g_output_stream_flush().

When the operation is finished @callback will be
called. You can then call g_output_stream_flush_finish() to get the
result of the operation.</doc>
        <source-position filename="goutputstream.h" line="105" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30165">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30166">the io priority of the request.</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30167">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30168">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30169">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30166">the io priority of the request.</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30168">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30167">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="flush_finish" invoker="flush_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoFlushFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="30181">Finishes flushing an output stream.</doc>
        <source-position filename="goutputstream.h" line="110" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="30190">%TRUE if flush operation succeeded, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30183">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30184">a GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30184">a GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="splice" invoker="splice" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoSplice">
        <doc xml:space="preserve" filename="gio-2.0.c" line="30270">Splices an input stream into an output stream.</doc>
        <source-position filename="goutputstream.h" line="71" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="30281">a #gssize containing the size of the data spliced, or
    -1 if an error occurred. Note that if the number of bytes
    spliced is greater than %G_MAXSSIZE, then that will be
    returned, and there is no way to determine the actual number
    of bytes spliced.</doc>
          <type name="gssize" c:type="gssize" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30272">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30273">a #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30274">a set of #GOutputStreamSpliceFlags.</doc>
            <type name="OutputStreamSpliceFlags" c:type="GOutputStreamSpliceFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30275">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30273">a #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30274">a set of #GOutputStreamSpliceFlags.</doc>
            <type name="OutputStreamSpliceFlags" c:type="GOutputStreamSpliceFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30275">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="splice_async" invoker="splice_async" gs:dll-name="gio-2.0" gs:managed-name="DoSpliceAsync">
        <doc xml:space="preserve" filename="gio-2.0.c" line="30289">Splices a stream asynchronously.
When the operation is finished @callback will be called.
You can then call g_output_stream_splice_finish() to get the
result of the operation.

For the synchronous, blocking version of this function, see
g_output_stream_splice().</doc>
        <source-position filename="goutputstream.h" line="95" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30291">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30292">a #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30293">a set of #GOutputStreamSpliceFlags.</doc>
            <type name="OutputStreamSpliceFlags" c:type="GOutputStreamSpliceFlags" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30294">the io priority of the request.</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30295">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30296">a #GAsyncReadyCallback.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30297">user data passed to @callback.</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30292">a #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30293">a set of #GOutputStreamSpliceFlags.</doc>
            <type name="OutputStreamSpliceFlags" c:type="GOutputStreamSpliceFlags" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30294">the io priority of the request.</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30296">a #GAsyncReadyCallback.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30295">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="splice_finish" invoker="splice_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoSpliceFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="30309">Finishes an asynchronous stream splice operation.</doc>
        <source-position filename="goutputstream.h" line="102" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="30318">a #gssize of the number of bytes spliced. Note that if the
    number of bytes spliced is greater than %G_MAXSSIZE, then that
    will be returned, and there is no way to determine the actual
    number of bytes spliced.</doc>
          <type name="gssize" c:type="gssize" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30311">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30312">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30312">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="write_async" invoker="write_async" gs:dll-name="gio-2.0" gs:managed-name="DoWriteAsync">
        <doc xml:space="preserve" filename="gio-2.0.c" line="30473">Request an asynchronous write of @count bytes from @buffer into
the stream. When the operation is finished @callback will be called.
You can then call g_output_stream_write_finish() to get the result of the
operation.

During an async request no other sync and async calls are allowed,
and will result in %G_IO_ERROR_PENDING errors.

A value of @count larger than %G_MAXSSIZE will cause a
%G_IO_ERROR_INVALID_ARGUMENT error.

On success, the number of bytes written will be passed to the
@callback. It is not an error if this is not the same as the
requested size, as it can happen e.g. on a partial I/O error,
but generally we try to write as many bytes as requested.

You are guaranteed that this method will never fail with
%G_IO_ERROR_WOULD_BLOCK - if @stream can't accept more data, the
method will just wait until this changes.

Any outstanding I/O request with higher priority (lower numerical
value) will be executed before an outstanding request with lower
priority. Default priority is %G_PRIORITY_DEFAULT.

The asynchronous methods have a default fallback that uses threads
to implement asynchronicity, so they are optional for inheriting
classes. However, if you override one you must override all.

For the synchronous, blocking version of this function, see
g_output_stream_write().

Note that no copy of @buffer will be made, so it must stay valid
until @callback is called. See g_output_stream_write_bytes_async()
for a #GBytes version that will automatically hold a reference to
the contents (without copying) for the duration of the call.</doc>
        <source-position filename="goutputstream.h" line="85" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30475">A #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="buffer" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30476">the buffer containing the data to write.</doc>
            <array length="1" zero-terminated="0" c:type="void*" gs:is-pointer="1">
              <type name="guint8" />
            </array>
          </parameter>
          <parameter name="count" transfer-ownership="none" gs:managed-name="count" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30477">the number of bytes to write</doc>
            <type name="gsize" c:type="gsize" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30478">the io priority of the request.</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30479">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30480">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30481">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="buffer" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="buffer" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30476">the buffer containing the data to write.</doc>
            <array length="1" zero-terminated="0" c:type="void*" gs:is-pointer="1">
              <type name="guint8" />
            </array>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30478">the io priority of the request.</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30480">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30479">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="write_finish" invoker="write_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoWriteFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="30582">Finishes a stream write operation.</doc>
        <source-position filename="goutputstream.h" line="92" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="30591">a #gssize containing the number of bytes written to the stream.</doc>
          <type name="gssize" c:type="gssize" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30584">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30585">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30585">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="write_fn" invoker="write" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoWriteFn">
        <doc xml:space="preserve" filename="gio-2.0.c" line="30353">Tries to write @count bytes from @buffer into the stream. Will block
during the operation.

If count is 0, returns 0 and does nothing. A value of @count
larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.

On success, the number of bytes written to the stream is returned.
It is not an error if this is not the same as the requested size, as it
can happen e.g. on a partial I/O error, or if there is not enough
storage in the stream. All writes block until at least one byte
is written or an error occurs; 0 is never returned (unless
@count is 0).

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
operation was partially finished when the operation was cancelled the
partial result will be returned, without an error.

On error -1 is returned and @error is set accordingly.</doc>
        <source-position filename="goutputstream.h" line="66" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="30382">Number of bytes written, or -1 on error</doc>
          <type name="gssize" c:type="gssize" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30355">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="buffer" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30356">the buffer containing the data to write.</doc>
            <array length="1" zero-terminated="0" c:type="void*" gs:is-pointer="1">
              <type name="guint8" />
            </array>
          </parameter>
          <parameter name="count" transfer-ownership="none" gs:managed-name="count" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30357">the number of bytes to write</doc>
            <type name="gsize" c:type="gsize" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30358">optional cancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="buffer" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="buffer" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30356">the buffer containing the data to write.</doc>
            <array length="1" zero-terminated="0" c:type="void*" gs:is-pointer="1">
              <type name="guint8" />
            </array>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30358">optional cancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="writev_async" invoker="writev_async" version="2.60" gs:dll-name="gio-2.0" gs:managed-name="DoWritevAsync">
        <doc xml:space="preserve" filename="gio-2.0.c" line="30726">Request an asynchronous write of the bytes contained in @n_vectors @vectors into
the stream. When the operation is finished @callback will be called.
You can then call g_output_stream_writev_finish() to get the result of the
operation.

During an async request no other sync and async calls are allowed,
and will result in %G_IO_ERROR_PENDING errors.

On success, the number of bytes written will be passed to the
@callback. It is not an error if this is not the same as the
requested size, as it can happen e.g. on a partial I/O error,
but generally we try to write as many bytes as requested.

You are guaranteed that this method will never fail with
%G_IO_ERROR_WOULD_BLOCK — if @stream can't accept more data, the
method will just wait until this changes.

Any outstanding I/O request with higher priority (lower numerical
value) will be executed before an outstanding request with lower
priority. Default priority is %G_PRIORITY_DEFAULT.

The asynchronous methods have a default fallback that uses threads
to implement asynchronicity, so they are optional for inheriting
classes. However, if you override one you must override all.

For the synchronous, blocking version of this function, see
g_output_stream_writev().

Note that no copy of @vectors will be made, so it must stay valid
until @callback is called.</doc>
        <source-position filename="goutputstream.h" line="129" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30728">A #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="vectors" transfer-ownership="none" gs:managed-name="vectors" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30729">the buffer containing the #GOutputVectors to write.</doc>
            <array length="1" zero-terminated="0" c:type="const GOutputVector*" gs:is-pointer="1">
              <type name="OutputVector" c:type="GOutputVector" />
            </array>
          </parameter>
          <parameter name="n_vectors" transfer-ownership="none" gs:managed-name="nVectors" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30730">the number of vectors to write</doc>
            <type name="gsize" c:type="gsize" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30731">the I/O priority of the request.</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30732">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30733">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="5" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30734">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="vectors" transfer-ownership="none" gs:managed-name="vectors" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30729">the buffer containing the #GOutputVectors to write.</doc>
            <array length="1" zero-terminated="0" c:type="const GOutputVector*" gs:is-pointer="1">
              <type name="OutputVector" c:type="GOutputVector" />
            </array>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30731">the I/O priority of the request.</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30733">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30732">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="writev_finish" invoker="writev_finish" version="2.60" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoWritevFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="30771">Finishes a stream writev operation.</doc>
        <source-position filename="goutputstream.h" line="137" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="30781">%TRUE on success, %FALSE if there was an error</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30773">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30774">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <parameter name="bytes_written" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="bytesWritten">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30775">location to store the number of bytes that were written to the stream</doc>
            <type name="gsize" c:type="gsize*" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30774">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <parameter name="bytes_written" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="bytesWritten">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30775">location to store the number of bytes that were written to the stream</doc>
            <type name="gsize" c:type="gsize*" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="writev_fn" invoker="writev" version="2.60" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoWritevFn">
        <doc xml:space="preserve" filename="gio-2.0.c" line="30595">Tries to write the bytes contained in the @n_vectors @vectors into the
stream. Will block during the operation.

If @n_vectors is 0 or the sum of all bytes in @vectors is 0, returns 0 and
does nothing.

On success, the number of bytes written to the stream is returned.
It is not an error if this is not the same as the requested size, as it
can happen e.g. on a partial I/O error, or if there is not enough
storage in the stream. All writes block until at least one byte
is written or an error occurs; 0 is never returned (unless
@n_vectors is 0 or the sum of all bytes in @vectors is 0).

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
operation was partially finished when the operation was cancelled the
partial result will be returned, without an error.

Some implementations of g_output_stream_writev() may have limitations on the
aggregate buffer size, and will return %G_IO_ERROR_INVALID_ARGUMENT if these
are exceeded. For example, when writing to a local file on UNIX platforms,
the aggregate buffer size must not exceed %G_MAXSSIZE bytes.</doc>
        <source-position filename="goutputstream.h" line="122" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="30629">%TRUE on success, %FALSE if there was an error</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30597">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="vectors" transfer-ownership="none" gs:managed-name="vectors" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30598">the buffer containing the #GOutputVectors to write.</doc>
            <array length="1" zero-terminated="0" c:type="const GOutputVector*" gs:is-pointer="1">
              <type name="OutputVector" c:type="GOutputVector" />
            </array>
          </parameter>
          <parameter name="n_vectors" transfer-ownership="none" gs:managed-name="nVectors" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30599">the number of vectors to write</doc>
            <type name="gsize" c:type="gsize" />
          </parameter>
          <parameter name="bytes_written" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="bytesWritten">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30600">location to store the number of bytes that were
    written to the stream</doc>
            <type name="gsize" c:type="gsize*" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30602">optional cancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="vectors" transfer-ownership="none" gs:managed-name="vectors" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30598">the buffer containing the #GOutputVectors to write.</doc>
            <array length="1" zero-terminated="0" c:type="const GOutputVector*" gs:is-pointer="1">
              <type name="OutputVector" c:type="GOutputVector" />
            </array>
          </parameter>
          <parameter name="bytes_written" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="bytesWritten">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30600">location to store the number of bytes that were
    written to the stream</doc>
            <type name="gsize" c:type="gsize*" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30602">optional cancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <method name="clear_pending" c:identifier="g_output_stream_clear_pending" gs:dll-name="gio-2.0" gs:managed-name="ClearPending">
        <doc xml:space="preserve" filename="gio-2.0.c" line="30061">Clears the pending flag on @stream.</doc>
        <source-position filename="goutputstream.h" line="327" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30063">output stream</doc>
            <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="close" c:identifier="g_output_stream_close" throws="1" gs:dll-name="gio-2.0" gs:managed-name="Close">
        <doc xml:space="preserve" filename="gio-2.0.c" line="30069">Closes the stream, releasing resources related to it.

Once the stream is closed, all other operations will return %G_IO_ERROR_CLOSED.
Closing a stream multiple times will not return an error.

Closing a stream will automatically flush any outstanding buffers in the
stream.

Streams will be automatically closed when the last reference
is dropped, but you might want to call this function to make sure
resources are released as early as possible.

Some streams might keep the backing store of the stream (e.g. a file descriptor)
open after the stream is closed. See the documentation for the individual
stream for details.

On failure the first error that happened will be reported, but the close
operation will finish as much as possible. A stream that failed to
close will still return %G_IO_ERROR_CLOSED for all operations. Still, it
is important to check and report the error to the user, otherwise
there might be a loss of data as all data might not be written.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
Cancelling a close will still leave the stream closed, but there some streams
can use a faster close that doesn't block to e.g. check errors. On
cancellation (as with any error) there is no guarantee that all written
data will reach the target.</doc>
        <source-position filename="goutputstream.h" line="213" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="30105">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30071">A #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30072">optional cancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30072">optional cancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="close_async" c:identifier="g_output_stream_close_async" gs:dll-name="gio-2.0" gs:managed-name="CloseAsync" gs:async="1" gs:async-finish="CloseFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="30109">Requests an asynchronous close of the stream, releasing resources
related to it. When the operation is finished @callback will be
called. You can then call g_output_stream_close_finish() to get
the result of the operation.

For behaviour details see g_output_stream_close().

The asynchronous methods have a default fallback that uses threads
to implement asynchronicity, so they are optional for inheriting
classes. However, if you override one you must override all.</doc>
        <source-position filename="goutputstream.h" line="307" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Threading.Tasks.Task" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30111">A #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30112">the io priority of the request.</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30113">optional cancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30114">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30115">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30112">the io priority of the request.</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30113">optional cancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="close_finish" c:identifier="g_output_stream_close_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="CloseFinish" gs:pinvoke-only="1" gs:finish-for="close_async">
        <doc xml:space="preserve" filename="gio-2.0.c" line="30130">Closes an output stream.</doc>
        <source-position filename="goutputstream.h" line="313" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="30139">%TRUE if stream was successfully closed, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30132">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30133">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30133">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="flush" c:identifier="g_output_stream_flush" throws="1" gs:dll-name="gio-2.0" gs:managed-name="Flush">
        <doc xml:space="preserve" filename="gio-2.0.c" line="30143">Forces a write of all user-space buffered data for the given
@stream. Will block during the operation. Closing the stream will
implicitly cause a flush.

This function is optional for inherited classes.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <source-position filename="goutputstream.h" line="209" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="30159">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30145">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30146">optional cancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30146">optional cancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="flush_async" c:identifier="g_output_stream_flush_async" gs:dll-name="gio-2.0" gs:managed-name="FlushAsync" gs:async="1" gs:async-finish="FlushFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="30163">Forces an asynchronous write of all user-space buffered data for
the given @stream.
For behaviour details see g_output_stream_flush().

When the operation is finished @callback will be
called. You can then call g_output_stream_flush_finish() to get the
result of the operation.</doc>
        <source-position filename="goutputstream.h" line="297" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Threading.Tasks.Task" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30165">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30166">the io priority of the request.</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30167">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30168">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30169">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30166">the io priority of the request.</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30167">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="flush_finish" c:identifier="g_output_stream_flush_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="FlushFinish" gs:pinvoke-only="1" gs:finish-for="flush_async">
        <doc xml:space="preserve" filename="gio-2.0.c" line="30181">Finishes flushing an output stream.</doc>
        <source-position filename="goutputstream.h" line="303" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="30190">%TRUE if flush operation succeeded, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30183">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30184">a GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30184">a GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="has_pending" c:identifier="g_output_stream_has_pending" gs:dll-name="gio-2.0" gs:managed-name="HasPending">
        <doc xml:space="preserve" filename="gio-2.0.c" line="30194">Checks if an output stream has pending actions.</doc>
        <source-position filename="goutputstream.h" line="322" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="30200">%TRUE if @stream has pending actions.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30196">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="is_closed" gs:dll-name="gio-2.0" gs:managed-name="IsClosed">
        <doc xml:space="preserve" filename="gio-2.0.c" line="30204">Checks if an output stream has already been closed.</doc>
        <source-position filename="goutputstream.h" line="318" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="30210">%TRUE if @stream is closed. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30206">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="is_closed" c:identifier="g_output_stream_is_closed" gs:dll-name="gio-2.0" gs:managed-name="GetIsClosed" gs:property-getter-for="IsClosed" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="30204">Checks if an output stream has already been closed.</doc>
        <source-position filename="goutputstream.h" line="318" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="30210">%TRUE if @stream is closed. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30206">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="is_closing" version="2.24" gs:dll-name="gio-2.0" gs:managed-name="IsClosing">
        <doc xml:space="preserve" filename="gio-2.0.c" line="30214">Checks if an output stream is being closed. This can be
used inside e.g. a flush implementation to see if the
flush (or other i/o operation) is called from within
the closing operation.</doc>
        <source-position filename="goutputstream.h" line="320" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="30223">%TRUE if @stream is being closed. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30216">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="is_closing" c:identifier="g_output_stream_is_closing" version="2.24" gs:dll-name="gio-2.0" gs:managed-name="GetIsClosing" gs:property-getter-for="IsClosing" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="30214">Checks if an output stream is being closed. This can be
used inside e.g. a flush implementation to see if the
flush (or other i/o operation) is called from within
the closing operation.</doc>
        <source-position filename="goutputstream.h" line="320" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="30223">%TRUE if @stream is being closed. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30216">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="set_pending" c:identifier="g_output_stream_set_pending" throws="1" gs:dll-name="gio-2.0" gs:managed-name="SetPending">
        <doc xml:space="preserve" filename="gio-2.0.c" line="30256">Sets @stream to have actions pending. If the pending flag is
already set or @stream is closed, it will return %FALSE and set
@error.</doc>
        <source-position filename="goutputstream.h" line="324" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="30266">%TRUE if pending was previously unset and is now set.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30258">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="splice" c:identifier="g_output_stream_splice" throws="1" gs:dll-name="gio-2.0" gs:managed-name="Splice">
        <doc xml:space="preserve" filename="gio-2.0.c" line="30270">Splices an input stream into an output stream.</doc>
        <source-position filename="goutputstream.h" line="203" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="30281">a #gssize containing the size of the data spliced, or
    -1 if an error occurred. Note that if the number of bytes
    spliced is greater than %G_MAXSSIZE, then that will be
    returned, and there is no way to determine the actual number
    of bytes spliced.</doc>
          <type name="gssize" c:type="gssize" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30272">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30273">a #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30274">a set of #GOutputStreamSpliceFlags.</doc>
            <type name="OutputStreamSpliceFlags" c:type="GOutputStreamSpliceFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30275">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30273">a #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30274">a set of #GOutputStreamSpliceFlags.</doc>
            <type name="OutputStreamSpliceFlags" c:type="GOutputStreamSpliceFlags" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30275">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="splice_async" c:identifier="g_output_stream_splice_async" gs:dll-name="gio-2.0" gs:managed-name="SpliceAsync" gs:async="1" gs:async-finish="SpliceFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="30289">Splices a stream asynchronously.
When the operation is finished @callback will be called.
You can then call g_output_stream_splice_finish() to get the
result of the operation.

For the synchronous, blocking version of this function, see
g_output_stream_splice().</doc>
        <source-position filename="goutputstream.h" line="285" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Threading.Tasks.Task">
            <type name="gssize" c:type="gssize" />
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30291">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30292">a #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30293">a set of #GOutputStreamSpliceFlags.</doc>
            <type name="OutputStreamSpliceFlags" c:type="GOutputStreamSpliceFlags" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30294">the io priority of the request.</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30295">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30296">a #GAsyncReadyCallback.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30297">user data passed to @callback.</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30292">a #GInputStream.</doc>
            <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30293">a set of #GOutputStreamSpliceFlags.</doc>
            <type name="OutputStreamSpliceFlags" c:type="GOutputStreamSpliceFlags" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30294">the io priority of the request.</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30295">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="splice_finish" c:identifier="g_output_stream_splice_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="SpliceFinish" gs:pinvoke-only="1" gs:finish-for="splice_async">
        <doc xml:space="preserve" filename="gio-2.0.c" line="30309">Finishes an asynchronous stream splice operation.</doc>
        <source-position filename="goutputstream.h" line="293" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="30318">a #gssize of the number of bytes spliced. Note that if the
    number of bytes spliced is greater than %G_MAXSSIZE, then that
    will be returned, and there is no way to determine the actual
    number of bytes spliced.</doc>
          <type name="gssize" c:type="gssize" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30311">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30312">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30312">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="write" c:identifier="g_output_stream_write" throws="1" gs:dll-name="gio-2.0" gs:managed-name="Write">
        <doc xml:space="preserve" filename="gio-2.0.c" line="30353">Tries to write @count bytes from @buffer into the stream. Will block
during the operation.

If count is 0, returns 0 and does nothing. A value of @count
larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.

On success, the number of bytes written to the stream is returned.
It is not an error if this is not the same as the requested size, as it
can happen e.g. on a partial I/O error, or if there is not enough
storage in the stream. All writes block until at least one byte
is written or an error occurs; 0 is never returned (unless
@count is 0).

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
operation was partially finished when the operation was cancelled the
partial result will be returned, without an error.

On error -1 is returned and @error is set accordingly.</doc>
        <source-position filename="goutputstream.h" line="155" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="30382">Number of bytes written, or -1 on error</doc>
          <type name="gssize" c:type="gssize" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30355">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none" gs:managed-name="buffer" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30356">the buffer containing the data to write.</doc>
            <array length="1" zero-terminated="0" c:type="void*" gs:is-pointer="1">
              <type name="guint8" />
            </array>
          </parameter>
          <parameter name="count" transfer-ownership="none" gs:managed-name="count" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30357">the number of bytes to write</doc>
            <type name="gsize" c:type="gsize" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30358">optional cancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="buffer" transfer-ownership="none" gs:managed-name="buffer" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30356">the buffer containing the data to write.</doc>
            <array length="1" zero-terminated="0" c:type="void*" gs:is-pointer="1">
              <type name="guint8" />
            </array>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30358">optional cancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="write_all" c:identifier="g_output_stream_write_all" throws="1" gs:dll-name="gio-2.0" gs:managed-name="WriteAll">
        <doc xml:space="preserve" filename="gio-2.0.c" line="30386">Tries to write @count bytes from @buffer into the stream. Will block
during the operation.

This function is similar to g_output_stream_write(), except it tries to
write as many bytes as requested, only stopping on an error.

On a successful write of @count bytes, %TRUE is returned, and @bytes_written
is set to @count.

If there is an error during the operation %FALSE is returned and @error
is set to indicate the error status.

As a special exception to the normal conventions for functions that
use #GError, if this function returns %FALSE (and sets @error) then
@bytes_written will be set to the number of bytes that were
successfully written before the error was encountered.  This
functionality is only available from C.  If you need it from another
language then you must write your own loop around
g_output_stream_write().</doc>
        <source-position filename="goutputstream.h" line="161" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="30416">%TRUE on success, %FALSE if there was an error</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30388">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none" gs:managed-name="buffer" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30389">the buffer containing the data to write.</doc>
            <array length="1" zero-terminated="0" c:type="void*" gs:is-pointer="1">
              <type name="guint8" />
            </array>
          </parameter>
          <parameter name="count" transfer-ownership="none" gs:managed-name="count" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30390">the number of bytes to write</doc>
            <type name="gsize" c:type="gsize" />
          </parameter>
          <parameter name="bytes_written" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="bytesWritten">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30391">location to store the number of bytes that was
    written to the stream</doc>
            <type name="gsize" c:type="gsize*" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30393">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="buffer" transfer-ownership="none" gs:managed-name="buffer" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30389">the buffer containing the data to write.</doc>
            <array length="1" zero-terminated="0" c:type="void*" gs:is-pointer="1">
              <type name="guint8" />
            </array>
          </parameter>
          <parameter name="bytes_written" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="bytesWritten">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30391">location to store the number of bytes that was
    written to the stream</doc>
            <type name="gsize" c:type="gsize*" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30393">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="write_all_async" c:identifier="g_output_stream_write_all_async" version="2.44" gs:dll-name="gio-2.0" gs:managed-name="WriteAllAsync" gs:async="1" gs:async-finish="WriteAllFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="30420">Request an asynchronous write of @count bytes from @buffer into
the stream. When the operation is finished @callback will be called.
You can then call g_output_stream_write_all_finish() to get the result of the
operation.

This is the asynchronous version of g_output_stream_write_all().

Call g_output_stream_write_all_finish() to collect the result.

Any outstanding I/O request with higher priority (lower numerical
value) will be executed before an outstanding request with lower
priority. Default priority is %G_PRIORITY_DEFAULT.

Note that no copy of @buffer will be made, so it must stay valid
until @callback is called.</doc>
        <source-position filename="goutputstream.h" line="230" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Threading.Tasks.Task">
            <type name="gsize" c:type="gsize*" />
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30422">A #GOutputStream</doc>
            <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none" gs:managed-name="buffer" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30423">the buffer containing the data to write</doc>
            <array length="1" zero-terminated="0" c:type="void*" gs:is-pointer="1">
              <type name="guint8" />
            </array>
          </parameter>
          <parameter name="count" transfer-ownership="none" gs:managed-name="count" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30424">the number of bytes to write</doc>
            <type name="gsize" c:type="gsize" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30425">the io priority of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30426">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30427">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30428">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="buffer" transfer-ownership="none" gs:managed-name="buffer" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30423">the buffer containing the data to write</doc>
            <array length="1" zero-terminated="0" c:type="void*" gs:is-pointer="1">
              <type name="guint8" />
            </array>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30425">the io priority of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30426">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="write_all_finish" c:identifier="g_output_stream_write_all_finish" version="2.44" throws="1" gs:dll-name="gio-2.0" gs:managed-name="WriteAllFinish" gs:pinvoke-only="1" gs:finish-for="write_all_async">
        <doc xml:space="preserve" filename="gio-2.0.c" line="30450">Finishes an asynchronous stream write operation started with
g_output_stream_write_all_async().

As a special exception to the normal conventions for functions that
use #GError, if this function returns %FALSE (and sets @error) then
@bytes_written will be set to the number of bytes that were
successfully written before the error was encountered.  This
functionality is only available from C.  If you need it from another
language then you must write your own loop around
g_output_stream_write_async().</doc>
        <source-position filename="goutputstream.h" line="239" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="30468">%TRUE on success, %FALSE if there was an error</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30452">a #GOutputStream</doc>
            <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30453">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <parameter name="bytes_written" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="bytesWritten">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30454">location to store the number of bytes that was written to the stream</doc>
            <type name="gsize" c:type="gsize*" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30453">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <parameter name="bytes_written" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="bytesWritten">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30454">location to store the number of bytes that was written to the stream</doc>
            <type name="gsize" c:type="gsize*" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="write_async" c:identifier="g_output_stream_write_async" gs:dll-name="gio-2.0" gs:managed-name="WriteAsync" gs:async="1" gs:async-finish="WriteFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="30473">Request an asynchronous write of @count bytes from @buffer into
the stream. When the operation is finished @callback will be called.
You can then call g_output_stream_write_finish() to get the result of the
operation.

During an async request no other sync and async calls are allowed,
and will result in %G_IO_ERROR_PENDING errors.

A value of @count larger than %G_MAXSSIZE will cause a
%G_IO_ERROR_INVALID_ARGUMENT error.

On success, the number of bytes written will be passed to the
@callback. It is not an error if this is not the same as the
requested size, as it can happen e.g. on a partial I/O error,
but generally we try to write as many bytes as requested.

You are guaranteed that this method will never fail with
%G_IO_ERROR_WOULD_BLOCK - if @stream can't accept more data, the
method will just wait until this changes.

Any outstanding I/O request with higher priority (lower numerical
value) will be executed before an outstanding request with lower
priority. Default priority is %G_PRIORITY_DEFAULT.

The asynchronous methods have a default fallback that uses threads
to implement asynchronicity, so they are optional for inheriting
classes. However, if you override one you must override all.

For the synchronous, blocking version of this function, see
g_output_stream_write().

Note that no copy of @buffer will be made, so it must stay valid
until @callback is called. See g_output_stream_write_bytes_async()
for a #GBytes version that will automatically hold a reference to
the contents (without copying) for the duration of the call.</doc>
        <source-position filename="goutputstream.h" line="217" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Threading.Tasks.Task">
            <type name="gssize" c:type="gssize" />
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30475">A #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none" gs:managed-name="buffer" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30476">the buffer containing the data to write.</doc>
            <array length="1" zero-terminated="0" c:type="void*" gs:is-pointer="1">
              <type name="guint8" />
            </array>
          </parameter>
          <parameter name="count" transfer-ownership="none" gs:managed-name="count" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30477">the number of bytes to write</doc>
            <type name="gsize" c:type="gsize" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30478">the io priority of the request.</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30479">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30480">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30481">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="buffer" transfer-ownership="none" gs:managed-name="buffer" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30476">the buffer containing the data to write.</doc>
            <array length="1" zero-terminated="0" c:type="void*" gs:is-pointer="1">
              <type name="guint8" />
            </array>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30478">the io priority of the request.</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30479">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="write_bytes" c:identifier="g_output_stream_write_bytes" throws="1" gs:dll-name="gio-2.0" gs:managed-name="WriteBytes">
        <doc xml:space="preserve" filename="gio-2.0.c" line="30521">A wrapper function for g_output_stream_write() which takes a
#GBytes as input.  This can be more convenient for use by language
bindings or in other cases where the refcounted nature of #GBytes
is helpful over a bare pointer interface.

However, note that this function may still perform partial writes,
just like g_output_stream_write().  If that occurs, to continue
writing, you will need to create a new #GBytes containing just the
remaining bytes, using g_bytes_new_from_bytes(). Passing the same
#GBytes instance multiple times potentially can result in duplicated
data in the output stream.</doc>
        <source-position filename="goutputstream.h" line="198" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="30540">Number of bytes written, or -1 on error</doc>
          <type name="gssize" c:type="gssize" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30523">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="bytes" transfer-ownership="none" gs:managed-name="bytes" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30524">the #GBytes to write</doc>
            <type name="GLib.Bytes" c:type="GBytes*" gs:is-pointer="1" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30525">optional cancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="bytes" transfer-ownership="none" gs:managed-name="bytes" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30524">the #GBytes to write</doc>
            <type name="GLib.Bytes" c:type="GBytes*" gs:is-pointer="1" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30525">optional cancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="write_bytes_async" c:identifier="g_output_stream_write_bytes_async" gs:dll-name="gio-2.0" gs:managed-name="WriteBytesAsync" gs:async="1" gs:async-finish="WriteBytesFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="30544">This function is similar to g_output_stream_write_async(), but
takes a #GBytes as input.  Due to the refcounted nature of #GBytes,
this allows the stream to avoid taking a copy of the data.

However, note that this function may still perform partial writes,
just like g_output_stream_write_async(). If that occurs, to continue
writing, you will need to create a new #GBytes containing just the
remaining bytes, using g_bytes_new_from_bytes(). Passing the same
#GBytes instance multiple times potentially can result in duplicated
data in the output stream.

For the synchronous, blocking version of this function, see
g_output_stream_write_bytes().</doc>
        <source-position filename="goutputstream.h" line="274" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Threading.Tasks.Task">
            <type name="gssize" c:type="gssize" />
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30546">A #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="bytes" transfer-ownership="none" gs:managed-name="bytes" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30547">The bytes to write</doc>
            <type name="GLib.Bytes" c:type="GBytes*" gs:is-pointer="1" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30548">the io priority of the request.</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30549">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30550">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30551">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="bytes" transfer-ownership="none" gs:managed-name="bytes" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30547">The bytes to write</doc>
            <type name="GLib.Bytes" c:type="GBytes*" gs:is-pointer="1" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30548">the io priority of the request.</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30549">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="write_bytes_finish" c:identifier="g_output_stream_write_bytes_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="WriteBytesFinish" gs:pinvoke-only="1" gs:finish-for="write_bytes_async">
        <doc xml:space="preserve" filename="gio-2.0.c" line="30569">Finishes a stream write-from-#GBytes operation.</doc>
        <source-position filename="goutputstream.h" line="281" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="30578">a #gssize containing the number of bytes written to the stream.</doc>
          <type name="gssize" c:type="gssize" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30571">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30572">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30572">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="write_finish" c:identifier="g_output_stream_write_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="WriteFinish" gs:pinvoke-only="1" gs:finish-for="write_async">
        <doc xml:space="preserve" filename="gio-2.0.c" line="30582">Finishes a stream write operation.</doc>
        <source-position filename="goutputstream.h" line="225" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="30591">a #gssize containing the number of bytes written to the stream.</doc>
          <type name="gssize" c:type="gssize" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30584">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30585">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30585">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="writev" c:identifier="g_output_stream_writev" version="2.60" throws="1" gs:dll-name="gio-2.0" gs:managed-name="Writev">
        <doc xml:space="preserve" filename="gio-2.0.c" line="30595">Tries to write the bytes contained in the @n_vectors @vectors into the
stream. Will block during the operation.

If @n_vectors is 0 or the sum of all bytes in @vectors is 0, returns 0 and
does nothing.

On success, the number of bytes written to the stream is returned.
It is not an error if this is not the same as the requested size, as it
can happen e.g. on a partial I/O error, or if there is not enough
storage in the stream. All writes block until at least one byte
is written or an error occurs; 0 is never returned (unless
@n_vectors is 0 or the sum of all bytes in @vectors is 0).

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
operation was partially finished when the operation was cancelled the
partial result will be returned, without an error.

Some implementations of g_output_stream_writev() may have limitations on the
aggregate buffer size, and will return %G_IO_ERROR_INVALID_ARGUMENT if these
are exceeded. For example, when writing to a local file on UNIX platforms,
the aggregate buffer size must not exceed %G_MAXSSIZE bytes.</doc>
        <source-position filename="goutputstream.h" line="169" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="30629">%TRUE on success, %FALSE if there was an error</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30597">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="vectors" transfer-ownership="none" gs:managed-name="vectors" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30598">the buffer containing the #GOutputVectors to write.</doc>
            <array length="1" zero-terminated="0" c:type="const GOutputVector*" gs:is-pointer="1">
              <type name="OutputVector" c:type="GOutputVector" />
            </array>
          </parameter>
          <parameter name="n_vectors" transfer-ownership="none" gs:managed-name="nVectors" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30599">the number of vectors to write</doc>
            <type name="gsize" c:type="gsize" />
          </parameter>
          <parameter name="bytes_written" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="bytesWritten">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30600">location to store the number of bytes that were
    written to the stream</doc>
            <type name="gsize" c:type="gsize*" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30602">optional cancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="vectors" transfer-ownership="none" gs:managed-name="vectors" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30598">the buffer containing the #GOutputVectors to write.</doc>
            <array length="1" zero-terminated="0" c:type="const GOutputVector*" gs:is-pointer="1">
              <type name="OutputVector" c:type="GOutputVector" />
            </array>
          </parameter>
          <parameter name="bytes_written" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="bytesWritten">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30600">location to store the number of bytes that were
    written to the stream</doc>
            <type name="gsize" c:type="gsize*" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30602">optional cancellable object</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="writev_all" c:identifier="g_output_stream_writev_all" version="2.60" throws="1" gs:dll-name="gio-2.0" gs:managed-name="WritevAll">
        <doc xml:space="preserve" filename="gio-2.0.c" line="30634">Tries to write the bytes contained in the @n_vectors @vectors into the
stream. Will block during the operation.

This function is similar to g_output_stream_writev(), except it tries to
write as many bytes as requested, only stopping on an error.

On a successful write of all @n_vectors vectors, %TRUE is returned, and
@bytes_written is set to the sum of all the sizes of @vectors.

If there is an error during the operation %FALSE is returned and @error
is set to indicate the error status.

As a special exception to the normal conventions for functions that
use #GError, if this function returns %FALSE (and sets @error) then
@bytes_written will be set to the number of bytes that were
successfully written before the error was encountered.  This
functionality is only available from C. If you need it from another
language then you must write your own loop around
g_output_stream_write().

The content of the individual elements of @vectors might be changed by this
function.</doc>
        <source-position filename="goutputstream.h" line="176" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="30667">%TRUE on success, %FALSE if there was an error</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30636">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="vectors" transfer-ownership="none" gs:managed-name="vectors" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30637">the buffer containing the #GOutputVectors to write.</doc>
            <array length="1" zero-terminated="0" c:type="GOutputVector*" gs:is-pointer="1">
              <type name="OutputVector" c:type="GOutputVector" />
            </array>
          </parameter>
          <parameter name="n_vectors" transfer-ownership="none" gs:managed-name="nVectors" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30638">the number of vectors to write</doc>
            <type name="gsize" c:type="gsize" />
          </parameter>
          <parameter name="bytes_written" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="bytesWritten">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30639">location to store the number of bytes that were
    written to the stream</doc>
            <type name="gsize" c:type="gsize*" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30641">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="vectors" transfer-ownership="none" gs:managed-name="vectors" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30637">the buffer containing the #GOutputVectors to write.</doc>
            <array length="1" zero-terminated="0" c:type="GOutputVector*" gs:is-pointer="1">
              <type name="OutputVector" c:type="GOutputVector" />
            </array>
          </parameter>
          <parameter name="bytes_written" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="bytesWritten">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30639">location to store the number of bytes that were
    written to the stream</doc>
            <type name="gsize" c:type="gsize*" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30641">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="writev_all_async" c:identifier="g_output_stream_writev_all_async" version="2.60" gs:dll-name="gio-2.0" gs:managed-name="WritevAllAsync" gs:async="1" gs:async-finish="WritevAllFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="30672">Request an asynchronous write of the bytes contained in the @n_vectors @vectors into
the stream. When the operation is finished @callback will be called.
You can then call g_output_stream_writev_all_finish() to get the result of the
operation.

This is the asynchronous version of g_output_stream_writev_all().

Call g_output_stream_writev_all_finish() to collect the result.

Any outstanding I/O request with higher priority (lower numerical
value) will be executed before an outstanding request with lower
priority. Default priority is %G_PRIORITY_DEFAULT.

Note that no copy of @vectors will be made, so it must stay valid
until @callback is called. The content of the individual elements
of @vectors might be changed by this function.</doc>
        <source-position filename="goutputstream.h" line="259" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Threading.Tasks.Task">
            <type name="gsize" c:type="gsize*" />
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30674">A #GOutputStream</doc>
            <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="vectors" transfer-ownership="none" gs:managed-name="vectors" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30675">the buffer containing the #GOutputVectors to write.</doc>
            <array length="1" zero-terminated="0" c:type="GOutputVector*" gs:is-pointer="1">
              <type name="OutputVector" c:type="GOutputVector" />
            </array>
          </parameter>
          <parameter name="n_vectors" transfer-ownership="none" gs:managed-name="nVectors" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30676">the number of vectors to write</doc>
            <type name="gsize" c:type="gsize" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30677">the I/O priority of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30678">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30679">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30680">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="vectors" transfer-ownership="none" gs:managed-name="vectors" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30675">the buffer containing the #GOutputVectors to write.</doc>
            <array length="1" zero-terminated="0" c:type="GOutputVector*" gs:is-pointer="1">
              <type name="OutputVector" c:type="GOutputVector" />
            </array>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30677">the I/O priority of the request</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30678">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="writev_all_finish" c:identifier="g_output_stream_writev_all_finish" version="2.60" throws="1" gs:dll-name="gio-2.0" gs:managed-name="WritevAllFinish" gs:pinvoke-only="1" gs:finish-for="writev_all_async">
        <doc xml:space="preserve" filename="gio-2.0.c" line="30703">Finishes an asynchronous stream write operation started with
g_output_stream_writev_all_async().

As a special exception to the normal conventions for functions that
use #GError, if this function returns %FALSE (and sets @error) then
@bytes_written will be set to the number of bytes that were
successfully written before the error was encountered.  This
functionality is only available from C.  If you need it from another
language then you must write your own loop around
g_output_stream_writev_async().</doc>
        <source-position filename="goutputstream.h" line="268" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="30721">%TRUE on success, %FALSE if there was an error</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30705">a #GOutputStream</doc>
            <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30706">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <parameter name="bytes_written" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="bytesWritten">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30707">location to store the number of bytes that were written to the stream</doc>
            <type name="gsize" c:type="gsize*" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30706">a #GAsyncResult</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <parameter name="bytes_written" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="bytesWritten">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30707">location to store the number of bytes that were written to the stream</doc>
            <type name="gsize" c:type="gsize*" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="writev_async" c:identifier="g_output_stream_writev_async" version="2.60" gs:dll-name="gio-2.0" gs:managed-name="WritevAsync" gs:async="1" gs:async-finish="WritevFinish">
        <doc xml:space="preserve" filename="gio-2.0.c" line="30726">Request an asynchronous write of the bytes contained in @n_vectors @vectors into
the stream. When the operation is finished @callback will be called.
You can then call g_output_stream_writev_finish() to get the result of the
operation.

During an async request no other sync and async calls are allowed,
and will result in %G_IO_ERROR_PENDING errors.

On success, the number of bytes written will be passed to the
@callback. It is not an error if this is not the same as the
requested size, as it can happen e.g. on a partial I/O error,
but generally we try to write as many bytes as requested.

You are guaranteed that this method will never fail with
%G_IO_ERROR_WOULD_BLOCK — if @stream can't accept more data, the
method will just wait until this changes.

Any outstanding I/O request with higher priority (lower numerical
value) will be executed before an outstanding request with lower
priority. Default priority is %G_PRIORITY_DEFAULT.

The asynchronous methods have a default fallback that uses threads
to implement asynchronicity, so they are optional for inheriting
classes. However, if you override one you must override all.

For the synchronous, blocking version of this function, see
g_output_stream_writev().

Note that no copy of @vectors will be made, so it must stay valid
until @callback is called.</doc>
        <source-position filename="goutputstream.h" line="245" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Threading.Tasks.Task">
            <type name="gsize" c:type="gsize*" />
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30728">A #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="vectors" transfer-ownership="none" gs:managed-name="vectors" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30729">the buffer containing the #GOutputVectors to write.</doc>
            <array length="1" zero-terminated="0" c:type="const GOutputVector*" gs:is-pointer="1">
              <type name="OutputVector" c:type="GOutputVector" />
            </array>
          </parameter>
          <parameter name="n_vectors" transfer-ownership="none" gs:managed-name="nVectors" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30730">the number of vectors to write</doc>
            <type name="gsize" c:type="gsize" />
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30731">the I/O priority of the request.</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30732">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30733">callback to call when the request is satisfied</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30734">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="vectors" transfer-ownership="none" gs:managed-name="vectors" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30729">the buffer containing the #GOutputVectors to write.</doc>
            <array length="1" zero-terminated="0" c:type="const GOutputVector*" gs:is-pointer="1">
              <type name="OutputVector" c:type="GOutputVector" />
            </array>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="ioPriority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30731">the I/O priority of the request.</doc>
            <type name="gint" c:type="int" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30732">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="writev_finish" c:identifier="g_output_stream_writev_finish" version="2.60" throws="1" gs:dll-name="gio-2.0" gs:managed-name="WritevFinish" gs:pinvoke-only="1" gs:finish-for="writev_async">
        <doc xml:space="preserve" filename="gio-2.0.c" line="30771">Finishes a stream writev operation.</doc>
        <source-position filename="goutputstream.h" line="253" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="30781">%TRUE on success, %FALSE if there was an error</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30773">a #GOutputStream.</doc>
            <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30774">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <parameter name="bytes_written" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="bytesWritten">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30775">location to store the number of bytes that were written to the stream</doc>
            <type name="gsize" c:type="gsize*" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30774">a #GAsyncResult.</doc>
            <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
          </parameter>
          <parameter name="bytes_written" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="bytesWritten">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30775">location to store the number of bytes that were written to the stream</doc>
            <type name="gsize" c:type="gsize*" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <field name="parent_instance" gs:managed-name="ParentInstance">
        <type name="GObject.Object" c:type="GObject" />
      </field>
      <field name="priv" readable="0" private="1" gs:managed-name="Priv">
        <type name="OutputStreamPrivate" c:type="GOutputStreamPrivate*" gs:is-pointer="1" />
      </field>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_output_stream_get_type" gs:access-modifiers="private" gs:dll-name="gio-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </class>
    <record name="OutputStreamClass" c:type="GOutputStreamClass" glib:is-gtype-struct-for="OutputStream" gs:managed-name="OutputStreamClass">
      <source-position filename="goutputstream.h" line="149" />
      <field name="parent_class" gs:managed-name="ParentClass">
        <type name="GObject.ObjectClass" c:type="GObjectClass" />
      </field>
      <field name="write_fn" gs:managed-name="WriteFn">
        <callback name="write_fn" throws="1" gs:dll-name="gio-2.0" gs:managed-name="WriteFn">
          <source-position filename="goutputstream.h" line="66" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30382">Number of bytes written, or -1 on error</doc>
            <type name="gssize" c:type="gssize" />
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30355">a #GOutputStream.</doc>
              <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="buffer" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="buffer" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30356">the buffer containing the data to write.</doc>
              <array length="2" zero-terminated="0" c:type="void*" gs:is-pointer="1">
                <type name="guint8" />
              </array>
            </parameter>
            <parameter name="count" transfer-ownership="none" gs:managed-name="count" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30357">the number of bytes to write</doc>
              <type name="gsize" c:type="gsize" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30358">optional cancellable object</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30355">a #GOutputStream.</doc>
              <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="buffer" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="buffer" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30356">the buffer containing the data to write.</doc>
              <array length="2" zero-terminated="0" c:type="void*" gs:is-pointer="1">
                <type name="guint8" />
              </array>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30358">optional cancellable object</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="splice" gs:managed-name="Splice">
        <callback name="splice" throws="1" gs:dll-name="gio-2.0" gs:managed-name="Splice">
          <source-position filename="goutputstream.h" line="71" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30281">a #gssize containing the size of the data spliced, or
    -1 if an error occurred. Note that if the number of bytes
    spliced is greater than %G_MAXSSIZE, then that will be
    returned, and there is no way to determine the actual number
    of bytes spliced.</doc>
            <type name="gssize" c:type="gssize" />
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30272">a #GOutputStream.</doc>
              <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30273">a #GInputStream.</doc>
              <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30274">a set of #GOutputStreamSpliceFlags.</doc>
              <type name="OutputStreamSpliceFlags" c:type="GOutputStreamSpliceFlags" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30275">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30272">a #GOutputStream.</doc>
              <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30273">a #GInputStream.</doc>
              <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30274">a set of #GOutputStreamSpliceFlags.</doc>
              <type name="OutputStreamSpliceFlags" c:type="GOutputStreamSpliceFlags" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30275">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="flush" gs:managed-name="Flush">
        <callback name="flush" throws="1" gs:dll-name="gio-2.0" gs:managed-name="Flush">
          <source-position filename="goutputstream.h" line="76" />
          <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30159">%TRUE on success, %FALSE on error</doc>
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30145">a #GOutputStream.</doc>
              <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30146">optional cancellable object</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30145">a #GOutputStream.</doc>
              <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30146">optional cancellable object</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="close_fn" gs:managed-name="CloseFn">
        <callback name="close_fn" throws="1" gs:dll-name="gio-2.0" gs:managed-name="CloseFn">
          <source-position filename="goutputstream.h" line="79" />
          <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="write_async" gs:managed-name="WriteAsync">
        <callback name="write_async" gs:dll-name="gio-2.0" gs:managed-name="WriteAsync">
          <source-position filename="goutputstream.h" line="85" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30475">A #GOutputStream.</doc>
              <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="buffer" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="buffer" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30476">the buffer containing the data to write.</doc>
              <array length="2" zero-terminated="0" c:type="void*" gs:is-pointer="1">
                <type name="guint8" />
              </array>
            </parameter>
            <parameter name="count" transfer-ownership="none" gs:managed-name="count" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30477">the number of bytes to write</doc>
              <type name="gsize" c:type="gsize" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30478">the io priority of the request.</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30479">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="6" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30480">callback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="6" gs:managed-name="userData" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30481">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30475">A #GOutputStream.</doc>
              <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="buffer" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="buffer" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30476">the buffer containing the data to write.</doc>
              <array length="2" zero-terminated="0" c:type="void*" gs:is-pointer="1">
                <type name="guint8" />
              </array>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30478">the io priority of the request.</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="6" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30480">callback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30479">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="write_finish" gs:managed-name="WriteFinish">
        <callback name="write_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="WriteFinish">
          <source-position filename="goutputstream.h" line="92" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30591">a #gssize containing the number of bytes written to the stream.</doc>
            <type name="gssize" c:type="gssize" />
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30584">a #GOutputStream.</doc>
              <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30585">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30584">a #GOutputStream.</doc>
              <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30585">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="splice_async" gs:managed-name="SpliceAsync">
        <callback name="splice_async" gs:dll-name="gio-2.0" gs:managed-name="SpliceAsync">
          <source-position filename="goutputstream.h" line="95" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30291">a #GOutputStream.</doc>
              <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30292">a #GInputStream.</doc>
              <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30293">a set of #GOutputStreamSpliceFlags.</doc>
              <type name="OutputStreamSpliceFlags" c:type="GOutputStreamSpliceFlags" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30294">the io priority of the request.</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30295">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="6" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30296">a #GAsyncReadyCallback.</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="6" gs:managed-name="userData" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30297">user data passed to @callback.</doc>
              <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30291">a #GOutputStream.</doc>
              <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30292">a #GInputStream.</doc>
              <type name="InputStream" c:type="GInputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30293">a set of #GOutputStreamSpliceFlags.</doc>
              <type name="OutputStreamSpliceFlags" c:type="GOutputStreamSpliceFlags" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30294">the io priority of the request.</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="6" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30296">a #GAsyncReadyCallback.</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30295">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="splice_finish" gs:managed-name="SpliceFinish">
        <callback name="splice_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="SpliceFinish">
          <source-position filename="goutputstream.h" line="102" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30318">a #gssize of the number of bytes spliced. Note that if the
    number of bytes spliced is greater than %G_MAXSSIZE, then that
    will be returned, and there is no way to determine the actual
    number of bytes spliced.</doc>
            <type name="gssize" c:type="gssize" />
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30311">a #GOutputStream.</doc>
              <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30312">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30311">a #GOutputStream.</doc>
              <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30312">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="flush_async" gs:managed-name="FlushAsync">
        <callback name="flush_async" gs:dll-name="gio-2.0" gs:managed-name="FlushAsync">
          <source-position filename="goutputstream.h" line="105" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30165">a #GOutputStream.</doc>
              <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30166">the io priority of the request.</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30167">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30168">a #GAsyncReadyCallback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4" gs:managed-name="userData" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30169">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30165">a #GOutputStream.</doc>
              <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30166">the io priority of the request.</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30168">a #GAsyncReadyCallback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30167">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="flush_finish" gs:managed-name="FlushFinish">
        <callback name="flush_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="FlushFinish">
          <source-position filename="goutputstream.h" line="110" />
          <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30190">%TRUE if flush operation succeeded, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30183">a #GOutputStream.</doc>
              <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30184">a GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30183">a #GOutputStream.</doc>
              <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30184">a GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="close_async" gs:managed-name="CloseAsync">
        <callback name="close_async" gs:dll-name="gio-2.0" gs:managed-name="CloseAsync">
          <source-position filename="goutputstream.h" line="113" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30111">A #GOutputStream.</doc>
              <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30112">the io priority of the request.</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30113">optional cancellable object</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30114">callback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4" gs:managed-name="userData" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30115">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30111">A #GOutputStream.</doc>
              <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30112">the io priority of the request.</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30114">callback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30113">optional cancellable object</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="close_finish" gs:managed-name="CloseFinish">
        <callback name="close_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="CloseFinish">
          <source-position filename="goutputstream.h" line="118" />
          <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30139">%TRUE if stream was successfully closed, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30132">a #GOutputStream.</doc>
              <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30133">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30132">a #GOutputStream.</doc>
              <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30133">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="writev_fn" gs:managed-name="WritevFn">
        <callback name="writev_fn" throws="1" gs:dll-name="gio-2.0" gs:managed-name="WritevFn">
          <source-position filename="goutputstream.h" line="122" />
          <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30629">%TRUE on success, %FALSE if there was an error</doc>
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30597">a #GOutputStream.</doc>
              <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="vectors" transfer-ownership="none" gs:managed-name="vectors" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30598">the buffer containing the #GOutputVectors to write.</doc>
              <array length="2" zero-terminated="0" c:type="const GOutputVector*" gs:is-pointer="1">
                <type name="OutputVector" c:type="GOutputVector" />
              </array>
            </parameter>
            <parameter name="n_vectors" transfer-ownership="none" gs:managed-name="nVectors" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30599">the number of vectors to write</doc>
              <type name="gsize" c:type="gsize" />
            </parameter>
            <parameter name="bytes_written" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="bytesWritten">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30600">location to store the number of bytes that were
    written to the stream</doc>
              <type name="gsize" c:type="gsize*" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30602">optional cancellable object</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30597">a #GOutputStream.</doc>
              <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="vectors" transfer-ownership="none" gs:managed-name="vectors" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30598">the buffer containing the #GOutputVectors to write.</doc>
              <array length="2" zero-terminated="0" c:type="const GOutputVector*" gs:is-pointer="1">
                <type name="OutputVector" c:type="GOutputVector" />
              </array>
            </parameter>
            <parameter name="bytes_written" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="bytesWritten">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30600">location to store the number of bytes that were
    written to the stream</doc>
              <type name="gsize" c:type="gsize*" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30602">optional cancellable object</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="writev_async" gs:managed-name="WritevAsync">
        <callback name="writev_async" gs:dll-name="gio-2.0" gs:managed-name="WritevAsync">
          <source-position filename="goutputstream.h" line="129" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" />
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30728">A #GOutputStream.</doc>
              <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="vectors" transfer-ownership="none" gs:managed-name="vectors" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30729">the buffer containing the #GOutputVectors to write.</doc>
              <array length="2" zero-terminated="0" c:type="const GOutputVector*" gs:is-pointer="1">
                <type name="OutputVector" c:type="GOutputVector" />
              </array>
            </parameter>
            <parameter name="n_vectors" transfer-ownership="none" gs:managed-name="nVectors" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30730">the number of vectors to write</doc>
              <type name="gsize" c:type="gsize" />
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30731">the I/O priority of the request.</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30732">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="6" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30733">callback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="6" gs:managed-name="userData" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30734">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30728">A #GOutputStream.</doc>
              <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="vectors" transfer-ownership="none" gs:managed-name="vectors" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30729">the buffer containing the #GOutputVectors to write.</doc>
              <array length="2" zero-terminated="0" c:type="const GOutputVector*" gs:is-pointer="1">
                <type name="OutputVector" c:type="GOutputVector" />
              </array>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none" gs:managed-name="ioPriority" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30731">the I/O priority of the request.</doc>
              <type name="gint" c:type="int" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="6" gs:managed-name="callback" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30733">callback to call when the request is satisfied</doc>
              <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30732">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="writev_finish" gs:managed-name="WritevFinish">
        <callback name="writev_finish" throws="1" gs:dll-name="gio-2.0" gs:managed-name="WritevFinish">
          <source-position filename="goutputstream.h" line="137" />
          <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="30781">%TRUE on success, %FALSE if there was an error</doc>
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30773">a #GOutputStream.</doc>
              <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30774">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
            <parameter name="bytes_written" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="bytesWritten">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30775">location to store the number of bytes that were written to the stream</doc>
              <type name="gsize" c:type="gsize*" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="stream" transfer-ownership="none" gs:managed-name="stream" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30773">a #GOutputStream.</doc>
              <type name="OutputStream" c:type="GOutputStream*" gs:is-pointer="1" />
            </parameter>
            <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30774">a #GAsyncResult.</doc>
              <type name="AsyncResult" c:type="GAsyncResult*" gs:is-pointer="1" />
            </parameter>
            <parameter name="bytes_written" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="bytesWritten">
              <doc xml:space="preserve" filename="gio-2.0.c" line="30775">location to store the number of bytes that were written to the stream</doc>
              <type name="gsize" c:type="gsize*" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="_g_reserved4" introspectable="1" gs:managed-name="GReserved4">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="_g_reserved5" introspectable="1" gs:managed-name="GReserved5">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="_g_reserved6" introspectable="1" gs:managed-name="GReserved6">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="_g_reserved7" introspectable="1" gs:managed-name="GReserved7">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
      <field name="_g_reserved8" introspectable="1" gs:managed-name="GReserved8">
        <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
      </field>
    </record>
    <bitfield name="OutputStreamSpliceFlags" glib:type-name="GOutputStreamSpliceFlags" glib:get-type="g_output_stream_splice_flags_get_type" c:type="GOutputStreamSpliceFlags" gs:managed-name="OutputStreamSpliceFlags">
      <doc xml:space="preserve" filename="gioenums.h" line="642">GOutputStreamSpliceFlags determine how streams should be spliced.</doc>
      <member name="none" value="0" c:identifier="G_OUTPUT_STREAM_SPLICE_NONE" glib:nick="none" gs:managed-name="None">
        <doc xml:space="preserve" filename="gioenums.h" line="644">Do not close either stream.</doc>
      </member>
      <member name="close_source" value="1" c:identifier="G_OUTPUT_STREAM_SPLICE_CLOSE_SOURCE" glib:nick="close-source" gs:managed-name="CloseSource">
        <doc xml:space="preserve" filename="gioenums.h" line="645">Close the source stream after
    the splice.</doc>
      </member>
      <member name="close_target" value="2" c:identifier="G_OUTPUT_STREAM_SPLICE_CLOSE_TARGET" glib:nick="close-target" gs:managed-name="CloseTarget">
        <doc xml:space="preserve" filename="gioenums.h" line="647">Close the target stream after
    the splice.</doc>
      </member>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_output_stream_splice_flags_get_type" gs:access-modifiers="private" gs:dll-name="gio-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </bitfield>
    <record name="OutputVector" c:type="GOutputVector" version="2.22" gs:managed-name="OutputVector">
      <doc xml:space="preserve" filename="giotypes.h" line="493">Structure used for scatter/gather data output.
You generally pass in an array of #GOutputVectors
and the operation will use all the buffers as if they were
one buffer.</doc>
      <source-position filename="giotypes.h" line="510" />
      <field name="buffer" writable="1" gs:managed-name="Buffer">
        <doc xml:space="preserve" filename="giotypes.h" line="495">Pointer to a buffer of data to read.</doc>
        <type name="gpointer" c:type="gconstpointer" gs:is-pointer="1" />
      </field>
      <field name="size" writable="1" gs:managed-name="Size">
        <doc xml:space="preserve" filename="giotypes.h" line="496">the size of @buffer.</doc>
        <type name="gsize" c:type="gsize" />
      </field>
    </record>
    <interface name="Seekable" c:symbol-prefix="seekable" c:type="GSeekable" glib:type-name="GSeekable" glib:get-type="g_seekable_get_type" glib:type-struct="SeekableIface" gs:managed-name="ISeekable">
      <doc xml:space="preserve" filename="gio-2.0.c" line="7728">#GSeekable is implemented by streams (implementations of
#GInputStream or #GOutputStream) that support seeking.

Seekable streams largely fall into two categories: resizable and
fixed-size.

#GSeekable on fixed-sized streams is approximately the same as POSIX
lseek() on a block device (for example: attempting to seek past the
end of the device is an error).  Fixed streams typically cannot be
truncated.

#GSeekable on resizable streams is approximately the same as POSIX
lseek() on a normal file.  Seeking past the end and writing data will
usually cause the stream to resize by introducing zero bytes.</doc>
      <source-position filename="gseekable.h" line="77" />
      <virtual-method name="can_seek" invoker="can_seek" gs:dll-name="gio-2.0" gs:managed-name="DoCanSeek">
        <doc xml:space="preserve" filename="gio-2.0.c" line="32296">Tests if the stream supports the #GSeekableIface.</doc>
        <source-position filename="gseekable.h" line="63" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="32302">%TRUE if @seekable can be seeked. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="seekable" transfer-ownership="none" gs:managed-name="seekable" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="32298">a #GSeekable.</doc>
            <type name="Seekable" c:type="GSeekable*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </virtual-method>
      <virtual-method name="can_truncate" invoker="can_truncate" gs:dll-name="gio-2.0" gs:managed-name="DoCanTruncate">
        <doc xml:space="preserve" filename="gio-2.0.c" line="32306">Tests if the length of the stream can be adjusted with
g_seekable_truncate().</doc>
        <source-position filename="gseekable.h" line="70" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="32313">%TRUE if the stream can be truncated, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="seekable" transfer-ownership="none" gs:managed-name="seekable" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="32308">a #GSeekable.</doc>
            <type name="Seekable" c:type="GSeekable*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </virtual-method>
      <virtual-method name="seek" invoker="seek" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoSeek">
        <doc xml:space="preserve" filename="gio-2.0.c" line="32317">Seeks in the stream by the given @offset, modified by @type.

Attempting to seek past the end of the stream will have different
results depending on if the stream is fixed-sized or resizable.  If
the stream is resizable then seeking past the end and then writing
will result in zeros filling the empty space.  Seeking past the end
of a resizable stream and reading will result in EOF.  Seeking past
the end of a fixed-sized stream will fail.

Any operation that would result in a negative offset will fail.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <source-position filename="gseekable.h" line="64" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="32341">%TRUE if successful. If an error
    has occurred, this function will return %FALSE and set @error
    appropriately if present.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="seekable" transfer-ownership="none" gs:managed-name="seekable" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="32319">a #GSeekable.</doc>
            <type name="Seekable" c:type="GSeekable*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none" gs:managed-name="offset" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="32320">a #goffset.</doc>
            <type name="gint64" c:type="goffset" />
          </parameter>
          <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="32321">a #GSeekType.</doc>
            <type name="GLib.SeekType" c:type="GSeekType" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="32322">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="offset" transfer-ownership="none" gs:managed-name="offset" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="32320">a #goffset.</doc>
            <type name="gint64" c:type="goffset" />
          </parameter>
          <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="32321">a #GSeekType.</doc>
            <type name="GLib.SeekType" c:type="GSeekType" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="32322">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="tell" invoker="tell" gs:dll-name="gio-2.0" gs:managed-name="DoTell">
        <doc xml:space="preserve" filename="gio-2.0.c" line="32347">Tells the current position within the stream.</doc>
        <source-position filename="gseekable.h" line="61" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="32353">the offset from the beginning of the buffer.</doc>
          <type name="gint64" c:type="goffset" />
        </return-value>
        <parameters>
          <instance-parameter name="seekable" transfer-ownership="none" gs:managed-name="seekable" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="32349">a #GSeekable.</doc>
            <type name="Seekable" c:type="GSeekable*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </virtual-method>
      <virtual-method name="truncate_fn" invoker="truncate" throws="1" gs:dll-name="gio-2.0" gs:managed-name="DoTruncateFn">
        <doc xml:space="preserve" filename="gio-2.0.c" line="32357">Sets the length of the stream to @offset. If the stream was previously
larger than @offset, the extra data is discarded. If the stream was
previously shorter than @offset, it is extended with NUL ('\0') bytes.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
operation was partially finished when the operation was cancelled the
partial result will be returned, without an error.</doc>
        <source-position filename="gseekable.h" line="71" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="32375">%TRUE if successful. If an error
    has occurred, this function will return %FALSE and set @error
    appropriately if present.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="seekable" transfer-ownership="none" gs:managed-name="seekable" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="32359">a #GSeekable.</doc>
            <type name="Seekable" c:type="GSeekable*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none" gs:managed-name="offset" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="32360">new length for @seekable, in bytes.</doc>
            <type name="gint64" c:type="goffset" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="32361">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="offset" transfer-ownership="none" gs:managed-name="offset" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="32360">new length for @seekable, in bytes.</doc>
            <type name="gint64" c:type="goffset" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="32361">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <method name="can_seek" c:identifier="g_seekable_can_seek" gs:dll-name="gio-2.0" gs:managed-name="CanSeek" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="32296">Tests if the stream supports the #GSeekableIface.</doc>
        <source-position filename="gseekable.h" line="85" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="32302">%TRUE if @seekable can be seeked. %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="seekable" transfer-ownership="none" gs:managed-name="seekable" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="32298">a #GSeekable.</doc>
            <type name="Seekable" c:type="GSeekable*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="seekable" transfer-ownership="none" gs:managed-name="seekable" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="32298">a #GSeekable.</doc>
            <type name="Seekable" c:type="GSeekable*" gs:is-pointer="1" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="can_truncate" c:identifier="g_seekable_can_truncate" gs:dll-name="gio-2.0" gs:managed-name="CanTruncate" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="32306">Tests if the length of the stream can be adjusted with
g_seekable_truncate().</doc>
        <source-position filename="gseekable.h" line="93" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="32313">%TRUE if the stream can be truncated, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="seekable" transfer-ownership="none" gs:managed-name="seekable" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="32308">a #GSeekable.</doc>
            <type name="Seekable" c:type="GSeekable*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="seekable" transfer-ownership="none" gs:managed-name="seekable" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="32308">a #GSeekable.</doc>
            <type name="Seekable" c:type="GSeekable*" gs:is-pointer="1" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="seek" c:identifier="g_seekable_seek" throws="1" gs:dll-name="gio-2.0" gs:managed-name="Seek" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="32317">Seeks in the stream by the given @offset, modified by @type.

Attempting to seek past the end of the stream will have different
results depending on if the stream is fixed-sized or resizable.  If
the stream is resizable then seeking past the end and then writing
will result in zeros filling the empty space.  Seeking past the end
of a resizable stream and reading will result in EOF.  Seeking past
the end of a fixed-sized stream will fail.

Any operation that would result in a negative offset will fail.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</doc>
        <source-position filename="gseekable.h" line="87" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="32341">%TRUE if successful. If an error
    has occurred, this function will return %FALSE and set @error
    appropriately if present.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="seekable" transfer-ownership="none" gs:managed-name="seekable" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="32319">a #GSeekable.</doc>
            <type name="Seekable" c:type="GSeekable*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none" gs:managed-name="offset" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="32320">a #goffset.</doc>
            <type name="gint64" c:type="goffset" />
          </parameter>
          <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="32321">a #GSeekType.</doc>
            <type name="GLib.SeekType" c:type="GSeekType" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="32322">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="seekable" transfer-ownership="none" gs:managed-name="seekable" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="32319">a #GSeekable.</doc>
            <type name="Seekable" c:type="GSeekable*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none" gs:managed-name="offset" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="32320">a #goffset.</doc>
            <type name="gint64" c:type="goffset" />
          </parameter>
          <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="32321">a #GSeekType.</doc>
            <type name="GLib.SeekType" c:type="GSeekType" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="32322">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="tell" c:identifier="g_seekable_tell" gs:dll-name="gio-2.0" gs:managed-name="Tell" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="32347">Tells the current position within the stream.</doc>
        <source-position filename="gseekable.h" line="83" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="32353">the offset from the beginning of the buffer.</doc>
          <type name="gint64" c:type="goffset" />
        </return-value>
        <parameters>
          <instance-parameter name="seekable" transfer-ownership="none" gs:managed-name="seekable" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="32349">a #GSeekable.</doc>
            <type name="Seekable" c:type="GSeekable*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="seekable" transfer-ownership="none" gs:managed-name="seekable" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="32349">a #GSeekable.</doc>
            <type name="Seekable" c:type="GSeekable*" gs:is-pointer="1" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="truncate" c:identifier="g_seekable_truncate" throws="1" gs:dll-name="gio-2.0" gs:managed-name="Truncate" gs:extension-method="1">
        <doc xml:space="preserve" filename="gio-2.0.c" line="32357">Sets the length of the stream to @offset. If the stream was previously
larger than @offset, the extra data is discarded. If the stream was
previously shorter than @offset, it is extended with NUL ('\0') bytes.

If @cancellable is not %NULL, then the operation can be cancelled by
triggering the cancellable object from another thread. If the operation
was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an
operation was partially finished when the operation was cancelled the
partial result will be returned, without an error.</doc>
        <source-position filename="gseekable.h" line="95" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="32375">%TRUE if successful. If an error
    has occurred, this function will return %FALSE and set @error
    appropriately if present.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="seekable" transfer-ownership="none" gs:managed-name="seekable" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="32359">a #GSeekable.</doc>
            <type name="Seekable" c:type="GSeekable*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none" gs:managed-name="offset" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="32360">new length for @seekable, in bytes.</doc>
            <type name="gint64" c:type="goffset" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="32361">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="seekable" transfer-ownership="none" gs:managed-name="seekable" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="32359">a #GSeekable.</doc>
            <type name="Seekable" c:type="GSeekable*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none" gs:managed-name="offset" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="32360">new length for @seekable, in bytes.</doc>
            <type name="gint64" c:type="goffset" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="32361">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_seekable_get_type" gs:access-modifiers="private" gs:dll-name="gio-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </interface>
    <record name="SeekableIface" c:type="GSeekableIface" glib:is-gtype-struct-for="Seekable" gs:managed-name="SeekableIface">
      <doc xml:space="preserve" filename="gseekable.h" line="44">Provides an interface for implementing seekable functionality on I/O Streams.</doc>
      <source-position filename="gseekable.h" line="77" />
      <field name="g_iface" gs:managed-name="GIface">
        <doc xml:space="preserve" filename="gseekable.h" line="46">The parent interface.</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface" />
      </field>
      <field name="tell" gs:managed-name="Tell">
        <callback name="tell" gs:dll-name="gio-2.0" gs:managed-name="Tell">
          <source-position filename="gseekable.h" line="61" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="32353">the offset from the beginning of the buffer.</doc>
            <type name="gint64" c:type="goffset" />
          </return-value>
          <parameters>
            <parameter name="seekable" transfer-ownership="none" gs:managed-name="seekable" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="32349">a #GSeekable.</doc>
              <type name="Seekable" c:type="GSeekable*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="seekable" transfer-ownership="none" gs:managed-name="seekable" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="32349">a #GSeekable.</doc>
              <type name="Seekable" c:type="GSeekable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="can_seek" gs:managed-name="CanSeek">
        <callback name="can_seek" gs:dll-name="gio-2.0" gs:managed-name="CanSeek">
          <source-position filename="gseekable.h" line="63" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="32302">%TRUE if @seekable can be seeked. %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="seekable" transfer-ownership="none" gs:managed-name="seekable" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="32298">a #GSeekable.</doc>
              <type name="Seekable" c:type="GSeekable*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="seekable" transfer-ownership="none" gs:managed-name="seekable" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="32298">a #GSeekable.</doc>
              <type name="Seekable" c:type="GSeekable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="seek" gs:managed-name="Seek">
        <callback name="seek" throws="1" gs:dll-name="gio-2.0" gs:managed-name="Seek">
          <source-position filename="gseekable.h" line="64" />
          <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="32341">%TRUE if successful. If an error
    has occurred, this function will return %FALSE and set @error
    appropriately if present.</doc>
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="seekable" transfer-ownership="none" gs:managed-name="seekable" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="32319">a #GSeekable.</doc>
              <type name="Seekable" c:type="GSeekable*" gs:is-pointer="1" />
            </parameter>
            <parameter name="offset" transfer-ownership="none" gs:managed-name="offset" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="32320">a #goffset.</doc>
              <type name="gint64" c:type="goffset" />
            </parameter>
            <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="32321">a #GSeekType.</doc>
              <type name="GLib.SeekType" c:type="GSeekType" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="32322">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="seekable" transfer-ownership="none" gs:managed-name="seekable" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="32319">a #GSeekable.</doc>
              <type name="Seekable" c:type="GSeekable*" gs:is-pointer="1" />
            </parameter>
            <parameter name="offset" transfer-ownership="none" gs:managed-name="offset" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="32320">a #goffset.</doc>
              <type name="gint64" c:type="goffset" />
            </parameter>
            <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="32321">a #GSeekType.</doc>
              <type name="GLib.SeekType" c:type="GSeekType" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="32322">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="can_truncate" gs:managed-name="CanTruncate">
        <callback name="can_truncate" gs:dll-name="gio-2.0" gs:managed-name="CanTruncate">
          <source-position filename="gseekable.h" line="70" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="32313">%TRUE if the stream can be truncated, %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="seekable" transfer-ownership="none" gs:managed-name="seekable" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="32308">a #GSeekable.</doc>
              <type name="Seekable" c:type="GSeekable*" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="seekable" transfer-ownership="none" gs:managed-name="seekable" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="32308">a #GSeekable.</doc>
              <type name="Seekable" c:type="GSeekable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="truncate_fn" gs:managed-name="TruncateFn">
        <callback name="truncate_fn" throws="1" gs:dll-name="gio-2.0" gs:managed-name="TruncateFn">
          <source-position filename="gseekable.h" line="71" />
          <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="32375">%TRUE if successful. If an error
    has occurred, this function will return %FALSE and set @error
    appropriately if present.</doc>
            <type name="gboolean" c:type="gboolean" />
          </return-value>
          <parameters>
            <parameter name="seekable" transfer-ownership="none" gs:managed-name="seekable" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="32359">a #GSeekable.</doc>
              <type name="Seekable" c:type="GSeekable*" gs:is-pointer="1" />
            </parameter>
            <parameter name="offset" transfer-ownership="none" gs:managed-name="offset" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="32360">new length for @seekable, in bytes.</doc>
              <type name="gint64" c:type="goffset" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="32361">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
            <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
              <doc>return location for a #GError</doc>
              <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
            </gs:error-parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="seekable" transfer-ownership="none" gs:managed-name="seekable" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="32359">a #GSeekable.</doc>
              <type name="Seekable" c:type="GSeekable*" gs:is-pointer="1" />
            </parameter>
            <parameter name="offset" transfer-ownership="none" gs:managed-name="offset" direction="in">
              <doc xml:space="preserve" filename="gio-2.0.c" line="32360">new length for @seekable, in bytes.</doc>
              <type name="gint64" c:type="goffset" />
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
              <doc xml:space="preserve" filename="gio-2.0.c" line="32361">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
    </record>
    <class name="SimpleAction" c:symbol-prefix="simple_action" c:type="GSimpleAction" parent="GObject.Object" glib:type-name="GSimpleAction" glib:get-type="g_simple_action_get_type" gs:managed-name="SimpleAction">
      <doc xml:space="preserve" filename="gio-2.0.c" line="8181">A #GSimpleAction is the obvious simple implementation of the #GAction
interface. This is the easiest way to create an action for purposes of
adding it to a #GSimpleActionGroup.

See also #GtkAction.</doc>
      <implements name="Action" gs:managed-name="Action" />
      <constructor name="new" c:identifier="g_simple_action_new" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="New">
        <doc xml:space="preserve" filename="gio-2.0.c" line="34051">Creates a new action.

The created action is stateless. See g_simple_action_new_stateful() to create
an action that has state.</doc>
        <source-position filename="gsimpleaction.h" line="41" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="34062">a new #GSimpleAction</doc>
          <type name="SimpleAction" c:type="GSimpleAction*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="34053">the name of the action</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="parameter_type" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="parameterType" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="34054">the type of parameter that will be passed to
  handlers for the #GSimpleAction::activate signal, or %NULL for no parameter</doc>
            <type name="GLib.VariantType" c:type="const GVariantType*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="34053">the name of the action</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="parameter_type" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="parameterType" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="34054">the type of parameter that will be passed to
  handlers for the #GSimpleAction::activate signal, or %NULL for no parameter</doc>
            <type name="GLib.VariantType" c:type="const GVariantType*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <constructor name="new_stateful" c:identifier="g_simple_action_new_stateful" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="NewStateful">
        <doc xml:space="preserve" filename="gio-2.0.c" line="34067">Creates a new stateful action.

All future state values must have the same #GVariantType as the initial
@state.

If the @state #GVariant is floating, it is consumed.</doc>
        <source-position filename="gsimpleaction.h" line="45" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="34081">a new #GSimpleAction</doc>
          <type name="SimpleAction" c:type="GSimpleAction*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="34069">the name of the action</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="parameter_type" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="parameterType" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="34070">the type of the parameter that will be passed to
  handlers for the #GSimpleAction::activate signal, or %NULL for no parameter</doc>
            <type name="GLib.VariantType" c:type="const GVariantType*" gs:is-pointer="1" />
          </parameter>
          <parameter name="state" transfer-ownership="none" gs:managed-name="state" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="34072">the initial state of the action</doc>
            <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="34069">the name of the action</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
          <parameter name="parameter_type" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="parameterType" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="34070">the type of the parameter that will be passed to
  handlers for the #GSimpleAction::activate signal, or %NULL for no parameter</doc>
            <type name="GLib.VariantType" c:type="const GVariantType*" gs:is-pointer="1" />
          </parameter>
          <parameter name="state" transfer-ownership="none" gs:managed-name="state" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="34072">the initial state of the action</doc>
            <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <method name="set_enabled" c:identifier="g_simple_action_set_enabled" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="SetEnabled">
        <doc xml:space="preserve" filename="gio-2.0.c" line="34086">Sets the action as enabled or not.

An action must be enabled in order to be activated or in order to
have its state changed from outside callers.

This should only be called by the implementor of the action.  Users
of the action should not attempt to modify its enabled flag.</doc>
        <source-position filename="gsimpleaction.h" line="50" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="simple" transfer-ownership="none" gs:managed-name="simple" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="34088">a #GSimpleAction</doc>
            <type name="SimpleAction" c:type="GSimpleAction*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="enabled" transfer-ownership="none" gs:managed-name="enabled" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="34089">whether the action is enabled</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="enabled" transfer-ownership="none" gs:managed-name="enabled" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="34089">whether the action is enabled</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_state" c:identifier="g_simple_action_set_state" version="2.30" gs:dll-name="gio-2.0" gs:managed-name="SetState">
        <doc xml:space="preserve" filename="gio-2.0.c" line="34103">Sets the state of the action.

This directly updates the 'state' property to the given value.

This should only be called by the implementor of the action.  Users
of the action should not attempt to directly modify the 'state'
property.  Instead, they should call g_action_change_state() to
request the change.

If the @value GVariant is floating, it is consumed.</doc>
        <source-position filename="gsimpleaction.h" line="54" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="simple" transfer-ownership="none" gs:managed-name="simple" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="34105">a #GSimpleAction</doc>
            <type name="SimpleAction" c:type="GSimpleAction*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="34106">the new #GVariant for the state</doc>
            <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="34106">the new #GVariant for the state</doc>
            <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_state_hint" c:identifier="g_simple_action_set_state_hint" version="2.44" gs:dll-name="gio-2.0" gs:managed-name="SetStateHint">
        <doc xml:space="preserve" filename="gio-2.0.c" line="34123">Sets the state hint for the action.

See g_action_get_state_hint() for more information about
action state hints.</doc>
        <source-position filename="gsimpleaction.h" line="58" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="simple" transfer-ownership="none" gs:managed-name="simple" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="34125">a #GSimpleAction</doc>
            <type name="SimpleAction" c:type="GSimpleAction*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="state_hint" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="stateHint" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="34126">a #GVariant representing the state hint</doc>
            <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="state_hint" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="stateHint" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="34126">a #GVariant representing the state hint</doc>
            <type name="GLib.Variant" c:type="GVariant*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <property name="enabled" version="2.28" writable="1" transfer-ownership="none" gs:managed-name="Enabled">
        <doc xml:space="preserve" filename="gio-2.0.c" line="3129">If @action is currently enabled.

If the action is disabled then calls to g_action_activate() and
g_action_change_state() have no effect.</doc>
        <type name="gboolean" c:type="gboolean" />
      </property>
      <property name="name" version="2.28" writable="1" construct-only="1" transfer-ownership="none" gs:managed-name="Name">
        <doc xml:space="preserve" filename="gio-2.0.c" line="3141">The name of the action. This is mostly meaningful for identifying
the action once it has been added to a #GSimpleActionGroup.</doc>
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </property>
      <property name="parameter-type" version="2.28" writable="1" construct-only="1" transfer-ownership="none" gs:managed-name="ParameterType">
        <doc xml:space="preserve" filename="gio-2.0.c" line="3151">The type of the parameter that must be given when activating the
action.</doc>
        <type name="GLib.VariantType" />
      </property>
      <property name="state" version="2.28" writable="1" construct="1" transfer-ownership="none" gs:managed-name="State">
        <doc xml:space="preserve" filename="gio-2.0.c" line="3161">The state of the action, or %NULL if the action is stateless.</doc>
        <type name="GLib.Variant" />
      </property>
      <property name="state-type" version="2.28" transfer-ownership="none" gs:managed-name="StateType">
        <doc xml:space="preserve" filename="gio-2.0.c" line="3170">The #GVariantType of the state that the action has, or %NULL if the
action is stateless.</doc>
        <type name="GLib.VariantType" />
      </property>
      <glib:signal name="activate" when="last" version="2.28" gs:dll-name="gio-2.0" gs:managed-name="ActivateSignal">
        <doc xml:space="preserve" filename="gio-2.0.c" line="3062">Indicates that the action was just activated.

@parameter will always be of the expected type, i.e. the parameter type
specified when the action was created. If an incorrect type is given when
activating the action, this signal is not emitted.

Since GLib 2.40, if no handler is connected to this signal then the
default behaviour for boolean-stated actions with a %NULL parameter
type is to toggle them via the #GSimpleAction::change-state signal.
For stateful actions where the state type is equal to the parameter
type, the default is to forward them directly to
#GSimpleAction::change-state.  This should allow almost all users
of #GSimpleAction to connect only one handler or the other.</doc>
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="simple_action" transfer-ownership="none" gs:managed-name="simpleAction" direction="in">
            <doc>the instance on which the signal was invoked</doc>
            <type name="SimpleAction" c:name="gpointer" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="parameter" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="parameter" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="3065">the parameter to the activation, or %NULL if it has
  no parameter</doc>
            <type name="GLib.Variant" gs:is-pointer="1" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="1" gs:managed-name="userData" direction="in">
            <type name="gpointer" c:name="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="simple_action" transfer-ownership="none" gs:managed-name="simpleAction" direction="in">
            <doc>the instance on which the signal was invoked</doc>
            <type name="SimpleAction" c:name="gpointer" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="parameter" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="parameter" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="3065">the parameter to the activation, or %NULL if it has
  no parameter</doc>
            <type name="GLib.Variant" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </glib:signal>
      <glib:signal name="change-state" when="last" version="2.30" gs:dll-name="gio-2.0" gs:managed-name="ChangeStateSignal">
        <doc xml:space="preserve" filename="gio-2.0.c" line="3086">Indicates that the action just received a request to change its
state.

@value will always be of the correct state type, i.e. the type of the
initial state passed to g_simple_action_new_stateful(). If an incorrect
type is given when requesting to change the state, this signal is not
emitted.

If no handler is connected to this signal then the default
behaviour is to call g_simple_action_set_state() to set the state
to the requested value. If you connect a signal handler then no
default action is taken. If the state should change then you must
call g_simple_action_set_state() from the handler.

An example of a 'change-state' handler:
|[&lt;!-- language="C" --&gt;
static void
change_volume_state (GSimpleAction *action,
                     GVariant      *value,
                     gpointer       user_data)
{
  gint requested;

  requested = g_variant_get_int32 (value);

  // Volume only goes from 0 to 10
  if (0 &lt;= requested &amp;&amp; requested &lt;= 10)
    g_simple_action_set_state (action, value);
}
]|

The handler need not set the state to the requested value.
It could set it to any value at all, or take some other action.</doc>
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="simple_action" transfer-ownership="none" gs:managed-name="simpleAction" direction="in">
            <doc>the instance on which the signal was invoked</doc>
            <type name="SimpleAction" c:name="gpointer" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="value" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="3089">the requested value for the state</doc>
            <type name="GLib.Variant" gs:is-pointer="1" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="1" gs:managed-name="userData" direction="in">
            <type name="gpointer" c:name="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="simple_action" transfer-ownership="none" gs:managed-name="simpleAction" direction="in">
            <doc>the instance on which the signal was invoked</doc>
            <type name="SimpleAction" c:name="gpointer" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="value" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="3089">the requested value for the state</doc>
            <type name="GLib.Variant" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </glib:signal>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_simple_action_get_type" gs:access-modifiers="private" gs:dll-name="gio-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </class>
    <class name="Task" c:symbol-prefix="task" c:type="GTask" parent="GObject.Object" glib:type-name="GTask" glib:get-type="g_task_get_type" glib:type-struct="TaskClass" gs:managed-name="Task">
      <doc xml:space="preserve" filename="gio-2.0.c" line="8847">A #GTask represents and manages a cancellable "task".

## Asynchronous operations

The most common usage of #GTask is as a #GAsyncResult, to
manage data during an asynchronous operation. You call
g_task_new() in the "start" method, followed by
g_task_set_task_data() and the like if you need to keep some
additional data associated with the task, and then pass the
task object around through your asynchronous operation.
Eventually, you will call a method such as
g_task_return_pointer() or g_task_return_error(), which will
save the value you give it and then invoke the task's callback
function in the
[thread-default main context][g-main-context-push-thread-default]
where it was created (waiting until the next iteration of the main
loop first, if necessary). The caller will pass the #GTask back to
the operation's finish function (as a #GAsyncResult), and you can
use g_task_propagate_pointer() or the like to extract the
return value.

Here is an example for using GTask as a GAsyncResult:
|[&lt;!-- language="C" --&gt;
    typedef struct {
      CakeFrostingType frosting;
      char *message;
    } DecorationData;

    static void
    decoration_data_free (DecorationData *decoration)
    {
      g_free (decoration-&gt;message);
      g_slice_free (DecorationData, decoration);
    }

    static void
    baked_cb (Cake     *cake,
              gpointer  user_data)
    {
      GTask *task = user_data;
      DecorationData *decoration = g_task_get_task_data (task);
      GError *error = NULL;

      if (cake == NULL)
        {
          g_task_return_new_error (task, BAKER_ERROR, BAKER_ERROR_NO_FLOUR,
                                   "Go to the supermarket");
          g_object_unref (task);
          return;
        }

      if (!cake_decorate (cake, decoration-&gt;frosting, decoration-&gt;message, &amp;error))
        {
          g_object_unref (cake);
          // g_task_return_error() takes ownership of error
          g_task_return_error (task, error);
          g_object_unref (task);
          return;
        }

      g_task_return_pointer (task, cake, g_object_unref);
      g_object_unref (task);
    }

    void
    baker_bake_cake_async (Baker               *self,
                           guint                radius,
                           CakeFlavor           flavor,
                           CakeFrostingType     frosting,
                           const char          *message,
                           GCancellable        *cancellable,
                           GAsyncReadyCallback  callback,
                           gpointer             user_data)
    {
      GTask *task;
      DecorationData *decoration;
      Cake  *cake;

      task = g_task_new (self, cancellable, callback, user_data);
      if (radius &lt; 3)
        {
          g_task_return_new_error (task, BAKER_ERROR, BAKER_ERROR_TOO_SMALL,
                                   "%ucm radius cakes are silly",
                                   radius);
          g_object_unref (task);
          return;
        }

      cake = _baker_get_cached_cake (self, radius, flavor, frosting, message);
      if (cake != NULL)
        {
          // _baker_get_cached_cake() returns a reffed cake
          g_task_return_pointer (task, cake, g_object_unref);
          g_object_unref (task);
          return;
        }

      decoration = g_slice_new (DecorationData);
      decoration-&gt;frosting = frosting;
      decoration-&gt;message = g_strdup (message);
      g_task_set_task_data (task, decoration, (GDestroyNotify) decoration_data_free);

      _baker_begin_cake (self, radius, flavor, cancellable, baked_cb, task);
    }

    Cake *
    baker_bake_cake_finish (Baker         *self,
                            GAsyncResult  *result,
                            GError       **error)
    {
      g_return_val_if_fail (g_task_is_valid (result, self), NULL);

      return g_task_propagate_pointer (G_TASK (result), error);
    }
]|

## Chained asynchronous operations

#GTask also tries to simplify asynchronous operations that
internally chain together several smaller asynchronous
operations. g_task_get_cancellable(), g_task_get_context(),
and g_task_get_priority() allow you to get back the task's
#GCancellable, #GMainContext, and [I/O priority][io-priority]
when starting a new subtask, so you don't have to keep track
of them yourself. g_task_attach_source() simplifies the case
of waiting for a source to fire (automatically using the correct
#GMainContext and priority).

Here is an example for chained asynchronous operations:
  |[&lt;!-- language="C" --&gt;
    typedef struct {
      Cake *cake;
      CakeFrostingType frosting;
      char *message;
    } BakingData;

    static void
    decoration_data_free (BakingData *bd)
    {
      if (bd-&gt;cake)
        g_object_unref (bd-&gt;cake);
      g_free (bd-&gt;message);
      g_slice_free (BakingData, bd);
    }

    static void
    decorated_cb (Cake         *cake,
                  GAsyncResult *result,
                  gpointer      user_data)
    {
      GTask *task = user_data;
      GError *error = NULL;

      if (!cake_decorate_finish (cake, result, &amp;error))
        {
          g_object_unref (cake);
          g_task_return_error (task, error);
          g_object_unref (task);
          return;
        }

      // baking_data_free() will drop its ref on the cake, so we have to
      // take another here to give to the caller.
      g_task_return_pointer (task, g_object_ref (cake), g_object_unref);
      g_object_unref (task);
    }

    static gboolean
    decorator_ready (gpointer user_data)
    {
      GTask *task = user_data;
      BakingData *bd = g_task_get_task_data (task);

      cake_decorate_async (bd-&gt;cake, bd-&gt;frosting, bd-&gt;message,
                           g_task_get_cancellable (task),
                           decorated_cb, task);

      return G_SOURCE_REMOVE;
    }

    static void
    baked_cb (Cake     *cake,
              gpointer  user_data)
    {
      GTask *task = user_data;
      BakingData *bd = g_task_get_task_data (task);
      GError *error = NULL;

      if (cake == NULL)
        {
          g_task_return_new_error (task, BAKER_ERROR, BAKER_ERROR_NO_FLOUR,
                                   "Go to the supermarket");
          g_object_unref (task);
          return;
        }

      bd-&gt;cake = cake;

      // Bail out now if the user has already cancelled
      if (g_task_return_error_if_cancelled (task))
        {
          g_object_unref (task);
          return;
        }

      if (cake_decorator_available (cake))
        decorator_ready (task);
      else
        {
          GSource *source;

          source = cake_decorator_wait_source_new (cake);
          // Attach @source to @task's GMainContext and have it call
          // decorator_ready() when it is ready.
          g_task_attach_source (task, source, decorator_ready);
          g_source_unref (source);
        }
    }

    void
    baker_bake_cake_async (Baker               *self,
                           guint                radius,
                           CakeFlavor           flavor,
                           CakeFrostingType     frosting,
                           const char          *message,
                           gint                 priority,
                           GCancellable        *cancellable,
                           GAsyncReadyCallback  callback,
                           gpointer             user_data)
    {
      GTask *task;
      BakingData *bd;

      task = g_task_new (self, cancellable, callback, user_data);
      g_task_set_priority (task, priority);

      bd = g_slice_new0 (BakingData);
      bd-&gt;frosting = frosting;
      bd-&gt;message = g_strdup (message);
      g_task_set_task_data (task, bd, (GDestroyNotify) baking_data_free);

      _baker_begin_cake (self, radius, flavor, cancellable, baked_cb, task);
    }

    Cake *
    baker_bake_cake_finish (Baker         *self,
                            GAsyncResult  *result,
                            GError       **error)
    {
      g_return_val_if_fail (g_task_is_valid (result, self), NULL);

      return g_task_propagate_pointer (G_TASK (result), error);
    }
]|

## Asynchronous operations from synchronous ones

You can use g_task_run_in_thread() to turn a synchronous
operation into an asynchronous one, by running it in a thread.
When it completes, the result will be dispatched to the
[thread-default main context][g-main-context-push-thread-default]
where the #GTask was created.

Running a task in a thread:
  |[&lt;!-- language="C" --&gt;
    typedef struct {
      guint radius;
      CakeFlavor flavor;
      CakeFrostingType frosting;
      char *message;
    } CakeData;

    static void
    cake_data_free (CakeData *cake_data)
    {
      g_free (cake_data-&gt;message);
      g_slice_free (CakeData, cake_data);
    }

    static void
    bake_cake_thread (GTask         *task,
                      gpointer       source_object,
                      gpointer       task_data,
                      GCancellable  *cancellable)
    {
      Baker *self = source_object;
      CakeData *cake_data = task_data;
      Cake *cake;
      GError *error = NULL;

      cake = bake_cake (baker, cake_data-&gt;radius, cake_data-&gt;flavor,
                        cake_data-&gt;frosting, cake_data-&gt;message,
                        cancellable, &amp;error);
      if (cake)
        g_task_return_pointer (task, cake, g_object_unref);
      else
        g_task_return_error (task, error);
    }

    void
    baker_bake_cake_async (Baker               *self,
                           guint                radius,
                           CakeFlavor           flavor,
                           CakeFrostingType     frosting,
                           const char          *message,
                           GCancellable        *cancellable,
                           GAsyncReadyCallback  callback,
                           gpointer             user_data)
    {
      CakeData *cake_data;
      GTask *task;

      cake_data = g_slice_new (CakeData);
      cake_data-&gt;radius = radius;
      cake_data-&gt;flavor = flavor;
      cake_data-&gt;frosting = frosting;
      cake_data-&gt;message = g_strdup (message);
      task = g_task_new (self, cancellable, callback, user_data);
      g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);
      g_task_run_in_thread (task, bake_cake_thread);
      g_object_unref (task);
    }

    Cake *
    baker_bake_cake_finish (Baker         *self,
                            GAsyncResult  *result,
                            GError       **error)
    {
      g_return_val_if_fail (g_task_is_valid (result, self), NULL);

      return g_task_propagate_pointer (G_TASK (result), error);
    }
]|

## Adding cancellability to uncancellable tasks

Finally, g_task_run_in_thread() and g_task_run_in_thread_sync()
can be used to turn an uncancellable operation into a
cancellable one. If you call g_task_set_return_on_cancel(),
passing %TRUE, then if the task's #GCancellable is cancelled,
it will return control back to the caller immediately, while
allowing the task thread to continue running in the background
(and simply discarding its result when it finally does finish).
Provided that the task thread is careful about how it uses
locks and other externally-visible resources, this allows you
to make "GLib-friendly" asynchronous and cancellable
synchronous variants of blocking APIs.

Cancelling a task:
  |[&lt;!-- language="C" --&gt;
    static void
    bake_cake_thread (GTask         *task,
                      gpointer       source_object,
                      gpointer       task_data,
                      GCancellable  *cancellable)
    {
      Baker *self = source_object;
      CakeData *cake_data = task_data;
      Cake *cake;
      GError *error = NULL;

      cake = bake_cake (baker, cake_data-&gt;radius, cake_data-&gt;flavor,
                        cake_data-&gt;frosting, cake_data-&gt;message,
                        &amp;error);
      if (error)
        {
          g_task_return_error (task, error);
          return;
        }

      // If the task has already been cancelled, then we don't want to add
      // the cake to the cake cache. Likewise, we don't  want to have the
      // task get cancelled in the middle of updating the cache.
      // g_task_set_return_on_cancel() will return %TRUE here if it managed
      // to disable return-on-cancel, or %FALSE if the task was cancelled
      // before it could.
      if (g_task_set_return_on_cancel (task, FALSE))
        {
          // If the caller cancels at this point, their
          // GAsyncReadyCallback won't be invoked until we return,
          // so we don't have to worry that this code will run at
          // the same time as that code does. But if there were
          // other functions that might look at the cake cache,
          // then we'd probably need a GMutex here as well.
          baker_add_cake_to_cache (baker, cake);
          g_task_return_pointer (task, cake, g_object_unref);
        }
    }

    void
    baker_bake_cake_async (Baker               *self,
                           guint                radius,
                           CakeFlavor           flavor,
                           CakeFrostingType     frosting,
                           const char          *message,
                           GCancellable        *cancellable,
                           GAsyncReadyCallback  callback,
                           gpointer             user_data)
    {
      CakeData *cake_data;
      GTask *task;

      cake_data = g_slice_new (CakeData);

      ...

      task = g_task_new (self, cancellable, callback, user_data);
      g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);
      g_task_set_return_on_cancel (task, TRUE);
      g_task_run_in_thread (task, bake_cake_thread);
    }

    Cake *
    baker_bake_cake_sync (Baker               *self,
                          guint                radius,
                          CakeFlavor           flavor,
                          CakeFrostingType     frosting,
                          const char          *message,
                          GCancellable        *cancellable,
                          GError             **error)
    {
      CakeData *cake_data;
      GTask *task;
      Cake *cake;

      cake_data = g_slice_new (CakeData);

      ...

      task = g_task_new (self, cancellable, NULL, NULL);
      g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);
      g_task_set_return_on_cancel (task, TRUE);
      g_task_run_in_thread_sync (task, bake_cake_thread);

      cake = g_task_propagate_pointer (task, error);
      g_object_unref (task);
      return cake;
    }
]|

## Porting from GSimpleAsyncResult

#GTask's API attempts to be simpler than #GSimpleAsyncResult's
in several ways:
- You can save task-specific data with g_task_set_task_data(), and
  retrieve it later with g_task_get_task_data(). This replaces the
  abuse of g_simple_async_result_set_op_res_gpointer() for the same
  purpose with #GSimpleAsyncResult.
- In addition to the task data, #GTask also keeps track of the
  [priority][io-priority], #GCancellable, and
  #GMainContext associated with the task, so tasks that consist of
  a chain of simpler asynchronous operations will have easy access
  to those values when starting each sub-task.
- g_task_return_error_if_cancelled() provides simplified
  handling for cancellation. In addition, cancellation
  overrides any other #GTask return value by default, like
  #GSimpleAsyncResult does when
  g_simple_async_result_set_check_cancellable() is called.
  (You can use g_task_set_check_cancellable() to turn off that
  behavior.) On the other hand, g_task_run_in_thread()
  guarantees that it will always run your
  `task_func`, even if the task's #GCancellable
  is already cancelled before the task gets a chance to run;
  you can start your `task_func` with a
  g_task_return_error_if_cancelled() check if you need the
  old behavior.
- The "return" methods (eg, g_task_return_pointer())
  automatically cause the task to be "completed" as well, and
  there is no need to worry about the "complete" vs "complete
  in idle" distinction. (#GTask automatically figures out
  whether the task's callback can be invoked directly, or
  if it needs to be sent to another #GMainContext, or delayed
  until the next iteration of the current #GMainContext.)
- The "finish" functions for #GTask based operations are generally
  much simpler than #GSimpleAsyncResult ones, normally consisting
  of only a single call to g_task_propagate_pointer() or the like.
  Since g_task_propagate_pointer() "steals" the return value from
  the #GTask, it is not necessary to juggle pointers around to
  prevent it from being freed twice.
- With #GSimpleAsyncResult, it was common to call
  g_simple_async_result_propagate_error() from the
  `_finish()` wrapper function, and have
  virtual method implementations only deal with successful
  returns. This behavior is deprecated, because it makes it
  difficult for a subclass to chain to a parent class's async
  methods. Instead, the wrapper function should just be a
  simple wrapper, and the virtual method should call an
  appropriate `g_task_propagate_` function.
  Note that wrapper methods can now use
  g_async_result_legacy_propagate_error() to do old-style
  #GSimpleAsyncResult error-returning behavior, and
  g_async_result_is_tagged() to check if a result is tagged as
  having come from the `_async()` wrapper
  function (for "short-circuit" results, such as when passing
  0 to g_input_stream_read_async()).</doc>
      <source-position filename="gtask.h" line="37" />
      <implements name="AsyncResult" gs:managed-name="AsyncResult" />
      <constructor name="new" c:identifier="g_task_new" version="2.36" gs:dll-name="gio-2.0" gs:managed-name="New">
        <doc xml:space="preserve" filename="gio-2.0.c" line="38435">Creates a #GTask acting on @source_object, which will eventually be
used to invoke @callback in the current
[thread-default main context][g-main-context-push-thread-default].

Call this in the "start" method of your asynchronous method, and
pass the #GTask around throughout the asynchronous operation. You
can use g_task_set_task_data() to attach task-specific data to the
object, which you can retrieve later via g_task_get_task_data().

By default, if @cancellable is cancelled, then the return value of
the task will always be %G_IO_ERROR_CANCELLED, even if the task had
already completed before the cancellation. This allows for
simplified handling in cases where cancellation may imply that
other objects that the task depends on have been destroyed. If you
do not want this behavior, you can use
g_task_set_check_cancellable() to change it.</doc>
        <source-position filename="gtask.h" line="43" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="38460">a #GTask.</doc>
          <type name="Task" c:type="GTask*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="source_object" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="sourceObject" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38437">the #GObject that owns
  this task, or %NULL.</doc>
            <type name="GObject.Object" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38439">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38440">a #GAsyncReadyCallback.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="callback_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="callbackData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38441">user data passed to @callback.</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="source_object" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="sourceObject" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38437">the #GObject that owns
  this task, or %NULL.</doc>
            <type name="GObject.Object" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38440">a #GAsyncReadyCallback.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38439">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <function name="is_valid" c:identifier="g_task_is_valid" version="2.36" gs:dll-name="gio-2.0" gs:managed-name="IsValid">
        <doc xml:space="preserve" filename="gio-2.0.c" line="38419">Checks that @result is a #GTask, and that @source_object is its
source object (or that @source_object is %NULL and @result has no
source object). This can be used in g_return_if_fail() checks.</doc>
        <source-position filename="gtask.h" line="109" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="38429">%TRUE if @result and @source_object are valid, %FALSE
if not</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38421">A #GAsyncResult</doc>
            <type name="AsyncResult" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="source_object" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="sourceObject" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38422">the source object
  expected to be associated with the task</doc>
            <type name="GObject.Object" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38421">A #GAsyncResult</doc>
            <type name="AsyncResult" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="source_object" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="sourceObject" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38422">the source object
  expected to be associated with the task</doc>
            <type name="GObject.Object" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="report_error" c:identifier="g_task_report_error" version="2.36" gs:dll-name="gio-2.0" gs:managed-name="ReportError">
        <doc xml:space="preserve" filename="gio-2.0.c" line="38542">Creates a #GTask and then immediately calls g_task_return_error()
on it. Use this in the wrapper function of an asynchronous method
when you want to avoid even calling the virtual method. You can
then use g_async_result_is_tagged() in the finish method wrapper to
check if the result there is tagged as having been created by the
wrapper method, and deal with it appropriately if so.

See also g_task_report_new_error().</doc>
        <source-position filename="gtask.h" line="49" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <parameter name="source_object" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="sourceObject" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38544">the #GObject that owns
  this task, or %NULL.</doc>
            <type name="GObject.Object" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="2" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38546">a #GAsyncReadyCallback.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="callback_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="callbackData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38547">user data passed to @callback.</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="source_tag" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="sourceTag" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38548">an opaque pointer indicating the source of this task</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="error" transfer-ownership="full" gs:managed-name="error" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38549">error to report</doc>
            <type name="GLib.Error" c:type="GError*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="source_object" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="sourceObject" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38544">the #GObject that owns
  this task, or %NULL.</doc>
            <type name="GObject.Object" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="2" gs:managed-name="callback" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38546">a #GAsyncReadyCallback.</doc>
            <type name="AsyncReadyCallback" c:type="GAsyncReadyCallback" />
          </parameter>
          <parameter name="source_tag" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="sourceTag" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38548">an opaque pointer indicating the source of this task</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="error" transfer-ownership="full" gs:managed-name="error" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38549">error to report</doc>
            <type name="GLib.Error" c:type="GError*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <gs:managed-property name="get_cancellable" version="2.36" gs:dll-name="gio-2.0" gs:managed-name="Cancellable">
        <doc xml:space="preserve" filename="gio-2.0.c" line="38289">Gets @task's #GCancellable</doc>
        <source-position filename="gtask.h" line="100" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="38295">@task's #GCancellable</doc>
          <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none" gs:managed-name="task" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38291">a #GTask</doc>
            <type name="Task" c:type="GTask*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_cancellable" c:identifier="g_task_get_cancellable" version="2.36" gs:dll-name="gio-2.0" gs:managed-name="GetCancellable" gs:property-getter-for="Cancellable" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="38289">Gets @task's #GCancellable</doc>
        <source-position filename="gtask.h" line="100" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="38295">@task's #GCancellable</doc>
          <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none" gs:managed-name="task" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38291">a #GTask</doc>
            <type name="Task" c:type="GTask*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_check_cancellable" version="2.36" gs:dll-name="gio-2.0" gs:managed-name="CheckCancellable">
        <doc xml:space="preserve" filename="gio-2.0.c" line="38300">Gets @task's check-cancellable flag. See
g_task_set_check_cancellable() for more details.</doc>
        <source-position filename="gtask.h" line="102" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none" gs:managed-name="task" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38302">the #GTask</doc>
            <type name="Task" c:type="GTask*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_check_cancellable" c:identifier="g_task_get_check_cancellable" version="2.36" gs:dll-name="gio-2.0" gs:managed-name="GetCheckCancellable" gs:property-getter-for="CheckCancellable" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="38300">Gets @task's check-cancellable flag. See
g_task_set_check_cancellable() for more details.</doc>
        <source-position filename="gtask.h" line="102" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none" gs:managed-name="task" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38302">the #GTask</doc>
            <type name="Task" c:type="GTask*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_completed" version="2.44" gs:dll-name="gio-2.0" gs:managed-name="Completed">
        <doc xml:space="preserve" filename="gio-2.0.c" line="38311">Gets the value of #GTask:completed. This changes from %FALSE to %TRUE after
the task’s callback is invoked, and will return %FALSE if called from inside
the callback.</doc>
        <source-position filename="gtask.h" line="178" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="38319">%TRUE if the task has completed, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none" gs:managed-name="task" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38313">a #GTask.</doc>
            <type name="Task" c:type="GTask*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_completed" c:identifier="g_task_get_completed" version="2.44" gs:dll-name="gio-2.0" gs:managed-name="GetCompleted" gs:property-getter-for="Completed" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="38311">Gets the value of #GTask:completed. This changes from %FALSE to %TRUE after
the task’s callback is invoked, and will return %FALSE if called from inside
the callback.</doc>
        <source-position filename="gtask.h" line="178" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="38319">%TRUE if the task has completed, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none" gs:managed-name="task" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38313">a #GTask.</doc>
            <type name="Task" c:type="GTask*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_context" version="2.36" gs:dll-name="gio-2.0" gs:managed-name="Context">
        <doc xml:space="preserve" filename="gio-2.0.c" line="38324">Gets the #GMainContext that @task will return its result in (that
is, the context that was the
[thread-default main context][g-main-context-push-thread-default]
at the point when @task was created).

This will always return a non-%NULL value, even if the task's
context is the default #GMainContext.</doc>
        <source-position filename="gtask.h" line="98" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="38336">@task's #GMainContext</doc>
          <type name="GLib.MainContext" c:type="GMainContext*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none" gs:managed-name="task" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38326">a #GTask</doc>
            <type name="Task" c:type="GTask*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_context" c:identifier="g_task_get_context" version="2.36" gs:dll-name="gio-2.0" gs:managed-name="GetContext" gs:property-getter-for="Context" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="38324">Gets the #GMainContext that @task will return its result in (that
is, the context that was the
[thread-default main context][g-main-context-push-thread-default]
at the point when @task was created).

This will always return a non-%NULL value, even if the task's
context is the default #GMainContext.</doc>
        <source-position filename="gtask.h" line="98" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="38336">@task's #GMainContext</doc>
          <type name="GLib.MainContext" c:type="GMainContext*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none" gs:managed-name="task" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38326">a #GTask</doc>
            <type name="Task" c:type="GTask*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_name" version="2.60" gs:dll-name="gio-2.0" gs:managed-name="Name">
        <doc xml:space="preserve" filename="gio-2.0.c" line="38341">Gets @task’s name. See g_task_set_name().</doc>
        <source-position filename="gtask.h" line="106" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="38347">@task’s name, or %NULL</doc>
          <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none" gs:managed-name="task" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38343">a #GTask</doc>
            <type name="Task" c:type="GTask*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_name" c:identifier="g_task_get_name" version="2.60" gs:dll-name="gio-2.0" gs:managed-name="GetName" gs:property-getter-for="Name" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="38341">Gets @task’s name. See g_task_set_name().</doc>
        <source-position filename="gtask.h" line="106" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="38347">@task’s name, or %NULL</doc>
          <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none" gs:managed-name="task" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38343">a #GTask</doc>
            <type name="Task" c:type="GTask*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_priority" version="2.36" gs:dll-name="gio-2.0" gs:managed-name="Priority">
        <doc xml:space="preserve" filename="gio-2.0.c" line="38352">Gets @task's priority</doc>
        <source-position filename="gtask.h" line="96" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="38358">@task's priority</doc>
          <type name="gint" c:type="gint" />
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none" gs:managed-name="task" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38354">a #GTask</doc>
            <type name="Task" c:type="GTask*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_priority" c:identifier="g_task_get_priority" version="2.36" gs:dll-name="gio-2.0" gs:managed-name="GetPriority" gs:property-getter-for="Priority" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="38352">Gets @task's priority</doc>
        <source-position filename="gtask.h" line="96" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="38358">@task's priority</doc>
          <type name="gint" c:type="gint" />
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none" gs:managed-name="task" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38354">a #GTask</doc>
            <type name="Task" c:type="GTask*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_return_on_cancel" version="2.36" gs:dll-name="gio-2.0" gs:managed-name="ReturnOnCancel">
        <doc xml:space="preserve" filename="gio-2.0.c" line="38363">Gets @task's return-on-cancel flag. See
g_task_set_return_on_cancel() for more details.</doc>
        <source-position filename="gtask.h" line="127" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none" gs:managed-name="task" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38365">the #GTask</doc>
            <type name="Task" c:type="GTask*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_return_on_cancel" c:identifier="g_task_get_return_on_cancel" version="2.36" gs:dll-name="gio-2.0" gs:managed-name="GetReturnOnCancel" gs:property-getter-for="ReturnOnCancel" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="38363">Gets @task's return-on-cancel flag. See
g_task_set_return_on_cancel() for more details.</doc>
        <source-position filename="gtask.h" line="127" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none" gs:managed-name="task" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38365">the #GTask</doc>
            <type name="Task" c:type="GTask*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_source_object" version="2.36" gs:dll-name="gio-2.0" gs:managed-name="SourceObject">
        <doc xml:space="preserve" filename="gio-2.0.c" line="38374">Gets the source object from @task. Like
g_async_result_get_source_object(), but does not ref the object.</doc>
        <source-position filename="gtask.h" line="92" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="38381">@task's source object, or %NULL</doc>
          <type name="GObject.Object" c:type="gpointer" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none" gs:managed-name="task" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38376">a #GTask</doc>
            <type name="Task" c:type="GTask*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_source_object" c:identifier="g_task_get_source_object" version="2.36" gs:dll-name="gio-2.0" gs:managed-name="GetSourceObject" gs:property-getter-for="SourceObject" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="38374">Gets the source object from @task. Like
g_async_result_get_source_object(), but does not ref the object.</doc>
        <source-position filename="gtask.h" line="92" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="38381">@task's source object, or %NULL</doc>
          <type name="GObject.Object" c:type="gpointer" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none" gs:managed-name="task" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38376">a #GTask</doc>
            <type name="Task" c:type="GTask*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_source_tag" version="2.36" gs:dll-name="gio-2.0" gs:managed-name="SourceTag">
        <doc xml:space="preserve" filename="gio-2.0.c" line="38386">Gets @task's source tag. See g_task_set_source_tag().</doc>
        <source-position filename="gtask.h" line="104" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="38392">@task's source tag</doc>
          <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none" gs:managed-name="task" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38388">a #GTask</doc>
            <type name="Task" c:type="GTask*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_source_tag" c:identifier="g_task_get_source_tag" version="2.36" gs:dll-name="gio-2.0" gs:managed-name="GetSourceTag" gs:property-getter-for="SourceTag" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="38386">Gets @task's source tag. See g_task_set_source_tag().</doc>
        <source-position filename="gtask.h" line="104" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="38392">@task's source tag</doc>
          <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none" gs:managed-name="task" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38388">a #GTask</doc>
            <type name="Task" c:type="GTask*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_task_data" version="2.36" gs:dll-name="gio-2.0" gs:managed-name="TaskData">
        <doc xml:space="preserve" filename="gio-2.0.c" line="38397">Gets @task's `task_data`.</doc>
        <source-position filename="gtask.h" line="94" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="38403">@task's `task_data`.</doc>
          <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none" gs:managed-name="task" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38399">a #GTask</doc>
            <type name="Task" c:type="GTask*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_task_data" c:identifier="g_task_get_task_data" version="2.36" gs:dll-name="gio-2.0" gs:managed-name="GetTaskData" gs:property-getter-for="TaskData" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="38397">Gets @task's `task_data`.</doc>
        <source-position filename="gtask.h" line="94" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="38403">@task's `task_data`.</doc>
          <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none" gs:managed-name="task" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38399">a #GTask</doc>
            <type name="Task" c:type="GTask*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="had_error" c:identifier="g_task_had_error" version="2.36" gs:dll-name="gio-2.0" gs:managed-name="HadError">
        <doc xml:space="preserve" filename="gio-2.0.c" line="38408">Tests if @task resulted in an error.</doc>
        <source-position filename="gtask.h" line="176" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="38414">%TRUE if the task resulted in an error, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none" gs:managed-name="task" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38410">a #GTask.</doc>
            <type name="Task" c:type="GTask*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="propagate_boolean" c:identifier="g_task_propagate_boolean" version="2.36" throws="1" gs:dll-name="gio-2.0" gs:managed-name="PropagateBoolean">
        <doc xml:space="preserve" filename="gio-2.0.c" line="38465">Gets the result of @task as a #gboolean.

If the task resulted in an error, or was cancelled, then this will
instead return %FALSE and set @error.

Since this method transfers ownership of the return value (or
error) to the caller, you may only call it once.</doc>
        <source-position filename="gtask.h" line="166" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="38478">the task result, or %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none" gs:managed-name="task" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38467">a #GTask.</doc>
            <type name="Task" c:type="GTask*" gs:is-pointer="1" />
          </instance-parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="propagate_int" c:identifier="g_task_propagate_int" version="2.36" throws="1" gs:dll-name="gio-2.0" gs:managed-name="PropagateInt">
        <doc xml:space="preserve" filename="gio-2.0.c" line="38483">Gets the result of @task as an integer (#gssize).

If the task resulted in an error, or was cancelled, then this will
instead return -1 and set @error.

Since this method transfers ownership of the return value (or
error) to the caller, you may only call it once.</doc>
        <source-position filename="gtask.h" line="169" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="38496">the task result, or -1 on error</doc>
          <type name="gssize" c:type="gssize" />
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none" gs:managed-name="task" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38485">a #GTask.</doc>
            <type name="Task" c:type="GTask*" gs:is-pointer="1" />
          </instance-parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="propagate_pointer" c:identifier="g_task_propagate_pointer" version="2.36" throws="1" gs:dll-name="gio-2.0" gs:managed-name="PropagatePointer">
        <doc xml:space="preserve" filename="gio-2.0.c" line="38501">Gets the result of @task as a pointer, and transfers ownership
of that value to the caller.

If the task resulted in an error, or was cancelled, then this will
instead return %NULL and set @error.

Since this method transfers ownership of the return value (or
error) to the caller, you may only call it once.</doc>
        <source-position filename="gtask.h" line="163" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="38515">the task result, or %NULL on error</doc>
          <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none" gs:managed-name="task" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38503">a #GTask</doc>
            <type name="Task" c:type="GTask*" gs:is-pointer="1" />
          </instance-parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="propagate_value" c:identifier="g_task_propagate_value" version="2.64" throws="1" gs:dll-name="gio-2.0" gs:managed-name="PropagateValue">
        <doc xml:space="preserve" filename="gio-2.0.c" line="38520">Gets the result of @task as a #GValue, and transfers ownership of
that value to the caller. As with g_task_return_value(), this is
a generic low-level method; g_task_propagate_pointer() and the like
will usually be more useful for C code.

If the task resulted in an error, or was cancelled, then this will
instead set @error and return %FALSE.

Since this method transfers ownership of the return value (or
error) to the caller, you may only call it once.</doc>
        <source-position filename="gtask.h" line="172" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="38537">%TRUE if @task succeeded, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none" gs:managed-name="task" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38522">a #GTask</doc>
            <type name="Task" c:type="GTask*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="value" direction="out" caller-allocates="1" transfer-ownership="none" gs:managed-name="value">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38523">return location for the #GValue</doc>
            <type name="GObject.Value" c:type="GValue*" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="value" direction="out" caller-allocates="1" transfer-ownership="none" gs:managed-name="value">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38523">return location for the #GValue</doc>
            <type name="GObject.Value" c:type="GValue*" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="return_boolean" c:identifier="g_task_return_boolean" version="2.36" gs:dll-name="gio-2.0" gs:managed-name="ReturnBoolean">
        <doc xml:space="preserve" filename="gio-2.0.c" line="38590">Sets @task's result to @result and completes the task (see
g_task_return_pointer() for more discussion of exactly what this
means).</doc>
        <source-position filename="gtask.h" line="140" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none" gs:managed-name="task" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38592">a #GTask.</doc>
            <type name="Task" c:type="GTask*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38593">the #gboolean result of a task function.</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38593">the #gboolean result of a task function.</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="return_error" c:identifier="g_task_return_error" version="2.36" gs:dll-name="gio-2.0" gs:managed-name="ReturnError">
        <doc xml:space="preserve" filename="gio-2.0.c" line="38603">Sets @task's result to @error (which @task assumes ownership of)
and completes the task (see g_task_return_pointer() for more
discussion of exactly what this means).

Note that since the task takes ownership of @error, and since the
task may be completed before returning from g_task_return_error(),
you cannot assume that @error is still valid after calling this.
Call g_error_copy() on the error if you need to keep a local copy
as well.

See also g_task_return_new_error().</doc>
        <source-position filename="gtask.h" line="147" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none" gs:managed-name="task" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38605">a #GTask.</doc>
            <type name="Task" c:type="GTask*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="error" transfer-ownership="full" gs:managed-name="error" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38606">the #GError result of a task function.</doc>
            <type name="GLib.Error" c:type="GError*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="error" transfer-ownership="full" gs:managed-name="error" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38606">the #GError result of a task function.</doc>
            <type name="GLib.Error" c:type="GError*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="return_error_if_cancelled" c:identifier="g_task_return_error_if_cancelled" version="2.36" gs:dll-name="gio-2.0" gs:managed-name="ReturnErrorIfCancelled">
        <doc xml:space="preserve" filename="gio-2.0.c" line="38624">Checks if @task's #GCancellable has been cancelled, and if so, sets
@task's error accordingly and completes the task (see
g_task_return_pointer() for more discussion of exactly what this
means).</doc>
        <source-position filename="gtask.h" line="160" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="38633">%TRUE if @task has been cancelled, %FALSE if not</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none" gs:managed-name="task" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38626">a #GTask</doc>
            <type name="Task" c:type="GTask*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="return_int" c:identifier="g_task_return_int" version="2.36" gs:dll-name="gio-2.0" gs:managed-name="ReturnInt">
        <doc xml:space="preserve" filename="gio-2.0.c" line="38638">Sets @task's result to @result and completes the task (see
g_task_return_pointer() for more discussion of exactly what this
means).</doc>
        <source-position filename="gtask.h" line="143" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none" gs:managed-name="task" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38640">a #GTask.</doc>
            <type name="Task" c:type="GTask*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38641">the integer (#gssize) result of a task function.</doc>
            <type name="gssize" c:type="gssize" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="result" transfer-ownership="none" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38641">the integer (#gssize) result of a task function.</doc>
            <type name="gssize" c:type="gssize" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="return_pointer" c:identifier="g_task_return_pointer" version="2.36" gs:pinvoke-only="1" gs:dll-name="gio-2.0" gs:managed-name="ReturnPointer">
        <doc xml:space="preserve" filename="gio-2.0.c" line="38670">Sets @task's result to @result and completes the task. If @result
is not %NULL, then @result_destroy will be used to free @result if
the caller does not take ownership of it with
g_task_propagate_pointer().

"Completes the task" means that for an ordinary asynchronous task
it will either invoke the task's callback, or else queue that
callback to be invoked in the proper #GMainContext, or in the next
iteration of the current #GMainContext. For a task run via
g_task_run_in_thread() or g_task_run_in_thread_sync(), calling this
method will save @result to be returned to the caller later, but
the task will not actually be completed until the #GTaskThreadFunc
exits.

Note that since the task may be completed before returning from
g_task_return_pointer(), you cannot assume that @result is still
valid after calling this, unless you are still holding another
reference on it.</doc>
        <source-position filename="gtask.h" line="136" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none" gs:managed-name="task" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38672">a #GTask</doc>
            <type name="Task" c:type="GTask*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="full" nullable="1" allow-none="1" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38673">the pointer result of a task
    function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="result_destroy" transfer-ownership="none" nullable="1" allow-none="1" scope="async" gs:managed-name="resultDestroy" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38675">a #GDestroyNotify function.</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="result" transfer-ownership="full" nullable="1" allow-none="1" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38673">the pointer result of a task
    function</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="result_destroy" transfer-ownership="none" nullable="1" allow-none="1" scope="async" gs:managed-name="resultDestroy" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38675">a #GDestroyNotify function.</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="return_value" c:identifier="g_task_return_value" version="2.64" gs:dll-name="gio-2.0" gs:managed-name="ReturnValue">
        <doc xml:space="preserve" filename="gio-2.0.c" line="38700">Sets @task's result to @result (by copying it) and completes the task.

If @result is %NULL then a #GValue of type #G_TYPE_POINTER
with a value of %NULL will be used for the result.

This is a very generic low-level method intended primarily for use
by language bindings; for C code, g_task_return_pointer() and the
like will normally be much easier to use.</doc>
        <source-position filename="gtask.h" line="156" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none" gs:managed-name="task" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38702">a #GTask</doc>
            <type name="Task" c:type="GTask*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="result" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38703">the #GValue result of
                                     a task function</doc>
            <type name="GObject.Value" c:type="GValue*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="result" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="result" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38703">the #GValue result of
                                     a task function</doc>
            <type name="GObject.Value" c:type="GValue*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="run_in_thread" c:identifier="g_task_run_in_thread" version="2.36" gs:pinvoke-only="1" gs:dll-name="gio-2.0" gs:managed-name="RunInThread">
        <doc xml:space="preserve" filename="gio-2.0.c" line="38719">Runs @task_func in another thread. When @task_func returns, @task's
#GAsyncReadyCallback will be invoked in @task's #GMainContext.

This takes a ref on @task until the task completes.

See #GTaskThreadFunc for more details about how @task_func is handled.

Although GLib currently rate-limits the tasks queued via
g_task_run_in_thread(), you should not assume that it will always
do this. If you have a very large number of tasks to run, but don't
want them to all run at once, you should only queue a limited
number of them at a time.</doc>
        <source-position filename="gtask.h" line="118" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none" gs:managed-name="task" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38721">a #GTask</doc>
            <type name="Task" c:type="GTask*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="task_func" transfer-ownership="none" scope="async" gs:managed-name="taskFunc" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38722">a #GTaskThreadFunc</doc>
            <type name="TaskThreadFunc" c:type="GTaskThreadFunc" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="task_func" transfer-ownership="none" scope="async" gs:managed-name="taskFunc" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38722">a #GTaskThreadFunc</doc>
            <type name="TaskThreadFunc" c:type="GTaskThreadFunc" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="run_in_thread_sync" c:identifier="g_task_run_in_thread_sync" version="2.36" gs:pinvoke-only="1" gs:dll-name="gio-2.0" gs:managed-name="RunInThreadSync">
        <doc xml:space="preserve" filename="gio-2.0.c" line="38741">Runs @task_func in another thread, and waits for it to return or be
cancelled. You can use g_task_propagate_pointer(), etc, afterward
to get the result of @task_func.

See #GTaskThreadFunc for more details about how @task_func is handled.

Normally this is used with tasks created with a %NULL
`callback`, but note that even if the task does
have a callback, it will not be invoked when @task_func returns.
#GTask:completed will be set to %TRUE just before this function returns.

Although GLib currently rate-limits the tasks queued via
g_task_run_in_thread_sync(), you should not assume that it will
always do this. If you have a very large number of tasks to run,
but don't want them to all run at once, you should only queue a
limited number of them at a time.</doc>
        <source-position filename="gtask.h" line="121" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none" gs:managed-name="task" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38743">a #GTask</doc>
            <type name="Task" c:type="GTask*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="task_func" transfer-ownership="none" scope="async" gs:managed-name="taskFunc" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38744">a #GTaskThreadFunc</doc>
            <type name="TaskThreadFunc" c:type="GTaskThreadFunc" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="task_func" transfer-ownership="none" scope="async" gs:managed-name="taskFunc" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38744">a #GTaskThreadFunc</doc>
            <type name="TaskThreadFunc" c:type="GTaskThreadFunc" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_check_cancellable" c:identifier="g_task_set_check_cancellable" version="2.36" gs:dll-name="gio-2.0" gs:managed-name="SetCheckCancellable" gs:property-setter-for="CheckCancellable" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="38767">Sets or clears @task's check-cancellable flag. If this is %TRUE
(the default), then g_task_propagate_pointer(), etc, and
g_task_had_error() will check the task's #GCancellable first, and
if it has been cancelled, then they will consider the task to have
returned an "Operation was cancelled" error
(%G_IO_ERROR_CANCELLED), regardless of any other error or return
value the task may have had.

If @check_cancellable is %FALSE, then the #GTask will not check the
cancellable itself, and it is up to @task's owner to do this (eg,
via g_task_return_error_if_cancelled()).

If you are using g_task_set_return_on_cancel() as well, then
you must leave check-cancellable set %TRUE.</doc>
        <source-position filename="gtask.h" line="72" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none" gs:managed-name="task" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38769">the #GTask</doc>
            <type name="Task" c:type="GTask*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="check_cancellable" transfer-ownership="none" gs:managed-name="checkCancellable" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38770">whether #GTask will check the state of
  its #GCancellable for you.</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="check_cancellable" transfer-ownership="none" gs:managed-name="checkCancellable" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38770">whether #GTask will check the state of
  its #GCancellable for you.</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_name" c:identifier="g_task_set_name" version="2.60" gs:dll-name="gio-2.0" gs:managed-name="SetName" gs:property-setter-for="Name" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="38792">Sets @task’s name, used in debugging and profiling. The name defaults to
%NULL.

The task name should describe in a human readable way what the task does.
For example, ‘Open file’ or ‘Connect to network host’. It is used to set the
name of the #GSource used for idle completion of the task.

This function may only be called before the @task is first used in a thread
other than the one it was constructed in.</doc>
        <source-position filename="gtask.h" line="78" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none" gs:managed-name="task" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38794">a #GTask</doc>
            <type name="Task" c:type="GTask*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="name" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38795">a human readable name for the task, or %NULL to unset it</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="name" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38795">a human readable name for the task, or %NULL to unset it</doc>
            <type name="utf8" c:type="const gchar*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_priority" c:identifier="g_task_set_priority" version="2.36" gs:dll-name="gio-2.0" gs:managed-name="SetPriority" gs:property-setter-for="Priority" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="38811">Sets @task's priority. If you do not call this, it will default to
%G_PRIORITY_DEFAULT.

This will affect the priority of #GSources created with
g_task_attach_source() and the scheduling of tasks run in threads,
and can also be explicitly retrieved later via
g_task_get_priority().</doc>
        <source-position filename="gtask.h" line="69" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none" gs:managed-name="task" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38813">the #GTask</doc>
            <type name="Task" c:type="GTask*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="priority" transfer-ownership="none" gs:managed-name="priority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38814">the [priority][io-priority] of the request</doc>
            <type name="gint" c:type="gint" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="priority" transfer-ownership="none" gs:managed-name="priority" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38814">the [priority][io-priority] of the request</doc>
            <type name="gint" c:type="gint" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_return_on_cancel" c:identifier="g_task_set_return_on_cancel" version="2.36" gs:dll-name="gio-2.0" gs:managed-name="SetReturnOnCancel">
        <doc xml:space="preserve" filename="gio-2.0.c" line="38828">Sets or clears @task's return-on-cancel flag. This is only
meaningful for tasks run via g_task_run_in_thread() or
g_task_run_in_thread_sync().

If @return_on_cancel is %TRUE, then cancelling @task's
#GCancellable will immediately cause it to return, as though the
task's #GTaskThreadFunc had called
g_task_return_error_if_cancelled() and then returned.

This allows you to create a cancellable wrapper around an
uninterruptible function. The #GTaskThreadFunc just needs to be
careful that it does not modify any externally-visible state after
it has been cancelled. To do that, the thread should call
g_task_set_return_on_cancel() again to (atomically) set
return-on-cancel %FALSE before making externally-visible changes;
if the task gets cancelled before the return-on-cancel flag could
be changed, g_task_set_return_on_cancel() will indicate this by
returning %FALSE.

You can disable and re-enable this flag multiple times if you wish.
If the task's #GCancellable is cancelled while return-on-cancel is
%FALSE, then calling g_task_set_return_on_cancel() to set it %TRUE
again will cause the task to be cancelled at that point.

If the task's #GCancellable is already cancelled before you call
g_task_run_in_thread()/g_task_run_in_thread_sync(), then the
#GTaskThreadFunc will still be run (for consistency), but the task
will also be completed right away.</doc>
        <source-position filename="gtask.h" line="124" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="38863">%TRUE if @task's return-on-cancel flag was changed to
  match @return_on_cancel. %FALSE if @task has already been
  cancelled.</doc>
          <type name="gboolean" c:type="gboolean" />
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none" gs:managed-name="task" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38830">the #GTask</doc>
            <type name="Task" c:type="GTask*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="return_on_cancel" transfer-ownership="none" gs:managed-name="returnOnCancel" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38831">whether the task returns automatically when
  it is cancelled.</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="return_on_cancel" transfer-ownership="none" gs:managed-name="returnOnCancel" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38831">whether the task returns automatically when
  it is cancelled.</doc>
            <type name="gboolean" c:type="gboolean" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_source_tag" c:identifier="g_task_set_source_tag" version="2.36" gs:dll-name="gio-2.0" gs:managed-name="SetSourceTag" gs:property-setter-for="SourceTag" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="38870">Sets @task's source tag. You can use this to tag a task return
value with a particular pointer (usually a pointer to the function
doing the tagging) and then later check it using
g_task_get_source_tag() (or g_async_result_is_tagged()) in the
task's "finish" function, to figure out if the response came from a
particular place.</doc>
        <source-position filename="gtask.h" line="75" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none" gs:managed-name="task" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38872">the #GTask</doc>
            <type name="Task" c:type="GTask*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="source_tag" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="sourceTag" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38873">an opaque pointer indicating the source of this task</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="source_tag" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="sourceTag" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38873">an opaque pointer indicating the source of this task</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_task_data" c:identifier="g_task_set_task_data" version="2.36" gs:pinvoke-only="1" gs:dll-name="gio-2.0" gs:managed-name="SetTaskData">
        <doc xml:space="preserve" filename="gio-2.0.c" line="38886">Sets @task's task data (freeing the existing task data, if any).</doc>
        <source-position filename="gtask.h" line="65" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="task" transfer-ownership="none" gs:managed-name="task" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38888">the #GTask</doc>
            <type name="Task" c:type="GTask*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="task_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="taskData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38889">task-specific data</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="task_data_destroy" transfer-ownership="none" nullable="1" allow-none="1" scope="async" gs:managed-name="taskDataDestroy" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38890">#GDestroyNotify for @task_data</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="task_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="taskData" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38889">task-specific data</doc>
            <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
          </parameter>
          <parameter name="task_data_destroy" transfer-ownership="none" nullable="1" allow-none="1" scope="async" gs:managed-name="taskDataDestroy" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="38890">#GDestroyNotify for @task_data</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <property name="completed" version="2.44" transfer-ownership="none" gs:managed-name="Completed_">
        <doc xml:space="preserve" filename="gio-2.0.c" line="3454">Whether the task has completed, meaning its callback (if set) has been
invoked. This can only happen after g_task_return_pointer(),
g_task_return_error() or one of the other return functions have been called
on the task.

This property is guaranteed to change from %FALSE to %TRUE exactly once.

The #GObject::notify signal for this change is emitted in the same main
context as the task’s callback, immediately after that callback is invoked.</doc>
        <type name="gboolean" c:type="gboolean" />
      </property>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_task_get_type" gs:access-modifiers="private" gs:dll-name="gio-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </class>
    <record name="TaskClass" c:type="GTaskClass" disguised="1" glib:is-gtype-struct-for="Task" gs:managed-name="TaskClass">
      <source-position filename="gtask.h" line="37" />
    </record>
    <callback name="TaskThreadFunc" c:type="GTaskThreadFunc" version="2.36" gs:pinvoke-only="1" gs:dll-name="gio-2.0" gs:managed-name="TaskThreadFunc">
      <doc xml:space="preserve" filename="gio-2.0.c" line="3471">The prototype for a task function to be run in a thread via
g_task_run_in_thread() or g_task_run_in_thread_sync().

If the return-on-cancel flag is set on @task, and @cancellable gets
cancelled, then the #GTask will be completed immediately (as though
g_task_return_error_if_cancelled() had been called), without
waiting for the task function to complete. However, the task
function will continue running in its thread in the background. The
function therefore needs to be careful about how it uses
externally-visible state in this case. See
g_task_set_return_on_cancel() for more details.

Other than in that case, @task will be completed when the
#GTaskThreadFunc returns, not when it calls a
`g_task_return_` function.</doc>
      <source-position filename="gtask.h" line="113" />
      <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
        <type name="none" c:type="void" />
      </return-value>
      <parameters>
        <parameter name="task" transfer-ownership="none" gs:managed-name="task" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="3473">the #GTask</doc>
          <type name="Task" c:type="GTask*" gs:is-pointer="1" />
        </parameter>
        <parameter name="source_object" transfer-ownership="none" gs:managed-name="sourceObject" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="3474">@task's source object</doc>
          <type name="GObject.Object" c:type="gpointer" gs:is-pointer="1" />
        </parameter>
        <parameter name="task_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="taskData" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="3475">@task's task data</doc>
          <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
        </parameter>
        <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
          <doc xml:space="preserve" filename="gio-2.0.c" line="3476">@task's #GCancellable, or %NULL</doc>
          <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
        </parameter>
      </parameters>
      <gs:managed-parameters>
        <parameter name="task" transfer-ownership="none" gs:managed-name="task" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="3473">the #GTask</doc>
          <type name="Task" c:type="GTask*" gs:is-pointer="1" />
        </parameter>
        <parameter name="source_object" transfer-ownership="none" gs:managed-name="sourceObject" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="3474">@task's source object</doc>
          <type name="GObject.Object" c:type="gpointer" gs:is-pointer="1" />
        </parameter>
        <parameter name="task_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="taskData" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="3475">@task's task data</doc>
          <type name="gpointer" c:type="gpointer" gs:is-pointer="1" />
        </parameter>
        <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
          <doc xml:space="preserve" filename="gio-2.0.c" line="3476">@task's #GCancellable, or %NULL</doc>
          <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
        </parameter>
      </gs:managed-parameters>
    </callback>
    <class name="ThemedIcon" c:symbol-prefix="themed_icon" c:type="GThemedIcon" parent="GObject.Object" glib:type-name="GThemedIcon" glib:get-type="g_themed_icon_get_type" glib:type-struct="ThemedIconClass" gs:managed-name="ThemedIcon">
      <doc xml:space="preserve" filename="gio-2.0.c" line="9464">#GThemedIcon is an implementation of #GIcon that supports icon themes.
#GThemedIcon contains a list of all of the icons present in an icon
theme, so that icons can be looked up quickly. #GThemedIcon does
not provide actual pixmaps for icons, just the icon names.
Ideally something like gtk_icon_theme_choose_icon() should be used to
resolve the list of names so that fallback icons work nicely with
themes that inherit other themes.</doc>
      <source-position filename="gthemedicon.h" line="44" />
      <implements name="Icon" gs:managed-name="Icon" />
      <constructor name="new" c:identifier="g_themed_icon_new" gs:custom-constructor="1" gs:dll-name="gio-2.0" gs:managed-name="New">
        <doc xml:space="preserve" filename="gio-2.0.c" line="39067">Creates a new themed icon for @iconname.</doc>
        <source-position filename="gthemedicon.h" line="50" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="39073">a new #GThemedIcon.</doc>
          <type name="ThemedIcon" c:type="GIcon*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="iconname" transfer-ownership="none" gs:managed-name="iconname" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="39069">a string containing an icon name.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="iconname" transfer-ownership="none" gs:managed-name="iconname" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="39069">a string containing an icon name.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <constructor name="new_from_names" c:identifier="g_themed_icon_new_from_names" gs:dll-name="gio-2.0" gs:managed-name="NewFromNames">
        <doc xml:space="preserve" filename="gio-2.0.c" line="39077">Creates a new themed icon for @iconnames.</doc>
        <source-position filename="gthemedicon.h" line="54" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="39085">a new #GThemedIcon</doc>
          <type name="ThemedIcon" c:type="GIcon*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="iconnames" transfer-ownership="none" gs:managed-name="iconnames" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="39079">an array of strings containing icon names.</doc>
            <array length="1" zero-terminated="0" c:type="char**" gs:is-pointer="1">
              <type name="utf8" c:type="char*" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none" gs:managed-name="len" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="39080">the length of the @iconnames array, or -1 if @iconnames is
    %NULL-terminated</doc>
            <type name="gint" c:type="int" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="iconnames" transfer-ownership="none" gs:managed-name="iconnames" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="39079">an array of strings containing icon names.</doc>
            <array length="1" zero-terminated="0" c:type="char**" gs:is-pointer="1">
              <type name="utf8" c:type="char*" gs:is-pointer="1" />
            </array>
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <constructor name="new_with_default_fallbacks" c:identifier="g_themed_icon_new_with_default_fallbacks" gs:custom-constructor="1" gs:dll-name="gio-2.0" gs:managed-name="NewWithDefaultFallbacks">
        <doc xml:space="preserve" filename="gio-2.0.c" line="39089">Creates a new themed icon for @iconname, and all the names
that can be created by shortening @iconname at '-' characters.

In the following example, @icon1 and @icon2 are equivalent:
|[&lt;!-- language="C" --&gt;
const char *names[] = {
  "gnome-dev-cdrom-audio",
  "gnome-dev-cdrom",
  "gnome-dev",
  "gnome"
};

icon1 = g_themed_icon_new_from_names (names, 4);
icon2 = g_themed_icon_new_with_default_fallbacks ("gnome-dev-cdrom-audio");
]|</doc>
        <source-position filename="gthemedicon.h" line="52" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="39109">a new #GThemedIcon.</doc>
          <type name="ThemedIcon" c:type="GIcon*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="iconname" transfer-ownership="none" gs:managed-name="iconname" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="39091">a string containing an icon name</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="iconname" transfer-ownership="none" gs:managed-name="iconname" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="39091">a string containing an icon name</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <method name="append_name" c:identifier="g_themed_icon_append_name" gs:dll-name="gio-2.0" gs:managed-name="AppendName">
        <doc xml:space="preserve" filename="gio-2.0.c" line="39045">Append a name to the list of icons from within @icon.

Note that doing so invalidates the hash computed by prior calls
to g_icon_hash().</doc>
        <source-position filename="gthemedicon.h" line="60" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="icon" transfer-ownership="none" gs:managed-name="icon" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="39047">a #GThemedIcon</doc>
            <type name="ThemedIcon" c:type="GThemedIcon*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="iconname" transfer-ownership="none" gs:managed-name="iconname" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="39048">name of icon to append to list of icons from within @icon.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="iconname" transfer-ownership="none" gs:managed-name="iconname" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="39048">name of icon to append to list of icons from within @icon.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <gs:managed-property name="get_names" gs:dll-name="gio-2.0" gs:managed-name="Names">
        <doc xml:space="preserve" filename="gio-2.0.c" line="39057">Gets the names of icons from within @icon.</doc>
        <source-position filename="gthemedicon.h" line="64" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="39063">a list of icon names.</doc>
          <array c:type="const gchar* const*" zero-terminated="1" gs:is-pointer="1">
            <type name="utf8" gs:is-pointer="1" />
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="icon" transfer-ownership="none" gs:managed-name="icon" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="39059">a #GThemedIcon.</doc>
            <type name="ThemedIcon" c:type="GThemedIcon*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_names" c:identifier="g_themed_icon_get_names" gs:dll-name="gio-2.0" gs:managed-name="GetNames" gs:property-getter-for="Names" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gio-2.0.c" line="39057">Gets the names of icons from within @icon.</doc>
        <source-position filename="gthemedicon.h" line="64" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="39063">a list of icon names.</doc>
          <array c:type="const gchar* const*" zero-terminated="1" gs:is-pointer="1">
            <type name="utf8" gs:is-pointer="1" />
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="icon" transfer-ownership="none" gs:managed-name="icon" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="39059">a #GThemedIcon.</doc>
            <type name="ThemedIcon" c:type="GThemedIcon*" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="prepend_name" c:identifier="g_themed_icon_prepend_name" version="2.18" gs:dll-name="gio-2.0" gs:managed-name="PrependName">
        <doc xml:space="preserve" filename="gio-2.0.c" line="39113">Prepend a name to the list of icons from within @icon.

Note that doing so invalidates the hash computed by prior calls
to g_icon_hash().</doc>
        <source-position filename="gthemedicon.h" line="57" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" />
        </return-value>
        <parameters>
          <instance-parameter name="icon" transfer-ownership="none" gs:managed-name="icon" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="39115">a #GThemedIcon</doc>
            <type name="ThemedIcon" c:type="GThemedIcon*" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="iconname" transfer-ownership="none" gs:managed-name="iconname" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="39116">name of icon to prepend to list of icons from within @icon.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="iconname" transfer-ownership="none" gs:managed-name="iconname" direction="in">
            <doc xml:space="preserve" filename="gio-2.0.c" line="39116">name of icon to prepend to list of icons from within @icon.</doc>
            <type name="utf8" c:type="const char*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <property name="name" readable="0" writable="1" construct-only="1" transfer-ownership="none" gs:managed-name="Name">
        <doc xml:space="preserve" filename="gio-2.0.c" line="3525">The icon name.</doc>
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </property>
      <property name="names" writable="1" construct-only="1" transfer-ownership="none" gs:managed-name="Names_">
        <doc xml:space="preserve" filename="gio-2.0.c" line="3532">A %NULL-terminated array of icon names.</doc>
        <array zero-terminated="1" gs:is-pointer="1">
          <type name="utf8" gs:is-pointer="1" />
        </array>
      </property>
      <property name="use-default-fallbacks" writable="1" construct-only="1" transfer-ownership="none" gs:managed-name="UseDefaultFallbacks">
        <doc xml:space="preserve" filename="gio-2.0.c" line="3539">Whether to use the default fallbacks found by shortening the icon name
at '-' characters. If the "names" array has more than one element,
ignores any past the first.

For example, if the icon name was "gnome-dev-cdrom-audio", the array
would become
|[&lt;!-- language="C" --&gt;
{
  "gnome-dev-cdrom-audio",
  "gnome-dev-cdrom",
  "gnome-dev",
  "gnome",
  NULL
};
]|</doc>
        <type name="gboolean" c:type="gboolean" />
      </property>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_themed_icon_get_type" gs:access-modifiers="private" gs:dll-name="gio-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </class>
    <record name="ThemedIconClass" c:type="GThemedIconClass" disguised="1" glib:is-gtype-struct-for="ThemedIcon" gs:managed-name="ThemedIconClass">
      <source-position filename="gthemedicon.h" line="44" />
    </record>
    <docsection name="extensionpoints" gs:managed-name="Extensionpoints">
      <doc xml:space="preserve" filename="gio-2.0.c" line="4459">#GIOExtensionPoint provides a mechanism for modules to extend the
functionality of the library or application that loaded it in an
organized fashion.

An extension point is identified by a name, and it may optionally
require that any implementation must be of a certain type (or derived
thereof). Use g_io_extension_point_register() to register an
extension point, and g_io_extension_point_set_required_type() to
set a required type.

A module can implement an extension point by specifying the #GType
that implements the functionality. Additionally, each implementation
of an extension point has a name, and a priority. Use
g_io_extension_point_implement() to implement an extension point.

 |[&lt;!-- language="C" --&gt;
 GIOExtensionPoint *ep;

 // Register an extension point
 ep = g_io_extension_point_register ("my-extension-point");
 g_io_extension_point_set_required_type (ep, MY_TYPE_EXAMPLE);
 ]|

 |[&lt;!-- language="C" --&gt;
 // Implement an extension point
 G_DEFINE_TYPE (MyExampleImpl, my_example_impl, MY_TYPE_EXAMPLE)
 g_io_extension_point_implement ("my-extension-point",
                                 my_example_impl_get_type (),
                                 "my-example",
                                 10);
 ]|

 It is up to the code that registered the extension point how
 it uses the implementations that have been associated with it.
 Depending on the use case, it may use all implementations, or
 only the one with the highest priority, or pick a specific
 one by name.

 To avoid opening all modules just to find out what extension
 points they implement, GIO makes use of a caching mechanism,
 see [gio-querymodules][gio-querymodules].
 You are expected to run this command after installing a
 GIO module.

 The `GIO_EXTRA_MODULES` environment variable can be used to
 specify additional directories to automatically load modules
 from. This environment variable has the same syntax as the
 `PATH`. If two modules have the same base name in different
 directories, then the latter one will be ignored. If additional
 directories are specified GIO will load modules from the built-in
 directory last.</doc>
    </docsection>
    <docsection name="gactiongroupexporter" gs:managed-name="Gactiongroupexporter">
      <doc xml:space="preserve" filename="gio-2.0.c" line="4612">These functions support exporting a #GActionGroup on D-Bus.
The D-Bus interface that is used is a private implementation
detail.

To access an exported #GActionGroup remotely, use
g_dbus_action_group_get() to obtain a #GDBusActionGroup.</doc>
    </docsection>
    <docsection name="gcontenttype" gs:managed-name="Gcontenttype">
      <doc xml:space="preserve" filename="gio-2.0.c" line="5299">A content type is a platform specific string that defines the type
of a file. On UNIX it is a
[MIME type](http://www.wikipedia.org/wiki/Internet_media_type)
like `text/plain` or `image/png`.
On Win32 it is an extension string like `.doc`, `.txt` or a perceived
string like `audio`. Such strings can be looked up in the registry at
`HKEY_CLASSES_ROOT`.
On macOS it is a [Uniform Type Identifier](https://en.wikipedia.org/wiki/Uniform_Type_Identifier)
such as `com.apple.application`.</doc>
    </docsection>
    <docsection name="gdbusaddress" gs:managed-name="Gdbusaddress">
      <doc xml:space="preserve" filename="gio-2.0.c" line="5497">Routines for working with D-Bus addresses. A D-Bus address is a string
like `unix:tmpdir=/tmp/my-app-name`. The exact format of addresses
is explained in detail in the
[D-Bus specification](http://dbus.freedesktop.org/doc/dbus-specification.html#addresses).

TCP D-Bus connections are supported, but accessing them via a proxy is
currently not supported.</doc>
    </docsection>
    <docsection name="gdbuserror" gs:managed-name="Gdbuserror">
      <doc xml:space="preserve" filename="gio-2.0.c" line="5640">All facilities that return errors from remote methods (such as
g_dbus_connection_call_sync()) use #GError to represent both D-Bus
errors (e.g. errors returned from the other peer) and locally
in-process generated errors.

To check if a returned #GError is an error from a remote peer, use
g_dbus_error_is_remote_error(). To get the actual D-Bus error name,
use g_dbus_error_get_remote_error(). Before presenting an error,
always use g_dbus_error_strip_remote_error().

In addition, facilities used to return errors to a remote peer also
use #GError. See g_dbus_method_invocation_return_error() for
discussion about how the D-Bus error name is set.

Applications can associate a #GError error domain with a set of D-Bus errors in order to
automatically map from D-Bus errors to #GError and back. This
is typically done in the function returning the #GQuark for the
error domain:
|[&lt;!-- language="C" --&gt;
// foo-bar-error.h:

#define FOO_BAR_ERROR (foo_bar_error_quark ())
GQuark foo_bar_error_quark (void);

typedef enum
{
  FOO_BAR_ERROR_FAILED,
  FOO_BAR_ERROR_ANOTHER_ERROR,
  FOO_BAR_ERROR_SOME_THIRD_ERROR,
  FOO_BAR_N_ERRORS / *&lt; skip &gt;* /
} FooBarError;

// foo-bar-error.c:

static const GDBusErrorEntry foo_bar_error_entries[] =
{
  {FOO_BAR_ERROR_FAILED,           "org.project.Foo.Bar.Error.Failed"},
  {FOO_BAR_ERROR_ANOTHER_ERROR,    "org.project.Foo.Bar.Error.AnotherError"},
  {FOO_BAR_ERROR_SOME_THIRD_ERROR, "org.project.Foo.Bar.Error.SomeThirdError"},
};

// Ensure that every error code has an associated D-Bus error name
G_STATIC_ASSERT (G_N_ELEMENTS (foo_bar_error_entries) == FOO_BAR_N_ERRORS);

GQuark
foo_bar_error_quark (void)
{
  static gsize quark = 0;
  g_dbus_error_register_error_domain ("foo-bar-error-quark",
                                      &amp;quark,
                                      foo_bar_error_entries,
                                      G_N_ELEMENTS (foo_bar_error_entries));
  return (GQuark) quark;
}
]|
With this setup, a D-Bus peer can transparently pass e.g. %FOO_BAR_ERROR_ANOTHER_ERROR and
other peers will see the D-Bus error name org.project.Foo.Bar.Error.AnotherError.

If the other peer is using GDBus, and has registered the association with
g_dbus_error_register_error_domain() in advance (e.g. by invoking the %FOO_BAR_ERROR quark
generation itself in the previous example) the peer will see also %FOO_BAR_ERROR_ANOTHER_ERROR instead
of %G_IO_ERROR_DBUS_ERROR. Note that GDBus clients can still recover
org.project.Foo.Bar.Error.AnotherError using g_dbus_error_get_remote_error().

Note that the %G_DBUS_ERROR error domain is intended only
for returning errors from a remote message bus process. Errors
generated locally in-process by e.g. #GDBusConnection should use the
%G_IO_ERROR domain.</doc>
    </docsection>
    <docsection name="gdbusintrospection" gs:managed-name="Gdbusintrospection">
      <doc xml:space="preserve" filename="gio-2.0.c" line="5737">Various data structures and convenience routines to parse and
generate D-Bus introspection XML. Introspection information is
used when registering objects with g_dbus_connection_register_object().

The format of D-Bus introspection XML is specified in the
[D-Bus specification](http://dbus.freedesktop.org/doc/dbus-specification.html#introspection-format)</doc>
    </docsection>
    <docsection name="gdbusnameowning" gs:managed-name="Gdbusnameowning">
      <doc xml:space="preserve" filename="gio-2.0.c" line="5790">Convenience API for owning bus names.

A simple example for owning a name can be found in
[gdbus-example-own-name.c](https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-own-name.c)</doc>
    </docsection>
    <docsection name="gdbusnamewatching" gs:managed-name="Gdbusnamewatching">
      <doc xml:space="preserve" filename="gio-2.0.c" line="5803">Convenience API for watching bus names.

A simple example for watching a name can be found in
[gdbus-example-watch-name.c](https://git.gnome.org/browse/glib/tree/gio/tests/gdbus-example-watch-name.c)</doc>
    </docsection>
    <docsection name="gdbusutils" gs:managed-name="Gdbusutils">
      <doc xml:space="preserve" filename="gio-2.0.c" line="6054">Various utility routines related to D-Bus.</doc>
    </docsection>
    <docsection name="gdesktopappinfo" gs:managed-name="Gdesktopappinfo">
      <doc xml:space="preserve" filename="gio-2.0.c" line="6064">#GDesktopAppInfo is an implementation of #GAppInfo based on
desktop files.

Note that `&lt;gio/gdesktopappinfo.h&gt;` belongs to the UNIX-specific
GIO interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config
file when using it.</doc>
    </docsection>
    <docsection name="gfileattribute" gs:managed-name="Gfileattribute">
      <doc xml:space="preserve" filename="gio-2.0.c" line="6286">File attributes in GIO consist of a list of key-value pairs.

Keys are strings that contain a key namespace and a key name, separated
by a colon, e.g. "namespace::keyname". Namespaces are included to sort
key-value pairs by namespaces for relevance. Keys can be retrieved
using wildcards, e.g. "standard::*" will return all of the keys in the
"standard" namespace.

The list of possible attributes for a filesystem (pointed to by a #GFile) is
available as a #GFileAttributeInfoList. This list is queryable by key names
as indicated earlier.

Information is stored within the list in #GFileAttributeInfo structures.
The info structure can store different types, listed in the enum
#GFileAttributeType. Upon creation of a #GFileAttributeInfo, the type will
be set to %G_FILE_ATTRIBUTE_TYPE_INVALID.

Classes that implement #GFileIface will create a #GFileAttributeInfoList and
install default keys and values for their given file system, architecture,
and other possible implementation details (e.g., on a UNIX system, a file
attribute key will be registered for the user id for a given file).

## Default Namespaces

- `"standard"`: The "Standard" namespace. General file information that
  any application may need should be put in this namespace. Examples
  include the file's name, type, and size.
- `"etag`: The [Entity Tag][gfile-etag] namespace. Currently, the only key
  in this namespace is "value", which contains the value of the current
  entity tag.
- `"id"`: The "Identification" namespace. This namespace is used by file
  managers and applications that list directories to check for loops and
  to uniquely identify files.
- `"access"`: The "Access" namespace. Used to check if a user has the
  proper privileges to access files and perform file operations. Keys in
  this namespace are made to be generic and easily understood, e.g. the
  "can_read" key is %TRUE if the current user has permission to read the
  file. UNIX permissions and NTFS ACLs in Windows should be mapped to
  these values.
- `"mountable"`: The "Mountable" namespace. Includes simple boolean keys
  for checking if a file or path supports mount operations, e.g. mount,
  unmount, eject. These are used for files of type %G_FILE_TYPE_MOUNTABLE.
- `"time"`: The "Time" namespace. Includes file access, changed, created
  times.
- `"unix"`: The "Unix" namespace. Includes UNIX-specific information and
  may not be available for all files. Examples include the UNIX "UID",
  "GID", etc.
- `"dos"`: The "DOS" namespace. Includes DOS-specific information and may
  not be available for all files. Examples include "is_system" for checking
  if a file is marked as a system file, and "is_archive" for checking if a
  file is marked as an archive file.
- `"owner"`: The "Owner" namespace. Includes information about who owns a
  file. May not be available for all file systems. Examples include "user"
  for getting the user name of the file owner. This information is often
  mapped from some backend specific data such as a UNIX UID.
- `"thumbnail"`: The "Thumbnail" namespace. Includes information about file
  thumbnails and their location within the file system. Examples of keys in
  this namespace include "path" to get the location of a thumbnail, "failed"
  to check if thumbnailing of the file failed, and "is-valid" to check if
  the thumbnail is outdated.
- `"filesystem"`: The "Filesystem" namespace. Gets information about the
  file system where a file is located, such as its type, how much space is
  left available, and the overall size of the file system.
- `"gvfs"`: The "GVFS" namespace. Keys in this namespace contain information
  about the current GVFS backend in use.
- `"xattr"`: The "xattr" namespace. Gets information about extended
  user attributes. See attr(5). The "user." prefix of the extended user
  attribute name is stripped away when constructing keys in this namespace,
  e.g. "xattr::mime_type" for the extended attribute with the name
  "user.mime_type". Note that this information is only available if
  GLib has been built with extended attribute support.
- `"xattr-sys"`: The "xattr-sys" namespace. Gets information about
  extended attributes which are not user-specific. See attr(5). Note
  that this information is only available if GLib has been built with
  extended attribute support.
- `"selinux"`: The "SELinux" namespace. Includes information about the
  SELinux context of files. Note that this information is only available
  if GLib has been built with SELinux support.

Please note that these are not all of the possible namespaces.
More namespaces can be added from GIO modules or by individual applications.
For more information about writing GIO modules, see #GIOModule.

&lt;!-- TODO: Implementation note about using extended attributes on supported
file systems --&gt;

## Default Keys

For a list of the built-in keys and their types, see the
[GFileInfo][GFileInfo] documentation.

Note that there are no predefined keys in the "xattr" and "xattr-sys"
namespaces. Keys for the "xattr" namespace are constructed by stripping
away the "user." prefix from the extended user attribute, and prepending
"xattr::". Keys for the "xattr-sys" namespace are constructed by
concatenating "xattr-sys::" with the extended attribute name. All extended
attribute values are returned as hex-encoded strings in which bytes outside
the ASCII range are encoded as escape sequences of the form \x`nn`
where `nn` is a 2-digit hexadecimal number.</doc>
    </docsection>
    <docsection name="gioerror" gs:managed-name="Gioerror">
      <doc xml:space="preserve" filename="gio-2.0.c" line="6746">Contains helper functions for reporting errors to the user.</doc>
    </docsection>
    <docsection name="gioscheduler" gs:managed-name="Gioscheduler">
      <doc xml:space="preserve" filename="gio-2.0.c" line="6766">As of GLib 2.36, #GIOScheduler is deprecated in favor of
#GThreadPool and #GTask.

Schedules asynchronous I/O operations. #GIOScheduler integrates
into the main event loop (#GMainLoop) and uses threads.</doc>
    </docsection>
    <docsection name="gmenuexporter" gs:managed-name="Gmenuexporter">
      <doc xml:space="preserve" filename="gio-2.0.c" line="7019">These functions support exporting a #GMenuModel on D-Bus.
The D-Bus interface that is used is a private implementation
detail.

To access an exported #GMenuModel remotely, use
g_dbus_menu_model_get() to obtain a #GDBusMenuModel.</doc>
    </docsection>
    <docsection name="gnetworking" gs:managed-name="Gnetworking">
      <doc xml:space="preserve" filename="gio-2.0.c" line="7242">The `&lt;gio/gnetworking.h&gt;` header can be included to get
various low-level networking-related system headers, automatically
taking care of certain portability issues for you.

This can be used, for example, if you want to call setsockopt()
on a #GSocket.

Note that while WinSock has many of the same APIs as the
traditional UNIX socket API, most of them behave at least slightly
differently (particularly with respect to error handling). If you
want your code to work under both UNIX and Windows, you will need
to take these differences into account.

Also, under GNU libc, certain non-portable functions are only visible
in the headers if you define %_GNU_SOURCE before including them. Note
that this symbol must be defined before including any headers, or it
may not take effect.</doc>
    </docsection>
    <docsection name="gpollableutils" gs:managed-name="Gpollableutils">
      <doc xml:space="preserve" filename="gio-2.0.c" line="7405">Utility functions for #GPollableInputStream and
#GPollableOutputStream implementations.</doc>
    </docsection>
    <docsection name="gtls" gs:managed-name="Gtls">
      <doc xml:space="preserve" filename="gio-2.0.c" line="9505">#GTlsConnection and related classes provide TLS (Transport Layer
Security, previously known as SSL, Secure Sockets Layer) support for
gio-based network streams.

#GDtlsConnection and related classes provide DTLS (Datagram TLS) support for
GIO-based network sockets, using the #GDatagramBased interface. The TLS and
DTLS APIs are almost identical, except TLS is stream-based and DTLS is
datagram-based. They share certificate and backend infrastructure.

In the simplest case, for a client TLS connection, you can just set the
#GSocketClient:tls flag on a #GSocketClient, and then any
connections created by that client will have TLS negotiated
automatically, using appropriate default settings, and rejecting
any invalid or self-signed certificates (unless you change that
default by setting the #GSocketClient:tls-validation-flags
property). The returned object will be a #GTcpWrapperConnection,
which wraps the underlying #GTlsClientConnection.

For greater control, you can create your own #GTlsClientConnection,
wrapping a #GSocketConnection (or an arbitrary #GIOStream with
pollable input and output streams) and then connect to its signals,
such as #GTlsConnection::accept-certificate, before starting the
handshake.

Server-side TLS is similar, using #GTlsServerConnection. At the
moment, there is no support for automatically wrapping server-side
connections in the way #GSocketClient does for client-side
connections.</doc>
    </docsection>
    <docsection name="gunixmounts" gs:managed-name="Gunixmounts">
      <doc xml:space="preserve" filename="gio-2.0.c" line="9782">Routines for managing mounted UNIX mount points and paths.

Note that `&lt;gio/gunixmounts.h&gt;` belongs to the UNIX-specific GIO
interfaces, thus you have to use the `gio-unix-2.0.pc` pkg-config
file when using it.</doc>
    </docsection>
    <docsection name="gwin32inputstream" gs:managed-name="Gwin32inputstream">
      <doc xml:space="preserve" filename="gio-2.0.c" line="9913">#GWin32InputStream implements #GInputStream for reading from a
Windows file handle.

Note that `&lt;gio/gwin32inputstream.h&gt;` belongs to the Windows-specific GIO
interfaces, thus you have to use the `gio-windows-2.0.pc` pkg-config file
when using it.</doc>
    </docsection>
    <docsection name="gwin32outputstream" gs:managed-name="Gwin32outputstream">
      <doc xml:space="preserve" filename="gio-2.0.c" line="9928">#GWin32OutputStream implements #GOutputStream for writing to a
Windows file handle.

Note that `&lt;gio/gwin32outputstream.h&gt;` belongs to the Windows-specific GIO
interfaces, thus you have to use the `gio-windows-2.0.pc` pkg-config file
when using it.</doc>
    </docsection>
    <docsection name="gwin32registrykey" gs:managed-name="Gwin32registrykey">
      <doc xml:space="preserve" filename="gio-2.0.c" line="9943">#GWin32RegistryKey represents a single Windows Registry key.

#GWin32RegistryKey is used by a number of helper functions that read
Windows Registry. All keys are opened with read-only access, and at
the moment there is no API for writing into registry keys or creating
new ones.

#GWin32RegistryKey implements the #GInitable interface, so if it is manually
constructed by e.g. g_object_new() you must call g_initable_init() and check
the results before using the object. This is done automatically
in g_win32_registry_key_new() and g_win32_registry_key_get_child(), so these
functions can return %NULL.

To increase efficiency, a UTF-16 variant is available for all functions
that deal with key or value names in the registry. Use these to perform
deep registry queries or other operations that require querying a name
of a key or a value and then opening it (or querying its data). The use
of UTF-16 functions avoids the overhead of converting names to UTF-8 and
back.

All functions operate in current user's context (it is not possible to
access registry tree of a different user).

Key paths must use '\\' as a separator, '/' is not supported. Key names
must not include '\\', because it's used as a separator. Value names
can include '\\'.

Key and value names are not case sensitive.

Full key name (excluding the pre-defined ancestor's name) can't exceed
255 UTF-16 characters, give or take. Value name can't exceed 16383 UTF-16
characters. Tree depth is limited to 512 levels.</doc>
    </docsection>
    <docsection name="gzcompressor" gs:managed-name="Gzcompressor">
      <doc xml:space="preserve" filename="gio-2.0.c" line="9984">#GZlibCompressor is an implementation of #GConverter that
compresses data using zlib.</doc>
    </docsection>
    <docsection name="gzdecompressor" gs:managed-name="Gzdecompressor">
      <doc xml:space="preserve" filename="gio-2.0.c" line="9994">#GZlibDecompressor is an implementation of #GConverter that
decompresses data compressed with zlib.</doc>
    </docsection>
    <gs:static-class name="CancellableSource" gs:managed-name="CancellableSource">
      <function name="new" c:identifier="g_cancellable_source_new" version="2.28" introspectable="1" gs:dll-name="gio-2.0" gs:managed-name="New">
        <doc xml:space="preserve" filename="gio-2.0.c" line="13728">Creates a source that triggers if @cancellable is cancelled and
calls its callback of type #GCancellableSourceFunc. This is
primarily useful for attaching to another (non-cancellable) source
with g_source_add_child_source() to add cancellability to it.

For convenience, you can call this with a %NULL #GCancellable,
in which case the source will never trigger.

The new #GSource will hold a reference to the #GCancellable.</doc>
        <source-position filename="gcancellable.h" line="92" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gio-2.0.c" line="13742">the new #GSource.</doc>
          <type name="GLib.Source" c:type="GSource*" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="13730">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="cancellable" direction="in" gs:default="null">
            <doc xml:space="preserve" filename="gio-2.0.c" line="13730">a #GCancellable, or %NULL</doc>
            <type name="Cancellable" c:type="GCancellable*" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
    </gs:static-class>
    <gs:static-class name="FileAttribute" gs:managed-name="FileAttribute">
      <constant name="ACCESS_CAN_DELETE" value="access::can-delete" c:type="G_FILE_ATTRIBUTE_ACCESS_CAN_DELETE" gs:managed-name="AccessCanDelete">
        <doc xml:space="preserve" filename="gfileinfo.h" line="327">A key in the "access" namespace for checking deletion privileges.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
This attribute will be %TRUE if the user is able to delete the file.</doc>
        <source-position filename="gfileinfo.h" line="334" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="ACCESS_CAN_EXECUTE" value="access::can-execute" c:type="G_FILE_ATTRIBUTE_ACCESS_CAN_EXECUTE" gs:managed-name="AccessCanExecute">
        <doc xml:space="preserve" filename="gfileinfo.h" line="318">A key in the "access" namespace for getting execution privileges.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
This attribute will be %TRUE if the user is able to execute the file.</doc>
        <source-position filename="gfileinfo.h" line="325" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="ACCESS_CAN_READ" value="access::can-read" c:type="G_FILE_ATTRIBUTE_ACCESS_CAN_READ" gs:managed-name="AccessCanRead">
        <doc xml:space="preserve" filename="gfileinfo.h" line="300">A key in the "access" namespace for getting read privileges.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
This attribute will be %TRUE if the user is able to read the file.</doc>
        <source-position filename="gfileinfo.h" line="307" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="ACCESS_CAN_RENAME" value="access::can-rename" c:type="G_FILE_ATTRIBUTE_ACCESS_CAN_RENAME" gs:managed-name="AccessCanRename">
        <doc xml:space="preserve" filename="gfileinfo.h" line="346">A key in the "access" namespace for checking renaming privileges.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
This attribute will be %TRUE if the user is able to rename the file.</doc>
        <source-position filename="gfileinfo.h" line="353" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="ACCESS_CAN_TRASH" value="access::can-trash" c:type="G_FILE_ATTRIBUTE_ACCESS_CAN_TRASH" gs:managed-name="AccessCanTrash">
        <doc xml:space="preserve" filename="gfileinfo.h" line="336">A key in the "access" namespace for checking trashing privileges.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
This attribute will be %TRUE if the user is able to move the file to
the trash.</doc>
        <source-position filename="gfileinfo.h" line="344" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="ACCESS_CAN_WRITE" value="access::can-write" c:type="G_FILE_ATTRIBUTE_ACCESS_CAN_WRITE" gs:managed-name="AccessCanWrite">
        <doc xml:space="preserve" filename="gfileinfo.h" line="309">A key in the "access" namespace for getting write privileges.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.
This attribute will be %TRUE if the user is able to write to the file.</doc>
        <source-position filename="gfileinfo.h" line="316" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="DOS_IS_ARCHIVE" value="dos::is-archive" c:type="G_FILE_ATTRIBUTE_DOS_IS_ARCHIVE" gs:managed-name="DosIsArchive">
        <doc xml:space="preserve" filename="gfileinfo.h" line="660">A key in the "dos" namespace for checking if the file's archive flag
is set. This attribute is %TRUE if the archive flag is set. This attribute
is only available for DOS file systems. Corresponding #GFileAttributeType
is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.</doc>
        <source-position filename="gfileinfo.h" line="668" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="DOS_IS_MOUNTPOINT" value="dos::is-mountpoint" c:type="G_FILE_ATTRIBUTE_DOS_IS_MOUNTPOINT" version="2.60" gs:managed-name="DosIsMountpoint">
        <doc xml:space="preserve" filename="gfileinfo.h" line="680">A key in the "dos" namespace for checking if the file is a NTFS mount point
(a volume mount or a junction point).
This attribute is %TRUE if file is a reparse point of type
[IO_REPARSE_TAG_MOUNT_POINT](https://msdn.microsoft.com/en-us/library/dd541667.aspx).
This attribute is only available for DOS file systems.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.</doc>
        <source-position filename="gfileinfo.h" line="692" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="DOS_IS_SYSTEM" value="dos::is-system" c:type="G_FILE_ATTRIBUTE_DOS_IS_SYSTEM" gs:managed-name="DosIsSystem">
        <doc xml:space="preserve" filename="gfileinfo.h" line="670">A key in the "dos" namespace for checking if the file's backup flag
is set. This attribute is %TRUE if the backup flag is set. This attribute
is only available for DOS file systems. Corresponding #GFileAttributeType
is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.</doc>
        <source-position filename="gfileinfo.h" line="678" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="DOS_REPARSE_POINT_TAG" value="dos::reparse-point-tag" c:type="G_FILE_ATTRIBUTE_DOS_REPARSE_POINT_TAG" version="2.60" gs:managed-name="DosReparsePointTag">
        <doc xml:space="preserve" filename="gfileinfo.h" line="694">A key in the "dos" namespace for getting the file NTFS reparse tag.
This value is 0 for files that are not reparse points.
See the [Reparse Tags](https://msdn.microsoft.com/en-us/library/dd541667.aspx)
page for possible reparse tag values. Corresponding #GFileAttributeType
is %G_FILE_ATTRIBUTE_TYPE_UINT32.</doc>
        <source-position filename="gfileinfo.h" line="705" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="ETAG_VALUE" value="etag::value" c:type="G_FILE_ATTRIBUTE_ETAG_VALUE" gs:managed-name="EtagValue">
        <doc xml:space="preserve" filename="gfileinfo.h" line="264">A key in the "etag" namespace for getting the value of the file's
entity tag. Corresponding #GFileAttributeType is
%G_FILE_ATTRIBUTE_TYPE_STRING.</doc>
        <source-position filename="gfileinfo.h" line="271" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="FILESYSTEM_FREE" value="filesystem::free" c:type="G_FILE_ATTRIBUTE_FILESYSTEM_FREE" gs:managed-name="FilesystemFree">
        <doc xml:space="preserve" filename="gfileinfo.h" line="795">A key in the "filesystem" namespace for getting the number of bytes of free space left on the
file system. Corresponding #GFileAttributeType is
%G_FILE_ATTRIBUTE_TYPE_UINT64.</doc>
        <source-position filename="gfileinfo.h" line="802" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="FILESYSTEM_READONLY" value="filesystem::readonly" c:type="G_FILE_ATTRIBUTE_FILESYSTEM_READONLY" gs:managed-name="FilesystemReadonly">
        <doc xml:space="preserve" filename="gfileinfo.h" line="823">A key in the "filesystem" namespace for checking if the file system
is read only. Is set to %TRUE if the file system is read only.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.</doc>
        <source-position filename="gfileinfo.h" line="830" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="FILESYSTEM_REMOTE" value="filesystem::remote" c:type="G_FILE_ATTRIBUTE_FILESYSTEM_REMOTE" gs:managed-name="FilesystemRemote">
        <doc xml:space="preserve" filename="gfileinfo.h" line="842">A key in the "filesystem" namespace for checking if the file system
is remote. Is set to %TRUE if the file system is remote.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.</doc>
        <source-position filename="gfileinfo.h" line="849" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="FILESYSTEM_SIZE" value="filesystem::size" c:type="G_FILE_ATTRIBUTE_FILESYSTEM_SIZE" gs:managed-name="FilesystemSize">
        <doc xml:space="preserve" filename="gfileinfo.h" line="786">A key in the "filesystem" namespace for getting the total size (in bytes) of the file system,
used in g_file_query_filesystem_info(). Corresponding #GFileAttributeType
is %G_FILE_ATTRIBUTE_TYPE_UINT64.</doc>
        <source-position filename="gfileinfo.h" line="793" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="FILESYSTEM_TYPE" value="filesystem::type" c:type="G_FILE_ATTRIBUTE_FILESYSTEM_TYPE" gs:managed-name="FilesystemType">
        <doc xml:space="preserve" filename="gfileinfo.h" line="815">A key in the "filesystem" namespace for getting the file system's type.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.</doc>
        <source-position filename="gfileinfo.h" line="821" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="FILESYSTEM_USED" value="filesystem::used" c:type="G_FILE_ATTRIBUTE_FILESYSTEM_USED" version="2.32" gs:managed-name="FilesystemUsed">
        <doc xml:space="preserve" filename="gfileinfo.h" line="804">A key in the "filesystem" namespace for getting the number of bytes of used on the
file system. Corresponding #GFileAttributeType is
%G_FILE_ATTRIBUTE_TYPE_UINT64.</doc>
        <source-position filename="gfileinfo.h" line="813" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="FILESYSTEM_USE_PREVIEW" value="filesystem::use-preview" c:type="G_FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW" gs:managed-name="FilesystemUsePreview">
        <doc xml:space="preserve" filename="gfileinfo.h" line="832">A key in the "filesystem" namespace for hinting a file manager
application whether it should preview (e.g. thumbnail) files on the
file system. The value for this key contain a
#GFilesystemPreviewType.</doc>
        <source-position filename="gfileinfo.h" line="840" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="GVFS_BACKEND" value="gvfs::backend" c:type="G_FILE_ATTRIBUTE_GVFS_BACKEND" gs:managed-name="GvfsBackend">
        <doc xml:space="preserve" filename="gfileinfo.h" line="851">A key in the "gvfs" namespace that gets the name of the current
GVFS backend in use. Corresponding #GFileAttributeType is
%G_FILE_ATTRIBUTE_TYPE_STRING.</doc>
        <source-position filename="gfileinfo.h" line="858" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="ID_FILE" value="id::file" c:type="G_FILE_ATTRIBUTE_ID_FILE" gs:managed-name="IdFile">
        <doc xml:space="preserve" filename="gfileinfo.h" line="277">A key in the "id" namespace for getting a file identifier.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
An example use would be during listing files, to avoid recursive
directory scanning.</doc>
        <source-position filename="gfileinfo.h" line="285" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="ID_FILESYSTEM" value="id::filesystem" c:type="G_FILE_ATTRIBUTE_ID_FILESYSTEM" gs:managed-name="IdFilesystem">
        <doc xml:space="preserve" filename="gfileinfo.h" line="287">A key in the "id" namespace for getting the file system identifier.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
An example use would be during drag and drop to see if the source
and target are on the same filesystem (default to move) or not (default
to copy).</doc>
        <source-position filename="gfileinfo.h" line="296" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="MOUNTABLE_CAN_EJECT" value="mountable::can-eject" c:type="G_FILE_ATTRIBUTE_MOUNTABLE_CAN_EJECT" gs:managed-name="MountableCanEject">
        <doc xml:space="preserve" filename="gfileinfo.h" line="375">A key in the "mountable" namespace for checking if a file (of type G_FILE_TYPE_MOUNTABLE) can be ejected.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.</doc>
        <source-position filename="gfileinfo.h" line="381" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="MOUNTABLE_CAN_MOUNT" value="mountable::can-mount" c:type="G_FILE_ATTRIBUTE_MOUNTABLE_CAN_MOUNT" gs:managed-name="MountableCanMount">
        <doc xml:space="preserve" filename="gfileinfo.h" line="359">A key in the "mountable" namespace for checking if a file (of type G_FILE_TYPE_MOUNTABLE) is mountable.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.</doc>
        <source-position filename="gfileinfo.h" line="365" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="MOUNTABLE_CAN_POLL" value="mountable::can-poll" c:type="G_FILE_ATTRIBUTE_MOUNTABLE_CAN_POLL" version="2.22" gs:managed-name="MountableCanPoll">
        <doc xml:space="preserve" filename="gfileinfo.h" line="450">A key in the "mountable" namespace for checking if a file (of type G_FILE_TYPE_MOUNTABLE) can be polled.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.</doc>
        <source-position filename="gfileinfo.h" line="458" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="MOUNTABLE_CAN_START" value="mountable::can-start" c:type="G_FILE_ATTRIBUTE_MOUNTABLE_CAN_START" version="2.22" gs:managed-name="MountableCanStart">
        <doc xml:space="preserve" filename="gfileinfo.h" line="409">A key in the "mountable" namespace for checking if a file (of type G_FILE_TYPE_MOUNTABLE) can be started.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.</doc>
        <source-position filename="gfileinfo.h" line="417" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="MOUNTABLE_CAN_START_DEGRADED" value="mountable::can-start-degraded" c:type="G_FILE_ATTRIBUTE_MOUNTABLE_CAN_START_DEGRADED" version="2.22" gs:managed-name="MountableCanStartDegraded">
        <doc xml:space="preserve" filename="gfileinfo.h" line="419">A key in the "mountable" namespace for checking if a file (of type G_FILE_TYPE_MOUNTABLE) can be started
degraded.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.</doc>
        <source-position filename="gfileinfo.h" line="428" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="MOUNTABLE_CAN_STOP" value="mountable::can-stop" c:type="G_FILE_ATTRIBUTE_MOUNTABLE_CAN_STOP" version="2.22" gs:managed-name="MountableCanStop">
        <doc xml:space="preserve" filename="gfileinfo.h" line="430">A key in the "mountable" namespace for checking if a file (of type G_FILE_TYPE_MOUNTABLE) can be stopped.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.</doc>
        <source-position filename="gfileinfo.h" line="438" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="MOUNTABLE_CAN_UNMOUNT" value="mountable::can-unmount" c:type="G_FILE_ATTRIBUTE_MOUNTABLE_CAN_UNMOUNT" gs:managed-name="MountableCanUnmount">
        <doc xml:space="preserve" filename="gfileinfo.h" line="367">A key in the "mountable" namespace for checking if a file (of type G_FILE_TYPE_MOUNTABLE)  is unmountable.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.</doc>
        <source-position filename="gfileinfo.h" line="373" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="MOUNTABLE_HAL_UDI" value="mountable::hal-udi" c:type="G_FILE_ATTRIBUTE_MOUNTABLE_HAL_UDI" gs:managed-name="MountableHalUdi">
        <doc xml:space="preserve" filename="gfileinfo.h" line="401">A key in the "mountable" namespace for getting the HAL UDI for the mountable
file. Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.</doc>
        <source-position filename="gfileinfo.h" line="407" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="MOUNTABLE_IS_MEDIA_CHECK_AUTOMATIC" value="mountable::is-media-check-automatic" c:type="G_FILE_ATTRIBUTE_MOUNTABLE_IS_MEDIA_CHECK_AUTOMATIC" version="2.22" gs:managed-name="MountableIsMediaCheckAutomatic">
        <doc xml:space="preserve" filename="gfileinfo.h" line="460">A key in the "mountable" namespace for checking if a file (of type G_FILE_TYPE_MOUNTABLE)
is automatically polled for media.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.</doc>
        <source-position filename="gfileinfo.h" line="469" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="MOUNTABLE_START_STOP_TYPE" value="mountable::start-stop-type" c:type="G_FILE_ATTRIBUTE_MOUNTABLE_START_STOP_TYPE" version="2.22" gs:managed-name="MountableStartStopType">
        <doc xml:space="preserve" filename="gfileinfo.h" line="440">A key in the "mountable" namespace for getting the #GDriveStartStopType.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.</doc>
        <source-position filename="gfileinfo.h" line="448" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="MOUNTABLE_UNIX_DEVICE" value="mountable::unix-device" c:type="G_FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE" gs:managed-name="MountableUnixDevice">
        <doc xml:space="preserve" filename="gfileinfo.h" line="383">A key in the "mountable" namespace for getting the unix device.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.</doc>
        <source-position filename="gfileinfo.h" line="389" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="MOUNTABLE_UNIX_DEVICE_FILE" value="mountable::unix-device-file" c:type="G_FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE_FILE" version="2.22" gs:managed-name="MountableUnixDeviceFile">
        <doc xml:space="preserve" filename="gfileinfo.h" line="391">A key in the "mountable" namespace for getting the unix device file.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.</doc>
        <source-position filename="gfileinfo.h" line="399" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="OWNER_GROUP" value="owner::group" c:type="G_FILE_ATTRIBUTE_OWNER_GROUP" gs:managed-name="OwnerGroup">
        <doc xml:space="preserve" filename="gfileinfo.h" line="727">A key in the "owner" namespace for getting the file owner's group.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.</doc>
        <source-position filename="gfileinfo.h" line="733" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="OWNER_USER" value="owner::user" c:type="G_FILE_ATTRIBUTE_OWNER_USER" gs:managed-name="OwnerUser">
        <doc xml:space="preserve" filename="gfileinfo.h" line="709">A key in the "owner" namespace for getting the user name of the
file's owner. Corresponding #GFileAttributeType is
%G_FILE_ATTRIBUTE_TYPE_STRING.</doc>
        <source-position filename="gfileinfo.h" line="716" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="OWNER_USER_REAL" value="owner::user-real" c:type="G_FILE_ATTRIBUTE_OWNER_USER_REAL" gs:managed-name="OwnerUserReal">
        <doc xml:space="preserve" filename="gfileinfo.h" line="718">A key in the "owner" namespace for getting the real name of the
user that owns the file. Corresponding #GFileAttributeType is
%G_FILE_ATTRIBUTE_TYPE_STRING.</doc>
        <source-position filename="gfileinfo.h" line="725" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="PREVIEW_ICON" value="preview::icon" c:type="G_FILE_ATTRIBUTE_PREVIEW_ICON" version="2.20" gs:managed-name="PreviewIcon">
        <doc xml:space="preserve" filename="gfileinfo.h" line="771">A key in the "preview" namespace for getting a #GIcon that can be
used to get preview of the file. For example, it may be a low
resolution thumbnail without metadata. Corresponding
#GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_OBJECT.  The value
for this key should contain a #GIcon.</doc>
        <source-position filename="gfileinfo.h" line="782" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="RECENT_MODIFIED" value="recent::modified" c:type="G_FILE_ATTRIBUTE_RECENT_MODIFIED" version="2.52" gs:managed-name="RecentModified">
        <doc xml:space="preserve" filename="gfileinfo.h" line="903">A key in the "recent" namespace for getting time, when the metadata for the
file in `recent:///` was last changed. Corresponding #GFileAttributeType is
%G_FILE_ATTRIBUTE_TYPE_INT64.</doc>
        <source-position filename="gfileinfo.h" line="912" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="SELINUX_CONTEXT" value="selinux::context" c:type="G_FILE_ATTRIBUTE_SELINUX_CONTEXT" gs:managed-name="SelinuxContext">
        <doc xml:space="preserve" filename="gfileinfo.h" line="860">A key in the "selinux" namespace for getting the file's SELinux
context. Corresponding #GFileAttributeType is
%G_FILE_ATTRIBUTE_TYPE_STRING. Note that this attribute is only
available if GLib has been built with SELinux support.</doc>
        <source-position filename="gfileinfo.h" line="868" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="STANDARD_ALLOCATED_SIZE" value="standard::allocated-size" c:type="G_FILE_ATTRIBUTE_STANDARD_ALLOCATED_SIZE" version="2.20" gs:managed-name="StandardAllocatedSize">
        <doc xml:space="preserve" filename="gfileinfo.h" line="219">A key in the "standard" namespace for getting the amount of disk space
that is consumed by the file (in bytes).  This will generally be larger
than the file size (due to block size overhead) but can occasionally be
smaller (for example, for sparse files).
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64.</doc>
        <source-position filename="gfileinfo.h" line="230" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="STANDARD_CONTENT_TYPE" value="standard::content-type" c:type="G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE" gs:managed-name="StandardContentType">
        <doc xml:space="preserve" filename="gfileinfo.h" line="190">A key in the "standard" namespace for getting the content type of the file.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.
The value for this key should contain a valid content type.</doc>
        <source-position filename="gfileinfo.h" line="197" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="STANDARD_COPY_NAME" value="standard::copy-name" c:type="G_FILE_ATTRIBUTE_STANDARD_COPY_NAME" gs:managed-name="StandardCopyName">
        <doc xml:space="preserve" filename="gfileinfo.h" line="142">A key in the "standard" namespace for getting the copy name of the file.
The copy name is an optional version of the name. If available it's always
in UTF8, and corresponds directly to the original filename (only transcoded to
UTF8). This is useful if you want to copy the file to another filesystem that
might have a different encoding. If the filename is not a valid string in the
encoding selected for the filesystem it is in then the copy name will not be set.

Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.</doc>
        <source-position filename="gfileinfo.h" line="154" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="STANDARD_DESCRIPTION" value="standard::description" c:type="G_FILE_ATTRIBUTE_STANDARD_DESCRIPTION" gs:managed-name="StandardDescription">
        <doc xml:space="preserve" filename="gfileinfo.h" line="156">A key in the "standard" namespace for getting the description of the file.
The description is a utf8 string that describes the file, generally containing
the filename, but can also contain further information. Example descriptions
could be "filename (on hostname)" for a remote file or "filename (in trash)"
for a file in the trash. This is useful for instance as the window title
when displaying a directory or for a bookmarks menu.

Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.</doc>
        <source-position filename="gfileinfo.h" line="168" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="STANDARD_DISPLAY_NAME" value="standard::display-name" c:type="G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME" gs:managed-name="StandardDisplayName">
        <doc xml:space="preserve" filename="gfileinfo.h" line="119">A key in the "standard" namespace for getting the display name of the file.
A display name is guaranteed to be in UTF-8 and can thus be displayed in
the UI. It is guaranteed to be set on every file.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.</doc>
        <source-position filename="gfileinfo.h" line="127" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="STANDARD_EDIT_NAME" value="standard::edit-name" c:type="G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME" gs:managed-name="StandardEditName">
        <doc xml:space="preserve" filename="gfileinfo.h" line="129">A key in the "standard" namespace for edit name of the file.
An edit name is similar to the display name, but it is meant to be
used when you want to rename the file in the UI. The display name
might contain information you don't want in the new filename (such as
"(invalid unicode)" if the filename was in an invalid encoding).

Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.</doc>
        <source-position filename="gfileinfo.h" line="140" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="STANDARD_FAST_CONTENT_TYPE" value="standard::fast-content-type" c:type="G_FILE_ATTRIBUTE_STANDARD_FAST_CONTENT_TYPE" gs:managed-name="StandardFastContentType">
        <doc xml:space="preserve" filename="gfileinfo.h" line="199">A key in the "standard" namespace for getting the fast content type.
The fast content type isn't as reliable as the regular one, as it
only uses the filename to guess it, but it is faster to calculate than the
regular content type.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.</doc>
        <source-position filename="gfileinfo.h" line="209" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="STANDARD_ICON" value="standard::icon" c:type="G_FILE_ATTRIBUTE_STANDARD_ICON" gs:managed-name="StandardIcon">
        <doc xml:space="preserve" filename="gfileinfo.h" line="170">A key in the "standard" namespace for getting the icon for the file.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_OBJECT.
The value for this key should contain a #GIcon.</doc>
        <source-position filename="gfileinfo.h" line="177" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="STANDARD_IS_BACKUP" value="standard::is-backup" c:type="G_FILE_ATTRIBUTE_STANDARD_IS_BACKUP" gs:managed-name="StandardIsBackup">
        <doc xml:space="preserve" filename="gfileinfo.h" line="65">A key in the "standard" namespace for checking if a file is a backup file.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.</doc>
        <source-position filename="gfileinfo.h" line="71" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="STANDARD_IS_HIDDEN" value="standard::is-hidden" c:type="G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN" gs:managed-name="StandardIsHidden">
        <doc xml:space="preserve" filename="gfileinfo.h" line="57">A key in the "standard" namespace for checking if a file is hidden.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.</doc>
        <source-position filename="gfileinfo.h" line="63" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="STANDARD_IS_SYMLINK" value="standard::is-symlink" c:type="G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK" gs:managed-name="StandardIsSymlink">
        <doc xml:space="preserve" filename="gfileinfo.h" line="73">A key in the "standard" namespace for checking if the file is a symlink.
Typically the actual type is something else, if we followed the symlink
to get the type.
On Windows NTFS mountpoints are considered to be symlinks as well.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.</doc>
        <source-position filename="gfileinfo.h" line="82" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="STANDARD_IS_VIRTUAL" value="standard::is-virtual" c:type="G_FILE_ATTRIBUTE_STANDARD_IS_VIRTUAL" gs:managed-name="StandardIsVirtual">
        <doc xml:space="preserve" filename="gfileinfo.h" line="84">A key in the "standard" namespace for checking if a file is virtual.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.</doc>
        <source-position filename="gfileinfo.h" line="90" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="STANDARD_IS_VOLATILE" value="standard::is-volatile" c:type="G_FILE_ATTRIBUTE_STANDARD_IS_VOLATILE" version="2.46" gs:managed-name="StandardIsVolatile">
        <doc xml:space="preserve" filename="gfileinfo.h" line="92">A key in the "standard" namespace for checking if a file is
volatile. This is meant for opaque, non-POSIX-like backends to
indicate that the URI is not persistent. Applications should look
at #G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET for the persistent URI.

Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.</doc>
        <source-position filename="gfileinfo.h" line="104" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="STANDARD_NAME" value="standard::name" c:type="G_FILE_ATTRIBUTE_STANDARD_NAME" gs:managed-name="StandardName">
        <doc xml:space="preserve" filename="gfileinfo.h" line="106">A key in the "standard" namespace for getting the name of the file.
The name is the on-disk filename which may not be in any known encoding,
and can thus not be generally displayed as is. It is guaranteed to be set on
every file.
Use #G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME if you need to display the
name in a user interface.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.</doc>
        <source-position filename="gfileinfo.h" line="117" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="STANDARD_SIZE" value="standard::size" c:type="G_FILE_ATTRIBUTE_STANDARD_SIZE" gs:managed-name="StandardSize">
        <doc xml:space="preserve" filename="gfileinfo.h" line="211">A key in the "standard" namespace for getting the file's size (in bytes).
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64.</doc>
        <source-position filename="gfileinfo.h" line="217" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="STANDARD_SORT_ORDER" value="standard::sort-order" c:type="G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER" gs:managed-name="StandardSortOrder">
        <doc xml:space="preserve" filename="gfileinfo.h" line="250">A key in the "standard" namespace for setting the sort order of a file.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_INT32.
An example use would be in file managers, which would use this key
to set the order files are displayed. Files with smaller sort order
should be sorted first, and files without sort order as if sort order
was zero.</doc>
        <source-position filename="gfileinfo.h" line="260" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="STANDARD_SYMBOLIC_ICON" value="standard::symbolic-icon" c:type="G_FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON" version="2.34" gs:managed-name="StandardSymbolicIcon">
        <doc xml:space="preserve" filename="gfileinfo.h" line="179">A key in the "standard" namespace for getting the symbolic icon for the file.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_OBJECT.
The value for this key should contain a #GIcon.</doc>
        <source-position filename="gfileinfo.h" line="188" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="STANDARD_SYMLINK_TARGET" value="standard::symlink-target" c:type="G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET" gs:managed-name="StandardSymlinkTarget">
        <doc xml:space="preserve" filename="gfileinfo.h" line="232">A key in the "standard" namespace for getting the symlink target, if the file
is a symlink. Corresponding #GFileAttributeType is
%G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.</doc>
        <source-position filename="gfileinfo.h" line="239" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="STANDARD_TARGET_URI" value="standard::target-uri" c:type="G_FILE_ATTRIBUTE_STANDARD_TARGET_URI" gs:managed-name="StandardTargetUri">
        <doc xml:space="preserve" filename="gfileinfo.h" line="241">A key in the "standard" namespace for getting the target URI for the file, in
the case of %G_FILE_TYPE_SHORTCUT or %G_FILE_TYPE_MOUNTABLE files.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.</doc>
        <source-position filename="gfileinfo.h" line="248" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="STANDARD_TYPE" value="standard::type" c:type="G_FILE_ATTRIBUTE_STANDARD_TYPE" gs:managed-name="StandardType">
        <doc xml:space="preserve" filename="gfileinfo.h" line="48">A key in the "standard" namespace for storing file types.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.
The value for this key should contain a #GFileType.</doc>
        <source-position filename="gfileinfo.h" line="55" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="THUMBNAILING_FAILED" value="thumbnail::failed" c:type="G_FILE_ATTRIBUTE_THUMBNAILING_FAILED" gs:managed-name="ThumbnailingFailed">
        <doc xml:space="preserve" filename="gfileinfo.h" line="745">A key in the "thumbnail" namespace for checking if thumbnailing failed.
This attribute is %TRUE if thumbnailing failed. Corresponding
#GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.</doc>
        <source-position filename="gfileinfo.h" line="752" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="THUMBNAIL_IS_VALID" value="thumbnail::is-valid" c:type="G_FILE_ATTRIBUTE_THUMBNAIL_IS_VALID" version="2.40" gs:managed-name="ThumbnailIsValid">
        <doc xml:space="preserve" filename="gfileinfo.h" line="753">A key in the "thumbnail" namespace for checking whether the thumbnail is outdated.
This attribute is %TRUE if the thumbnail is up-to-date with the file it represents,
and %FALSE if the file has been modified since the thumbnail was generated.

If %G_FILE_ATTRIBUTE_THUMBNAILING_FAILED is %TRUE and this attribute is %FALSE,
it indicates that thumbnailing may be attempted again and may succeed.

Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.</doc>
        <source-position filename="gfileinfo.h" line="767" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="THUMBNAIL_PATH" value="thumbnail::path" c:type="G_FILE_ATTRIBUTE_THUMBNAIL_PATH" gs:managed-name="ThumbnailPath">
        <doc xml:space="preserve" filename="gfileinfo.h" line="737">A key in the "thumbnail" namespace for getting the path to the thumbnail
image. Corresponding #GFileAttributeType is
%G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.</doc>
        <source-position filename="gfileinfo.h" line="744" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="TIME_ACCESS" value="time::access" c:type="G_FILE_ATTRIBUTE_TIME_ACCESS" gs:managed-name="TimeAccess">
        <doc xml:space="preserve" filename="gfileinfo.h" line="493">A key in the "time" namespace for getting the time the file was last
accessed. Corresponding #GFileAttributeType is
%G_FILE_ATTRIBUTE_TYPE_UINT64, and contains the time since the
file was last accessed, in seconds since the UNIX epoch.</doc>
        <source-position filename="gfileinfo.h" line="501" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="TIME_ACCESS_USEC" value="time::access-usec" c:type="G_FILE_ATTRIBUTE_TIME_ACCESS_USEC" gs:managed-name="TimeAccessUsec">
        <doc xml:space="preserve" filename="gfileinfo.h" line="503">A key in the "time" namespace for getting the microseconds of the time
the file was last accessed. This should be used in conjunction with
#G_FILE_ATTRIBUTE_TIME_ACCESS. Corresponding #GFileAttributeType is
%G_FILE_ATTRIBUTE_TYPE_UINT32.</doc>
        <source-position filename="gfileinfo.h" line="511" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="TIME_CHANGED" value="time::changed" c:type="G_FILE_ATTRIBUTE_TIME_CHANGED" gs:managed-name="TimeChanged">
        <doc xml:space="preserve" filename="gfileinfo.h" line="513">A key in the "time" namespace for getting the time the file was last
changed. Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64,
and contains the time since the file was last changed, in seconds since the
UNIX epoch.

This corresponds to the traditional UNIX ctime.</doc>
        <source-position filename="gfileinfo.h" line="523" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="TIME_CHANGED_USEC" value="time::changed-usec" c:type="G_FILE_ATTRIBUTE_TIME_CHANGED_USEC" gs:managed-name="TimeChangedUsec">
        <doc xml:space="preserve" filename="gfileinfo.h" line="525">A key in the "time" namespace for getting the microseconds of the time
the file was last changed. This should be used in conjunction with
#G_FILE_ATTRIBUTE_TIME_CHANGED. Corresponding #GFileAttributeType is
%G_FILE_ATTRIBUTE_TYPE_UINT32.</doc>
        <source-position filename="gfileinfo.h" line="533" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="TIME_CREATED" value="time::created" c:type="G_FILE_ATTRIBUTE_TIME_CREATED" gs:managed-name="TimeCreated">
        <doc xml:space="preserve" filename="gfileinfo.h" line="535">A key in the "time" namespace for getting the time the file was created.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64,
and contains the time since the file was created, in seconds since the UNIX
epoch.

This may correspond to Linux stx_btime, FreeBSD st_birthtim, NetBSD
st_birthtime or NTFS ctime.</doc>
        <source-position filename="gfileinfo.h" line="546" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="TIME_CREATED_USEC" value="time::created-usec" c:type="G_FILE_ATTRIBUTE_TIME_CREATED_USEC" gs:managed-name="TimeCreatedUsec">
        <doc xml:space="preserve" filename="gfileinfo.h" line="548">A key in the "time" namespace for getting the microseconds of the time
the file was created. This should be used in conjunction with
#G_FILE_ATTRIBUTE_TIME_CREATED. Corresponding #GFileAttributeType is
%G_FILE_ATTRIBUTE_TYPE_UINT32.</doc>
        <source-position filename="gfileinfo.h" line="556" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="TIME_MODIFIED" value="time::modified" c:type="G_FILE_ATTRIBUTE_TIME_MODIFIED" gs:managed-name="TimeModified">
        <doc xml:space="preserve" filename="gfileinfo.h" line="473">A key in the "time" namespace for getting the time the file was last
modified. Corresponding #GFileAttributeType is
%G_FILE_ATTRIBUTE_TYPE_UINT64, and contains the time since the
file was modified, in seconds since the UNIX epoch.</doc>
        <source-position filename="gfileinfo.h" line="481" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="TIME_MODIFIED_USEC" value="time::modified-usec" c:type="G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC" gs:managed-name="TimeModifiedUsec">
        <doc xml:space="preserve" filename="gfileinfo.h" line="483">A key in the "time" namespace for getting the microseconds of the time
the file was last modified. This should be used in conjunction with
#G_FILE_ATTRIBUTE_TIME_MODIFIED. Corresponding #GFileAttributeType is
%G_FILE_ATTRIBUTE_TYPE_UINT32.</doc>
        <source-position filename="gfileinfo.h" line="491" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="TRASH_DELETION_DATE" value="trash::deletion-date" c:type="G_FILE_ATTRIBUTE_TRASH_DELETION_DATE" version="2.24" gs:managed-name="TrashDeletionDate">
        <doc xml:space="preserve" filename="gfileinfo.h" line="891">A key in the "trash" namespace.  When requested against
items in `trash:///`, will return the date and time when the file
was trashed. The format of the returned string is YYYY-MM-DDThh:mm:ss.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_STRING.</doc>
        <source-position filename="gfileinfo.h" line="901" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="TRASH_ITEM_COUNT" value="trash::item-count" c:type="G_FILE_ATTRIBUTE_TRASH_ITEM_COUNT" gs:managed-name="TrashItemCount">
        <doc xml:space="preserve" filename="gfileinfo.h" line="870">A key in the "trash" namespace.  When requested against
`trash:///` returns the number of (toplevel) items in the trash folder.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.</doc>
        <source-position filename="gfileinfo.h" line="877" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="TRASH_ORIG_PATH" value="trash::orig-path" c:type="G_FILE_ATTRIBUTE_TRASH_ORIG_PATH" version="2.24" gs:managed-name="TrashOrigPath">
        <doc xml:space="preserve" filename="gfileinfo.h" line="879">A key in the "trash" namespace.  When requested against
items in `trash:///`, will return the original path to the file before it
was trashed. Corresponding #GFileAttributeType is
%G_FILE_ATTRIBUTE_TYPE_BYTE_STRING.</doc>
        <source-position filename="gfileinfo.h" line="889" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="UNIX_BLOCKS" value="unix::blocks" c:type="G_FILE_ATTRIBUTE_UNIX_BLOCKS" gs:managed-name="UnixBlocks">
        <doc xml:space="preserve" filename="gfileinfo.h" line="638">A key in the "unix" namespace for getting the number of blocks allocated
for the file. This attribute is only available for UNIX file systems.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64.</doc>
        <source-position filename="gfileinfo.h" line="645" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="UNIX_BLOCK_SIZE" value="unix::block-size" c:type="G_FILE_ATTRIBUTE_UNIX_BLOCK_SIZE" gs:managed-name="UnixBlockSize">
        <doc xml:space="preserve" filename="gfileinfo.h" line="629">A key in the "unix" namespace for getting the block size for the file
system. This attribute is only available for UNIX file systems.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.</doc>
        <source-position filename="gfileinfo.h" line="636" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="UNIX_DEVICE" value="unix::device" c:type="G_FILE_ATTRIBUTE_UNIX_DEVICE" gs:managed-name="UnixDevice">
        <doc xml:space="preserve" filename="gfileinfo.h" line="560">A key in the "unix" namespace for getting the device id of the device the
file is located on (see stat() documentation). This attribute is only
available for UNIX file systems. Corresponding #GFileAttributeType is
%G_FILE_ATTRIBUTE_TYPE_UINT32.</doc>
        <source-position filename="gfileinfo.h" line="568" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="UNIX_GID" value="unix::gid" c:type="G_FILE_ATTRIBUTE_UNIX_GID" gs:managed-name="UnixGid">
        <doc xml:space="preserve" filename="gfileinfo.h" line="610">A key in the "unix" namespace for getting the group ID for the file.
This attribute is only available for UNIX file systems.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.</doc>
        <source-position filename="gfileinfo.h" line="617" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="UNIX_INODE" value="unix::inode" c:type="G_FILE_ATTRIBUTE_UNIX_INODE" gs:managed-name="UnixInode">
        <doc xml:space="preserve" filename="gfileinfo.h" line="570">A key in the "unix" namespace for getting the inode of the file.
This attribute is only available for UNIX file systems. Corresponding
#GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT64.</doc>
        <source-position filename="gfileinfo.h" line="577" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="UNIX_IS_MOUNTPOINT" value="unix::is-mountpoint" c:type="G_FILE_ATTRIBUTE_UNIX_IS_MOUNTPOINT" gs:managed-name="UnixIsMountpoint">
        <doc xml:space="preserve" filename="gfileinfo.h" line="647">A key in the "unix" namespace for checking if the file represents a
UNIX mount point. This attribute is %TRUE if the file is a UNIX mount
point. Since 2.58, `/` is considered to be a mount point.
This attribute is only available for UNIX file systems.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_BOOLEAN.</doc>
        <source-position filename="gfileinfo.h" line="656" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="UNIX_MODE" value="unix::mode" c:type="G_FILE_ATTRIBUTE_UNIX_MODE" gs:managed-name="UnixMode">
        <doc xml:space="preserve" filename="gfileinfo.h" line="579">A key in the "unix" namespace for getting the mode of the file
(e.g. whether the file is a regular file, symlink, etc). See the
documentation for `lstat()`: this attribute is equivalent to the `st_mode`
member of `struct stat`, and includes both the file type and permissions.
This attribute is only available for UNIX file systems.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.</doc>
        <source-position filename="gfileinfo.h" line="589" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="UNIX_NLINK" value="unix::nlink" c:type="G_FILE_ATTRIBUTE_UNIX_NLINK" gs:managed-name="UnixNlink">
        <doc xml:space="preserve" filename="gfileinfo.h" line="591">A key in the "unix" namespace for getting the number of hard links
for a file. See lstat() documentation. This attribute is only available
for UNIX file systems. Corresponding #GFileAttributeType is
%G_FILE_ATTRIBUTE_TYPE_UINT32.</doc>
        <source-position filename="gfileinfo.h" line="599" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="UNIX_RDEV" value="unix::rdev" c:type="G_FILE_ATTRIBUTE_UNIX_RDEV" gs:managed-name="UnixRdev">
        <doc xml:space="preserve" filename="gfileinfo.h" line="619">A key in the "unix" namespace for getting the device ID for the file
(if it is a special file). See lstat() documentation. This attribute
is only available for UNIX file systems. Corresponding #GFileAttributeType
is %G_FILE_ATTRIBUTE_TYPE_UINT32.</doc>
        <source-position filename="gfileinfo.h" line="627" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
      <constant name="UNIX_UID" value="unix::uid" c:type="G_FILE_ATTRIBUTE_UNIX_UID" gs:managed-name="UnixUid">
        <doc xml:space="preserve" filename="gfileinfo.h" line="601">A key in the "unix" namespace for getting the user ID for the file.
This attribute is only available for UNIX file systems.
Corresponding #GFileAttributeType is %G_FILE_ATTRIBUTE_TYPE_UINT32.</doc>
        <source-position filename="gfileinfo.h" line="608" />
        <type name="utf8" c:type="gchar*" gs:is-pointer="1" />
      </constant>
    </gs:static-class>
  </namespace>
</repository>