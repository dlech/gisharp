// SPDX-License-Identifier: MIT
// ATTENTION: This file is automatically generated. Do not edit manually.
#nullable enable
namespace GISharp.Lib.GModule
{
    /// <include file="Module.xmldoc" path="declaration/member[@name='Module']/*" />
    public sealed unsafe partial class Module : GISharp.Runtime.Opaque
    {
        /// <summary>
        /// The unmanaged data structure.
        /// </summary>
        public struct UnmanagedStruct
        {
        }

        /// <include file="Module.xmldoc" path="declaration/member[@name='Module.Name']/*" />
        public GISharp.Runtime.UnownedUtf8 Name { get => GetName(); }

        /// <include file="Module.xmldoc" path="declaration/member[@name='Module.Error']/*" />
        public static GISharp.Runtime.UnownedUtf8 Error { get => GetError(); }

        /// <include file="Module.xmldoc" path="declaration/member[@name='Module.Supported']/*" />
        public static bool Supported { get => GetSupported(); }

        /// <summary>
        /// For internal runtime use only.
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        public Module(System.IntPtr handle, GISharp.Runtime.Transfer ownership) : base(handle, ownership)
        {
        }

        /// <summary>
        /// A portable way to build the filename of a module. The platform-specific
        /// prefix and suffix are added to the filename, if needed, and the result
        /// is added to the directory, using the correct separator character.
        /// </summary>
        /// <remarks>
        /// <para>
        /// The directory should specify the directory where the module can be found.
        /// It can be %NULL or an empty string to indicate that the module is in a
        /// standard platform-specific directory, though this is not recommended
        /// since the wrong module may be found.
        /// </para>
        /// <para>
        /// For example, calling g_module_build_path() on a Linux system with a
        /// @directory of `/lib` and a @module_name of "mylibrary" will return
        /// `/lib/libmylibrary.so`. On a Windows system, using `\Windows` as the
        /// directory it will return `\Windows\mylibrary.dll`.
        /// </para>
        /// </remarks>
        /// <param name="directory">
        /// the directory where the module is. This can be
        ///     %NULL or the empty string to indicate that the standard platform-specific
        ///     directories will be used, though that is not recommended
        /// </param>
        /// <param name="moduleName">
        /// the name of the module
        /// </param>
        /// <returns>
        /// the complete path of the module, including the standard library
        ///     prefix and suffix. This should be freed when no longer needed
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gmodule-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="gchar*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern byte* g_module_build_path(
        /* <type name="utf8" type="const gchar*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        byte* directory,
        /* <type name="utf8" type="const gchar*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* moduleName);
        static partial void CheckBuildPathArgs(GISharp.Runtime.NullableUnownedUtf8 directory, GISharp.Runtime.UnownedUtf8 moduleName);

        /// <include file="Module.xmldoc" path="declaration/member[@name='Module.BuildPath(GISharp.Runtime.NullableUnownedUtf8,GISharp.Runtime.UnownedUtf8)']/*" />
        public static GISharp.Runtime.Utf8 BuildPath(GISharp.Runtime.NullableUnownedUtf8 directory, GISharp.Runtime.UnownedUtf8 moduleName)
        {
            CheckBuildPathArgs(directory, moduleName);
            var directory_ = (byte*)directory.UnsafeHandle;
            var moduleName_ = (byte*)moduleName.UnsafeHandle;
            var ret_ = g_module_build_path(directory_,moduleName_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Runtime.Utf8.GetInstance<GISharp.Runtime.Utf8>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Gets a string describing the last module error.
        /// </summary>
        /// <returns>
        /// a string describing the last module error
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gmodule-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="const gchar*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern byte* g_module_error();
        static partial void CheckGetErrorArgs();

        private static GISharp.Runtime.UnownedUtf8 GetError()
        {
            CheckGetErrorArgs();
            var ret_ = g_module_error();
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = new GISharp.Runtime.UnownedUtf8(ret_);
            return ret;
        }

        /// <summary>
        /// Opens a module. If the module has already been opened,
        /// its reference count is incremented.
        /// </summary>
        /// <remarks>
        /// <para>
        /// First of all g_module_open() tries to open @file_name as a module.
        /// If that fails and @file_name has the ".la"-suffix (and is a libtool
        /// archive) it tries to open the corresponding module. If that fails
        /// and it doesn't have the proper module suffix for the platform
        /// (#G_MODULE_SUFFIX), this suffix will be appended and the corresponding
        /// module will be opened. If that fails and @file_name doesn't have the
        /// ".la"-suffix, this suffix is appended and g_module_open() tries to open
        /// the corresponding module. If eventually that fails as well, %NULL is
        /// returned.
        /// </para>
        /// </remarks>
        /// <param name="fileName">
        /// the name of the file containing the module, or %NULL
        ///     to obtain a #GModule representing the main program itself
        /// </param>
        /// <param name="flags">
        /// the flags used for opening the module. This can be the
        ///     logical OR of any of the #GModuleFlags
        /// </param>
        /// <returns>
        /// a #GModule on success, or %NULL on failure
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gmodule-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Module" type="GModule*" is-pointer="1" /> */
        /* nullable:1 transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GModule.Module.UnmanagedStruct* g_module_open(
        /* <type name="utf8" type="const gchar*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        byte* fileName,
        /* <type name="ModuleFlags" type="GModuleFlags" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GModule.ModuleFlags flags);
        static partial void CheckOpenArgs(GISharp.Runtime.NullableUnownedUtf8 fileName, GISharp.Lib.GModule.ModuleFlags flags = default);

        /// <include file="Module.xmldoc" path="declaration/member[@name='Module.Open(GISharp.Runtime.NullableUnownedUtf8,GISharp.Lib.GModule.ModuleFlags)']/*" />
        public static GISharp.Lib.GModule.Module? Open(GISharp.Runtime.NullableUnownedUtf8 fileName, GISharp.Lib.GModule.ModuleFlags flags = default)
        {
            CheckOpenArgs(fileName, flags);
            var fileName_ = (byte*)fileName.UnsafeHandle;
            var flags_ = (GISharp.Lib.GModule.ModuleFlags)flags;
            var ret_ = g_module_open(fileName_,flags_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Lib.GModule.Module.GetInstance<GISharp.Lib.GModule.Module>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full);
            return ret;
        }

        /// <summary>
        /// Checks if modules are supported on the current platform.
        /// </summary>
        /// <returns>
        /// %TRUE if modules are supported
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gmodule-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_module_supported();
        static partial void CheckGetSupportedArgs();

        private static bool GetSupported()
        {
            CheckGetSupportedArgs();
            var ret_ = g_module_supported();
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Closes a module.
        /// </summary>
        /// <param name="module">
        /// a #GModule to close
        /// </param>
        /// <returns>
        /// %TRUE on success
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gmodule-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_module_close(
        /* <type name="Module" type="GModule*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GModule.Module.UnmanagedStruct* module);
        partial void CheckCloseArgs();
        partial void CheckCloseReturn(bool ret);

        /// <include file="Module.xmldoc" path="declaration/member[@name='Module.Close()']/*" />
        public bool Close()
        {
            CheckCloseArgs();
            var module_ = (GISharp.Lib.GModule.Module.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_module_close(module_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            CheckCloseReturn(ret);
            return ret;
        }

        /// <summary>
        /// Ensures that a module will never be unloaded.
        /// Any future g_module_close() calls on the module will be ignored.
        /// </summary>
        /// <param name="module">
        /// a #GModule to make permanently resident
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gmodule-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_module_make_resident(
        /* <type name="Module" type="GModule*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GModule.Module.UnmanagedStruct* module);
        partial void CheckMakeResidentArgs();

        /// <include file="Module.xmldoc" path="declaration/member[@name='Module.MakeResident()']/*" />
        public void MakeResident()
        {
            CheckMakeResidentArgs();
            var module_ = (GISharp.Lib.GModule.Module.UnmanagedStruct*)UnsafeHandle;
            g_module_make_resident(module_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
        }

        /// <summary>
        /// Returns the filename that the module was opened with.
        /// </summary>
        /// <remarks>
        /// <para>
        /// If @module refers to the application itself, "main" is returned.
        /// </para>
        /// </remarks>
        /// <param name="module">
        /// a #GModule
        /// </param>
        /// <returns>
        /// the filename of the module
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gmodule-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="const gchar*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern byte* g_module_name(
        /* <type name="Module" type="GModule*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GModule.Module.UnmanagedStruct* module);
        partial void CheckGetNameArgs();

        private GISharp.Runtime.UnownedUtf8 GetName()
        {
            CheckGetNameArgs();
            var module_ = (GISharp.Lib.GModule.Module.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_module_name(module_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = new GISharp.Runtime.UnownedUtf8(ret_);
            return ret;
        }

        /// <summary>
        /// Gets a symbol pointer from a module, such as one exported
        /// by #G_MODULE_EXPORT. Note that a valid symbol can be %NULL.
        /// </summary>
        /// <param name="module">
        /// a #GModule
        /// </param>
        /// <param name="symbolName">
        /// the name of the symbol to find
        /// </param>
        /// <param name="symbol">
        /// returns the pointer to the symbol value
        /// </param>
        /// <returns>
        /// %TRUE on success
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gmodule-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_module_symbol(
        /* <type name="Module" type="GModule*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GModule.Module.UnmanagedStruct* module,
        /* <type name="utf8" type="const gchar*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* symbolName,
        /* <type name="gpointer" type="gpointer*" is-pointer="1" /> */
        /* direction:out caller-allocates:0 transfer-ownership:full nullable:1 */
        System.IntPtr* symbol);
        partial void CheckTrySymbolArgs(GISharp.Runtime.UnownedUtf8 symbolName);

        /// <include file="Module.xmldoc" path="declaration/member[@name='Module.TrySymbol(GISharp.Runtime.UnownedUtf8,System.IntPtr)']/*" />
        public bool TrySymbol(GISharp.Runtime.UnownedUtf8 symbolName, out System.IntPtr symbol)
        {
            CheckTrySymbolArgs(symbolName);
            var module_ = (GISharp.Lib.GModule.Module.UnmanagedStruct*)UnsafeHandle;
            var symbolName_ = (byte*)symbolName.UnsafeHandle;
            System.IntPtr symbol_;
            var ret_ = g_module_symbol(module_,symbolName_,&symbol_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            symbol = (System.IntPtr)symbol_;
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }
    }
}