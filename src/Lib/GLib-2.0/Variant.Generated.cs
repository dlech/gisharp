// SPDX-License-Identifier: MIT
// ATTENTION: This file is automatically generated. Do not edit manually.
#nullable enable
namespace GISharp.Lib.GLib
{
    /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant']/*" />
    [GISharp.Runtime.SinceAttribute("2.24")]
    [GISharp.Runtime.GTypeAttribute("GVariant", IsProxyForUnmanagedType = true)]
    public sealed unsafe partial class Variant : GISharp.Lib.GObject.Boxed, System.IComparable<Variant>, System.IEquatable<Variant>
    {
        private static readonly GISharp.Lib.GObject.GType _GType = intern();

        /// <summary>
        /// The unmanaged data structure.
        /// </summary>
        public struct UnmanagedStruct
        {
        }

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.Boolean']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public bool Boolean { get => GetBoolean(); }

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.Byte']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public byte Byte { get => GetByte(); }

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.Bytestring']/*" />
        [GISharp.Runtime.SinceAttribute("2.26")]
        public System.ReadOnlySpan<byte> Bytestring { get => GetBytestring(); }

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.BytestringArray']/*" />
        [GISharp.Runtime.SinceAttribute("2.26")]
        public GISharp.Runtime.CPtrArray<GISharp.Lib.GLib.Utf8> BytestringArray { get => GetBytestringArray(); }

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.Data']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public System.IntPtr Data { get => GetData(); }

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.DataAsBytes']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        public GISharp.Lib.GLib.Bytes DataAsBytes { get => GetDataAsBytes(); }

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.Double']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public double Double { get => GetDouble(); }

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.Handle']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public int Handle { get => GetHandle(); }

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.Int16']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public short Int16 { get => GetInt16(); }

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.Int32']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public int Int32 { get => GetInt32(); }

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.Int64']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public long Int64 { get => GetInt64(); }

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.Maybe']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public GISharp.Lib.GLib.Variant? Maybe { get => GetMaybe(); }

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.NormalForm']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public GISharp.Lib.GLib.Variant NormalForm { get => GetNormalForm(); }

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.Objv']/*" />
        [GISharp.Runtime.SinceAttribute("2.30")]
        public GISharp.Lib.GLib.Strv Objv { get => GetObjv(); }

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.Size']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public int Size { get => GetSize(); }

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.Strv']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public GISharp.Lib.GLib.Strv Strv { get => GetStrv(); }

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.Type']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public GISharp.Lib.GLib.VariantType Type { get => GetType_(); }

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.TypeString']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public GISharp.Lib.GLib.UnownedUtf8 TypeString { get => GetTypeString(); }

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.Uint16']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public ushort Uint16 { get => GetUint16(); }

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.Uint32']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public uint Uint32 { get => GetUint32(); }

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.Uint64']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public ulong Uint64 { get => GetUint64(); }

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.Variant']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public GISharp.Lib.GLib.Variant Variant { get => GetVariant(); }

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.IsContainer']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public bool IsContainer { get => GetIsContainer(); }

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.IsFloating']/*" />
        [GISharp.Runtime.SinceAttribute("2.26")]
        public bool IsFloating { get => GetIsFloating(); }

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.IsNormalForm']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public bool IsNormalForm { get => GetIsNormalForm(); }

        /// <summary>
        /// For internal runtime use only.
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        public Variant(System.IntPtr handle, GISharp.Runtime.Transfer ownership) : base(handle)
        {
            if (ownership == GISharp.Runtime.Transfer.None)
            {
                this.handle = (System.IntPtr)g_variant_ref((UnmanagedStruct*)handle);
            }
        }

        /// <summary>
        /// Creates a new #GVariant array from @children.
        /// </summary>
        /// <remarks>
        /// @child_type must be non-%NULL if @n_children is zero.  Otherwise, the
        /// child type is determined by inspecting the first element of the
        /// @children array.  If @child_type is non-%NULL then it must be a
        /// definite type.
        /// 
        /// The items of the array are taken from the @children array.  No entry
        /// in the @children array may be %NULL.
        /// 
        /// All items in the array must have the same type, which must be the
        /// same as @child_type, if given.
        /// 
        /// If the @children are floating references (see g_variant_ref_sink()), the
        /// new instance takes ownership of them as if via g_variant_ref_sink().
        /// </remarks>
        /// <param name="childType">
        /// the element type of the new array
        /// </param>
        /// <param name="children">
        /// an array of
        ///            #GVariant pointers, the children
        /// </param>
        /// <param name="nChildren">
        /// the length of @children
        /// </param>
        /// <returns>
        /// a floating reference to a new #GVariant array
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GLib.Variant.UnmanagedStruct* g_variant_new_array(
        /* <type name="VariantType" type="const GVariantType*" managed-name="VariantType" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.GLib.VariantType.UnmanagedStruct* childType,
        /* <array length="2" zero-terminated="0" type="GVariant* const*" managed-name="GISharp.Runtime.CArray" is-pointer="1">
*   <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" />
* </array> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.GLib.Variant.UnmanagedStruct** children,
        /* <type name="gsize" type="gsize" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        nuint nChildren);
        static partial void CheckNewArrayArgs(GISharp.Lib.GLib.VariantType? childType, GISharp.Runtime.UnownedCPtrArray<GISharp.Lib.GLib.Variant> children);

        [GISharp.Runtime.SinceAttribute("2.24")]
        static GISharp.Lib.GLib.Variant.UnmanagedStruct* NewArray(GISharp.Lib.GLib.VariantType? childType, GISharp.Runtime.UnownedCPtrArray<GISharp.Lib.GLib.Variant> children)
        {
            fixed (System.IntPtr* childrenData_ = children)
            {
                CheckNewArrayArgs(childType, children);
                var childType_ = (GISharp.Lib.GLib.VariantType.UnmanagedStruct*)(childType?.UnsafeHandle ?? System.IntPtr.Zero);
                var children_ = (GISharp.Lib.GLib.Variant.UnmanagedStruct**)childrenData_;
                var nChildren_ = (nuint)children.Length;
                var ret_ = g_variant_new_array(childType_,children_,nChildren_);
                return ret_;
            }
        }

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.Variant(GISharp.Lib.GLib.VariantType?,GISharp.Runtime.UnownedCPtrArray&lt;GISharp.Lib.GLib.Variant&gt;)']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public Variant(GISharp.Lib.GLib.VariantType? childType, GISharp.Runtime.UnownedCPtrArray<GISharp.Lib.GLib.Variant> children) : this((System.IntPtr)NewArray(childType, children), GISharp.Runtime.Transfer.None)
        {
        }

        /// <summary>
        /// Creates a new boolean #GVariant instance -- either %TRUE or %FALSE.
        /// </summary>
        /// <param name="value">
        /// a #gboolean value
        /// </param>
        /// <returns>
        /// a floating reference to a new boolean #GVariant instance
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GLib.Variant.UnmanagedStruct* g_variant_new_boolean(
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.Boolean value);
        static partial void CheckNewBooleanArgs(bool value);

        [GISharp.Runtime.SinceAttribute("2.24")]
        static GISharp.Lib.GLib.Variant.UnmanagedStruct* NewBoolean(bool value)
        {
            CheckNewBooleanArgs(value);
            var value_ = GISharp.Runtime.BooleanExtensions.ToBoolean(value);
            var ret_ = g_variant_new_boolean(value_);
            return ret_;
        }

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.Variant(bool)']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public Variant(bool value) : this((System.IntPtr)NewBoolean(value), GISharp.Runtime.Transfer.None)
        {
        }

        /// <summary>
        /// Creates a new byte #GVariant instance.
        /// </summary>
        /// <param name="value">
        /// a #guint8 value
        /// </param>
        /// <returns>
        /// a floating reference to a new byte #GVariant instance
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GLib.Variant.UnmanagedStruct* g_variant_new_byte(
        /* <type name="guint8" type="guint8" managed-name="System.Byte" /> */
        /* transfer-ownership:none direction:in */
        byte value);
        static partial void CheckNewByteArgs(byte value);

        [GISharp.Runtime.SinceAttribute("2.24")]
        static GISharp.Lib.GLib.Variant.UnmanagedStruct* NewByte(byte value)
        {
            CheckNewByteArgs(value);
            var value_ = (byte)value;
            var ret_ = g_variant_new_byte(value_);
            return ret_;
        }

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.Variant(byte)']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public Variant(byte value) : this((System.IntPtr)NewByte(value), GISharp.Runtime.Transfer.None)
        {
        }

        /// <summary>
        /// Creates an array-of-bytes #GVariant with the contents of @string.
        /// This function is just like g_variant_new_string() except that the
        /// string need not be valid UTF-8.
        /// </summary>
        /// <remarks>
        /// The nul terminator character at the end of the string is stored in
        /// the array.
        /// </remarks>
        /// <param name="string">
        /// a normal
        ///          nul-terminated string in no particular encoding
        /// </param>
        /// <returns>
        /// a floating reference to a new bytestring #GVariant instance
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.26")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GLib.Variant.UnmanagedStruct* g_variant_new_bytestring(
        /* <array type="const gchar*" zero-terminated="1" managed-name="GISharp.Runtime.CArray" is-pointer="1">
*   <type name="guint8" managed-name="System.Byte" />
* </array> */
        /* transfer-ownership:none direction:in */
        byte* @string);
        static partial void CheckNewBytestringArgs(System.ReadOnlySpan<byte> @string);

        [GISharp.Runtime.SinceAttribute("2.26")]
        static GISharp.Lib.GLib.Variant.UnmanagedStruct* NewBytestring(System.ReadOnlySpan<byte> @string)
        {
            fixed (byte* @stringData_ = @string)
            {
                CheckNewBytestringArgs(@string);
                var @string_ = (byte*)@stringData_;
                var ret_ = g_variant_new_bytestring(@string_);
                return ret_;
            }
        }

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.Variant(System.ReadOnlySpan&lt;byte&gt;)']/*" />
        [GISharp.Runtime.SinceAttribute("2.26")]
        public Variant(System.ReadOnlySpan<byte> @string) : this((System.IntPtr)NewBytestring(@string), GISharp.Runtime.Transfer.None)
        {
        }

        /// <summary>
        /// Constructs an array of bytestring #GVariant from the given array of
        /// strings.
        /// </summary>
        /// <remarks>
        /// If @length is -1 then @strv is %NULL-terminated.
        /// </remarks>
        /// <param name="strv">
        /// an array of strings
        /// </param>
        /// <param name="length">
        /// the length of @strv, or -1
        /// </param>
        /// <returns>
        /// a new floating #GVariant instance
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.26")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GLib.Variant.UnmanagedStruct* g_variant_new_bytestring_array(
        /* <array length="1" zero-terminated="0" type="const gchar* const*" managed-name="GISharp.Runtime.CArray" is-pointer="1">
*   <type name="utf8" type="gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" />
* </array> */
        /* transfer-ownership:none direction:in */
        byte** strv,
        /* <type name="gssize" type="gssize" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        nint length);
        static partial void CheckNewBytestringArrayArgs(GISharp.Runtime.UnownedCPtrArray<GISharp.Lib.GLib.Utf8> strv);

        [GISharp.Runtime.SinceAttribute("2.26")]
        static GISharp.Lib.GLib.Variant.UnmanagedStruct* NewBytestringArray(GISharp.Runtime.UnownedCPtrArray<GISharp.Lib.GLib.Utf8> strv)
        {
            fixed (System.IntPtr* strvData_ = strv)
            {
                CheckNewBytestringArrayArgs(strv);
                var strv_ = (byte**)strvData_;
                var length_ = (nint)strv.Length;
                var ret_ = g_variant_new_bytestring_array(strv_,length_);
                return ret_;
            }
        }

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.Variant(GISharp.Runtime.UnownedCPtrArray&lt;GISharp.Lib.GLib.Utf8&gt;)']/*" />
        [GISharp.Runtime.SinceAttribute("2.26")]
        public Variant(GISharp.Runtime.UnownedCPtrArray<GISharp.Lib.GLib.Utf8> strv) : this((System.IntPtr)NewBytestringArray(strv), GISharp.Runtime.Transfer.None)
        {
        }

        /// <summary>
        /// Creates a new dictionary entry #GVariant. @key and @value must be
        /// non-%NULL. @key must be a value of a basic type (ie: not a container).
        /// </summary>
        /// <remarks>
        /// If the @key or @value are floating references (see g_variant_ref_sink()),
        /// the new instance takes ownership of them as if via g_variant_ref_sink().
        /// </remarks>
        /// <param name="key">
        /// a basic #GVariant, the key
        /// </param>
        /// <param name="value">
        /// a #GVariant, the value
        /// </param>
        /// <returns>
        /// a floating reference to a new dictionary entry #GVariant
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GLib.Variant.UnmanagedStruct* g_variant_new_dict_entry(
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Variant.UnmanagedStruct* key,
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Variant.UnmanagedStruct* value);
        static partial void CheckNewDictEntryArgs(GISharp.Lib.GLib.Variant key, GISharp.Lib.GLib.Variant value);

        [GISharp.Runtime.SinceAttribute("2.24")]
        static GISharp.Lib.GLib.Variant.UnmanagedStruct* NewDictEntry(GISharp.Lib.GLib.Variant key, GISharp.Lib.GLib.Variant value)
        {
            CheckNewDictEntryArgs(key, value);
            var key_ = (GISharp.Lib.GLib.Variant.UnmanagedStruct*)key.UnsafeHandle;
            var value_ = (GISharp.Lib.GLib.Variant.UnmanagedStruct*)value.UnsafeHandle;
            var ret_ = g_variant_new_dict_entry(key_,value_);
            return ret_;
        }

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.Variant(GISharp.Lib.GLib.Variant,GISharp.Lib.GLib.Variant)']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public Variant(GISharp.Lib.GLib.Variant key, GISharp.Lib.GLib.Variant value) : this((System.IntPtr)NewDictEntry(key, value), GISharp.Runtime.Transfer.None)
        {
        }

        /// <summary>
        /// Creates a new double #GVariant instance.
        /// </summary>
        /// <param name="value">
        /// a #gdouble floating point value
        /// </param>
        /// <returns>
        /// a floating reference to a new double #GVariant instance
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GLib.Variant.UnmanagedStruct* g_variant_new_double(
        /* <type name="gdouble" type="gdouble" managed-name="System.Double" /> */
        /* transfer-ownership:none direction:in */
        double value);
        static partial void CheckNewDoubleArgs(double value);

        [GISharp.Runtime.SinceAttribute("2.24")]
        static GISharp.Lib.GLib.Variant.UnmanagedStruct* NewDouble(double value)
        {
            CheckNewDoubleArgs(value);
            var value_ = (double)value;
            var ret_ = g_variant_new_double(value_);
            return ret_;
        }

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.Variant(double)']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public Variant(double value) : this((System.IntPtr)NewDouble(value), GISharp.Runtime.Transfer.None)
        {
        }

        /// <summary>
        /// Constructs a new array #GVariant instance, where the elements are
        /// of @element_type type.
        /// </summary>
        /// <remarks>
        /// @elements must be an array with fixed-sized elements.  Numeric types are
        /// fixed-size as are tuples containing only other fixed-sized types.
        /// 
        /// @element_size must be the size of a single element in the array.
        /// For example, if calling this function for an array of 32-bit integers,
        /// you might say sizeof(gint32). This value isn't used except for the purpose
        /// of a double-check that the form of the serialised data matches the caller's
        /// expectation.
        /// 
        /// @n_elements must be the length of the @elements array.
        /// </remarks>
        /// <param name="elementType">
        /// the #GVariantType of each element
        /// </param>
        /// <param name="elements">
        /// a pointer to the fixed array of contiguous elements
        /// </param>
        /// <param name="nElements">
        /// the number of elements
        /// </param>
        /// <param name="elementSize">
        /// the size of each element
        /// </param>
        /// <returns>
        /// a floating reference to a new array #GVariant instance
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.32")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GLib.Variant.UnmanagedStruct* g_variant_new_fixed_array(
        /* <type name="VariantType" type="const GVariantType*" managed-name="VariantType" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.VariantType.UnmanagedStruct* elementType,
        /* <type name="gpointer" type="gconstpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr elements,
        /* <type name="gsize" type="gsize" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        nuint nElements,
        /* <type name="gsize" type="gsize" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        nuint elementSize);
        static partial void CheckNewFixedArrayArgs(GISharp.Lib.GLib.VariantType elementType, System.IntPtr elements, int nElements, int elementSize);

        [GISharp.Runtime.SinceAttribute("2.32")]
        static GISharp.Lib.GLib.Variant.UnmanagedStruct* NewFixedArray(GISharp.Lib.GLib.VariantType elementType, System.IntPtr elements, int nElements, int elementSize)
        {
            CheckNewFixedArrayArgs(elementType, elements, nElements, elementSize);
            var elementType_ = (GISharp.Lib.GLib.VariantType.UnmanagedStruct*)elementType.UnsafeHandle;
            var elements_ = (System.IntPtr)elements;
            var nElements_ = (nuint)nElements;
            var elementSize_ = (nuint)elementSize;
            var ret_ = g_variant_new_fixed_array(elementType_,elements_,nElements_,elementSize_);
            return ret_;
        }

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.Variant(GISharp.Lib.GLib.VariantType,System.IntPtr,int,int)']/*" />
        [GISharp.Runtime.SinceAttribute("2.32")]
        public Variant(GISharp.Lib.GLib.VariantType elementType, System.IntPtr elements, int nElements, int elementSize) : this((System.IntPtr)NewFixedArray(elementType, elements, nElements, elementSize), GISharp.Runtime.Transfer.None)
        {
        }

        /// <summary>
        /// Constructs a new serialised-mode #GVariant instance.  This is the
        /// inner interface for creation of new serialised values that gets
        /// called from various functions in gvariant.c.
        /// </summary>
        /// <remarks>
        /// A reference is taken on @bytes.
        /// 
        /// The data in @bytes must be aligned appropriately for the @type being loaded.
        /// Otherwise this function will internally create a copy of the memory (since
        /// GLib 2.60) or (in older versions) fail and exit the process.
        /// </remarks>
        /// <param name="type">
        /// a #GVariantType
        /// </param>
        /// <param name="bytes">
        /// a #GBytes
        /// </param>
        /// <param name="trusted">
        /// if the contents of @bytes are trusted
        /// </param>
        /// <returns>
        /// a new #GVariant with a floating reference
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GLib.Variant.UnmanagedStruct* g_variant_new_from_bytes(
        /* <type name="VariantType" type="const GVariantType*" managed-name="VariantType" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.VariantType.UnmanagedStruct* type,
        /* <type name="Bytes" type="GBytes*" managed-name="Bytes" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Bytes.UnmanagedStruct* bytes,
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.Boolean trusted);
        static partial void CheckNewFromBytesArgs(GISharp.Lib.GLib.VariantType type, GISharp.Lib.GLib.Bytes bytes, bool trusted);

        [GISharp.Runtime.SinceAttribute("2.36")]
        static GISharp.Lib.GLib.Variant.UnmanagedStruct* NewFromBytes(GISharp.Lib.GLib.VariantType type, GISharp.Lib.GLib.Bytes bytes, bool trusted)
        {
            CheckNewFromBytesArgs(type, bytes, trusted);
            var type_ = (GISharp.Lib.GLib.VariantType.UnmanagedStruct*)type.UnsafeHandle;
            var bytes_ = (GISharp.Lib.GLib.Bytes.UnmanagedStruct*)bytes.UnsafeHandle;
            var trusted_ = GISharp.Runtime.BooleanExtensions.ToBoolean(trusted);
            var ret_ = g_variant_new_from_bytes(type_,bytes_,trusted_);
            return ret_;
        }

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.Variant(GISharp.Lib.GLib.VariantType,GISharp.Lib.GLib.Bytes,bool)']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        public Variant(GISharp.Lib.GLib.VariantType type, GISharp.Lib.GLib.Bytes bytes, bool trusted) : this((System.IntPtr)NewFromBytes(type, bytes, trusted), GISharp.Runtime.Transfer.None)
        {
        }

        /// <summary>
        /// Creates a new #GVariant instance from serialised data.
        /// </summary>
        /// <remarks>
        /// @type is the type of #GVariant instance that will be constructed.
        /// The interpretation of @data depends on knowing the type.
        /// 
        /// @data is not modified by this function and must remain valid with an
        /// unchanging value until such a time as @notify is called with
        /// @user_data.  If the contents of @data change before that time then
        /// the result is undefined.
        /// 
        /// If @data is trusted to be serialised data in normal form then
        /// @trusted should be %TRUE.  This applies to serialised data created
        /// within this process or read from a trusted location on the disk (such
        /// as a file installed in /usr/lib alongside your application).  You
        /// should set trusted to %FALSE if @data is read from the network, a
        /// file in the user's home directory, etc.
        /// 
        /// If @data was not stored in this machine's native endianness, any multi-byte
        /// numeric values in the returned variant will also be in non-native
        /// endianness. g_variant_byteswap() can be used to recover the original values.
        /// 
        /// @notify will be called with @user_data when @data is no longer
        /// needed.  The exact time of this call is unspecified and might even be
        /// before this function returns.
        /// 
        /// Note: @data must be backed by memory that is aligned appropriately for the
        /// @type being loaded. Otherwise this function will internally create a copy of
        /// the memory (since GLib 2.60) or (in older versions) fail and exit the
        /// process.
        /// </remarks>
        /// <param name="type">
        /// a definite #GVariantType
        /// </param>
        /// <param name="data">
        /// the serialised data
        /// </param>
        /// <param name="size">
        /// the size of @data
        /// </param>
        /// <param name="trusted">
        /// %TRUE if @data is definitely in normal form
        /// </param>
        /// <param name="notify">
        /// function to call when @data is no longer needed
        /// </param>
        /// <param name="userData">
        /// data for @notify
        /// </param>
        /// <returns>
        /// a new floating #GVariant of type @type
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GLib.Variant.UnmanagedStruct* g_variant_new_from_data(
        /* <type name="VariantType" type="const GVariantType*" managed-name="VariantType" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.VariantType.UnmanagedStruct* type,
        /* <array length="2" zero-terminated="0" type="gconstpointer" managed-name="GISharp.Runtime.CArray" is-pointer="1">
*   <type name="guint8" managed-name="System.Byte" />
* </array> */
        /* transfer-ownership:none direction:in */
        byte* data,
        /* <type name="gsize" type="gsize" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        nuint size,
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.Boolean trusted,
        /* <type name="DestroyNotify" type="GDestroyNotify" managed-name="DestroyNotify" /> */
        /* transfer-ownership:none scope:async direction:in */
        delegate* unmanaged[Cdecl]<System.IntPtr, void> notify,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr userData);

        /// <summary>
        /// Creates a new handle #GVariant instance.
        /// </summary>
        /// <remarks>
        /// By convention, handles are indexes into an array of file descriptors
        /// that are sent alongside a D-Bus message.  If you're not interacting
        /// with D-Bus, you probably don't need them.
        /// </remarks>
        /// <param name="value">
        /// a #gint32 value
        /// </param>
        /// <returns>
        /// a floating reference to a new handle #GVariant instance
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GLib.Variant.UnmanagedStruct* g_variant_new_handle(
        /* <type name="gint32" type="gint32" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        int value);
        static partial void CheckNewHandleArgs(int value);

        [GISharp.Runtime.SinceAttribute("2.24")]
        static GISharp.Lib.GLib.Variant.UnmanagedStruct* NewHandle(int value)
        {
            CheckNewHandleArgs(value);
            var value_ = (int)value;
            var ret_ = g_variant_new_handle(value_);
            return ret_;
        }

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.Variant(int)']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public Variant(int value) : this((System.IntPtr)NewHandle(value), GISharp.Runtime.Transfer.None)
        {
        }

        /// <summary>
        /// Creates a new int16 #GVariant instance.
        /// </summary>
        /// <param name="value">
        /// a #gint16 value
        /// </param>
        /// <returns>
        /// a floating reference to a new int16 #GVariant instance
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GLib.Variant.UnmanagedStruct* g_variant_new_int16(
        /* <type name="gint16" type="gint16" managed-name="System.Int16" /> */
        /* transfer-ownership:none direction:in */
        short value);
        static partial void CheckNewInt16Args(short value);

        [GISharp.Runtime.SinceAttribute("2.24")]
        static GISharp.Lib.GLib.Variant.UnmanagedStruct* NewInt16(short value)
        {
            CheckNewInt16Args(value);
            var value_ = (short)value;
            var ret_ = g_variant_new_int16(value_);
            return ret_;
        }

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.Variant(short)']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public Variant(short value) : this((System.IntPtr)NewInt16(value), GISharp.Runtime.Transfer.None)
        {
        }

        /// <summary>
        /// Creates a new int32 #GVariant instance.
        /// </summary>
        /// <param name="value">
        /// a #gint32 value
        /// </param>
        /// <returns>
        /// a floating reference to a new int32 #GVariant instance
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GLib.Variant.UnmanagedStruct* g_variant_new_int32(
        /* <type name="gint32" type="gint32" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        int value);
        static partial void CheckNewInt32Args(int value);

        [GISharp.Runtime.SinceAttribute("2.24")]
        static GISharp.Lib.GLib.Variant.UnmanagedStruct* NewInt32(int value)
        {
            CheckNewInt32Args(value);
            var value_ = (int)value;
            var ret_ = g_variant_new_int32(value_);
            return ret_;
        }

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.Variant(int)']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public Variant(int value) : this((System.IntPtr)NewInt32(value), GISharp.Runtime.Transfer.None)
        {
        }

        /// <summary>
        /// Creates a new int64 #GVariant instance.
        /// </summary>
        /// <param name="value">
        /// a #gint64 value
        /// </param>
        /// <returns>
        /// a floating reference to a new int64 #GVariant instance
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GLib.Variant.UnmanagedStruct* g_variant_new_int64(
        /* <type name="gint64" type="gint64" managed-name="System.Int64" /> */
        /* transfer-ownership:none direction:in */
        long value);
        static partial void CheckNewInt64Args(long value);

        [GISharp.Runtime.SinceAttribute("2.24")]
        static GISharp.Lib.GLib.Variant.UnmanagedStruct* NewInt64(long value)
        {
            CheckNewInt64Args(value);
            var value_ = (long)value;
            var ret_ = g_variant_new_int64(value_);
            return ret_;
        }

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.Variant(long)']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public Variant(long value) : this((System.IntPtr)NewInt64(value), GISharp.Runtime.Transfer.None)
        {
        }

        /// <summary>
        /// Depending on if @child is %NULL, either wraps @child inside of a
        /// maybe container or creates a Nothing instance for the given @type.
        /// </summary>
        /// <remarks>
        /// At least one of @child_type and @child must be non-%NULL.
        /// If @child_type is non-%NULL then it must be a definite type.
        /// If they are both non-%NULL then @child_type must be the type
        /// of @child.
        /// 
        /// If @child is a floating reference (see g_variant_ref_sink()), the new
        /// instance takes ownership of @child.
        /// </remarks>
        /// <param name="childType">
        /// the #GVariantType of the child, or %NULL
        /// </param>
        /// <param name="child">
        /// the child value, or %NULL
        /// </param>
        /// <returns>
        /// a floating reference to a new #GVariant maybe instance
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GLib.Variant.UnmanagedStruct* g_variant_new_maybe(
        /* <type name="VariantType" type="const GVariantType*" managed-name="VariantType" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.GLib.VariantType.UnmanagedStruct* childType,
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.GLib.Variant.UnmanagedStruct* child);
        static partial void CheckNewMaybeArgs(GISharp.Lib.GLib.VariantType? childType, GISharp.Lib.GLib.Variant? child);

        [GISharp.Runtime.SinceAttribute("2.24")]
        static GISharp.Lib.GLib.Variant.UnmanagedStruct* NewMaybe(GISharp.Lib.GLib.VariantType? childType, GISharp.Lib.GLib.Variant? child)
        {
            CheckNewMaybeArgs(childType, child);
            var childType_ = (GISharp.Lib.GLib.VariantType.UnmanagedStruct*)(childType?.UnsafeHandle ?? System.IntPtr.Zero);
            var child_ = (GISharp.Lib.GLib.Variant.UnmanagedStruct*)(child?.UnsafeHandle ?? System.IntPtr.Zero);
            var ret_ = g_variant_new_maybe(childType_,child_);
            return ret_;
        }

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.Variant(GISharp.Lib.GLib.VariantType?,GISharp.Lib.GLib.Variant?)']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public Variant(GISharp.Lib.GLib.VariantType? childType, GISharp.Lib.GLib.Variant? child) : this((System.IntPtr)NewMaybe(childType, child), GISharp.Runtime.Transfer.None)
        {
        }

        /// <summary>
        /// Creates a D-Bus object path #GVariant with the contents of @string.
        /// @string must be a valid D-Bus object path.  Use
        /// g_variant_is_object_path() if you're not sure.
        /// </summary>
        /// <param name="objectPath">
        /// a normal C nul-terminated string
        /// </param>
        /// <returns>
        /// a floating reference to a new object path #GVariant instance
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GLib.Variant.UnmanagedStruct* g_variant_new_object_path(
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* objectPath);
        static partial void CheckNewObjectPathArgs(GISharp.Lib.GLib.UnownedUtf8 objectPath);

        [GISharp.Runtime.SinceAttribute("2.24")]
        static GISharp.Lib.GLib.Variant.UnmanagedStruct* NewObjectPath(GISharp.Lib.GLib.UnownedUtf8 objectPath)
        {
            CheckNewObjectPathArgs(objectPath);
            var objectPath_ = (byte*)objectPath.UnsafeHandle;
            var ret_ = g_variant_new_object_path(objectPath_);
            return ret_;
        }

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.Variant(GISharp.Lib.GLib.UnownedUtf8)']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public Variant(GISharp.Lib.GLib.UnownedUtf8 objectPath) : this((System.IntPtr)NewObjectPath(objectPath), GISharp.Runtime.Transfer.None)
        {
        }

        /// <summary>
        /// Constructs an array of object paths #GVariant from the given array of
        /// strings.
        /// </summary>
        /// <remarks>
        /// Each string must be a valid #GVariant object path; see
        /// g_variant_is_object_path().
        /// 
        /// If @length is -1 then @strv is %NULL-terminated.
        /// </remarks>
        /// <param name="strv">
        /// an array of strings
        /// </param>
        /// <param name="length">
        /// the length of @strv, or -1
        /// </param>
        /// <returns>
        /// a new floating #GVariant instance
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.30")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GLib.Variant.UnmanagedStruct* g_variant_new_objv(
        /* <array length="1" zero-terminated="0" type="const gchar* const*" managed-name="GISharp.Runtime.CArray" is-pointer="1">
*   <type name="utf8" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" />
* </array> */
        /* transfer-ownership:none direction:in */
        byte** strv,
        /* <type name="gssize" type="gssize" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        nint length);
        static partial void CheckNewObjvArgs(GISharp.Runtime.UnownedCPtrArray<GISharp.Lib.GLib.Utf8> strv);

        [GISharp.Runtime.SinceAttribute("2.30")]
        static GISharp.Lib.GLib.Variant.UnmanagedStruct* NewObjv(GISharp.Runtime.UnownedCPtrArray<GISharp.Lib.GLib.Utf8> strv)
        {
            fixed (System.IntPtr* strvData_ = strv)
            {
                CheckNewObjvArgs(strv);
                var strv_ = (byte**)strvData_;
                var length_ = (nint)strv.Length;
                var ret_ = g_variant_new_objv(strv_,length_);
                return ret_;
            }
        }

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.Variant(GISharp.Runtime.UnownedCPtrArray&lt;GISharp.Lib.GLib.Utf8&gt;)']/*" />
        [GISharp.Runtime.SinceAttribute("2.30")]
        public Variant(GISharp.Runtime.UnownedCPtrArray<GISharp.Lib.GLib.Utf8> strv) : this((System.IntPtr)NewObjv(strv), GISharp.Runtime.Transfer.None)
        {
        }

        /// <summary>
        /// Creates a D-Bus type signature #GVariant with the contents of
        /// @string.  @string must be a valid D-Bus type signature.  Use
        /// g_variant_is_signature() if you're not sure.
        /// </summary>
        /// <param name="signature">
        /// a normal C nul-terminated string
        /// </param>
        /// <returns>
        /// a floating reference to a new signature #GVariant instance
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GLib.Variant.UnmanagedStruct* g_variant_new_signature(
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* signature);
        static partial void CheckNewSignatureArgs(GISharp.Lib.GLib.UnownedUtf8 signature);

        [GISharp.Runtime.SinceAttribute("2.24")]
        static GISharp.Lib.GLib.Variant.UnmanagedStruct* NewSignature(GISharp.Lib.GLib.UnownedUtf8 signature)
        {
            CheckNewSignatureArgs(signature);
            var signature_ = (byte*)signature.UnsafeHandle;
            var ret_ = g_variant_new_signature(signature_);
            return ret_;
        }

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.Variant(GISharp.Lib.GLib.UnownedUtf8)']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public Variant(GISharp.Lib.GLib.UnownedUtf8 signature) : this((System.IntPtr)NewSignature(signature), GISharp.Runtime.Transfer.None)
        {
        }

        /// <summary>
        /// Creates a string #GVariant with the contents of @string.
        /// </summary>
        /// <remarks>
        /// @string must be valid UTF-8, and must not be %NULL. To encode
        /// potentially-%NULL strings, use g_variant_new() with `ms` as the
        /// [format string][gvariant-format-strings-maybe-types].
        /// </remarks>
        /// <param name="string">
        /// a normal UTF-8 nul-terminated string
        /// </param>
        /// <returns>
        /// a floating reference to a new string #GVariant instance
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GLib.Variant.UnmanagedStruct* g_variant_new_string(
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* @string);
        static partial void CheckNewStringArgs(GISharp.Lib.GLib.UnownedUtf8 @string);

        [GISharp.Runtime.SinceAttribute("2.24")]
        static GISharp.Lib.GLib.Variant.UnmanagedStruct* NewString(GISharp.Lib.GLib.UnownedUtf8 @string)
        {
            CheckNewStringArgs(@string);
            var @string_ = (byte*)@string.UnsafeHandle;
            var ret_ = g_variant_new_string(@string_);
            return ret_;
        }

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.Variant(GISharp.Lib.GLib.UnownedUtf8)']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public Variant(GISharp.Lib.GLib.UnownedUtf8 @string) : this((System.IntPtr)NewString(@string), GISharp.Runtime.Transfer.None)
        {
        }

        /// <summary>
        /// Constructs an array of strings #GVariant from the given array of
        /// strings.
        /// </summary>
        /// <remarks>
        /// If @length is -1 then @strv is %NULL-terminated.
        /// </remarks>
        /// <param name="strv">
        /// an array of strings
        /// </param>
        /// <param name="length">
        /// the length of @strv, or -1
        /// </param>
        /// <returns>
        /// a new floating #GVariant instance
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GLib.Variant.UnmanagedStruct* g_variant_new_strv(
        /* <array length="1" zero-terminated="0" type="const gchar* const*" managed-name="GISharp.Runtime.CArray" is-pointer="1">
*   <type name="utf8" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" />
* </array> */
        /* transfer-ownership:none direction:in */
        byte** strv,
        /* <type name="gssize" type="gssize" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        nint length);
        static partial void CheckNewStrvArgs(GISharp.Runtime.UnownedCPtrArray<GISharp.Lib.GLib.Utf8> strv);

        [GISharp.Runtime.SinceAttribute("2.24")]
        static GISharp.Lib.GLib.Variant.UnmanagedStruct* NewStrv(GISharp.Runtime.UnownedCPtrArray<GISharp.Lib.GLib.Utf8> strv)
        {
            fixed (System.IntPtr* strvData_ = strv)
            {
                CheckNewStrvArgs(strv);
                var strv_ = (byte**)strvData_;
                var length_ = (nint)strv.Length;
                var ret_ = g_variant_new_strv(strv_,length_);
                return ret_;
            }
        }

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.Variant(GISharp.Runtime.UnownedCPtrArray&lt;GISharp.Lib.GLib.Utf8&gt;)']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public Variant(GISharp.Runtime.UnownedCPtrArray<GISharp.Lib.GLib.Utf8> strv) : this((System.IntPtr)NewStrv(strv), GISharp.Runtime.Transfer.None)
        {
        }

        /// <summary>
        /// Creates a new tuple #GVariant out of the items in @children.  The
        /// type is determined from the types of @children.  No entry in the
        /// @children array may be %NULL.
        /// </summary>
        /// <remarks>
        /// If @n_children is 0 then the unit tuple is constructed.
        /// 
        /// If the @children are floating references (see g_variant_ref_sink()), the
        /// new instance takes ownership of them as if via g_variant_ref_sink().
        /// </remarks>
        /// <param name="children">
        /// the items to make the tuple out of
        /// </param>
        /// <param name="nChildren">
        /// the length of @children
        /// </param>
        /// <returns>
        /// a floating reference to a new #GVariant tuple
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GLib.Variant.UnmanagedStruct* g_variant_new_tuple(
        /* <array length="1" zero-terminated="0" type="GVariant* const*" managed-name="GISharp.Runtime.CArray" is-pointer="1">
*   <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" />
* </array> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Variant.UnmanagedStruct** children,
        /* <type name="gsize" type="gsize" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        nuint nChildren);
        static partial void CheckNewTupleArgs(GISharp.Runtime.UnownedCPtrArray<GISharp.Lib.GLib.Variant> children);

        [GISharp.Runtime.SinceAttribute("2.24")]
        static GISharp.Lib.GLib.Variant.UnmanagedStruct* NewTuple(GISharp.Runtime.UnownedCPtrArray<GISharp.Lib.GLib.Variant> children)
        {
            fixed (System.IntPtr* childrenData_ = children)
            {
                CheckNewTupleArgs(children);
                var children_ = (GISharp.Lib.GLib.Variant.UnmanagedStruct**)childrenData_;
                var nChildren_ = (nuint)children.Length;
                var ret_ = g_variant_new_tuple(children_,nChildren_);
                return ret_;
            }
        }

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.Variant(GISharp.Runtime.UnownedCPtrArray&lt;GISharp.Lib.GLib.Variant&gt;)']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public Variant(GISharp.Runtime.UnownedCPtrArray<GISharp.Lib.GLib.Variant> children) : this((System.IntPtr)NewTuple(children), GISharp.Runtime.Transfer.None)
        {
        }

        /// <summary>
        /// Creates a new uint16 #GVariant instance.
        /// </summary>
        /// <param name="value">
        /// a #guint16 value
        /// </param>
        /// <returns>
        /// a floating reference to a new uint16 #GVariant instance
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GLib.Variant.UnmanagedStruct* g_variant_new_uint16(
        /* <type name="guint16" type="guint16" managed-name="System.UInt16" /> */
        /* transfer-ownership:none direction:in */
        ushort value);
        static partial void CheckNewUint16Args(ushort value);

        [GISharp.Runtime.SinceAttribute("2.24")]
        static GISharp.Lib.GLib.Variant.UnmanagedStruct* NewUint16(ushort value)
        {
            CheckNewUint16Args(value);
            var value_ = (ushort)value;
            var ret_ = g_variant_new_uint16(value_);
            return ret_;
        }

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.Variant(ushort)']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public Variant(ushort value) : this((System.IntPtr)NewUint16(value), GISharp.Runtime.Transfer.None)
        {
        }

        /// <summary>
        /// Creates a new uint32 #GVariant instance.
        /// </summary>
        /// <param name="value">
        /// a #guint32 value
        /// </param>
        /// <returns>
        /// a floating reference to a new uint32 #GVariant instance
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GLib.Variant.UnmanagedStruct* g_variant_new_uint32(
        /* <type name="guint32" type="guint32" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        uint value);
        static partial void CheckNewUint32Args(uint value);

        [GISharp.Runtime.SinceAttribute("2.24")]
        static GISharp.Lib.GLib.Variant.UnmanagedStruct* NewUint32(uint value)
        {
            CheckNewUint32Args(value);
            var value_ = (uint)value;
            var ret_ = g_variant_new_uint32(value_);
            return ret_;
        }

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.Variant(uint)']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public Variant(uint value) : this((System.IntPtr)NewUint32(value), GISharp.Runtime.Transfer.None)
        {
        }

        /// <summary>
        /// Creates a new uint64 #GVariant instance.
        /// </summary>
        /// <param name="value">
        /// a #guint64 value
        /// </param>
        /// <returns>
        /// a floating reference to a new uint64 #GVariant instance
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GLib.Variant.UnmanagedStruct* g_variant_new_uint64(
        /* <type name="guint64" type="guint64" managed-name="System.UInt64" /> */
        /* transfer-ownership:none direction:in */
        ulong value);
        static partial void CheckNewUint64Args(ulong value);

        [GISharp.Runtime.SinceAttribute("2.24")]
        static GISharp.Lib.GLib.Variant.UnmanagedStruct* NewUint64(ulong value)
        {
            CheckNewUint64Args(value);
            var value_ = (ulong)value;
            var ret_ = g_variant_new_uint64(value_);
            return ret_;
        }

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.Variant(ulong)']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public Variant(ulong value) : this((System.IntPtr)NewUint64(value), GISharp.Runtime.Transfer.None)
        {
        }

        /// <summary>
        /// Boxes @value.  The result is a #GVariant instance representing a
        /// variant containing the original value.
        /// </summary>
        /// <remarks>
        /// If @child is a floating reference (see g_variant_ref_sink()), the new
        /// instance takes ownership of @child.
        /// </remarks>
        /// <param name="value">
        /// a #GVariant instance
        /// </param>
        /// <returns>
        /// a floating reference to a new variant #GVariant instance
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GLib.Variant.UnmanagedStruct* g_variant_new_variant(
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Variant.UnmanagedStruct* value);
        static partial void CheckNewVariantArgs(GISharp.Lib.GLib.Variant value);

        [GISharp.Runtime.SinceAttribute("2.24")]
        static GISharp.Lib.GLib.Variant.UnmanagedStruct* NewVariant(GISharp.Lib.GLib.Variant value)
        {
            CheckNewVariantArgs(value);
            var value_ = (GISharp.Lib.GLib.Variant.UnmanagedStruct*)value.UnsafeHandle;
            var ret_ = g_variant_new_variant(value_);
            return ret_;
        }

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.Variant(GISharp.Lib.GLib.Variant)']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public Variant(GISharp.Lib.GLib.Variant value) : this((System.IntPtr)NewVariant(value), GISharp.Runtime.Transfer.None)
        {
        }

        /// <summary>
        /// Compares @one and @two.
        /// </summary>
        /// <remarks>
        /// The types of @one and @two are #gconstpointer only to allow use of
        /// this function with #GTree, #GPtrArray, etc.  They must each be a
        /// #GVariant.
        /// 
        /// Comparison is only defined for basic types (ie: booleans, numbers,
        /// strings).  For booleans, %FALSE is less than %TRUE.  Numbers are
        /// ordered in the usual way.  Strings are in ASCII lexographical order.
        /// 
        /// It is a programmer error to attempt to compare container values or
        /// two values that have types that are not exactly equal.  For example,
        /// you cannot compare a 32-bit signed integer with a 32-bit unsigned
        /// integer.  Also note that this function is not particularly
        /// well-behaved when it comes to comparison of doubles; in particular,
        /// the handling of incomparable values (ie: NaN) is undefined.
        /// 
        /// If you only require an equality comparison, g_variant_equal() is more
        /// general.
        /// </remarks>
        /// <param name="one">
        /// a basic-typed #GVariant instance
        /// </param>
        /// <param name="two">
        /// a #GVariant instance of the same type
        /// </param>
        /// <returns>
        /// negative value if a &lt; b;
        ///          zero if a = b;
        ///          positive value if a &gt; b.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.26")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gint" type="gint" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        private static extern int g_variant_compare(
        /* <type name="Variant" type="gconstpointer" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Variant.UnmanagedStruct* one,
        /* <type name="Variant" type="gconstpointer" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Variant.UnmanagedStruct* two);
        static partial void CheckCompareArgs(GISharp.Lib.GLib.Variant one, GISharp.Lib.GLib.Variant two);

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.Compare(GISharp.Lib.GLib.Variant,GISharp.Lib.GLib.Variant)']/*" />
        [GISharp.Runtime.SinceAttribute("2.26")]
        public static int Compare(GISharp.Lib.GLib.Variant one, GISharp.Lib.GLib.Variant two)
        {
            CheckCompareArgs(one, two);
            var one_ = (GISharp.Lib.GLib.Variant.UnmanagedStruct*)one.UnsafeHandle;
            var two_ = (GISharp.Lib.GLib.Variant.UnmanagedStruct*)two.UnsafeHandle;
            var ret_ = g_variant_compare(one_,two_);
            var ret = (int)ret_;
            return ret;
        }

        /// <inheritdoc/>
        /// <seealso cref="GISharp.Lib.GLib.Variant.Compare"/>
        public System.Int32 CompareTo(GISharp.Lib.GLib.Variant? other)
        {
            return Compare(this, other ?? throw new System.ArgumentNullException(nameof(other)));
        }

        /// <inheritdoc/>
        public static System.Boolean operator <(GISharp.Lib.GLib.Variant one, GISharp.Lib.GLib.Variant two)
        {
            return Compare(one, two) < 0;
        }

        /// <inheritdoc/>
        public static System.Boolean operator >(GISharp.Lib.GLib.Variant one, GISharp.Lib.GLib.Variant two)
        {
            return Compare(one, two) > 0;
        }

        /// <inheritdoc/>
        public static System.Boolean operator <=(GISharp.Lib.GLib.Variant one, GISharp.Lib.GLib.Variant two)
        {
            return Compare(one, two) <= 0;
        }

        /// <inheritdoc/>
        public static System.Boolean operator >=(GISharp.Lib.GLib.Variant one, GISharp.Lib.GLib.Variant two)
        {
            return Compare(one, two) >= 0;
        }

        /// <summary>
        /// Determines if a given string is a valid D-Bus object path.  You
        /// should ensure that a string is a valid D-Bus object path before
        /// passing it to g_variant_new_object_path().
        /// </summary>
        /// <remarks>
        /// A valid object path starts with `/` followed by zero or more
        /// sequences of characters separated by `/` characters.  Each sequence
        /// must contain only the characters `[A-Z][a-z][0-9]_`.  No sequence
        /// (including the one following the final `/` character) may be empty.
        /// </remarks>
        /// <param name="string">
        /// a normal C nul-terminated string
        /// </param>
        /// <returns>
        /// %TRUE if @string is a D-Bus object path
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_variant_is_object_path(
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* @string);
        static partial void CheckIsObjectPathArgs(GISharp.Lib.GLib.UnownedUtf8 @string);

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.IsObjectPath(GISharp.Lib.GLib.UnownedUtf8)']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public static bool IsObjectPath(GISharp.Lib.GLib.UnownedUtf8 @string)
        {
            CheckIsObjectPathArgs(@string);
            var @string_ = (byte*)@string.UnsafeHandle;
            var ret_ = g_variant_is_object_path(@string_);
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Determines if a given string is a valid D-Bus type signature.  You
        /// should ensure that a string is a valid D-Bus type signature before
        /// passing it to g_variant_new_signature().
        /// </summary>
        /// <remarks>
        /// D-Bus type signatures consist of zero or more definite #GVariantType
        /// strings in sequence.
        /// </remarks>
        /// <param name="string">
        /// a normal C nul-terminated string
        /// </param>
        /// <returns>
        /// %TRUE if @string is a D-Bus type signature
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_variant_is_signature(
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* @string);
        static partial void CheckIsSignatureArgs(GISharp.Lib.GLib.UnownedUtf8 @string);

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.IsSignature(GISharp.Lib.GLib.UnownedUtf8)']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public static bool IsSignature(GISharp.Lib.GLib.UnownedUtf8 @string)
        {
            CheckIsSignatureArgs(@string);
            var @string_ = (byte*)@string.UnsafeHandle;
            var ret_ = g_variant_is_signature(@string_);
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Parses a #GVariant from a text representation.
        /// </summary>
        /// <remarks>
        /// A single #GVariant is parsed from the content of @text.
        /// 
        /// The format is described [here][gvariant-text].
        /// 
        /// The memory at @limit will never be accessed and the parser behaves as
        /// if the character at @limit is the nul terminator.  This has the
        /// effect of bounding @text.
        /// 
        /// If @endptr is non-%NULL then @text is permitted to contain data
        /// following the value that this function parses and @endptr will be
        /// updated to point to the first character past the end of the text
        /// parsed by this function.  If @endptr is %NULL and there is extra data
        /// then an error is returned.
        /// 
        /// If @type is non-%NULL then the value will be parsed to have that
        /// type.  This may result in additional parse errors (in the case that
        /// the parsed value doesn't fit the type) but may also result in fewer
        /// errors (in the case that the type would have been ambiguous, such as
        /// with empty arrays).
        /// 
        /// In the event that the parsing is successful, the resulting #GVariant
        /// is returned. It is never floating, and must be freed with
        /// g_variant_unref().
        /// 
        /// In case of any error, %NULL will be returned.  If @error is non-%NULL
        /// then it will be set to reflect the error that occurred.
        /// 
        /// Officially, the language understood by the parser is "any string
        /// produced by g_variant_print()".
        /// 
        /// There may be implementation specific restrictions on deeply nested values,
        /// which would result in a %G_VARIANT_PARSE_ERROR_RECURSION error. #GVariant is
        /// guaranteed to handle nesting up to at least 64 levels.
        /// </remarks>
        /// <param name="type">
        /// a #GVariantType, or %NULL
        /// </param>
        /// <param name="text">
        /// a string containing a GVariant in text form
        /// </param>
        /// <param name="limit">
        /// a pointer to the end of @text, or %NULL
        /// </param>
        /// <param name="endptr">
        /// a location to store the end pointer, or %NULL
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// a non-floating reference to a #GVariant, or %NULL
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GLib.Variant.UnmanagedStruct* g_variant_parse(
        /* <type name="VariantType" type="const GVariantType*" managed-name="VariantType" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.GLib.VariantType.UnmanagedStruct* type,
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* text,
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        byte* limit,
        /* <type name="utf8" type="const gchar**" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        byte* endptr,
        /* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);
        static partial void CheckParseArgs(GISharp.Lib.GLib.VariantType? type, GISharp.Lib.GLib.UnownedUtf8 text, GISharp.Lib.GLib.NullableUnownedUtf8 limit, GISharp.Lib.GLib.NullableUnownedUtf8 endptr);

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.Parse(GISharp.Lib.GLib.VariantType?,GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.GLib.NullableUnownedUtf8,GISharp.Lib.GLib.NullableUnownedUtf8)']/*" />
        public static GISharp.Lib.GLib.Variant Parse(GISharp.Lib.GLib.VariantType? type, GISharp.Lib.GLib.UnownedUtf8 text, GISharp.Lib.GLib.NullableUnownedUtf8 limit, GISharp.Lib.GLib.NullableUnownedUtf8 endptr)
        {
            CheckParseArgs(type, text, limit, endptr);
            var type_ = (GISharp.Lib.GLib.VariantType.UnmanagedStruct*)(type?.UnsafeHandle ?? System.IntPtr.Zero);
            var text_ = (byte*)text.UnsafeHandle;
            var limit_ = (byte*)limit.UnsafeHandle;
            var endptr_ = (byte*)endptr.UnsafeHandle;
            var error_ = default(GISharp.Lib.GLib.Error.UnmanagedStruct*);
            var ret_ = g_variant_parse(type_,text_,limit_,endptr_,&error_);
            if (error_ is not null)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>((System.IntPtr)error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Runtime.GErrorException(error);
            }

            var ret = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Variant>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Pretty-prints a message showing the context of a #GVariant parse
        /// error within the string for which parsing was attempted.
        /// </summary>
        /// <remarks>
        /// The resulting string is suitable for output to the console or other
        /// monospace media where newlines are treated in the usual way.
        /// 
        /// The message will typically look something like one of the following:
        /// 
        /// |[
        /// unterminated string constant:
        ///   (1, 2, 3, 'abc
        ///             ^^^^
        /// ]|
        /// 
        /// or
        /// 
        /// |[
        /// unable to find a common type:
        ///   [1, 2, 3, 'str']
        ///    ^        ^^^^^
        /// ]|
        /// 
        /// The format of the message may change in a future version.
        /// 
        /// @error must have come from a failed attempt to g_variant_parse() and
        /// @source_str must be exactly the same string that caused the error.
        /// If @source_str was not nul-terminated when you passed it to
        /// g_variant_parse() then you must add nul termination before using this
        /// function.
        /// </remarks>
        /// <param name="error">
        /// a #GError from the #GVariantParseError domain
        /// </param>
        /// <param name="sourceStr">
        /// the string that was given to the parser
        /// </param>
        /// <returns>
        /// the printed message
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.40")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern byte* g_variant_parse_error_print_context(
        /* <type name="Error" type="GError*" managed-name="Error" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Error.UnmanagedStruct* error,
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* sourceStr);
        static partial void CheckParseErrorPrintContextArgs(GISharp.Lib.GLib.Error error, GISharp.Lib.GLib.UnownedUtf8 sourceStr);

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.ParseErrorPrintContext(GISharp.Lib.GLib.Error,GISharp.Lib.GLib.UnownedUtf8)']/*" />
        [GISharp.Runtime.SinceAttribute("2.40")]
        public static GISharp.Lib.GLib.Utf8 ParseErrorPrintContext(GISharp.Lib.GLib.Error error, GISharp.Lib.GLib.UnownedUtf8 sourceStr)
        {
            CheckParseErrorPrintContextArgs(error, sourceStr);
            var error_ = (GISharp.Lib.GLib.Error.UnmanagedStruct*)error.UnsafeHandle;
            var sourceStr_ = (byte*)sourceStr.UnsafeHandle;
            var ret_ = g_variant_parse_error_print_context(error_,sourceStr_);
            var ret = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Utf8>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Quark" type="GQuark" managed-name="Quark" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GLib.Quark g_variant_parse_error_quark();
        static partial void CheckParseErrorQuarkArgs();

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.ParseErrorQuark()']/*" />
        public static GISharp.Lib.GLib.Quark ParseErrorQuark()
        {
            CheckParseErrorQuarkArgs();
            var ret_ = g_variant_parse_error_quark();
            var ret = (GISharp.Lib.GLib.Quark)ret_;
            return ret;
        }

        /// <summary>
        /// Same as g_variant_error_quark().
        /// </summary>
        [System.ObsoleteAttribute("Use g_variant_parse_error_quark() instead.")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Quark" type="GQuark" managed-name="Quark" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GLib.Quark g_variant_parser_get_error_quark();
        static partial void CheckParserGetErrorQuarkArgs();

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.ParserGetErrorQuark()']/*" />
        [System.ObsoleteAttribute("Use g_variant_parse_error_quark() instead.")]
        public static GISharp.Lib.GLib.Quark ParserGetErrorQuark()
        {
            CheckParserGetErrorQuarkArgs();
            var ret_ = g_variant_parser_get_error_quark();
            var ret = (GISharp.Lib.GLib.Quark)ret_;
            return ret;
        }

        /// <summary>
        /// Performs a byteswapping operation on the contents of @value.  The
        /// result is that all multi-byte numeric data contained in @value is
        /// byteswapped.  That includes 16, 32, and 64bit signed and unsigned
        /// integers as well as file handles and double precision floating point
        /// values.
        /// </summary>
        /// <remarks>
        /// This function is an identity mapping on any value that does not
        /// contain multi-byte numeric data.  That include strings, booleans,
        /// bytes and containers containing only these things (recursively).
        /// 
        /// The returned value is always in normal form and is marked as trusted.
        /// </remarks>
        /// <param name="value">
        /// a #GVariant
        /// </param>
        /// <returns>
        /// the byteswapped form of @value
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GLib.Variant.UnmanagedStruct* g_variant_byteswap(
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Variant.UnmanagedStruct* value);
        partial void CheckByteswapArgs();

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.Byteswap()']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public GISharp.Lib.GLib.Variant Byteswap()
        {
            CheckByteswapArgs();
            var value_ = (GISharp.Lib.GLib.Variant.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_variant_byteswap(value_);
            var ret = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Variant>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Checks if calling g_variant_get() with @format_string on @value would
        /// be valid from a type-compatibility standpoint.  @format_string is
        /// assumed to be a valid format string (from a syntactic standpoint).
        /// </summary>
        /// <remarks>
        /// If @copy_only is %TRUE then this function additionally checks that it
        /// would be safe to call g_variant_unref() on @value immediately after
        /// the call to g_variant_get() without invalidating the result.  This is
        /// only possible if deep copies are made (ie: there are no pointers to
        /// the data inside of the soon-to-be-freed #GVariant instance).  If this
        /// check fails then a g_critical() is printed and %FALSE is returned.
        /// 
        /// This function is meant to be used by functions that wish to provide
        /// varargs accessors to #GVariant values of uncertain values (eg:
        /// g_variant_lookup() or g_menu_model_get_item_attribute()).
        /// </remarks>
        /// <param name="value">
        /// a #GVariant
        /// </param>
        /// <param name="formatString">
        /// a valid #GVariant format string
        /// </param>
        /// <param name="copyOnly">
        /// %TRUE to ensure the format string makes deep copies
        /// </param>
        /// <returns>
        /// %TRUE if @format_string is safe to use
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.34")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_variant_check_format_string(
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Variant.UnmanagedStruct* value,
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* formatString,
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.Boolean copyOnly);
        partial void CheckCheckFormatStringArgs(GISharp.Lib.GLib.UnownedUtf8 formatString, bool copyOnly);

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.CheckFormatString(GISharp.Lib.GLib.UnownedUtf8,bool)']/*" />
        [GISharp.Runtime.SinceAttribute("2.34")]
        public bool CheckFormatString(GISharp.Lib.GLib.UnownedUtf8 formatString, bool copyOnly)
        {
            CheckCheckFormatStringArgs(formatString, copyOnly);
            var value_ = (GISharp.Lib.GLib.Variant.UnmanagedStruct*)UnsafeHandle;
            var formatString_ = (byte*)formatString.UnsafeHandle;
            var copyOnly_ = GISharp.Runtime.BooleanExtensions.ToBoolean(copyOnly);
            var ret_ = g_variant_check_format_string(value_,formatString_,copyOnly_);
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Classifies @value according to its top-level type.
        /// </summary>
        /// <param name="value">
        /// a #GVariant
        /// </param>
        /// <returns>
        /// the #GVariantClass of @value
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="VariantClass" type="GVariantClass" managed-name="VariantClass" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GLib.VariantClass g_variant_classify(
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Variant.UnmanagedStruct* value);
        partial void CheckClassifyArgs();

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.Classify()']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public GISharp.Lib.GLib.VariantClass Classify()
        {
            CheckClassifyArgs();
            var value_ = (GISharp.Lib.GLib.Variant.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_variant_classify(value_);
            var ret = (GISharp.Lib.GLib.VariantClass)ret_;
            return ret;
        }

        /// <summary>
        /// Similar to g_variant_get_bytestring() except that instead of
        /// returning a constant string, the string is duplicated.
        /// </summary>
        /// <remarks>
        /// The return value must be freed using g_free().
        /// </remarks>
        /// <param name="value">
        /// an array-of-bytes #GVariant instance
        /// </param>
        /// <param name="length">
        /// a pointer to a #gsize, to store
        ///          the length (not including the nul terminator)
        /// </param>
        /// <returns>
        /// 
        ///          a newly allocated string
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.26")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <array length="0" zero-terminated="1" type="gchar*" managed-name="GISharp.Runtime.CArray" is-pointer="1">
*   <type name="guint8" managed-name="System.Byte" />
* </array> */
        /* transfer-ownership:full direction:in */
        private static extern byte* g_variant_dup_bytestring(
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Variant.UnmanagedStruct* value,
        /* <type name="gsize" type="gsize*" managed-name="System.Int32" /> */
        /* direction:out caller-allocates:0 transfer-ownership:full optional:1 allow-none:1 */
        nuint* length);
        partial void CheckDupBytestringArgs();

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.DupBytestring()']/*" />
        [GISharp.Runtime.SinceAttribute("2.26")]
        public GISharp.Runtime.CArray<byte> DupBytestring()
        {
            CheckDupBytestringArgs();
            var value_ = (GISharp.Lib.GLib.Variant.UnmanagedStruct*)UnsafeHandle;
            nuint length_;
            var ret_ = g_variant_dup_bytestring(value_,&length_);
            var ret = new GISharp.Runtime.CArray<byte>((System.IntPtr)ret_, (int)length_, GISharp.Runtime.Transfer.Full);
            return ret;
        }

        /// <summary>
        /// Gets the contents of an array of array of bytes #GVariant.  This call
        /// makes a deep copy; the return result should be released with
        /// g_strfreev().
        /// </summary>
        /// <remarks>
        /// If @length is non-%NULL then the number of elements in the result is
        /// stored there.  In any case, the resulting array will be
        /// %NULL-terminated.
        /// 
        /// For an empty array, @length will be set to 0 and a pointer to a
        /// %NULL pointer will be returned.
        /// </remarks>
        /// <param name="value">
        /// an array of array of bytes #GVariant ('aay')
        /// </param>
        /// <param name="length">
        /// the length of the result, or %NULL
        /// </param>
        /// <returns>
        /// an array of strings
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.26")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <array length="0" zero-terminated="0" type="gchar**" managed-name="GISharp.Runtime.CArray" is-pointer="1">
*   <type name="utf8" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" />
* </array> */
        /* transfer-ownership:full direction:in */
        private static extern byte** g_variant_dup_bytestring_array(
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Variant.UnmanagedStruct* value,
        /* <type name="gsize" type="gsize*" managed-name="System.Int32" /> */
        /* direction:out caller-allocates:0 transfer-ownership:full optional:1 allow-none:1 */
        nuint* length);
        partial void CheckDupBytestringArrayArgs();

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.DupBytestringArray()']/*" />
        [GISharp.Runtime.SinceAttribute("2.26")]
        public GISharp.Runtime.CPtrArray<GISharp.Lib.GLib.Utf8> DupBytestringArray()
        {
            CheckDupBytestringArrayArgs();
            var value_ = (GISharp.Lib.GLib.Variant.UnmanagedStruct*)UnsafeHandle;
            nuint length_;
            var ret_ = g_variant_dup_bytestring_array(value_,&length_);
            var ret = new GISharp.Runtime.CPtrArray<GISharp.Lib.GLib.Utf8>((System.IntPtr)ret_, (int)length_, GISharp.Runtime.Transfer.Full);
            return ret;
        }

        /// <summary>
        /// Gets the contents of an array of object paths #GVariant.  This call
        /// makes a deep copy; the return result should be released with
        /// g_strfreev().
        /// </summary>
        /// <remarks>
        /// If @length is non-%NULL then the number of elements in the result
        /// is stored there.  In any case, the resulting array will be
        /// %NULL-terminated.
        /// 
        /// For an empty array, @length will be set to 0 and a pointer to a
        /// %NULL pointer will be returned.
        /// </remarks>
        /// <param name="value">
        /// an array of object paths #GVariant
        /// </param>
        /// <param name="length">
        /// the length of the result, or %NULL
        /// </param>
        /// <returns>
        /// an array of strings
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.30")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <array length="0" zero-terminated="1" type="gchar**" name="GLib.Strv" managed-name="GISharp.Lib.GLib.Strv" is-pointer="1">
*   <type name="utf8" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" />
* </array> */
        /* transfer-ownership:full direction:in */
        private static extern byte** g_variant_dup_objv(
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Variant.UnmanagedStruct* value,
        /* <type name="gsize" type="gsize*" managed-name="System.Int32" /> */
        /* direction:out caller-allocates:0 transfer-ownership:full optional:1 allow-none:1 */
        nuint* length);
        partial void CheckDupObjvArgs();

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.DupObjv()']/*" />
        [GISharp.Runtime.SinceAttribute("2.30")]
        public GISharp.Lib.GLib.Strv DupObjv()
        {
            CheckDupObjvArgs();
            var value_ = (GISharp.Lib.GLib.Variant.UnmanagedStruct*)UnsafeHandle;
            nuint length_;
            var ret_ = g_variant_dup_objv(value_,&length_);
            var ret = new GISharp.Lib.GLib.Strv((System.IntPtr)ret_, (int)length_, GISharp.Runtime.Transfer.Full);
            return ret;
        }

        /// <summary>
        /// Similar to g_variant_get_string() except that instead of returning
        /// a constant string, the string is duplicated.
        /// </summary>
        /// <remarks>
        /// The string will always be UTF-8 encoded.
        /// 
        /// The return value must be freed using g_free().
        /// </remarks>
        /// <param name="value">
        /// a string #GVariant instance
        /// </param>
        /// <param name="length">
        /// a pointer to a #gsize, to store the length
        /// </param>
        /// <returns>
        /// a newly allocated string, UTF-8 encoded
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern byte* g_variant_dup_string(
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Variant.UnmanagedStruct* value,
        /* <type name="gsize" type="gsize*" managed-name="System.Int32" /> */
        /* direction:out caller-allocates:0 transfer-ownership:full */
        nuint* length);
        partial void CheckDupStringArgs();

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.DupString(int)']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public GISharp.Lib.GLib.Utf8 DupString(out int length)
        {
            CheckDupStringArgs();
            var value_ = (GISharp.Lib.GLib.Variant.UnmanagedStruct*)UnsafeHandle;
            nuint length_;
            var ret_ = g_variant_dup_string(value_,&length_);
            length = (int)length_;
            var ret = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Utf8>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Gets the contents of an array of strings #GVariant.  This call
        /// makes a deep copy; the return result should be released with
        /// g_strfreev().
        /// </summary>
        /// <remarks>
        /// If @length is non-%NULL then the number of elements in the result
        /// is stored there.  In any case, the resulting array will be
        /// %NULL-terminated.
        /// 
        /// For an empty array, @length will be set to 0 and a pointer to a
        /// %NULL pointer will be returned.
        /// </remarks>
        /// <param name="value">
        /// an array of strings #GVariant
        /// </param>
        /// <param name="length">
        /// the length of the result, or %NULL
        /// </param>
        /// <returns>
        /// an array of strings
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <array length="0" zero-terminated="1" type="gchar**" name="GLib.Strv" managed-name="GISharp.Lib.GLib.Strv" is-pointer="1">
*   <type name="utf8" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" />
* </array> */
        /* transfer-ownership:full direction:in */
        private static extern byte** g_variant_dup_strv(
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Variant.UnmanagedStruct* value,
        /* <type name="gsize" type="gsize*" managed-name="System.Int32" /> */
        /* direction:out caller-allocates:0 transfer-ownership:full optional:1 allow-none:1 */
        nuint* length);
        partial void CheckDupStrvArgs();

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.DupStrv()']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public GISharp.Lib.GLib.Strv DupStrv()
        {
            CheckDupStrvArgs();
            var value_ = (GISharp.Lib.GLib.Variant.UnmanagedStruct*)UnsafeHandle;
            nuint length_;
            var ret_ = g_variant_dup_strv(value_,&length_);
            var ret = new GISharp.Lib.GLib.Strv((System.IntPtr)ret_, (int)length_, GISharp.Runtime.Transfer.Full);
            return ret;
        }

        /// <summary>
        /// Checks if @one and @two have the same type and value.
        /// </summary>
        /// <remarks>
        /// The types of @one and @two are #gconstpointer only to allow use of
        /// this function with #GHashTable.  They must each be a #GVariant.
        /// </remarks>
        /// <param name="one">
        /// a #GVariant instance
        /// </param>
        /// <param name="two">
        /// a #GVariant instance
        /// </param>
        /// <returns>
        /// %TRUE if @one and @two are equal
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_variant_equal(
        /* <type name="Variant" type="gconstpointer" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Variant.UnmanagedStruct* one,
        /* <type name="Variant" type="gconstpointer" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Variant.UnmanagedStruct* two);
        partial void CheckEqualsArgs(GISharp.Lib.GLib.Variant two);

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.Equals(GISharp.Lib.GLib.Variant?)']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public bool Equals(GISharp.Lib.GLib.Variant? two)
        {
            if (two is null)
            {
                return false;
            }

            CheckEqualsArgs(two);
            var one_ = (GISharp.Lib.GLib.Variant.UnmanagedStruct*)UnsafeHandle;
            var two_ = (GISharp.Lib.GLib.Variant.UnmanagedStruct*)two.UnsafeHandle;
            var ret_ = g_variant_equal(one_,two_);
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <inheritdoc/>
        public override bool Equals(object? other)
        {
            if (other is GISharp.Lib.GLib.Variant variant)
            {
                return Equals(variant);
            }

            return base.Equals(other);
        }

        /// <inheritdoc/>
        public static bool operator ==(GISharp.Lib.GLib.Variant a, GISharp.Lib.GLib.Variant b)
        {
            return a.Equals(b);
        }

        /// <inheritdoc/>
        public static System.Boolean operator !=(GISharp.Lib.GLib.Variant a, GISharp.Lib.GLib.Variant b)
        {
            return !a.Equals(b);
        }

        /// <summary>
        /// Returns the boolean value of @value.
        /// </summary>
        /// <remarks>
        /// It is an error to call this function with a @value of any type
        /// other than %G_VARIANT_TYPE_BOOLEAN.
        /// </remarks>
        /// <param name="value">
        /// a boolean #GVariant instance
        /// </param>
        /// <returns>
        /// %TRUE or %FALSE
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_variant_get_boolean(
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Variant.UnmanagedStruct* value);
        partial void CheckGetBooleanArgs();

        [GISharp.Runtime.SinceAttribute("2.24")]
        private bool GetBoolean()
        {
            CheckGetBooleanArgs();
            var value_ = (GISharp.Lib.GLib.Variant.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_variant_get_boolean(value_);
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Returns the byte value of @value.
        /// </summary>
        /// <remarks>
        /// It is an error to call this function with a @value of any type
        /// other than %G_VARIANT_TYPE_BYTE.
        /// </remarks>
        /// <param name="value">
        /// a byte #GVariant instance
        /// </param>
        /// <returns>
        /// a #guint8
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="guint8" type="guint8" managed-name="System.Byte" /> */
        /* transfer-ownership:none direction:in */
        private static extern byte g_variant_get_byte(
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Variant.UnmanagedStruct* value);
        partial void CheckGetByteArgs();

        [GISharp.Runtime.SinceAttribute("2.24")]
        private byte GetByte()
        {
            CheckGetByteArgs();
            var value_ = (GISharp.Lib.GLib.Variant.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_variant_get_byte(value_);
            var ret = (byte)ret_;
            return ret;
        }

        /// <summary>
        /// Returns the string value of a #GVariant instance with an
        /// array-of-bytes type.  The string has no particular encoding.
        /// </summary>
        /// <remarks>
        /// If the array does not end with a nul terminator character, the empty
        /// string is returned.  For this reason, you can always trust that a
        /// non-%NULL nul-terminated string will be returned by this function.
        /// 
        /// If the array contains a nul terminator character somewhere other than
        /// the last byte then the returned string is the string, up to the first
        /// such nul character.
        /// 
        /// g_variant_get_fixed_array() should be used instead if the array contains
        /// arbitrary data that could not be nul-terminated or could contain nul bytes.
        /// 
        /// It is an error to call this function with a @value that is not an
        /// array of bytes.
        /// 
        /// The return value remains valid as long as @value exists.
        /// </remarks>
        /// <param name="value">
        /// an array-of-bytes #GVariant instance
        /// </param>
        /// <returns>
        /// 
        ///          the constant string
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.26")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <array type="const gchar*" zero-terminated="1" managed-name="GISharp.Runtime.CArray" is-pointer="1">
*   <type name="guint8" managed-name="System.Byte" />
* </array> */
        /* transfer-ownership:none direction:in */
        private static extern byte* g_variant_get_bytestring(
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Variant.UnmanagedStruct* value);
        partial void CheckGetBytestringArgs();

        [GISharp.Runtime.SinceAttribute("2.26")]
        private System.ReadOnlySpan<byte> GetBytestring()
        {
            CheckGetBytestringArgs();
            var value_ = (GISharp.Lib.GLib.Variant.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_variant_get_bytestring(value_);
            var ret = new System.ReadOnlySpan<byte>(ret_, -1);
            return ret;
        }

        /// <summary>
        /// Gets the contents of an array of array of bytes #GVariant.  This call
        /// makes a shallow copy; the return result should be released with
        /// g_free(), but the individual strings must not be modified.
        /// </summary>
        /// <remarks>
        /// If @length is non-%NULL then the number of elements in the result is
        /// stored there.  In any case, the resulting array will be
        /// %NULL-terminated.
        /// 
        /// For an empty array, @length will be set to 0 and a pointer to a
        /// %NULL pointer will be returned.
        /// </remarks>
        /// <param name="value">
        /// an array of array of bytes #GVariant ('aay')
        /// </param>
        /// <param name="length">
        /// the length of the result, or %NULL
        /// </param>
        /// <returns>
        /// an array of constant strings
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.26")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <array length="0" zero-terminated="0" type="const gchar**" managed-name="GISharp.Runtime.CArray" is-pointer="1">
*   <type name="utf8" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" />
* </array> */
        /* transfer-ownership:container direction:in */
        private static extern byte** g_variant_get_bytestring_array(
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Variant.UnmanagedStruct* value,
        /* <type name="gsize" type="gsize*" managed-name="System.Int32" /> */
        /* direction:out caller-allocates:0 transfer-ownership:full optional:1 allow-none:1 */
        nuint* length);
        partial void CheckGetBytestringArrayArgs();

        [GISharp.Runtime.SinceAttribute("2.26")]
        private GISharp.Runtime.CPtrArray<GISharp.Lib.GLib.Utf8> GetBytestringArray()
        {
            CheckGetBytestringArrayArgs();
            var value_ = (GISharp.Lib.GLib.Variant.UnmanagedStruct*)UnsafeHandle;
            nuint length_;
            var ret_ = g_variant_get_bytestring_array(value_,&length_);
            var ret = new GISharp.Runtime.CPtrArray<GISharp.Lib.GLib.Utf8>((System.IntPtr)ret_, (int)length_, GISharp.Runtime.Transfer.Container);
            return ret;
        }

        /// <summary>
        /// Reads a child item out of a container #GVariant instance.  This
        /// includes variants, maybes, arrays, tuples and dictionary
        /// entries.  It is an error to call this function on any other type of
        /// #GVariant.
        /// </summary>
        /// <remarks>
        /// It is an error if @index_ is greater than the number of child items
        /// in the container.  See g_variant_n_children().
        /// 
        /// The returned value is never floating.  You should free it with
        /// g_variant_unref() when you're done with it.
        /// 
        /// Note that values borrowed from the returned child are not guaranteed to
        /// still be valid after the child is freed even if you still hold a reference
        /// to @value, if @value has not been serialised at the time this function is
        /// called. To avoid this, you can serialize @value by calling
        /// g_variant_get_data() and optionally ignoring the return value.
        /// 
        /// There may be implementation specific restrictions on deeply nested values,
        /// which would result in the unit tuple being returned as the child value,
        /// instead of further nested children. #GVariant is guaranteed to handle
        /// nesting up to at least 64 levels.
        /// 
        /// This function is O(1).
        /// </remarks>
        /// <param name="value">
        /// a container #GVariant
        /// </param>
        /// <param name="index">
        /// the index of the child to fetch
        /// </param>
        /// <returns>
        /// the child at the specified index
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GLib.Variant.UnmanagedStruct* g_variant_get_child_value(
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Variant.UnmanagedStruct* value,
        /* <type name="gsize" type="gsize" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        nuint index);
        partial void CheckGetChildValueArgs(int index);

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.GetChildValue(int)']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public GISharp.Lib.GLib.Variant GetChildValue(int index)
        {
            CheckGetChildValueArgs(index);
            var value_ = (GISharp.Lib.GLib.Variant.UnmanagedStruct*)UnsafeHandle;
            var index_ = (nuint)index;
            var ret_ = g_variant_get_child_value(value_,index_);
            var ret = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Variant>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Returns a pointer to the serialised form of a #GVariant instance.
        /// The returned data may not be in fully-normalised form if read from an
        /// untrusted source.  The returned data must not be freed; it remains
        /// valid for as long as @value exists.
        /// </summary>
        /// <remarks>
        /// If @value is a fixed-sized value that was deserialised from a
        /// corrupted serialised container then %NULL may be returned.  In this
        /// case, the proper thing to do is typically to use the appropriate
        /// number of nul bytes in place of @value.  If @value is not fixed-sized
        /// then %NULL is never returned.
        /// 
        /// In the case that @value is already in serialised form, this function
        /// is O(1).  If the value is not already in serialised form,
        /// serialisation occurs implicitly and is approximately O(n) in the size
        /// of the result.
        /// 
        /// To deserialise the data returned by this function, in addition to the
        /// serialised data, you must know the type of the #GVariant, and (if the
        /// machine might be different) the endianness of the machine that stored
        /// it. As a result, file formats or network messages that incorporate
        /// serialised #GVariants must include this information either
        /// implicitly (for instance "the file always contains a
        /// %G_VARIANT_TYPE_VARIANT and it is always in little-endian order") or
        /// explicitly (by storing the type and/or endianness in addition to the
        /// serialised data).
        /// </remarks>
        /// <param name="value">
        /// a #GVariant instance
        /// </param>
        /// <returns>
        /// the serialised form of @value, or %NULL
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gpointer" type="gconstpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 direction:in */
        private static extern System.IntPtr g_variant_get_data(
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Variant.UnmanagedStruct* value);
        partial void CheckGetDataArgs();

        [GISharp.Runtime.SinceAttribute("2.24")]
        private System.IntPtr GetData()
        {
            CheckGetDataArgs();
            var value_ = (GISharp.Lib.GLib.Variant.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_variant_get_data(value_);
            var ret = (System.IntPtr)ret_;
            return ret;
        }

        /// <summary>
        /// Returns a pointer to the serialised form of a #GVariant instance.
        /// The semantics of this function are exactly the same as
        /// g_variant_get_data(), except that the returned #GBytes holds
        /// a reference to the variant data.
        /// </summary>
        /// <param name="value">
        /// a #GVariant
        /// </param>
        /// <returns>
        /// A new #GBytes representing the variant data
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Bytes" type="GBytes*" managed-name="Bytes" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GLib.Bytes.UnmanagedStruct* g_variant_get_data_as_bytes(
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Variant.UnmanagedStruct* value);
        partial void CheckGetDataAsBytesArgs();

        [GISharp.Runtime.SinceAttribute("2.36")]
        private GISharp.Lib.GLib.Bytes GetDataAsBytes()
        {
            CheckGetDataAsBytesArgs();
            var value_ = (GISharp.Lib.GLib.Variant.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_variant_get_data_as_bytes(value_);
            var ret = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Bytes>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Returns the double precision floating point value of @value.
        /// </summary>
        /// <remarks>
        /// It is an error to call this function with a @value of any type
        /// other than %G_VARIANT_TYPE_DOUBLE.
        /// </remarks>
        /// <param name="value">
        /// a double #GVariant instance
        /// </param>
        /// <returns>
        /// a #gdouble
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gdouble" type="gdouble" managed-name="System.Double" /> */
        /* transfer-ownership:none direction:in */
        private static extern double g_variant_get_double(
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Variant.UnmanagedStruct* value);
        partial void CheckGetDoubleArgs();

        [GISharp.Runtime.SinceAttribute("2.24")]
        private double GetDouble()
        {
            CheckGetDoubleArgs();
            var value_ = (GISharp.Lib.GLib.Variant.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_variant_get_double(value_);
            var ret = (double)ret_;
            return ret;
        }

        /// <summary>
        /// Returns the 32-bit signed integer value of @value.
        /// </summary>
        /// <remarks>
        /// It is an error to call this function with a @value of any type other
        /// than %G_VARIANT_TYPE_HANDLE.
        /// 
        /// By convention, handles are indexes into an array of file descriptors
        /// that are sent alongside a D-Bus message.  If you're not interacting
        /// with D-Bus, you probably don't need them.
        /// </remarks>
        /// <param name="value">
        /// a handle #GVariant instance
        /// </param>
        /// <returns>
        /// a #gint32
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gint32" type="gint32" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        private static extern int g_variant_get_handle(
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Variant.UnmanagedStruct* value);
        partial void CheckGetHandleArgs();

        [GISharp.Runtime.SinceAttribute("2.24")]
        private int GetHandle()
        {
            CheckGetHandleArgs();
            var value_ = (GISharp.Lib.GLib.Variant.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_variant_get_handle(value_);
            var ret = (int)ret_;
            return ret;
        }

        /// <summary>
        /// Returns the 16-bit signed integer value of @value.
        /// </summary>
        /// <remarks>
        /// It is an error to call this function with a @value of any type
        /// other than %G_VARIANT_TYPE_INT16.
        /// </remarks>
        /// <param name="value">
        /// an int16 #GVariant instance
        /// </param>
        /// <returns>
        /// a #gint16
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gint16" type="gint16" managed-name="System.Int16" /> */
        /* transfer-ownership:none direction:in */
        private static extern short g_variant_get_int16(
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Variant.UnmanagedStruct* value);
        partial void CheckGetInt16Args();

        [GISharp.Runtime.SinceAttribute("2.24")]
        private short GetInt16()
        {
            CheckGetInt16Args();
            var value_ = (GISharp.Lib.GLib.Variant.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_variant_get_int16(value_);
            var ret = (short)ret_;
            return ret;
        }

        /// <summary>
        /// Returns the 32-bit signed integer value of @value.
        /// </summary>
        /// <remarks>
        /// It is an error to call this function with a @value of any type
        /// other than %G_VARIANT_TYPE_INT32.
        /// </remarks>
        /// <param name="value">
        /// an int32 #GVariant instance
        /// </param>
        /// <returns>
        /// a #gint32
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gint32" type="gint32" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        private static extern int g_variant_get_int32(
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Variant.UnmanagedStruct* value);
        partial void CheckGetInt32Args();

        [GISharp.Runtime.SinceAttribute("2.24")]
        private int GetInt32()
        {
            CheckGetInt32Args();
            var value_ = (GISharp.Lib.GLib.Variant.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_variant_get_int32(value_);
            var ret = (int)ret_;
            return ret;
        }

        /// <summary>
        /// Returns the 64-bit signed integer value of @value.
        /// </summary>
        /// <remarks>
        /// It is an error to call this function with a @value of any type
        /// other than %G_VARIANT_TYPE_INT64.
        /// </remarks>
        /// <param name="value">
        /// an int64 #GVariant instance
        /// </param>
        /// <returns>
        /// a #gint64
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gint64" type="gint64" managed-name="System.Int64" /> */
        /* transfer-ownership:none direction:in */
        private static extern long g_variant_get_int64(
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Variant.UnmanagedStruct* value);
        partial void CheckGetInt64Args();

        [GISharp.Runtime.SinceAttribute("2.24")]
        private long GetInt64()
        {
            CheckGetInt64Args();
            var value_ = (GISharp.Lib.GLib.Variant.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_variant_get_int64(value_);
            var ret = (long)ret_;
            return ret;
        }

        /// <summary>
        /// Given a maybe-typed #GVariant instance, extract its value.  If the
        /// value is Nothing, then this function returns %NULL.
        /// </summary>
        /// <param name="value">
        /// a maybe-typed value
        /// </param>
        /// <returns>
        /// the contents of @value, or %NULL
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:full nullable:1 direction:in */
        private static extern GISharp.Lib.GLib.Variant.UnmanagedStruct* g_variant_get_maybe(
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Variant.UnmanagedStruct* value);
        partial void CheckGetMaybeArgs();

        [GISharp.Runtime.SinceAttribute("2.24")]
        private GISharp.Lib.GLib.Variant? GetMaybe()
        {
            CheckGetMaybeArgs();
            var value_ = (GISharp.Lib.GLib.Variant.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_variant_get_maybe(value_);
            var ret = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Variant>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full);
            return ret;
        }

        /// <summary>
        /// Gets a #GVariant instance that has the same value as @value and is
        /// trusted to be in normal form.
        /// </summary>
        /// <remarks>
        /// If @value is already trusted to be in normal form then a new
        /// reference to @value is returned.
        /// 
        /// If @value is not already trusted, then it is scanned to check if it
        /// is in normal form.  If it is found to be in normal form then it is
        /// marked as trusted and a new reference to it is returned.
        /// 
        /// If @value is found not to be in normal form then a new trusted
        /// #GVariant is created with the same value as @value.
        /// 
        /// It makes sense to call this function if you've received #GVariant
        /// data from untrusted sources and you want to ensure your serialised
        /// output is definitely in normal form.
        /// 
        /// If @value is already in normal form, a new reference will be returned
        /// (which will be floating if @value is floating). If it is not in normal form,
        /// the newly created #GVariant will be returned with a single non-floating
        /// reference. Typically, g_variant_take_ref() should be called on the return
        /// value from this function to guarantee ownership of a single non-floating
        /// reference to it.
        /// </remarks>
        /// <param name="value">
        /// a #GVariant
        /// </param>
        /// <returns>
        /// a trusted #GVariant
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GLib.Variant.UnmanagedStruct* g_variant_get_normal_form(
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Variant.UnmanagedStruct* value);
        partial void CheckGetNormalFormArgs();

        [GISharp.Runtime.SinceAttribute("2.24")]
        private GISharp.Lib.GLib.Variant GetNormalForm()
        {
            CheckGetNormalFormArgs();
            var value_ = (GISharp.Lib.GLib.Variant.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_variant_get_normal_form(value_);
            var ret = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Variant>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Gets the contents of an array of object paths #GVariant.  This call
        /// makes a shallow copy; the return result should be released with
        /// g_free(), but the individual strings must not be modified.
        /// </summary>
        /// <remarks>
        /// If @length is non-%NULL then the number of elements in the result
        /// is stored there.  In any case, the resulting array will be
        /// %NULL-terminated.
        /// 
        /// For an empty array, @length will be set to 0 and a pointer to a
        /// %NULL pointer will be returned.
        /// </remarks>
        /// <param name="value">
        /// an array of object paths #GVariant
        /// </param>
        /// <param name="length">
        /// the length of the result, or %NULL
        /// </param>
        /// <returns>
        /// an array of constant strings
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.30")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <array length="0" zero-terminated="1" type="const gchar**" name="GLib.Strv" managed-name="GISharp.Lib.GLib.Strv" is-pointer="1">
*   <type name="utf8" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" />
* </array> */
        /* transfer-ownership:container direction:in */
        private static extern byte** g_variant_get_objv(
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Variant.UnmanagedStruct* value,
        /* <type name="gsize" type="gsize*" managed-name="System.Int32" /> */
        /* direction:out caller-allocates:0 transfer-ownership:full optional:1 allow-none:1 */
        nuint* length);
        partial void CheckGetObjvArgs();

        [GISharp.Runtime.SinceAttribute("2.30")]
        private GISharp.Lib.GLib.Strv GetObjv()
        {
            CheckGetObjvArgs();
            var value_ = (GISharp.Lib.GLib.Variant.UnmanagedStruct*)UnsafeHandle;
            nuint length_;
            var ret_ = g_variant_get_objv(value_,&length_);
            var ret = new GISharp.Lib.GLib.Strv((System.IntPtr)ret_, (int)length_, GISharp.Runtime.Transfer.Container);
            return ret;
        }

        /// <summary>
        /// Determines the number of bytes that would be required to store @value
        /// with g_variant_store().
        /// </summary>
        /// <remarks>
        /// If @value has a fixed-sized type then this function always returned
        /// that fixed size.
        /// 
        /// In the case that @value is already in serialised form or the size has
        /// already been calculated (ie: this function has been called before)
        /// then this function is O(1).  Otherwise, the size is calculated, an
        /// operation which is approximately O(n) in the number of values
        /// involved.
        /// </remarks>
        /// <param name="value">
        /// a #GVariant instance
        /// </param>
        /// <returns>
        /// the serialised size of @value
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gsize" type="gsize" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        private static extern nuint g_variant_get_size(
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Variant.UnmanagedStruct* value);
        partial void CheckGetSizeArgs();

        [GISharp.Runtime.SinceAttribute("2.24")]
        private int GetSize()
        {
            CheckGetSizeArgs();
            var value_ = (GISharp.Lib.GLib.Variant.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_variant_get_size(value_);
            var ret = (int)ret_;
            return ret;
        }

        /// <summary>
        /// Returns the string value of a #GVariant instance with a string
        /// type.  This includes the types %G_VARIANT_TYPE_STRING,
        /// %G_VARIANT_TYPE_OBJECT_PATH and %G_VARIANT_TYPE_SIGNATURE.
        /// </summary>
        /// <remarks>
        /// The string will always be UTF-8 encoded, will never be %NULL, and will never
        /// contain nul bytes.
        /// 
        /// If @length is non-%NULL then the length of the string (in bytes) is
        /// returned there.  For trusted values, this information is already
        /// known.  Untrusted values will be validated and, if valid, a strlen() will be
        /// performed. If invalid, a default value will be returned  for
        /// %G_VARIANT_TYPE_OBJECT_PATH, this is `"/"`, and for other types it is the
        /// empty string.
        /// 
        /// It is an error to call this function with a @value of any type
        /// other than those three.
        /// 
        /// The return value remains valid as long as @value exists.
        /// </remarks>
        /// <param name="value">
        /// a string #GVariant instance
        /// </param>
        /// <param name="length">
        /// a pointer to a #gsize,
        ///          to store the length
        /// </param>
        /// <returns>
        /// the constant string, UTF-8 encoded
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern byte* g_variant_get_string(
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Variant.UnmanagedStruct* value,
        /* <type name="gsize" type="gsize*" managed-name="System.Int32" /> */
        /* direction:out caller-allocates:0 transfer-ownership:full optional:1 allow-none:1 */
        nuint* length);
        partial void CheckGetStringArgs();

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.GetString(int)']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public GISharp.Lib.GLib.UnownedUtf8 GetString(out int length)
        {
            CheckGetStringArgs();
            var value_ = (GISharp.Lib.GLib.Variant.UnmanagedStruct*)UnsafeHandle;
            nuint length_;
            var ret_ = g_variant_get_string(value_,&length_);
            length = (int)length_;
            var ret = new GISharp.Lib.GLib.UnownedUtf8(ret_);
            return ret;
        }

        /// <summary>
        /// Gets the contents of an array of strings #GVariant.  This call
        /// makes a shallow copy; the return result should be released with
        /// g_free(), but the individual strings must not be modified.
        /// </summary>
        /// <remarks>
        /// If @length is non-%NULL then the number of elements in the result
        /// is stored there.  In any case, the resulting array will be
        /// %NULL-terminated.
        /// 
        /// For an empty array, @length will be set to 0 and a pointer to a
        /// %NULL pointer will be returned.
        /// </remarks>
        /// <param name="value">
        /// an array of strings #GVariant
        /// </param>
        /// <param name="length">
        /// the length of the result, or %NULL
        /// </param>
        /// <returns>
        /// an array of constant strings
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <array length="0" zero-terminated="1" type="const gchar**" name="GLib.Strv" managed-name="GISharp.Lib.GLib.Strv" is-pointer="1">
*   <type name="utf8" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" />
* </array> */
        /* transfer-ownership:container direction:in */
        private static extern byte** g_variant_get_strv(
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Variant.UnmanagedStruct* value,
        /* <type name="gsize" type="gsize*" managed-name="System.Int32" /> */
        /* direction:out caller-allocates:0 transfer-ownership:full optional:1 allow-none:1 */
        nuint* length);
        partial void CheckGetStrvArgs();

        [GISharp.Runtime.SinceAttribute("2.24")]
        private GISharp.Lib.GLib.Strv GetStrv()
        {
            CheckGetStrvArgs();
            var value_ = (GISharp.Lib.GLib.Variant.UnmanagedStruct*)UnsafeHandle;
            nuint length_;
            var ret_ = g_variant_get_strv(value_,&length_);
            var ret = new GISharp.Lib.GLib.Strv((System.IntPtr)ret_, (int)length_, GISharp.Runtime.Transfer.Container);
            return ret;
        }

        /// <summary>
        /// Determines the type of @value.
        /// </summary>
        /// <remarks>
        /// The return value is valid for the lifetime of @value and must not
        /// be freed.
        /// </remarks>
        /// <param name="value">
        /// a #GVariant
        /// </param>
        /// <returns>
        /// a #GVariantType
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="VariantType" type="const GVariantType*" managed-name="VariantType" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GLib.VariantType.UnmanagedStruct* g_variant_get_type(
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Variant.UnmanagedStruct* value);
        partial void CheckGetType_Args();

        [GISharp.Runtime.SinceAttribute("2.24")]
        private GISharp.Lib.GLib.VariantType GetType_()
        {
            CheckGetType_Args();
            var value_ = (GISharp.Lib.GLib.Variant.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_variant_get_type(value_);
            var ret = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.VariantType>((System.IntPtr)ret_, GISharp.Runtime.Transfer.None)!;
            return ret;
        }

        /// <summary>
        /// Returns the type string of @value.  Unlike the result of calling
        /// g_variant_type_peek_string(), this string is nul-terminated.  This
        /// string belongs to #GVariant and must not be freed.
        /// </summary>
        /// <param name="value">
        /// a #GVariant
        /// </param>
        /// <returns>
        /// the type string for the type of @value
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern byte* g_variant_get_type_string(
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Variant.UnmanagedStruct* value);
        partial void CheckGetTypeStringArgs();

        [GISharp.Runtime.SinceAttribute("2.24")]
        private GISharp.Lib.GLib.UnownedUtf8 GetTypeString()
        {
            CheckGetTypeStringArgs();
            var value_ = (GISharp.Lib.GLib.Variant.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_variant_get_type_string(value_);
            var ret = new GISharp.Lib.GLib.UnownedUtf8(ret_);
            return ret;
        }

        /// <summary>
        /// Returns the 16-bit unsigned integer value of @value.
        /// </summary>
        /// <remarks>
        /// It is an error to call this function with a @value of any type
        /// other than %G_VARIANT_TYPE_UINT16.
        /// </remarks>
        /// <param name="value">
        /// a uint16 #GVariant instance
        /// </param>
        /// <returns>
        /// a #guint16
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="guint16" type="guint16" managed-name="System.UInt16" /> */
        /* transfer-ownership:none direction:in */
        private static extern ushort g_variant_get_uint16(
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Variant.UnmanagedStruct* value);
        partial void CheckGetUint16Args();

        [GISharp.Runtime.SinceAttribute("2.24")]
        private ushort GetUint16()
        {
            CheckGetUint16Args();
            var value_ = (GISharp.Lib.GLib.Variant.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_variant_get_uint16(value_);
            var ret = (ushort)ret_;
            return ret;
        }

        /// <summary>
        /// Returns the 32-bit unsigned integer value of @value.
        /// </summary>
        /// <remarks>
        /// It is an error to call this function with a @value of any type
        /// other than %G_VARIANT_TYPE_UINT32.
        /// </remarks>
        /// <param name="value">
        /// a uint32 #GVariant instance
        /// </param>
        /// <returns>
        /// a #guint32
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="guint32" type="guint32" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        private static extern uint g_variant_get_uint32(
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Variant.UnmanagedStruct* value);
        partial void CheckGetUint32Args();

        [GISharp.Runtime.SinceAttribute("2.24")]
        private uint GetUint32()
        {
            CheckGetUint32Args();
            var value_ = (GISharp.Lib.GLib.Variant.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_variant_get_uint32(value_);
            var ret = (uint)ret_;
            return ret;
        }

        /// <summary>
        /// Returns the 64-bit unsigned integer value of @value.
        /// </summary>
        /// <remarks>
        /// It is an error to call this function with a @value of any type
        /// other than %G_VARIANT_TYPE_UINT64.
        /// </remarks>
        /// <param name="value">
        /// a uint64 #GVariant instance
        /// </param>
        /// <returns>
        /// a #guint64
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="guint64" type="guint64" managed-name="System.UInt64" /> */
        /* transfer-ownership:none direction:in */
        private static extern ulong g_variant_get_uint64(
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Variant.UnmanagedStruct* value);
        partial void CheckGetUint64Args();

        [GISharp.Runtime.SinceAttribute("2.24")]
        private ulong GetUint64()
        {
            CheckGetUint64Args();
            var value_ = (GISharp.Lib.GLib.Variant.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_variant_get_uint64(value_);
            var ret = (ulong)ret_;
            return ret;
        }

        /// <summary>
        /// Unboxes @value.  The result is the #GVariant instance that was
        /// contained in @value.
        /// </summary>
        /// <param name="value">
        /// a variant #GVariant instance
        /// </param>
        /// <returns>
        /// the item contained in the variant
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GLib.Variant.UnmanagedStruct* g_variant_get_variant(
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Variant.UnmanagedStruct* value);
        partial void CheckGetVariantArgs();

        [GISharp.Runtime.SinceAttribute("2.24")]
        private GISharp.Lib.GLib.Variant GetVariant()
        {
            CheckGetVariantArgs();
            var value_ = (GISharp.Lib.GLib.Variant.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_variant_get_variant(value_);
            var ret = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Variant>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Generates a hash value for a #GVariant instance.
        /// </summary>
        /// <remarks>
        /// The output of this function is guaranteed to be the same for a given
        /// value only per-process.  It may change between different processor
        /// architectures or even different versions of GLib.  Do not use this
        /// function as a basis for building protocols or file formats.
        /// 
        /// The type of @value is #gconstpointer only to allow use of this
        /// function with #GHashTable.  @value must be a #GVariant.
        /// </remarks>
        /// <param name="value">
        /// a basic #GVariant value as a #gconstpointer
        /// </param>
        /// <returns>
        /// a hash value corresponding to @value
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="guint" type="guint" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        private static extern uint g_variant_hash(
        /* <type name="Variant" type="gconstpointer" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Variant.UnmanagedStruct* value);
        partial void CheckGetHashCodeArgs();

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.GetHashCode()']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public override System.Int32 GetHashCode()
        {
            CheckGetHashCodeArgs();
            var value_ = (GISharp.Lib.GLib.Variant.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_variant_hash(value_);
            var ret = (System.Int32)ret_;
            return ret;
        }

        /// <summary>
        /// Checks if @value is a container.
        /// </summary>
        /// <param name="value">
        /// a #GVariant instance
        /// </param>
        /// <returns>
        /// %TRUE if @value is a container
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_variant_is_container(
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Variant.UnmanagedStruct* value);
        partial void CheckGetIsContainerArgs();

        [GISharp.Runtime.SinceAttribute("2.24")]
        private bool GetIsContainer()
        {
            CheckGetIsContainerArgs();
            var value_ = (GISharp.Lib.GLib.Variant.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_variant_is_container(value_);
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Checks whether @value has a floating reference count.
        /// </summary>
        /// <remarks>
        /// This function should only ever be used to assert that a given variant
        /// is or is not floating, or for debug purposes. To acquire a reference
        /// to a variant that might be floating, always use g_variant_ref_sink()
        /// or g_variant_take_ref().
        /// 
        /// See g_variant_ref_sink() for more information about floating reference
        /// counts.
        /// </remarks>
        /// <param name="value">
        /// a #GVariant
        /// </param>
        /// <returns>
        /// whether @value is floating
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.26")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_variant_is_floating(
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Variant.UnmanagedStruct* value);
        partial void CheckGetIsFloatingArgs();

        [GISharp.Runtime.SinceAttribute("2.26")]
        private bool GetIsFloating()
        {
            CheckGetIsFloatingArgs();
            var value_ = (GISharp.Lib.GLib.Variant.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_variant_is_floating(value_);
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Checks if @value is in normal form.
        /// </summary>
        /// <remarks>
        /// The main reason to do this is to detect if a given chunk of
        /// serialised data is in normal form: load the data into a #GVariant
        /// using g_variant_new_from_data() and then use this function to
        /// check.
        /// 
        /// If @value is found to be in normal form then it will be marked as
        /// being trusted.  If the value was already marked as being trusted then
        /// this function will immediately return %TRUE.
        /// 
        /// There may be implementation specific restrictions on deeply nested values.
        /// GVariant is guaranteed to handle nesting up to at least 64 levels.
        /// </remarks>
        /// <param name="value">
        /// a #GVariant instance
        /// </param>
        /// <returns>
        /// %TRUE if @value is in normal form
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_variant_is_normal_form(
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Variant.UnmanagedStruct* value);
        partial void CheckGetIsNormalFormArgs();

        [GISharp.Runtime.SinceAttribute("2.24")]
        private bool GetIsNormalForm()
        {
            CheckGetIsNormalFormArgs();
            var value_ = (GISharp.Lib.GLib.Variant.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_variant_is_normal_form(value_);
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Checks if a value has a type matching the provided type.
        /// </summary>
        /// <param name="value">
        /// a #GVariant instance
        /// </param>
        /// <param name="type">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// %TRUE if the type of @value matches @type
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_variant_is_of_type(
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Variant.UnmanagedStruct* value,
        /* <type name="VariantType" type="const GVariantType*" managed-name="VariantType" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.VariantType.UnmanagedStruct* type);
        partial void CheckIsOfTypeArgs(GISharp.Lib.GLib.VariantType type);

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.IsOfType(GISharp.Lib.GLib.VariantType)']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public bool IsOfType(GISharp.Lib.GLib.VariantType type)
        {
            CheckIsOfTypeArgs(type);
            var value_ = (GISharp.Lib.GLib.Variant.UnmanagedStruct*)UnsafeHandle;
            var type_ = (GISharp.Lib.GLib.VariantType.UnmanagedStruct*)type.UnsafeHandle;
            var ret_ = g_variant_is_of_type(value_,type_);
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Looks up a value in a dictionary #GVariant.
        /// </summary>
        /// <remarks>
        /// This function works with dictionaries of the type a{s*} (and equally
        /// well with type a{o*}, but we only further discuss the string case
        /// for sake of clarity).
        /// 
        /// In the event that @dictionary has the type a{sv}, the @expected_type
        /// string specifies what type of value is expected to be inside of the
        /// variant. If the value inside the variant has a different type then
        /// %NULL is returned. In the event that @dictionary has a value type other
        /// than v then @expected_type must directly match the value type and it is
        /// used to unpack the value directly or an error occurs.
        /// 
        /// In either case, if @key is not found in @dictionary, %NULL is returned.
        /// 
        /// If the key is found and the value has the correct type, it is
        /// returned.  If @expected_type was specified then any non-%NULL return
        /// value will have this type.
        /// 
        /// This function is currently implemented with a linear scan.  If you
        /// plan to do many lookups then #GVariantDict may be more efficient.
        /// </remarks>
        /// <param name="dictionary">
        /// a dictionary #GVariant
        /// </param>
        /// <param name="key">
        /// the key to look up in the dictionary
        /// </param>
        /// <param name="expectedType">
        /// a #GVariantType, or %NULL
        /// </param>
        /// <returns>
        /// the value of the dictionary key, or %NULL
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.28")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GLib.Variant.UnmanagedStruct* g_variant_lookup_value(
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Variant.UnmanagedStruct* dictionary,
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* key,
        /* <type name="VariantType" type="const GVariantType*" managed-name="VariantType" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.GLib.VariantType.UnmanagedStruct* expectedType);
        partial void CheckLookupValueArgs(GISharp.Lib.GLib.UnownedUtf8 key, GISharp.Lib.GLib.VariantType? expectedType);

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.LookupValue(GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.GLib.VariantType?)']/*" />
        [GISharp.Runtime.SinceAttribute("2.28")]
        public GISharp.Lib.GLib.Variant LookupValue(GISharp.Lib.GLib.UnownedUtf8 key, GISharp.Lib.GLib.VariantType? expectedType)
        {
            CheckLookupValueArgs(key, expectedType);
            var dictionary_ = (GISharp.Lib.GLib.Variant.UnmanagedStruct*)UnsafeHandle;
            var key_ = (byte*)key.UnsafeHandle;
            var expectedType_ = (GISharp.Lib.GLib.VariantType.UnmanagedStruct*)(expectedType?.UnsafeHandle ?? System.IntPtr.Zero);
            var ret_ = g_variant_lookup_value(dictionary_,key_,expectedType_);
            var ret = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Variant>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Determines the number of children in a container #GVariant instance.
        /// This includes variants, maybes, arrays, tuples and dictionary
        /// entries.  It is an error to call this function on any other type of
        /// #GVariant.
        /// </summary>
        /// <remarks>
        /// For variants, the return value is always 1.  For values with maybe
        /// types, it is always zero or one.  For arrays, it is the length of the
        /// array.  For tuples it is the number of tuple items (which depends
        /// only on the type).  For dictionary entries, it is always 2
        /// 
        /// This function is O(1).
        /// </remarks>
        /// <param name="value">
        /// a container #GVariant
        /// </param>
        /// <returns>
        /// the number of children in the container
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gsize" type="gsize" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        private static extern nuint g_variant_n_children(
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Variant.UnmanagedStruct* value);
        partial void CheckNChildrenArgs();

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.NChildren()']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public int NChildren()
        {
            CheckNChildrenArgs();
            var value_ = (GISharp.Lib.GLib.Variant.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_variant_n_children(value_);
            var ret = (int)ret_;
            return ret;
        }

        /// <summary>
        /// Pretty-prints @value in the format understood by g_variant_parse().
        /// </summary>
        /// <remarks>
        /// The format is described [here][gvariant-text].
        /// 
        /// If @type_annotate is %TRUE, then type information is included in
        /// the output.
        /// </remarks>
        /// <param name="value">
        /// a #GVariant
        /// </param>
        /// <param name="typeAnnotate">
        /// %TRUE if type information should be included in
        ///                 the output
        /// </param>
        /// <returns>
        /// a newly-allocated string holding the result.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern byte* g_variant_print(
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Variant.UnmanagedStruct* value,
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.Boolean typeAnnotate);
        partial void CheckPrintArgs(bool typeAnnotate);

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.Print(bool)']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public GISharp.Lib.GLib.Utf8 Print(bool typeAnnotate)
        {
            CheckPrintArgs(typeAnnotate);
            var value_ = (GISharp.Lib.GLib.Variant.UnmanagedStruct*)UnsafeHandle;
            var typeAnnotate_ = GISharp.Runtime.BooleanExtensions.ToBoolean(typeAnnotate);
            var ret_ = g_variant_print(value_,typeAnnotate_);
            var ret = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Utf8>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Increases the reference count of @value.
        /// </summary>
        /// <param name="value">
        /// a #GVariant
        /// </param>
        /// <returns>
        /// the same @value
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GLib.Variant.UnmanagedStruct* g_variant_ref(
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Variant.UnmanagedStruct* value);

        /// <summary>
        /// Takes ownership of the unmanaged pointer without freeing it.
        /// The managed object can no longer be used (will throw disposed exception).
        /// </summary>
        public override System.IntPtr Take() => (System.IntPtr)g_variant_ref((GISharp.Lib.GLib.Variant.UnmanagedStruct*)UnsafeHandle);

        /// <summary>
        /// #GVariant uses a floating reference count system.  All functions with
        /// names starting with `g_variant_new_` return floating
        /// references.
        /// </summary>
        /// <remarks>
        /// Calling g_variant_ref_sink() on a #GVariant with a floating reference
        /// will convert the floating reference into a full reference.  Calling
        /// g_variant_ref_sink() on a non-floating #GVariant results in an
        /// additional normal reference being added.
        /// 
        /// In other words, if the @value is floating, then this call "assumes
        /// ownership" of the floating reference, converting it to a normal
        /// reference.  If the @value is not floating, then this call adds a
        /// new normal reference increasing the reference count by one.
        /// 
        /// All calls that result in a #GVariant instance being inserted into a
        /// container will call g_variant_ref_sink() on the instance.  This means
        /// that if the value was just created (and has only its floating
        /// reference) then the container will assume sole ownership of the value
        /// at that point and the caller will not need to unreference it.  This
        /// makes certain common styles of programming much easier while still
        /// maintaining normal refcounting semantics in situations where values
        /// are not floating.
        /// </remarks>
        /// <param name="value">
        /// a #GVariant
        /// </param>
        /// <returns>
        /// the same @value
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GLib.Variant.UnmanagedStruct* g_variant_ref_sink(
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Variant.UnmanagedStruct* value);
        partial void CheckRefSinkArgs();

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.RefSink()']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public GISharp.Lib.GLib.Variant RefSink()
        {
            CheckRefSinkArgs();
            var value_ = (GISharp.Lib.GLib.Variant.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_variant_ref_sink(value_);
            var ret = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Variant>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Stores the serialised form of @value at @data.  @data should be
        /// large enough.  See g_variant_get_size().
        /// </summary>
        /// <remarks>
        /// The stored data is in machine native byte order but may not be in
        /// fully-normalised form if read from an untrusted source.  See
        /// g_variant_get_normal_form() for a solution.
        /// 
        /// As with g_variant_get_data(), to be able to deserialise the
        /// serialised variant successfully, its type and (if the destination
        /// machine might be different) its endianness must also be available.
        /// 
        /// This function is approximately O(n) in the size of @data.
        /// </remarks>
        /// <param name="value">
        /// the #GVariant to store
        /// </param>
        /// <param name="data">
        /// the location to store the serialised data at
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_variant_store(
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Variant.UnmanagedStruct* value,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr data);
        partial void CheckStoreArgs(System.IntPtr data);

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.Store(System.IntPtr)']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public void Store(System.IntPtr data)
        {
            CheckStoreArgs(data);
            var value_ = (GISharp.Lib.GLib.Variant.UnmanagedStruct*)UnsafeHandle;
            var data_ = (System.IntPtr)data;
            g_variant_store(value_, data_);
        }

        /// <summary>
        /// If @value is floating, sink it.  Otherwise, do nothing.
        /// </summary>
        /// <remarks>
        /// Typically you want to use g_variant_ref_sink() in order to
        /// automatically do the correct thing with respect to floating or
        /// non-floating references, but there is one specific scenario where
        /// this function is helpful.
        /// 
        /// The situation where this function is helpful is when creating an API
        /// that allows the user to provide a callback function that returns a
        /// #GVariant.  We certainly want to allow the user the flexibility to
        /// return a non-floating reference from this callback (for the case
        /// where the value that is being returned already exists).
        /// 
        /// At the same time, the style of the #GVariant API makes it likely that
        /// for newly-created #GVariant instances, the user can be saved some
        /// typing if they are allowed to return a #GVariant with a floating
        /// reference.
        /// 
        /// Using this function on the return value of the user's callback allows
        /// the user to do whichever is more convenient for them.  The caller
        /// will always receives exactly one full reference to the value: either
        /// the one that was returned in the first place, or a floating reference
        /// that has been converted to a full reference.
        /// 
        /// This function has an odd interaction when combined with
        /// g_variant_ref_sink() running at the same time in another thread on
        /// the same #GVariant instance.  If g_variant_ref_sink() runs first then
        /// the result will be that the floating reference is converted to a hard
        /// reference.  If g_variant_take_ref() runs first then the result will
        /// be that the floating reference is converted to a hard reference and
        /// an additional reference on top of that one is added.  It is best to
        /// avoid this situation.
        /// </remarks>
        /// <param name="value">
        /// a #GVariant
        /// </param>
        /// <returns>
        /// the same @value
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GLib.Variant.UnmanagedStruct* g_variant_take_ref(
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Variant.UnmanagedStruct* value);
        partial void CheckTakeRefArgs();

        /// <include file="Variant.xmldoc" path="declaration/member[@name='Variant.TakeRef()']/*" />
        public GISharp.Lib.GLib.Variant TakeRef()
        {
            CheckTakeRefArgs();
            var value_ = (GISharp.Lib.GLib.Variant.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_variant_take_ref(value_);
            var ret = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Variant>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Decreases the reference count of @value.  When its reference count
        /// drops to 0, the memory used by the variant is freed.
        /// </summary>
        /// <param name="value">
        /// a #GVariant
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_variant_unref(
        /* <type name="Variant" type="GVariant*" managed-name="Variant" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Variant.UnmanagedStruct* value);

        /// <inheritdoc/>
        protected override void Dispose(bool disposing)
        {
            if (handle != System.IntPtr.Zero)
            {
                g_variant_unref((UnmanagedStruct*)handle);
            }

            base.Dispose(disposing);
        }
    }
}