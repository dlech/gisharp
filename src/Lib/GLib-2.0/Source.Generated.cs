// SPDX-License-Identifier: MIT
// ATTENTION: This file is automatically generated. Do not edit manually.
#nullable enable
namespace GISharp.Lib.GLib
{
    /// <include file="Source.xmldoc" path="declaration/member[@name='Source']/*" />
    [GISharp.Runtime.GTypeAttribute("GSource", IsProxyForUnmanagedType = true)]
    public sealed unsafe partial class Source : GISharp.Runtime.Boxed
    {
        private static readonly GISharp.Lib.GObject.GType _GType = g_source_get_type();

        /// <summary>
        /// The unmanaged data structure.
        /// </summary>
        public struct UnmanagedStruct
        {
#pragma warning disable CS0169, CS0649
            /// <include file="Source.xmldoc" path="declaration/member[@name='UnmanagedStruct.CallbackData']/*" />
            private readonly System.IntPtr CallbackData;

            /// <include file="Source.xmldoc" path="declaration/member[@name='UnmanagedStruct.CallbackFuncs']/*" />
            private readonly GISharp.Lib.GLib.SourceCallbackFuncs* CallbackFuncs;

            /// <include file="Source.xmldoc" path="declaration/member[@name='UnmanagedStruct.SourceFuncs']/*" />
            private readonly GISharp.Lib.GLib.SourceFuncs* SourceFuncs;

            /// <include file="Source.xmldoc" path="declaration/member[@name='UnmanagedStruct.RefCount']/*" />
            private readonly uint RefCount;

            /// <include file="Source.xmldoc" path="declaration/member[@name='UnmanagedStruct.Context']/*" />
            private readonly GISharp.Lib.GLib.MainContext.UnmanagedStruct* Context;

            /// <include file="Source.xmldoc" path="declaration/member[@name='UnmanagedStruct.Priority']/*" />
            private readonly int Priority;

            /// <include file="Source.xmldoc" path="declaration/member[@name='UnmanagedStruct.Flags']/*" />
            private readonly uint Flags;

            /// <include file="Source.xmldoc" path="declaration/member[@name='UnmanagedStruct.SourceId']/*" />
            private readonly uint SourceId;

            /// <include file="Source.xmldoc" path="declaration/member[@name='UnmanagedStruct.PollFds']/*" />
            private readonly GISharp.Lib.GLib.SList.UnmanagedStruct* PollFds;

            /// <include file="Source.xmldoc" path="declaration/member[@name='UnmanagedStruct.Prev']/*" />
            private readonly GISharp.Lib.GLib.Source.UnmanagedStruct* Prev;

            /// <include file="Source.xmldoc" path="declaration/member[@name='UnmanagedStruct.Next']/*" />
            private readonly GISharp.Lib.GLib.Source.UnmanagedStruct* Next;

            /// <include file="Source.xmldoc" path="declaration/member[@name='UnmanagedStruct.Name']/*" />
            private readonly byte* Name;

            /// <include file="Source.xmldoc" path="declaration/member[@name='UnmanagedStruct.Priv']/*" />
            private readonly System.IntPtr Priv;
#pragma warning restore CS0169, CS0649
        }

        /// <include file="Source.xmldoc" path="declaration/member[@name='Source.Continue']/*" />
        [GISharp.Runtime.SinceAttribute("2.32")]
        public const System.Boolean Continue = true;

        /// <include file="Source.xmldoc" path="declaration/member[@name='Source.Remove']/*" />
        [GISharp.Runtime.SinceAttribute("2.32")]
        public const System.Boolean Remove = false;

        /// <include file="Source.xmldoc" path="declaration/member[@name='Source.CanRecurse']/*" />
        public bool CanRecurse { get => GetCanRecurse(); set => SetCanRecurse(value); }

        /// <include file="Source.xmldoc" path="declaration/member[@name='Source.Context']/*" />
        public GISharp.Lib.GLib.MainContext? Context { get => GetContext(); }

        /// <include file="Source.xmldoc" path="declaration/member[@name='Source.Id']/*" />
        public uint Id { get => GetId(); }

        /// <include file="Source.xmldoc" path="declaration/member[@name='Source.Name']/*" />
        [GISharp.Runtime.SinceAttribute("2.26")]
        public GISharp.Lib.GLib.UnownedUtf8 Name { get => GetName(); set => SetName(value); }

        /// <include file="Source.xmldoc" path="declaration/member[@name='Source.Priority']/*" />
        public int Priority { get => GetPriority(); set => SetPriority(value); }

        /// <include file="Source.xmldoc" path="declaration/member[@name='Source.ReadyTime']/*" />
        public long ReadyTime { get => GetReadyTime(); set => SetReadyTime(value); }

        /// <include file="Source.xmldoc" path="declaration/member[@name='Source.Time']/*" />
        [GISharp.Runtime.SinceAttribute("2.28")]
        public long Time { get => GetTime(); }

        /// <include file="Source.xmldoc" path="declaration/member[@name='Source.IsDestroyed']/*" />
        [GISharp.Runtime.SinceAttribute("2.12")]
        public bool IsDestroyed { get => GetIsDestroyed(); }

        /// <include file="Source.xmldoc" path="declaration/member[@name='Source.Current']/*" />
        [GISharp.Runtime.SinceAttribute("2.12")]
        public static GISharp.Lib.GLib.Source Current { get => GetCurrent(); }

        /// <summary>
        /// For internal runtime use only.
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        public Source(System.IntPtr handle, GISharp.Runtime.Transfer ownership) : base(handle)
        {
            if (ownership == GISharp.Runtime.Transfer.None)
            {
                this.handle = (System.IntPtr)g_source_ref((UnmanagedStruct*)handle);
            }
        }

        /// <summary>
        /// Creates a new #GSource structure. The size is specified to
        /// allow creating structures derived from #GSource that contain
        /// additional data. The size passed in must be at least
        /// `sizeof (GSource)`.
        /// </summary>
        /// <remarks>
        /// The source will not initially be associated with any #GMainContext
        /// and must be added to one with g_source_attach() before it will be
        /// executed.
        /// </remarks>
        /// <param name="sourceFuncs">
        /// structure containing functions that implement
        ///                the sources behavior.
        /// </param>
        /// <param name="structSize">
        /// size of the #GSource structure to create.
        /// </param>
        /// <returns>
        /// the newly-created #GSource.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Source" type="GSource*" managed-name="Source" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GLib.Source.UnmanagedStruct* g_source_new(
        /* <type name="SourceFuncs" type="GSourceFuncs*" managed-name="SourceFuncs" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.SourceFuncs* sourceFuncs,
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        uint structSize);
        static partial void CheckNewArgs(GISharp.Lib.GLib.SourceFuncs sourceFuncs, uint structSize);

        static GISharp.Lib.GLib.Source.UnmanagedStruct* New(GISharp.Lib.GLib.SourceFuncs sourceFuncs, uint structSize)
        {
            CheckNewArgs(sourceFuncs, structSize);
            var sourceFuncs_ = &sourceFuncs;
            var structSize_ = (uint)structSize;
            var ret_ = g_source_new(sourceFuncs_,structSize_);
            return ret_;
        }

        /// <include file="Source.xmldoc" path="declaration/member[@name='Source.Source(GISharp.Lib.GLib.SourceFuncs,uint)']/*" />
        public Source(GISharp.Lib.GLib.SourceFuncs sourceFuncs, uint structSize) : this((System.IntPtr)New(sourceFuncs, structSize), GISharp.Runtime.Transfer.Full)
        {
        }

        /// <summary>
        /// Removes the source with the given ID from the default main context. You must
        /// use g_source_destroy() for sources added to a non-default main context.
        /// </summary>
        /// <remarks>
        /// The ID of a #GSource is given by g_source_get_id(), or will be
        /// returned by the functions g_source_attach(), g_idle_add(),
        /// g_idle_add_full(), g_timeout_add(), g_timeout_add_full(),
        /// g_child_watch_add(), g_child_watch_add_full(), g_io_add_watch(), and
        /// g_io_add_watch_full().
        /// 
        /// It is a programmer error to attempt to remove a non-existent source.
        /// 
        /// More specifically: source IDs can be reissued after a source has been
        /// destroyed and therefore it is never valid to use this function with a
        /// source ID which may have already been removed.  An example is when
        /// scheduling an idle to run in another thread with g_idle_add(): the
        /// idle may already have run and been removed by the time this function
        /// is called on its (now invalid) source ID.  This source ID may have
        /// been reissued, leading to the operation being performed against the
        /// wrong source.
        /// </remarks>
        /// <param name="tag">
        /// the ID of the source to remove.
        /// </param>
        /// <returns>
        /// For historical reasons, this function always returns %TRUE
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_source_remove(
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        uint tag);
        static partial void CheckRemoveByIdArgs(uint tag);

        /// <include file="Source.xmldoc" path="declaration/member[@name='Source.RemoveById(uint)']/*" />
        public static bool RemoveById(uint tag)
        {
            CheckRemoveByIdArgs(tag);
            var tag_ = (uint)tag;
            var ret_ = g_source_remove(tag_);
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Removes a source from the default main loop context given the
        /// source functions and user data. If multiple sources exist with the
        /// same source functions and user data, only one will be destroyed.
        /// </summary>
        /// <param name="funcs">
        /// The @source_funcs passed to g_source_new()
        /// </param>
        /// <param name="userData">
        /// the user data for the callback
        /// </param>
        /// <returns>
        /// %TRUE if a source was found and removed.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_source_remove_by_funcs_user_data(
        /* <type name="SourceFuncs" type="GSourceFuncs*" managed-name="SourceFuncs" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.SourceFuncs* funcs,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr userData);
        static partial void CheckRemoveByFuncsUserDataArgs(GISharp.Lib.GLib.SourceFuncs funcs, System.IntPtr userData);

        /// <include file="Source.xmldoc" path="declaration/member[@name='Source.RemoveByFuncsUserData(GISharp.Lib.GLib.SourceFuncs,System.IntPtr)']/*" />
        public static bool RemoveByFuncsUserData(GISharp.Lib.GLib.SourceFuncs funcs, System.IntPtr userData)
        {
            CheckRemoveByFuncsUserDataArgs(funcs, userData);
            var funcs_ = &funcs;
            var userData_ = (System.IntPtr)userData;
            var ret_ = g_source_remove_by_funcs_user_data(funcs_,userData_);
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Removes a source from the default main loop context given the user
        /// data for the callback. If multiple sources exist with the same user
        /// data, only one will be destroyed.
        /// </summary>
        /// <param name="userData">
        /// the user_data for the callback.
        /// </param>
        /// <returns>
        /// %TRUE if a source was found and removed.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_source_remove_by_user_data(
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr userData);
        static partial void CheckRemoveByUserDataArgs(System.IntPtr userData);

        /// <include file="Source.xmldoc" path="declaration/member[@name='Source.RemoveByUserData(System.IntPtr)']/*" />
        public static bool RemoveByUserData(System.IntPtr userData)
        {
            CheckRemoveByUserDataArgs(userData);
            var userData_ = (System.IntPtr)userData;
            var ret_ = g_source_remove_by_user_data(userData_);
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Sets the name of a source using its ID.
        /// </summary>
        /// <remarks>
        /// This is a convenience utility to set source names from the return
        /// value of g_idle_add(), g_timeout_add(), etc.
        /// 
        /// It is a programmer error to attempt to set the name of a non-existent
        /// source.
        /// 
        /// More specifically: source IDs can be reissued after a source has been
        /// destroyed and therefore it is never valid to use this function with a
        /// source ID which may have already been removed.  An example is when
        /// scheduling an idle to run in another thread with g_idle_add(): the
        /// idle may already have run and been removed by the time this function
        /// is called on its (now invalid) source ID.  This source ID may have
        /// been reissued, leading to the operation being performed against the
        /// wrong source.
        /// </remarks>
        /// <param name="tag">
        /// a #GSource ID
        /// </param>
        /// <param name="name">
        /// debug name for the source
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.26")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_source_set_name_by_id(
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        uint tag,
        /* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* name);
        static partial void CheckSetNameByIdArgs(uint tag, GISharp.Lib.GLib.UnownedUtf8 name);

        /// <include file="Source.xmldoc" path="declaration/member[@name='Source.SetNameById(uint,GISharp.Lib.GLib.UnownedUtf8)']/*" />
        [GISharp.Runtime.SinceAttribute("2.26")]
        public static void SetNameById(uint tag, GISharp.Lib.GLib.UnownedUtf8 name)
        {
            CheckSetNameByIdArgs(tag, name);
            var tag_ = (uint)tag;
            var name_ = (byte*)name.UnsafeHandle;
            g_source_set_name_by_id(tag_, name_);
        }

        /// <summary>
        /// Returns the currently firing source for this thread.
        /// </summary>
        /// <returns>
        /// The currently firing source or %NULL.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.12")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Source" type="GSource*" managed-name="Source" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GLib.Source.UnmanagedStruct* g_main_current_source();
        static partial void CheckGetCurrentArgs();

        [GISharp.Runtime.SinceAttribute("2.12")]
        private static GISharp.Lib.GLib.Source GetCurrent()
        {
            CheckGetCurrentArgs();
            var ret_ = g_main_current_source();
            var ret = GISharp.Lib.GLib.Source.GetInstance<GISharp.Lib.GLib.Source>((System.IntPtr)ret_, GISharp.Runtime.Transfer.None)!;
            return ret;
        }

        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="GType" type="GType" managed-name="GISharp.Lib.GObject.GType" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GObject.GType g_source_get_type();

        /// <summary>
        /// Adds @child_source to @source as a "polled" source; when @source is
        /// added to a #GMainContext, @child_source will be automatically added
        /// with the same priority, when @child_source is triggered, it will
        /// cause @source to dispatch (in addition to calling its own
        /// callback), and when @source is destroyed, it will destroy
        /// @child_source as well. (@source will also still be dispatched if
        /// its own prepare/check functions indicate that it is ready.)
        /// </summary>
        /// <remarks>
        /// If you don't need @child_source to do anything on its own when it
        /// triggers, you can call g_source_set_dummy_callback() on it to set a
        /// callback that does nothing (except return %TRUE if appropriate).
        /// 
        /// @source will hold a reference on @child_source while @child_source
        /// is attached to it.
        /// 
        /// This API is only intended to be used by implementations of #GSource.
        /// Do not call this API on a #GSource that you did not create.
        /// </remarks>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <param name="childSource">
        /// a second #GSource that @source should "poll"
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.28")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_source_add_child_source(
        /* <type name="Source" type="GSource*" managed-name="Source" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Source.UnmanagedStruct* source,
        /* <type name="Source" type="GSource*" managed-name="Source" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Source.UnmanagedStruct* childSource);
        partial void CheckAddChildSourceArgs(GISharp.Lib.GLib.Source childSource);

        /// <include file="Source.xmldoc" path="declaration/member[@name='Source.AddChildSource(GISharp.Lib.GLib.Source)']/*" />
        [GISharp.Runtime.SinceAttribute("2.28")]
        public void AddChildSource(GISharp.Lib.GLib.Source childSource)
        {
            CheckAddChildSourceArgs(childSource);
            var source_ = (GISharp.Lib.GLib.Source.UnmanagedStruct*)UnsafeHandle;
            var childSource_ = (GISharp.Lib.GLib.Source.UnmanagedStruct*)childSource.UnsafeHandle;
            g_source_add_child_source(source_, childSource_);
        }

        /// <summary>
        /// Adds a file descriptor to the set of file descriptors polled for
        /// this source. This is usually combined with g_source_new() to add an
        /// event source. The event source's check function will typically test
        /// the @revents field in the #GPollFD struct and return %TRUE if events need
        /// to be processed.
        /// </summary>
        /// <remarks>
        /// This API is only intended to be used by implementations of #GSource.
        /// Do not call this API on a #GSource that you did not create.
        /// 
        /// Using this API forces the linear scanning of event sources on each
        /// main loop iteration.  Newly-written event sources should try to use
        /// g_source_add_unix_fd() instead of this API.
        /// </remarks>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <param name="fd">
        /// a #GPollFD structure holding information about a file
        ///      descriptor to watch.
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_source_add_poll(
        /* <type name="Source" type="GSource*" managed-name="Source" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Source.UnmanagedStruct* source,
        /* <type name="PollFD" type="GPollFD*" managed-name="PollFD" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.PollFD* fd);
        partial void CheckAddPollArgs(GISharp.Lib.GLib.PollFD fd);

        /// <include file="Source.xmldoc" path="declaration/member[@name='Source.AddPoll(GISharp.Lib.GLib.PollFD)']/*" />
        public void AddPoll(GISharp.Lib.GLib.PollFD fd)
        {
            CheckAddPollArgs(fd);
            var source_ = (GISharp.Lib.GLib.Source.UnmanagedStruct*)UnsafeHandle;
            var fd_ = &fd;
            g_source_add_poll(source_, fd_);
        }

        /// <summary>
        /// Monitors @fd for the IO events in @events.
        /// </summary>
        /// <remarks>
        /// The tag returned by this function can be used to remove or modify the
        /// monitoring of the fd using g_source_remove_unix_fd() or
        /// g_source_modify_unix_fd().
        /// 
        /// It is not necessary to remove the fd before destroying the source; it
        /// will be cleaned up automatically.
        /// 
        /// This API is only intended to be used by implementations of #GSource.
        /// Do not call this API on a #GSource that you did not create.
        /// 
        /// As the name suggests, this function is not available on Windows.
        /// </remarks>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <param name="fd">
        /// the fd to monitor
        /// </param>
        /// <param name="events">
        /// an event mask
        /// </param>
        /// <returns>
        /// an opaque tag
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern System.IntPtr g_source_add_unix_fd(
        /* <type name="Source" type="GSource*" managed-name="Source" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Source.UnmanagedStruct* source,
        /* <type name="gint" type="gint" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        int fd,
        /* <type name="IOCondition" type="GIOCondition" managed-name="IOCondition" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.IOCondition events);
        partial void CheckAddUnixFdArgs(int fd, GISharp.Lib.GLib.IOCondition events);

        /// <include file="Source.xmldoc" path="declaration/member[@name='Source.AddUnixFd(int,GISharp.Lib.GLib.IOCondition)']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        public System.IntPtr AddUnixFd(int fd, GISharp.Lib.GLib.IOCondition events)
        {
            CheckAddUnixFdArgs(fd, events);
            var source_ = (GISharp.Lib.GLib.Source.UnmanagedStruct*)UnsafeHandle;
            var fd_ = (int)fd;
            var events_ = (GISharp.Lib.GLib.IOCondition)events;
            var ret_ = g_source_add_unix_fd(source_,fd_,events_);
            var ret = (System.IntPtr)ret_;
            return ret;
        }

        /// <summary>
        /// Adds a #GSource to a @context so that it will be executed within
        /// that context. Remove it by calling g_source_destroy().
        /// </summary>
        /// <remarks>
        /// This function is safe to call from any thread, regardless of which thread
        /// the @context is running in.
        /// </remarks>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <param name="context">
        /// a #GMainContext (if %NULL, the default context will be used)
        /// </param>
        /// <returns>
        /// the ID (greater than 0) for the source within the
        ///   #GMainContext.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        private static extern uint g_source_attach(
        /* <type name="Source" type="GSource*" managed-name="Source" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Source.UnmanagedStruct* source,
        /* <type name="MainContext" type="GMainContext*" managed-name="MainContext" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.GLib.MainContext.UnmanagedStruct* context);
        partial void CheckAttachArgs(GISharp.Lib.GLib.MainContext? context);

        /// <include file="Source.xmldoc" path="declaration/member[@name='Source.Attach(GISharp.Lib.GLib.MainContext?)']/*" />
        public uint Attach(GISharp.Lib.GLib.MainContext? context)
        {
            CheckAttachArgs(context);
            var source_ = (GISharp.Lib.GLib.Source.UnmanagedStruct*)UnsafeHandle;
            var context_ = (GISharp.Lib.GLib.MainContext.UnmanagedStruct*)(context?.UnsafeHandle ?? System.IntPtr.Zero);
            var ret_ = g_source_attach(source_,context_);
            var ret = (uint)ret_;
            return ret;
        }

        /// <summary>
        /// Removes a source from its #GMainContext, if any, and mark it as
        /// destroyed.  The source cannot be subsequently added to another
        /// context. It is safe to call this on sources which have already been
        /// removed from their context.
        /// </summary>
        /// <remarks>
        /// This does not unref the #GSource: if you still hold a reference, use
        /// g_source_unref() to drop it.
        /// 
        /// This function is safe to call from any thread, regardless of which thread
        /// the #GMainContext is running in.
        /// </remarks>
        /// <param name="source">
        /// a #GSource
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_source_destroy(
        /* <type name="Source" type="GSource*" managed-name="Source" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Source.UnmanagedStruct* source);
        partial void CheckDestroyArgs();

        /// <include file="Source.xmldoc" path="declaration/member[@name='Source.Destroy()']/*" />
        public void Destroy()
        {
            CheckDestroyArgs();
            var source_ = (GISharp.Lib.GLib.Source.UnmanagedStruct*)UnsafeHandle;
            g_source_destroy(source_);
        }

        /// <summary>
        /// Checks whether a source is allowed to be called recursively.
        /// see g_source_set_can_recurse().
        /// </summary>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <returns>
        /// whether recursion is allowed.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_source_get_can_recurse(
        /* <type name="Source" type="GSource*" managed-name="Source" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Source.UnmanagedStruct* source);
        partial void CheckGetCanRecurseArgs();

        private bool GetCanRecurse()
        {
            CheckGetCanRecurseArgs();
            var source_ = (GISharp.Lib.GLib.Source.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_source_get_can_recurse(source_);
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Gets the #GMainContext with which the source is associated.
        /// </summary>
        /// <remarks>
        /// You can call this on a source that has been destroyed, provided
        /// that the #GMainContext it was attached to still exists (in which
        /// case it will return that #GMainContext). In particular, you can
        /// always call this function on the source returned from
        /// g_main_current_source(). But calling this function on a source
        /// whose #GMainContext has been destroyed is an error.
        /// </remarks>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <returns>
        /// the #GMainContext with which the
        ///               source is associated, or %NULL if the context has not
        ///               yet been added to a source.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="MainContext" type="GMainContext*" managed-name="MainContext" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 direction:in */
        private static extern GISharp.Lib.GLib.MainContext.UnmanagedStruct* g_source_get_context(
        /* <type name="Source" type="GSource*" managed-name="Source" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Source.UnmanagedStruct* source);
        partial void CheckGetContextArgs();

        private GISharp.Lib.GLib.MainContext? GetContext()
        {
            CheckGetContextArgs();
            var source_ = (GISharp.Lib.GLib.Source.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_source_get_context(source_);
            var ret = GISharp.Lib.GLib.MainContext.GetInstance<GISharp.Lib.GLib.MainContext>((System.IntPtr)ret_, GISharp.Runtime.Transfer.None);
            return ret;
        }

        /// <summary>
        /// This function ignores @source and is otherwise the same as
        /// g_get_current_time().
        /// </summary>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <param name="timeval">
        /// #GTimeVal structure in which to store current time.
        /// </param>
        [System.ObsoleteAttribute("use g_source_get_time() instead")]
        [GISharp.Runtime.DeprecatedSinceAttribute("2.28")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_source_get_current_time(
        /* <type name="Source" type="GSource*" managed-name="Source" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Source.UnmanagedStruct* source,
        /* <type name="TimeVal" type="GTimeVal*" managed-name="TimeVal" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.TimeVal* timeval);
        partial void CheckGetCurrentTimeArgs(GISharp.Lib.GLib.TimeVal timeval);

        /// <include file="Source.xmldoc" path="declaration/member[@name='Source.GetCurrentTime(GISharp.Lib.GLib.TimeVal)']/*" />
        [System.ObsoleteAttribute("use g_source_get_time() instead")]
        [GISharp.Runtime.DeprecatedSinceAttribute("2.28")]
        public void GetCurrentTime(GISharp.Lib.GLib.TimeVal timeval)
        {
            CheckGetCurrentTimeArgs(timeval);
            var source_ = (GISharp.Lib.GLib.Source.UnmanagedStruct*)UnsafeHandle;
            var timeval_ = &timeval;
            g_source_get_current_time(source_, timeval_);
        }

        /// <summary>
        /// Returns the numeric ID for a particular source. The ID of a source
        /// is a positive integer which is unique within a particular main loop
        /// context. The reverse
        /// mapping from ID to source is done by g_main_context_find_source_by_id().
        /// </summary>
        /// <remarks>
        /// You can only call this function while the source is associated to a
        /// #GMainContext instance; calling this function before g_source_attach()
        /// or after g_source_destroy() yields undefined behavior. The ID returned
        /// is unique within the #GMainContext instance passed to g_source_attach().
        /// </remarks>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <returns>
        /// the ID (greater than 0) for the source
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        private static extern uint g_source_get_id(
        /* <type name="Source" type="GSource*" managed-name="Source" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Source.UnmanagedStruct* source);
        partial void CheckGetIdArgs();

        private uint GetId()
        {
            CheckGetIdArgs();
            var source_ = (GISharp.Lib.GLib.Source.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_source_get_id(source_);
            var ret = (uint)ret_;
            return ret;
        }

        /// <summary>
        /// Gets a name for the source, used in debugging and profiling.  The
        /// name may be #NULL if it has never been set with g_source_set_name().
        /// </summary>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <returns>
        /// the name of the source
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.26")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern byte* g_source_get_name(
        /* <type name="Source" type="GSource*" managed-name="Source" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Source.UnmanagedStruct* source);
        partial void CheckGetNameArgs();

        [GISharp.Runtime.SinceAttribute("2.26")]
        private GISharp.Lib.GLib.UnownedUtf8 GetName()
        {
            CheckGetNameArgs();
            var source_ = (GISharp.Lib.GLib.Source.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_source_get_name(source_);
            var ret = new GISharp.Lib.GLib.UnownedUtf8(ret_);
            return ret;
        }

        /// <summary>
        /// Gets the priority of a source.
        /// </summary>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <returns>
        /// the priority of the source
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gint" type="gint" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        private static extern int g_source_get_priority(
        /* <type name="Source" type="GSource*" managed-name="Source" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Source.UnmanagedStruct* source);
        partial void CheckGetPriorityArgs();

        private int GetPriority()
        {
            CheckGetPriorityArgs();
            var source_ = (GISharp.Lib.GLib.Source.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_source_get_priority(source_);
            var ret = (int)ret_;
            return ret;
        }

        /// <summary>
        /// Gets the "ready time" of @source, as set by
        /// g_source_set_ready_time().
        /// </summary>
        /// <remarks>
        /// Any time before the current monotonic time (including 0) is an
        /// indication that the source will fire immediately.
        /// </remarks>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <returns>
        /// the monotonic ready time, -1 for "never"
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gint64" type="gint64" managed-name="System.Int64" /> */
        /* transfer-ownership:none direction:in */
        private static extern long g_source_get_ready_time(
        /* <type name="Source" type="GSource*" managed-name="Source" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Source.UnmanagedStruct* source);
        partial void CheckGetReadyTimeArgs();

        private long GetReadyTime()
        {
            CheckGetReadyTimeArgs();
            var source_ = (GISharp.Lib.GLib.Source.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_source_get_ready_time(source_);
            var ret = (long)ret_;
            return ret;
        }

        /// <summary>
        /// Gets the time to be used when checking this source. The advantage of
        /// calling this function over calling g_get_monotonic_time() directly is
        /// that when checking multiple sources, GLib can cache a single value
        /// instead of having to repeatedly get the system monotonic time.
        /// </summary>
        /// <remarks>
        /// The time here is the system monotonic time, if available, or some
        /// other reasonable alternative otherwise.  See g_get_monotonic_time().
        /// </remarks>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <returns>
        /// the monotonic time in microseconds
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.28")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gint64" type="gint64" managed-name="System.Int64" /> */
        /* transfer-ownership:none direction:in */
        private static extern long g_source_get_time(
        /* <type name="Source" type="GSource*" managed-name="Source" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Source.UnmanagedStruct* source);
        partial void CheckGetTimeArgs();

        [GISharp.Runtime.SinceAttribute("2.28")]
        private long GetTime()
        {
            CheckGetTimeArgs();
            var source_ = (GISharp.Lib.GLib.Source.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_source_get_time(source_);
            var ret = (long)ret_;
            return ret;
        }

        /// <summary>
        /// Returns whether @source has been destroyed.
        /// </summary>
        /// <remarks>
        /// This is important when you operate upon your objects
        /// from within idle handlers, but may have freed the object
        /// before the dispatch of your idle handler.
        /// 
        /// |[&lt;!-- language="C" --&gt;
        /// static gboolean
        /// idle_callback (gpointer data)
        /// {
        ///   SomeWidget *self = data;
        ///    
        ///   GDK_THREADS_ENTER ();
        ///   // do stuff with self
        ///   self-&gt;idle_id = 0;
        ///   GDK_THREADS_LEAVE ();
        ///    
        ///   return G_SOURCE_REMOVE;
        /// }
        ///  
        /// static void
        /// some_widget_do_stuff_later (SomeWidget *self)
        /// {
        ///   self-&gt;idle_id = g_idle_add (idle_callback, self);
        /// }
        ///  
        /// static void
        /// some_widget_finalize (GObject *object)
        /// {
        ///   SomeWidget *self = SOME_WIDGET (object);
        ///    
        ///   if (self-&gt;idle_id)
        ///     g_source_remove (self-&gt;idle_id);
        ///    
        ///   G_OBJECT_CLASS (parent_class)-&gt;finalize (object);
        /// }
        /// ]|
        /// 
        /// This will fail in a multi-threaded application if the
        /// widget is destroyed before the idle handler fires due
        /// to the use after free in the callback. A solution, to
        /// this particular problem, is to check to if the source
        /// has already been destroy within the callback.
        /// 
        /// |[&lt;!-- language="C" --&gt;
        /// static gboolean
        /// idle_callback (gpointer data)
        /// {
        ///   SomeWidget *self = data;
        ///   
        ///   GDK_THREADS_ENTER ();
        ///   if (!g_source_is_destroyed (g_main_current_source ()))
        ///     {
        ///       // do stuff with self
        ///     }
        ///   GDK_THREADS_LEAVE ();
        ///   
        ///   return FALSE;
        /// }
        /// ]|
        /// 
        /// Calls to this function from a thread other than the one acquired by the
        /// #GMainContext the #GSource is attached to are typically redundant, as the
        /// source could be destroyed immediately after this function returns. However,
        /// once a source is destroyed it cannot be un-destroyed, so this function can be
        /// used for opportunistic checks from any thread.
        /// </remarks>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <returns>
        /// %TRUE if the source has been destroyed
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.12")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_source_is_destroyed(
        /* <type name="Source" type="GSource*" managed-name="Source" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Source.UnmanagedStruct* source);
        partial void CheckGetIsDestroyedArgs();

        [GISharp.Runtime.SinceAttribute("2.12")]
        private bool GetIsDestroyed()
        {
            CheckGetIsDestroyedArgs();
            var source_ = (GISharp.Lib.GLib.Source.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_source_is_destroyed(source_);
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Updates the event mask to watch for the fd identified by @tag.
        /// </summary>
        /// <remarks>
        /// @tag is the tag returned from g_source_add_unix_fd().
        /// 
        /// If you want to remove a fd, don't set its event mask to zero.
        /// Instead, call g_source_remove_unix_fd().
        /// 
        /// This API is only intended to be used by implementations of #GSource.
        /// Do not call this API on a #GSource that you did not create.
        /// 
        /// As the name suggests, this function is not available on Windows.
        /// </remarks>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <param name="tag">
        /// the tag from g_source_add_unix_fd()
        /// </param>
        /// <param name="newEvents">
        /// the new event mask to watch
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_source_modify_unix_fd(
        /* <type name="Source" type="GSource*" managed-name="Source" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Source.UnmanagedStruct* source,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr tag,
        /* <type name="IOCondition" type="GIOCondition" managed-name="IOCondition" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.IOCondition newEvents);
        partial void CheckModifyUnixFdArgs(System.IntPtr tag, GISharp.Lib.GLib.IOCondition newEvents);

        /// <include file="Source.xmldoc" path="declaration/member[@name='Source.ModifyUnixFd(System.IntPtr,GISharp.Lib.GLib.IOCondition)']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        public void ModifyUnixFd(System.IntPtr tag, GISharp.Lib.GLib.IOCondition newEvents)
        {
            CheckModifyUnixFdArgs(tag, newEvents);
            var source_ = (GISharp.Lib.GLib.Source.UnmanagedStruct*)UnsafeHandle;
            var tag_ = (System.IntPtr)tag;
            var newEvents_ = (GISharp.Lib.GLib.IOCondition)newEvents;
            g_source_modify_unix_fd(source_, tag_, newEvents_);
        }

        /// <summary>
        /// Queries the events reported for the fd corresponding to @tag on
        /// @source during the last poll.
        /// </summary>
        /// <remarks>
        /// The return value of this function is only defined when the function
        /// is called from the check or dispatch functions for @source.
        /// 
        /// This API is only intended to be used by implementations of #GSource.
        /// Do not call this API on a #GSource that you did not create.
        /// 
        /// As the name suggests, this function is not available on Windows.
        /// </remarks>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <param name="tag">
        /// the tag from g_source_add_unix_fd()
        /// </param>
        /// <returns>
        /// the conditions reported on the fd
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="IOCondition" type="GIOCondition" managed-name="IOCondition" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GLib.IOCondition g_source_query_unix_fd(
        /* <type name="Source" type="GSource*" managed-name="Source" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Source.UnmanagedStruct* source,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr tag);
        partial void CheckQueryUnixFdArgs(System.IntPtr tag);

        /// <include file="Source.xmldoc" path="declaration/member[@name='Source.QueryUnixFd(System.IntPtr)']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        public GISharp.Lib.GLib.IOCondition QueryUnixFd(System.IntPtr tag)
        {
            CheckQueryUnixFdArgs(tag);
            var source_ = (GISharp.Lib.GLib.Source.UnmanagedStruct*)UnsafeHandle;
            var tag_ = (System.IntPtr)tag;
            var ret_ = g_source_query_unix_fd(source_,tag_);
            var ret = (GISharp.Lib.GLib.IOCondition)ret_;
            return ret;
        }

        /// <summary>
        /// Increases the reference count on a source by one.
        /// </summary>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <returns>
        /// @source
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Source" type="GSource*" managed-name="Source" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GLib.Source.UnmanagedStruct* g_source_ref(
        /* <type name="Source" type="GSource*" managed-name="Source" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Source.UnmanagedStruct* source);

        /// <summary>
        /// Takes ownership of the unmanaged pointer without freeing it.
        /// The managed object can no longer be used (will throw disposed exception).
        /// </summary>
        public override System.IntPtr Take() => (System.IntPtr)g_source_ref((GISharp.Lib.GLib.Source.UnmanagedStruct*)UnsafeHandle);

        /// <summary>
        /// Detaches @child_source from @source and destroys it.
        /// </summary>
        /// <remarks>
        /// This API is only intended to be used by implementations of #GSource.
        /// Do not call this API on a #GSource that you did not create.
        /// </remarks>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <param name="childSource">
        /// a #GSource previously passed to
        ///     g_source_add_child_source().
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.28")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_source_remove_child_source(
        /* <type name="Source" type="GSource*" managed-name="Source" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Source.UnmanagedStruct* source,
        /* <type name="Source" type="GSource*" managed-name="Source" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Source.UnmanagedStruct* childSource);
        partial void CheckRemoveChildSourceArgs(GISharp.Lib.GLib.Source childSource);

        /// <include file="Source.xmldoc" path="declaration/member[@name='Source.RemoveChildSource(GISharp.Lib.GLib.Source)']/*" />
        [GISharp.Runtime.SinceAttribute("2.28")]
        public void RemoveChildSource(GISharp.Lib.GLib.Source childSource)
        {
            CheckRemoveChildSourceArgs(childSource);
            var source_ = (GISharp.Lib.GLib.Source.UnmanagedStruct*)UnsafeHandle;
            var childSource_ = (GISharp.Lib.GLib.Source.UnmanagedStruct*)childSource.UnsafeHandle;
            g_source_remove_child_source(source_, childSource_);
        }

        /// <summary>
        /// Removes a file descriptor from the set of file descriptors polled for
        /// this source.
        /// </summary>
        /// <remarks>
        /// This API is only intended to be used by implementations of #GSource.
        /// Do not call this API on a #GSource that you did not create.
        /// </remarks>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <param name="fd">
        /// a #GPollFD structure previously passed to g_source_add_poll().
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_source_remove_poll(
        /* <type name="Source" type="GSource*" managed-name="Source" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Source.UnmanagedStruct* source,
        /* <type name="PollFD" type="GPollFD*" managed-name="PollFD" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.PollFD* fd);
        partial void CheckRemovePollArgs(GISharp.Lib.GLib.PollFD fd);

        /// <include file="Source.xmldoc" path="declaration/member[@name='Source.RemovePoll(GISharp.Lib.GLib.PollFD)']/*" />
        public void RemovePoll(GISharp.Lib.GLib.PollFD fd)
        {
            CheckRemovePollArgs(fd);
            var source_ = (GISharp.Lib.GLib.Source.UnmanagedStruct*)UnsafeHandle;
            var fd_ = &fd;
            g_source_remove_poll(source_, fd_);
        }

        /// <summary>
        /// Reverses the effect of a previous call to g_source_add_unix_fd().
        /// </summary>
        /// <remarks>
        /// You only need to call this if you want to remove an fd from being
        /// watched while keeping the same source around.  In the normal case you
        /// will just want to destroy the source.
        /// 
        /// This API is only intended to be used by implementations of #GSource.
        /// Do not call this API on a #GSource that you did not create.
        /// 
        /// As the name suggests, this function is not available on Windows.
        /// </remarks>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <param name="tag">
        /// the tag from g_source_add_unix_fd()
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_source_remove_unix_fd(
        /* <type name="Source" type="GSource*" managed-name="Source" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Source.UnmanagedStruct* source,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr tag);
        partial void CheckRemoveUnixFdArgs(System.IntPtr tag);

        /// <include file="Source.xmldoc" path="declaration/member[@name='Source.RemoveUnixFd(System.IntPtr)']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        public void RemoveUnixFd(System.IntPtr tag)
        {
            CheckRemoveUnixFdArgs(tag);
            var source_ = (GISharp.Lib.GLib.Source.UnmanagedStruct*)UnsafeHandle;
            var tag_ = (System.IntPtr)tag;
            g_source_remove_unix_fd(source_, tag_);
        }

        /// <summary>
        /// Sets the callback function for a source. The callback for a source is
        /// called from the source's dispatch function.
        /// </summary>
        /// <remarks>
        /// The exact type of @func depends on the type of source; ie. you
        /// should not count on @func being called with @data as its first
        /// parameter. Cast @func with G_SOURCE_FUNC() to avoid warnings about
        /// incompatible function types.
        /// 
        /// See [memory management of sources][mainloop-memory-management] for details
        /// on how to handle memory management of @data.
        /// 
        /// Typically, you won't use this function. Instead use functions specific
        /// to the type of source you are using, such as g_idle_add() or g_timeout_add().
        /// 
        /// It is safe to call this function multiple times on a source which has already
        /// been attached to a context. The changes will take effect for the next time
        /// the source is dispatched after this call returns.
        /// </remarks>
        /// <param name="source">
        /// the source
        /// </param>
        /// <param name="func">
        /// a callback function
        /// </param>
        /// <param name="data">
        /// the data to pass to callback function
        /// </param>
        /// <param name="notify">
        /// a function to call when @data is no longer in use, or %NULL.
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_source_set_callback(
        /* <type name="Source" type="GSource*" managed-name="Source" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Source.UnmanagedStruct* source,
        /* <type name="SourceFunc" type="GSourceFunc" managed-name="SourceFunc" /> */
        /* transfer-ownership:none scope:notified closure:1 destroy:2 direction:in */
        delegate* unmanaged[Cdecl]<System.IntPtr, GISharp.Runtime.Boolean> func,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr data,
        /* <type name="DestroyNotify" type="GDestroyNotify" managed-name="DestroyNotify" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:async direction:in */
        delegate* unmanaged[Cdecl]<System.IntPtr, void> notify);
        partial void CheckSetCallbackArgs(GISharp.Lib.GLib.SourceFunc func);

        /// <include file="Source.xmldoc" path="declaration/member[@name='Source.SetCallback(GISharp.Lib.GLib.SourceFunc)']/*" />
        public void SetCallback(GISharp.Lib.GLib.SourceFunc func)
        {
            CheckSetCallbackArgs(func);
            var source_ = (GISharp.Lib.GLib.Source.UnmanagedStruct*)UnsafeHandle;
            var func_ = (delegate* unmanaged[Cdecl]<System.IntPtr, GISharp.Runtime.Boolean>)&GISharp.Lib.GLib.SourceFuncMarshal.Callback;
            var funcHandle = System.Runtime.InteropServices.GCHandle.Alloc((func, GISharp.Runtime.CallbackScope.Notified));
            var data_ = (System.IntPtr)funcHandle;
            var notify_ = (delegate* unmanaged[Cdecl]<System.IntPtr, void>)&GISharp.Runtime.GMarshal.DestroyGCHandle;
            g_source_set_callback(source_, func_, data_, notify_);
        }

        /// <summary>
        /// Sets the callback function storing the data as a refcounted callback
        /// "object". This is used internally. Note that calling
        /// g_source_set_callback_indirect() assumes
        /// an initial reference count on @callback_data, and thus
        /// @callback_funcs-&gt;unref will eventually be called once more
        /// than @callback_funcs-&gt;ref.
        /// </summary>
        /// <remarks>
        /// It is safe to call this function multiple times on a source which has already
        /// been attached to a context. The changes will take effect for the next time
        /// the source is dispatched after this call returns.
        /// </remarks>
        /// <param name="source">
        /// the source
        /// </param>
        /// <param name="callbackData">
        /// pointer to callback data "object"
        /// </param>
        /// <param name="callbackFuncs">
        /// functions for reference counting @callback_data
        ///                  and getting the callback and data
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_source_set_callback_indirect(
        /* <type name="Source" type="GSource*" managed-name="Source" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Source.UnmanagedStruct* source,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr callbackData,
        /* <type name="SourceCallbackFuncs" type="GSourceCallbackFuncs*" managed-name="SourceCallbackFuncs" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.SourceCallbackFuncs* callbackFuncs);
        partial void CheckSetCallbackIndirectArgs(System.IntPtr callbackData, GISharp.Lib.GLib.SourceCallbackFuncs callbackFuncs);

        /// <include file="Source.xmldoc" path="declaration/member[@name='Source.SetCallbackIndirect(System.IntPtr,GISharp.Lib.GLib.SourceCallbackFuncs)']/*" />
        public void SetCallbackIndirect(System.IntPtr callbackData, GISharp.Lib.GLib.SourceCallbackFuncs callbackFuncs)
        {
            CheckSetCallbackIndirectArgs(callbackData, callbackFuncs);
            var source_ = (GISharp.Lib.GLib.Source.UnmanagedStruct*)UnsafeHandle;
            var callbackData_ = (System.IntPtr)callbackData;
            var callbackFuncs_ = &callbackFuncs;
            g_source_set_callback_indirect(source_, callbackData_, callbackFuncs_);
        }

        /// <summary>
        /// Sets whether a source can be called recursively. If @can_recurse is
        /// %TRUE, then while the source is being dispatched then this source
        /// will be processed normally. Otherwise, all processing of this
        /// source is blocked until the dispatch function returns.
        /// </summary>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <param name="canRecurse">
        /// whether recursion is allowed for this source
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_source_set_can_recurse(
        /* <type name="Source" type="GSource*" managed-name="Source" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Source.UnmanagedStruct* source,
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.Boolean canRecurse);
        partial void CheckSetCanRecurseArgs(bool canRecurse);

        private void SetCanRecurse(bool canRecurse)
        {
            CheckSetCanRecurseArgs(canRecurse);
            var source_ = (GISharp.Lib.GLib.Source.UnmanagedStruct*)UnsafeHandle;
            var canRecurse_ = GISharp.Runtime.BooleanExtensions.ToBoolean(canRecurse);
            g_source_set_can_recurse(source_, canRecurse_);
        }

        /// <summary>
        /// Sets the source functions (can be used to override
        /// default implementations) of an unattached source.
        /// </summary>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <param name="funcs">
        /// the new #GSourceFuncs
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.12")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_source_set_funcs(
        /* <type name="Source" type="GSource*" managed-name="Source" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Source.UnmanagedStruct* source,
        /* <type name="SourceFuncs" type="GSourceFuncs*" managed-name="SourceFuncs" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.SourceFuncs* funcs);
        partial void CheckSetFuncsArgs(GISharp.Lib.GLib.SourceFuncs funcs);

        /// <include file="Source.xmldoc" path="declaration/member[@name='Source.SetFuncs(GISharp.Lib.GLib.SourceFuncs)']/*" />
        [GISharp.Runtime.SinceAttribute("2.12")]
        public void SetFuncs(GISharp.Lib.GLib.SourceFuncs funcs)
        {
            CheckSetFuncsArgs(funcs);
            var source_ = (GISharp.Lib.GLib.Source.UnmanagedStruct*)UnsafeHandle;
            var funcs_ = &funcs;
            g_source_set_funcs(source_, funcs_);
        }

        /// <summary>
        /// Sets a name for the source, used in debugging and profiling.
        /// The name defaults to #NULL.
        /// </summary>
        /// <remarks>
        /// The source name should describe in a human-readable way
        /// what the source does. For example, "X11 event queue"
        /// or "GTK+ repaint idle handler" or whatever it is.
        /// 
        /// It is permitted to call this function multiple times, but is not
        /// recommended due to the potential performance impact.  For example,
        /// one could change the name in the "check" function of a #GSourceFuncs
        /// to include details like the event type in the source name.
        /// 
        /// Use caution if changing the name while another thread may be
        /// accessing it with g_source_get_name(); that function does not copy
        /// the value, and changing the value will free it while the other thread
        /// may be attempting to use it.
        /// </remarks>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <param name="name">
        /// debug name for the source
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.26")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_source_set_name(
        /* <type name="Source" type="GSource*" managed-name="Source" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Source.UnmanagedStruct* source,
        /* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* name);
        partial void CheckSetNameArgs(GISharp.Lib.GLib.UnownedUtf8 name);

        [GISharp.Runtime.SinceAttribute("2.26")]
        private void SetName(GISharp.Lib.GLib.UnownedUtf8 name)
        {
            CheckSetNameArgs(name);
            var source_ = (GISharp.Lib.GLib.Source.UnmanagedStruct*)UnsafeHandle;
            var name_ = (byte*)name.UnsafeHandle;
            g_source_set_name(source_, name_);
        }

        /// <summary>
        /// Sets the priority of a source. While the main loop is being run, a
        /// source will be dispatched if it is ready to be dispatched and no
        /// sources at a higher (numerically smaller) priority are ready to be
        /// dispatched.
        /// </summary>
        /// <remarks>
        /// A child source always has the same priority as its parent.  It is not
        /// permitted to change the priority of a source once it has been added
        /// as a child of another source.
        /// </remarks>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <param name="priority">
        /// the new priority.
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_source_set_priority(
        /* <type name="Source" type="GSource*" managed-name="Source" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Source.UnmanagedStruct* source,
        /* <type name="gint" type="gint" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        int priority);
        partial void CheckSetPriorityArgs(int priority);

        private void SetPriority(int priority)
        {
            CheckSetPriorityArgs(priority);
            var source_ = (GISharp.Lib.GLib.Source.UnmanagedStruct*)UnsafeHandle;
            var priority_ = (int)priority;
            g_source_set_priority(source_, priority_);
        }

        /// <summary>
        /// Sets a #GSource to be dispatched when the given monotonic time is
        /// reached (or passed).  If the monotonic time is in the past (as it
        /// always will be if @ready_time is 0) then the source will be
        /// dispatched immediately.
        /// </summary>
        /// <remarks>
        /// If @ready_time is -1 then the source is never woken up on the basis
        /// of the passage of time.
        /// 
        /// Dispatching the source does not reset the ready time.  You should do
        /// so yourself, from the source dispatch function.
        /// 
        /// Note that if you have a pair of sources where the ready time of one
        /// suggests that it will be delivered first but the priority for the
        /// other suggests that it would be delivered first, and the ready time
        /// for both sources is reached during the same main context iteration,
        /// then the order of dispatch is undefined.
        /// 
        /// It is a no-op to call this function on a #GSource which has already been
        /// destroyed with g_source_destroy().
        /// 
        /// This API is only intended to be used by implementations of #GSource.
        /// Do not call this API on a #GSource that you did not create.
        /// </remarks>
        /// <param name="source">
        /// a #GSource
        /// </param>
        /// <param name="readyTime">
        /// the monotonic time at which the source will be ready,
        ///              0 for "immediately", -1 for "never"
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_source_set_ready_time(
        /* <type name="Source" type="GSource*" managed-name="Source" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Source.UnmanagedStruct* source,
        /* <type name="gint64" type="gint64" managed-name="System.Int64" /> */
        /* transfer-ownership:none direction:in */
        long readyTime);
        partial void CheckSetReadyTimeArgs(long readyTime);

        [GISharp.Runtime.SinceAttribute("2.36")]
        private void SetReadyTime(long readyTime)
        {
            CheckSetReadyTimeArgs(readyTime);
            var source_ = (GISharp.Lib.GLib.Source.UnmanagedStruct*)UnsafeHandle;
            var readyTime_ = (long)readyTime;
            g_source_set_ready_time(source_, readyTime_);
        }

        /// <summary>
        /// Decreases the reference count of a source by one. If the
        /// resulting reference count is zero the source and associated
        /// memory will be destroyed.
        /// </summary>
        /// <param name="source">
        /// a #GSource
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_source_unref(
        /* <type name="Source" type="GSource*" managed-name="Source" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Source.UnmanagedStruct* source);

        /// <inheritdoc/>
        protected override void Dispose(bool disposing)
        {
            if (handle != System.IntPtr.Zero)
            {
                g_source_unref((UnmanagedStruct*)handle);
            }

            base.Dispose(disposing);
        }
    }
}