// SPDX-License-Identifier: MIT
// ATTENTION: This file is automatically generated. Do not edit manually.
#nullable enable
namespace GISharp.Lib.GLib
{
    /// <include file="Timeout.xmldoc" path="declaration/member[@name='Timeout']/*" />
    public static unsafe partial class Timeout
    {
        /// <summary>
        /// Sets a function to be called at regular intervals, with the given
        /// priority.  The function is called repeatedly until it returns
        /// %FALSE, at which point the timeout is automatically destroyed and
        /// the function will not be called again.  The @notify function is
        /// called when the timeout is destroyed.  The first call to the
        /// function will be at the end of the first @interval.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Note that timeout functions may be delayed, due to the processing of other
        /// event sources. Thus they should not be relied on for precise timing.
        /// After each call to the timeout function, the time of the next
        /// timeout is recalculated based on the current time and the given interval
        /// (it does not try to 'catch up' time lost in delays).
        /// </para>
        /// <para>
        /// See [memory management of sources][mainloop-memory-management] for details
        /// on how to handle the return value and memory management of @data.
        /// </para>
        /// <para>
        /// This internally creates a main loop source using g_timeout_source_new()
        /// and attaches it to the global #GMainContext using g_source_attach(), so
        /// the callback will be invoked in whichever thread is running that main
        /// context. You can do these steps manually if you need greater control or to
        /// use a custom main context.
        /// </para>
        /// <para>
        /// The interval given is in terms of monotonic time, not wall clock time.
        /// See g_get_monotonic_time().
        /// </para>
        /// </remarks>
        /// <param name="priority">
        /// the priority of the timeout source. Typically this will be in
        ///            the range between #G_PRIORITY_DEFAULT and #G_PRIORITY_HIGH.
        /// </param>
        /// <param name="interval">
        /// the time between calls to the function, in milliseconds
        ///             (1/1000ths of a second)
        /// </param>
        /// <param name="function">
        /// function to call
        /// </param>
        /// <param name="data">
        /// data to pass to @function
        /// </param>
        /// <param name="notify">
        /// function to call when the timeout is removed, or %NULL
        /// </param>
        /// <returns>
        /// the ID (greater than 0) of the event source.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        private static extern uint g_timeout_add_full(
        /* <type name="gint" type="gint" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        int priority,
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        uint interval,
        /* <type name="SourceFunc" type="GSourceFunc" managed-name="SourceFunc" /> */
        /* transfer-ownership:none scope:notified closure:3 destroy:4 direction:in */
        delegate* unmanaged[Cdecl]<System.IntPtr, GISharp.Runtime.Boolean> function,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr data,
        /* <type name="DestroyNotify" type="GDestroyNotify" managed-name="DestroyNotify" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:async direction:in */
        delegate* unmanaged[Cdecl]<System.IntPtr, void> notify);
        static partial void CheckAddArgs(uint interval, GISharp.Lib.GLib.SourceFunc function, int priority = GISharp.Lib.GLib.Priority.Default);

        /// <include file="Timeout.xmldoc" path="declaration/member[@name='Timeout.Add(uint,GISharp.Lib.GLib.SourceFunc,int)']/*" />
        public static uint Add(uint interval, GISharp.Lib.GLib.SourceFunc function, int priority = GISharp.Lib.GLib.Priority.Default)
        {
            CheckAddArgs(interval, function, priority);
            var interval_ = (uint)interval;
            var function_ = (delegate* unmanaged[Cdecl]<System.IntPtr, GISharp.Runtime.Boolean>)&GISharp.Lib.GLib.SourceFuncMarshal.Callback;
            var functionHandle = System.Runtime.InteropServices.GCHandle.Alloc((function, GISharp.Runtime.CallbackScope.Notified));
            var data_ = (System.IntPtr)functionHandle;
            var notify_ = (delegate* unmanaged[Cdecl]<System.IntPtr, void>)&GISharp.Runtime.GMarshal.DestroyGCHandle;
            var priority_ = (int)priority;
            var ret_ = g_timeout_add_full(priority_,interval_,function_,data_,notify_);
            var ret = (uint)ret_;
            return ret;
        }

        /// <summary>
        /// Sets a function to be called at regular intervals, with @priority.
        /// The function is called repeatedly until it returns %FALSE, at which
        /// point the timeout is automatically destroyed and the function will
        /// not be called again.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Unlike g_timeout_add(), this function operates at whole second granularity.
        /// The initial starting point of the timer is determined by the implementation
        /// and the implementation is expected to group multiple timers together so that
        /// they fire all at the same time.
        /// To allow this grouping, the @interval to the first timer is rounded
        /// and can deviate up to one second from the specified interval.
        /// Subsequent timer iterations will generally run at the specified interval.
        /// </para>
        /// <para>
        /// Note that timeout functions may be delayed, due to the processing of other
        /// event sources. Thus they should not be relied on for precise timing.
        /// After each call to the timeout function, the time of the next
        /// timeout is recalculated based on the current time and the given @interval
        /// </para>
        /// <para>
        /// See [memory management of sources][mainloop-memory-management] for details
        /// on how to handle the return value and memory management of @data.
        /// </para>
        /// <para>
        /// If you want timing more precise than whole seconds, use g_timeout_add()
        /// instead.
        /// </para>
        /// <para>
        /// The grouping of timers to fire at the same time results in a more power
        /// and CPU efficient behavior so if your timer is in multiples of seconds
        /// and you don't require the first timer exactly one second from now, the
        /// use of g_timeout_add_seconds() is preferred over g_timeout_add().
        /// </para>
        /// <para>
        /// This internally creates a main loop source using
        /// g_timeout_source_new_seconds() and attaches it to the main loop context
        /// using g_source_attach(). You can do these steps manually if you need
        /// greater control.
        /// </para>
        /// <para>
        /// It is safe to call this function from any thread.
        /// </para>
        /// <para>
        /// The interval given is in terms of monotonic time, not wall clock
        /// time.  See g_get_monotonic_time().
        /// </para>
        /// </remarks>
        /// <param name="priority">
        /// the priority of the timeout source. Typically this will be in
        ///            the range between #G_PRIORITY_DEFAULT and #G_PRIORITY_HIGH.
        /// </param>
        /// <param name="interval">
        /// the time between calls to the function, in seconds
        /// </param>
        /// <param name="function">
        /// function to call
        /// </param>
        /// <param name="data">
        /// data to pass to @function
        /// </param>
        /// <param name="notify">
        /// function to call when the timeout is removed, or %NULL
        /// </param>
        /// <returns>
        /// the ID (greater than 0) of the event source.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.14")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        private static extern uint g_timeout_add_seconds_full(
        /* <type name="gint" type="gint" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        int priority,
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        uint interval,
        /* <type name="SourceFunc" type="GSourceFunc" managed-name="SourceFunc" /> */
        /* transfer-ownership:none scope:notified closure:3 destroy:4 direction:in */
        delegate* unmanaged[Cdecl]<System.IntPtr, GISharp.Runtime.Boolean> function,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr data,
        /* <type name="DestroyNotify" type="GDestroyNotify" managed-name="DestroyNotify" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:async direction:in */
        delegate* unmanaged[Cdecl]<System.IntPtr, void> notify);
        static partial void CheckAddSecondsArgs(uint interval, GISharp.Lib.GLib.SourceFunc function, int priority = GISharp.Lib.GLib.Priority.Default);

        /// <include file="Timeout.xmldoc" path="declaration/member[@name='Timeout.AddSeconds(uint,GISharp.Lib.GLib.SourceFunc,int)']/*" />
        [GISharp.Runtime.SinceAttribute("2.14")]
        public static uint AddSeconds(uint interval, GISharp.Lib.GLib.SourceFunc function, int priority = GISharp.Lib.GLib.Priority.Default)
        {
            CheckAddSecondsArgs(interval, function, priority);
            var interval_ = (uint)interval;
            var function_ = (delegate* unmanaged[Cdecl]<System.IntPtr, GISharp.Runtime.Boolean>)&GISharp.Lib.GLib.SourceFuncMarshal.Callback;
            var functionHandle = System.Runtime.InteropServices.GCHandle.Alloc((function, GISharp.Runtime.CallbackScope.Notified));
            var data_ = (System.IntPtr)functionHandle;
            var notify_ = (delegate* unmanaged[Cdecl]<System.IntPtr, void>)&GISharp.Runtime.GMarshal.DestroyGCHandle;
            var priority_ = (int)priority;
            var ret_ = g_timeout_add_seconds_full(priority_,interval_,function_,data_,notify_);
            var ret = (uint)ret_;
            return ret;
        }
    }
}