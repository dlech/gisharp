// SPDX-License-Identifier: MIT
// ATTENTION: This file is automatically generated. Do not edit manually.
#nullable enable
namespace GISharp.Lib.GLib
{
    /// <include file="PtrArray.xmldoc" path="declaration/member[@name='PtrArray']/*" />
    [GISharp.Runtime.GTypeAttribute("GPtrArray", IsProxyForUnmanagedType = true)]
    public abstract unsafe partial class PtrArray : GISharp.Runtime.Boxed
    {
        private static readonly GISharp.Runtime.GType _GType = g_ptr_array_get_type();

        /// <summary>
        /// The unmanaged data structure.
        /// </summary>
        public struct UnmanagedStruct
        {
#pragma warning disable CS0169, CS0414, CS0649
            /// <include file="PtrArray.xmldoc" path="declaration/member[@name='UnmanagedStruct.Pdata']/*" />
            public readonly System.IntPtr Pdata;

            /// <include file="PtrArray.xmldoc" path="declaration/member[@name='UnmanagedStruct.Len']/*" />
            public readonly uint Len;
#pragma warning restore CS0169, CS0414, CS0649
        }

        /// <summary>
        /// For internal runtime use only.
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        public PtrArray(System.IntPtr handle, GISharp.Runtime.Transfer ownership) : base(handle)
        {
            if (ownership == GISharp.Runtime.Transfer.None)
            {
                this.handle = (System.IntPtr)g_ptr_array_ref((UnmanagedStruct*)handle);
            }
        }

        /// <summary>
        /// Adds a pointer to the end of the pointer array. The array will grow
        /// in size automatically if necessary.
        /// </summary>
        /// <param name="array">
        /// a #GPtrArray
        /// </param>
        /// <param name="data">
        /// the pointer to add
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_ptr_array_add(
        /* <array name="GLib.PtrArray" type="GPtrArray*" zero-terminated="1" managed-name="GISharp.Lib.GLib.PtrArray" is-pointer="1">
*   <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" />
* </array> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.PtrArray.UnmanagedStruct* array,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr data);

        /// <summary>
        /// Makes a full (deep) copy of a #GPtrArray.
        /// </summary>
        /// <remarks>
        /// <para>
        /// @func, as a #GCopyFunc, takes two arguments, the data to be copied
        /// and a @user_data pointer. On common processor architectures, it's safe to
        /// pass %NULL as @user_data if the copy function takes only one argument. You
        /// may get compiler warnings from this though if compiling with GCC’s
        /// `-Wcast-function-type` warning.
        /// </para>
        /// <para>
        /// If @func is %NULL, then only the pointers (and not what they are
        /// pointing to) are copied to the new #GPtrArray.
        /// </para>
        /// <para>
        /// The copy of @array will have the same #GDestroyNotify for its elements as
        /// @array.
        /// </para>
        /// </remarks>
        /// <param name="array">
        /// #GPtrArray to duplicate
        /// </param>
        /// <param name="func">
        /// a copy function used to copy every element in the array
        /// </param>
        /// <param name="userData">
        /// user data passed to the copy function @func, or %NULL
        /// </param>
        /// <returns>
        /// a deep copy of the initial #GPtrArray.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.62")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <array name="GLib.PtrArray" type="GPtrArray*" zero-terminated="1" managed-name="GISharp.Lib.GLib.PtrArray" is-pointer="1">
*   <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" />
* </array> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GLib.PtrArray.UnmanagedStruct* g_ptr_array_copy(
        /* <array name="GLib.PtrArray" type="GPtrArray*" zero-terminated="1" managed-name="GISharp.Lib.GLib.PtrArray" is-pointer="1">
*   <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" />
* </array> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.PtrArray.UnmanagedStruct* array,
        /* <type name="CopyFunc" type="GCopyFunc" managed-name="CopyFunc" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 closure:2 direction:in */
        delegate* unmanaged[Cdecl]<System.IntPtr, System.IntPtr, System.IntPtr> func,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr userData);

        /// <summary>
        /// Adds all pointers of @array to the end of the array @array_to_extend.
        /// The array will grow in size automatically if needed. @array_to_extend is
        /// modified in-place.
        /// </summary>
        /// <remarks>
        /// <para>
        /// @func, as a #GCopyFunc, takes two arguments, the data to be copied
        /// and a @user_data pointer. On common processor architectures, it's safe to
        /// pass %NULL as @user_data if the copy function takes only one argument. You
        /// may get compiler warnings from this though if compiling with GCC’s
        /// `-Wcast-function-type` warning.
        /// </para>
        /// <para>
        /// If @func is %NULL, then only the pointers (and not what they are
        /// pointing to) are copied to the new #GPtrArray.
        /// </para>
        /// </remarks>
        /// <param name="arrayToExtend">
        /// a #GPtrArray.
        /// </param>
        /// <param name="array">
        /// a #GPtrArray to add to the end of @array_to_extend.
        /// </param>
        /// <param name="func">
        /// a copy function used to copy every element in the array
        /// </param>
        /// <param name="userData">
        /// user data passed to the copy function @func, or %NULL
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.62")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_ptr_array_extend(
        /* <array name="GLib.PtrArray" type="GPtrArray*" zero-terminated="1" managed-name="GISharp.Lib.GLib.PtrArray" is-pointer="1">
*   <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" />
* </array> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.PtrArray.UnmanagedStruct* arrayToExtend,
        /* <array name="GLib.PtrArray" type="GPtrArray*" zero-terminated="1" managed-name="GISharp.Lib.GLib.PtrArray" is-pointer="1">
*   <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" />
* </array> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.PtrArray.UnmanagedStruct* array,
        /* <type name="CopyFunc" type="GCopyFunc" managed-name="CopyFunc" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 closure:3 direction:in */
        delegate* unmanaged[Cdecl]<System.IntPtr, System.IntPtr, System.IntPtr> func,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr userData);

        /// <summary>
        /// Adds all the pointers in @array to the end of @array_to_extend, transferring
        /// ownership of each element from @array to @array_to_extend and modifying
        /// @array_to_extend in-place. @array is then freed.
        /// </summary>
        /// <remarks>
        /// <para>
        /// As with g_ptr_array_free(), @array will be destroyed if its reference count
        /// is 1. If its reference count is higher, it will be decremented and the
        /// length of @array set to zero.
        /// </para>
        /// </remarks>
        /// <param name="arrayToExtend">
        /// a #GPtrArray.
        /// </param>
        /// <param name="array">
        /// a #GPtrArray to add to the end of
        ///     @array_to_extend.
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.62")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_ptr_array_extend_and_steal(
        /* <array name="GLib.PtrArray" type="GPtrArray*" zero-terminated="1" managed-name="GISharp.Lib.GLib.PtrArray" is-pointer="1">
*   <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" />
* </array> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.PtrArray.UnmanagedStruct* arrayToExtend,
        /* <array name="GLib.PtrArray" type="GPtrArray*" zero-terminated="1" managed-name="GISharp.Lib.GLib.PtrArray" is-pointer="1">
*   <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" />
* </array> */
        /* transfer-ownership:container direction:in */
        GISharp.Lib.GLib.PtrArray.UnmanagedStruct* array);

        /// <summary>
        /// Checks whether @needle exists in @haystack. If the element is found, %TRUE is
        /// returned and the element’s index is returned in @index_ (if non-%NULL).
        /// Otherwise, %FALSE is returned and @index_ is undefined. If @needle exists
        /// multiple times in @haystack, the index of the first instance is returned.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This does pointer comparisons only. If you want to use more complex equality
        /// checks, such as string comparisons, use g_ptr_array_find_with_equal_func().
        /// </para>
        /// </remarks>
        /// <param name="haystack">
        /// pointer array to be searched
        /// </param>
        /// <param name="needle">
        /// pointer to look for
        /// </param>
        /// <param name="index">
        /// return location for the index of
        ///    the element, if found
        /// </param>
        /// <returns>
        /// %TRUE if @needle is one of the elements of @haystack
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.54")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_ptr_array_find(
        /* <array name="GLib.PtrArray" type="GPtrArray*" zero-terminated="1" managed-name="GISharp.Lib.GLib.PtrArray" is-pointer="1">
*   <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" />
* </array> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.PtrArray.UnmanagedStruct* haystack,
        /* <type name="gpointer" type="gconstpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr needle,
        /* <type name="guint" type="guint*" managed-name="System.UInt32" /> */
        /* direction:out caller-allocates:1 transfer-ownership:none optional:1 allow-none:1 */
        uint* index);

        /// <summary>
        /// Checks whether @needle exists in @haystack, using the given @equal_func.
        /// If the element is found, %TRUE is returned and the element’s index is
        /// returned in @index_ (if non-%NULL). Otherwise, %FALSE is returned and @index_
        /// is undefined. If @needle exists multiple times in @haystack, the index of
        /// the first instance is returned.
        /// </summary>
        /// <remarks>
        /// <para>
        /// @equal_func is called with the element from the array as its first parameter,
        /// and @needle as its second parameter. If @equal_func is %NULL, pointer
        /// equality is used.
        /// </para>
        /// </remarks>
        /// <param name="haystack">
        /// pointer array to be searched
        /// </param>
        /// <param name="needle">
        /// pointer to look for
        /// </param>
        /// <param name="equalFunc">
        /// the function to call for each element, which should
        ///    return %TRUE when the desired element is found; or %NULL to use pointer
        ///    equality
        /// </param>
        /// <param name="index">
        /// return location for the index of
        ///    the element, if found
        /// </param>
        /// <returns>
        /// %TRUE if @needle is one of the elements of @haystack
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.54")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_ptr_array_find_with_equal_func(
        /* <array name="GLib.PtrArray" type="GPtrArray*" zero-terminated="1" managed-name="GISharp.Lib.GLib.PtrArray" is-pointer="1">
*   <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" />
* </array> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.PtrArray.UnmanagedStruct* haystack,
        /* <type name="gpointer" type="gconstpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr needle,
        /* <type name="EqualFunc" type="GEqualFunc" managed-name="EqualFunc" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        delegate* unmanaged[Cdecl]<System.IntPtr, System.IntPtr, GISharp.Runtime.Boolean> equalFunc,
        /* <type name="guint" type="guint*" managed-name="System.UInt32" /> */
        /* direction:out caller-allocates:1 transfer-ownership:none optional:1 allow-none:1 */
        uint* index);

        /// <summary>
        /// Calls a function for each element of a #GPtrArray. @func must not
        /// add elements to or remove elements from the array.
        /// </summary>
        /// <param name="array">
        /// a #GPtrArray
        /// </param>
        /// <param name="func">
        /// the function to call for each array element
        /// </param>
        /// <param name="userData">
        /// user data to pass to the function
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.4")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_ptr_array_foreach(
        /* <array name="GLib.PtrArray" type="GPtrArray*" zero-terminated="1" managed-name="GISharp.Lib.GLib.PtrArray" is-pointer="1">
*   <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" />
* </array> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.PtrArray.UnmanagedStruct* array,
        /* <type name="Func" type="GFunc" managed-name="Func" /> */
        /* transfer-ownership:none closure:2 direction:in */
        delegate* unmanaged[Cdecl]<System.IntPtr, System.IntPtr, void> func,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr userData);

        /// <summary>
        /// Frees the memory allocated for the #GPtrArray. If @free_seg is %TRUE
        /// it frees the memory block holding the elements as well. Pass %FALSE
        /// if you want to free the #GPtrArray wrapper but preserve the
        /// underlying array for use elsewhere. If the reference count of @array
        /// is greater than one, the #GPtrArray wrapper is preserved but the
        /// size of @array will be set to zero.
        /// </summary>
        /// <remarks>
        /// <para>
        /// If array contents point to dynamically-allocated memory, they should
        /// be freed separately if @free_seg is %TRUE and no #GDestroyNotify
        /// function has been set for @array.
        /// </para>
        /// <para>
        /// This function is not thread-safe. If using a #GPtrArray from multiple
        /// threads, use only the atomic g_ptr_array_ref() and g_ptr_array_unref()
        /// functions.
        /// </para>
        /// </remarks>
        /// <param name="array">
        /// a #GPtrArray
        /// </param>
        /// <param name="freeSeg">
        /// if %TRUE the actual pointer array is freed as well
        /// </param>
        /// <returns>
        /// the pointer array if @free_seg is %FALSE, otherwise %NULL.
        ///     The pointer array should be freed using g_free().
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gpointer" type="gpointer*" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 direction:in */
        private static extern System.IntPtr g_ptr_array_free(
        /* <array name="GLib.PtrArray" type="GPtrArray*" zero-terminated="1" managed-name="GISharp.Lib.GLib.PtrArray" is-pointer="1">
*   <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" />
* </array> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.PtrArray.UnmanagedStruct* array,
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.Boolean freeSeg);

        /// <summary>
        /// Inserts an element into the pointer array at the given index. The
        /// array will grow in size automatically if necessary.
        /// </summary>
        /// <param name="array">
        /// a #GPtrArray
        /// </param>
        /// <param name="index">
        /// the index to place the new element at, or -1 to append
        /// </param>
        /// <param name="data">
        /// the pointer to add.
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.40")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_ptr_array_insert(
        /* <array name="GLib.PtrArray" type="GPtrArray*" zero-terminated="1" managed-name="GISharp.Lib.GLib.PtrArray" is-pointer="1">
*   <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" />
* </array> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.PtrArray.UnmanagedStruct* array,
        /* <type name="gint" type="gint" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        int index,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr data);

        /// <summary>
        /// Creates a new #GPtrArray with a reference count of 1.
        /// </summary>
        /// <returns>
        /// the new #GPtrArray
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <array name="GLib.PtrArray" type="GPtrArray*" zero-terminated="1" managed-name="GISharp.Lib.GLib.PtrArray" is-pointer="1">
*   <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" />
* </array> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GLib.PtrArray.UnmanagedStruct* g_ptr_array_new();

        /// <summary>
        /// Creates a new #GPtrArray with @reserved_size pointers preallocated
        /// and a reference count of 1. This avoids frequent reallocation, if
        /// you are going to add many pointers to the array. Note however that
        /// the size of the array is still 0. It also set @element_free_func
        /// for freeing each element when the array is destroyed either via
        /// g_ptr_array_unref(), when g_ptr_array_free() is called with
        /// @free_segment set to %TRUE or when removing elements.
        /// </summary>
        /// <param name="reservedSize">
        /// number of pointers preallocated
        /// </param>
        /// <param name="elementFreeFunc">
        /// A function to free elements with
        ///     destroy @array or %NULL
        /// </param>
        /// <returns>
        /// A new #GPtrArray
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.30")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <array name="GLib.PtrArray" type="GPtrArray*" zero-terminated="1" managed-name="GISharp.Lib.GLib.PtrArray" is-pointer="1">
*   <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" />
* </array> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GLib.PtrArray.UnmanagedStruct* g_ptr_array_new_full(
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        uint reservedSize,
        /* <type name="DestroyNotify" type="GDestroyNotify" managed-name="DestroyNotify" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:async direction:in */
        delegate* unmanaged[Cdecl]<System.IntPtr, void> elementFreeFunc);

        /// <summary>
        /// Creates a new #GPtrArray with a reference count of 1 and use
        /// @element_free_func for freeing each element when the array is destroyed
        /// either via g_ptr_array_unref(), when g_ptr_array_free() is called with
        /// @free_segment set to %TRUE or when removing elements.
        /// </summary>
        /// <param name="elementFreeFunc">
        /// A function to free elements with
        ///     destroy @array or %NULL
        /// </param>
        /// <returns>
        /// A new #GPtrArray
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.22")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <array name="GLib.PtrArray" type="GPtrArray*" zero-terminated="1" managed-name="GISharp.Lib.GLib.PtrArray" is-pointer="1">
*   <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" />
* </array> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GLib.PtrArray.UnmanagedStruct* g_ptr_array_new_with_free_func(
        /* <type name="DestroyNotify" type="GDestroyNotify" managed-name="DestroyNotify" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:async direction:in */
        delegate* unmanaged[Cdecl]<System.IntPtr, void> elementFreeFunc);

        /// <summary>
        /// Removes the first occurrence of the given pointer from the pointer
        /// array. The following elements are moved down one place. If @array
        /// has a non-%NULL #GDestroyNotify function it is called for the
        /// removed element.
        /// </summary>
        /// <remarks>
        /// <para>
        /// It returns %TRUE if the pointer was removed, or %FALSE if the
        /// pointer was not found.
        /// </para>
        /// </remarks>
        /// <param name="array">
        /// a #GPtrArray
        /// </param>
        /// <param name="data">
        /// the pointer to remove
        /// </param>
        /// <returns>
        /// %TRUE if the pointer is removed, %FALSE if the pointer
        ///     is not found in the array
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_ptr_array_remove(
        /* <array name="GLib.PtrArray" type="GPtrArray*" zero-terminated="1" managed-name="GISharp.Lib.GLib.PtrArray" is-pointer="1">
*   <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" />
* </array> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.PtrArray.UnmanagedStruct* array,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr data);

        /// <summary>
        /// Removes the first occurrence of the given pointer from the pointer
        /// array. The last element in the array is used to fill in the space,
        /// so this function does not preserve the order of the array. But it
        /// is faster than g_ptr_array_remove(). If @array has a non-%NULL
        /// #GDestroyNotify function it is called for the removed element.
        /// </summary>
        /// <remarks>
        /// <para>
        /// It returns %TRUE if the pointer was removed, or %FALSE if the
        /// pointer was not found.
        /// </para>
        /// </remarks>
        /// <param name="array">
        /// a #GPtrArray
        /// </param>
        /// <param name="data">
        /// the pointer to remove
        /// </param>
        /// <returns>
        /// %TRUE if the pointer was found in the array
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_ptr_array_remove_fast(
        /* <array name="GLib.PtrArray" type="GPtrArray*" zero-terminated="1" managed-name="GISharp.Lib.GLib.PtrArray" is-pointer="1">
*   <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" />
* </array> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.PtrArray.UnmanagedStruct* array,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr data);

        /// <summary>
        /// Removes the pointer at the given index from the pointer array.
        /// The following elements are moved down one place. If @array has
        /// a non-%NULL #GDestroyNotify function it is called for the removed
        /// element. If so, the return value from this function will potentially point
        /// to freed memory (depending on the #GDestroyNotify implementation).
        /// </summary>
        /// <param name="array">
        /// a #GPtrArray
        /// </param>
        /// <param name="index">
        /// the index of the pointer to remove
        /// </param>
        /// <returns>
        /// the pointer which was removed
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 direction:in */
        private static extern System.IntPtr g_ptr_array_remove_index(
        /* <array name="GLib.PtrArray" type="GPtrArray*" zero-terminated="1" managed-name="GISharp.Lib.GLib.PtrArray" is-pointer="1">
*   <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" />
* </array> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.PtrArray.UnmanagedStruct* array,
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        uint index);

        /// <summary>
        /// Removes the pointer at the given index from the pointer array.
        /// The last element in the array is used to fill in the space, so
        /// this function does not preserve the order of the array. But it
        /// is faster than g_ptr_array_remove_index(). If @array has a non-%NULL
        /// #GDestroyNotify function it is called for the removed element. If so, the
        /// return value from this function will potentially point to freed memory
        /// (depending on the #GDestroyNotify implementation).
        /// </summary>
        /// <param name="array">
        /// a #GPtrArray
        /// </param>
        /// <param name="index">
        /// the index of the pointer to remove
        /// </param>
        /// <returns>
        /// the pointer which was removed
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 direction:in */
        private static extern System.IntPtr g_ptr_array_remove_index_fast(
        /* <array name="GLib.PtrArray" type="GPtrArray*" zero-terminated="1" managed-name="GISharp.Lib.GLib.PtrArray" is-pointer="1">
*   <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" />
* </array> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.PtrArray.UnmanagedStruct* array,
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        uint index);

        /// <summary>
        /// Removes the given number of pointers starting at the given index
        /// from a #GPtrArray. The following elements are moved to close the
        /// gap. If @array has a non-%NULL #GDestroyNotify function it is
        /// called for the removed elements.
        /// </summary>
        /// <param name="array">
        /// a @GPtrArray
        /// </param>
        /// <param name="index">
        /// the index of the first pointer to remove
        /// </param>
        /// <param name="length">
        /// the number of pointers to remove
        /// </param>
        /// <returns>
        /// the @array
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.4")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <array name="GLib.PtrArray" type="GPtrArray*" zero-terminated="1" managed-name="GISharp.Lib.GLib.PtrArray" is-pointer="1">
*   <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" />
* </array> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GLib.PtrArray.UnmanagedStruct* g_ptr_array_remove_range(
        /* <array name="GLib.PtrArray" type="GPtrArray*" zero-terminated="1" managed-name="GISharp.Lib.GLib.PtrArray" is-pointer="1">
*   <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" />
* </array> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.PtrArray.UnmanagedStruct* array,
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        uint index,
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        uint length);

        /// <summary>
        /// Sets a function for freeing each element when @array is destroyed
        /// either via g_ptr_array_unref(), when g_ptr_array_free() is called
        /// with @free_segment set to %TRUE or when removing elements.
        /// </summary>
        /// <param name="array">
        /// A #GPtrArray
        /// </param>
        /// <param name="elementFreeFunc">
        /// A function to free elements with
        ///     destroy @array or %NULL
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.22")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_ptr_array_set_free_func(
        /* <array name="GLib.PtrArray" type="GPtrArray*" zero-terminated="1" managed-name="GISharp.Lib.GLib.PtrArray" is-pointer="1">
*   <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" />
* </array> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.PtrArray.UnmanagedStruct* array,
        /* <type name="DestroyNotify" type="GDestroyNotify" managed-name="DestroyNotify" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:async direction:in */
        delegate* unmanaged[Cdecl]<System.IntPtr, void> elementFreeFunc);

        /// <summary>
        /// Sets the size of the array. When making the array larger,
        /// newly-added elements will be set to %NULL. When making it smaller,
        /// if @array has a non-%NULL #GDestroyNotify function then it will be
        /// called for the removed elements.
        /// </summary>
        /// <param name="array">
        /// a #GPtrArray
        /// </param>
        /// <param name="length">
        /// the new length of the pointer array
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_ptr_array_set_size(
        /* <array name="GLib.PtrArray" type="GPtrArray*" zero-terminated="1" managed-name="GISharp.Lib.GLib.PtrArray" is-pointer="1">
*   <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" />
* </array> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.PtrArray.UnmanagedStruct* array,
        /* <type name="gint" type="gint" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        int length);

        /// <summary>
        /// Creates a new #GPtrArray with @reserved_size pointers preallocated
        /// and a reference count of 1. This avoids frequent reallocation, if
        /// you are going to add many pointers to the array. Note however that
        /// the size of the array is still 0.
        /// </summary>
        /// <param name="reservedSize">
        /// number of pointers preallocated
        /// </param>
        /// <returns>
        /// the new #GPtrArray
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <array name="GLib.PtrArray" type="GPtrArray*" zero-terminated="1" managed-name="GISharp.Lib.GLib.PtrArray" is-pointer="1">
*   <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" />
* </array> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GLib.PtrArray.UnmanagedStruct* g_ptr_array_sized_new(
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        uint reservedSize);

        /// <summary>
        /// Sorts the array, using @compare_func which should be a qsort()-style
        /// comparison function (returns less than zero for first arg is less
        /// than second arg, zero for equal, greater than zero if irst arg is
        /// greater than second arg).
        /// </summary>
        /// <remarks>
        /// <para>
        /// Note that the comparison function for g_ptr_array_sort() doesn't
        /// take the pointers from the array as arguments, it takes pointers to
        /// the pointers in the array. Here is a full example of usage:
        /// </para>
        /// <para>
        /// |[&lt;!-- language="C" --&gt;
        /// typedef struct
        /// {
        ///   gchar *name;
        ///   gint size;
        /// } FileListEntry;
        /// </para>
        /// <para>
        /// static gint
        /// sort_filelist (gconstpointer a, gconstpointer b)
        /// {
        ///   const FileListEntry *entry1 = *((FileListEntry **) a);
        ///   const FileListEntry *entry2 = *((FileListEntry **) b);
        /// </para>
        /// <para>
        ///   return g_ascii_strcasecmp (entry1-&gt;name, entry2-&gt;name);
        /// }
        /// </para>
        /// <para>
        /// …
        /// g_autoptr (GPtrArray) file_list = NULL;
        /// </para>
        /// <para>
        /// // initialize file_list array and load with many FileListEntry entries
        /// ...
        /// // now sort it with
        /// g_ptr_array_sort (file_list, sort_filelist);
        /// ]|
        /// </para>
        /// <para>
        /// This is guaranteed to be a stable sort since version 2.32.
        /// </para>
        /// </remarks>
        /// <param name="array">
        /// a #GPtrArray
        /// </param>
        /// <param name="compareFunc">
        /// comparison function
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_ptr_array_sort(
        /* <array name="GLib.PtrArray" type="GPtrArray*" zero-terminated="1" managed-name="GISharp.Lib.GLib.PtrArray" is-pointer="1">
*   <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" />
* </array> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.PtrArray.UnmanagedStruct* array,
        /* <type name="CompareFunc" type="GCompareFunc" managed-name="CompareFunc" /> */
        /* transfer-ownership:none direction:in */
        delegate* unmanaged[Cdecl]<System.IntPtr, System.IntPtr, int> compareFunc);

        /// <summary>
        /// Like g_ptr_array_sort(), but the comparison function has an extra
        /// user data argument.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Note that the comparison function for g_ptr_array_sort_with_data()
        /// doesn't take the pointers from the array as arguments, it takes
        /// pointers to the pointers in the array. Here is a full example of use:
        /// </para>
        /// <para>
        /// |[&lt;!-- language="C" --&gt;
        /// typedef enum { SORT_NAME, SORT_SIZE } SortMode;
        /// </para>
        /// <para>
        /// typedef struct
        /// {
        ///   gchar *name;
        ///   gint size;
        /// } FileListEntry;
        /// </para>
        /// <para>
        /// static gint
        /// sort_filelist (gconstpointer a, gconstpointer b, gpointer user_data)
        /// {
        ///   gint order;
        ///   const SortMode sort_mode = GPOINTER_TO_INT (user_data);
        ///   const FileListEntry *entry1 = *((FileListEntry **) a);
        ///   const FileListEntry *entry2 = *((FileListEntry **) b);
        /// </para>
        /// <para>
        ///   switch (sort_mode)
        ///     {
        ///     case SORT_NAME:
        ///       order = g_ascii_strcasecmp (entry1-&gt;name, entry2-&gt;name);
        ///       break;
        ///     case SORT_SIZE:
        ///       order = entry1-&gt;size - entry2-&gt;size;
        ///       break;
        ///     default:
        ///       order = 0;
        ///       break;
        ///     }
        ///   return order;
        /// }
        /// </para>
        /// <para>
        /// ...
        /// g_autoptr (GPtrArray) file_list = NULL;
        /// SortMode sort_mode;
        /// </para>
        /// <para>
        /// // initialize file_list array and load with many FileListEntry entries
        /// ...
        /// // now sort it with
        /// sort_mode = SORT_NAME;
        /// g_ptr_array_sort_with_data (file_list,
        ///                             sort_filelist,
        ///                             GINT_TO_POINTER (sort_mode));
        /// ]|
        /// </para>
        /// <para>
        /// This is guaranteed to be a stable sort since version 2.32.
        /// </para>
        /// </remarks>
        /// <param name="array">
        /// a #GPtrArray
        /// </param>
        /// <param name="compareFunc">
        /// comparison function
        /// </param>
        /// <param name="userData">
        /// data to pass to @compare_func
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_ptr_array_sort_with_data(
        /* <array name="GLib.PtrArray" type="GPtrArray*" zero-terminated="1" managed-name="GISharp.Lib.GLib.PtrArray" is-pointer="1">
*   <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" />
* </array> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.PtrArray.UnmanagedStruct* array,
        /* <type name="CompareDataFunc" type="GCompareDataFunc" managed-name="CompareDataFunc" /> */
        /* transfer-ownership:none closure:2 direction:in */
        delegate* unmanaged[Cdecl]<System.IntPtr, System.IntPtr, System.IntPtr, int> compareFunc,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr userData);

        /// <summary>
        /// Frees the data in the array and resets the size to zero, while
        /// the underlying array is preserved for use elsewhere and returned
        /// to the caller.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Even if set, the #GDestroyNotify function will never be called
        /// on the current contents of the array and the caller is
        /// responsible for freeing the array elements.
        /// </para>
        /// <para>
        /// An example of use:
        /// |[&lt;!-- language="C" --&gt;
        /// g_autoptr(GPtrArray) chunk_buffer = g_ptr_array_new_with_free_func (g_bytes_unref);
        /// </para>
        /// <para>
        /// // Some part of your application appends a number of chunks to the pointer array.
        /// g_ptr_array_add (chunk_buffer, g_bytes_new_static ("hello", 5));
        /// g_ptr_array_add (chunk_buffer, g_bytes_new_static ("world", 5));
        /// </para>
        /// <para>
        /// …
        /// </para>
        /// <para>
        /// // Periodically, the chunks need to be sent as an array-and-length to some
        /// // other part of the program.
        /// GBytes **chunks;
        /// gsize n_chunks;
        /// </para>
        /// <para>
        /// chunks = g_ptr_array_steal (chunk_buffer, &amp;n_chunks);
        /// for (gsize i = 0; i &lt; n_chunks; i++)
        ///   {
        ///     // Do something with each chunk here, and then free them, since
        ///     // g_ptr_array_steal() transfers ownership of all the elements and the
        ///     // array to the caller.
        ///     …
        /// </para>
        /// <para>
        ///     g_bytes_unref (chunks[i]);
        ///   }
        /// </para>
        /// <para>
        /// g_free (chunks);
        /// </para>
        /// <para>
        /// // After calling g_ptr_array_steal(), the pointer array can be reused for the
        /// // next set of chunks.
        /// g_assert (chunk_buffer-&gt;len == 0);
        /// ]|
        /// </para>
        /// </remarks>
        /// <param name="array">
        /// a #GPtrArray.
        /// </param>
        /// <param name="len">
        /// pointer to retrieve the number of
        ///    elements of the original array
        /// </param>
        /// <returns>
        /// the element data, which should be
        ///     freed using g_free().
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.64")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gpointer" type="gpointer*" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:full nullable:1 direction:in */
        private static extern System.IntPtr g_ptr_array_steal(
        /* <array name="GLib.PtrArray" type="GPtrArray*" zero-terminated="1" managed-name="GISharp.Lib.GLib.PtrArray" is-pointer="1">
*   <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" />
* </array> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.PtrArray.UnmanagedStruct* array,
        /* <type name="gsize" type="gsize*" managed-name="System.Int32" /> */
        /* direction:out caller-allocates:1 transfer-ownership:none optional:1 allow-none:1 */
        nuint* len);

        /// <summary>
        /// Removes the pointer at the given index from the pointer array.
        /// The following elements are moved down one place. The #GDestroyNotify for
        /// @array is *not* called on the removed element; ownership is transferred to
        /// the caller of this function.
        /// </summary>
        /// <param name="array">
        /// a #GPtrArray
        /// </param>
        /// <param name="index">
        /// the index of the pointer to steal
        /// </param>
        /// <returns>
        /// the pointer which was removed
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.58")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:full nullable:1 direction:in */
        private static extern System.IntPtr g_ptr_array_steal_index(
        /* <array name="GLib.PtrArray" type="GPtrArray*" zero-terminated="1" managed-name="GISharp.Lib.GLib.PtrArray" is-pointer="1">
*   <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" />
* </array> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.PtrArray.UnmanagedStruct* array,
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        uint index);

        /// <summary>
        /// Removes the pointer at the given index from the pointer array.
        /// The last element in the array is used to fill in the space, so
        /// this function does not preserve the order of the array. But it
        /// is faster than g_ptr_array_steal_index(). The #GDestroyNotify for @array is
        /// *not* called on the removed element; ownership is transferred to the caller
        /// of this function.
        /// </summary>
        /// <param name="array">
        /// a #GPtrArray
        /// </param>
        /// <param name="index">
        /// the index of the pointer to steal
        /// </param>
        /// <returns>
        /// the pointer which was removed
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.58")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:full nullable:1 direction:in */
        private static extern System.IntPtr g_ptr_array_steal_index_fast(
        /* <array name="GLib.PtrArray" type="GPtrArray*" zero-terminated="1" managed-name="GISharp.Lib.GLib.PtrArray" is-pointer="1">
*   <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" />
* </array> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.PtrArray.UnmanagedStruct* array,
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        uint index);
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="GType" type="GType" managed-name="GISharp.Runtime.GType" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Runtime.GType g_ptr_array_get_type();

        /// <summary>
        /// Atomically increments the reference count of @array by one.
        /// This function is thread-safe and may be called from any thread.
        /// </summary>
        /// <param name="array">
        /// a #GPtrArray
        /// </param>
        /// <returns>
        /// The passed in #GPtrArray
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.22")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <array name="GLib.PtrArray" type="GPtrArray*" zero-terminated="1" managed-name="GISharp.Lib.GLib.PtrArray" is-pointer="1">
*   <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" />
* </array> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GLib.PtrArray.UnmanagedStruct* g_ptr_array_ref(
        /* <array name="GLib.PtrArray" type="GPtrArray*" zero-terminated="1" managed-name="GISharp.Lib.GLib.PtrArray" is-pointer="1">
*   <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" />
* </array> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.PtrArray.UnmanagedStruct* array);

        /// <summary>
        /// Takes ownership of the unmanaged pointer without freeing it.
        /// The managed object can no longer be used (will throw disposed exception).
        /// </summary>
        public override System.IntPtr Take() => (System.IntPtr)g_ptr_array_ref((GISharp.Lib.GLib.PtrArray.UnmanagedStruct*)UnsafeHandle);

        /// <summary>
        /// Atomically decrements the reference count of @array by one. If the
        /// reference count drops to 0, the effect is the same as calling
        /// g_ptr_array_free() with @free_segment set to %TRUE. This function
        /// is thread-safe and may be called from any thread.
        /// </summary>
        /// <param name="array">
        /// A #GPtrArray
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.22")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_ptr_array_unref(
        /* <array name="GLib.PtrArray" type="GPtrArray*" zero-terminated="1" managed-name="GISharp.Lib.GLib.PtrArray" is-pointer="1">
*   <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" />
* </array> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.PtrArray.UnmanagedStruct* array);

        /// <inheritdoc/>
        protected override void Dispose(bool disposing)
        {
            if (handle != System.IntPtr.Zero)
            {
                g_ptr_array_unref((UnmanagedStruct*)handle);
            }

            base.Dispose(disposing);
        }
    }
}