// SPDX-License-Identifier: MIT
// ATTENTION: This file is automatically generated. Do not edit manually.
#nullable enable
namespace GISharp.Lib.GLib
{
    /// <summary>
    /// Specifies the type of the hash function which is passed to
    /// g_hash_table_new() when a #GHashTable is created.
    /// </summary>
    /// <remarks>
    /// <para>
    /// The function is passed a key and should return a #guint hash value.
    /// The functions g_direct_hash(), g_int_hash() and g_str_hash() provide
    /// hash functions which can be used when the key is a #gpointer, #gint*,
    /// and #gchar* respectively.
    /// </para>
    /// <para>
    /// g_direct_hash() is also the appropriate hash function for keys
    /// of the form `GINT_TO_POINTER (n)` (or similar macros).
    /// </para>
    /// <para>
    /// A good hash functions should produce
    /// hash values that are evenly distributed over a fairly large range.
    /// The modulus is taken with the hash table size (a prime number) to
    /// find the 'bucket' to place each key into. The function should also
    /// be very fast, since it is called for each key lookup.
    /// </para>
    /// <para>
    /// Note that the hash functions provided by GLib have these qualities,
    /// but are not particularly robust against manufactured keys that
    /// cause hash collisions. Therefore, you should consider choosing
    /// a more secure hash function when using a GHashTable with keys
    /// that originate in untrusted data (such as HTTP requests).
    /// Using g_str_hash() in that situation might make your application
    /// vulnerable to
    /// [Algorithmic Complexity Attacks](https://lwn.net/Articles/474912/).
    /// </para>
    /// <para>
    /// The key to choosing a good hash is unpredictability.  Even
    /// cryptographic hashes are very easy to find collisions for when the
    /// remainder is taken modulo a somewhat predictable prime number.  There
    /// must be an element of randomness that an attacker is unable to guess.
    /// </para>
    /// </remarks>
    [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
    [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
    /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
    /* transfer-ownership:none direction:in */
    public unsafe delegate uint UnmanagedHashFunc(
    /* <type name="gpointer" type="gconstpointer" managed-name="System.IntPtr" is-pointer="1" /> */
    /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
    System.IntPtr key);

    /// <include file="HashFunc.xmldoc" path="declaration/member[@name='HashFunc']/*" />
    public delegate uint HashFunc(System.IntPtr key);

    /// <summary>
    /// Class for marshalling <see cref="HashFunc"/> methods.
    /// </summary>
    public static unsafe class HashFuncMarshal
    {
        /// <summary>
        /// Marshals an unmanaged pointer to a <see cref="HashFunc"/>.
        /// </summary>
        public static GISharp.Lib.GLib.HashFunc FromPointer(delegate* unmanaged[Cdecl]<System.IntPtr, uint> callback_, System.IntPtr userData_)
        {
            uint managedCallback(System.IntPtr key)
            {
                var key_ = (System.IntPtr)key;
                var ret_ = callback_(key_);
                GISharp.Runtime.GMarshal.PopUnhandledException();
                var ret = (uint)ret_;
                return ret;
            }

            return managedCallback;
        }
    }
}