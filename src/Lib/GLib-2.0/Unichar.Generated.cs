// SPDX-License-Identifier: MIT
// ATTENTION: This file is automatically generated. Do not edit manually.
#nullable enable
namespace GISharp.Lib.GLib
{
    /// <include file="Unichar.xmldoc" path="declaration/member[@name='Unichar']/*" />
    public static unsafe partial class Unichar
    {
        /// <include file="Unichar.xmldoc" path="declaration/member[@name='Unichar.maxDecompositionLength']/*" />
        [GISharp.Runtime.SinceAttribute("2.32")]
        private const int maxDecompositionLength = 18;

        /// <summary>
        /// Determines the break type of @c. @c should be a Unicode character
        /// (to derive a character from UTF-8 encoded text, use
        /// g_utf8_get_char()). The break type is used to find word and line
        /// breaks ("text boundaries"), Pango implements the Unicode boundary
        /// resolution algorithms and normally you would use a function such
        /// as pango_break() instead of caring about break types yourself.
        /// </summary>
        /// <param name="c">
        /// a Unicode character
        /// </param>
        /// <returns>
        /// the break type of @c
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="UnicodeBreakType" type="GUnicodeBreakType" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GLib.UnicodeBreakType g_unichar_break_type(
        /* <type name="gunichar" type="gunichar" /> */
        /* transfer-ownership:none direction:in */
        uint c);
        static partial void CheckBreakTypeArgs(this System.Text.Rune c);

        /// <include file="Unichar.xmldoc" path="declaration/member[@name='Unichar.BreakType(System.Text.Rune)']/*" />
        public static GISharp.Lib.GLib.UnicodeBreakType BreakType(this System.Text.Rune c)
        {
            CheckBreakTypeArgs(c);
            var c_ = (uint)c.Value;
            var ret_ = g_unichar_break_type(c_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = (GISharp.Lib.GLib.UnicodeBreakType)ret_;
            return ret;
        }

        /// <summary>
        /// Determines the canonical combining class of a Unicode character.
        /// </summary>
        /// <param name="uc">
        /// a Unicode character
        /// </param>
        /// <returns>
        /// the combining class of the character
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.14")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gint" type="gint" /> */
        /* transfer-ownership:none direction:in */
        private static extern int g_unichar_combining_class(
        /* <type name="gunichar" type="gunichar" /> */
        /* transfer-ownership:none direction:in */
        uint uc);
        static partial void CheckCombiningClassArgs(this System.Text.Rune uc);

        /// <include file="Unichar.xmldoc" path="declaration/member[@name='Unichar.CombiningClass(System.Text.Rune)']/*" />
        [GISharp.Runtime.SinceAttribute("2.14")]
        public static int CombiningClass(this System.Text.Rune uc)
        {
            CheckCombiningClassArgs(uc);
            var uc_ = (uint)uc.Value;
            var ret_ = g_unichar_combining_class(uc_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = (int)ret_;
            return ret;
        }

        /// <summary>
        /// Performs a single composition step of the
        /// Unicode canonical composition algorithm.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This function includes algorithmic Hangul Jamo composition,
        /// but it is not exactly the inverse of g_unichar_decompose().
        /// No composition can have either of @a or @b equal to zero.
        /// To be precise, this function composes if and only if
        /// there exists a Primary Composite P which is canonically
        /// equivalent to the sequence &lt;@a,@b&gt;.  See the Unicode
        /// Standard for the definition of Primary Composite.
        /// </para>
        /// <para>
        /// If @a and @b do not compose a new character, @ch is set to zero.
        /// </para>
        /// <para>
        /// See
        /// [UAX#15](http://unicode.org/reports/tr15/)
        /// for details.
        /// </para>
        /// </remarks>
        /// <param name="a">
        /// a Unicode character
        /// </param>
        /// <param name="b">
        /// a Unicode character
        /// </param>
        /// <param name="ch">
        /// return location for the composed character
        /// </param>
        /// <returns>
        /// %TRUE if the characters could be composed
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.30")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_unichar_compose(
        /* <type name="gunichar" type="gunichar" /> */
        /* transfer-ownership:none direction:in */
        uint a,
        /* <type name="gunichar" type="gunichar" /> */
        /* transfer-ownership:none direction:in */
        uint b,
        /* <type name="gunichar" type="gunichar*" /> */
        /* direction:out caller-allocates:0 transfer-ownership:full */
        uint* ch);
        static partial void CheckTryComposeArgs(this System.Text.Rune a, System.Text.Rune b);

        /// <include file="Unichar.xmldoc" path="declaration/member[@name='Unichar.TryCompose(System.Text.Rune,System.Text.Rune,System.Text.Rune)']/*" />
        [GISharp.Runtime.SinceAttribute("2.30")]
        public static bool TryCompose(this System.Text.Rune a, System.Text.Rune b, out System.Text.Rune ch)
        {
            CheckTryComposeArgs(a, b);
            var a_ = (uint)a.Value;
            var b_ = (uint)b.Value;
            uint ch_;
            var ret_ = g_unichar_compose(a_,b_,&ch_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            ch = (System.Text.Rune)ch_;
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Performs a single decomposition step of the
        /// Unicode canonical decomposition algorithm.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This function does not include compatibility
        /// decompositions. It does, however, include algorithmic
        /// Hangul Jamo decomposition, as well as 'singleton'
        /// decompositions which replace a character by a single
        /// other character. In the case of singletons *@b will
        /// be set to zero.
        /// </para>
        /// <para>
        /// If @ch is not decomposable, *@a is set to @ch and *@b
        /// is set to zero.
        /// </para>
        /// <para>
        /// Note that the way Unicode decomposition pairs are
        /// defined, it is guaranteed that @b would not decompose
        /// further, but @a may itself decompose.  To get the full
        /// canonical decomposition for @ch, one would need to
        /// recursively call this function on @a.  Or use
        /// g_unichar_fully_decompose().
        /// </para>
        /// <para>
        /// See
        /// [UAX#15](http://unicode.org/reports/tr15/)
        /// for details.
        /// </para>
        /// </remarks>
        /// <param name="ch">
        /// a Unicode character
        /// </param>
        /// <param name="a">
        /// return location for the first component of @ch
        /// </param>
        /// <param name="b">
        /// return location for the second component of @ch
        /// </param>
        /// <returns>
        /// %TRUE if the character could be decomposed
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.30")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_unichar_decompose(
        /* <type name="gunichar" type="gunichar" /> */
        /* transfer-ownership:none direction:in */
        uint ch,
        /* <type name="gunichar" type="gunichar*" /> */
        /* direction:out caller-allocates:0 transfer-ownership:full */
        uint* a,
        /* <type name="gunichar" type="gunichar*" /> */
        /* direction:out caller-allocates:0 transfer-ownership:full */
        uint* b);
        static partial void CheckTryDecomposeArgs(this System.Text.Rune ch);

        /// <include file="Unichar.xmldoc" path="declaration/member[@name='Unichar.TryDecompose(System.Text.Rune,System.Text.Rune,System.Text.Rune)']/*" />
        [GISharp.Runtime.SinceAttribute("2.30")]
        public static bool TryDecompose(this System.Text.Rune ch, out System.Text.Rune a, out System.Text.Rune b)
        {
            CheckTryDecomposeArgs(ch);
            var ch_ = (uint)ch.Value;
            uint a_;
            uint b_;
            var ret_ = g_unichar_decompose(ch_,&a_,&b_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            a = (System.Text.Rune)a_;
            b = (System.Text.Rune)b_;
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Determines the numeric value of a character as a decimal
        /// digit.
        /// </summary>
        /// <param name="c">
        /// a Unicode character
        /// </param>
        /// <returns>
        /// If @c is a decimal digit (according to
        /// g_unichar_isdigit()), its numeric value. Otherwise, -1.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gint" type="gint" /> */
        /* transfer-ownership:none direction:in */
        private static extern int g_unichar_digit_value(
        /* <type name="gunichar" type="gunichar" /> */
        /* transfer-ownership:none direction:in */
        uint c);
        static partial void CheckDigitValueArgs(this System.Text.Rune c);

        /// <include file="Unichar.xmldoc" path="declaration/member[@name='Unichar.DigitValue(System.Text.Rune)']/*" />
        public static int DigitValue(this System.Text.Rune c)
        {
            CheckDigitValueArgs(c);
            var c_ = (uint)c.Value;
            var ret_ = g_unichar_digit_value(c_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = (int)ret_;
            return ret;
        }

        /// <summary>
        /// Computes the canonical or compatibility decomposition of a
        /// Unicode character.  For compatibility decomposition,
        /// pass %TRUE for @compat; for canonical decomposition
        /// pass %FALSE for @compat.
        /// </summary>
        /// <remarks>
        /// <para>
        /// The decomposed sequence is placed in @result.  Only up to
        /// @result_len characters are written into @result.  The length
        /// of the full decomposition (irrespective of @result_len) is
        /// returned by the function.  For canonical decomposition,
        /// currently all decompositions are of length at most 4, but
        /// this may change in the future (very unlikely though).
        /// At any rate, Unicode does guarantee that a buffer of length
        /// 18 is always enough for both compatibility and canonical
        /// decompositions, so that is the size recommended. This is provided
        /// as %G_UNICHAR_MAX_DECOMPOSITION_LENGTH.
        /// </para>
        /// <para>
        /// See
        /// [UAX#15](http://unicode.org/reports/tr15/)
        /// for details.
        /// </para>
        /// </remarks>
        /// <param name="ch">
        /// a Unicode character.
        /// </param>
        /// <param name="compat">
        /// whether perform canonical or compatibility decomposition
        /// </param>
        /// <param name="result">
        /// location to store decomposed result, or %NULL
        /// </param>
        /// <param name="resultLen">
        /// length of @result
        /// </param>
        /// <returns>
        /// the length of the full decomposition.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.30")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gsize" type="gsize" /> */
        /* transfer-ownership:none direction:in */
        private static extern nuint g_unichar_fully_decompose(
        /* <type name="gunichar" type="gunichar" /> */
        /* transfer-ownership:none direction:in */
        uint ch,
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.Boolean compat,
        /* <array length="2" zero-terminated="0" type="gunichar*" is-pointer="1">
*   <type name="gunichar" type="gunichar" />
* </array> */
        /* direction:out caller-allocates:1 transfer-ownership:none optional:1 allow-none:1 */
        uint* result,
        /* <type name="gsize" type="gsize" /> */
        /* transfer-ownership:none direction:in */
        nuint resultLen);

        /// <summary>
        /// In Unicode, some characters are "mirrored". This means that their
        /// images are mirrored horizontally in text that is laid out from right
        /// to left. For instance, "(" would become its mirror image, ")", in
        /// right-to-left text.
        /// </summary>
        /// <remarks>
        /// <para>
        /// If @ch has the Unicode mirrored property and there is another unicode
        /// character that typically has a glyph that is the mirror image of @ch's
        /// glyph and @mirrored_ch is set, it puts that character in the address
        /// pointed to by @mirrored_ch.  Otherwise the original character is put.
        /// </para>
        /// </remarks>
        /// <param name="ch">
        /// a Unicode character
        /// </param>
        /// <param name="mirroredCh">
        /// location to store the mirrored character
        /// </param>
        /// <returns>
        /// %TRUE if @ch has a mirrored character, %FALSE otherwise
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.4")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_unichar_get_mirror_char(
        /* <type name="gunichar" type="gunichar" /> */
        /* transfer-ownership:none direction:in */
        uint ch,
        /* <type name="gunichar" type="gunichar*" /> */
        /* transfer-ownership:none direction:out */
        uint* mirroredCh);
        static partial void CheckTryGetMirrorCharArgs(this System.Text.Rune ch);

        /// <include file="Unichar.xmldoc" path="declaration/member[@name='Unichar.TryGetMirrorChar(System.Text.Rune,System.Text.Rune)']/*" />
        [GISharp.Runtime.SinceAttribute("2.4")]
        public static bool TryGetMirrorChar(this System.Text.Rune ch, out System.Text.Rune mirroredCh)
        {
            CheckTryGetMirrorCharArgs(ch);
            var ch_ = (uint)ch.Value;
            uint mirroredCh_;
            var ret_ = g_unichar_get_mirror_char(ch_,&mirroredCh_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            mirroredCh = (System.Text.Rune)mirroredCh_;
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Looks up the #GUnicodeScript for a particular character (as defined
        /// by Unicode Standard Annex \#24). No check is made for @ch being a
        /// valid Unicode character; if you pass in invalid character, the
        /// result is undefined.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This function is equivalent to pango_script_for_unichar() and the
        /// two are interchangeable.
        /// </para>
        /// </remarks>
        /// <param name="ch">
        /// a Unicode character
        /// </param>
        /// <returns>
        /// the #GUnicodeScript for the character.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.14")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="UnicodeScript" type="GUnicodeScript" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GLib.UnicodeScript g_unichar_get_script(
        /* <type name="gunichar" type="gunichar" /> */
        /* transfer-ownership:none direction:in */
        uint ch);
        static partial void CheckGetScriptArgs(this System.Text.Rune ch);

        /// <include file="Unichar.xmldoc" path="declaration/member[@name='Unichar.GetScript(System.Text.Rune)']/*" />
        [GISharp.Runtime.SinceAttribute("2.14")]
        public static GISharp.Lib.GLib.UnicodeScript GetScript(this System.Text.Rune ch)
        {
            CheckGetScriptArgs(ch);
            var ch_ = (uint)ch.Value;
            var ret_ = g_unichar_get_script(ch_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = (GISharp.Lib.GLib.UnicodeScript)ret_;
            return ret;
        }

        /// <summary>
        /// Determines whether a character is alphanumeric.
        /// Given some UTF-8 text, obtain a character value
        /// with g_utf8_get_char().
        /// </summary>
        /// <param name="c">
        /// a Unicode character
        /// </param>
        /// <returns>
        /// %TRUE if @c is an alphanumeric character
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_unichar_isalnum(
        /* <type name="gunichar" type="gunichar" /> */
        /* transfer-ownership:none direction:in */
        uint c);
        static partial void CheckIsAlphaNumericArgs(this System.Text.Rune c);

        /// <include file="Unichar.xmldoc" path="declaration/member[@name='Unichar.IsAlphaNumeric(System.Text.Rune)']/*" />
        public static bool IsAlphaNumeric(this System.Text.Rune c)
        {
            CheckIsAlphaNumericArgs(c);
            var c_ = (uint)c.Value;
            var ret_ = g_unichar_isalnum(c_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Determines whether a character is alphabetic (i.e. a letter).
        /// Given some UTF-8 text, obtain a character value with
        /// g_utf8_get_char().
        /// </summary>
        /// <param name="c">
        /// a Unicode character
        /// </param>
        /// <returns>
        /// %TRUE if @c is an alphabetic character
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_unichar_isalpha(
        /* <type name="gunichar" type="gunichar" /> */
        /* transfer-ownership:none direction:in */
        uint c);
        static partial void CheckIsAlphaArgs(this System.Text.Rune c);

        /// <include file="Unichar.xmldoc" path="declaration/member[@name='Unichar.IsAlpha(System.Text.Rune)']/*" />
        public static bool IsAlpha(this System.Text.Rune c)
        {
            CheckIsAlphaArgs(c);
            var c_ = (uint)c.Value;
            var ret_ = g_unichar_isalpha(c_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Determines whether a character is a control character.
        /// Given some UTF-8 text, obtain a character value with
        /// g_utf8_get_char().
        /// </summary>
        /// <param name="c">
        /// a Unicode character
        /// </param>
        /// <returns>
        /// %TRUE if @c is a control character
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_unichar_iscntrl(
        /* <type name="gunichar" type="gunichar" /> */
        /* transfer-ownership:none direction:in */
        uint c);
        static partial void CheckIsControlArgs(this System.Text.Rune c);

        /// <include file="Unichar.xmldoc" path="declaration/member[@name='Unichar.IsControl(System.Text.Rune)']/*" />
        public static bool IsControl(this System.Text.Rune c)
        {
            CheckIsControlArgs(c);
            var c_ = (uint)c.Value;
            var ret_ = g_unichar_iscntrl(c_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Determines if a given character is assigned in the Unicode
        /// standard.
        /// </summary>
        /// <param name="c">
        /// a Unicode character
        /// </param>
        /// <returns>
        /// %TRUE if the character has an assigned value
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_unichar_isdefined(
        /* <type name="gunichar" type="gunichar" /> */
        /* transfer-ownership:none direction:in */
        uint c);
        static partial void CheckIsDefinedArgs(this System.Text.Rune c);

        /// <include file="Unichar.xmldoc" path="declaration/member[@name='Unichar.IsDefined(System.Text.Rune)']/*" />
        public static bool IsDefined(this System.Text.Rune c)
        {
            CheckIsDefinedArgs(c);
            var c_ = (uint)c.Value;
            var ret_ = g_unichar_isdefined(c_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Determines whether a character is numeric (i.e. a digit).  This
        /// covers ASCII 0-9 and also digits in other languages/scripts.  Given
        /// some UTF-8 text, obtain a character value with g_utf8_get_char().
        /// </summary>
        /// <param name="c">
        /// a Unicode character
        /// </param>
        /// <returns>
        /// %TRUE if @c is a digit
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_unichar_isdigit(
        /* <type name="gunichar" type="gunichar" /> */
        /* transfer-ownership:none direction:in */
        uint c);
        static partial void CheckIsDigitArgs(this System.Text.Rune c);

        /// <include file="Unichar.xmldoc" path="declaration/member[@name='Unichar.IsDigit(System.Text.Rune)']/*" />
        public static bool IsDigit(this System.Text.Rune c)
        {
            CheckIsDigitArgs(c);
            var c_ = (uint)c.Value;
            var ret_ = g_unichar_isdigit(c_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Determines whether a character is printable and not a space
        /// (returns %FALSE for control characters, format characters, and
        /// spaces). g_unichar_isprint() is similar, but returns %TRUE for
        /// spaces. Given some UTF-8 text, obtain a character value with
        /// g_utf8_get_char().
        /// </summary>
        /// <param name="c">
        /// a Unicode character
        /// </param>
        /// <returns>
        /// %TRUE if @c is printable unless it's a space
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_unichar_isgraph(
        /* <type name="gunichar" type="gunichar" /> */
        /* transfer-ownership:none direction:in */
        uint c);
        static partial void CheckIsGraphArgs(this System.Text.Rune c);

        /// <include file="Unichar.xmldoc" path="declaration/member[@name='Unichar.IsGraph(System.Text.Rune)']/*" />
        public static bool IsGraph(this System.Text.Rune c)
        {
            CheckIsGraphArgs(c);
            var c_ = (uint)c.Value;
            var ret_ = g_unichar_isgraph(c_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Determines whether a character is a lowercase letter.
        /// Given some UTF-8 text, obtain a character value with
        /// g_utf8_get_char().
        /// </summary>
        /// <param name="c">
        /// a Unicode character
        /// </param>
        /// <returns>
        /// %TRUE if @c is a lowercase letter
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_unichar_islower(
        /* <type name="gunichar" type="gunichar" /> */
        /* transfer-ownership:none direction:in */
        uint c);
        static partial void CheckIsLowerArgs(this System.Text.Rune c);

        /// <include file="Unichar.xmldoc" path="declaration/member[@name='Unichar.IsLower(System.Text.Rune)']/*" />
        public static bool IsLower(this System.Text.Rune c)
        {
            CheckIsLowerArgs(c);
            var c_ = (uint)c.Value;
            var ret_ = g_unichar_islower(c_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Determines whether a character is a mark (non-spacing mark,
        /// combining mark, or enclosing mark in Unicode speak).
        /// Given some UTF-8 text, obtain a character value
        /// with g_utf8_get_char().
        /// </summary>
        /// <remarks>
        /// <para>
        /// Note: in most cases where isalpha characters are allowed,
        /// ismark characters should be allowed to as they are essential
        /// for writing most European languages as well as many non-Latin
        /// scripts.
        /// </para>
        /// </remarks>
        /// <param name="c">
        /// a Unicode character
        /// </param>
        /// <returns>
        /// %TRUE if @c is a mark character
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.14")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_unichar_ismark(
        /* <type name="gunichar" type="gunichar" /> */
        /* transfer-ownership:none direction:in */
        uint c);
        static partial void CheckIsMarkArgs(this System.Text.Rune c);

        /// <include file="Unichar.xmldoc" path="declaration/member[@name='Unichar.IsMark(System.Text.Rune)']/*" />
        [GISharp.Runtime.SinceAttribute("2.14")]
        public static bool IsMark(this System.Text.Rune c)
        {
            CheckIsMarkArgs(c);
            var c_ = (uint)c.Value;
            var ret_ = g_unichar_ismark(c_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Determines whether a character is printable.
        /// Unlike g_unichar_isgraph(), returns %TRUE for spaces.
        /// Given some UTF-8 text, obtain a character value with
        /// g_utf8_get_char().
        /// </summary>
        /// <param name="c">
        /// a Unicode character
        /// </param>
        /// <returns>
        /// %TRUE if @c is printable
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_unichar_isprint(
        /* <type name="gunichar" type="gunichar" /> */
        /* transfer-ownership:none direction:in */
        uint c);
        static partial void CheckIsPrintableArgs(this System.Text.Rune c);

        /// <include file="Unichar.xmldoc" path="declaration/member[@name='Unichar.IsPrintable(System.Text.Rune)']/*" />
        public static bool IsPrintable(this System.Text.Rune c)
        {
            CheckIsPrintableArgs(c);
            var c_ = (uint)c.Value;
            var ret_ = g_unichar_isprint(c_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Determines whether a character is punctuation or a symbol.
        /// Given some UTF-8 text, obtain a character value with
        /// g_utf8_get_char().
        /// </summary>
        /// <param name="c">
        /// a Unicode character
        /// </param>
        /// <returns>
        /// %TRUE if @c is a punctuation or symbol character
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_unichar_ispunct(
        /* <type name="gunichar" type="gunichar" /> */
        /* transfer-ownership:none direction:in */
        uint c);
        static partial void CheckIsPunctuationArgs(this System.Text.Rune c);

        /// <include file="Unichar.xmldoc" path="declaration/member[@name='Unichar.IsPunctuation(System.Text.Rune)']/*" />
        public static bool IsPunctuation(this System.Text.Rune c)
        {
            CheckIsPunctuationArgs(c);
            var c_ = (uint)c.Value;
            var ret_ = g_unichar_ispunct(c_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Determines whether a character is a space, tab, or line separator
        /// (newline, carriage return, etc.).  Given some UTF-8 text, obtain a
        /// character value with g_utf8_get_char().
        /// </summary>
        /// <remarks>
        /// <para>
        /// (Note: don't use this to do word breaking; you have to use
        /// Pango or equivalent to get word breaking right, the algorithm
        /// is fairly complex.)
        /// </para>
        /// </remarks>
        /// <param name="c">
        /// a Unicode character
        /// </param>
        /// <returns>
        /// %TRUE if @c is a space character
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_unichar_isspace(
        /* <type name="gunichar" type="gunichar" /> */
        /* transfer-ownership:none direction:in */
        uint c);
        static partial void CheckIsSpaceArgs(this System.Text.Rune c);

        /// <include file="Unichar.xmldoc" path="declaration/member[@name='Unichar.IsSpace(System.Text.Rune)']/*" />
        public static bool IsSpace(this System.Text.Rune c)
        {
            CheckIsSpaceArgs(c);
            var c_ = (uint)c.Value;
            var ret_ = g_unichar_isspace(c_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Determines if a character is titlecase. Some characters in
        /// Unicode which are composites, such as the DZ digraph
        /// have three case variants instead of just two. The titlecase
        /// form is used at the beginning of a word where only the
        /// first letter is capitalized. The titlecase form of the DZ
        /// digraph is U+01F2 LATIN CAPITAL LETTTER D WITH SMALL LETTER Z.
        /// </summary>
        /// <param name="c">
        /// a Unicode character
        /// </param>
        /// <returns>
        /// %TRUE if the character is titlecase
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_unichar_istitle(
        /* <type name="gunichar" type="gunichar" /> */
        /* transfer-ownership:none direction:in */
        uint c);
        static partial void CheckIsTitleArgs(this System.Text.Rune c);

        /// <include file="Unichar.xmldoc" path="declaration/member[@name='Unichar.IsTitle(System.Text.Rune)']/*" />
        public static bool IsTitle(this System.Text.Rune c)
        {
            CheckIsTitleArgs(c);
            var c_ = (uint)c.Value;
            var ret_ = g_unichar_istitle(c_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Determines if a character is uppercase.
        /// </summary>
        /// <param name="c">
        /// a Unicode character
        /// </param>
        /// <returns>
        /// %TRUE if @c is an uppercase character
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_unichar_isupper(
        /* <type name="gunichar" type="gunichar" /> */
        /* transfer-ownership:none direction:in */
        uint c);
        static partial void CheckIsUpperArgs(this System.Text.Rune c);

        /// <include file="Unichar.xmldoc" path="declaration/member[@name='Unichar.IsUpper(System.Text.Rune)']/*" />
        public static bool IsUpper(this System.Text.Rune c)
        {
            CheckIsUpperArgs(c);
            var c_ = (uint)c.Value;
            var ret_ = g_unichar_isupper(c_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Determines if a character is typically rendered in a double-width
        /// cell.
        /// </summary>
        /// <param name="c">
        /// a Unicode character
        /// </param>
        /// <returns>
        /// %TRUE if the character is wide
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_unichar_iswide(
        /* <type name="gunichar" type="gunichar" /> */
        /* transfer-ownership:none direction:in */
        uint c);
        static partial void CheckIsWideArgs(this System.Text.Rune c);

        /// <include file="Unichar.xmldoc" path="declaration/member[@name='Unichar.IsWide(System.Text.Rune)']/*" />
        public static bool IsWide(this System.Text.Rune c)
        {
            CheckIsWideArgs(c);
            var c_ = (uint)c.Value;
            var ret_ = g_unichar_iswide(c_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Determines if a character is typically rendered in a double-width
        /// cell under legacy East Asian locales.  If a character is wide according to
        /// g_unichar_iswide(), then it is also reported wide with this function, but
        /// the converse is not necessarily true. See the
        /// [Unicode Standard Annex #11](http://www.unicode.org/reports/tr11/)
        /// for details.
        /// </summary>
        /// <remarks>
        /// <para>
        /// If a character passes the g_unichar_iswide() test then it will also pass
        /// this test, but not the other way around.  Note that some characters may
        /// pass both this test and g_unichar_iszerowidth().
        /// </para>
        /// </remarks>
        /// <param name="c">
        /// a Unicode character
        /// </param>
        /// <returns>
        /// %TRUE if the character is wide in legacy East Asian locales
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.12")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_unichar_iswide_cjk(
        /* <type name="gunichar" type="gunichar" /> */
        /* transfer-ownership:none direction:in */
        uint c);
        static partial void CheckIsWideCjkArgs(this System.Text.Rune c);

        /// <include file="Unichar.xmldoc" path="declaration/member[@name='Unichar.IsWideCjk(System.Text.Rune)']/*" />
        [GISharp.Runtime.SinceAttribute("2.12")]
        public static bool IsWideCjk(this System.Text.Rune c)
        {
            CheckIsWideCjkArgs(c);
            var c_ = (uint)c.Value;
            var ret_ = g_unichar_iswide_cjk(c_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Determines if a character is a hexadecimal digit.
        /// </summary>
        /// <param name="c">
        /// a Unicode character.
        /// </param>
        /// <returns>
        /// %TRUE if the character is a hexadecimal digit
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_unichar_isxdigit(
        /* <type name="gunichar" type="gunichar" /> */
        /* transfer-ownership:none direction:in */
        uint c);
        static partial void CheckIsHexDigitArgs(this System.Text.Rune c);

        /// <include file="Unichar.xmldoc" path="declaration/member[@name='Unichar.IsHexDigit(System.Text.Rune)']/*" />
        public static bool IsHexDigit(this System.Text.Rune c)
        {
            CheckIsHexDigitArgs(c);
            var c_ = (uint)c.Value;
            var ret_ = g_unichar_isxdigit(c_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Determines if a given character typically takes zero width when rendered.
        /// The return value is %TRUE for all non-spacing and enclosing marks
        /// (e.g., combining accents), format characters, zero-width
        /// space, but not U+00AD SOFT HYPHEN.
        /// </summary>
        /// <remarks>
        /// <para>
        /// A typical use of this function is with one of g_unichar_iswide() or
        /// g_unichar_iswide_cjk() to determine the number of cells a string occupies
        /// when displayed on a grid display (terminals).  However, note that not all
        /// terminals support zero-width rendering of zero-width marks.
        /// </para>
        /// </remarks>
        /// <param name="c">
        /// a Unicode character
        /// </param>
        /// <returns>
        /// %TRUE if the character has zero width
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.14")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_unichar_iszerowidth(
        /* <type name="gunichar" type="gunichar" /> */
        /* transfer-ownership:none direction:in */
        uint c);
        static partial void CheckIsZeroWidthArgs(this System.Text.Rune c);

        /// <include file="Unichar.xmldoc" path="declaration/member[@name='Unichar.IsZeroWidth(System.Text.Rune)']/*" />
        [GISharp.Runtime.SinceAttribute("2.14")]
        public static bool IsZeroWidth(this System.Text.Rune c)
        {
            CheckIsZeroWidthArgs(c);
            var c_ = (uint)c.Value;
            var ret_ = g_unichar_iszerowidth(c_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Converts a single character to UTF-8.
        /// </summary>
        /// <param name="c">
        /// a Unicode character code
        /// </param>
        /// <param name="outbuf">
        /// output buffer, must have at
        ///       least 6 bytes of space. If %NULL, the length will be computed and
        ///       returned and nothing will be written to @outbuf.
        /// </param>
        /// <returns>
        /// number of bytes written
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gint" type="gint" /> */
        /* transfer-ownership:none direction:in */
        private static extern int g_unichar_to_utf8(
        /* <type name="gunichar" type="gunichar" /> */
        /* transfer-ownership:none direction:in */
        uint c,
        /* <type name="utf8" type="gchar*" is-pointer="1" /> */
        /* direction:out caller-allocates:1 transfer-ownership:none optional:1 allow-none:1 */
        byte* outbuf);

        /// <summary>
        /// Converts a character to lower case.
        /// </summary>
        /// <param name="c">
        /// a Unicode character.
        /// </param>
        /// <returns>
        /// the result of converting @c to lower case.
        ///               If @c is not an upperlower or titlecase character,
        ///               or has no lowercase equivalent @c is returned unchanged.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gunichar" type="gunichar" /> */
        /* transfer-ownership:none direction:in */
        private static extern uint g_unichar_tolower(
        /* <type name="gunichar" type="gunichar" /> */
        /* transfer-ownership:none direction:in */
        uint c);
        static partial void CheckToLowerArgs(this System.Text.Rune c);

        /// <include file="Unichar.xmldoc" path="declaration/member[@name='Unichar.ToLower(System.Text.Rune)']/*" />
        public static System.Text.Rune ToLower(this System.Text.Rune c)
        {
            CheckToLowerArgs(c);
            var c_ = (uint)c.Value;
            var ret_ = g_unichar_tolower(c_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = (System.Text.Rune)ret_;
            return ret;
        }

        /// <summary>
        /// Converts a character to the titlecase.
        /// </summary>
        /// <param name="c">
        /// a Unicode character
        /// </param>
        /// <returns>
        /// the result of converting @c to titlecase.
        ///               If @c is not an uppercase or lowercase character,
        ///               @c is returned unchanged.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gunichar" type="gunichar" /> */
        /* transfer-ownership:none direction:in */
        private static extern uint g_unichar_totitle(
        /* <type name="gunichar" type="gunichar" /> */
        /* transfer-ownership:none direction:in */
        uint c);
        static partial void CheckToTitleArgs(this System.Text.Rune c);

        /// <include file="Unichar.xmldoc" path="declaration/member[@name='Unichar.ToTitle(System.Text.Rune)']/*" />
        public static System.Text.Rune ToTitle(this System.Text.Rune c)
        {
            CheckToTitleArgs(c);
            var c_ = (uint)c.Value;
            var ret_ = g_unichar_totitle(c_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = (System.Text.Rune)ret_;
            return ret;
        }

        /// <summary>
        /// Converts a character to uppercase.
        /// </summary>
        /// <param name="c">
        /// a Unicode character
        /// </param>
        /// <returns>
        /// the result of converting @c to uppercase.
        ///               If @c is not a lowercase or titlecase character,
        ///               or has no upper case equivalent @c is returned unchanged.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gunichar" type="gunichar" /> */
        /* transfer-ownership:none direction:in */
        private static extern uint g_unichar_toupper(
        /* <type name="gunichar" type="gunichar" /> */
        /* transfer-ownership:none direction:in */
        uint c);
        static partial void CheckToUpperArgs(this System.Text.Rune c);

        /// <include file="Unichar.xmldoc" path="declaration/member[@name='Unichar.ToUpper(System.Text.Rune)']/*" />
        public static System.Text.Rune ToUpper(this System.Text.Rune c)
        {
            CheckToUpperArgs(c);
            var c_ = (uint)c.Value;
            var ret_ = g_unichar_toupper(c_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = (System.Text.Rune)ret_;
            return ret;
        }

        /// <summary>
        /// Classifies a Unicode character by type.
        /// </summary>
        /// <param name="c">
        /// a Unicode character
        /// </param>
        /// <returns>
        /// the type of the character.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="UnicodeType" type="GUnicodeType" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GLib.UnicodeType g_unichar_type(
        /* <type name="gunichar" type="gunichar" /> */
        /* transfer-ownership:none direction:in */
        uint c);
        static partial void CheckTypeArgs(this System.Text.Rune c);

        /// <include file="Unichar.xmldoc" path="declaration/member[@name='Unichar.Type(System.Text.Rune)']/*" />
        public static GISharp.Lib.GLib.UnicodeType Type(this System.Text.Rune c)
        {
            CheckTypeArgs(c);
            var c_ = (uint)c.Value;
            var ret_ = g_unichar_type(c_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = (GISharp.Lib.GLib.UnicodeType)ret_;
            return ret;
        }

        /// <summary>
        /// Checks whether @ch is a valid Unicode character. Some possible
        /// integer values of @ch will not be valid. 0 is considered a valid
        /// character, though it's normally a string terminator.
        /// </summary>
        /// <param name="ch">
        /// a Unicode character
        /// </param>
        /// <returns>
        /// %TRUE if @ch is a valid Unicode character
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_unichar_validate(
        /* <type name="gunichar" type="gunichar" /> */
        /* transfer-ownership:none direction:in */
        uint ch);
        static partial void CheckValidateArgs(this System.Text.Rune ch);

        /// <include file="Unichar.xmldoc" path="declaration/member[@name='Unichar.Validate(System.Text.Rune)']/*" />
        public static bool Validate(this System.Text.Rune ch)
        {
            CheckValidateArgs(ch);
            var ch_ = (uint)ch.Value;
            var ret_ = g_unichar_validate(ch_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Determines the numeric value of a character as a hexadecimal
        /// digit.
        /// </summary>
        /// <param name="c">
        /// a Unicode character
        /// </param>
        /// <returns>
        /// If @c is a hex digit (according to
        /// g_unichar_isxdigit()), its numeric value. Otherwise, -1.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gint" type="gint" /> */
        /* transfer-ownership:none direction:in */
        private static extern int g_unichar_xdigit_value(
        /* <type name="gunichar" type="gunichar" /> */
        /* transfer-ownership:none direction:in */
        uint c);
        static partial void CheckHexDigitValueArgs(this System.Text.Rune c);

        /// <include file="Unichar.xmldoc" path="declaration/member[@name='Unichar.HexDigitValue(System.Text.Rune)']/*" />
        public static int HexDigitValue(this System.Text.Rune c)
        {
            CheckHexDigitValueArgs(c);
            var c_ = (uint)c.Value;
            var ret_ = g_unichar_xdigit_value(c_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = (int)ret_;
            return ret;
        }
    }
}