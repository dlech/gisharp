// SPDX-License-Identifier: MIT
// ATTENTION: This file is automatically generated. Do not edit manually.
#nullable enable
namespace GISharp.Lib.GLib
{
    /// <include file="MainContext.xmldoc" path="declaration/member[@name='MainContext']/*" />
    [GISharp.Runtime.GTypeAttribute("GMainContext", IsProxyForUnmanagedType = true)]
    public sealed unsafe partial class MainContext : GISharp.Lib.GObject.Boxed
    {
        private static readonly GISharp.Lib.GObject.GType _GType = g_main_context_get_type();

        /// <summary>
        /// The unmanaged data structure.
        /// </summary>
        public struct UnmanagedStruct
        {
        }

        /// <include file="MainContext.xmldoc" path="declaration/member[@name='MainContext.IsOwner']/*" />
        [GISharp.Runtime.SinceAttribute("2.10")]
        public System.Boolean IsOwner { get => GetIsOwner(); }

        /// <include file="MainContext.xmldoc" path="declaration/member[@name='MainContext.IsPending']/*" />
        public System.Boolean IsPending { get => GetIsPending(); }

        /// <include file="MainContext.xmldoc" path="declaration/member[@name='MainContext.Default']/*" />
        public static GISharp.Lib.GLib.MainContext Default { get => GetDefault(); }

        /// <include file="MainContext.xmldoc" path="declaration/member[@name='MainContext.ThreadDefault']/*" />
        [GISharp.Runtime.SinceAttribute("2.32")]
        public static GISharp.Lib.GLib.MainContext ThreadDefault { get => GetThreadDefault(); }

        /// <include file="MainContext.xmldoc" path="declaration/member[@name='MainContext.Depth']/*" />
        public static int Depth { get => GetDepth(); }

        /// <summary>
        /// For internal runtime use only.
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        public MainContext(System.IntPtr handle, GISharp.Runtime.Transfer ownership) : base(handle)
        {
            if (ownership == GISharp.Runtime.Transfer.None)
            {
                this.handle = (System.IntPtr)g_main_context_ref((UnmanagedStruct*)handle);
            }
        }

        /// <summary>
        /// Creates a new #GMainContext structure.
        /// </summary>
        /// <returns>
        /// the new #GMainContext
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="MainContext" type="GMainContext*" managed-name="MainContext" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GLib.MainContext.UnmanagedStruct* g_main_context_new();
        static partial void CheckNewArgs();

        static GISharp.Lib.GLib.MainContext.UnmanagedStruct* New()
        {
            CheckNewArgs();
            var ret_ = g_main_context_new();
            return ret_;
        }

        /// <include file="MainContext.xmldoc" path="declaration/member[@name='MainContext.MainContext()']/*" />
        public MainContext() : this((System.IntPtr)New(), GISharp.Runtime.Transfer.Full)
        {
        }

        /// <summary>
        /// Returns the global default main context. This is the main context
        /// used for main loop functions when a main loop is not explicitly
        /// specified, and corresponds to the "main" main loop. See also
        /// g_main_context_get_thread_default().
        /// </summary>
        /// <returns>
        /// the global default main context.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="MainContext" type="GMainContext*" managed-name="MainContext" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GLib.MainContext.UnmanagedStruct* g_main_context_default();
        static partial void CheckGetDefaultArgs();

        private static GISharp.Lib.GLib.MainContext GetDefault()
        {
            CheckGetDefaultArgs();
            var ret_ = g_main_context_default();
            var ret = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.MainContext>((System.IntPtr)ret_, GISharp.Runtime.Transfer.None)!;
            return ret;
        }

        /// <summary>
        /// Gets the thread-default #GMainContext for this thread, as with
        /// g_main_context_get_thread_default(), but also adds a reference to
        /// it with g_main_context_ref(). In addition, unlike
        /// g_main_context_get_thread_default(), if the thread-default context
        /// is the global default context, this will return that #GMainContext
        /// (with a ref added to it) rather than returning %NULL.
        /// </summary>
        /// <returns>
        /// the thread-default #GMainContext. Unref
        ///     with g_main_context_unref() when you are done with it.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.32")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="MainContext" type="GMainContext*" managed-name="MainContext" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GLib.MainContext.UnmanagedStruct* g_main_context_ref_thread_default();
        static partial void CheckGetThreadDefaultArgs();

        [GISharp.Runtime.SinceAttribute("2.32")]
        private static GISharp.Lib.GLib.MainContext GetThreadDefault()
        {
            CheckGetThreadDefaultArgs();
            var ret_ = g_main_context_ref_thread_default();
            var ret = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.MainContext>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Returns the depth of the stack of calls to
        /// g_main_context_dispatch() on any #GMainContext in the current thread.
        ///  That is, when called from the toplevel, it gives 0. When
        /// called from within a callback from g_main_context_iteration()
        /// (or g_main_loop_run(), etc.) it returns 1. When called from within
        /// a callback to a recursive call to g_main_context_iteration(),
        /// it returns 2. And so forth.
        /// </summary>
        /// <remarks>
        /// This function is useful in a situation like the following:
        /// Imagine an extremely simple "garbage collected" system.
        /// 
        /// |[&lt;!-- language="C" --&gt;
        /// static GList *free_list;
        /// 
        /// gpointer
        /// allocate_memory (gsize size)
        /// {
        ///   gpointer result = g_malloc (size);
        ///   free_list = g_list_prepend (free_list, result);
        ///   return result;
        /// }
        /// 
        /// void
        /// free_allocated_memory (void)
        /// {
        ///   GList *l;
        ///   for (l = free_list; l; l = l-&gt;next);
        ///     g_free (l-&gt;data);
        ///   g_list_free (free_list);
        ///   free_list = NULL;
        ///  }
        /// 
        /// [...]
        /// 
        /// while (TRUE);
        ///  {
        ///    g_main_context_iteration (NULL, TRUE);
        ///    free_allocated_memory();
        ///   }
        /// ]|
        /// 
        /// This works from an application, however, if you want to do the same
        /// thing from a library, it gets more difficult, since you no longer
        /// control the main loop. You might think you can simply use an idle
        /// function to make the call to free_allocated_memory(), but that
        /// doesn't work, since the idle function could be called from a
        /// recursive callback. This can be fixed by using g_main_depth()
        /// 
        /// |[&lt;!-- language="C" --&gt;
        /// gpointer
        /// allocate_memory (gsize size)
        /// {
        ///   FreeListBlock *block = g_new (FreeListBlock, 1);
        ///   block-&gt;mem = g_malloc (size);
        ///   block-&gt;depth = g_main_depth ();
        ///   free_list = g_list_prepend (free_list, block);
        ///   return block-&gt;mem;
        /// }
        /// 
        /// void
        /// free_allocated_memory (void)
        /// {
        ///   GList *l;
        ///   
        ///   int depth = g_main_depth ();
        ///   for (l = free_list; l; );
        ///     {
        ///       GList *next = l-&gt;next;
        ///       FreeListBlock *block = l-&gt;data;
        ///       if (block-&gt;depth &gt; depth)
        ///         {
        ///           g_free (block-&gt;mem);
        ///           g_free (block);
        ///           free_list = g_list_delete_link (free_list, l);
        ///         }
        ///               
        ///       l = next;
        ///     }
        ///   }
        /// ]|
        /// 
        /// There is a temptation to use g_main_depth() to solve
        /// problems with reentrancy. For instance, while waiting for data
        /// to be received from the network in response to a menu item,
        /// the menu item might be selected again. It might seem that
        /// one could make the menu item's callback return immediately
        /// and do nothing if g_main_depth() returns a value greater than 1.
        /// However, this should be avoided since the user then sees selecting
        /// the menu item do nothing. Furthermore, you'll find yourself adding
        /// these checks all over your code, since there are doubtless many,
        /// many things that the user could do. Instead, you can use the
        /// following techniques:
        /// 
        /// 1. Use gtk_widget_set_sensitive() or modal dialogs to prevent
        ///    the user from interacting with elements while the main
        ///    loop is recursing.
        /// 
        /// 2. Avoid main loop recursion in situations where you can't handle
        ///    arbitrary  callbacks. Instead, structure your code so that you
        ///    simply return to the main loop and then get called again when
        ///    there is more work to do.
        /// </remarks>
        /// <returns>
        /// The main loop recursion level in the current thread
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gint" type="gint" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        private static extern int g_main_depth();
        static partial void CheckGetDepthArgs();

        private static int GetDepth()
        {
            CheckGetDepthArgs();
            var ret_ = g_main_depth();
            var ret = (int)ret_;
            return ret;
        }

        /// <summary>
        /// Polls @fds, as with the poll() system call, but portably. (On
        /// systems that don't have poll(), it is emulated using select().)
        /// This is used internally by #GMainContext, but it can be called
        /// directly if you need to block until a file descriptor is ready, but
        /// don't want to run the full main loop.
        /// </summary>
        /// <remarks>
        /// Each element of @fds is a #GPollFD describing a single file
        /// descriptor to poll. The @fd field indicates the file descriptor,
        /// and the @events field indicates the events to poll for. On return,
        /// the @revents fields will be filled with the events that actually
        /// occurred.
        /// 
        /// On POSIX systems, the file descriptors in @fds can be any sort of
        /// file descriptor, but the situation is much more complicated on
        /// Windows. If you need to use g_poll() in code that has to run on
        /// Windows, the easiest solution is to construct all of your
        /// #GPollFDs with g_io_channel_win32_make_pollfd().
        /// </remarks>
        /// <param name="fds">
        /// file descriptors to poll
        /// </param>
        /// <param name="nfds">
        /// the number of file descriptors in @fds
        /// </param>
        /// <param name="timeout">
        /// amount of time to wait, in milliseconds, or -1 to wait forever
        /// </param>
        /// <returns>
        /// the number of entries in @fds whose @revents fields
        /// were filled in, or 0 if the operation timed out, or -1 on error or
        /// if the call was interrupted.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.20")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gint" type="gint" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        private static extern int g_poll(
        /* <array type="GPollFD*" length="1" managed-name="GISharp.Runtime.CArray" is-pointer="1">
*   <type name="PollFD" type="GPollFD" managed-name="PollFD" />
* </array> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.PollFD* fds,
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        uint nfds,
        /* <type name="gint" type="gint" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        int timeout);
        static partial void CheckPollArgs(System.ReadOnlySpan<GISharp.Lib.GLib.PollFD> fds, int timeout = -1);

        /// <include file="MainContext.xmldoc" path="declaration/member[@name='MainContext.Poll(System.ReadOnlySpan&lt;GISharp.Lib.GLib.PollFD&gt;,int)']/*" />
        [GISharp.Runtime.SinceAttribute("2.20")]
        public static int Poll(System.ReadOnlySpan<GISharp.Lib.GLib.PollFD> fds, int timeout = -1)
        {
            fixed (GISharp.Lib.GLib.PollFD* fdsData_ = fds)
            {
                CheckPollArgs(fds, timeout);
                var fds_ = (GISharp.Lib.GLib.PollFD*)fdsData_;
                var nfds_ = (uint)fds.Length;
                var timeout_ = (int)timeout;
                var ret_ = g_poll(fds_,nfds_,timeout_);
                var ret = (int)ret_;
                return ret;
            }
        }

        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="GType" type="GType" managed-name="GISharp.Lib.GObject.GType" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GObject.GType g_main_context_get_type();

        /// <summary>
        /// Tries to become the owner of the specified context.
        /// If some other thread is the owner of the context,
        /// returns %FALSE immediately. Ownership is properly
        /// recursive: the owner can require ownership again
        /// and will release ownership when g_main_context_release()
        /// is called as many times as g_main_context_acquire().
        /// </summary>
        /// <remarks>
        /// You must be the owner of a context before you
        /// can call g_main_context_prepare(), g_main_context_query(),
        /// g_main_context_check(), g_main_context_dispatch().
        /// </remarks>
        /// <param name="context">
        /// a #GMainContext
        /// </param>
        /// <returns>
        /// %TRUE if the operation succeeded, and
        ///   this thread is now the owner of @context.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_main_context_acquire(
        /* <type name="MainContext" type="GMainContext*" managed-name="MainContext" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.MainContext.UnmanagedStruct* context);
        partial void CheckAcquireArgs();

        /// <include file="MainContext.xmldoc" path="declaration/member[@name='MainContext.Acquire()']/*" />
        public System.Boolean Acquire()
        {
            CheckAcquireArgs();
            var context_ = (GISharp.Lib.GLib.MainContext.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_main_context_acquire(context_);
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Adds a file descriptor to the set of file descriptors polled for
        /// this context. This will very seldom be used directly. Instead
        /// a typical event source will use g_source_add_unix_fd() instead.
        /// </summary>
        /// <param name="context">
        /// a #GMainContext (or %NULL for the default context)
        /// </param>
        /// <param name="fd">
        /// a #GPollFD structure holding information about a file
        ///      descriptor to watch.
        /// </param>
        /// <param name="priority">
        /// the priority for this file descriptor which should be
        ///      the same as the priority used for g_source_attach() to ensure that the
        ///      file descriptor is polled whenever the results may be needed.
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_main_context_add_poll(
        /* <type name="MainContext" type="GMainContext*" managed-name="MainContext" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.GLib.MainContext.UnmanagedStruct* context,
        /* <type name="PollFD" type="GPollFD*" managed-name="PollFD" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.PollFD* fd,
        /* <type name="gint" type="gint" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        int priority);
        partial void CheckAddPollArgs(GISharp.Lib.GLib.PollFD fd, int priority = GISharp.Lib.GLib.Priority.Default);

        /// <include file="MainContext.xmldoc" path="declaration/member[@name='MainContext.AddPoll(GISharp.Lib.GLib.PollFD,int)']/*" />
        public void AddPoll(GISharp.Lib.GLib.PollFD fd, int priority = GISharp.Lib.GLib.Priority.Default)
        {
            CheckAddPollArgs(fd, priority);
            var context_ = (GISharp.Lib.GLib.MainContext.UnmanagedStruct*)UnsafeHandle;
            var fd_ = &fd;
            var priority_ = (int)priority;
            g_main_context_add_poll(context_, fd_, priority_);
        }

        /// <summary>
        /// Passes the results of polling back to the main loop.
        /// </summary>
        /// <remarks>
        /// You must have successfully acquired the context with
        /// g_main_context_acquire() before you may call this function.
        /// </remarks>
        /// <param name="context">
        /// a #GMainContext
        /// </param>
        /// <param name="maxPriority">
        /// the maximum numerical priority of sources to check
        /// </param>
        /// <param name="fds">
        /// array of #GPollFD's that was passed to
        ///       the last call to g_main_context_query()
        /// </param>
        /// <param name="nFds">
        /// return value of g_main_context_query()
        /// </param>
        /// <returns>
        /// %TRUE if some sources are ready to be dispatched.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_main_context_check(
        /* <type name="MainContext" type="GMainContext*" managed-name="MainContext" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.MainContext.UnmanagedStruct* context,
        /* <type name="gint" type="gint" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        int maxPriority,
        /* <array length="2" zero-terminated="0" type="GPollFD*" managed-name="GISharp.Runtime.CArray" is-pointer="1">
*   <type name="PollFD" type="GPollFD" managed-name="PollFD" />
* </array> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.PollFD* fds,
        /* <type name="gint" type="gint" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        int nFds);
        partial void CheckCheckArgs(int maxPriority, System.ReadOnlySpan<GISharp.Lib.GLib.PollFD> fds);

        /// <include file="MainContext.xmldoc" path="declaration/member[@name='MainContext.Check(int,System.ReadOnlySpan&lt;GISharp.Lib.GLib.PollFD&gt;)']/*" />
        public System.Boolean Check(int maxPriority, System.ReadOnlySpan<GISharp.Lib.GLib.PollFD> fds)
        {
            fixed (GISharp.Lib.GLib.PollFD* fdsData_ = fds)
            {
                CheckCheckArgs(maxPriority, fds);
                var context_ = (GISharp.Lib.GLib.MainContext.UnmanagedStruct*)UnsafeHandle;
                var maxPriority_ = (int)maxPriority;
                var fds_ = (GISharp.Lib.GLib.PollFD*)fdsData_;
                var nFds_ = (int)fds.Length;
                var ret_ = g_main_context_check(context_,maxPriority_,fds_,nFds_);
                var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
                return ret;
            }
        }

        /// <summary>
        /// Dispatches all pending sources.
        /// </summary>
        /// <remarks>
        /// You must have successfully acquired the context with
        /// g_main_context_acquire() before you may call this function.
        /// </remarks>
        /// <param name="context">
        /// a #GMainContext
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_main_context_dispatch(
        /* <type name="MainContext" type="GMainContext*" managed-name="MainContext" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.MainContext.UnmanagedStruct* context);
        partial void CheckDispatchArgs();

        /// <include file="MainContext.xmldoc" path="declaration/member[@name='MainContext.Dispatch()']/*" />
        public void Dispatch()
        {
            CheckDispatchArgs();
            var context_ = (GISharp.Lib.GLib.MainContext.UnmanagedStruct*)UnsafeHandle;
            g_main_context_dispatch(context_);
        }

        /// <summary>
        /// Finds a source with the given source functions and user data.  If
        /// multiple sources exist with the same source function and user data,
        /// the first one found will be returned.
        /// </summary>
        /// <param name="context">
        /// a #GMainContext (if %NULL, the default context will be used).
        /// </param>
        /// <param name="funcs">
        /// the @source_funcs passed to g_source_new().
        /// </param>
        /// <param name="userData">
        /// the user data from the callback.
        /// </param>
        /// <returns>
        /// the source, if one was found, otherwise %NULL
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Source" type="GSource*" managed-name="Source" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GLib.Source.UnmanagedStruct* g_main_context_find_source_by_funcs_user_data(
        /* <type name="MainContext" type="GMainContext*" managed-name="MainContext" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.GLib.MainContext.UnmanagedStruct* context,
        /* <type name="SourceFuncs" type="GSourceFuncs*" managed-name="SourceFuncs" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.SourceFuncs* funcs,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr userData);
        partial void CheckFindSourceByFuncsUserDataArgs(GISharp.Lib.GLib.SourceFuncs funcs, System.IntPtr userData);

        /// <include file="MainContext.xmldoc" path="declaration/member[@name='MainContext.FindSourceByFuncsUserData(GISharp.Lib.GLib.SourceFuncs,System.IntPtr)']/*" />
        public GISharp.Lib.GLib.Source FindSourceByFuncsUserData(GISharp.Lib.GLib.SourceFuncs funcs, System.IntPtr userData)
        {
            CheckFindSourceByFuncsUserDataArgs(funcs, userData);
            var context_ = (GISharp.Lib.GLib.MainContext.UnmanagedStruct*)UnsafeHandle;
            var funcs_ = &funcs;
            var userData_ = (System.IntPtr)userData;
            var ret_ = g_main_context_find_source_by_funcs_user_data(context_,funcs_,userData_);
            var ret = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Source>((System.IntPtr)ret_, GISharp.Runtime.Transfer.None)!;
            return ret;
        }

        /// <summary>
        /// Finds a #GSource given a pair of context and ID.
        /// </summary>
        /// <remarks>
        /// It is a programmer error to attempt to look up a non-existent source.
        /// 
        /// More specifically: source IDs can be reissued after a source has been
        /// destroyed and therefore it is never valid to use this function with a
        /// source ID which may have already been removed.  An example is when
        /// scheduling an idle to run in another thread with g_idle_add(): the
        /// idle may already have run and been removed by the time this function
        /// is called on its (now invalid) source ID.  This source ID may have
        /// been reissued, leading to the operation being performed against the
        /// wrong source.
        /// </remarks>
        /// <param name="context">
        /// a #GMainContext (if %NULL, the default context will be used)
        /// </param>
        /// <param name="sourceId">
        /// the source ID, as returned by g_source_get_id().
        /// </param>
        /// <returns>
        /// the #GSource
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Source" type="GSource*" managed-name="Source" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GLib.Source.UnmanagedStruct* g_main_context_find_source_by_id(
        /* <type name="MainContext" type="GMainContext*" managed-name="MainContext" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.GLib.MainContext.UnmanagedStruct* context,
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        uint sourceId);
        partial void CheckFindSourceByIdArgs(uint sourceId);

        /// <include file="MainContext.xmldoc" path="declaration/member[@name='MainContext.FindSourceById(uint)']/*" />
        public GISharp.Lib.GLib.Source FindSourceById(uint sourceId)
        {
            CheckFindSourceByIdArgs(sourceId);
            var context_ = (GISharp.Lib.GLib.MainContext.UnmanagedStruct*)UnsafeHandle;
            var sourceId_ = (uint)sourceId;
            var ret_ = g_main_context_find_source_by_id(context_,sourceId_);
            var ret = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Source>((System.IntPtr)ret_, GISharp.Runtime.Transfer.None)!;
            return ret;
        }

        /// <summary>
        /// Finds a source with the given user data for the callback.  If
        /// multiple sources exist with the same user data, the first
        /// one found will be returned.
        /// </summary>
        /// <param name="context">
        /// a #GMainContext
        /// </param>
        /// <param name="userData">
        /// the user_data for the callback.
        /// </param>
        /// <returns>
        /// the source, if one was found, otherwise %NULL
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Source" type="GSource*" managed-name="Source" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GLib.Source.UnmanagedStruct* g_main_context_find_source_by_user_data(
        /* <type name="MainContext" type="GMainContext*" managed-name="MainContext" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.MainContext.UnmanagedStruct* context,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr userData);
        partial void CheckFindSourceByUserDataArgs(System.IntPtr userData);

        /// <include file="MainContext.xmldoc" path="declaration/member[@name='MainContext.FindSourceByUserData(System.IntPtr)']/*" />
        public GISharp.Lib.GLib.Source FindSourceByUserData(System.IntPtr userData)
        {
            CheckFindSourceByUserDataArgs(userData);
            var context_ = (GISharp.Lib.GLib.MainContext.UnmanagedStruct*)UnsafeHandle;
            var userData_ = (System.IntPtr)userData;
            var ret_ = g_main_context_find_source_by_user_data(context_,userData_);
            var ret = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Source>((System.IntPtr)ret_, GISharp.Runtime.Transfer.None)!;
            return ret;
        }

        /// <summary>
        /// Invokes a function in such a way that @context is owned during the
        /// invocation of @function.
        /// </summary>
        /// <remarks>
        /// This function is the same as g_main_context_invoke() except that it
        /// lets you specify the priority in case @function ends up being
        /// scheduled as an idle and also lets you give a #GDestroyNotify for @data.
        /// 
        /// @notify should not assume that it is called from any particular
        /// thread or with any particular context acquired.
        /// </remarks>
        /// <param name="context">
        /// a #GMainContext, or %NULL
        /// </param>
        /// <param name="priority">
        /// the priority at which to run @function
        /// </param>
        /// <param name="function">
        /// function to call
        /// </param>
        /// <param name="data">
        /// data to pass to @function
        /// </param>
        /// <param name="notify">
        /// a function to call when @data is no longer in use, or %NULL.
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.28")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_main_context_invoke_full(
        /* <type name="MainContext" type="GMainContext*" managed-name="MainContext" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.GLib.MainContext.UnmanagedStruct* context,
        /* <type name="gint" type="gint" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        int priority,
        /* <type name="SourceFunc" type="GSourceFunc" managed-name="SourceFunc" /> */
        /* transfer-ownership:none scope:notified closure:2 destroy:3 direction:in */
        delegate* unmanaged[Cdecl]<System.IntPtr, GISharp.Runtime.Boolean> function,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr data,
        /* <type name="DestroyNotify" type="GDestroyNotify" managed-name="DestroyNotify" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:async direction:in */
        delegate* unmanaged[Cdecl]<System.IntPtr, void> notify);
        partial void CheckInvokeArgs(GISharp.Lib.GLib.SourceFunc function, int priority = GISharp.Lib.GLib.Priority.Default);

        /// <include file="MainContext.xmldoc" path="declaration/member[@name='MainContext.Invoke(GISharp.Lib.GLib.SourceFunc,int)']/*" />
        [GISharp.Runtime.SinceAttribute("2.28")]
        public void Invoke(GISharp.Lib.GLib.SourceFunc function, int priority = GISharp.Lib.GLib.Priority.Default)
        {
            CheckInvokeArgs(function, priority);
            var context_ = (GISharp.Lib.GLib.MainContext.UnmanagedStruct*)UnsafeHandle;
            var function_ = (delegate* unmanaged[Cdecl]<System.IntPtr, GISharp.Runtime.Boolean>)&GISharp.Lib.GLib.SourceFuncMarshal.Callback;
            var functionHandle = System.Runtime.InteropServices.GCHandle.Alloc((function, GISharp.Runtime.CallbackScope.Notified));
            var data_ = (System.IntPtr)functionHandle;
            var notify_ = (delegate* unmanaged[Cdecl]<System.IntPtr, void>)&GISharp.Runtime.GMarshal.DestroyGCHandle;
            var priority_ = (int)priority;
            g_main_context_invoke_full(context_, priority_, function_, data_, notify_);
        }

        /// <summary>
        /// Determines whether this thread holds the (recursive)
        /// ownership of this #GMainContext. This is useful to
        /// know before waiting on another thread that may be
        /// blocking to get ownership of @context.
        /// </summary>
        /// <param name="context">
        /// a #GMainContext
        /// </param>
        /// <returns>
        /// %TRUE if current thread is owner of @context.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.10")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_main_context_is_owner(
        /* <type name="MainContext" type="GMainContext*" managed-name="MainContext" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.MainContext.UnmanagedStruct* context);
        partial void CheckGetIsOwnerArgs();

        [GISharp.Runtime.SinceAttribute("2.10")]
        private System.Boolean GetIsOwner()
        {
            CheckGetIsOwnerArgs();
            var context_ = (GISharp.Lib.GLib.MainContext.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_main_context_is_owner(context_);
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Runs a single iteration for the given main loop. This involves
        /// checking to see if any event sources are ready to be processed,
        /// then if no events sources are ready and @may_block is %TRUE, waiting
        /// for a source to become ready, then dispatching the highest priority
        /// events sources that are ready. Otherwise, if @may_block is %FALSE
        /// sources are not waited to become ready, only those highest priority
        /// events sources will be dispatched (if any), that are ready at this
        /// given moment without further waiting.
        /// </summary>
        /// <remarks>
        /// Note that even when @may_block is %TRUE, it is still possible for
        /// g_main_context_iteration() to return %FALSE, since the wait may
        /// be interrupted for other reasons than an event source becoming ready.
        /// </remarks>
        /// <param name="context">
        /// a #GMainContext (if %NULL, the default context will be used)
        /// </param>
        /// <param name="mayBlock">
        /// whether the call may block.
        /// </param>
        /// <returns>
        /// %TRUE if events were dispatched.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_main_context_iteration(
        /* <type name="MainContext" type="GMainContext*" managed-name="MainContext" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.GLib.MainContext.UnmanagedStruct* context,
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.Boolean mayBlock);
        partial void CheckIterationArgs(System.Boolean mayBlock);

        /// <include file="MainContext.xmldoc" path="declaration/member[@name='MainContext.Iteration(System.Boolean)']/*" />
        public System.Boolean Iteration(System.Boolean mayBlock)
        {
            CheckIterationArgs(mayBlock);
            var context_ = (GISharp.Lib.GLib.MainContext.UnmanagedStruct*)UnsafeHandle;
            var mayBlock_ = GISharp.Runtime.BooleanExtensions.ToBoolean(mayBlock);
            var ret_ = g_main_context_iteration(context_,mayBlock_);
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Checks if any sources have pending events for the given context.
        /// </summary>
        /// <param name="context">
        /// a #GMainContext (if %NULL, the default context will be used)
        /// </param>
        /// <returns>
        /// %TRUE if events are pending.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_main_context_pending(
        /* <type name="MainContext" type="GMainContext*" managed-name="MainContext" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.GLib.MainContext.UnmanagedStruct* context);
        partial void CheckGetIsPendingArgs();

        private System.Boolean GetIsPending()
        {
            CheckGetIsPendingArgs();
            var context_ = (GISharp.Lib.GLib.MainContext.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_main_context_pending(context_);
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Pops @context off the thread-default context stack (verifying that
        /// it was on the top of the stack).
        /// </summary>
        /// <param name="context">
        /// a #GMainContext object, or %NULL
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.22")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_main_context_pop_thread_default(
        /* <type name="MainContext" type="GMainContext*" managed-name="MainContext" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.GLib.MainContext.UnmanagedStruct* context);
        partial void CheckPopThreadDefaultArgs();

        /// <include file="MainContext.xmldoc" path="declaration/member[@name='MainContext.PopThreadDefault()']/*" />
        [GISharp.Runtime.SinceAttribute("2.22")]
        public void PopThreadDefault()
        {
            CheckPopThreadDefaultArgs();
            var context_ = (GISharp.Lib.GLib.MainContext.UnmanagedStruct*)UnsafeHandle;
            g_main_context_pop_thread_default(context_);
        }

        /// <summary>
        /// Prepares to poll sources within a main loop. The resulting information
        /// for polling is determined by calling g_main_context_query ().
        /// </summary>
        /// <remarks>
        /// You must have successfully acquired the context with
        /// g_main_context_acquire() before you may call this function.
        /// </remarks>
        /// <param name="context">
        /// a #GMainContext
        /// </param>
        /// <param name="priority">
        /// location to store priority of highest priority
        ///            source already ready.
        /// </param>
        /// <returns>
        /// %TRUE if some source is ready to be dispatched
        ///               prior to polling.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_main_context_prepare(
        /* <type name="MainContext" type="GMainContext*" managed-name="MainContext" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.MainContext.UnmanagedStruct* context,
        /* <type name="gint" type="gint*" managed-name="System.Int32" /> */
        /* direction:out caller-allocates:0 transfer-ownership:full optional:1 allow-none:1 */
        int* priority);
        partial void CheckTryPrepareArgs();

        /// <include file="MainContext.xmldoc" path="declaration/member[@name='MainContext.TryPrepare(int)']/*" />
        public System.Boolean TryPrepare(out int priority)
        {
            CheckTryPrepareArgs();
            var context_ = (GISharp.Lib.GLib.MainContext.UnmanagedStruct*)UnsafeHandle;
            int priority_;
            var ret_ = g_main_context_prepare(context_,&priority_);
            priority = (int)priority_;
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Acquires @context and sets it as the thread-default context for the
        /// current thread. This will cause certain asynchronous operations
        /// (such as most [gio][gio]-based I/O) which are
        /// started in this thread to run under @context and deliver their
        /// results to its main loop, rather than running under the global
        /// default context in the main thread. Note that calling this function
        /// changes the context returned by g_main_context_get_thread_default(),
        /// not the one returned by g_main_context_default(), so it does not affect
        /// the context used by functions like g_idle_add().
        /// </summary>
        /// <remarks>
        /// Normally you would call this function shortly after creating a new
        /// thread, passing it a #GMainContext which will be run by a
        /// #GMainLoop in that thread, to set a new default context for all
        /// async operations in that thread. In this case you may not need to
        /// ever call g_main_context_pop_thread_default(), assuming you want the
        /// new #GMainContext to be the default for the whole lifecycle of the
        /// thread.
        /// 
        /// If you don't have control over how the new thread was created (e.g.
        /// in the new thread isn't newly created, or if the thread life
        /// cycle is managed by a #GThreadPool), it is always suggested to wrap
        /// the logic that needs to use the new #GMainContext inside a
        /// g_main_context_push_thread_default() / g_main_context_pop_thread_default()
        /// pair, otherwise threads that are re-used will end up never explicitly
        /// releasing the #GMainContext reference they hold.
        /// 
        /// In some cases you may want to schedule a single operation in a
        /// non-default context, or temporarily use a non-default context in
        /// the main thread. In that case, you can wrap the call to the
        /// asynchronous operation inside a
        /// g_main_context_push_thread_default() /
        /// g_main_context_pop_thread_default() pair, but it is up to you to
        /// ensure that no other asynchronous operations accidentally get
        /// started while the non-default context is active.
        /// 
        /// Beware that libraries that predate this function may not correctly
        /// handle being used from a thread with a thread-default context. Eg,
        /// see g_file_supports_thread_contexts().
        /// </remarks>
        /// <param name="context">
        /// a #GMainContext, or %NULL for the global default context
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.22")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_main_context_push_thread_default(
        /* <type name="MainContext" type="GMainContext*" managed-name="MainContext" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.GLib.MainContext.UnmanagedStruct* context);
        partial void CheckPushThreadDefaultArgs();

        /// <include file="MainContext.xmldoc" path="declaration/member[@name='MainContext.PushThreadDefault()']/*" />
        [GISharp.Runtime.SinceAttribute("2.22")]
        public void PushThreadDefault()
        {
            CheckPushThreadDefaultArgs();
            var context_ = (GISharp.Lib.GLib.MainContext.UnmanagedStruct*)UnsafeHandle;
            g_main_context_push_thread_default(context_);
        }

        /// <summary>
        /// Determines information necessary to poll this main loop.
        /// </summary>
        /// <remarks>
        /// You must have successfully acquired the context with
        /// g_main_context_acquire() before you may call this function.
        /// </remarks>
        /// <param name="context">
        /// a #GMainContext
        /// </param>
        /// <param name="maxPriority">
        /// maximum priority source to check
        /// </param>
        /// <param name="timeout">
        /// location to store timeout to be used in polling
        /// </param>
        /// <param name="fds">
        /// location to
        ///       store #GPollFD records that need to be polled.
        /// </param>
        /// <param name="nFds">
        /// length of @fds.
        /// </param>
        /// <returns>
        /// the number of records actually stored in @fds,
        ///   or, if more than @n_fds records need to be stored, the number
        ///   of records that need to be stored.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gint" type="gint" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        private static extern int g_main_context_query(
        /* <type name="MainContext" type="GMainContext*" managed-name="MainContext" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.MainContext.UnmanagedStruct* context,
        /* <type name="gint" type="gint" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        int maxPriority,
        /* <type name="gint" type="gint*" managed-name="System.Int32" /> */
        /* direction:out caller-allocates:0 transfer-ownership:full */
        int* timeout,
        /* <array length="3" zero-terminated="0" type="GPollFD*" managed-name="GISharp.Runtime.CArray" is-pointer="1">
*   <type name="PollFD" type="GPollFD" managed-name="PollFD" />
* </array> */
        /* direction:out caller-allocates:1 transfer-ownership:none */
        GISharp.Lib.GLib.PollFD* fds,
        /* <type name="gint" type="gint" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        int nFds);
        partial void CheckQueryArgs(int maxPriority);

        /// <include file="MainContext.xmldoc" path="declaration/member[@name='MainContext.Query(int,int,System.Span&lt;GISharp.Lib.GLib.PollFD&gt;)']/*" />
        public int Query(int maxPriority, out int timeout, System.Span<GISharp.Lib.GLib.PollFD> fds)
        {
            fixed (GISharp.Lib.GLib.PollFD* fdsData_ = fds)
            {
                CheckQueryArgs(maxPriority);
                var context_ = (GISharp.Lib.GLib.MainContext.UnmanagedStruct*)UnsafeHandle;
                var maxPriority_ = (int)maxPriority;
                var fds_ = (GISharp.Lib.GLib.PollFD*)fdsData_;
                var nFds_ = (int)fds.Length;
                int timeout_;
                var ret_ = g_main_context_query(context_,maxPriority_,&timeout_,fds_,nFds_);
                timeout = (int)timeout_;
                var ret = (int)ret_;
                return ret;
            }
        }

        /// <summary>
        /// Increases the reference count on a #GMainContext object by one.
        /// </summary>
        /// <param name="context">
        /// a #GMainContext
        /// </param>
        /// <returns>
        /// the @context that was passed in (since 2.6)
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="MainContext" type="GMainContext*" managed-name="MainContext" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GLib.MainContext.UnmanagedStruct* g_main_context_ref(
        /* <type name="MainContext" type="GMainContext*" managed-name="MainContext" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.MainContext.UnmanagedStruct* context);

        /// <summary>
        /// Takes ownership of the unmanaged pointer without freeing it.
        /// The managed object can no longer be used (will throw disposed exception).
        /// </summary>
        public override System.IntPtr Take() => (System.IntPtr)g_main_context_ref((GISharp.Lib.GLib.MainContext.UnmanagedStruct*)UnsafeHandle);

        /// <summary>
        /// Releases ownership of a context previously acquired by this thread
        /// with g_main_context_acquire(). If the context was acquired multiple
        /// times, the ownership will be released only when g_main_context_release()
        /// is called as many times as it was acquired.
        /// </summary>
        /// <param name="context">
        /// a #GMainContext
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_main_context_release(
        /* <type name="MainContext" type="GMainContext*" managed-name="MainContext" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.MainContext.UnmanagedStruct* context);
        partial void CheckReleaseArgs();

        /// <include file="MainContext.xmldoc" path="declaration/member[@name='MainContext.Release()']/*" />
        public void Release()
        {
            CheckReleaseArgs();
            var context_ = (GISharp.Lib.GLib.MainContext.UnmanagedStruct*)UnsafeHandle;
            g_main_context_release(context_);
        }

        /// <summary>
        /// Removes file descriptor from the set of file descriptors to be
        /// polled for a particular context.
        /// </summary>
        /// <param name="context">
        /// a #GMainContext
        /// </param>
        /// <param name="fd">
        /// a #GPollFD descriptor previously added with g_main_context_add_poll()
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_main_context_remove_poll(
        /* <type name="MainContext" type="GMainContext*" managed-name="MainContext" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.MainContext.UnmanagedStruct* context,
        /* <type name="PollFD" type="GPollFD*" managed-name="PollFD" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.PollFD* fd);
        partial void CheckRemovePollArgs(GISharp.Lib.GLib.PollFD fd);

        /// <include file="MainContext.xmldoc" path="declaration/member[@name='MainContext.RemovePoll(GISharp.Lib.GLib.PollFD)']/*" />
        public void RemovePoll(GISharp.Lib.GLib.PollFD fd)
        {
            CheckRemovePollArgs(fd);
            var context_ = (GISharp.Lib.GLib.MainContext.UnmanagedStruct*)UnsafeHandle;
            var fd_ = &fd;
            g_main_context_remove_poll(context_, fd_);
        }

        /// <summary>
        /// Decreases the reference count on a #GMainContext object by one. If
        /// the result is zero, free the context and free all associated memory.
        /// </summary>
        /// <param name="context">
        /// a #GMainContext
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_main_context_unref(
        /* <type name="MainContext" type="GMainContext*" managed-name="MainContext" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.MainContext.UnmanagedStruct* context);

        /// <inheritdoc/>
        protected override void Dispose(bool disposing)
        {
            if (handle != System.IntPtr.Zero)
            {
                g_main_context_unref((UnmanagedStruct*)handle);
            }

            base.Dispose(disposing);
        }

        /// <summary>
        /// If @context is currently blocking in g_main_context_iteration()
        /// waiting for a source to become ready, cause it to stop blocking
        /// and return.  Otherwise, cause the next invocation of
        /// g_main_context_iteration() to return without blocking.
        /// </summary>
        /// <remarks>
        /// This API is useful for low-level control over #GMainContext; for
        /// example, integrating it with main loop implementations such as
        /// #GMainLoop.
        /// 
        /// Another related use for this function is when implementing a main
        /// loop with a termination condition, computed from multiple threads:
        /// 
        /// |[&lt;!-- language="C" --&gt;
        ///   #define NUM_TASKS 10
        ///   static volatile gint tasks_remaining = NUM_TASKS;
        ///   ...
        ///  
        ///   while (g_atomic_int_get (&amp;tasks_remaining) != 0)
        ///     g_main_context_iteration (NULL, TRUE);
        /// ]|
        ///  
        /// Then in a thread:
        /// |[&lt;!-- language="C" --&gt;
        ///   perform_work();
        /// 
        ///   if (g_atomic_int_dec_and_test (&amp;tasks_remaining))
        ///     g_main_context_wakeup (NULL);
        /// ]|
        /// </remarks>
        /// <param name="context">
        /// a #GMainContext
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_main_context_wakeup(
        /* <type name="MainContext" type="GMainContext*" managed-name="MainContext" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.MainContext.UnmanagedStruct* context);
        partial void CheckWakeUpArgs();

        /// <include file="MainContext.xmldoc" path="declaration/member[@name='MainContext.WakeUp()']/*" />
        public void WakeUp()
        {
            CheckWakeUpArgs();
            var context_ = (GISharp.Lib.GLib.MainContext.UnmanagedStruct*)UnsafeHandle;
            g_main_context_wakeup(context_);
        }
    }
}