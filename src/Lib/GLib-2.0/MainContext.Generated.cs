// SPDX-License-Identifier: MIT
// ATTENTION: This file is automatically generated. Do not edit manually.
#nullable enable
namespace GISharp.Lib.GLib
{
    /// <include file="MainContext.xmldoc" path="declaration/member[@name='MainContext']/*" />
    [GISharp.Runtime.GTypeAttribute("GMainContext", IsProxyForUnmanagedType = true)]
    public sealed unsafe partial class MainContext : GISharp.Lib.GObject.Boxed
    {
        private static readonly GISharp.Lib.GObject.GType _GType = g_main_context_get_type();

        /// <summary>
        /// The unmanaged data structure.
        /// </summary>
        public struct UnmanagedStruct
        {
        }

        /// <include file="MainContext.xmldoc" path="declaration/member[@name='MainContext.IsOwner']/*" />
        [GISharp.Runtime.SinceAttribute("2.10")]
        public System.Boolean IsOwner { get => GetIsOwner(); }

        /// <include file="MainContext.xmldoc" path="declaration/member[@name='MainContext.ThreadDefault']/*" />
        [GISharp.Runtime.SinceAttribute("2.22")]
        public static GISharp.Lib.GLib.MainContext ThreadDefault { get => GetThreadDefault(); }

        /// <summary>
        /// For internal runtime use only.
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        public MainContext(System.IntPtr handle, GISharp.Runtime.Transfer ownership) : base(handle)
        {
            if (ownership == GISharp.Runtime.Transfer.None)
            {
                this.handle = (System.IntPtr)g_main_context_ref((UnmanagedStruct*)handle);
            }
        }

        static partial void CheckNewArgs();

        /// <summary>
        /// Creates a new #GMainContext structure.
        /// </summary>
        /// <returns>
        /// the new #GMainContext
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="MainContext" type="GMainContext*" managed-name="MainContext" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GLib.MainContext.UnmanagedStruct* g_main_context_new();

        static GISharp.Lib.GLib.MainContext.UnmanagedStruct* New()
        {
            CheckNewArgs();
            var ret_ = g_main_context_new();
            return ret_;
        }

        /// <include file="MainContext.xmldoc" path="declaration/member[@name='MainContext.MainContext()']/*" />
        public MainContext() : this((System.IntPtr)New(), GISharp.Runtime.Transfer.Full)
        {
        }

        static partial void CheckDefaultArgs();

        /// <summary>
        /// Returns the global default main context. This is the main context
        /// used for main loop functions when a main loop is not explicitly
        /// specified, and corresponds to the "main" main loop. See also
        /// g_main_context_get_thread_default().
        /// </summary>
        /// <returns>
        /// the global default main context.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="MainContext" type="GMainContext*" managed-name="MainContext" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GLib.MainContext.UnmanagedStruct* g_main_context_default();

        /// <include file="MainContext.xmldoc" path="declaration/member[@name='MainContext.Default()']/*" />
        public static GISharp.Lib.GLib.MainContext Default()
        {
            CheckDefaultArgs();
            var ret_ = g_main_context_default();
            var ret = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.MainContext>((System.IntPtr)ret_, GISharp.Runtime.Transfer.None)!;
            return ret;
        }

        static partial void CheckGetThreadDefaultArgs();

        /// <summary>
        /// Gets the thread-default #GMainContext for this thread. Asynchronous
        /// operations that want to be able to be run in contexts other than
        /// the default one should call this method or
        /// g_main_context_ref_thread_default() to get a #GMainContext to add
        /// their #GSources to. (Note that even in single-threaded
        /// programs applications may sometimes want to temporarily push a
        /// non-default context, so it is not safe to assume that this will
        /// always return %NULL if you are running in the default thread.)
        /// </summary>
        /// <remarks>
        /// If you need to hold a reference on the context, use
        /// g_main_context_ref_thread_default() instead.
        /// </remarks>
        /// <returns>
        /// the thread-default #GMainContext, or
        /// %NULL if the thread-default context is the global default context.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.22")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="MainContext" type="GMainContext*" managed-name="MainContext" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GLib.MainContext.UnmanagedStruct* g_main_context_get_thread_default();

        [GISharp.Runtime.SinceAttribute("2.22")]
        private static GISharp.Lib.GLib.MainContext GetThreadDefault()
        {
            CheckGetThreadDefaultArgs();
            var ret_ = g_main_context_get_thread_default();
            var ret = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.MainContext>((System.IntPtr)ret_, GISharp.Runtime.Transfer.None)!;
            return ret;
        }

        static partial void CheckRefThreadDefaultArgs();

        /// <summary>
        /// Gets the thread-default #GMainContext for this thread, as with
        /// g_main_context_get_thread_default(), but also adds a reference to
        /// it with g_main_context_ref(). In addition, unlike
        /// g_main_context_get_thread_default(), if the thread-default context
        /// is the global default context, this will return that #GMainContext
        /// (with a ref added to it) rather than returning %NULL.
        /// </summary>
        /// <returns>
        /// the thread-default #GMainContext. Unref
        ///     with g_main_context_unref() when you are done with it.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.32")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="MainContext" type="GMainContext*" managed-name="MainContext" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GLib.MainContext.UnmanagedStruct* g_main_context_ref_thread_default();

        /// <include file="MainContext.xmldoc" path="declaration/member[@name='MainContext.RefThreadDefault()']/*" />
        [GISharp.Runtime.SinceAttribute("2.32")]
        public static GISharp.Lib.GLib.MainContext RefThreadDefault()
        {
            CheckRefThreadDefaultArgs();
            var ret_ = g_main_context_ref_thread_default();
            var ret = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.MainContext>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        static partial void CheckGetGTypeArgs();
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="GType" type="GType" managed-name="GISharp.Lib.GObject.GType" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GObject.GType g_main_context_get_type();

        /// <summary>
        /// Tries to become the owner of the specified context.
        /// If some other thread is the owner of the context,
        /// returns %FALSE immediately. Ownership is properly
        /// recursive: the owner can require ownership again
        /// and will release ownership when g_main_context_release()
        /// is called as many times as g_main_context_acquire().
        /// </summary>
        /// <remarks>
        /// You must be the owner of a context before you
        /// can call g_main_context_prepare(), g_main_context_query(),
        /// g_main_context_check(), g_main_context_dispatch().
        /// </remarks>
        /// <param name="context">
        /// a #GMainContext
        /// </param>
        /// <returns>
        /// %TRUE if the operation succeeded, and
        ///   this thread is now the owner of @context.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_main_context_acquire(
        /* <type name="MainContext" type="GMainContext*" managed-name="MainContext" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.MainContext.UnmanagedStruct* context);
        partial void CheckAcquireArgs();

        /// <include file="MainContext.xmldoc" path="declaration/member[@name='MainContext.Acquire()']/*" />
        public System.Boolean Acquire()
        {
            CheckAcquireArgs();
            var context_ = (GISharp.Lib.GLib.MainContext.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_main_context_acquire(context_);
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Adds a file descriptor to the set of file descriptors polled for
        /// this context. This will very seldom be used directly. Instead
        /// a typical event source will use g_source_add_unix_fd() instead.
        /// </summary>
        /// <param name="context">
        /// a #GMainContext (or %NULL for the default context)
        /// </param>
        /// <param name="fd">
        /// a #GPollFD structure holding information about a file
        ///      descriptor to watch.
        /// </param>
        /// <param name="priority">
        /// the priority for this file descriptor which should be
        ///      the same as the priority used for g_source_attach() to ensure that the
        ///      file descriptor is polled whenever the results may be needed.
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_main_context_add_poll(
        /* <type name="MainContext" type="GMainContext*" managed-name="MainContext" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.GLib.MainContext.UnmanagedStruct* context,
        /* <type name="PollFD" type="GPollFD*" managed-name="PollFD" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.PollFD* fd,
        /* <type name="gint" type="gint" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        int priority);
        partial void CheckAddPollArgs(GISharp.Lib.GLib.PollFD fd, int priority);

        /// <include file="MainContext.xmldoc" path="declaration/member[@name='MainContext.AddPoll(GISharp.Lib.GLib.PollFD,int)']/*" />
        public void AddPoll(GISharp.Lib.GLib.PollFD fd, int priority)
        {
            CheckAddPollArgs(fd, priority);
            var context_ = (GISharp.Lib.GLib.MainContext.UnmanagedStruct*)UnsafeHandle;
            var fd_ = &fd;
            var priority_ = (int)priority;
            g_main_context_add_poll(context_, fd_, priority_);
        }

        /// <summary>
        /// Passes the results of polling back to the main loop.
        /// </summary>
        /// <remarks>
        /// You must have successfully acquired the context with
        /// g_main_context_acquire() before you may call this function.
        /// </remarks>
        /// <param name="context">
        /// a #GMainContext
        /// </param>
        /// <param name="maxPriority">
        /// the maximum numerical priority of sources to check
        /// </param>
        /// <param name="fds">
        /// array of #GPollFD's that was passed to
        ///       the last call to g_main_context_query()
        /// </param>
        /// <param name="nFds">
        /// return value of g_main_context_query()
        /// </param>
        /// <returns>
        /// %TRUE if some sources are ready to be dispatched.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_main_context_check(
        /* <type name="MainContext" type="GMainContext*" managed-name="MainContext" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.MainContext.UnmanagedStruct* context,
        /* <type name="gint" type="gint" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        int maxPriority,
        /* <array length="2" zero-terminated="0" type="GPollFD*" managed-name="GISharp.Runtime.CArray" is-pointer="1">
*   <type name="PollFD" type="GPollFD" managed-name="PollFD" />
* </array> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.PollFD* fds,
        /* <type name="gint" type="gint" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        int nFds);
        partial void CheckCheckArgs(int maxPriority, System.ReadOnlySpan<GISharp.Lib.GLib.PollFD> fds);

        /// <include file="MainContext.xmldoc" path="declaration/member[@name='MainContext.Check(int,System.ReadOnlySpan&lt;GISharp.Lib.GLib.PollFD&gt;)']/*" />
        public System.Boolean Check(int maxPriority, System.ReadOnlySpan<GISharp.Lib.GLib.PollFD> fds)
        {
            fixed (GISharp.Lib.GLib.PollFD* fdsData_ = fds)
            {
                CheckCheckArgs(maxPriority, fds);
                var context_ = (GISharp.Lib.GLib.MainContext.UnmanagedStruct*)UnsafeHandle;
                var maxPriority_ = (int)maxPriority;
                var fds_ = (GISharp.Lib.GLib.PollFD*)fdsData_;
                var nFds_ = (int)fds.Length;
                var ret_ = g_main_context_check(context_,maxPriority_,fds_,nFds_);
                var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
                return ret;
            }
        }

        /// <summary>
        /// Dispatches all pending sources.
        /// </summary>
        /// <remarks>
        /// You must have successfully acquired the context with
        /// g_main_context_acquire() before you may call this function.
        /// </remarks>
        /// <param name="context">
        /// a #GMainContext
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_main_context_dispatch(
        /* <type name="MainContext" type="GMainContext*" managed-name="MainContext" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.MainContext.UnmanagedStruct* context);
        partial void CheckDispatchArgs();

        /// <include file="MainContext.xmldoc" path="declaration/member[@name='MainContext.Dispatch()']/*" />
        public void Dispatch()
        {
            CheckDispatchArgs();
            var context_ = (GISharp.Lib.GLib.MainContext.UnmanagedStruct*)UnsafeHandle;
            g_main_context_dispatch(context_);
        }

        /// <summary>
        /// Finds a source with the given source functions and user data.  If
        /// multiple sources exist with the same source function and user data,
        /// the first one found will be returned.
        /// </summary>
        /// <param name="context">
        /// a #GMainContext (if %NULL, the default context will be used).
        /// </param>
        /// <param name="funcs">
        /// the @source_funcs passed to g_source_new().
        /// </param>
        /// <param name="userData">
        /// the user data from the callback.
        /// </param>
        /// <returns>
        /// the source, if one was found, otherwise %NULL
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Source" type="GSource*" managed-name="Source" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GLib.Source.UnmanagedStruct* g_main_context_find_source_by_funcs_user_data(
        /* <type name="MainContext" type="GMainContext*" managed-name="MainContext" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.GLib.MainContext.UnmanagedStruct* context,
        /* <type name="SourceFuncs" type="GSourceFuncs*" managed-name="SourceFuncs" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.SourceFuncs* funcs,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr userData);
        partial void CheckFindSourceByFuncsUserDataArgs(GISharp.Lib.GLib.SourceFuncs funcs, System.IntPtr userData);

        /// <include file="MainContext.xmldoc" path="declaration/member[@name='MainContext.FindSourceByFuncsUserData(GISharp.Lib.GLib.SourceFuncs,System.IntPtr)']/*" />
        public GISharp.Lib.GLib.Source FindSourceByFuncsUserData(GISharp.Lib.GLib.SourceFuncs funcs, System.IntPtr userData)
        {
            CheckFindSourceByFuncsUserDataArgs(funcs, userData);
            var context_ = (GISharp.Lib.GLib.MainContext.UnmanagedStruct*)UnsafeHandle;
            var funcs_ = &funcs;
            var userData_ = (System.IntPtr)userData;
            var ret_ = g_main_context_find_source_by_funcs_user_data(context_,funcs_,userData_);
            var ret = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Source>((System.IntPtr)ret_, GISharp.Runtime.Transfer.None)!;
            return ret;
        }

        /// <summary>
        /// Finds a #GSource given a pair of context and ID.
        /// </summary>
        /// <remarks>
        /// It is a programmer error to attempt to look up a non-existent source.
        /// 
        /// More specifically: source IDs can be reissued after a source has been
        /// destroyed and therefore it is never valid to use this function with a
        /// source ID which may have already been removed.  An example is when
        /// scheduling an idle to run in another thread with g_idle_add(): the
        /// idle may already have run and been removed by the time this function
        /// is called on its (now invalid) source ID.  This source ID may have
        /// been reissued, leading to the operation being performed against the
        /// wrong source.
        /// </remarks>
        /// <param name="context">
        /// a #GMainContext (if %NULL, the default context will be used)
        /// </param>
        /// <param name="sourceId">
        /// the source ID, as returned by g_source_get_id().
        /// </param>
        /// <returns>
        /// the #GSource
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Source" type="GSource*" managed-name="Source" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GLib.Source.UnmanagedStruct* g_main_context_find_source_by_id(
        /* <type name="MainContext" type="GMainContext*" managed-name="MainContext" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.GLib.MainContext.UnmanagedStruct* context,
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        uint sourceId);
        partial void CheckFindSourceByIdArgs(uint sourceId);

        /// <include file="MainContext.xmldoc" path="declaration/member[@name='MainContext.FindSourceById(uint)']/*" />
        public GISharp.Lib.GLib.Source FindSourceById(uint sourceId)
        {
            CheckFindSourceByIdArgs(sourceId);
            var context_ = (GISharp.Lib.GLib.MainContext.UnmanagedStruct*)UnsafeHandle;
            var sourceId_ = (uint)sourceId;
            var ret_ = g_main_context_find_source_by_id(context_,sourceId_);
            var ret = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Source>((System.IntPtr)ret_, GISharp.Runtime.Transfer.None)!;
            return ret;
        }

        /// <summary>
        /// Finds a source with the given user data for the callback.  If
        /// multiple sources exist with the same user data, the first
        /// one found will be returned.
        /// </summary>
        /// <param name="context">
        /// a #GMainContext
        /// </param>
        /// <param name="userData">
        /// the user_data for the callback.
        /// </param>
        /// <returns>
        /// the source, if one was found, otherwise %NULL
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Source" type="GSource*" managed-name="Source" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GLib.Source.UnmanagedStruct* g_main_context_find_source_by_user_data(
        /* <type name="MainContext" type="GMainContext*" managed-name="MainContext" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.MainContext.UnmanagedStruct* context,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr userData);
        partial void CheckFindSourceByUserDataArgs(System.IntPtr userData);

        /// <include file="MainContext.xmldoc" path="declaration/member[@name='MainContext.FindSourceByUserData(System.IntPtr)']/*" />
        public GISharp.Lib.GLib.Source FindSourceByUserData(System.IntPtr userData)
        {
            CheckFindSourceByUserDataArgs(userData);
            var context_ = (GISharp.Lib.GLib.MainContext.UnmanagedStruct*)UnsafeHandle;
            var userData_ = (System.IntPtr)userData;
            var ret_ = g_main_context_find_source_by_user_data(context_,userData_);
            var ret = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Source>((System.IntPtr)ret_, GISharp.Runtime.Transfer.None)!;
            return ret;
        }

        /// <summary>
        /// Invokes a function in such a way that @context is owned during the
        /// invocation of @function.
        /// </summary>
        /// <remarks>
        /// This function is the same as g_main_context_invoke() except that it
        /// lets you specify the priority in case @function ends up being
        /// scheduled as an idle and also lets you give a #GDestroyNotify for @data.
        /// 
        /// @notify should not assume that it is called from any particular
        /// thread or with any particular context acquired.
        /// </remarks>
        /// <param name="context">
        /// a #GMainContext, or %NULL
        /// </param>
        /// <param name="priority">
        /// the priority at which to run @function
        /// </param>
        /// <param name="function">
        /// function to call
        /// </param>
        /// <param name="data">
        /// data to pass to @function
        /// </param>
        /// <param name="notify">
        /// a function to call when @data is no longer in use, or %NULL.
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.28")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_main_context_invoke_full(
        /* <type name="MainContext" type="GMainContext*" managed-name="MainContext" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.GLib.MainContext.UnmanagedStruct* context,
        /* <type name="gint" type="gint" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        int priority,
        /* <type name="SourceFunc" type="GSourceFunc" managed-name="SourceFunc" /> */
        /* transfer-ownership:none scope:notified closure:2 destroy:3 direction:in */
        System.IntPtr function,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr data,
        /* <type name="DestroyNotify" type="GDestroyNotify" managed-name="DestroyNotify" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:async direction:in */
        System.IntPtr notify);
        partial void CheckInvokeFullArgs(int priority, GISharp.Lib.GLib.SourceFunc function);

        /// <include file="MainContext.xmldoc" path="declaration/member[@name='MainContext.InvokeFull(int,GISharp.Lib.GLib.SourceFunc)']/*" />
        [GISharp.Runtime.SinceAttribute("2.28")]
        public void InvokeFull(int priority, GISharp.Lib.GLib.SourceFunc function)
        {
            CheckInvokeFullArgs(priority, function);
            var context_ = (GISharp.Lib.GLib.MainContext.UnmanagedStruct*)UnsafeHandle;
            var priority_ = (int)priority;
            var (function_, notify_, data_) = GISharp.Lib.GLib.SourceFuncMarshal.ToUnmanagedFunctionPointer(function, GISharp.Runtime.CallbackScope.Notified);
            g_main_context_invoke_full(context_, priority_, function_, data_, notify_);
        }

        /// <summary>
        /// Determines whether this thread holds the (recursive)
        /// ownership of this #GMainContext. This is useful to
        /// know before waiting on another thread that may be
        /// blocking to get ownership of @context.
        /// </summary>
        /// <param name="context">
        /// a #GMainContext
        /// </param>
        /// <returns>
        /// %TRUE if current thread is owner of @context.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.10")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_main_context_is_owner(
        /* <type name="MainContext" type="GMainContext*" managed-name="MainContext" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.MainContext.UnmanagedStruct* context);
        partial void CheckGetIsOwnerArgs();

        [GISharp.Runtime.SinceAttribute("2.10")]
        private System.Boolean GetIsOwner()
        {
            CheckGetIsOwnerArgs();
            var context_ = (GISharp.Lib.GLib.MainContext.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_main_context_is_owner(context_);
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Runs a single iteration for the given main loop. This involves
        /// checking to see if any event sources are ready to be processed,
        /// then if no events sources are ready and @may_block is %TRUE, waiting
        /// for a source to become ready, then dispatching the highest priority
        /// events sources that are ready. Otherwise, if @may_block is %FALSE
        /// sources are not waited to become ready, only those highest priority
        /// events sources will be dispatched (if any), that are ready at this
        /// given moment without further waiting.
        /// </summary>
        /// <remarks>
        /// Note that even when @may_block is %TRUE, it is still possible for
        /// g_main_context_iteration() to return %FALSE, since the wait may
        /// be interrupted for other reasons than an event source becoming ready.
        /// </remarks>
        /// <param name="context">
        /// a #GMainContext (if %NULL, the default context will be used)
        /// </param>
        /// <param name="mayBlock">
        /// whether the call may block.
        /// </param>
        /// <returns>
        /// %TRUE if events were dispatched.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_main_context_iteration(
        /* <type name="MainContext" type="GMainContext*" managed-name="MainContext" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.GLib.MainContext.UnmanagedStruct* context,
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.Boolean mayBlock);
        partial void CheckIterationArgs(System.Boolean mayBlock);

        /// <include file="MainContext.xmldoc" path="declaration/member[@name='MainContext.Iteration(System.Boolean)']/*" />
        public System.Boolean Iteration(System.Boolean mayBlock)
        {
            CheckIterationArgs(mayBlock);
            var context_ = (GISharp.Lib.GLib.MainContext.UnmanagedStruct*)UnsafeHandle;
            var mayBlock_ = GISharp.Runtime.BooleanExtensions.ToBoolean(mayBlock);
            var ret_ = g_main_context_iteration(context_,mayBlock_);
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Checks if any sources have pending events for the given context.
        /// </summary>
        /// <param name="context">
        /// a #GMainContext (if %NULL, the default context will be used)
        /// </param>
        /// <returns>
        /// %TRUE if events are pending.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_main_context_pending(
        /* <type name="MainContext" type="GMainContext*" managed-name="MainContext" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.GLib.MainContext.UnmanagedStruct* context);
        partial void CheckPendingArgs();

        /// <include file="MainContext.xmldoc" path="declaration/member[@name='MainContext.Pending()']/*" />
        public System.Boolean Pending()
        {
            CheckPendingArgs();
            var context_ = (GISharp.Lib.GLib.MainContext.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_main_context_pending(context_);
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Pops @context off the thread-default context stack (verifying that
        /// it was on the top of the stack).
        /// </summary>
        /// <param name="context">
        /// a #GMainContext object, or %NULL
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.22")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_main_context_pop_thread_default(
        /* <type name="MainContext" type="GMainContext*" managed-name="MainContext" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.GLib.MainContext.UnmanagedStruct* context);
        partial void CheckPopThreadDefaultArgs();

        /// <include file="MainContext.xmldoc" path="declaration/member[@name='MainContext.PopThreadDefault()']/*" />
        [GISharp.Runtime.SinceAttribute("2.22")]
        public void PopThreadDefault()
        {
            CheckPopThreadDefaultArgs();
            var context_ = (GISharp.Lib.GLib.MainContext.UnmanagedStruct*)UnsafeHandle;
            g_main_context_pop_thread_default(context_);
        }

        /// <summary>
        /// Prepares to poll sources within a main loop. The resulting information
        /// for polling is determined by calling g_main_context_query ().
        /// </summary>
        /// <remarks>
        /// You must have successfully acquired the context with
        /// g_main_context_acquire() before you may call this function.
        /// </remarks>
        /// <param name="context">
        /// a #GMainContext
        /// </param>
        /// <param name="priority">
        /// location to store priority of highest priority
        ///            source already ready.
        /// </param>
        /// <returns>
        /// %TRUE if some source is ready to be dispatched
        ///               prior to polling.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_main_context_prepare(
        /* <type name="MainContext" type="GMainContext*" managed-name="MainContext" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.MainContext.UnmanagedStruct* context,
        /* <type name="gint" type="gint*" managed-name="System.Int32" /> */
        /* direction:out caller-allocates:0 transfer-ownership:full optional:1 allow-none:1 */
        int* priority);
        partial void CheckTryPrepareArgs();

        /// <include file="MainContext.xmldoc" path="declaration/member[@name='MainContext.TryPrepare(int)']/*" />
        public System.Boolean TryPrepare(out int priority)
        {
            CheckTryPrepareArgs();
            var context_ = (GISharp.Lib.GLib.MainContext.UnmanagedStruct*)UnsafeHandle;
            int priority_;
            var ret_ = g_main_context_prepare(context_,&priority_);
            priority = (int)priority_;
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Acquires @context and sets it as the thread-default context for the
        /// current thread. This will cause certain asynchronous operations
        /// (such as most [gio][gio]-based I/O) which are
        /// started in this thread to run under @context and deliver their
        /// results to its main loop, rather than running under the global
        /// default context in the main thread. Note that calling this function
        /// changes the context returned by g_main_context_get_thread_default(),
        /// not the one returned by g_main_context_default(), so it does not affect
        /// the context used by functions like g_idle_add().
        /// </summary>
        /// <remarks>
        /// Normally you would call this function shortly after creating a new
        /// thread, passing it a #GMainContext which will be run by a
        /// #GMainLoop in that thread, to set a new default context for all
        /// async operations in that thread. In this case you may not need to
        /// ever call g_main_context_pop_thread_default(), assuming you want the
        /// new #GMainContext to be the default for the whole lifecycle of the
        /// thread.
        /// 
        /// If you don't have control over how the new thread was created (e.g.
        /// in the new thread isn't newly created, or if the thread life
        /// cycle is managed by a #GThreadPool), it is always suggested to wrap
        /// the logic that needs to use the new #GMainContext inside a
        /// g_main_context_push_thread_default() / g_main_context_pop_thread_default()
        /// pair, otherwise threads that are re-used will end up never explicitly
        /// releasing the #GMainContext reference they hold.
        /// 
        /// In some cases you may want to schedule a single operation in a
        /// non-default context, or temporarily use a non-default context in
        /// the main thread. In that case, you can wrap the call to the
        /// asynchronous operation inside a
        /// g_main_context_push_thread_default() /
        /// g_main_context_pop_thread_default() pair, but it is up to you to
        /// ensure that no other asynchronous operations accidentally get
        /// started while the non-default context is active.
        /// 
        /// Beware that libraries that predate this function may not correctly
        /// handle being used from a thread with a thread-default context. Eg,
        /// see g_file_supports_thread_contexts().
        /// </remarks>
        /// <param name="context">
        /// a #GMainContext, or %NULL for the global default context
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.22")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_main_context_push_thread_default(
        /* <type name="MainContext" type="GMainContext*" managed-name="MainContext" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.GLib.MainContext.UnmanagedStruct* context);
        partial void CheckPushThreadDefaultArgs();

        /// <include file="MainContext.xmldoc" path="declaration/member[@name='MainContext.PushThreadDefault()']/*" />
        [GISharp.Runtime.SinceAttribute("2.22")]
        public void PushThreadDefault()
        {
            CheckPushThreadDefaultArgs();
            var context_ = (GISharp.Lib.GLib.MainContext.UnmanagedStruct*)UnsafeHandle;
            g_main_context_push_thread_default(context_);
        }

        /// <summary>
        /// Determines information necessary to poll this main loop.
        /// </summary>
        /// <remarks>
        /// You must have successfully acquired the context with
        /// g_main_context_acquire() before you may call this function.
        /// </remarks>
        /// <param name="context">
        /// a #GMainContext
        /// </param>
        /// <param name="maxPriority">
        /// maximum priority source to check
        /// </param>
        /// <param name="timeout">
        /// location to store timeout to be used in polling
        /// </param>
        /// <param name="fds">
        /// location to
        ///       store #GPollFD records that need to be polled.
        /// </param>
        /// <param name="nFds">
        /// length of @fds.
        /// </param>
        /// <returns>
        /// the number of records actually stored in @fds,
        ///   or, if more than @n_fds records need to be stored, the number
        ///   of records that need to be stored.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gint" type="gint" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        private static extern int g_main_context_query(
        /* <type name="MainContext" type="GMainContext*" managed-name="MainContext" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.MainContext.UnmanagedStruct* context,
        /* <type name="gint" type="gint" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        int maxPriority,
        /* <type name="gint" type="gint*" managed-name="System.Int32" /> */
        /* direction:out caller-allocates:0 transfer-ownership:full */
        int* timeout,
        /* <array length="3" zero-terminated="0" type="GPollFD*" managed-name="GISharp.Runtime.CArray" is-pointer="1">
*   <type name="PollFD" type="GPollFD" managed-name="PollFD" />
* </array> */
        /* direction:out caller-allocates:1 transfer-ownership:none */
        GISharp.Lib.GLib.PollFD* fds,
        /* <type name="gint" type="gint" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        int nFds);
        partial void CheckQueryArgs(int maxPriority);

        /// <include file="MainContext.xmldoc" path="declaration/member[@name='MainContext.Query(int,int,System.Span&lt;GISharp.Lib.GLib.PollFD&gt;)']/*" />
        public int Query(int maxPriority, out int timeout, System.Span<GISharp.Lib.GLib.PollFD> fds)
        {
            fixed (GISharp.Lib.GLib.PollFD* fdsData_ = fds)
            {
                CheckQueryArgs(maxPriority);
                var context_ = (GISharp.Lib.GLib.MainContext.UnmanagedStruct*)UnsafeHandle;
                var maxPriority_ = (int)maxPriority;
                var fds_ = (GISharp.Lib.GLib.PollFD*)fdsData_;
                var nFds_ = (int)fds.Length;
                int timeout_;
                var ret_ = g_main_context_query(context_,maxPriority_,&timeout_,fds_,nFds_);
                timeout = (int)timeout_;
                var ret = (int)ret_;
                return ret;
            }
        }

        /// <summary>
        /// Increases the reference count on a #GMainContext object by one.
        /// </summary>
        /// <param name="context">
        /// a #GMainContext
        /// </param>
        /// <returns>
        /// the @context that was passed in (since 2.6)
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="MainContext" type="GMainContext*" managed-name="MainContext" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GLib.MainContext.UnmanagedStruct* g_main_context_ref(
        /* <type name="MainContext" type="GMainContext*" managed-name="MainContext" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.MainContext.UnmanagedStruct* context);

        /// <summary>
        /// Takes ownership of the unmanaged pointer without freeing it.
        /// The managed object can no longer be used (will throw disposed exception).
        /// </summary>
        public override System.IntPtr Take() => (System.IntPtr)g_main_context_ref((GISharp.Lib.GLib.MainContext.UnmanagedStruct*)UnsafeHandle);

        /// <summary>
        /// Releases ownership of a context previously acquired by this thread
        /// with g_main_context_acquire(). If the context was acquired multiple
        /// times, the ownership will be released only when g_main_context_release()
        /// is called as many times as it was acquired.
        /// </summary>
        /// <param name="context">
        /// a #GMainContext
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_main_context_release(
        /* <type name="MainContext" type="GMainContext*" managed-name="MainContext" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.MainContext.UnmanagedStruct* context);
        partial void CheckReleaseArgs();

        /// <include file="MainContext.xmldoc" path="declaration/member[@name='MainContext.Release()']/*" />
        public void Release()
        {
            CheckReleaseArgs();
            var context_ = (GISharp.Lib.GLib.MainContext.UnmanagedStruct*)UnsafeHandle;
            g_main_context_release(context_);
        }

        /// <summary>
        /// Removes file descriptor from the set of file descriptors to be
        /// polled for a particular context.
        /// </summary>
        /// <param name="context">
        /// a #GMainContext
        /// </param>
        /// <param name="fd">
        /// a #GPollFD descriptor previously added with g_main_context_add_poll()
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_main_context_remove_poll(
        /* <type name="MainContext" type="GMainContext*" managed-name="MainContext" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.MainContext.UnmanagedStruct* context,
        /* <type name="PollFD" type="GPollFD*" managed-name="PollFD" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.PollFD* fd);
        partial void CheckRemovePollArgs(GISharp.Lib.GLib.PollFD fd);

        /// <include file="MainContext.xmldoc" path="declaration/member[@name='MainContext.RemovePoll(GISharp.Lib.GLib.PollFD)']/*" />
        public void RemovePoll(GISharp.Lib.GLib.PollFD fd)
        {
            CheckRemovePollArgs(fd);
            var context_ = (GISharp.Lib.GLib.MainContext.UnmanagedStruct*)UnsafeHandle;
            var fd_ = &fd;
            g_main_context_remove_poll(context_, fd_);
        }

        /// <summary>
        /// Decreases the reference count on a #GMainContext object by one. If
        /// the result is zero, free the context and free all associated memory.
        /// </summary>
        /// <param name="context">
        /// a #GMainContext
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_main_context_unref(
        /* <type name="MainContext" type="GMainContext*" managed-name="MainContext" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.MainContext.UnmanagedStruct* context);

        /// <inheritdoc/>
        protected override void Dispose(bool disposing)
        {
            if (handle != System.IntPtr.Zero)
            {
                g_main_context_unref((UnmanagedStruct*)handle);
            }

            base.Dispose(disposing);
        }

        /// <summary>
        /// Tries to become the owner of the specified context,
        /// as with g_main_context_acquire(). But if another thread
        /// is the owner, atomically drop @mutex and wait on @cond until
        /// that owner releases ownership or until @cond is signaled, then
        /// try again (once) to become the owner.
        /// </summary>
        /// <param name="context">
        /// a #GMainContext
        /// </param>
        /// <param name="cond">
        /// a condition variable
        /// </param>
        /// <param name="mutex">
        /// a mutex, currently held
        /// </param>
        /// <returns>
        /// %TRUE if the operation succeeded, and
        ///   this thread is now the owner of @context.
        /// </returns>
        [System.ObsoleteAttribute("Use g_main_context_is_owner() and separate locking instead.")]
        [GISharp.Runtime.DeprecatedSinceAttribute("2.58")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_main_context_wait(
        /* <type name="MainContext" type="GMainContext*" managed-name="MainContext" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.MainContext.UnmanagedStruct* context,
        /* <type name="Cond" type="GCond*" managed-name="Cond" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Cond* cond,
        /* <type name="Mutex" type="GMutex*" managed-name="Mutex" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Mutex* mutex);
        partial void CheckWaitArgs(GISharp.Lib.GLib.Cond cond, GISharp.Lib.GLib.Mutex mutex);

        /// <include file="MainContext.xmldoc" path="declaration/member[@name='MainContext.Wait(GISharp.Lib.GLib.Cond,GISharp.Lib.GLib.Mutex)']/*" />
        [System.ObsoleteAttribute("Use g_main_context_is_owner() and separate locking instead.")]
        [GISharp.Runtime.DeprecatedSinceAttribute("2.58")]
        public System.Boolean Wait(GISharp.Lib.GLib.Cond cond, GISharp.Lib.GLib.Mutex mutex)
        {
            CheckWaitArgs(cond, mutex);
            var context_ = (GISharp.Lib.GLib.MainContext.UnmanagedStruct*)UnsafeHandle;
            var cond_ = &cond;
            var mutex_ = &mutex;
            var ret_ = g_main_context_wait(context_,cond_,mutex_);
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// If @context is currently blocking in g_main_context_iteration()
        /// waiting for a source to become ready, cause it to stop blocking
        /// and return.  Otherwise, cause the next invocation of
        /// g_main_context_iteration() to return without blocking.
        /// </summary>
        /// <remarks>
        /// This API is useful for low-level control over #GMainContext; for
        /// example, integrating it with main loop implementations such as
        /// #GMainLoop.
        /// 
        /// Another related use for this function is when implementing a main
        /// loop with a termination condition, computed from multiple threads:
        /// 
        /// |[&lt;!-- language="C" --&gt;
        ///   #define NUM_TASKS 10
        ///   static volatile gint tasks_remaining = NUM_TASKS;
        ///   ...
        ///  
        ///   while (g_atomic_int_get (&amp;tasks_remaining) != 0)
        ///     g_main_context_iteration (NULL, TRUE);
        /// ]|
        ///  
        /// Then in a thread:
        /// |[&lt;!-- language="C" --&gt;
        ///   perform_work();
        /// 
        ///   if (g_atomic_int_dec_and_test (&amp;tasks_remaining))
        ///     g_main_context_wakeup (NULL);
        /// ]|
        /// </remarks>
        /// <param name="context">
        /// a #GMainContext
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_main_context_wakeup(
        /* <type name="MainContext" type="GMainContext*" managed-name="MainContext" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.MainContext.UnmanagedStruct* context);
        partial void CheckWakeupArgs();

        /// <include file="MainContext.xmldoc" path="declaration/member[@name='MainContext.Wakeup()']/*" />
        public void Wakeup()
        {
            CheckWakeupArgs();
            var context_ = (GISharp.Lib.GLib.MainContext.UnmanagedStruct*)UnsafeHandle;
            g_main_context_wakeup(context_);
        }
    }
}