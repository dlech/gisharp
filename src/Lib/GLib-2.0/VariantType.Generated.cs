// SPDX-License-Identifier: MIT
// ATTENTION: This file is automatically generated. Do not edit manually.
#nullable enable
namespace GISharp.Lib.GLib
{
    /// <include file="VariantType.xmldoc" path="declaration/member[@name='VariantType']/*" />
    [GISharp.Runtime.GTypeAttribute("GVariantType", IsProxyForUnmanagedType = true)]
    public sealed unsafe partial class VariantType : GISharp.Runtime.Boxed, System.IEquatable<VariantType>
    {
        private static readonly GISharp.Runtime.GType _GType = g_variant_type_get_gtype();

        /// <summary>
        /// The unmanaged data structure.
        /// </summary>
        public struct UnmanagedStruct
        {
        }

        /// <include file="VariantType.xmldoc" path="declaration/member[@name='VariantType.StringLength']/*" />
        public int StringLength { get => GetStringLength(); }

        /// <include file="VariantType.xmldoc" path="declaration/member[@name='VariantType.IsArray']/*" />
        public bool IsArray { get => GetIsArray(); }

        /// <include file="VariantType.xmldoc" path="declaration/member[@name='VariantType.IsBasic']/*" />
        public bool IsBasic { get => GetIsBasic(); }

        /// <include file="VariantType.xmldoc" path="declaration/member[@name='VariantType.IsContainer']/*" />
        public bool IsContainer { get => GetIsContainer(); }

        /// <include file="VariantType.xmldoc" path="declaration/member[@name='VariantType.IsDefinite']/*" />
        public bool IsDefinite { get => GetIsDefinite(); }

        /// <include file="VariantType.xmldoc" path="declaration/member[@name='VariantType.IsDictEntry']/*" />
        public bool IsDictEntry { get => GetIsDictEntry(); }

        /// <include file="VariantType.xmldoc" path="declaration/member[@name='VariantType.IsMaybe']/*" />
        public bool IsMaybe { get => GetIsMaybe(); }

        /// <include file="VariantType.xmldoc" path="declaration/member[@name='VariantType.IsTuple']/*" />
        public bool IsTuple { get => GetIsTuple(); }

        /// <include file="VariantType.xmldoc" path="declaration/member[@name='VariantType.IsVariant']/*" />
        public bool IsVariant { get => GetIsVariant(); }

        /// <summary>
        /// For internal runtime use only.
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        public VariantType(System.IntPtr handle, GISharp.Runtime.Transfer ownership) : base(handle)
        {
            if (ownership == GISharp.Runtime.Transfer.None)
            {
                this.handle = (System.IntPtr)g_variant_type_copy((UnmanagedStruct*)handle);
            }
        }

        /// <summary>
        /// Creates a new #GVariantType corresponding to the type string given
        /// by @type_string.  It is appropriate to call g_variant_type_free() on
        /// the return value.
        /// </summary>
        /// <remarks>
        /// <para>
        /// It is a programmer error to call this function with an invalid type
        /// string.  Use g_variant_type_string_is_valid() if you are unsure.
        /// </para>
        /// </remarks>
        /// <param name="typeString">
        /// a valid GVariant type string
        /// </param>
        /// <returns>
        /// a new #GVariantType
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="VariantType" type="GVariantType*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GLib.VariantType.UnmanagedStruct* g_variant_type_new(
        /* <type name="utf8" type="const gchar*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* typeString);
        static partial void CheckNewArgs(GISharp.Lib.GLib.UnownedUtf8 typeString);

        [GISharp.Runtime.SinceAttribute("2.24")]
        static GISharp.Lib.GLib.VariantType.UnmanagedStruct* New(GISharp.Lib.GLib.UnownedUtf8 typeString)
        {
            CheckNewArgs(typeString);
            var typeString_ = (byte*)typeString.UnsafeHandle;
            var ret_ = g_variant_type_new(typeString_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            return ret_;
        }

        /// <include file="VariantType.xmldoc" path="declaration/member[@name='VariantType.VariantType(GISharp.Lib.GLib.UnownedUtf8)']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public VariantType(GISharp.Lib.GLib.UnownedUtf8 typeString) : this((System.IntPtr)New(typeString), GISharp.Runtime.Transfer.Full)
        {
        }

        /// <summary>
        /// Constructs the type corresponding to an array of elements of the
        /// type @type.
        /// </summary>
        /// <remarks>
        /// <para>
        /// It is appropriate to call g_variant_type_free() on the return value.
        /// </para>
        /// </remarks>
        /// <param name="element">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// a new array #GVariantType
        /// 
        /// Since 2.24
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="VariantType" type="GVariantType*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GLib.VariantType.UnmanagedStruct* g_variant_type_new_array(
        /* <type name="VariantType" type="const GVariantType*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.VariantType.UnmanagedStruct* element);
        static partial void CheckNewArrayArgs(GISharp.Lib.GLib.VariantType element);

        static GISharp.Lib.GLib.VariantType.UnmanagedStruct* NewArray(GISharp.Lib.GLib.VariantType element)
        {
            CheckNewArrayArgs(element);
            var element_ = (GISharp.Lib.GLib.VariantType.UnmanagedStruct*)element.UnsafeHandle;
            var ret_ = g_variant_type_new_array(element_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            return ret_;
        }

        /// <include file="VariantType.xmldoc" path="declaration/member[@name='VariantType.VariantType(GISharp.Lib.GLib.VariantType)']/*" />
        public VariantType(GISharp.Lib.GLib.VariantType element) : this((System.IntPtr)NewArray(element), GISharp.Runtime.Transfer.Full)
        {
        }

        /// <summary>
        /// Constructs the type corresponding to a dictionary entry with a key
        /// of type @key and a value of type @value.
        /// </summary>
        /// <remarks>
        /// <para>
        /// It is appropriate to call g_variant_type_free() on the return value.
        /// </para>
        /// </remarks>
        /// <param name="key">
        /// a basic #GVariantType
        /// </param>
        /// <param name="value">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// a new dictionary entry #GVariantType
        /// 
        /// Since 2.24
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="VariantType" type="GVariantType*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GLib.VariantType.UnmanagedStruct* g_variant_type_new_dict_entry(
        /* <type name="VariantType" type="const GVariantType*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.VariantType.UnmanagedStruct* key,
        /* <type name="VariantType" type="const GVariantType*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.VariantType.UnmanagedStruct* value);
        static partial void CheckNewDictEntryArgs(GISharp.Lib.GLib.VariantType key, GISharp.Lib.GLib.VariantType value);

        static GISharp.Lib.GLib.VariantType.UnmanagedStruct* NewDictEntry(GISharp.Lib.GLib.VariantType key, GISharp.Lib.GLib.VariantType value)
        {
            CheckNewDictEntryArgs(key, value);
            var key_ = (GISharp.Lib.GLib.VariantType.UnmanagedStruct*)key.UnsafeHandle;
            var value_ = (GISharp.Lib.GLib.VariantType.UnmanagedStruct*)value.UnsafeHandle;
            var ret_ = g_variant_type_new_dict_entry(key_,value_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            return ret_;
        }

        /// <include file="VariantType.xmldoc" path="declaration/member[@name='VariantType.VariantType(GISharp.Lib.GLib.VariantType,GISharp.Lib.GLib.VariantType)']/*" />
        public VariantType(GISharp.Lib.GLib.VariantType key, GISharp.Lib.GLib.VariantType value) : this((System.IntPtr)NewDictEntry(key, value), GISharp.Runtime.Transfer.Full)
        {
        }

        /// <summary>
        /// Constructs the type corresponding to a maybe instance containing
        /// type @type or Nothing.
        /// </summary>
        /// <remarks>
        /// <para>
        /// It is appropriate to call g_variant_type_free() on the return value.
        /// </para>
        /// </remarks>
        /// <param name="element">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// a new maybe #GVariantType
        /// 
        /// Since 2.24
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="VariantType" type="GVariantType*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GLib.VariantType.UnmanagedStruct* g_variant_type_new_maybe(
        /* <type name="VariantType" type="const GVariantType*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.VariantType.UnmanagedStruct* element);
        static partial void CheckNewMaybeArgs(GISharp.Lib.GLib.VariantType element);

        static GISharp.Lib.GLib.VariantType.UnmanagedStruct* NewMaybe(GISharp.Lib.GLib.VariantType element)
        {
            CheckNewMaybeArgs(element);
            var element_ = (GISharp.Lib.GLib.VariantType.UnmanagedStruct*)element.UnsafeHandle;
            var ret_ = g_variant_type_new_maybe(element_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            return ret_;
        }

        /// <include file="VariantType.xmldoc" path="declaration/member[@name='VariantType.VariantType(GISharp.Lib.GLib.VariantType)']/*" />
        public VariantType(GISharp.Lib.GLib.VariantType element) : this((System.IntPtr)NewMaybe(element), GISharp.Runtime.Transfer.Full)
        {
        }

        /// <summary>
        /// Constructs a new tuple type, from @items.
        /// </summary>
        /// <remarks>
        /// <para>
        /// @length is the number of items in @items, or -1 to indicate that
        /// @items is %NULL-terminated.
        /// </para>
        /// <para>
        /// It is appropriate to call g_variant_type_free() on the return value.
        /// </para>
        /// </remarks>
        /// <param name="items">
        /// an array of #GVariantTypes, one for each item
        /// </param>
        /// <param name="length">
        /// the length of @items, or -1
        /// </param>
        /// <returns>
        /// a new tuple #GVariantType
        /// 
        /// Since 2.24
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="VariantType" type="GVariantType*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GLib.VariantType.UnmanagedStruct* g_variant_type_new_tuple(
        /* <array length="1" zero-terminated="0" type="const GVariantType* const*" is-pointer="1">
*   <type name="VariantType" type="GVariantType*" is-pointer="1" />
* </array> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.VariantType.UnmanagedStruct** items,
        /* <type name="gint" type="gint" /> */
        /* transfer-ownership:none direction:in */
        int length);
        static partial void CheckNewTupleArgs(GISharp.Runtime.UnownedCPtrArray<GISharp.Lib.GLib.VariantType> items);

        static GISharp.Lib.GLib.VariantType.UnmanagedStruct* NewTuple(GISharp.Runtime.UnownedCPtrArray<GISharp.Lib.GLib.VariantType> items)
        {
            fixed (System.IntPtr* itemsData_ = items)
            {
                CheckNewTupleArgs(items);
                var items_ = (GISharp.Lib.GLib.VariantType.UnmanagedStruct**)itemsData_;
                var length_ = (int)items.Length;
                var ret_ = g_variant_type_new_tuple(items_,length_);
                GISharp.Runtime.GMarshal.PopUnhandledException();
                return ret_;
            }
        }

        /// <include file="VariantType.xmldoc" path="declaration/member[@name='VariantType.VariantType(GISharp.Runtime.UnownedCPtrArray&lt;GISharp.Lib.GLib.VariantType&gt;)']/*" />
        public VariantType(GISharp.Runtime.UnownedCPtrArray<GISharp.Lib.GLib.VariantType> items) : this((System.IntPtr)NewTuple(items), GISharp.Runtime.Transfer.Full)
        {
        }

        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="VariantType" type="const GVariantType*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GLib.VariantType.UnmanagedStruct* g_variant_type_checked_(
/* <type name="utf8" type="const gchar*" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
byte* arg0);
        static partial void CheckCheckedArgs(GISharp.Lib.GLib.UnownedUtf8 arg0);

        /// <include file="VariantType.xmldoc" path="declaration/member[@name='VariantType.Checked(GISharp.Lib.GLib.UnownedUtf8)']/*" />
        public static GISharp.Lib.GLib.VariantType Checked(GISharp.Lib.GLib.UnownedUtf8 arg0)
        {
            CheckCheckedArgs(arg0);
            var arg0_ = (byte*)arg0.UnsafeHandle;
            var ret_ = g_variant_type_checked_(arg0_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Lib.GLib.VariantType.GetInstance<GISharp.Lib.GLib.VariantType>((System.IntPtr)ret_, GISharp.Runtime.Transfer.None)!;
            return ret;
        }

        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gsize" type="gsize" /> */
        /* transfer-ownership:none direction:in */
        private static extern nuint g_variant_type_string_get_depth_(
/* <type name="utf8" type="const gchar*" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
byte* typeString);
        static partial void CheckStringGetDepthArgs(GISharp.Lib.GLib.UnownedUtf8 typeString);

        /// <include file="VariantType.xmldoc" path="declaration/member[@name='VariantType.StringGetDepth(GISharp.Lib.GLib.UnownedUtf8)']/*" />
        public static int StringGetDepth(GISharp.Lib.GLib.UnownedUtf8 typeString)
        {
            CheckStringGetDepthArgs(typeString);
            var typeString_ = (byte*)typeString.UnsafeHandle;
            var ret_ = g_variant_type_string_get_depth_(typeString_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = (int)ret_;
            return ret;
        }

        /// <summary>
        /// Checks if @type_string is a valid GVariant type string.  This call is
        /// equivalent to calling g_variant_type_string_scan() and confirming
        /// that the following character is a nul terminator.
        /// </summary>
        /// <param name="typeString">
        /// a pointer to any string
        /// </param>
        /// <returns>
        /// %TRUE if @type_string is exactly one valid type string
        /// 
        /// Since 2.24
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_variant_type_string_is_valid(
        /* <type name="utf8" type="const gchar*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* typeString);
        static partial void CheckStringIsValidArgs(GISharp.Lib.GLib.UnownedUtf8 typeString);

        /// <include file="VariantType.xmldoc" path="declaration/member[@name='VariantType.StringIsValid(GISharp.Lib.GLib.UnownedUtf8)']/*" />
        public static bool StringIsValid(GISharp.Lib.GLib.UnownedUtf8 typeString)
        {
            CheckStringIsValidArgs(typeString);
            var typeString_ = (byte*)typeString.UnsafeHandle;
            var ret_ = g_variant_type_string_is_valid(typeString_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Scan for a single complete and valid GVariant type string in @string.
        /// The memory pointed to by @limit (or bytes beyond it) is never
        /// accessed.
        /// </summary>
        /// <remarks>
        /// <para>
        /// If a valid type string is found, @endptr is updated to point to the
        /// first character past the end of the string that was found and %TRUE
        /// is returned.
        /// </para>
        /// <para>
        /// If there is no valid type string starting at @string, or if the type
        /// string does not end before @limit then %FALSE is returned.
        /// </para>
        /// <para>
        /// For the simple case of checking if a string is a valid type string,
        /// see g_variant_type_string_is_valid().
        /// </para>
        /// </remarks>
        /// <param name="string">
        /// a pointer to any string
        /// </param>
        /// <param name="limit">
        /// the end of @string, or %NULL
        /// </param>
        /// <param name="endptr">
        /// location to store the end pointer, or %NULL
        /// </param>
        /// <returns>
        /// %TRUE if a valid type string was found
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.24")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_variant_type_string_scan(
        /* <type name="utf8" type="const gchar*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        byte* @string,
        /* <type name="utf8" type="const gchar*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        byte* limit,
        /* <type name="utf8" type="const gchar**" is-pointer="1" /> */
        /* direction:out caller-allocates:0 transfer-ownership:full optional:1 allow-none:1 */
        byte** endptr);
        static partial void CheckTryStringScanArgs(GISharp.Lib.GLib.UnownedUtf8 @string, GISharp.Lib.GLib.NullableUnownedUtf8 limit);

        /// <include file="VariantType.xmldoc" path="declaration/member[@name='VariantType.TryStringScan(GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.GLib.NullableUnownedUtf8,GISharp.Lib.GLib.Utf8)']/*" />
        [GISharp.Runtime.SinceAttribute("2.24")]
        public static bool TryStringScan(GISharp.Lib.GLib.UnownedUtf8 @string, GISharp.Lib.GLib.NullableUnownedUtf8 limit, out GISharp.Lib.GLib.Utf8 endptr)
        {
            CheckTryStringScanArgs(@string, limit);
            var @string_ = (byte*)@string.UnsafeHandle;
            var limit_ = (byte*)limit.UnsafeHandle;
            byte* endptr_;
            var ret_ = g_variant_type_string_scan(@string_,limit_,&endptr_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            endptr = GISharp.Lib.GLib.Utf8.GetInstance<GISharp.Lib.GLib.Utf8>((System.IntPtr)endptr_, GISharp.Runtime.Transfer.Full)!;
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="GType" type="GType" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Runtime.GType g_variant_type_get_gtype();

        /// <summary>
        /// Makes a copy of a #GVariantType.  It is appropriate to call
        /// g_variant_type_free() on the return value.  @type may not be %NULL.
        /// </summary>
        /// <param name="type">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// a new #GVariantType
        /// 
        /// Since 2.24
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="VariantType" type="GVariantType*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GLib.VariantType.UnmanagedStruct* g_variant_type_copy(
        /* <type name="VariantType" type="const GVariantType*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.VariantType.UnmanagedStruct* type);

        /// <summary>
        /// Returns a newly-allocated copy of the type string corresponding to
        /// @type.  The returned string is nul-terminated.  It is appropriate to
        /// call g_free() on the return value.
        /// </summary>
        /// <param name="type">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// the corresponding type string
        /// 
        /// Since 2.24
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="gchar*" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern byte* g_variant_type_dup_string(
        /* <type name="VariantType" type="const GVariantType*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.VariantType.UnmanagedStruct* type);
        partial void CheckDupStringArgs();

        /// <include file="VariantType.xmldoc" path="declaration/member[@name='VariantType.DupString()']/*" />
        public GISharp.Lib.GLib.Utf8 DupString()
        {
            CheckDupStringArgs();
            var type_ = (GISharp.Lib.GLib.VariantType.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_variant_type_dup_string(type_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Lib.GLib.Utf8.GetInstance<GISharp.Lib.GLib.Utf8>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Determines the element type of an array or maybe type.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This function may only be used with array or maybe types.
        /// </para>
        /// </remarks>
        /// <param name="type">
        /// an array or maybe #GVariantType
        /// </param>
        /// <returns>
        /// the element type of @type
        /// 
        /// Since 2.24
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="VariantType" type="const GVariantType*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GLib.VariantType.UnmanagedStruct* g_variant_type_element(
        /* <type name="VariantType" type="const GVariantType*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.VariantType.UnmanagedStruct* type);
        partial void CheckElementArgs();

        /// <include file="VariantType.xmldoc" path="declaration/member[@name='VariantType.Element()']/*" />
        public GISharp.Lib.GLib.VariantType Element()
        {
            CheckElementArgs();
            var type_ = (GISharp.Lib.GLib.VariantType.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_variant_type_element(type_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Lib.GLib.VariantType.GetInstance<GISharp.Lib.GLib.VariantType>((System.IntPtr)ret_, GISharp.Runtime.Transfer.None)!;
            return ret;
        }

        /// <summary>
        /// Compares @type1 and @type2 for equality.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Only returns %TRUE if the types are exactly equal.  Even if one type
        /// is an indefinite type and the other is a subtype of it, %FALSE will
        /// be returned if they are not exactly equal.  If you want to check for
        /// subtypes, use g_variant_type_is_subtype_of().
        /// </para>
        /// <para>
        /// The argument types of @type1 and @type2 are only #gconstpointer to
        /// allow use with #GHashTable without function pointer casting.  For
        /// both arguments, a valid #GVariantType must be provided.
        /// </para>
        /// </remarks>
        /// <param name="type1">
        /// a #GVariantType
        /// </param>
        /// <param name="type2">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// %TRUE if @type1 and @type2 are exactly equal
        /// 
        /// Since 2.24
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_variant_type_equal(
        /* <type name="VariantType" type="gconstpointer" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.VariantType.UnmanagedStruct* type1,
        /* <type name="VariantType" type="gconstpointer" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.VariantType.UnmanagedStruct* type2);
        partial void CheckEqualsArgs(GISharp.Lib.GLib.VariantType type2);

        /// <include file="VariantType.xmldoc" path="declaration/member[@name='VariantType.Equals(GISharp.Lib.GLib.VariantType?)']/*" />
        public bool Equals(GISharp.Lib.GLib.VariantType? type2)
        {
            if (type2 is null)
            {
                return false;
            }

            CheckEqualsArgs(type2);
            var type1_ = (GISharp.Lib.GLib.VariantType.UnmanagedStruct*)UnsafeHandle;
            var type2_ = (GISharp.Lib.GLib.VariantType.UnmanagedStruct*)type2.UnsafeHandle;
            var ret_ = g_variant_type_equal(type1_,type2_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <inheritdoc/>
        public override bool Equals(object? other)
        {
            if (other is GISharp.Lib.GLib.VariantType variantType)
            {
                return Equals(variantType);
            }

            return base.Equals(other);
        }

        /// <inheritdoc/>
        public static bool operator ==(GISharp.Lib.GLib.VariantType a, GISharp.Lib.GLib.VariantType b)
        {
            return a.Equals(b);
        }

        /// <inheritdoc/>
        public static System.Boolean operator !=(GISharp.Lib.GLib.VariantType a, GISharp.Lib.GLib.VariantType b)
        {
            return !a.Equals(b);
        }

        /// <summary>
        /// Determines the first item type of a tuple or dictionary entry
        /// type.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This function may only be used with tuple or dictionary entry types,
        /// but must not be used with the generic tuple type
        /// %G_VARIANT_TYPE_TUPLE.
        /// </para>
        /// <para>
        /// In the case of a dictionary entry type, this returns the type of
        /// the key.
        /// </para>
        /// <para>
        /// %NULL is returned in case of @type being %G_VARIANT_TYPE_UNIT.
        /// </para>
        /// <para>
        /// This call, together with g_variant_type_next() provides an iterator
        /// interface over tuple and dictionary entry types.
        /// </para>
        /// </remarks>
        /// <param name="type">
        /// a tuple or dictionary entry #GVariantType
        /// </param>
        /// <returns>
        /// the first item type of @type, or %NULL
        /// 
        /// Since 2.24
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="VariantType" type="const GVariantType*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GLib.VariantType.UnmanagedStruct* g_variant_type_first(
        /* <type name="VariantType" type="const GVariantType*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.VariantType.UnmanagedStruct* type);
        partial void CheckFirstArgs();

        /// <include file="VariantType.xmldoc" path="declaration/member[@name='VariantType.First()']/*" />
        public GISharp.Lib.GLib.VariantType First()
        {
            CheckFirstArgs();
            var type_ = (GISharp.Lib.GLib.VariantType.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_variant_type_first(type_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Lib.GLib.VariantType.GetInstance<GISharp.Lib.GLib.VariantType>((System.IntPtr)ret_, GISharp.Runtime.Transfer.None)!;
            return ret;
        }

        /// <summary>
        /// Frees a #GVariantType that was allocated with
        /// g_variant_type_copy(), g_variant_type_new() or one of the container
        /// type constructor functions.
        /// </summary>
        /// <remarks>
        /// <para>
        /// In the case that @type is %NULL, this function does nothing.
        /// </para>
        /// <para>
        /// Since 2.24
        /// </para>
        /// </remarks>
        /// <param name="type">
        /// a #GVariantType, or %NULL
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_variant_type_free(
        /* <type name="VariantType" type="GVariantType*" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        GISharp.Lib.GLib.VariantType.UnmanagedStruct* type);

        /// <inheritdoc/>
        protected override void Dispose(bool disposing)
        {
            if (handle != System.IntPtr.Zero)
            {
                g_variant_type_free((UnmanagedStruct*)handle);
            }

            base.Dispose(disposing);
        }

        /// <summary>
        /// Returns the length of the type string corresponding to the given
        /// @type.  This function must be used to determine the valid extent of
        /// the memory region returned by g_variant_type_peek_string().
        /// </summary>
        /// <param name="type">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// the length of the corresponding type string
        /// 
        /// Since 2.24
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gsize" type="gsize" /> */
        /* transfer-ownership:none direction:in */
        private static extern nuint g_variant_type_get_string_length(
        /* <type name="VariantType" type="const GVariantType*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.VariantType.UnmanagedStruct* type);
        partial void CheckGetStringLengthArgs();

        private int GetStringLength()
        {
            CheckGetStringLengthArgs();
            var type_ = (GISharp.Lib.GLib.VariantType.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_variant_type_get_string_length(type_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = (int)ret_;
            return ret;
        }

        /// <summary>
        /// Hashes @type.
        /// </summary>
        /// <remarks>
        /// <para>
        /// The argument type of @type is only #gconstpointer to allow use with
        /// #GHashTable without function pointer casting.  A valid
        /// #GVariantType must be provided.
        /// </para>
        /// </remarks>
        /// <param name="type">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// the hash value
        /// 
        /// Since 2.24
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="guint" type="guint" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        private static extern uint g_variant_type_hash(
        /* <type name="VariantType" type="gconstpointer" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.VariantType.UnmanagedStruct* type);
        partial void CheckGetHashCodeArgs();

        /// <include file="VariantType.xmldoc" path="declaration/member[@name='VariantType.GetHashCode()']/*" />
        public override System.Int32 GetHashCode()
        {
            CheckGetHashCodeArgs();
            var type_ = (GISharp.Lib.GLib.VariantType.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_variant_type_hash(type_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = (System.Int32)ret_;
            return ret;
        }

        /// <summary>
        /// Determines if the given @type is an array type.  This is true if the
        /// type string for @type starts with an 'a'.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This function returns %TRUE for any indefinite type for which every
        /// definite subtype is an array type -- %G_VARIANT_TYPE_ARRAY, for
        /// example.
        /// </para>
        /// </remarks>
        /// <param name="type">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// %TRUE if @type is an array type
        /// 
        /// Since 2.24
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_variant_type_is_array(
        /* <type name="VariantType" type="const GVariantType*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.VariantType.UnmanagedStruct* type);
        partial void CheckGetIsArrayArgs();

        private bool GetIsArray()
        {
            CheckGetIsArrayArgs();
            var type_ = (GISharp.Lib.GLib.VariantType.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_variant_type_is_array(type_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Determines if the given @type is a basic type.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Basic types are booleans, bytes, integers, doubles, strings, object
        /// paths and signatures.
        /// </para>
        /// <para>
        /// Only a basic type may be used as the key of a dictionary entry.
        /// </para>
        /// <para>
        /// This function returns %FALSE for all indefinite types except
        /// %G_VARIANT_TYPE_BASIC.
        /// </para>
        /// </remarks>
        /// <param name="type">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// %TRUE if @type is a basic type
        /// 
        /// Since 2.24
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_variant_type_is_basic(
        /* <type name="VariantType" type="const GVariantType*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.VariantType.UnmanagedStruct* type);
        partial void CheckGetIsBasicArgs();

        private bool GetIsBasic()
        {
            CheckGetIsBasicArgs();
            var type_ = (GISharp.Lib.GLib.VariantType.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_variant_type_is_basic(type_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Determines if the given @type is a container type.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Container types are any array, maybe, tuple, or dictionary
        /// entry types plus the variant type.
        /// </para>
        /// <para>
        /// This function returns %TRUE for any indefinite type for which every
        /// definite subtype is a container -- %G_VARIANT_TYPE_ARRAY, for
        /// example.
        /// </para>
        /// </remarks>
        /// <param name="type">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// %TRUE if @type is a container type
        /// 
        /// Since 2.24
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_variant_type_is_container(
        /* <type name="VariantType" type="const GVariantType*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.VariantType.UnmanagedStruct* type);
        partial void CheckGetIsContainerArgs();

        private bool GetIsContainer()
        {
            CheckGetIsContainerArgs();
            var type_ = (GISharp.Lib.GLib.VariantType.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_variant_type_is_container(type_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Determines if the given @type is definite (ie: not indefinite).
        /// </summary>
        /// <remarks>
        /// <para>
        /// A type is definite if its type string does not contain any indefinite
        /// type characters ('*', '?', or 'r').
        /// </para>
        /// <para>
        /// A #GVariant instance may not have an indefinite type, so calling
        /// this function on the result of g_variant_get_type() will always
        /// result in %TRUE being returned.  Calling this function on an
        /// indefinite type like %G_VARIANT_TYPE_ARRAY, however, will result in
        /// %FALSE being returned.
        /// </para>
        /// </remarks>
        /// <param name="type">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// %TRUE if @type is definite
        /// 
        /// Since 2.24
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_variant_type_is_definite(
        /* <type name="VariantType" type="const GVariantType*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.VariantType.UnmanagedStruct* type);
        partial void CheckGetIsDefiniteArgs();

        private bool GetIsDefinite()
        {
            CheckGetIsDefiniteArgs();
            var type_ = (GISharp.Lib.GLib.VariantType.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_variant_type_is_definite(type_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Determines if the given @type is a dictionary entry type.  This is
        /// true if the type string for @type starts with a '{'.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This function returns %TRUE for any indefinite type for which every
        /// definite subtype is a dictionary entry type --
        /// %G_VARIANT_TYPE_DICT_ENTRY, for example.
        /// </para>
        /// </remarks>
        /// <param name="type">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// %TRUE if @type is a dictionary entry type
        /// 
        /// Since 2.24
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_variant_type_is_dict_entry(
        /* <type name="VariantType" type="const GVariantType*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.VariantType.UnmanagedStruct* type);
        partial void CheckGetIsDictEntryArgs();

        private bool GetIsDictEntry()
        {
            CheckGetIsDictEntryArgs();
            var type_ = (GISharp.Lib.GLib.VariantType.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_variant_type_is_dict_entry(type_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Determines if the given @type is a maybe type.  This is true if the
        /// type string for @type starts with an 'm'.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This function returns %TRUE for any indefinite type for which every
        /// definite subtype is a maybe type -- %G_VARIANT_TYPE_MAYBE, for
        /// example.
        /// </para>
        /// </remarks>
        /// <param name="type">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// %TRUE if @type is a maybe type
        /// 
        /// Since 2.24
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_variant_type_is_maybe(
        /* <type name="VariantType" type="const GVariantType*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.VariantType.UnmanagedStruct* type);
        partial void CheckGetIsMaybeArgs();

        private bool GetIsMaybe()
        {
            CheckGetIsMaybeArgs();
            var type_ = (GISharp.Lib.GLib.VariantType.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_variant_type_is_maybe(type_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Checks if @type is a subtype of @supertype.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This function returns %TRUE if @type is a subtype of @supertype.  All
        /// types are considered to be subtypes of themselves.  Aside from that,
        /// only indefinite types can have subtypes.
        /// </para>
        /// </remarks>
        /// <param name="type">
        /// a #GVariantType
        /// </param>
        /// <param name="supertype">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// %TRUE if @type is a subtype of @supertype
        /// 
        /// Since 2.24
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_variant_type_is_subtype_of(
        /* <type name="VariantType" type="const GVariantType*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.VariantType.UnmanagedStruct* type,
        /* <type name="VariantType" type="const GVariantType*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.VariantType.UnmanagedStruct* supertype);
        partial void CheckIsSubtypeOfArgs(GISharp.Lib.GLib.VariantType supertype);

        /// <include file="VariantType.xmldoc" path="declaration/member[@name='VariantType.IsSubtypeOf(GISharp.Lib.GLib.VariantType)']/*" />
        public bool IsSubtypeOf(GISharp.Lib.GLib.VariantType supertype)
        {
            CheckIsSubtypeOfArgs(supertype);
            var type_ = (GISharp.Lib.GLib.VariantType.UnmanagedStruct*)UnsafeHandle;
            var supertype_ = (GISharp.Lib.GLib.VariantType.UnmanagedStruct*)supertype.UnsafeHandle;
            var ret_ = g_variant_type_is_subtype_of(type_,supertype_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Determines if the given @type is a tuple type.  This is true if the
        /// type string for @type starts with a '(' or if @type is
        /// %G_VARIANT_TYPE_TUPLE.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This function returns %TRUE for any indefinite type for which every
        /// definite subtype is a tuple type -- %G_VARIANT_TYPE_TUPLE, for
        /// example.
        /// </para>
        /// </remarks>
        /// <param name="type">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// %TRUE if @type is a tuple type
        /// 
        /// Since 2.24
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_variant_type_is_tuple(
        /* <type name="VariantType" type="const GVariantType*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.VariantType.UnmanagedStruct* type);
        partial void CheckGetIsTupleArgs();

        private bool GetIsTuple()
        {
            CheckGetIsTupleArgs();
            var type_ = (GISharp.Lib.GLib.VariantType.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_variant_type_is_tuple(type_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Determines if the given @type is the variant type.
        /// </summary>
        /// <param name="type">
        /// a #GVariantType
        /// </param>
        /// <returns>
        /// %TRUE if @type is the variant type
        /// 
        /// Since 2.24
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_variant_type_is_variant(
        /* <type name="VariantType" type="const GVariantType*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.VariantType.UnmanagedStruct* type);
        partial void CheckGetIsVariantArgs();

        private bool GetIsVariant()
        {
            CheckGetIsVariantArgs();
            var type_ = (GISharp.Lib.GLib.VariantType.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_variant_type_is_variant(type_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }

        /// <summary>
        /// Determines the key type of a dictionary entry type.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This function may only be used with a dictionary entry type.  Other
        /// than the additional restriction, this call is equivalent to
        /// g_variant_type_first().
        /// </para>
        /// </remarks>
        /// <param name="type">
        /// a dictionary entry #GVariantType
        /// </param>
        /// <returns>
        /// the key type of the dictionary entry
        /// 
        /// Since 2.24
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="VariantType" type="const GVariantType*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GLib.VariantType.UnmanagedStruct* g_variant_type_key(
        /* <type name="VariantType" type="const GVariantType*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.VariantType.UnmanagedStruct* type);
        partial void CheckKeyArgs();

        /// <include file="VariantType.xmldoc" path="declaration/member[@name='VariantType.Key()']/*" />
        public GISharp.Lib.GLib.VariantType Key()
        {
            CheckKeyArgs();
            var type_ = (GISharp.Lib.GLib.VariantType.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_variant_type_key(type_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Lib.GLib.VariantType.GetInstance<GISharp.Lib.GLib.VariantType>((System.IntPtr)ret_, GISharp.Runtime.Transfer.None)!;
            return ret;
        }

        /// <summary>
        /// Determines the number of items contained in a tuple or
        /// dictionary entry type.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This function may only be used with tuple or dictionary entry types,
        /// but must not be used with the generic tuple type
        /// %G_VARIANT_TYPE_TUPLE.
        /// </para>
        /// <para>
        /// In the case of a dictionary entry type, this function will always
        /// return 2.
        /// </para>
        /// </remarks>
        /// <param name="type">
        /// a tuple or dictionary entry #GVariantType
        /// </param>
        /// <returns>
        /// the number of items in @type
        /// 
        /// Since 2.24
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gsize" type="gsize" /> */
        /* transfer-ownership:none direction:in */
        private static extern nuint g_variant_type_n_items(
        /* <type name="VariantType" type="const GVariantType*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.VariantType.UnmanagedStruct* type);
        partial void CheckNItemsArgs();

        /// <include file="VariantType.xmldoc" path="declaration/member[@name='VariantType.NItems()']/*" />
        public int NItems()
        {
            CheckNItemsArgs();
            var type_ = (GISharp.Lib.GLib.VariantType.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_variant_type_n_items(type_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = (int)ret_;
            return ret;
        }

        /// <summary>
        /// Determines the next item type of a tuple or dictionary entry
        /// type.
        /// </summary>
        /// <remarks>
        /// <para>
        /// @type must be the result of a previous call to
        /// g_variant_type_first() or g_variant_type_next().
        /// </para>
        /// <para>
        /// If called on the key type of a dictionary entry then this call
        /// returns the value type.  If called on the value type of a dictionary
        /// entry then this call returns %NULL.
        /// </para>
        /// <para>
        /// For tuples, %NULL is returned when @type is the last item in a tuple.
        /// </para>
        /// </remarks>
        /// <param name="type">
        /// a #GVariantType from a previous call
        /// </param>
        /// <returns>
        /// the next #GVariantType after @type, or %NULL
        /// 
        /// Since 2.24
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="VariantType" type="const GVariantType*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GLib.VariantType.UnmanagedStruct* g_variant_type_next(
        /* <type name="VariantType" type="const GVariantType*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.VariantType.UnmanagedStruct* type);
        partial void CheckNextArgs();

        /// <include file="VariantType.xmldoc" path="declaration/member[@name='VariantType.Next()']/*" />
        public GISharp.Lib.GLib.VariantType Next()
        {
            CheckNextArgs();
            var type_ = (GISharp.Lib.GLib.VariantType.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_variant_type_next(type_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Lib.GLib.VariantType.GetInstance<GISharp.Lib.GLib.VariantType>((System.IntPtr)ret_, GISharp.Runtime.Transfer.None)!;
            return ret;
        }

        /// <summary>
        /// Determines the value type of a dictionary entry type.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This function may only be used with a dictionary entry type.
        /// </para>
        /// </remarks>
        /// <param name="type">
        /// a dictionary entry #GVariantType
        /// </param>
        /// <returns>
        /// the value type of the dictionary entry
        /// 
        /// Since 2.24
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="VariantType" type="const GVariantType*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GLib.VariantType.UnmanagedStruct* g_variant_type_value(
        /* <type name="VariantType" type="const GVariantType*" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.VariantType.UnmanagedStruct* type);
        partial void CheckValueArgs();

        /// <include file="VariantType.xmldoc" path="declaration/member[@name='VariantType.Value()']/*" />
        public GISharp.Lib.GLib.VariantType Value()
        {
            CheckValueArgs();
            var type_ = (GISharp.Lib.GLib.VariantType.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_variant_type_value(type_);
            GISharp.Runtime.GMarshal.PopUnhandledException();
            var ret = GISharp.Lib.GLib.VariantType.GetInstance<GISharp.Lib.GLib.VariantType>((System.IntPtr)ret_, GISharp.Runtime.Transfer.None)!;
            return ret;
        }
    }
}