<declaration>

<member name='Variant.Boolean'>
<summary>
Returns the boolean value of this instance.
</summary>
<remarks>
<para>
It is an error to call this function with a this instance of any type
other than %G_VARIANT_TYPE_BOOLEAN.
</para>
</remarks>
</member>

<member name='Variant.Byte'>
<summary>
Returns the byte value of this instance.
</summary>
<remarks>
<para>
It is an error to call this function with a this instance of any type
other than %G_VARIANT_TYPE_BYTE.
</para>
</remarks>
</member>

<member name='Variant.Bytestring'>
<summary>
Returns the string value of a <see cref="Variant"/> instance with an
array-of-bytes type.  The string has no particular encoding.
</summary>
<remarks>
<para>
If the array does not end with a nul terminator character, the empty
string is returned.  For this reason, you can always trust that a
non-<c>null</c> nul-terminated string will be returned by this function.
</para>
<para>
If the array contains a nul terminator character somewhere other than
the last byte then the returned string is the string, up to the first
such nul character.
</para>
<para>
g_variant_get_fixed_array() should be used instead if the array contains
arbitrary data that could not be nul-terminated or could contain nul bytes.
</para>
<para>
It is an error to call this function with a this instance that is not an
array of bytes.
</para>
<para>
The return value remains valid as long as this instance exists.
</para>
</remarks>
</member>

<member name='Variant.BytestringArray'>
<summary>
Gets the contents of an array of array of bytes <see cref="Variant"/>.  This call
makes a shallow copy; the return result should be released with
g_free(), but the individual strings must not be modified.
</summary>
<remarks>
<para>
If <paramref name="length"/> is non-<c>null</c> then the number of elements in the result is
stored there.  In any case, the resulting array will be
<c>null</c>-terminated.
</para>
<para>
For an empty array, <paramref name="length"/> will be set to 0 and a pointer to a
<c>null</c> pointer will be returned.
</para>
</remarks>
</member>

<member name='Variant.Data'>
<summary>
Returns a pointer to the serialised form of a <see cref="Variant"/> instance.
The returned data may not be in fully-normalised form if read from an
untrusted source.  The returned data must not be freed; it remains
valid for as long as this instance exists.
</summary>
<remarks>
<para>
If this instance is a fixed-sized value that was deserialised from a
corrupted serialised container then <c>null</c> may be returned.  In this
case, the proper thing to do is typically to use the appropriate
number of nul bytes in place of this instance.  If this instance is not fixed-sized
then <c>null</c> is never returned.
</para>
<para>
In the case that this instance is already in serialised form, this function
is O(1).  If the value is not already in serialised form,
serialisation occurs implicitly and is approximately O(n) in the size
of the result.
</para>
<para>
To deserialise the data returned by this function, in addition to the
serialised data, you must know the type of the <see cref="Variant"/>, and (if the
machine might be different) the endianness of the machine that stored
it. As a result, file formats or network messages that incorporate
serialised <see cref="Variant"/>s must include this information either
implicitly (for instance "the file always contains a
%G_VARIANT_TYPE_VARIANT and it is always in little-endian order") or
explicitly (by storing the type and/or endianness in addition to the
serialised data).
</para>
</remarks>
</member>

<member name='Variant.DataAsBytes'>
<summary>
Returns a pointer to the serialised form of a <see cref="Variant"/> instance.
The semantics of this function are exactly the same as
<see cref="Variant.GetData()"/>, except that the returned <see cref="Bytes"/> holds
a reference to the variant data.
</summary>
</member>

<member name='Variant.Double'>
<summary>
Returns the double precision floating point value of this instance.
</summary>
<remarks>
<para>
It is an error to call this function with a this instance of any type
other than %G_VARIANT_TYPE_DOUBLE.
</para>
</remarks>
</member>

<member name='Variant.Handle'>
<summary>
Returns the 32-bit signed integer value of this instance.
</summary>
<remarks>
<para>
It is an error to call this function with a this instance of any type other
than %G_VARIANT_TYPE_HANDLE.
</para>
<para>
By convention, handles are indexes into an array of file descriptors
that are sent alongside a D-Bus message.  If you're not interacting
with D-Bus, you probably don't need them.
</para>
</remarks>
</member>

<member name='Variant.Int16'>
<summary>
Returns the 16-bit signed integer value of this instance.
</summary>
<remarks>
<para>
It is an error to call this function with a this instance of any type
other than %G_VARIANT_TYPE_INT16.
</para>
</remarks>
</member>

<member name='Variant.Int32'>
<summary>
Returns the 32-bit signed integer value of this instance.
</summary>
<remarks>
<para>
It is an error to call this function with a this instance of any type
other than %G_VARIANT_TYPE_INT32.
</para>
</remarks>
</member>

<member name='Variant.Int64'>
<summary>
Returns the 64-bit signed integer value of this instance.
</summary>
<remarks>
<para>
It is an error to call this function with a this instance of any type
other than %G_VARIANT_TYPE_INT64.
</para>
</remarks>
</member>

<member name='Variant.Maybe'>
<summary>
Given a maybe-typed <see cref="Variant"/> instance, extract its value.  If the
value is Nothing, then this function returns <c>null</c>.
</summary>
</member>

<member name='Variant.NormalForm'>
<summary>
Gets a <see cref="Variant"/> instance that has the same value as this instance and is
trusted to be in normal form.
</summary>
<remarks>
<para>
If this instance is already trusted to be in normal form then a new
reference to this instance is returned.
</para>
<para>
If this instance is not already trusted, then it is scanned to check if it
is in normal form.  If it is found to be in normal form then it is
marked as trusted and a new reference to it is returned.
</para>
<para>
If this instance is found not to be in normal form then a new trusted
<see cref="Variant"/> is created with the same value as this instance.
</para>
<para>
It makes sense to call this function if you've received <see cref="Variant"/>
data from untrusted sources and you want to ensure your serialised
output is definitely in normal form.
</para>
<para>
If this instance is already in normal form, a new reference will be returned
(which will be floating if this instance is floating). If it is not in normal form,
the newly created <see cref="Variant"/> will be returned with a single non-floating
reference. Typically, <see cref="Variant.TakeRef()"/> should be called on the return
value from this function to guarantee ownership of a single non-floating
reference to it.
</para>
</remarks>
</member>

<member name='Variant.Objv'>
<summary>
Gets the contents of an array of object paths <see cref="Variant"/>.  This call
makes a shallow copy; the return result should be released with
g_free(), but the individual strings must not be modified.
</summary>
<remarks>
<para>
If <paramref name="length"/> is non-<c>null</c> then the number of elements in the result
is stored there.  In any case, the resulting array will be
<c>null</c>-terminated.
</para>
<para>
For an empty array, <paramref name="length"/> will be set to 0 and a pointer to a
<c>null</c> pointer will be returned.
</para>
</remarks>
</member>

<member name='Variant.Size'>
<summary>
Determines the number of bytes that would be required to store this instance
with <see cref="Variant.Store(System.IntPtr)"/>.
</summary>
<remarks>
<para>
If this instance has a fixed-sized type then this function always returned
that fixed size.
</para>
<para>
In the case that this instance is already in serialised form or the size has
already been calculated (ie: this function has been called before)
then this function is O(1).  Otherwise, the size is calculated, an
operation which is approximately O(n) in the number of values
involved.
</para>
</remarks>
</member>

<member name='Variant.Strv'>
<summary>
Gets the contents of an array of strings <see cref="Variant"/>.  This call
makes a shallow copy; the return result should be released with
g_free(), but the individual strings must not be modified.
</summary>
<remarks>
<para>
If <paramref name="length"/> is non-<c>null</c> then the number of elements in the result
is stored there.  In any case, the resulting array will be
<c>null</c>-terminated.
</para>
<para>
For an empty array, <paramref name="length"/> will be set to 0 and a pointer to a
<c>null</c> pointer will be returned.
</para>
</remarks>
</member>

<member name='Variant.Type'>
<summary>
Determines the type of this instance.
</summary>
<remarks>
<para>
The return value is valid for the lifetime of this instance and must not
be freed.
</para>
</remarks>
</member>

<member name='Variant.TypeString'>
<summary>
Returns the type string of this instance.  Unlike the result of calling
<see cref="VariantType.PeekString()"/>, this string is nul-terminated.  This
string belongs to <see cref="Variant"/> and must not be freed.
</summary>
</member>

<member name='Variant.Uint16'>
<summary>
Returns the 16-bit unsigned integer value of this instance.
</summary>
<remarks>
<para>
It is an error to call this function with a this instance of any type
other than %G_VARIANT_TYPE_UINT16.
</para>
</remarks>
</member>

<member name='Variant.Uint32'>
<summary>
Returns the 32-bit unsigned integer value of this instance.
</summary>
<remarks>
<para>
It is an error to call this function with a this instance of any type
other than %G_VARIANT_TYPE_UINT32.
</para>
</remarks>
</member>

<member name='Variant.Uint64'>
<summary>
Returns the 64-bit unsigned integer value of this instance.
</summary>
<remarks>
<para>
It is an error to call this function with a this instance of any type
other than %G_VARIANT_TYPE_UINT64.
</para>
</remarks>
</member>

<member name='Variant.BoxedVariant'>
<summary>
Unboxes this instance.  The result is the <see cref="Variant"/> instance that was
contained in this instance.
</summary>
</member>

<member name='Variant.IsContainer'>
<summary>
Checks if this instance is a container.
</summary>
</member>

<member name='Variant.IsFloating'>
<summary>
Checks whether this instance has a floating reference count.
</summary>
<remarks>
<para>
This function should only ever be used to assert that a given variant
is or is not floating, or for debug purposes. To acquire a reference
to a variant that might be floating, always use <see cref="Variant.RefSink()"/>
or <see cref="Variant.TakeRef()"/>.
</para>
<para>
See <see cref="Variant.RefSink()"/> for more information about floating reference
counts.
</para>
</remarks>
</member>

<member name='Variant.IsNormalForm'>
<summary>
Checks if this instance is in normal form.
</summary>
<remarks>
<para>
The main reason to do this is to detect if a given chunk of
serialised data is in normal form: load the data into a <see cref="Variant"/>
using <see cref="Variant.Variant(GISharp.Lib.GLib.VariantType,System.ReadOnlySpan{byte},bool,GISharp.Lib.GLib.DestroyNotify,System.IntPtr)"/> and then use this function to
check.
</para>
<para>
If this instance is found to be in normal form then it will be marked as
being trusted.  If the value was already marked as being trusted then
this function will immediately return <c>true</c>.
</para>
<para>
There may be implementation specific restrictions on deeply nested values.
GVariant is guaranteed to handle nesting up to at least 64 levels.
</para>
</remarks>
</member>

<member name='Variant.Variant(GISharp.Lib.GLib.VariantType?,GISharp.Runtime.UnownedCPtrArray&lt;GISharp.Lib.GLib.Variant&gt;)'>
<summary>
Creates a new <see cref="Variant"/> array from <paramref name="children"/>.
</summary>
<remarks>
<para>
<paramref name="childType"/> must be non-<c>null</c> if the length of <paramref name="children"/> is zero.  Otherwise, the
child type is determined by inspecting the first element of the
<paramref name="children"/> array.  If <paramref name="childType"/> is non-<c>null</c> then it must be a
definite type.
</para>
<para>
The items of the array are taken from the <paramref name="children"/> array.  No entry
in the <paramref name="children"/> array may be <c>null</c>.
</para>
<para>
All items in the array must have the same type, which must be the
same as <paramref name="childType"/>, if given.
</para>
<para>
If the <paramref name="children"/> are floating references (see <see cref="Variant.RefSink()"/>), the
new instance takes ownership of them as if via <see cref="Variant.RefSink()"/>.
</para>
</remarks>
<param name="childType">
the element type of the new array
</param>
<param name="children">
an array of
           <see cref="Variant"/> pointers, the children
</param>
</member>

<member name='Variant.Variant(bool)'>
<summary>
Creates a new boolean <see cref="Variant"/> instance -- either <c>true</c> or <c>false</c>.
</summary>
<param name="value">
a #gboolean value
</param>
</member>

<member name='Variant.Variant(byte)'>
<summary>
Creates a new byte <see cref="Variant"/> instance.
</summary>
<param name="value">
a #guint8 value
</param>
</member>

<member name='Variant.Variant(GISharp.Runtime.ByteString)'>
<summary>
Creates an array-of-bytes <see cref="Variant"/> with the contents of <paramref name="string"/>.
This function is just like <see cref="Variant.Variant(GISharp.Lib.GLib.UnownedUtf8)"/> except that the
string need not be valid UTF-8.
</summary>
<remarks>
<para>
The nul terminator character at the end of the string is stored in
the array.
</para>
</remarks>
<param name="string">
a normal
         nul-terminated string in no particular encoding
</param>
</member>

<member name='Variant.Variant(GISharp.Runtime.UnownedCPtrArray&lt;GISharp.Runtime.ByteString&gt;)'>
<summary>
Constructs an array of bytestring <see cref="Variant"/> from the given array of
strings.
</summary>
<remarks>
<para>
If the length of <paramref name="strv"/> is -1 then <paramref name="strv"/> is <c>null</c>-terminated.
</para>
</remarks>
<param name="strv">
an array of strings
</param>
</member>

<member name='Variant.Variant(GISharp.Lib.GLib.Variant,GISharp.Lib.GLib.Variant)'>
<summary>
Creates a new dictionary entry <see cref="Variant"/>. <paramref name="key"/> and <paramref name="value"/> must be
non-<c>null</c>. <paramref name="key"/> must be a value of a basic type (ie: not a container).
</summary>
<remarks>
<para>
If the <paramref name="key"/> or <paramref name="value"/> are floating references (see <see cref="Variant.RefSink()"/>),
the new instance takes ownership of them as if via <see cref="Variant.RefSink()"/>.
</para>
</remarks>
<param name="key">
a basic <see cref="Variant"/>, the key
</param>
<param name="value">
a <see cref="Variant"/>, the value
</param>
</member>

<member name='Variant.Variant(double)'>
<summary>
Creates a new double <see cref="Variant"/> instance.
</summary>
<param name="value">
a #gdouble floating point value
</param>
</member>

<member name='Variant.Variant(GISharp.Lib.GLib.VariantType,System.IntPtr,int,int)'>
<summary>
Constructs a new array <see cref="Variant"/> instance, where the elements are
of <paramref name="elementType"/> type.
</summary>
<remarks>
<para>
<paramref name="elements"/> must be an array with fixed-sized elements.  Numeric types are
fixed-size as are tuples containing only other fixed-sized types.
</para>
<para>
<paramref name="elementSize"/> must be the size of a single element in the array.
For example, if calling this function for an array of 32-bit integers,
you might say sizeof(gint32). This value isn't used except for the purpose
of a double-check that the form of the serialised data matches the caller's
expectation.
</para>
<para>
<paramref name="nElements"/> must be the length of the <paramref name="elements"/> array.
</para>
</remarks>
<param name="elementType">
the <see cref="VariantType"/> of each element
</param>
<param name="elements">
a pointer to the fixed array of contiguous elements
</param>
<param name="nElements">
the number of elements
</param>
<param name="elementSize">
the size of each element
</param>
</member>

<member name='Variant.Variant(GISharp.Lib.GLib.VariantType,GISharp.Lib.GLib.Bytes,bool)'>
<summary>
Constructs a new serialised-mode <see cref="Variant"/> instance.  This is the
inner interface for creation of new serialised values that gets
called from various functions in gvariant.c.
</summary>
<remarks>
<para>
A reference is taken on <paramref name="bytes"/>.
</para>
<para>
The data in <paramref name="bytes"/> must be aligned appropriately for the <paramref name="type"/> being loaded.
Otherwise this function will internally create a copy of the memory (since
GLib 2.60) or (in older versions) fail and exit the process.
</para>
</remarks>
<param name="type">
a <see cref="VariantType"/>
</param>
<param name="bytes">
a <see cref="Bytes"/>
</param>
<param name="trusted">
if the contents of <paramref name="bytes"/> are trusted
</param>
</member>

<member name='Variant.Variant(GISharp.Lib.GLib.DBusHandle)'>
<summary>
Creates a new handle <see cref="Variant"/> instance.
</summary>
<remarks>
<para>
By convention, handles are indexes into an array of file descriptors
that are sent alongside a D-Bus message.  If you're not interacting
with D-Bus, you probably don't need them.
</para>
</remarks>
<param name="value">
a #gint32 value
</param>
</member>

<member name='Variant.Variant(short)'>
<summary>
Creates a new int16 <see cref="Variant"/> instance.
</summary>
<param name="value">
a #gint16 value
</param>
</member>

<member name='Variant.Variant(int)'>
<summary>
Creates a new int32 <see cref="Variant"/> instance.
</summary>
<param name="value">
a #gint32 value
</param>
</member>

<member name='Variant.Variant(long)'>
<summary>
Creates a new int64 <see cref="Variant"/> instance.
</summary>
<param name="value">
a #gint64 value
</param>
</member>

<member name='Variant.Variant(GISharp.Lib.GLib.VariantType?,GISharp.Lib.GLib.Variant?)'>
<summary>
Depending on if <paramref name="child"/> is <c>null</c>, either wraps <paramref name="child"/> inside of a
maybe container or creates a Nothing instance for the given <c>type</c>.
</summary>
<remarks>
<para>
At least one of <paramref name="childType"/> and <paramref name="child"/> must be non-<c>null</c>.
If <paramref name="childType"/> is non-<c>null</c> then it must be a definite type.
If they are both non-<c>null</c> then <paramref name="childType"/> must be the type
of <paramref name="child"/>.
</para>
<para>
If <paramref name="child"/> is a floating reference (see <see cref="Variant.RefSink()"/>), the new
instance takes ownership of <paramref name="child"/>.
</para>
</remarks>
<param name="childType">
the <see cref="VariantType"/> of the child, or <c>null</c>
</param>
<param name="child">
the child value, or <c>null</c>
</param>
</member>

<member name='Variant.Variant(GISharp.Lib.GLib.DBusObjectPath)'>
<summary>
Creates a D-Bus object path <see cref="Variant"/> with the contents of <c><c>@string</c></c>.
<c><c>@string</c></c> must be a valid D-Bus object path.  Use
<see cref="Variant.IsObjectPath(GISharp.Lib.GLib.UnownedUtf8)"/> if you're not sure.
</summary>
<param name="objectPath">
a normal C nul-terminated string
</param>
</member>

<member name='Variant.Variant(GISharp.Runtime.UnownedCPtrArray&lt;GISharp.Lib.GLib.DBusObjectPath&gt;)'>
<summary>
Constructs an array of object paths <see cref="Variant"/> from the given array of
strings.
</summary>
<remarks>
<para>
Each string must be a valid <see cref="Variant"/> object path; see
<see cref="Variant.IsObjectPath(GISharp.Lib.GLib.UnownedUtf8)"/>.
</para>
<para>
If the length of <paramref name="strv"/> is -1 then <paramref name="strv"/> is <c>null</c>-terminated.
</para>
</remarks>
<param name="strv">
an array of strings
</param>
</member>

<member name='Variant.Variant(GISharp.Lib.GLib.DBusSignature)'>
<summary>
Creates a D-Bus type signature <see cref="Variant"/> with the contents of
<c><c>@string</c></c>.  <c><c>@string</c></c> must be a valid D-Bus type signature.  Use
<see cref="Variant.IsSignature(GISharp.Lib.GLib.UnownedUtf8)"/> if you're not sure.
</summary>
<param name="signature">
a normal C nul-terminated string
</param>
</member>

<member name='Variant.Variant(GISharp.Lib.GLib.UnownedUtf8)'>
<summary>
Creates a string <see cref="Variant"/> with the contents of <paramref name="string"/>.
</summary>
<remarks>
<para>
<paramref name="string"/> must be valid UTF-8, and must not be <c>null</c>. To encode
potentially-<c>null</c> strings, use g_variant_new() with `ms` as the
[format string][gvariant-format-strings-maybe-types].
</para>
</remarks>
<param name="string">
a normal UTF-8 nul-terminated string
</param>
</member>

<member name='Variant.Variant(GISharp.Runtime.UnownedCPtrArray&lt;GISharp.Lib.GLib.Utf8&gt;)'>
<summary>
Constructs an array of strings <see cref="Variant"/> from the given array of
strings.
</summary>
<remarks>
<para>
If the length of <paramref name="strv"/> is -1 then <paramref name="strv"/> is <c>null</c>-terminated.
</para>
</remarks>
<param name="strv">
an array of strings
</param>
</member>

<member name='Variant.Variant(GISharp.Runtime.UnownedCPtrArray&lt;GISharp.Lib.GLib.Variant&gt;)'>
<summary>
Creates a new tuple <see cref="Variant"/> out of the items in <paramref name="children"/>.  The
type is determined from the types of <paramref name="children"/>.  No entry in the
<paramref name="children"/> array may be <c>null</c>.
</summary>
<remarks>
<para>
If the length of <paramref name="children"/> is 0 then the unit tuple is constructed.
</para>
<para>
If the <paramref name="children"/> are floating references (see <see cref="Variant.RefSink()"/>), the
new instance takes ownership of them as if via <see cref="Variant.RefSink()"/>.
</para>
</remarks>
<param name="children">
the items to make the tuple out of
</param>
</member>

<member name='Variant.Variant(ushort)'>
<summary>
Creates a new uint16 <see cref="Variant"/> instance.
</summary>
<param name="value">
a #guint16 value
</param>
</member>

<member name='Variant.Variant(uint)'>
<summary>
Creates a new uint32 <see cref="Variant"/> instance.
</summary>
<param name="value">
a #guint32 value
</param>
</member>

<member name='Variant.Variant(ulong)'>
<summary>
Creates a new uint64 <see cref="Variant"/> instance.
</summary>
<param name="value">
a #guint64 value
</param>
</member>

<member name='Variant.Variant(GISharp.Lib.GLib.Variant)'>
<summary>
Boxes <paramref name="value"/>.  The result is a <see cref="Variant"/> instance representing a
variant containing the original value.
</summary>
<remarks>
<para>
If <c>child</c> is a floating reference (see <see cref="Variant.RefSink()"/>), the new
instance takes ownership of <c>child</c>.
</para>
</remarks>
<param name="value">
a <see cref="Variant"/> instance
</param>
</member>

<member name='Variant.Compare(GISharp.Lib.GLib.Variant,GISharp.Lib.GLib.Variant)'>
<summary>
Compares <paramref name="one"/> and <paramref name="two"/>.
</summary>
<remarks>
<para>
The types of <paramref name="one"/> and <paramref name="two"/> are #gconstpointer only to allow use of
this function with #GTree, <see cref="PtrArray"/>, etc.  They must each be a
<see cref="Variant"/>.
</para>
<para>
Comparison is only defined for basic types (ie: booleans, numbers,
strings).  For booleans, <c>false</c> is less than <c>true</c>.  Numbers are
ordered in the usual way.  Strings are in ASCII lexographical order.
</para>
<para>
It is a programmer error to attempt to compare container values or
two values that have types that are not exactly equal.  For example,
you cannot compare a 32-bit signed integer with a 32-bit unsigned
integer.  Also note that this function is not particularly
well-behaved when it comes to comparison of doubles; in particular,
the handling of incomparable values (ie: NaN) is undefined.
</para>
<para>
If you only require an equality comparison, <see cref="Variant.Equals(GISharp.Lib.GLib.Variant)"/> is more
general.
</para>
</remarks>
<param name="one">
a basic-typed <see cref="Variant"/> instance
</param>
<param name="two">
a <see cref="Variant"/> instance of the same type
</param>
<returns>
negative value if a &lt; b;
         zero if a = b;
         positive value if a &gt; b.
</returns>
</member>

<member name='Variant.IsObjectPath(GISharp.Lib.GLib.UnownedUtf8)'>
<summary>
Determines if a given string is a valid D-Bus object path.  You
should ensure that a string is a valid D-Bus object path before
passing it to <see cref="Variant.Variant(GISharp.Lib.GLib.DBusObjectPath)"/>.
</summary>
<remarks>
<para>
A valid object path starts with `/` followed by zero or more
sequences of characters separated by `/` characters.  Each sequence
must contain only the characters `[A-Z][a-z][0-9]_`.  No sequence
(including the one following the final `/` character) may be empty.
</para>
</remarks>
<param name="string">
a normal C nul-terminated string
</param>
<returns>
<c>true</c> if <paramref name="string"/> is a D-Bus object path
</returns>
</member>

<member name='Variant.IsSignature(GISharp.Lib.GLib.UnownedUtf8)'>
<summary>
Determines if a given string is a valid D-Bus type signature.  You
should ensure that a string is a valid D-Bus type signature before
passing it to <see cref="Variant.Variant(GISharp.Lib.GLib.DBusSignature)"/>.
</summary>
<remarks>
<para>
D-Bus type signatures consist of zero or more definite <see cref="VariantType"/>
strings in sequence.
</para>
</remarks>
<param name="string">
a normal C nul-terminated string
</param>
<returns>
<c>true</c> if <paramref name="string"/> is a D-Bus type signature
</returns>
</member>

<member name='Variant.Parse(GISharp.Lib.GLib.VariantType?,GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.GLib.NullableUnownedUtf8,GISharp.Lib.GLib.NullableUnownedUtf8)'>
<summary>
Parses a <see cref="Variant"/> from a text representation.
</summary>
<remarks>
<para>
A single <see cref="Variant"/> is parsed from the content of <paramref name="text"/>.
</para>
<para>
The format is described [here][gvariant-text].
</para>
<para>
The memory at <paramref name="limit"/> will never be accessed and the parser behaves as
if the character at <paramref name="limit"/> is the nul terminator.  This has the
effect of bounding <paramref name="text"/>.
</para>
<para>
If <paramref name="endptr"/> is non-<c>null</c> then <paramref name="text"/> is permitted to contain data
following the value that this function parses and <paramref name="endptr"/> will be
updated to point to the first character past the end of the text
parsed by this function.  If <paramref name="endptr"/> is <c>null</c> and there is extra data
then an error is returned.
</para>
<para>
If <paramref name="type"/> is non-<c>null</c> then the value will be parsed to have that
type.  This may result in additional parse errors (in the case that
the parsed value doesn't fit the type) but may also result in fewer
errors (in the case that the type would have been ambiguous, such as
with empty arrays).
</para>
<para>
In the event that the parsing is successful, the resulting <see cref="Variant"/>
is returned. It is never floating, and must be freed with
<see cref="Variant.Unref()"/>.
</para>
<para>
In case of any error, <c>null</c> will be returned.  If <see cref="GISharp.Runtime.GErrorException"/> is non-<c>null</c>
then it will be set to reflect the error that occurred.
</para>
<para>
Officially, the language understood by the parser is "any string
produced by <see cref="Variant.Print(bool)"/>".
</para>
<para>
There may be implementation specific restrictions on deeply nested values,
which would result in a <see cref="VariantParseError.Recursion"/> error. <see cref="Variant"/> is
guaranteed to handle nesting up to at least 64 levels.
</para>
</remarks>
<param name="type">
a <see cref="VariantType"/>, or <c>null</c>
</param>
<param name="text">
a string containing a GVariant in text form
</param>
<param name="limit">
a pointer to the end of <paramref name="text"/>, or <c>null</c>
</param>
<param name="endptr">
a location to store the end pointer, or <c>null</c>
</param>
<returns>
a non-floating reference to a <see cref="Variant"/>, or <c>null</c>
</returns>
<exception name="GISharp.Runtime.GErrorException">
On error
</exception>
</member>

<member name='Variant.ParserGetErrorQuark()'>
<summary>
Same as g_variant_error_quark().
</summary>
</member>

<member name='Variant.Byteswap()'>
<summary>
Performs a byteswapping operation on the contents of this instance.  The
result is that all multi-byte numeric data contained in this instance is
byteswapped.  That includes 16, 32, and 64bit signed and unsigned
integers as well as file handles and double precision floating point
values.
</summary>
<remarks>
<para>
This function is an identity mapping on any value that does not
contain multi-byte numeric data.  That include strings, booleans,
bytes and containers containing only these things (recursively).
</para>
<para>
The returned value is always in normal form and is marked as trusted.
</para>
</remarks>
<returns>
the byteswapped form of this instance
</returns>
</member>

<member name='Variant.CheckFormatString(GISharp.Lib.GLib.UnownedUtf8,bool)'>
<summary>
Checks if calling g_variant_get() with <paramref name="formatString"/> on this instance would
be valid from a type-compatibility standpoint.  <paramref name="formatString"/> is
assumed to be a valid format string (from a syntactic standpoint).
</summary>
<remarks>
<para>
If <paramref name="copyOnly"/> is <c>true</c> then this function additionally checks that it
would be safe to call <see cref="Variant.Unref()"/> on this instance immediately after
the call to g_variant_get() without invalidating the result.  This is
only possible if deep copies are made (ie: there are no pointers to
the data inside of the soon-to-be-freed <see cref="Variant"/> instance).  If this
check fails then a g_critical() is printed and <c>false</c> is returned.
</para>
<para>
This function is meant to be used by functions that wish to provide
varargs accessors to <see cref="Variant"/> values of uncertain values (eg:
g_variant_lookup() or g_menu_model_get_item_attribute()).
</para>
</remarks>
<param name="formatString">
a valid <see cref="Variant"/> format string
</param>
<param name="copyOnly">
<c>true</c> to ensure the format string makes deep copies
</param>
<returns>
<c>true</c> if <paramref name="formatString"/> is safe to use
</returns>
</member>

<member name='Variant.Classify()'>
<summary>
Classifies this instance according to its top-level type.
</summary>
<returns>
the <see cref="VariantClass"/> of this instance
</returns>
</member>

<member name='Variant.Equals(GISharp.Lib.GLib.Variant?)'>
<summary>
Checks if this instance and <paramref name="two"/> have the same type and value.
</summary>
<remarks>
<para>
The types of this instance and <paramref name="two"/> are #gconstpointer only to allow use of
this function with <see cref="HashTable"/>.  They must each be a <see cref="Variant"/>.
</para>
</remarks>
<param name="two">
a <see cref="Variant"/> instance
</param>
<returns>
<c>true</c> if this instance and <paramref name="two"/> are equal
</returns>
</member>

<member name='Variant.GetHashCode()'>
<summary>
Generates a hash value for a <see cref="Variant"/> instance.
</summary>
<remarks>
<para>
The output of this function is guaranteed to be the same for a given
value only per-process.  It may change between different processor
architectures or even different versions of GLib.  Do not use this
function as a basis for building protocols or file formats.
</para>
<para>
The type of this instance is #gconstpointer only to allow use of this
function with <see cref="HashTable"/>.  this instance must be a <see cref="Variant"/>.
</para>
</remarks>
<returns>
a hash value corresponding to this instance
</returns>
</member>

<member name='Variant.IsOfType(GISharp.Lib.GLib.VariantType)'>
<summary>
Checks if a value has a type matching the provided type.
</summary>
<param name="type">
a <see cref="VariantType"/>
</param>
<returns>
<c>true</c> if the type of this instance matches <paramref name="type"/>
</returns>
</member>

<member name='Variant.LookupValue(GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.GLib.VariantType?)'>
<summary>
Looks up a value in a dictionary <see cref="Variant"/>.
</summary>
<remarks>
<para>
This function works with dictionaries of the type a{s*} (and equally
well with type a{o*}, but we only further discuss the string case
for sake of clarity).
</para>
<para>
In the event that this instance has the type a{sv}, the <paramref name="expectedType"/>
string specifies what type of value is expected to be inside of the
variant. If the value inside the variant has a different type then
<c>null</c> is returned. In the event that this instance has a value type other
than v then <paramref name="expectedType"/> must directly match the value type and it is
used to unpack the value directly or an error occurs.
</para>
<para>
In either case, if <paramref name="key"/> is not found in this instance, <c>null</c> is returned.
</para>
<para>
If the key is found and the value has the correct type, it is
returned.  If <paramref name="expectedType"/> was specified then any non-<c>null</c> return
value will have this type.
</para>
<para>
This function is currently implemented with a linear scan.  If you
plan to do many lookups then <see cref="VariantDict"/> may be more efficient.
</para>
</remarks>
<param name="key">
the key to look up in the dictionary
</param>
<param name="expectedType">
a <see cref="VariantType"/>, or <c>null</c>
</param>
<returns>
the value of the dictionary key, or <c>null</c>
</returns>
</member>

<member name='Variant.Print(bool)'>
<summary>
Pretty-prints this instance in the format understood by <see cref="Variant.Parse(GISharp.Lib.GLib.VariantType,GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.GLib.NullableUnownedUtf8,GISharp.Lib.GLib.NullableUnownedUtf8)"/>.
</summary>
<remarks>
<para>
The format is described [here][gvariant-text].
</para>
<para>
If <paramref name="typeAnnotate"/> is <c>true</c>, then type information is included in
the output.
</para>
</remarks>
<param name="typeAnnotate">
<c>true</c> if type information should be included in
                the output
</param>
<returns>
a newly-allocated string holding the result.
</returns>
</member>

<member name='Variant'>
<summary>
<see cref="Variant"/> is a variant datatype; it can contain one or more values
along with information about the type of the values.
</summary>
<remarks>
<para>
A <see cref="Variant"/> may contain simple types, like an integer, or a boolean value;
or complex types, like an array of two strings, or a dictionary of key
value pairs. A <see cref="Variant"/> is also immutable: once it's been created neither
its type nor its content can be modified further.
</para>
<para>
GVariant is useful whenever data needs to be serialized, for example when
sending method parameters in D-Bus, or when saving settings using GSettings.
</para>
<para>
When creating a new <see cref="Variant"/>, you pass the data you want to store in it
along with a string representing the type of data you wish to pass to it.
</para>
<para>
For instance, if you want to create a <see cref="Variant"/> holding an integer value you
can use:
</para>
<para>
|[&lt;!-- language="C" --&gt;
  GVariant *v = g_variant_new ("u", 40);
]|
</para>
<para>
The string "u" in the first argument tells <see cref="Variant"/> that the data passed to
the constructor (40) is going to be an unsigned integer.
</para>
<para>
More advanced examples of <see cref="Variant"/> in use can be found in documentation for
[GVariant format strings][gvariant-format-strings-pointers].
</para>
<para>
The range of possible values is determined by the type.
</para>
<para>
The type system used by <see cref="Variant"/> is <see cref="VariantType"/>.
</para>
<para>
<see cref="Variant"/> instances always have a type and a value (which are given
at construction time).  The type and value of a <see cref="Variant"/> instance
can never change other than by the <see cref="Variant"/> itself being
destroyed.  A <see cref="Variant"/> cannot contain a pointer.
</para>
<para>
<see cref="Variant"/> is reference counted using <see cref="Variant.Ref()"/> and
<see cref="Variant.Unref()"/>.  <see cref="Variant"/> also has floating reference counts --
see <see cref="Variant.RefSink()"/>.
</para>
<para>
<see cref="Variant"/> is completely threadsafe.  A <see cref="Variant"/> instance can be
concurrently accessed in any way from any number of threads without
problems.
</para>
<para>
<see cref="Variant"/> is heavily optimised for dealing with data in serialised
form.  It works particularly well with data located in memory-mapped
files.  It can perform nearly all deserialisation operations in a
small constant time, usually touching only a single memory page.
Serialised <see cref="Variant"/> data can also be sent over the network.
</para>
<para>
<see cref="Variant"/> is largely compatible with D-Bus.  Almost all types of
<see cref="Variant"/> instances can be sent over D-Bus.  See <see cref="VariantType"/> for
exceptions.  (However, <see cref="Variant"/>'s serialisation format is not the same
as the serialisation format of a D-Bus message body: use #GDBusMessage,
in the gio library, for those.)
</para>
<para>
For space-efficiency, the <see cref="Variant"/> serialisation format does not
automatically include the variant's length, type or endianness,
which must either be implied from context (such as knowledge that a
particular file format always contains a little-endian
%G_VARIANT_TYPE_VARIANT which occupies the whole length of the file)
or supplied out-of-band (for instance, a length, type and/or endianness
indicator could be placed at the beginning of a file, network message
or network stream).
</para>
<para>
A <see cref="Variant"/>'s size is limited mainly by any lower level operating
system constraints, such as the number of bits in #gsize.  For
example, it is reasonable to have a 2GB file mapped into memory
with #GMappedFile, and call <see cref="Variant.Variant(GISharp.Lib.GLib.VariantType,System.ReadOnlySpan{byte},bool,GISharp.Lib.GLib.DestroyNotify,System.IntPtr)"/> on it.
</para>
<para>
For convenience to C programmers, <see cref="Variant"/> features powerful
varargs-based value construction and destruction.  This feature is
designed to be embedded in other libraries.
</para>
<para>
There is a Python-inspired text language for describing <see cref="Variant"/>
values.  <see cref="Variant"/> includes a printer for this language and a parser
with type inferencing.
</para>
<para>
## Memory Use
</para>
<para>
<see cref="Variant"/> tries to be quite efficient with respect to memory use.
This section gives a rough idea of how much memory is used by the
current implementation.  The information here is subject to change
in the future.
</para>
<para>
The memory allocated by <see cref="Variant"/> can be grouped into 4 broad
purposes: memory for serialised data, memory for the type
information cache, buffer management memory and memory for the
<see cref="Variant"/> structure itself.
</para>
<para>
## Serialised Data Memory
</para>
<para>
This is the memory that is used for storing GVariant data in
serialised form.  This is what would be sent over the network or
what would end up on disk, not counting any indicator of the
endianness, or of the length or type of the top-level variant.
</para>
<para>
The amount of memory required to store a boolean is 1 byte. 16,
32 and 64 bit integers and double precision floating point numbers
use their "natural" size.  Strings (including object path and
signature strings) are stored with a nul terminator, and as such
use the length of the string plus 1 byte.
</para>
<para>
Maybe types use no space at all to represent the null value and
use the same amount of space (sometimes plus one byte) as the
equivalent non-maybe-typed value to represent the non-null case.
</para>
<para>
Arrays use the amount of space required to store each of their
members, concatenated.  Additionally, if the items stored in an
array are not of a fixed-size (ie: strings, other arrays, etc)
then an additional framing offset is stored for each item.  The
size of this offset is either 1, 2 or 4 bytes depending on the
overall size of the container.  Additionally, extra padding bytes
are added as required for alignment of child values.
</para>
<para>
Tuples (including dictionary entries) use the amount of space
required to store each of their members, concatenated, plus one
framing offset (as per arrays) for each non-fixed-sized item in
the tuple, except for the last one.  Additionally, extra padding
bytes are added as required for alignment of child values.
</para>
<para>
Variants use the same amount of space as the item inside of the
variant, plus 1 byte, plus the length of the type string for the
item inside the variant.
</para>
<para>
As an example, consider a dictionary mapping strings to variants.
In the case that the dictionary is empty, 0 bytes are required for
the serialisation.
</para>
<para>
If we add an item "width" that maps to the int32 value of 500 then
we will use 4 byte to store the int32 (so 6 for the variant
containing it) and 6 bytes for the string.  The variant must be
aligned to 8 after the 6 bytes of the string, so that's 2 extra
bytes.  6 (string) + 2 (padding) + 6 (variant) is 14 bytes used
for the dictionary entry.  An additional 1 byte is added to the
array as a framing offset making a total of 15 bytes.
</para>
<para>
If we add another entry, "title" that maps to a nullable string
that happens to have a value of null, then we use 0 bytes for the
null value (and 3 bytes for the variant to contain it along with
its type string) plus 6 bytes for the string.  Again, we need 2
padding bytes.  That makes a total of 6 + 2 + 3 = 11 bytes.
</para>
<para>
We now require extra padding between the two items in the array.
After the 14 bytes of the first item, that's 2 bytes required.
We now require 2 framing offsets for an extra two
bytes. 14 + 2 + 11 + 2 = 29 bytes to encode the entire two-item
dictionary.
</para>
<para>
## Type Information Cache
</para>
<para>
For each GVariant type that currently exists in the program a type
information structure is kept in the type information cache.  The
type information structure is required for rapid deserialisation.
</para>
<para>
Continuing with the above example, if a <see cref="Variant"/> exists with the
type "a{sv}" then a type information struct will exist for
"a{sv}", "{sv}", "s", and "v".  Multiple uses of the same type
will share the same type information.  Additionally, all
single-digit types are stored in read-only static memory and do
not contribute to the writable memory footprint of a program using
<see cref="Variant"/>.
</para>
<para>
Aside from the type information structures stored in read-only
memory, there are two forms of type information.  One is used for
container types where there is a single element type: arrays and
maybe types.  The other is used for container types where there
are multiple element types: tuples and dictionary entries.
</para>
<para>
Array type info structures are 6 * sizeof (void *), plus the
memory required to store the type string itself.  This means that
on 32-bit systems, the cache entry for "a{sv}" would require 30
bytes of memory (plus malloc overhead).
</para>
<para>
Tuple type info structures are 6 * sizeof (void *), plus 4 *
sizeof (void *) for each item in the tuple, plus the memory
required to store the type string itself.  A 2-item tuple, for
example, would have a type information structure that consumed
writable memory in the size of 14 * sizeof (void *) (plus type
string)  This means that on 32-bit systems, the cache entry for
"{sv}" would require 61 bytes of memory (plus malloc overhead).
</para>
<para>
This means that in total, for our "a{sv}" example, 91 bytes of
type information would be allocated.
</para>
<para>
The type information cache, additionally, uses a <see cref="HashTable"/> to
store and look up the cached items and stores a pointer to this
hash table in static storage.  The hash table is freed when there
are zero items in the type cache.
</para>
<para>
Although these sizes may seem large it is important to remember
that a program will probably only have a very small number of
different types of values in it and that only one type information
structure is required for many different values of the same type.
</para>
<para>
## Buffer Management Memory
</para>
<para>
<see cref="Variant"/> uses an internal buffer management structure to deal
with the various different possible sources of serialised data
that it uses.  The buffer is responsible for ensuring that the
correct call is made when the data is no longer in use by
<see cref="Variant"/>.  This may involve a g_free() or a g_slice_free() or
even g_mapped_file_unref().
</para>
<para>
One buffer management structure is used for each chunk of
serialised data.  The size of the buffer management structure
is 4 * (void *).  On 32-bit systems, that's 16 bytes.
</para>
<para>
## GVariant structure
</para>
<para>
The size of a <see cref="Variant"/> structure is 6 * (void *).  On 32-bit
systems, that's 24 bytes.
</para>
<para>
<see cref="Variant"/> structures only exist if they are explicitly created
with API calls.  For example, if a <see cref="Variant"/> is constructed out of
serialised data for the example given above (with the dictionary)
then although there are 9 individual values that comprise the
entire dictionary (two keys, two values, two variants containing
the values, two dictionary entries, plus the dictionary itself),
only 1 <see cref="Variant"/> instance exists -- the one referring to the
dictionary.
</para>
<para>
If calls are made to start accessing the other values then
<see cref="Variant"/> instances will exist for those values only for as long
as they are in use (ie: until you call <see cref="Variant.Unref()"/>).  The
type information is shared.  The serialised data and the buffer
management structure for that serialised data is shared by the
child.
</para>
<para>
## Summary
</para>
<para>
To put the entire example together, for our dictionary mapping
strings to variants (with two entries, as given above), we are
using 91 bytes of memory for type information, 29 bytes of memory
for the serialised data, 16 bytes for buffer management and 24
bytes for the <see cref="Variant"/> instance, or a total of 160 bytes, plus
malloc overhead.  If we were to use <see cref="Variant.GetChildValue(int)"/> to
access the two dictionary entries, we would use an additional 48
bytes.  If we were to have other dictionaries of the same type, we
would use more memory for the serialised data and buffer
management for those dictionaries, but the type information would
be shared.
</para>
</remarks>
</member>

</declaration>
