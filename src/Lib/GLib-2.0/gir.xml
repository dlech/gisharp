<?xml version="1.0" encoding="utf-8"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2" xmlns="http://www.gtk.org/introspection/core/1.0" xmlns:c="http://www.gtk.org/introspection/c/1.0" xmlns:glib="http://www.gtk.org/introspection/glib/1.0" xmlns:gs="http://gisharp.org/introspection/gisharp/1.0">
  <package name="glib-2.0" gs:managed-name="Glib2.0" />
  <c:include name="glib.h" gs:managed-name="Glib.h" />
  <namespace name="GLib" version="2.0" shared-library="/usr/local/opt/glib/lib/libgobject-2.0.0.dylib,/usr/local/opt/glib/lib/libglib-2.0.0.dylib" c:identifier-prefixes="G" c:symbol-prefixes="g,glib" gs:managed-name="GLib">
    <alias name="Quark" c:type="GQuark" gs:managed-name="Quark">
      <doc xml:space="preserve" filename="glib-2.0.c" line="1498">A GQuark is a non-zero integer which uniquely identifies a
particular string. A GQuark value of zero is associated to %NULL.</doc>
      <source-position filename="gquark.h" line="36" />
      <type name="guint32" c:type="guint32" gs:managed-name="System.UInt32" />
    </alias>
    <alias name="Strv" c:type="GStrv" gs:managed-name="Strv">
      <doc xml:space="preserve" filename="glib-2.0.c" line="1900">A typedef alias for gchar**. This is mostly useful when used together with
g_auto().</doc>
      <source-position filename="gstrfuncs.h" line="269" />
      <type name="utf8" c:type="gchar**" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
    </alias>
    <alias name="TimeSpan" c:type="GTimeSpan" gs:managed-name="TimeSpan">
      <doc xml:space="preserve" filename="gdatetime.h" line="80">A value representing an interval of time, in microseconds.</doc>
      <source-position filename="gdatetime.h" line="87" />
      <type name="gint64" c:type="gint64" gs:managed-name="System.Int64" />
      <constant name="DAY" value="86400000000" c:type="G_TIME_SPAN_DAY" version="2.26" gs:managed-name="Day">
        <doc xml:space="preserve" filename="gdatetime.h" line="35">Evaluates to a time span of one day.</doc>
        <source-position filename="gdatetime.h" line="42" />
        <type name="gint64" c:type="gint64" gs:managed-name="System.Int64" />
      </constant>
      <constant name="HOUR" value="3600000000" c:type="G_TIME_SPAN_HOUR" version="2.26" gs:managed-name="Hour">
        <doc xml:space="preserve" filename="gdatetime.h" line="44">Evaluates to a time span of one hour.</doc>
        <source-position filename="gdatetime.h" line="51" />
        <type name="gint64" c:type="gint64" gs:managed-name="System.Int64" />
      </constant>
      <constant name="MILLISECOND" value="1000" c:type="G_TIME_SPAN_MILLISECOND" version="2.26" gs:managed-name="Millisecond">
        <doc xml:space="preserve" filename="gdatetime.h" line="71">Evaluates to a time span of one millisecond.</doc>
        <source-position filename="gdatetime.h" line="78" />
        <type name="gint64" c:type="gint64" gs:managed-name="System.Int64" />
      </constant>
      <constant name="MINUTE" value="60000000" c:type="G_TIME_SPAN_MINUTE" version="2.26" gs:managed-name="Minute">
        <doc xml:space="preserve" filename="gdatetime.h" line="53">Evaluates to a time span of one minute.</doc>
        <source-position filename="gdatetime.h" line="60" />
        <type name="gint64" c:type="gint64" gs:managed-name="System.Int64" />
      </constant>
      <constant name="SECOND" value="1000000" c:type="G_TIME_SPAN_SECOND" version="2.26" gs:managed-name="Second">
        <doc xml:space="preserve" filename="gdatetime.h" line="62">Evaluates to a time span of one second.</doc>
        <source-position filename="gdatetime.h" line="69" />
        <type name="gint64" c:type="gint64" gs:managed-name="System.Int64" />
      </constant>
    </alias>
    <record name="Array" c:type="GArray" glib:type-name="GArray" glib:get-type="g_array_get_type" c:symbol-prefix="array" gs:inheritance-modifiers="abstract" gs:managed-name="Array">
      <doc xml:space="preserve" filename="glib-2.0.c" line="68">Contains the public fields of a GArray.</doc>
      <source-position filename="garray.h" line="45" />
      <field name="data" writable="1" gs:managed-name="Data">
        <doc xml:space="preserve" filename="glib-2.0.c" line="70">a pointer to the element data. The data may be moved as
    elements are added to the #GArray.</doc>
        <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
      </field>
      <field name="len" writable="1" gs:managed-name="Len">
        <doc xml:space="preserve" filename="glib-2.0.c" line="72">the number of elements in the #GArray not including the
    possible terminating zero element.</doc>
        <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
      </field>
      <function name="append_vals" c:identifier="g_array_append_vals" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="AppendVals">
        <doc xml:space="preserve" filename="glib-2.0.c" line="9055">Adds @len elements onto the end of the array.</doc>
        <source-position filename="garray.h" line="93" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="9063">the #GArray</doc>
          <array name="GLib.Array" c:type="GArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.Array" gs:is-pointer="1">
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </array>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9057">a #GArray</doc>
            <array name="GLib.Array" c:type="GArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.Array" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="data" transfer-ownership="none" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9058">a pointer to the elements to append to the end of the array</doc>
            <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
          <parameter name="len" transfer-ownership="none" gs:managed-name="len" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9059">the number of elements to append</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9057">a #GArray</doc>
            <array name="GLib.Array" c:type="GArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.Array" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="data" transfer-ownership="none" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9058">a pointer to the elements to append to the end of the array</doc>
            <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
          <parameter name="len" transfer-ownership="none" gs:managed-name="len" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9059">the number of elements to append</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="binary_search" c:identifier="g_array_binary_search" version="2.62" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="TryBinarySearch">
        <doc xml:space="preserve" filename="glib-2.0.c" line="9067">Checks whether @target exists in @array by performing a binary
search based on the given comparison function @compare_func which
get pointers to items as arguments. If the element is found, %TRUE
is returned and the element’s index is returned in @out_match_index
(if non-%NULL). Otherwise, %FALSE is returned and @out_match_index
is undefined. If @target exists multiple times in @array, the index
of the first instance is returned. This search is using a binary
search, so the @array must absolutely be sorted to return a correct
result (if not, the function may produce false-negative).

This example defines a comparison function and search an element in a #GArray:
|[&lt;!-- language="C" --&gt;
static gint*
cmpint (gconstpointer a, gconstpointer b)
{
  const gint *_a = a;
  const gint *_b = b;

  return *_a - *_b;
}
...
gint i = 424242;
guint matched_index;
gboolean result = g_array_binary_search (garray, &amp;i, cmpint, &amp;matched_index);
...
]|</doc>
        <source-position filename="garray.h" line="126" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="9102">%TRUE if @target is one of the elements of @array, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9069">a #GArray.</doc>
            <array name="GLib.Array" c:type="GArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.Array" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="target" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="target" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9070">a pointer to the item to look up.</doc>
            <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
          <parameter name="compare_func" transfer-ownership="none" gs:managed-name="compareFunc" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9071">A #GCompareFunc used to locate @target.</doc>
            <type name="CompareFunc" c:type="GCompareFunc" gs:managed-name="CompareFunc" />
          </parameter>
          <parameter name="out_match_index" direction="out" caller-allocates="1" transfer-ownership="none" optional="1" allow-none="1" gs:managed-name="outMatchIndex">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9072">return location
   for the index of the element, if found.</doc>
            <type name="guint" c:type="guint*" gs:managed-name="System.UInt32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9069">a #GArray.</doc>
            <array name="GLib.Array" c:type="GArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.Array" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="target" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="target" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9070">a pointer to the item to look up.</doc>
            <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
          <parameter name="compare_func" transfer-ownership="none" gs:managed-name="compareFunc" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9071">A #GCompareFunc used to locate @target.</doc>
            <type name="CompareFunc" c:type="GCompareFunc" gs:managed-name="CompareFunc" />
          </parameter>
          <parameter name="out_match_index" direction="out" caller-allocates="1" transfer-ownership="none" optional="1" allow-none="1" gs:managed-name="outMatchIndex">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9072">return location
   for the index of the element, if found.</doc>
            <type name="guint" c:type="guint*" gs:managed-name="System.UInt32" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="copy" c:identifier="g_array_copy" version="2.62" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="Copy">
        <doc xml:space="preserve" filename="glib-2.0.c" line="9107">Create a shallow copy of a #GArray. If the array elements consist of
pointers to data, the pointers are copied but the actual data is not.</doc>
        <source-position filename="garray.h" line="82" />
        <return-value transfer-ownership="container" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="9114">A copy of @array.</doc>
          <array name="GLib.Array" c:type="GArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.Array" gs:is-pointer="1">
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </array>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9109">A #GArray.</doc>
            <array name="GLib.Array" c:type="GArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.Array" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9109">A #GArray.</doc>
            <array name="GLib.Array" c:type="GArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.Array" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="free" c:identifier="g_array_free" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="Free">
        <doc xml:space="preserve" filename="glib-2.0.c" line="9119">Frees the memory allocated for the #GArray. If @free_segment is
%TRUE it frees the memory block holding the elements as well. Pass
%FALSE if you want to free the #GArray wrapper but preserve the
underlying array for use elsewhere. If the reference count of
@array is greater than one, the #GArray wrapper is preserved but
the size of  @array will be set to zero.

If array contents point to dynamically-allocated memory, they should
be freed separately if @free_seg is %TRUE and no @clear_func
function has been set for @array.

This function is not thread-safe. If using a #GArray from multiple
threads, use only the atomic g_array_ref() and g_array_unref()
functions.</doc>
        <source-position filename="garray.h" line="84" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="9139">the element data if @free_segment is %FALSE, otherwise
    %NULL. The element data should be freed using g_free().</doc>
          <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9121">a #GArray</doc>
            <array name="GLib.Array" c:type="GArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.Array" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="free_segment" transfer-ownership="none" gs:managed-name="freeSegment" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9122">if %TRUE the actual element data is freed as well</doc>
            <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9121">a #GArray</doc>
            <array name="GLib.Array" c:type="GArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.Array" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="free_segment" transfer-ownership="none" gs:managed-name="freeSegment" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9122">if %TRUE the actual element data is freed as well</doc>
            <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="get_element_size" c:identifier="g_array_get_element_size" version="2.22" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="GetElementSize">
        <doc xml:space="preserve" filename="glib-2.0.c" line="9144">Gets the size of the elements in @array.</doc>
        <source-position filename="garray.h" line="91" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="9150">Size of each element, in bytes</doc>
          <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9146">A #GArray</doc>
            <array name="GLib.Array" c:type="GArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.Array" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9146">A #GArray</doc>
            <array name="GLib.Array" c:type="GArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.Array" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="insert_vals" c:identifier="g_array_insert_vals" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="InsertVals">
        <doc xml:space="preserve" filename="glib-2.0.c" line="9207">Inserts @len elements into a #GArray at the given index.

If @index_ is greater than the array’s current length, the array is expanded.
The elements between the old end of the array and the newly inserted elements
will be initialised to zero if the array was configured to clear elements;
otherwise their values will be undefined.

If @index_ is less than the array’s current length, new entries will be
inserted into the array, and the existing entries above @index_ will be moved
upwards.

@data may be %NULL if (and only if) @len is zero. If @len is zero, this
function is a no-op.</doc>
        <source-position filename="garray.h" line="101" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="9228">the #GArray</doc>
          <array name="GLib.Array" c:type="GArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.Array" gs:is-pointer="1">
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </array>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9209">a #GArray</doc>
            <array name="GLib.Array" c:type="GArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.Array" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="index_" transfer-ownership="none" gs:managed-name="index" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9210">the index to place the elements at</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9211">a pointer to the elements to insert</doc>
            <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
          <parameter name="len" transfer-ownership="none" gs:managed-name="len" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9212">the number of elements to insert</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9209">a #GArray</doc>
            <array name="GLib.Array" c:type="GArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.Array" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="index_" transfer-ownership="none" gs:managed-name="index" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9210">the index to place the elements at</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9211">a pointer to the elements to insert</doc>
            <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
          <parameter name="len" transfer-ownership="none" gs:managed-name="len" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9212">the number of elements to insert</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="new" c:identifier="g_array_new" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="New">
        <doc xml:space="preserve" filename="glib-2.0.c" line="9232">Creates a new #GArray with a reference count of 1.</doc>
        <source-position filename="garray.h" line="70" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="9242">the new #GArray</doc>
          <array name="GLib.Array" c:type="GArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.Array" gs:is-pointer="1">
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </array>
        </return-value>
        <parameters>
          <parameter name="zero_terminated" transfer-ownership="none" gs:managed-name="zeroTerminated" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9234">%TRUE if the array should have an extra element at
    the end which is set to 0</doc>
            <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
          </parameter>
          <parameter name="clear_" transfer-ownership="none" gs:managed-name="clear" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9236">%TRUE if #GArray elements should be automatically cleared
    to 0 when they are allocated</doc>
            <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
          </parameter>
          <parameter name="element_size" transfer-ownership="none" gs:managed-name="elementSize" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9238">the size of each element in bytes</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="zero_terminated" transfer-ownership="none" gs:managed-name="zeroTerminated" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9234">%TRUE if the array should have an extra element at
    the end which is set to 0</doc>
            <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
          </parameter>
          <parameter name="clear_" transfer-ownership="none" gs:managed-name="clear" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9236">%TRUE if #GArray elements should be automatically cleared
    to 0 when they are allocated</doc>
            <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
          </parameter>
          <parameter name="element_size" transfer-ownership="none" gs:managed-name="elementSize" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9238">the size of each element in bytes</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="prepend_vals" c:identifier="g_array_prepend_vals" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="PrependVals">
        <doc xml:space="preserve" filename="glib-2.0.c" line="9266">Adds @len elements onto the start of the array.

@data may be %NULL if (and only if) @len is zero. If @len is zero, this
function is a no-op.

This operation is slower than g_array_append_vals() since the
existing elements in the array have to be moved to make space for
the new elements.</doc>
        <source-position filename="garray.h" line="97" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="9281">the #GArray</doc>
          <array name="GLib.Array" c:type="GArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.Array" gs:is-pointer="1">
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </array>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9268">a #GArray</doc>
            <array name="GLib.Array" c:type="GArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.Array" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9269">a pointer to the elements to prepend to the start of the array</doc>
            <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
          <parameter name="len" transfer-ownership="none" gs:managed-name="len" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9270">the number of elements to prepend, which may be zero</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9268">a #GArray</doc>
            <array name="GLib.Array" c:type="GArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.Array" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9269">a pointer to the elements to prepend to the start of the array</doc>
            <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
          <parameter name="len" transfer-ownership="none" gs:managed-name="len" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9270">the number of elements to prepend, which may be zero</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <method name="ref" c:identifier="g_array_ref" version="2.22" introspectable="1" gs:dll-name="glib-2.0" gs:managed-name="Ref" gs:special-func="ref" gs:pinvoke-only="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="9285">Atomically increments the reference count of @array by one.
This function is thread-safe and may be called from any thread.</doc>
        <source-position filename="garray.h" line="87" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="9292">The passed in #GArray</doc>
          <array name="GLib.Array" c:type="GArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.Array" gs:is-pointer="1">
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9287">A #GArray</doc>
            <array name="GLib.Array" c:type="GArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.Array" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <function name="remove_index" c:identifier="g_array_remove_index" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="RemoveIndex">
        <doc xml:space="preserve" filename="glib-2.0.c" line="9297">Removes the element at the given index from a #GArray. The following
elements are moved down one place.</doc>
        <source-position filename="garray.h" line="109" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="9305">the #GArray</doc>
          <array name="GLib.Array" c:type="GArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.Array" gs:is-pointer="1">
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </array>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9299">a #GArray</doc>
            <array name="GLib.Array" c:type="GArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.Array" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="index_" transfer-ownership="none" gs:managed-name="index" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9300">the index of the element to remove</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9299">a #GArray</doc>
            <array name="GLib.Array" c:type="GArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.Array" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="index_" transfer-ownership="none" gs:managed-name="index" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9300">the index of the element to remove</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="remove_index_fast" c:identifier="g_array_remove_index_fast" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="RemoveIndexFast">
        <doc xml:space="preserve" filename="glib-2.0.c" line="9309">Removes the element at the given index from a #GArray. The last
element in the array is used to fill in the space, so this function
does not preserve the order of the #GArray. But it is faster than
g_array_remove_index().</doc>
        <source-position filename="garray.h" line="112" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="9319">the #GArray</doc>
          <array name="GLib.Array" c:type="GArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.Array" gs:is-pointer="1">
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </array>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9311">a @GArray</doc>
            <array name="GLib.Array" c:type="GArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.Array" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="index_" transfer-ownership="none" gs:managed-name="index" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9312">the index of the element to remove</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9311">a @GArray</doc>
            <array name="GLib.Array" c:type="GArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.Array" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="index_" transfer-ownership="none" gs:managed-name="index" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9312">the index of the element to remove</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="remove_range" c:identifier="g_array_remove_range" version="2.4" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="RemoveRange">
        <doc xml:space="preserve" filename="glib-2.0.c" line="9323">Removes the given number of elements starting at the given index
from a #GArray.  The following elements are moved to close the gap.</doc>
        <source-position filename="garray.h" line="115" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="9332">the #GArray</doc>
          <array name="GLib.Array" c:type="GArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.Array" gs:is-pointer="1">
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </array>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9325">a @GArray</doc>
            <array name="GLib.Array" c:type="GArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.Array" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="index_" transfer-ownership="none" gs:managed-name="index" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9326">the index of the first element to remove</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
          <parameter name="length" transfer-ownership="none" gs:managed-name="length" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9327">the number of elements to remove</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9325">a @GArray</doc>
            <array name="GLib.Array" c:type="GArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.Array" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="index_" transfer-ownership="none" gs:managed-name="index" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9326">the index of the first element to remove</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
          <parameter name="length" transfer-ownership="none" gs:managed-name="length" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9327">the number of elements to remove</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="set_clear_func" c:identifier="g_array_set_clear_func" version="2.32" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="SetClearFunc">
        <doc xml:space="preserve" filename="glib-2.0.c" line="9337">Sets a function to clear an element of @array.

The @clear_func will be called when an element in the array
data segment is removed and when the array is freed and data
segment is deallocated as well. @clear_func will be passed a
pointer to the element to clear, rather than the element itself.

Note that in contrast with other uses of #GDestroyNotify
functions, @clear_func is expected to clear the contents of
the array element it is given, but not free the element itself.</doc>
        <source-position filename="garray.h" line="131" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9339">A #GArray</doc>
            <array name="GLib.Array" c:type="GArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.Array" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="clear_func" transfer-ownership="none" scope="async" gs:managed-name="clearFunc" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9340">a function to clear an element of @array</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify" gs:managed-name="DestroyNotify" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9339">A #GArray</doc>
            <array name="GLib.Array" c:type="GArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.Array" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="clear_func" transfer-ownership="none" scope="async" gs:managed-name="clearFunc" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9340">a function to clear an element of @array</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify" gs:managed-name="DestroyNotify" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="set_size" c:identifier="g_array_set_size" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="SetSize">
        <doc xml:space="preserve" filename="glib-2.0.c" line="9357">Sets the size of the array, expanding it if necessary. If the array
was created with @clear_ set to %TRUE, the new elements are set to 0.</doc>
        <source-position filename="garray.h" line="106" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="9365">the #GArray</doc>
          <array name="GLib.Array" c:type="GArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.Array" gs:is-pointer="1">
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </array>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9359">a #GArray</doc>
            <array name="GLib.Array" c:type="GArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.Array" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none" gs:managed-name="length" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9360">the new size of the #GArray</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9359">a #GArray</doc>
            <array name="GLib.Array" c:type="GArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.Array" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none" gs:managed-name="length" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9360">the new size of the #GArray</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="sized_new" c:identifier="g_array_sized_new" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="SizedNew">
        <doc xml:space="preserve" filename="glib-2.0.c" line="9369">Creates a new #GArray with @reserved_size elements preallocated and
a reference count of 1. This avoids frequent reallocation, if you
are going to add many elements to the array. Note however that the
size of the array is still 0.</doc>
        <source-position filename="garray.h" line="77" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="9383">the new #GArray</doc>
          <array name="GLib.Array" c:type="GArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.Array" gs:is-pointer="1">
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </array>
        </return-value>
        <parameters>
          <parameter name="zero_terminated" transfer-ownership="none" gs:managed-name="zeroTerminated" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9371">%TRUE if the array should have an extra element at
    the end with all bits cleared</doc>
            <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
          </parameter>
          <parameter name="clear_" transfer-ownership="none" gs:managed-name="clear" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9373">%TRUE if all bits in the array should be cleared to 0 on
    allocation</doc>
            <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
          </parameter>
          <parameter name="element_size" transfer-ownership="none" gs:managed-name="elementSize" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9375">size of each element in the array</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
          <parameter name="reserved_size" transfer-ownership="none" gs:managed-name="reservedSize" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9376">number of elements preallocated</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="zero_terminated" transfer-ownership="none" gs:managed-name="zeroTerminated" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9371">%TRUE if the array should have an extra element at
    the end with all bits cleared</doc>
            <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
          </parameter>
          <parameter name="clear_" transfer-ownership="none" gs:managed-name="clear" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9373">%TRUE if all bits in the array should be cleared to 0 on
    allocation</doc>
            <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
          </parameter>
          <parameter name="element_size" transfer-ownership="none" gs:managed-name="elementSize" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9375">size of each element in the array</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
          <parameter name="reserved_size" transfer-ownership="none" gs:managed-name="reservedSize" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9376">number of elements preallocated</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="sort" c:identifier="g_array_sort" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="Sort">
        <doc xml:space="preserve" filename="glib-2.0.c" line="9387">Sorts a #GArray using @compare_func which should be a qsort()-style
comparison function (returns less than zero for first arg is less
than second arg, zero for equal, greater zero if first arg is
greater than second arg).

This is guaranteed to be a stable sort since version 2.32.</doc>
        <source-position filename="garray.h" line="119" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9389">a #GArray</doc>
            <array name="GLib.Array" c:type="GArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.Array" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="compare_func" transfer-ownership="none" gs:managed-name="compareFunc" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9390">comparison function</doc>
            <type name="CompareFunc" c:type="GCompareFunc" gs:managed-name="CompareFunc" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9389">a #GArray</doc>
            <array name="GLib.Array" c:type="GArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.Array" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="compare_func" transfer-ownership="none" gs:managed-name="compareFunc" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9390">comparison function</doc>
            <type name="CompareFunc" c:type="GCompareFunc" gs:managed-name="CompareFunc" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="sort_with_data" c:identifier="g_array_sort_with_data" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="SortWithData">
        <doc xml:space="preserve" filename="glib-2.0.c" line="9401">Like g_array_sort(), but the comparison function receives an extra
user data argument.

This is guaranteed to be a stable sort since version 2.32.

There used to be a comment here about making the sort stable by
using the addresses of the elements in the comparison function.
This did not actually work, so any such code should be removed.</doc>
        <source-position filename="garray.h" line="122" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9403">a #GArray</doc>
            <array name="GLib.Array" c:type="GArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.Array" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="compare_func" transfer-ownership="none" closure="2" gs:managed-name="compareFunc" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9404">comparison function</doc>
            <type name="CompareDataFunc" c:type="GCompareDataFunc" gs:managed-name="CompareDataFunc" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9405">data to pass to @compare_func</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9403">a #GArray</doc>
            <array name="GLib.Array" c:type="GArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.Array" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="compare_func" transfer-ownership="none" closure="2" gs:managed-name="compareFunc" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9404">comparison function</doc>
            <type name="CompareDataFunc" c:type="GCompareDataFunc" gs:managed-name="CompareDataFunc" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="steal" c:identifier="g_array_steal" version="2.64" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="Steal">
        <doc xml:space="preserve" filename="glib-2.0.c" line="9418">Frees the data in the array and resets the size to zero, while
the underlying array is preserved for use elsewhere and returned
to the caller.

If the array was created with the @zero_terminate property
set to %TRUE, the returned data is zero terminated too.

If array elements contain dynamically-allocated memory,
the array elements should also be freed by the caller.

A short example of use:
|[&lt;!-- language="C" --&gt;
...
gpointer data;
gsize data_len;
data = g_array_steal (some_array, &amp;data_len);
...
]|</doc>
        <source-position filename="garray.h" line="74" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="9443">the element data, which should be
    freed using g_free().</doc>
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9420">a #GArray.</doc>
            <array name="GLib.Array" c:type="GArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.Array" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="len" direction="out" caller-allocates="1" transfer-ownership="none" optional="1" allow-none="1" gs:managed-name="len">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9421">pointer to retrieve the number of
   elements of the original array</doc>
            <type name="gsize" c:type="gsize*" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9420">a #GArray.</doc>
            <array name="GLib.Array" c:type="GArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.Array" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="len" direction="out" caller-allocates="1" transfer-ownership="none" optional="1" allow-none="1" gs:managed-name="len">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9421">pointer to retrieve the number of
   elements of the original array</doc>
            <type name="gsize" c:type="gsize*" gs:managed-name="System.Int32" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <method name="unref" c:identifier="g_array_unref" version="2.22" introspectable="1" gs:dll-name="glib-2.0" gs:managed-name="Unref" gs:special-func="unref" gs:pinvoke-only="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="9449">Atomically decrements the reference count of @array by one. If the
reference count drops to 0, all memory allocated by the array is
released. This function is thread-safe and may be called from any
thread.</doc>
        <source-position filename="garray.h" line="89" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="9451">A #GArray</doc>
            <array name="GLib.Array" c:type="GArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.Array" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_array_get_type" gs:access-modifiers="private" gs:dll-name="gobject-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </record>
    <record name="ByteArray" c:type="GByteArray" glib:type-name="GByteArray" glib:get-type="g_byte_array_get_type" c:symbol-prefix="byte_array" gs:managed-name="ByteArray">
      <doc xml:space="preserve" filename="glib-2.0.c" line="88">Contains the public fields of a GByteArray.</doc>
      <source-position filename="garray.h" line="51" />
      <field name="data" writable="1" gs:managed-name="Data">
        <doc xml:space="preserve" filename="glib-2.0.c" line="90">a pointer to the element data. The data may be moved as
    elements are added to the #GByteArray</doc>
        <type name="guint8" c:type="guint8*" gs:managed-name="System.Byte" gs:is-pointer="1" />
      </field>
      <field name="len" writable="1" gs:managed-name="Len">
        <doc xml:space="preserve" filename="glib-2.0.c" line="92">the number of elements in the #GByteArray</doc>
        <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
      </field>
      <method name="append" c:identifier="g_byte_array_append" introspectable="1" gs:dll-name="glib-2.0" gs:managed-name="Append">
        <doc xml:space="preserve" filename="glib-2.0.c" line="12771">Adds the given bytes to the end of the #GByteArray.
The array will grow in size automatically if necessary.</doc>
        <source-position filename="garray.h" line="251" />
        <return-value skip="1" transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="12780">the #GByteArray</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.ByteArray" gs:is-pointer="1">
            <type name="guint8" c:type="guint8" gs:managed-name="System.Byte" />
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="12773">a #GByteArray</doc>
            <array name="GLib.ByteArray" c:type="GByteArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.ByteArray" gs:is-pointer="1">
              <type name="guint8" c:type="guint8" gs:managed-name="System.Byte" />
            </array>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="12774">the byte data to be added</doc>
            <array length="1" zero-terminated="0" c:type="const guint8*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="guint8" c:type="guint8" gs:managed-name="System.Byte" />
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none" gs:managed-name="len" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="12775">the number of bytes to add</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="data" transfer-ownership="none" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="12774">the byte data to be added</doc>
            <array length="1" zero-terminated="0" c:type="const guint8*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="guint8" c:type="guint8" gs:managed-name="System.Byte" />
            </array>
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="free" c:identifier="g_byte_array_free" introspectable="1" gs:dll-name="glib-2.0" gs:managed-name="Free">
        <doc xml:space="preserve" filename="glib-2.0.c" line="12784">Frees the memory allocated by the #GByteArray. If @free_segment is
%TRUE it frees the actual byte data. If the reference count of
@array is greater than one, the #GByteArray wrapper is preserved but
the size of @array will be set to zero.</doc>
        <source-position filename="garray.h" line="242" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="12794">the element data if @free_segment is %FALSE, otherwise
         %NULL.  The element data should be freed using g_free().</doc>
          <type name="guint8" c:type="guint8*" gs:managed-name="System.Byte" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="12786">a #GByteArray</doc>
            <array name="GLib.ByteArray" c:type="GByteArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.ByteArray" gs:is-pointer="1">
              <type name="guint8" c:type="guint8" gs:managed-name="System.Byte" />
            </array>
          </instance-parameter>
          <parameter name="free_segment" transfer-ownership="none" gs:managed-name="freeSegment" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="12787">if %TRUE the actual byte data is freed as well</doc>
            <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="free_segment" transfer-ownership="none" gs:managed-name="freeSegment" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="12787">if %TRUE the actual byte data is freed as well</doc>
            <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="free_to_bytes" c:identifier="g_byte_array_free_to_bytes" version="2.32" introspectable="1" gs:dll-name="glib-2.0" gs:managed-name="FreeToBytes">
        <doc xml:space="preserve" filename="glib-2.0.c" line="12799">Transfers the data from the #GByteArray into a new immutable #GBytes.

The #GByteArray is freed unless the reference count of @array is greater
than one, the #GByteArray wrapper is preserved but the size of @array
will be set to zero.

This is identical to using g_bytes_new_take() and g_byte_array_free()
together.</doc>
        <source-position filename="garray.h" line="245" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="12813">a new immutable #GBytes representing same
    byte data that was in the array</doc>
          <type name="Bytes" c:type="GBytes*" gs:managed-name="Bytes" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="full" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="12801">a #GByteArray</doc>
            <array name="GLib.ByteArray" c:type="GByteArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.ByteArray" gs:is-pointer="1">
              <type name="guint8" c:type="guint8" gs:managed-name="System.Byte" />
            </array>
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <constructor name="new" c:identifier="g_byte_array_new" introspectable="1" gs:dll-name="glib-2.0" gs:managed-name="New">
        <doc xml:space="preserve" filename="glib-2.0.c" line="12818">Creates a new #GByteArray with a reference count of 1.</doc>
        <source-position filename="garray.h" line="232" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="12823">the new #GByteArray</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.ByteArray" gs:is-pointer="1">
            <type name="guint8" c:type="guint8" gs:managed-name="System.Byte" />
          </array>
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </constructor>
      <constructor name="new_take" c:identifier="g_byte_array_new_take" version="2.32" introspectable="1" gs:dll-name="glib-2.0" gs:managed-name="NewTake">
        <doc xml:space="preserve" filename="glib-2.0.c" line="12827">Create byte array containing the data. The data will be owned by the array
and will be freed with g_free(), i.e. it could be allocated using g_strdup().</doc>
        <source-position filename="garray.h" line="234" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="12836">a new #GByteArray</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.ByteArray" gs:is-pointer="1">
            <type name="guint8" c:type="guint8" gs:managed-name="System.Byte" />
          </array>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="full" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="12829">byte data for the array</doc>
            <array length="1" zero-terminated="0" c:type="guint8*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="guint8" c:type="guint8" gs:managed-name="System.Byte" />
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none" gs:managed-name="len" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="12830">length of @data</doc>
            <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="data" transfer-ownership="full" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="12829">byte data for the array</doc>
            <array length="1" zero-terminated="0" c:type="guint8*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="guint8" c:type="guint8" gs:managed-name="System.Byte" />
            </array>
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <method name="prepend" c:identifier="g_byte_array_prepend" introspectable="1" gs:dll-name="glib-2.0" gs:managed-name="Prepend">
        <doc xml:space="preserve" filename="glib-2.0.c" line="12840">Adds the given data to the start of the #GByteArray.
The array will grow in size automatically if necessary.</doc>
        <source-position filename="garray.h" line="255" />
        <return-value skip="1" transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="12849">the #GByteArray</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.ByteArray" gs:is-pointer="1">
            <type name="guint8" c:type="guint8" gs:managed-name="System.Byte" />
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="12842">a #GByteArray</doc>
            <array name="GLib.ByteArray" c:type="GByteArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.ByteArray" gs:is-pointer="1">
              <type name="guint8" c:type="guint8" gs:managed-name="System.Byte" />
            </array>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="12843">the byte data to be added</doc>
            <array length="1" zero-terminated="0" c:type="const guint8*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="guint8" c:type="guint8" gs:managed-name="System.Byte" />
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none" gs:managed-name="len" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="12844">the number of bytes to add</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="data" transfer-ownership="none" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="12843">the byte data to be added</doc>
            <array length="1" zero-terminated="0" c:type="const guint8*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="guint8" c:type="guint8" gs:managed-name="System.Byte" />
            </array>
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="ref" c:identifier="g_byte_array_ref" version="2.22" introspectable="1" gs:dll-name="glib-2.0" gs:managed-name="Ref" gs:special-func="ref" gs:pinvoke-only="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="12853">Atomically increments the reference count of @array by one.
This function is thread-safe and may be called from any thread.</doc>
        <source-position filename="garray.h" line="247" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="12860">The passed in #GByteArray</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.ByteArray" gs:is-pointer="1">
            <type name="guint8" c:type="guint8" gs:managed-name="System.Byte" />
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="12855">A #GByteArray</doc>
            <array name="GLib.ByteArray" c:type="GByteArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.ByteArray" gs:is-pointer="1">
              <type name="guint8" c:type="guint8" gs:managed-name="System.Byte" />
            </array>
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="remove_index" c:identifier="g_byte_array_remove_index" introspectable="1" gs:dll-name="glib-2.0" gs:managed-name="RemoveIndex">
        <doc xml:space="preserve" filename="glib-2.0.c" line="12865">Removes the byte at the given index from a #GByteArray.
The following bytes are moved down one place.</doc>
        <source-position filename="garray.h" line="262" />
        <return-value skip="1" transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="12873">the #GByteArray</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.ByteArray" gs:is-pointer="1">
            <type name="guint8" c:type="guint8" gs:managed-name="System.Byte" />
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="12867">a #GByteArray</doc>
            <array name="GLib.ByteArray" c:type="GByteArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.ByteArray" gs:is-pointer="1">
              <type name="guint8" c:type="guint8" gs:managed-name="System.Byte" />
            </array>
          </instance-parameter>
          <parameter name="index_" transfer-ownership="none" gs:managed-name="index" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="12868">the index of the byte to remove</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="index_" transfer-ownership="none" gs:managed-name="index" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="12868">the index of the byte to remove</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="remove_index_fast" c:identifier="g_byte_array_remove_index_fast" introspectable="1" gs:dll-name="glib-2.0" gs:managed-name="RemoveIndexFast">
        <doc xml:space="preserve" filename="glib-2.0.c" line="12877">Removes the byte at the given index from a #GByteArray. The last
element in the array is used to fill in the space, so this function
does not preserve the order of the #GByteArray. But it is faster
than g_byte_array_remove_index().</doc>
        <source-position filename="garray.h" line="265" />
        <return-value skip="1" transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="12887">the #GByteArray</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.ByteArray" gs:is-pointer="1">
            <type name="guint8" c:type="guint8" gs:managed-name="System.Byte" />
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="12879">a #GByteArray</doc>
            <array name="GLib.ByteArray" c:type="GByteArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.ByteArray" gs:is-pointer="1">
              <type name="guint8" c:type="guint8" gs:managed-name="System.Byte" />
            </array>
          </instance-parameter>
          <parameter name="index_" transfer-ownership="none" gs:managed-name="index" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="12880">the index of the byte to remove</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="index_" transfer-ownership="none" gs:managed-name="index" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="12880">the index of the byte to remove</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="remove_range" c:identifier="g_byte_array_remove_range" version="2.4" introspectable="1" gs:dll-name="glib-2.0" gs:managed-name="RemoveRange">
        <doc xml:space="preserve" filename="glib-2.0.c" line="12891">Removes the given number of bytes starting at the given index from a
#GByteArray.  The following elements are moved to close the gap.</doc>
        <source-position filename="garray.h" line="268" />
        <return-value skip="1" transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="12900">the #GByteArray</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.ByteArray" gs:is-pointer="1">
            <type name="guint8" c:type="guint8" gs:managed-name="System.Byte" />
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="12893">a @GByteArray</doc>
            <array name="GLib.ByteArray" c:type="GByteArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.ByteArray" gs:is-pointer="1">
              <type name="guint8" c:type="guint8" gs:managed-name="System.Byte" />
            </array>
          </instance-parameter>
          <parameter name="index_" transfer-ownership="none" gs:managed-name="index" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="12894">the index of the first byte to remove</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
          <parameter name="length" transfer-ownership="none" gs:managed-name="length" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="12895">the number of bytes to remove</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="index_" transfer-ownership="none" gs:managed-name="index" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="12894">the index of the first byte to remove</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
          <parameter name="length" transfer-ownership="none" gs:managed-name="length" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="12895">the number of bytes to remove</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_size" c:identifier="g_byte_array_set_size" introspectable="1" gs:dll-name="glib-2.0" gs:managed-name="SetSize">
        <doc xml:space="preserve" filename="glib-2.0.c" line="12905">Sets the size of the #GByteArray, expanding it if necessary.</doc>
        <source-position filename="garray.h" line="259" />
        <return-value skip="1" transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="12912">the #GByteArray</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.ByteArray" gs:is-pointer="1">
            <type name="guint8" c:type="guint8" gs:managed-name="System.Byte" />
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="12907">a #GByteArray</doc>
            <array name="GLib.ByteArray" c:type="GByteArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.ByteArray" gs:is-pointer="1">
              <type name="guint8" c:type="guint8" gs:managed-name="System.Byte" />
            </array>
          </instance-parameter>
          <parameter name="length" transfer-ownership="none" gs:managed-name="length" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="12908">the new size of the #GByteArray</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="length" transfer-ownership="none" gs:managed-name="length" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="12908">the new size of the #GByteArray</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <constructor name="sized_new" c:identifier="g_byte_array_sized_new" introspectable="1" gs:dll-name="glib-2.0" gs:managed-name="SizedNew">
        <doc xml:space="preserve" filename="glib-2.0.c" line="12916">Creates a new #GByteArray with @reserved_size bytes preallocated.
This avoids frequent reallocation, if you are going to add many
bytes to the array. Note however that the size of the array is still
0.</doc>
        <source-position filename="garray.h" line="240" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="12925">the new #GByteArray</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.ByteArray" gs:is-pointer="1">
            <type name="guint8" c:type="guint8" gs:managed-name="System.Byte" />
          </array>
        </return-value>
        <parameters>
          <parameter name="reserved_size" transfer-ownership="none" gs:managed-name="reservedSize" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="12918">number of bytes preallocated</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="reserved_size" transfer-ownership="none" gs:managed-name="reservedSize" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="12918">number of bytes preallocated</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <method name="sort" c:identifier="g_byte_array_sort" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="Sort">
        <doc xml:space="preserve" filename="glib-2.0.c" line="12929">Sorts a byte array, using @compare_func which should be a
qsort()-style comparison function (returns less than zero for first
arg is less than second arg, zero for equal, greater than zero if
first arg is greater than second arg).

If two array elements compare equal, their order in the sorted array
is undefined. If you want equal elements to keep their order (i.e.
you want a stable sort) you can write a comparison function that,
if two elements would otherwise compare equal, compares them by
their addresses.</doc>
        <source-position filename="garray.h" line="272" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="12931">a #GByteArray</doc>
            <array name="GLib.ByteArray" c:type="GByteArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.ByteArray" gs:is-pointer="1">
              <type name="guint8" c:type="guint8" gs:managed-name="System.Byte" />
            </array>
          </instance-parameter>
          <parameter name="compare_func" transfer-ownership="none" gs:managed-name="compareFunc" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="12932">comparison function</doc>
            <type name="CompareFunc" c:type="GCompareFunc" gs:managed-name="CompareFunc" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="compare_func" transfer-ownership="none" gs:managed-name="compareFunc" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="12932">comparison function</doc>
            <type name="CompareFunc" c:type="GCompareFunc" gs:managed-name="CompareFunc" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="sort_with_data" c:identifier="g_byte_array_sort_with_data" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="SortWithData">
        <doc xml:space="preserve" filename="glib-2.0.c" line="12947">Like g_byte_array_sort(), but the comparison function takes an extra
user data argument.</doc>
        <source-position filename="garray.h" line="275" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="12949">a #GByteArray</doc>
            <array name="GLib.ByteArray" c:type="GByteArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.ByteArray" gs:is-pointer="1">
              <type name="guint8" c:type="guint8" gs:managed-name="System.Byte" />
            </array>
          </instance-parameter>
          <parameter name="compare_func" transfer-ownership="none" closure="1" scope="call" gs:managed-name="compareFunc" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="12950">comparison function</doc>
            <type name="CompareDataFunc" c:type="GCompareDataFunc" gs:managed-name="CompareDataFunc" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="12951">data to pass to @compare_func</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="compare_func" transfer-ownership="none" closure="1" scope="call" gs:managed-name="compareFunc" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="12950">comparison function</doc>
            <type name="CompareDataFunc" c:type="GCompareDataFunc" gs:managed-name="CompareDataFunc" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="unref" c:identifier="g_byte_array_unref" version="2.22" introspectable="1" gs:dll-name="glib-2.0" gs:managed-name="Unref" gs:special-func="unref" gs:pinvoke-only="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="12974">Atomically decrements the reference count of @array by one. If the
reference count drops to 0, all memory allocated by the array is
released. This function is thread-safe and may be called from any
thread.</doc>
        <source-position filename="garray.h" line="249" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="12976">A #GByteArray</doc>
            <array name="GLib.ByteArray" c:type="GByteArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.ByteArray" gs:is-pointer="1">
              <type name="guint8" c:type="guint8" gs:managed-name="System.Byte" />
            </array>
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_byte_array_get_type" gs:access-modifiers="private" gs:dll-name="gobject-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </record>
    <record name="Bytes" c:type="GBytes" version="2.32" glib:type-name="GBytes" glib:get-type="g_bytes_get_type" c:symbol-prefix="bytes" gs:managed-name="Bytes">
      <doc xml:space="preserve" filename="glib-2.0.c" line="98">A simple refcounted data type representing an immutable sequence of zero or
more bytes from an unspecified origin.

The purpose of a #GBytes is to keep the memory region that it holds
alive for as long as anyone holds a reference to the bytes.  When
the last reference count is dropped, the memory is released. Multiple
unrelated callers can use byte data in the #GBytes without coordinating
their activities, resting assured that the byte data will not change or
move while they hold a reference.

A #GBytes can come from many different origins that may have
different procedures for freeing the memory region.  Examples are
memory from g_malloc(), from memory slices, from a #GMappedFile or
memory from other allocators.

#GBytes work well as keys in #GHashTable. Use g_bytes_equal() and
g_bytes_hash() as parameters to g_hash_table_new() or g_hash_table_new_full().
#GBytes can also be used as keys in a #GTree by passing the g_bytes_compare()
function to g_tree_new().

The data pointed to by this bytes must not be modified. For a mutable
array of bytes see #GByteArray. Use g_bytes_unref_to_array() to create a
mutable array for a #GBytes sequence. To create an immutable #GBytes from
a mutable #GByteArray, use the g_byte_array_free_to_bytes() function.</doc>
      <source-position filename="garray.h" line="36" />
      <constructor name="new" c:identifier="g_bytes_new" version="2.32" gs:dll-name="glib-2.0" gs:managed-name="New">
        <doc xml:space="preserve" filename="glib-2.0.c" line="13071">Creates a new #GBytes from @data.

@data is copied. If @size is 0, @data may be %NULL.</doc>
        <source-position filename="gbytes.h" line="35" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="13081">a new #GBytes</doc>
          <type name="Bytes" c:type="GBytes*" gs:managed-name="Bytes" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="13073">
       the data to be used for the bytes</doc>
            <array length="1" zero-terminated="0" c:type="gconstpointer" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="guint8" gs:managed-name="System.Byte" />
            </array>
          </parameter>
          <parameter name="size" transfer-ownership="none" gs:managed-name="size" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="13075">the size of @data</doc>
            <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="13073">
       the data to be used for the bytes</doc>
            <array length="1" zero-terminated="0" c:type="gconstpointer" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="guint8" gs:managed-name="System.Byte" />
            </array>
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <constructor name="new_take" c:identifier="g_bytes_new_take" version="2.32" gs:dll-name="glib-2.0" gs:managed-name="NewTake">
        <doc xml:space="preserve" filename="glib-2.0.c" line="13125">Creates a new #GBytes from @data.

After this call, @data belongs to the bytes and may no longer be
modified by the caller.  g_free() will be called on @data when the
bytes is no longer in use. Because of this @data must have been created by
a call to g_malloc(), g_malloc0() or g_realloc() or by one of the many
functions that wrap these calls (such as g_new(), g_strdup(), etc).

For creating #GBytes with memory from other allocators, see
g_bytes_new_with_free_func().

@data may be %NULL if @size is 0.</doc>
        <source-position filename="gbytes.h" line="39" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="13144">a new #GBytes</doc>
          <type name="Bytes" c:type="GBytes*" gs:managed-name="Bytes" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="full" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="13127">
       the data to be used for the bytes</doc>
            <array length="1" zero-terminated="0" c:type="gpointer" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="guint8" gs:managed-name="System.Byte" />
            </array>
          </parameter>
          <parameter name="size" transfer-ownership="none" gs:managed-name="size" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="13129">the size of @data</doc>
            <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="data" transfer-ownership="full" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="13127">
       the data to be used for the bytes</doc>
            <array length="1" zero-terminated="0" c:type="gpointer" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="guint8" gs:managed-name="System.Byte" />
            </array>
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <constructor name="new_with_free_func" c:identifier="g_bytes_new_with_free_func" version="2.32" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="NewWithFreeFunc">
        <doc xml:space="preserve" filename="glib-2.0.c" line="13149">Creates a #GBytes from @data.

When the last reference is dropped, @free_func will be called with the
@user_data argument.

@data must not be modified after this call is made until @free_func has
been called to indicate that the bytes is no longer in use.

@data may be %NULL if @size is 0.</doc>
        <source-position filename="gbytes.h" line="47" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="13167">a new #GBytes</doc>
          <type name="Bytes" c:type="GBytes*" gs:managed-name="Bytes" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="13151">
       the data to be used for the bytes</doc>
            <array length="1" zero-terminated="0" c:type="gconstpointer" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="guint8" gs:managed-name="System.Byte" />
            </array>
          </parameter>
          <parameter name="size" transfer-ownership="none" gs:managed-name="size" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="13153">the size of @data</doc>
            <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="free_func" transfer-ownership="none" scope="async" gs:managed-name="freeFunc" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="13154">the function to call to release the data</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify" gs:managed-name="DestroyNotify" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="13155">data to pass to @free_func</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="13151">
       the data to be used for the bytes</doc>
            <array length="1" zero-terminated="0" c:type="gconstpointer" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="guint8" gs:managed-name="System.Byte" />
            </array>
          </parameter>
          <parameter name="free_func" transfer-ownership="none" scope="async" gs:managed-name="freeFunc" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="13154">the function to call to release the data</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify" gs:managed-name="DestroyNotify" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="13155">data to pass to @free_func</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <function name="compare" c:identifier="g_bytes_compare" version="2.32" gs:dll-name="glib-2.0" gs:managed-name="Compare" gs:special-func="compare">
        <doc xml:space="preserve" filename="glib-2.0.c" line="12987">Compares the two #GBytes values.

This function can be used to sort GBytes instances in lexicographical order.

If @bytes1 and @bytes2 have different length but the shorter one is a
prefix of the longer one then the shorter one is considered to be less than
the longer one. Otherwise the first byte where both differ is used for
comparison. If @bytes1 has a smaller value at that position it is
considered less, otherwise greater than @bytes2.</doc>
        <source-position filename="gbytes.h" line="85" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="13002">a negative value if @bytes1 is less than @bytes2, a positive value
         if @bytes1 is greater than @bytes2, and zero if @bytes1 is equal to
         @bytes2</doc>
          <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <parameter name="bytes1" transfer-ownership="none" gs:managed-name="bytes1" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="12989">a pointer to a #GBytes</doc>
            <type name="Bytes" c:type="gconstpointer" gs:managed-name="Bytes" gs:is-pointer="1" />
          </parameter>
          <parameter name="bytes2" transfer-ownership="none" gs:managed-name="bytes2" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="12990">a pointer to a #GBytes to compare with @bytes1</doc>
            <type name="Bytes" c:type="gconstpointer" gs:managed-name="Bytes" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="bytes1" transfer-ownership="none" gs:managed-name="bytes1" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="12989">a pointer to a #GBytes</doc>
            <type name="Bytes" c:type="gconstpointer" gs:managed-name="Bytes" gs:is-pointer="1" />
          </parameter>
          <parameter name="bytes2" transfer-ownership="none" gs:managed-name="bytes2" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="12990">a pointer to a #GBytes to compare with @bytes1</doc>
            <type name="Bytes" c:type="gconstpointer" gs:managed-name="Bytes" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <method name="equal" c:identifier="g_bytes_equal" version="2.32" gs:dll-name="glib-2.0" gs:managed-name="Equals" gs:equal="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="13009">Compares the two #GBytes values being pointed to and returns
%TRUE if they are equal.

This function can be passed to g_hash_table_new() as the @key_equal_func
parameter, when using non-%NULL #GBytes pointers as keys in a #GHashTable.</doc>
        <source-position filename="gbytes.h" line="81" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="13020">%TRUE if the two keys match.</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="bytes1" transfer-ownership="none" gs:managed-name="bytes1" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="13011">a pointer to a #GBytes</doc>
            <type name="Bytes" c:type="gconstpointer" gs:managed-name="Bytes" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="bytes2" transfer-ownership="none" gs:managed-name="bytes2" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="13012">a pointer to a #GBytes to compare with @bytes1</doc>
            <type name="Bytes" c:type="gconstpointer" gs:managed-name="Bytes" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="bytes2" transfer-ownership="none" gs:managed-name="bytes2" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="13012">a pointer to a #GBytes to compare with @bytes1</doc>
            <type name="Bytes" c:type="gconstpointer" gs:managed-name="Bytes" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <gs:managed-property name="get_data" version="2.32" gs:dll-name="glib-2.0" gs:managed-name="Data">
        <doc xml:space="preserve" filename="glib-2.0.c" line="13025">Get the byte data in the #GBytes. This data should not be modified.

This function will always return the same pointer for a given #GBytes.

%NULL may be returned if @size is 0. This is not guaranteed, as the #GBytes
may represent an empty string with @data non-%NULL and @size as 0. %NULL will
not be returned if @size is non-zero.</doc>
        <source-position filename="gbytes.h" line="58" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="13038">
         a pointer to the byte data, or %NULL</doc>
          <array length="0" zero-terminated="0" c:type="gconstpointer" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
            <type name="guint8" gs:managed-name="System.Byte" />
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="bytes" transfer-ownership="none" gs:managed-name="bytes" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="13027">a #GBytes</doc>
            <type name="Bytes" c:type="GBytes*" gs:managed-name="Bytes" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="size" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="size">
            <doc xml:space="preserve" filename="glib-2.0.c" line="13028">location to return size of byte data</doc>
            <type name="gsize" c:type="gsize*" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_data" c:identifier="g_bytes_get_data" version="2.32" gs:dll-name="glib-2.0" gs:managed-name="GetData" gs:property-getter-for="Data" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="13025">Get the byte data in the #GBytes. This data should not be modified.

This function will always return the same pointer for a given #GBytes.

%NULL may be returned if @size is 0. This is not guaranteed, as the #GBytes
may represent an empty string with @data non-%NULL and @size as 0. %NULL will
not be returned if @size is non-zero.</doc>
        <source-position filename="gbytes.h" line="58" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="13038">
         a pointer to the byte data, or %NULL</doc>
          <array length="0" zero-terminated="0" c:type="gconstpointer" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
            <type name="guint8" gs:managed-name="System.Byte" />
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="bytes" transfer-ownership="none" gs:managed-name="bytes" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="13027">a #GBytes</doc>
            <type name="Bytes" c:type="GBytes*" gs:managed-name="Bytes" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="size" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="size">
            <doc xml:space="preserve" filename="glib-2.0.c" line="13028">location to return size of byte data</doc>
            <type name="gsize" c:type="gsize*" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_size" version="2.32" gs:dll-name="glib-2.0" gs:managed-name="Size">
        <doc xml:space="preserve" filename="glib-2.0.c" line="13044">Get the size of the byte data in the #GBytes.

This function will always return the same value for a given #GBytes.</doc>
        <source-position filename="gbytes.h" line="62" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="13052">the size</doc>
          <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="bytes" transfer-ownership="none" gs:managed-name="bytes" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="13046">a #GBytes</doc>
            <type name="Bytes" c:type="GBytes*" gs:managed-name="Bytes" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_size" c:identifier="g_bytes_get_size" version="2.32" gs:dll-name="glib-2.0" gs:managed-name="GetSize" gs:property-getter-for="Size" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="13044">Get the size of the byte data in the #GBytes.

This function will always return the same value for a given #GBytes.</doc>
        <source-position filename="gbytes.h" line="62" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="13052">the size</doc>
          <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="bytes" transfer-ownership="none" gs:managed-name="bytes" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="13046">a #GBytes</doc>
            <type name="Bytes" c:type="GBytes*" gs:managed-name="Bytes" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="hash" c:identifier="g_bytes_hash" version="2.32" gs:dll-name="glib-2.0" gs:managed-name="GetHashCode" gs:hash="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="13057">Creates an integer hash code for the byte data in the #GBytes.

This function can be passed to g_hash_table_new() as the @key_hash_func
parameter, when using non-%NULL #GBytes pointers as keys in a #GHashTable.</doc>
        <source-position filename="gbytes.h" line="78" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="13066">a hash value corresponding to the key.</doc>
          <type name="guint" c:type="guint" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="bytes" transfer-ownership="none" gs:managed-name="bytes" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="13059">a pointer to a #GBytes key</doc>
            <type name="Bytes" c:type="gconstpointer" gs:managed-name="Bytes" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="new_from_bytes" c:identifier="g_bytes_new_from_bytes" version="2.32" gs:dll-name="glib-2.0" gs:managed-name="NewFromBytes">
        <doc xml:space="preserve" filename="glib-2.0.c" line="13086">Creates a #GBytes which is a subsection of another #GBytes. The @offset +
@length may not be longer than the size of @bytes.

A reference to @bytes will be held by the newly created #GBytes until
the byte data is no longer needed.

Since 2.56, if @offset is 0 and @length matches the size of @bytes, then
@bytes will be returned with the reference count incremented by 1. If @bytes
is a slice of another #GBytes, then the resulting #GBytes will reference
the same #GBytes instead of @bytes. This allows consumers to simplify the
usage of #GBytes when asynchronously writing to streams.</doc>
        <source-position filename="gbytes.h" line="53" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="13104">a new #GBytes</doc>
          <type name="Bytes" c:type="GBytes*" gs:managed-name="Bytes" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="bytes" transfer-ownership="none" gs:managed-name="bytes" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="13088">a #GBytes</doc>
            <type name="Bytes" c:type="GBytes*" gs:managed-name="Bytes" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none" gs:managed-name="offset" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="13089">offset which subsection starts at</doc>
            <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="length" transfer-ownership="none" gs:managed-name="length" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="13090">length of subsection</doc>
            <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="offset" transfer-ownership="none" gs:managed-name="offset" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="13089">offset which subsection starts at</doc>
            <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="length" transfer-ownership="none" gs:managed-name="length" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="13090">length of subsection</doc>
            <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="ref" c:identifier="g_bytes_ref" version="2.32" gs:dll-name="glib-2.0" gs:managed-name="Ref" gs:special-func="ref" gs:pinvoke-only="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="13172">Increase the reference count on @bytes.</doc>
        <source-position filename="gbytes.h" line="65" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="13178">the #GBytes</doc>
          <type name="Bytes" c:type="GBytes*" gs:managed-name="Bytes" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="bytes" transfer-ownership="none" gs:managed-name="bytes" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="13174">a #GBytes</doc>
            <type name="Bytes" c:type="GBytes*" gs:managed-name="Bytes" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="unref" c:identifier="g_bytes_unref" version="2.32" gs:dll-name="glib-2.0" gs:managed-name="Unref" gs:special-func="unref" gs:pinvoke-only="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="13183">Releases a reference on @bytes.  This may result in the bytes being
freed. If @bytes is %NULL, it will return immediately.</doc>
        <source-position filename="gbytes.h" line="68" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="bytes" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="bytes" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="13185">a #GBytes</doc>
            <type name="Bytes" c:type="GBytes*" gs:managed-name="Bytes" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="unref_to_array" c:identifier="g_bytes_unref_to_array" version="2.32" gs:dll-name="glib-2.0" gs:managed-name="UnrefToArray">
        <doc xml:space="preserve" filename="glib-2.0.c" line="13194">Unreferences the bytes, and returns a new mutable #GByteArray containing
the same byte data.

As an optimization, the byte data is transferred to the array without copying
if this was the last reference to bytes and bytes was created with
g_bytes_new(), g_bytes_new_take() or g_byte_array_free_to_bytes(). In all
other cases the data is copied.</doc>
        <source-position filename="gbytes.h" line="75" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="13206">a new mutable #GByteArray containing the same byte data</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.ByteArray" gs:is-pointer="1">
            <type name="guint8" c:type="guint8" gs:managed-name="System.Byte" />
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="bytes" transfer-ownership="full" gs:managed-name="bytes" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="13196">a #GBytes</doc>
            <type name="Bytes" c:type="GBytes*" gs:managed-name="Bytes" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="unref_to_data" c:identifier="g_bytes_unref_to_data" version="2.32" gs:dll-name="glib-2.0" gs:managed-name="UnrefToData">
        <doc xml:space="preserve" filename="glib-2.0.c" line="13211">Unreferences the bytes, and returns a pointer the same byte data
contents.

As an optimization, the byte data is returned without copying if this was
the last reference to bytes and bytes was created with g_bytes_new(),
g_bytes_new_take() or g_byte_array_free_to_bytes(). In all other cases the
data is copied.</doc>
        <source-position filename="gbytes.h" line="71" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="13224">a pointer to the same byte data, which should be
         freed with g_free()</doc>
          <array length="0" zero-terminated="0" c:type="gpointer" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
            <type name="guint8" gs:managed-name="System.Byte" />
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="bytes" transfer-ownership="full" gs:managed-name="bytes" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="13213">a #GBytes</doc>
            <type name="Bytes" c:type="GBytes*" gs:managed-name="Bytes" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="size" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="size">
            <doc xml:space="preserve" filename="glib-2.0.c" line="13214">location to place the length of the returned data</doc>
            <type name="gsize" c:type="gsize*" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_bytes_get_type" gs:access-modifiers="private" gs:dll-name="gobject-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </record>
    <callback name="CompareDataFunc" c:type="GCompareDataFunc" gs:dll-name="glib-2.0" gs:managed-name="CompareDataFunc">
      <doc xml:space="preserve" filename="glib-2.0.c" line="130">Specifies the type of a comparison function used to compare two
values.  The function should return a negative integer if the first
value comes before the second, 0 if they are equal, or a positive
integer if the first value comes after the second.</doc>
      <source-position filename="gtypes.h" line="108" />
      <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
        <doc xml:space="preserve" filename="glib-2.0.c" line="141">negative value if @a &lt; @b; zero if @a = @b; positive
         value if @a &gt; @b</doc>
        <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
      </return-value>
      <parameters>
        <parameter name="a" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="a" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="132">a value</doc>
          <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </parameter>
        <parameter name="b" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="b" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="133">a value to compare with</doc>
          <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="2" gs:managed-name="userData" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="134">user data</doc>
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </parameter>
      </parameters>
      <gs:managed-parameters>
        <parameter name="a" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="a" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="132">a value</doc>
          <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </parameter>
        <parameter name="b" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="b" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="133">a value to compare with</doc>
          <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </parameter>
      </gs:managed-parameters>
    </callback>
    <callback name="CompareFunc" c:type="GCompareFunc" gs:dll-name="glib-2.0" gs:managed-name="CompareFunc">
      <doc xml:space="preserve" filename="glib-2.0.c" line="146">Specifies the type of a comparison function used to compare two
values.  The function should return a negative integer if the first
value comes before the second, 0 if they are equal, or a positive
integer if the first value comes after the second.</doc>
      <source-position filename="gtypes.h" line="106" />
      <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
        <doc xml:space="preserve" filename="glib-2.0.c" line="156">negative value if @a &lt; @b; zero if @a = @b; positive
         value if @a &gt; @b</doc>
        <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
      </return-value>
      <parameters>
        <parameter name="a" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="a" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="148">a value</doc>
          <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </parameter>
        <parameter name="b" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="b" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="149">a value to compare with</doc>
          <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </parameter>
      </parameters>
      <gs:managed-parameters>
        <parameter name="a" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="a" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="148">a value</doc>
          <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </parameter>
        <parameter name="b" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="b" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="149">a value to compare with</doc>
          <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </parameter>
      </gs:managed-parameters>
    </callback>
    <record name="Cond" c:type="GCond" gs:managed-name="Cond">
      <doc xml:space="preserve" filename="glib-2.0.c" line="161">The #GCond struct is an opaque data structure that represents a
condition. Threads can block on a #GCond if they find a certain
condition to be false. If other threads change the state of this
condition they signal the #GCond, and that causes the waiting
threads to be woken up.

Consider the following example of a shared variable.  One or more
threads can wait for data to be published to the variable and when
another thread publishes the data, it can signal one of the waiting
threads to wake up to collect the data.

Here is an example for using GCond to block a thread until a condition
is satisfied:
|[&lt;!-- language="C" --&gt;
  gpointer current_data = NULL;
  GMutex data_mutex;
  GCond data_cond;

  void
  push_data (gpointer data)
  {
    g_mutex_lock (&amp;data_mutex);
    current_data = data;
    g_cond_signal (&amp;data_cond);
    g_mutex_unlock (&amp;data_mutex);
  }

  gpointer
  pop_data (void)
  {
    gpointer data;

    g_mutex_lock (&amp;data_mutex);
    while (!current_data)
      g_cond_wait (&amp;data_cond, &amp;data_mutex);
    data = current_data;
    current_data = NULL;
    g_mutex_unlock (&amp;data_mutex);

    return data;
  }
]|
Whenever a thread calls pop_data() now, it will wait until
current_data is non-%NULL, i.e. until some other thread
has called push_data().

The example shows that use of a condition variable must always be
paired with a mutex.  Without the use of a mutex, there would be a
race between the check of @current_data by the while loop in
pop_data() and waiting. Specifically, another thread could set
@current_data after the check, and signal the cond (with nobody
waiting on it) before the first thread goes to sleep. #GCond is
specifically useful for its ability to release the mutex and go
to sleep atomically.

It is also important to use the g_cond_wait() and g_cond_wait_until()
functions only inside a loop which checks for the condition to be
true.  See g_cond_wait() for an explanation of why the condition may
not be true even after it returns.

If a #GCond is allocated in static storage then it can be used
without initialisation.  Otherwise, you should call g_cond_init()
on it and g_cond_clear() when done.

A #GCond should only be accessed via the g_cond_ functions.</doc>
      <source-position filename="gthread.h" line="77" />
      <field name="p" readable="0" private="1" gs:managed-name="P">
        <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
      </field>
      <field name="i" readable="0" private="1" gs:managed-name="I">
        <array zero-terminated="0" fixed-size="2" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
          <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
        </array>
      </field>
      <method name="broadcast" c:identifier="g_cond_broadcast" gs:dll-name="glib-2.0" gs:managed-name="Broadcast">
        <doc xml:space="preserve" filename="glib-2.0.c" line="13736">If threads are waiting for @cond, all of them are unblocked.
If no threads are waiting for @cond, this function has no effect.
It is good practice to lock the same mutex as the waiting threads
while calling this function, though not required.</doc>
        <source-position filename="gthread.h" line="212" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="cond" transfer-ownership="none" gs:managed-name="cond" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="13738">a #GCond</doc>
            <type name="Cond" c:type="GCond*" gs:managed-name="Cond" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="clear" c:identifier="g_cond_clear" version="2.32" gs:dll-name="glib-2.0" gs:managed-name="Clear">
        <doc xml:space="preserve" filename="glib-2.0.c" line="13747">Frees the resources allocated to a #GCond with g_cond_init().

This function should not be used with a #GCond that has been
statically allocated.

Calling g_cond_clear() for a #GCond on which threads are
blocking leads to undefined behaviour.</doc>
        <source-position filename="gthread.h" line="205" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="cond" transfer-ownership="none" gs:managed-name="cond" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="13749">an initialised #GCond</doc>
            <type name="Cond" c:type="GCond*" gs:managed-name="Cond" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="init" c:identifier="g_cond_init" version="2.32" gs:dll-name="glib-2.0" gs:managed-name="Init">
        <doc xml:space="preserve" filename="glib-2.0.c" line="13763">Initialises a #GCond so that it can be used.

This function is useful to initialise a #GCond that has been
allocated as part of a larger structure.  It is not necessary to
initialise a #GCond that has been statically allocated.

To undo the effect of g_cond_init() when a #GCond is no longer
needed, use g_cond_clear().

Calling g_cond_init() on an already-initialised #GCond leads
to undefined behaviour.</doc>
        <source-position filename="gthread.h" line="203" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="cond" transfer-ownership="none" gs:managed-name="cond" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="13765">an uninitialized #GCond</doc>
            <type name="Cond" c:type="GCond*" gs:managed-name="Cond" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="signal" c:identifier="g_cond_signal" gs:dll-name="glib-2.0" gs:managed-name="Signal">
        <doc xml:space="preserve" filename="glib-2.0.c" line="13783">If threads are waiting for @cond, at least one of them is unblocked.
If no threads are waiting for @cond, this function has no effect.
It is good practice to hold the same lock as the waiting thread
while calling this function, though not required.</doc>
        <source-position filename="gthread.h" line="210" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="cond" transfer-ownership="none" gs:managed-name="cond" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="13785">a #GCond</doc>
            <type name="Cond" c:type="GCond*" gs:managed-name="Cond" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="wait" c:identifier="g_cond_wait" gs:dll-name="glib-2.0" gs:managed-name="Wait">
        <doc xml:space="preserve" filename="glib-2.0.c" line="13794">Atomically releases @mutex and waits until @cond is signalled.
When this function returns, @mutex is locked again and owned by the
calling thread.

When using condition variables, it is possible that a spurious wakeup
may occur (ie: g_cond_wait() returns even though g_cond_signal() was
not called).  It's also possible that a stolen wakeup may occur.
This is when g_cond_signal() is called, but another thread acquires
@mutex before this thread and modifies the state of the program in
such a way that when g_cond_wait() is able to return, the expected
condition is no longer met.

For this reason, g_cond_wait() must always be used in a loop.  See
the documentation for #GCond for a complete example.</doc>
        <source-position filename="gthread.h" line="207" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="cond" transfer-ownership="none" gs:managed-name="cond" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="13796">a #GCond</doc>
            <type name="Cond" c:type="GCond*" gs:managed-name="Cond" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="mutex" transfer-ownership="none" gs:managed-name="mutex" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="13797">a #GMutex that is currently locked</doc>
            <type name="Mutex" c:type="GMutex*" gs:managed-name="Mutex" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="mutex" transfer-ownership="none" gs:managed-name="mutex" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="13797">a #GMutex that is currently locked</doc>
            <type name="Mutex" c:type="GMutex*" gs:managed-name="Mutex" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="wait_until" c:identifier="g_cond_wait_until" version="2.32" gs:dll-name="glib-2.0" gs:managed-name="WaitUntil">
        <doc xml:space="preserve" filename="glib-2.0.c" line="13816">Waits until either @cond is signalled or @end_time has passed.

As with g_cond_wait() it is possible that a spurious or stolen wakeup
could occur.  For that reason, waiting on a condition variable should
always be in a loop, based on an explicitly-checked predicate.

%TRUE is returned if the condition variable was signalled (or in the
case of a spurious wakeup).  %FALSE is returned if @end_time has
passed.

The following code shows how to correctly perform a timed wait on a
condition variable (extending the example presented in the
documentation for #GCond):

|[&lt;!-- language="C" --&gt;
gpointer
pop_data_timed (void)
{
  gint64 end_time;
  gpointer data;

  g_mutex_lock (&amp;data_mutex);

  end_time = g_get_monotonic_time () + 5 * G_TIME_SPAN_SECOND;
  while (!current_data)
    if (!g_cond_wait_until (&amp;data_cond, &amp;data_mutex, end_time))
      {
        // timeout has passed.
        g_mutex_unlock (&amp;data_mutex);
        return NULL;
      }

  // there is data for us
  data = current_data;
  current_data = NULL;

  g_mutex_unlock (&amp;data_mutex);

  return data;
}
]|

Notice that the end time is calculated once, before entering the
loop and reused.  This is the motivation behind the use of absolute
time on this API -- if a relative time of 5 seconds were passed
directly to the call and a spurious wakeup occurred, the program would
have to start over waiting again (which would lead to a total wait
time of more than 5 seconds).</doc>
        <source-position filename="gthread.h" line="214" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="13871">%TRUE on a signal, %FALSE on a timeout</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="cond" transfer-ownership="none" gs:managed-name="cond" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="13818">a #GCond</doc>
            <type name="Cond" c:type="GCond*" gs:managed-name="Cond" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="mutex" transfer-ownership="none" gs:managed-name="mutex" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="13819">a #GMutex that is currently locked</doc>
            <type name="Mutex" c:type="GMutex*" gs:managed-name="Mutex" gs:is-pointer="1" />
          </parameter>
          <parameter name="end_time" transfer-ownership="none" gs:managed-name="endTime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="13820">the monotonic time to wait until</doc>
            <type name="gint64" c:type="gint64" gs:managed-name="System.Int64" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="mutex" transfer-ownership="none" gs:managed-name="mutex" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="13819">a #GMutex that is currently locked</doc>
            <type name="Mutex" c:type="GMutex*" gs:managed-name="Mutex" gs:is-pointer="1" />
          </parameter>
          <parameter name="end_time" transfer-ownership="none" gs:managed-name="endTime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="13820">the monotonic time to wait until</doc>
            <type name="gint64" c:type="gint64" gs:managed-name="System.Int64" />
          </parameter>
        </gs:managed-parameters>
      </method>
    </record>
    <callback name="CopyFunc" c:type="GCopyFunc" version="2.4" gs:dll-name="glib-2.0" gs:managed-name="CopyFunc">
      <doc xml:space="preserve" filename="gtypes.h" line="121">A function of this signature is used to copy the node data
when doing a deep-copy of a tree.</doc>
      <source-position filename="gtypes.h" line="133" />
      <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
        <doc xml:space="preserve" filename="gtypes.h" line="129">A pointer to the copy</doc>
        <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
      </return-value>
      <parameters>
        <parameter name="src" transfer-ownership="none" gs:managed-name="src" direction="in">
          <doc xml:space="preserve" filename="gtypes.h" line="123">A pointer to the data which should be copied</doc>
          <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </parameter>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
          <doc xml:space="preserve" filename="gtypes.h" line="124">Additional data</doc>
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </parameter>
      </parameters>
      <gs:managed-parameters>
        <parameter name="src" transfer-ownership="none" gs:managed-name="src" direction="in">
          <doc xml:space="preserve" filename="gtypes.h" line="123">A pointer to the data which should be copied</doc>
          <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </parameter>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
          <doc xml:space="preserve" filename="gtypes.h" line="124">Additional data</doc>
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </parameter>
      </gs:managed-parameters>
    </callback>
    <record name="Data" c:type="GData" disguised="1" gs:managed-name="Data">
      <doc xml:space="preserve" filename="glib-2.0.c" line="232">The #GData struct is an opaque data structure to represent a
[Keyed Data List][glib-Keyed-Data-Lists]. It should only be
accessed via the following functions.</doc>
      <source-position filename="gdataset.h" line="36" />
    </record>
    <record name="DateTime" c:type="GDateTime" version="2.26" glib:type-name="GDateTime" glib:get-type="g_date_time_get_type" c:symbol-prefix="date_time" gs:managed-name="DateTime">
      <doc xml:space="preserve" filename="gdatetime.h" line="89">`GDateTime` is an opaque structure whose members
cannot be accessed directly.</doc>
      <source-position filename="gdatetime.h" line="97" />
      <constructor name="new" c:identifier="g_date_time_new" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="New">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15605">Creates a new #GDateTime corresponding to the given date and time in
the time zone @tz.

The @year must be between 1 and 9999, @month between 1 and 12 and @day
between 1 and 28, 29, 30 or 31 depending on the month and the year.

@hour must be between 0 and 23 and @minute must be between 0 and 59.

@seconds must be at least 0.0 and must be strictly less than 60.0.
It will be rounded down to the nearest microsecond.

If the given time is not representable in the given time zone (for
example, 02:30 on March 14th 2010 in Toronto, due to daylight savings
time) then the time will be rounded up to the nearest existing time
(in this case, 03:00).  If this matters to you then you should verify
the return value for containing the same as the numbers you gave.

In the case that the given time is ambiguous in the given time zone
(for example, 01:30 on November 7th 2010 in Toronto, due to daylight
savings time) then the time falling within standard (ie:
non-daylight) time is taken.

It not considered a programmer error for the values to this function
to be out of range, but in the case that they are, the function will
return %NULL.

You should release the return value by calling g_date_time_unref()
when you are done with it.</doc>
        <source-position filename="gdatetime.h" line="128" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15644">a new #GDateTime, or %NULL</doc>
          <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="tz" transfer-ownership="none" gs:managed-name="tz" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15607">a #GTimeZone</doc>
            <type name="TimeZone" c:type="GTimeZone*" gs:managed-name="TimeZone" gs:is-pointer="1" />
          </parameter>
          <parameter name="year" transfer-ownership="none" gs:managed-name="year" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15608">the year component of the date</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="month" transfer-ownership="none" gs:managed-name="month" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15609">the month component of the date</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="day" transfer-ownership="none" gs:managed-name="day" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15610">the day component of the date</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="hour" transfer-ownership="none" gs:managed-name="hour" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15611">the hour component of the date</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="minute" transfer-ownership="none" gs:managed-name="minute" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15612">the minute component of the date</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="seconds" transfer-ownership="none" gs:managed-name="seconds" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15613">the number of seconds past the minute</doc>
            <type name="gdouble" c:type="gdouble" gs:managed-name="System.Double" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="tz" transfer-ownership="none" gs:managed-name="tz" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15607">a #GTimeZone</doc>
            <type name="TimeZone" c:type="GTimeZone*" gs:managed-name="TimeZone" gs:is-pointer="1" />
          </parameter>
          <parameter name="year" transfer-ownership="none" gs:managed-name="year" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15608">the year component of the date</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="month" transfer-ownership="none" gs:managed-name="month" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15609">the month component of the date</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="day" transfer-ownership="none" gs:managed-name="day" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15610">the day component of the date</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="hour" transfer-ownership="none" gs:managed-name="hour" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15611">the hour component of the date</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="minute" transfer-ownership="none" gs:managed-name="minute" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15612">the minute component of the date</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="seconds" transfer-ownership="none" gs:managed-name="seconds" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15613">the number of seconds past the minute</doc>
            <type name="gdouble" c:type="gdouble" gs:managed-name="System.Double" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <function name="from_iso8601" c:identifier="g_date_time_new_from_iso8601" version="2.56" gs:dll-name="glib-2.0" gs:managed-name="FromIso8601">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15649">Creates a #GDateTime corresponding to the given
[ISO 8601 formatted string](https://en.wikipedia.org/wiki/ISO_8601)
@text. ISO 8601 strings of the form &lt;date&gt;&lt;sep&gt;&lt;time&gt;&lt;tz&gt; are supported, with
some extensions from [RFC 3339](https://tools.ietf.org/html/rfc3339) as
mentioned below.

Note that as #GDateTime "is oblivious to leap seconds", leap seconds information
in an ISO-8601 string will be ignored, so a `23:59:60` time would be parsed as
`23:59:59`.

&lt;sep&gt; is the separator and can be either 'T', 't' or ' '. The latter two
separators are an extension from
[RFC 3339](https://tools.ietf.org/html/rfc3339#section-5.6).

&lt;date&gt; is in the form:

- `YYYY-MM-DD` - Year/month/day, e.g. 2016-08-24.
- `YYYYMMDD` - Same as above without dividers.
- `YYYY-DDD` - Ordinal day where DDD is from 001 to 366, e.g. 2016-237.
- `YYYYDDD` - Same as above without dividers.
- `YYYY-Www-D` - Week day where ww is from 01 to 52 and D from 1-7,
  e.g. 2016-W34-3.
- `YYYYWwwD` - Same as above without dividers.

&lt;time&gt; is in the form:

- `hh:mm:ss(.sss)` - Hours, minutes, seconds (subseconds), e.g. 22:10:42.123.
- `hhmmss(.sss)` - Same as above without dividers.

&lt;tz&gt; is an optional timezone suffix of the form:

- `Z` - UTC.
- `+hh:mm` or `-hh:mm` - Offset from UTC in hours and minutes, e.g. +12:00.
- `+hh` or `-hh` - Offset from UTC in hours, e.g. +12.

If the timezone is not provided in @text it must be provided in @default_tz
(this field is otherwise ignored).

This call can fail (returning %NULL) if @text is not a valid ISO 8601
formatted string.

You should release the return value by calling g_date_time_unref()
when you are done with it.</doc>
        <source-position filename="gdatetime.h" line="124" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15699">a new #GDateTime, or %NULL</doc>
          <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="text" transfer-ownership="none" gs:managed-name="text" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15651">an ISO 8601 formatted time string.</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="default_tz" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="defaultTz" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15652">a #GTimeZone to use if the text doesn't contain a
                         timezone, or %NULL.</doc>
            <type name="TimeZone" c:type="GTimeZone*" gs:managed-name="TimeZone" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="text" transfer-ownership="none" gs:managed-name="text" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15651">an ISO 8601 formatted time string.</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="default_tz" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="defaultTz" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15652">a #GTimeZone to use if the text doesn't contain a
                         timezone, or %NULL.</doc>
            <type name="TimeZone" c:type="GTimeZone*" gs:managed-name="TimeZone" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="from_timeval_local" c:identifier="g_date_time_new_from_timeval_local" version="2.26" deprecated="1" deprecated-version="2.62" gs:dll-name="glib-2.0" gs:managed-name="FromTimevalLocal">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15704">Creates a #GDateTime corresponding to the given #GTimeVal @tv in the
local time zone.

The time contained in a #GTimeVal is always stored in the form of
seconds elapsed since 1970-01-01 00:00:00 UTC, regardless of the
local time offset.

This call can fail (returning %NULL) if @tv represents a time outside
of the supported range of #GDateTime.

You should release the return value by calling g_date_time_unref()
when you are done with it.</doc>
        <doc-deprecated xml:space="preserve">#GTimeVal is not year-2038-safe. Use
   g_date_time_new_from_unix_local() instead.</doc-deprecated>
        <source-position filename="gdatetime.h" line="118" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15721">a new #GDateTime, or %NULL</doc>
          <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="tv" transfer-ownership="none" gs:managed-name="tv" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15706">a #GTimeVal</doc>
            <type name="TimeVal" c:type="const GTimeVal*" gs:managed-name="TimeVal" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="tv" transfer-ownership="none" gs:managed-name="tv" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15706">a #GTimeVal</doc>
            <type name="TimeVal" c:type="const GTimeVal*" gs:managed-name="TimeVal" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="from_timeval_utc" c:identifier="g_date_time_new_from_timeval_utc" version="2.26" deprecated="1" deprecated-version="2.62" gs:dll-name="glib-2.0" gs:managed-name="FromTimevalUtc">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15728">Creates a #GDateTime corresponding to the given #GTimeVal @tv in UTC.

The time contained in a #GTimeVal is always stored in the form of
seconds elapsed since 1970-01-01 00:00:00 UTC.

This call can fail (returning %NULL) if @tv represents a time outside
of the supported range of #GDateTime.

You should release the return value by calling g_date_time_unref()
when you are done with it.</doc>
        <doc-deprecated xml:space="preserve">#GTimeVal is not year-2038-safe. Use
   g_date_time_new_from_unix_utc() instead.</doc-deprecated>
        <source-position filename="gdatetime.h" line="120" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15743">a new #GDateTime, or %NULL</doc>
          <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="tv" transfer-ownership="none" gs:managed-name="tv" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15730">a #GTimeVal</doc>
            <type name="TimeVal" c:type="const GTimeVal*" gs:managed-name="TimeVal" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="tv" transfer-ownership="none" gs:managed-name="tv" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15730">a #GTimeVal</doc>
            <type name="TimeVal" c:type="const GTimeVal*" gs:managed-name="TimeVal" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="from_unix_local" c:identifier="g_date_time_new_from_unix_local" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="FromUnixLocal">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15750">Creates a #GDateTime corresponding to the given Unix time @t in the
local time zone.

Unix time is the number of seconds that have elapsed since 1970-01-01
00:00:00 UTC, regardless of the local time offset.

This call can fail (returning %NULL) if @t represents a time outside
of the supported range of #GDateTime.

You should release the return value by calling g_date_time_unref()
when you are done with it.</doc>
        <source-position filename="gdatetime.h" line="112" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15766">a new #GDateTime, or %NULL</doc>
          <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="t" transfer-ownership="none" gs:managed-name="t" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15752">the Unix time</doc>
            <type name="gint64" c:type="gint64" gs:managed-name="System.Int64" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="t" transfer-ownership="none" gs:managed-name="t" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15752">the Unix time</doc>
            <type name="gint64" c:type="gint64" gs:managed-name="System.Int64" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="from_unix_utc" c:identifier="g_date_time_new_from_unix_utc" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="FromUnixUtc">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15771">Creates a #GDateTime corresponding to the given Unix time @t in UTC.

Unix time is the number of seconds that have elapsed since 1970-01-01
00:00:00 UTC.

This call can fail (returning %NULL) if @t represents a time outside
of the supported range of #GDateTime.

You should release the return value by calling g_date_time_unref()
when you are done with it.</doc>
        <source-position filename="gdatetime.h" line="114" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15786">a new #GDateTime, or %NULL</doc>
          <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="t" transfer-ownership="none" gs:managed-name="t" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15773">the Unix time</doc>
            <type name="gint64" c:type="gint64" gs:managed-name="System.Int64" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="t" transfer-ownership="none" gs:managed-name="t" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15773">the Unix time</doc>
            <type name="gint64" c:type="gint64" gs:managed-name="System.Int64" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="get_local" c:identifier="g_date_time_new_local" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="GetLocal">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15791">Creates a new #GDateTime corresponding to the given date and time in
the local time zone.

This call is equivalent to calling g_date_time_new() with the time
zone returned by g_time_zone_new_local().</doc>
        <source-position filename="gdatetime.h" line="136" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15806">a #GDateTime, or %NULL</doc>
          <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="year" transfer-ownership="none" gs:managed-name="year" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15793">the year component of the date</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="month" transfer-ownership="none" gs:managed-name="month" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15794">the month component of the date</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="day" transfer-ownership="none" gs:managed-name="day" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15795">the day component of the date</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="hour" transfer-ownership="none" gs:managed-name="hour" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15796">the hour component of the date</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="minute" transfer-ownership="none" gs:managed-name="minute" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15797">the minute component of the date</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="seconds" transfer-ownership="none" gs:managed-name="seconds" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15798">the number of seconds past the minute</doc>
            <type name="gdouble" c:type="gdouble" gs:managed-name="System.Double" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="year" transfer-ownership="none" gs:managed-name="year" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15793">the year component of the date</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="month" transfer-ownership="none" gs:managed-name="month" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15794">the month component of the date</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="day" transfer-ownership="none" gs:managed-name="day" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15795">the day component of the date</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="hour" transfer-ownership="none" gs:managed-name="hour" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15796">the hour component of the date</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="minute" transfer-ownership="none" gs:managed-name="minute" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15797">the minute component of the date</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="seconds" transfer-ownership="none" gs:managed-name="seconds" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15798">the number of seconds past the minute</doc>
            <type name="gdouble" c:type="gdouble" gs:managed-name="System.Double" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="get_now" c:identifier="g_date_time_new_now" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="GetNow">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15811">Creates a #GDateTime corresponding to this exact instant in the given
time zone @tz.  The time is as accurate as the system allows, to a
maximum accuracy of 1 microsecond.

This function will always succeed unless GLib is still being used after the
year 9999.

You should release the return value by calling g_date_time_unref()
when you are done with it.</doc>
        <source-position filename="gdatetime.h" line="105" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15825">a new #GDateTime, or %NULL</doc>
          <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="tz" transfer-ownership="none" gs:managed-name="tz" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15813">a #GTimeZone</doc>
            <type name="TimeZone" c:type="GTimeZone*" gs:managed-name="TimeZone" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="tz" transfer-ownership="none" gs:managed-name="tz" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15813">a #GTimeZone</doc>
            <type name="TimeZone" c:type="GTimeZone*" gs:managed-name="TimeZone" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <gs:managed-property name="get_now_local" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="NowLocal">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15830">Creates a #GDateTime corresponding to this exact instant in the local
time zone.

This is equivalent to calling g_date_time_new_now() with the time
zone returned by g_time_zone_new_local().</doc>
        <source-position filename="gdatetime.h" line="107" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15839">a new #GDateTime, or %NULL</doc>
          <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </gs:managed-property>
      <function name="get_now_local" c:identifier="g_date_time_new_now_local" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="GetNowLocal" gs:property-getter-for="NowLocal" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15830">Creates a #GDateTime corresponding to this exact instant in the local
time zone.

This is equivalent to calling g_date_time_new_now() with the time
zone returned by g_time_zone_new_local().</doc>
        <source-position filename="gdatetime.h" line="107" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15839">a new #GDateTime, or %NULL</doc>
          <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
      <gs:managed-property name="get_now_utc" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="NowUtc">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15844">Creates a #GDateTime corresponding to this exact instant in UTC.

This is equivalent to calling g_date_time_new_now() with the time
zone returned by g_time_zone_new_utc().</doc>
        <source-position filename="gdatetime.h" line="109" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15852">a new #GDateTime, or %NULL</doc>
          <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </gs:managed-property>
      <function name="get_now_utc" c:identifier="g_date_time_new_now_utc" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="GetNowUtc" gs:property-getter-for="NowUtc" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15844">Creates a #GDateTime corresponding to this exact instant in UTC.

This is equivalent to calling g_date_time_new_now() with the time
zone returned by g_time_zone_new_utc().</doc>
        <source-position filename="gdatetime.h" line="109" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15852">a new #GDateTime, or %NULL</doc>
          <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
      <function name="get_utc" c:identifier="g_date_time_new_utc" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="GetUtc">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15857">Creates a new #GDateTime corresponding to the given date and time in
UTC.

This call is equivalent to calling g_date_time_new() with the time
zone returned by g_time_zone_new_utc().</doc>
        <source-position filename="gdatetime.h" line="143" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15872">a #GDateTime, or %NULL</doc>
          <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="year" transfer-ownership="none" gs:managed-name="year" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15859">the year component of the date</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="month" transfer-ownership="none" gs:managed-name="month" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15860">the month component of the date</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="day" transfer-ownership="none" gs:managed-name="day" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15861">the day component of the date</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="hour" transfer-ownership="none" gs:managed-name="hour" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15862">the hour component of the date</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="minute" transfer-ownership="none" gs:managed-name="minute" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15863">the minute component of the date</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="seconds" transfer-ownership="none" gs:managed-name="seconds" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15864">the number of seconds past the minute</doc>
            <type name="gdouble" c:type="gdouble" gs:managed-name="System.Double" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="year" transfer-ownership="none" gs:managed-name="year" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15859">the year component of the date</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="month" transfer-ownership="none" gs:managed-name="month" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15860">the month component of the date</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="day" transfer-ownership="none" gs:managed-name="day" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15861">the day component of the date</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="hour" transfer-ownership="none" gs:managed-name="hour" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15862">the hour component of the date</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="minute" transfer-ownership="none" gs:managed-name="minute" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15863">the minute component of the date</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="seconds" transfer-ownership="none" gs:managed-name="seconds" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15864">the number of seconds past the minute</doc>
            <type name="gdouble" c:type="gdouble" gs:managed-name="System.Double" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <method name="add" c:identifier="g_date_time_add" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="Add">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15027">Creates a copy of @datetime and adds the specified timespan to the copy.</doc>
        <source-position filename="gdatetime.h" line="152" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15034">the newly created #GDateTime which
  should be freed with g_date_time_unref(), or %NULL</doc>
          <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none" gs:managed-name="datetime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15029">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="timespan" transfer-ownership="none" gs:managed-name="timespan" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15030">a #GTimeSpan</doc>
            <type name="TimeSpan" c:type="GTimeSpan" gs:managed-name="TimeSpan" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="timespan" transfer-ownership="none" gs:managed-name="timespan" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15030">a #GTimeSpan</doc>
            <type name="TimeSpan" c:type="GTimeSpan" gs:managed-name="TimeSpan" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="add_days" c:identifier="g_date_time_add_days" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="AddDays">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15040">Creates a copy of @datetime and adds the specified number of days to the
copy. Add negative values to subtract days.</doc>
        <source-position filename="gdatetime.h" line="169" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15048">the newly created #GDateTime which
  should be freed with g_date_time_unref(), or %NULL</doc>
          <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none" gs:managed-name="datetime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15042">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="days" transfer-ownership="none" gs:managed-name="days" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15043">the number of days</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="days" transfer-ownership="none" gs:managed-name="days" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15043">the number of days</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="add_full" c:identifier="g_date_time_add_full" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="AddFull">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15054">Creates a new #GDateTime adding the specified values to the current date and
time in @datetime. Add negative values to subtract.</doc>
        <source-position filename="gdatetime.h" line="187" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15067">the newly created #GDateTime which
  should be freed with g_date_time_unref(), or %NULL</doc>
          <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none" gs:managed-name="datetime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15056">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="years" transfer-ownership="none" gs:managed-name="years" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15057">the number of years to add</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="months" transfer-ownership="none" gs:managed-name="months" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15058">the number of months to add</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="days" transfer-ownership="none" gs:managed-name="days" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15059">the number of days to add</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="hours" transfer-ownership="none" gs:managed-name="hours" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15060">the number of hours to add</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="minutes" transfer-ownership="none" gs:managed-name="minutes" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15061">the number of minutes to add</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="seconds" transfer-ownership="none" gs:managed-name="seconds" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15062">the number of seconds to add</doc>
            <type name="gdouble" c:type="gdouble" gs:managed-name="System.Double" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="years" transfer-ownership="none" gs:managed-name="years" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15057">the number of years to add</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="months" transfer-ownership="none" gs:managed-name="months" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15058">the number of months to add</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="days" transfer-ownership="none" gs:managed-name="days" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15059">the number of days to add</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="hours" transfer-ownership="none" gs:managed-name="hours" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15060">the number of hours to add</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="minutes" transfer-ownership="none" gs:managed-name="minutes" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15061">the number of minutes to add</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="seconds" transfer-ownership="none" gs:managed-name="seconds" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15062">the number of seconds to add</doc>
            <type name="gdouble" c:type="gdouble" gs:managed-name="System.Double" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="add_hours" c:identifier="g_date_time_add_hours" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="AddHours">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15073">Creates a copy of @datetime and adds the specified number of hours.
Add negative values to subtract hours.</doc>
        <source-position filename="gdatetime.h" line="174" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15081">the newly created #GDateTime which
  should be freed with g_date_time_unref(), or %NULL</doc>
          <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none" gs:managed-name="datetime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15075">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="hours" transfer-ownership="none" gs:managed-name="hours" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15076">the number of hours to add</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="hours" transfer-ownership="none" gs:managed-name="hours" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15076">the number of hours to add</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="add_minutes" c:identifier="g_date_time_add_minutes" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="AddMinutes">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15087">Creates a copy of @datetime adding the specified number of minutes.
Add negative values to subtract minutes.</doc>
        <source-position filename="gdatetime.h" line="178" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15095">the newly created #GDateTime which
  should be freed with g_date_time_unref(), or %NULL</doc>
          <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none" gs:managed-name="datetime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15089">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="minutes" transfer-ownership="none" gs:managed-name="minutes" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15090">the number of minutes to add</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="minutes" transfer-ownership="none" gs:managed-name="minutes" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15090">the number of minutes to add</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="add_months" c:identifier="g_date_time_add_months" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="AddMonths">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15101">Creates a copy of @datetime and adds the specified number of months to the
copy. Add negative values to subtract months.

The day of the month of the resulting #GDateTime is clamped to the number
of days in the updated calendar month. For example, if adding 1 month to
31st January 2018, the result would be 28th February 2018. In 2020 (a leap
year), the result would be 29th February.</doc>
        <source-position filename="gdatetime.h" line="161" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15114">the newly created #GDateTime which
  should be freed with g_date_time_unref(), or %NULL</doc>
          <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none" gs:managed-name="datetime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15103">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="months" transfer-ownership="none" gs:managed-name="months" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15104">the number of months</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="months" transfer-ownership="none" gs:managed-name="months" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15104">the number of months</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="add_seconds" c:identifier="g_date_time_add_seconds" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="AddSeconds">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15120">Creates a copy of @datetime and adds the specified number of seconds.
Add negative values to subtract seconds.</doc>
        <source-position filename="gdatetime.h" line="182" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15128">the newly created #GDateTime which
  should be freed with g_date_time_unref(), or %NULL</doc>
          <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none" gs:managed-name="datetime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15122">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="seconds" transfer-ownership="none" gs:managed-name="seconds" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15123">the number of seconds to add</doc>
            <type name="gdouble" c:type="gdouble" gs:managed-name="System.Double" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="seconds" transfer-ownership="none" gs:managed-name="seconds" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15123">the number of seconds to add</doc>
            <type name="gdouble" c:type="gdouble" gs:managed-name="System.Double" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="add_weeks" c:identifier="g_date_time_add_weeks" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="AddWeeks">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15134">Creates a copy of @datetime and adds the specified number of weeks to the
copy. Add negative values to subtract weeks.</doc>
        <source-position filename="gdatetime.h" line="165" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15142">the newly created #GDateTime which
  should be freed with g_date_time_unref(), or %NULL</doc>
          <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none" gs:managed-name="datetime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15136">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="weeks" transfer-ownership="none" gs:managed-name="weeks" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15137">the number of weeks</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="weeks" transfer-ownership="none" gs:managed-name="weeks" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15137">the number of weeks</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="add_years" c:identifier="g_date_time_add_years" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="AddYears">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15148">Creates a copy of @datetime and adds the specified number of years to the
copy. Add negative values to subtract years.

As with g_date_time_add_months(), if the resulting date would be 29th
February on a non-leap year, the day will be clamped to 28th February.</doc>
        <source-position filename="gdatetime.h" line="157" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15159">the newly created #GDateTime which
  should be freed with g_date_time_unref(), or %NULL</doc>
          <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none" gs:managed-name="datetime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15150">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="years" transfer-ownership="none" gs:managed-name="years" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15151">the number of years</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="years" transfer-ownership="none" gs:managed-name="years" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15151">the number of years</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="difference" c:identifier="g_date_time_difference" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="Difference">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15179">Calculates the difference in time between @end and @begin.  The
#GTimeSpan that is returned is effectively @end - @begin (ie:
positive if the first parameter is larger).</doc>
        <source-position filename="gdatetime.h" line="199" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15188">the difference between the two #GDateTime, as a time
  span expressed in microseconds.</doc>
          <type name="TimeSpan" c:type="GTimeSpan" gs:managed-name="TimeSpan" />
        </return-value>
        <parameters>
          <instance-parameter name="end" transfer-ownership="none" gs:managed-name="end" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15181">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="begin" transfer-ownership="none" gs:managed-name="begin" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15182">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="begin" transfer-ownership="none" gs:managed-name="begin" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15182">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="format" c:identifier="g_date_time_format" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="Format">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15209">Creates a newly allocated string representing the requested @format.

The format strings understood by this function are a subset of the
strftime() format language as specified by C99.  The \%D, \%U and \%W
conversions are not supported, nor is the 'E' modifier.  The GNU
extensions \%k, \%l, \%s and \%P are supported, however, as are the
'0', '_' and '-' modifiers. The Python extension \%f is also supported.

In contrast to strftime(), this function always produces a UTF-8
string, regardless of the current locale.  Note that the rendering of
many formats is locale-dependent and may not match the strftime()
output exactly.

The following format specifiers are supported:

- \%a: the abbreviated weekday name according to the current locale
- \%A: the full weekday name according to the current locale
- \%b: the abbreviated month name according to the current locale
- \%B: the full month name according to the current locale
- \%c: the preferred date and time representation for the current locale
- \%C: the century number (year/100) as a 2-digit integer (00-99)
- \%d: the day of the month as a decimal number (range 01 to 31)
- \%e: the day of the month as a decimal number (range  1 to 31)
- \%F: equivalent to `%Y-%m-%d` (the ISO 8601 date format)
- \%g: the last two digits of the ISO 8601 week-based year as a
  decimal number (00-99). This works well with \%V and \%u.
- \%G: the ISO 8601 week-based year as a decimal number. This works
  well with \%V and \%u.
- \%h: equivalent to \%b
- \%H: the hour as a decimal number using a 24-hour clock (range 00 to 23)
- \%I: the hour as a decimal number using a 12-hour clock (range 01 to 12)
- \%j: the day of the year as a decimal number (range 001 to 366)
- \%k: the hour (24-hour clock) as a decimal number (range 0 to 23);
  single digits are preceded by a blank
- \%l: the hour (12-hour clock) as a decimal number (range 1 to 12);
  single digits are preceded by a blank
- \%m: the month as a decimal number (range 01 to 12)
- \%M: the minute as a decimal number (range 00 to 59)
- \%f: the microsecond as a decimal number (range 000000 to 999999)
- \%p: either "AM" or "PM" according to the given time value, or the
  corresponding  strings for the current locale.  Noon is treated as
  "PM" and midnight as "AM". Use of this format specifier is discouraged, as
  many locales have no concept of AM/PM formatting. Use \%c or \%X instead.
- \%P: like \%p but lowercase: "am" or "pm" or a corresponding string for
  the current locale. Use of this format specifier is discouraged, as
  many locales have no concept of AM/PM formatting. Use \%c or \%X instead.
- \%r: the time in a.m. or p.m. notation. Use of this format specifier is
  discouraged, as many locales have no concept of AM/PM formatting. Use \%c
  or \%X instead.
- \%R: the time in 24-hour notation (\%H:\%M)
- \%s: the number of seconds since the Epoch, that is, since 1970-01-01
  00:00:00 UTC
- \%S: the second as a decimal number (range 00 to 60)
- \%t: a tab character
- \%T: the time in 24-hour notation with seconds (\%H:\%M:\%S)
- \%u: the ISO 8601 standard day of the week as a decimal, range 1 to 7,
   Monday being 1. This works well with \%G and \%V.
- \%V: the ISO 8601 standard week number of the current year as a decimal
  number, range 01 to 53, where week 1 is the first week that has at
  least 4 days in the new year. See g_date_time_get_week_of_year().
  This works well with \%G and \%u.
- \%w: the day of the week as a decimal, range 0 to 6, Sunday being 0.
  This is not the ISO 8601 standard format -- use \%u instead.
- \%x: the preferred date representation for the current locale without
  the time
- \%X: the preferred time representation for the current locale without
  the date
- \%y: the year as a decimal number without the century
- \%Y: the year as a decimal number including the century
- \%z: the time zone as an offset from UTC (+hhmm)
- \%:z: the time zone as an offset from UTC (+hh:mm).
  This is a gnulib strftime() extension. Since: 2.38
- \%::z: the time zone as an offset from UTC (+hh:mm:ss). This is a
  gnulib strftime() extension. Since: 2.38
- \%:::z: the time zone as an offset from UTC, with : to necessary
  precision (e.g., -04, +05:30). This is a gnulib strftime() extension. Since: 2.38
- \%Z: the time zone or name or abbreviation
- \%\%: a literal \% character

Some conversion specifications can be modified by preceding the
conversion specifier by one or more modifier characters. The
following modifiers are supported for many of the numeric
conversions:

- O: Use alternative numeric symbols, if the current locale supports those.
- _: Pad a numeric result with spaces. This overrides the default padding
  for the specifier.
- -: Do not pad a numeric result. This overrides the default padding
  for the specifier.
- 0: Pad a numeric result with zeros. This overrides the default padding
  for the specifier.

Additionally, when O is used with B, b, or h, it produces the alternative
form of a month name. The alternative form should be used when the month
name is used without a day number (e.g., standalone). It is required in
some languages (Baltic, Slavic, Greek, and more) due to their grammatical
rules. For other languages there is no difference. \%OB is a GNU and BSD
strftime() extension expected to be added to the future POSIX specification,
\%Ob and \%Oh are GNU strftime() extensions. Since: 2.56</doc>
        <source-position filename="gdatetime.h" line="267" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15315">a newly allocated string formatted to
   the requested format or %NULL in the case that there was an error (such
   as a format specifier not being supported in the current locale). The
   string should be freed with g_free().</doc>
          <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none" gs:managed-name="datetime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15211">A #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="format" transfer-ownership="none" gs:managed-name="format" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15212">a valid UTF-8 string, containing the format for the
         #GDateTime</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="format" transfer-ownership="none" gs:managed-name="format" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15212">a valid UTF-8 string, containing the format for the
         #GDateTime</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="format_iso8601" c:identifier="g_date_time_format_iso8601" version="2.62" gs:dll-name="glib-2.0" gs:managed-name="FormatIso8601">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15323">Format @datetime in [ISO 8601 format](https://en.wikipedia.org/wiki/ISO_8601),
including the date, time and time zone, and return that as a UTF-8 encoded
string.

Since GLib 2.66, this will output to sub-second precision if needed.</doc>
        <source-position filename="gdatetime.h" line="270" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15333">a newly allocated string formatted in
  ISO 8601 format or %NULL in the case that there was an error. The string
  should be freed with g_free().</doc>
          <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none" gs:managed-name="datetime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15325">A #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_day_of_month" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="DayOfMonth">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15340">Retrieves the day of the month represented by @datetime in the gregorian
calendar.</doc>
        <source-position filename="gdatetime.h" line="218" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15347">the day of the month</doc>
          <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none" gs:managed-name="datetime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15342">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_day_of_month" c:identifier="g_date_time_get_day_of_month" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="GetDayOfMonth" gs:property-getter-for="DayOfMonth" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15340">Retrieves the day of the month represented by @datetime in the gregorian
calendar.</doc>
        <source-position filename="gdatetime.h" line="218" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15347">the day of the month</doc>
          <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none" gs:managed-name="datetime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15342">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_day_of_week" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="DayOfWeek">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15352">Retrieves the ISO 8601 day of the week on which @datetime falls (1 is
Monday, 2 is Tuesday... 7 is Sunday).</doc>
        <source-position filename="gdatetime.h" line="225" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15359">the day of the week</doc>
          <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none" gs:managed-name="datetime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15354">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_day_of_week" c:identifier="g_date_time_get_day_of_week" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="GetDayOfWeek" gs:property-getter-for="DayOfWeek" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15352">Retrieves the ISO 8601 day of the week on which @datetime falls (1 is
Monday, 2 is Tuesday... 7 is Sunday).</doc>
        <source-position filename="gdatetime.h" line="225" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15359">the day of the week</doc>
          <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none" gs:managed-name="datetime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15354">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_day_of_year" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="DayOfYear">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15364">Retrieves the day of the year represented by @datetime in the Gregorian
calendar.</doc>
        <source-position filename="gdatetime.h" line="228" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15371">the day of the year</doc>
          <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none" gs:managed-name="datetime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15366">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_day_of_year" c:identifier="g_date_time_get_day_of_year" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="GetDayOfYear" gs:property-getter-for="DayOfYear" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15364">Retrieves the day of the year represented by @datetime in the Gregorian
calendar.</doc>
        <source-position filename="gdatetime.h" line="228" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15371">the day of the year</doc>
          <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none" gs:managed-name="datetime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15366">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_hour" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="Hour">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15376">Retrieves the hour of the day represented by @datetime</doc>
        <source-position filename="gdatetime.h" line="231" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15382">the hour of the day</doc>
          <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none" gs:managed-name="datetime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15378">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_hour" c:identifier="g_date_time_get_hour" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="GetHour" gs:property-getter-for="Hour" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15376">Retrieves the hour of the day represented by @datetime</doc>
        <source-position filename="gdatetime.h" line="231" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15382">the hour of the day</doc>
          <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none" gs:managed-name="datetime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15378">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_microsecond" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="Microsecond">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15387">Retrieves the microsecond of the date represented by @datetime</doc>
        <source-position filename="gdatetime.h" line="237" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15393">the microsecond of the second</doc>
          <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none" gs:managed-name="datetime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15389">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_microsecond" c:identifier="g_date_time_get_microsecond" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="GetMicrosecond" gs:property-getter-for="Microsecond" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15387">Retrieves the microsecond of the date represented by @datetime</doc>
        <source-position filename="gdatetime.h" line="237" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15393">the microsecond of the second</doc>
          <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none" gs:managed-name="datetime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15389">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_minute" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="Minute">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15398">Retrieves the minute of the hour represented by @datetime</doc>
        <source-position filename="gdatetime.h" line="233" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15404">the minute of the hour</doc>
          <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none" gs:managed-name="datetime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15400">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_minute" c:identifier="g_date_time_get_minute" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="GetMinute" gs:property-getter-for="Minute" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15398">Retrieves the minute of the hour represented by @datetime</doc>
        <source-position filename="gdatetime.h" line="233" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15404">the minute of the hour</doc>
          <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none" gs:managed-name="datetime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15400">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_month" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="Month">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15409">Retrieves the month of the year represented by @datetime in the Gregorian
calendar.</doc>
        <source-position filename="gdatetime.h" line="216" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15416">the month represented by @datetime</doc>
          <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none" gs:managed-name="datetime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15411">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_month" c:identifier="g_date_time_get_month" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="GetMonth" gs:property-getter-for="Month" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15409">Retrieves the month of the year represented by @datetime in the Gregorian
calendar.</doc>
        <source-position filename="gdatetime.h" line="216" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15416">the month represented by @datetime</doc>
          <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none" gs:managed-name="datetime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15411">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_second" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="Second">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15421">Retrieves the second of the minute represented by @datetime</doc>
        <source-position filename="gdatetime.h" line="235" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15427">the second represented by @datetime</doc>
          <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none" gs:managed-name="datetime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15423">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_second" c:identifier="g_date_time_get_second" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="GetSecond" gs:property-getter-for="Second" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15421">Retrieves the second of the minute represented by @datetime</doc>
        <source-position filename="gdatetime.h" line="235" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15427">the second represented by @datetime</doc>
          <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none" gs:managed-name="datetime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15423">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_seconds" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="Seconds">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15432">Retrieves the number of seconds since the start of the last minute,
including the fractional part.</doc>
        <source-position filename="gdatetime.h" line="239" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15439">the number of seconds</doc>
          <type name="gdouble" c:type="gdouble" gs:managed-name="System.Double" />
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none" gs:managed-name="datetime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15434">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_seconds" c:identifier="g_date_time_get_seconds" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="GetSeconds" gs:property-getter-for="Seconds" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15432">Retrieves the number of seconds since the start of the last minute,
including the fractional part.</doc>
        <source-position filename="gdatetime.h" line="239" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15439">the number of seconds</doc>
          <type name="gdouble" c:type="gdouble" gs:managed-name="System.Double" />
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none" gs:managed-name="datetime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15434">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_timezone" version="2.58" gs:dll-name="glib-2.0" gs:managed-name="Timezone">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15444">Get the time zone for this @datetime.</doc>
        <source-position filename="gdatetime.h" line="252" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15450">the time zone</doc>
          <type name="TimeZone" c:type="GTimeZone*" gs:managed-name="TimeZone" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none" gs:managed-name="datetime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15446">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_timezone" c:identifier="g_date_time_get_timezone" version="2.58" gs:dll-name="glib-2.0" gs:managed-name="GetTimezone" gs:property-getter-for="Timezone" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15444">Get the time zone for this @datetime.</doc>
        <source-position filename="gdatetime.h" line="252" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15450">the time zone</doc>
          <type name="TimeZone" c:type="GTimeZone*" gs:managed-name="TimeZone" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none" gs:managed-name="datetime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15446">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_timezone_abbreviation" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="TimezoneAbbreviation">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15455">Determines the time zone abbreviation to be used at the time and in
the time zone of @datetime.

For example, in Toronto this is currently "EST" during the winter
months and "EDT" during the summer months when daylight savings
time is in effect.</doc>
        <source-position filename="gdatetime.h" line="254" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15466">the time zone abbreviation. The returned
         string is owned by the #GDateTime and it should not be
         modified or freed</doc>
          <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none" gs:managed-name="datetime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15457">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_timezone_abbreviation" c:identifier="g_date_time_get_timezone_abbreviation" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="GetTimezoneAbbreviation" gs:property-getter-for="TimezoneAbbreviation" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15455">Determines the time zone abbreviation to be used at the time and in
the time zone of @datetime.

For example, in Toronto this is currently "EST" during the winter
months and "EDT" during the summer months when daylight savings
time is in effect.</doc>
        <source-position filename="gdatetime.h" line="254" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15466">the time zone abbreviation. The returned
         string is owned by the #GDateTime and it should not be
         modified or freed</doc>
          <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none" gs:managed-name="datetime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15457">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_utc_offset" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="UtcOffset">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15473">Determines the offset to UTC in effect at the time and in the time
zone of @datetime.

The offset is the number of microseconds that you add to UTC time to
arrive at local time for the time zone (ie: negative numbers for time
zones west of GMT, positive numbers for east).

If @datetime represents UTC time, then the offset is always zero.</doc>
        <source-position filename="gdatetime.h" line="250" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15486">the number of microseconds that should be added to UTC to
         get the local time</doc>
          <type name="TimeSpan" c:type="GTimeSpan" gs:managed-name="TimeSpan" />
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none" gs:managed-name="datetime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15475">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_utc_offset" c:identifier="g_date_time_get_utc_offset" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="GetUtcOffset" gs:property-getter-for="UtcOffset" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15473">Determines the offset to UTC in effect at the time and in the time
zone of @datetime.

The offset is the number of microseconds that you add to UTC time to
arrive at local time for the time zone (ie: negative numbers for time
zones west of GMT, positive numbers for east).

If @datetime represents UTC time, then the offset is always zero.</doc>
        <source-position filename="gdatetime.h" line="250" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15486">the number of microseconds that should be added to UTC to
         get the local time</doc>
          <type name="TimeSpan" c:type="GTimeSpan" gs:managed-name="TimeSpan" />
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none" gs:managed-name="datetime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15475">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_week_numbering_year" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="WeekNumberingYear">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15492">Returns the ISO 8601 week-numbering year in which the week containing
@datetime falls.

This function, taken together with g_date_time_get_week_of_year() and
g_date_time_get_day_of_week() can be used to determine the full ISO
week date on which @datetime falls.

This is usually equal to the normal Gregorian year (as returned by
g_date_time_get_year()), except as detailed below:

For Thursday, the week-numbering year is always equal to the usual
calendar year.  For other days, the number is such that every day
within a complete week (Monday to Sunday) is contained within the
same week-numbering year.

For Monday, Tuesday and Wednesday occurring near the end of the year,
this may mean that the week-numbering year is one greater than the
calendar year (so that these days have the same week-numbering year
as the Thursday occurring early in the next year).

For Friday, Saturday and Sunday occurring near the start of the year,
this may mean that the week-numbering year is one less than the
calendar year (so that these days have the same week-numbering year
as the Thursday occurring late in the previous year).

An equivalent description is that the week-numbering year is equal to
the calendar year containing the majority of the days in the current
week (Monday to Sunday).

Note that January 1 0001 in the proleptic Gregorian calendar is a
Monday, so this function never returns 0.</doc>
        <source-position filename="gdatetime.h" line="221" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15528">the ISO 8601 week-numbering year for @datetime</doc>
          <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none" gs:managed-name="datetime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15494">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_week_numbering_year" c:identifier="g_date_time_get_week_numbering_year" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="GetWeekNumberingYear" gs:property-getter-for="WeekNumberingYear" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15492">Returns the ISO 8601 week-numbering year in which the week containing
@datetime falls.

This function, taken together with g_date_time_get_week_of_year() and
g_date_time_get_day_of_week() can be used to determine the full ISO
week date on which @datetime falls.

This is usually equal to the normal Gregorian year (as returned by
g_date_time_get_year()), except as detailed below:

For Thursday, the week-numbering year is always equal to the usual
calendar year.  For other days, the number is such that every day
within a complete week (Monday to Sunday) is contained within the
same week-numbering year.

For Monday, Tuesday and Wednesday occurring near the end of the year,
this may mean that the week-numbering year is one greater than the
calendar year (so that these days have the same week-numbering year
as the Thursday occurring early in the next year).

For Friday, Saturday and Sunday occurring near the start of the year,
this may mean that the week-numbering year is one less than the
calendar year (so that these days have the same week-numbering year
as the Thursday occurring late in the previous year).

An equivalent description is that the week-numbering year is equal to
the calendar year containing the majority of the days in the current
week (Monday to Sunday).

Note that January 1 0001 in the proleptic Gregorian calendar is a
Monday, so this function never returns 0.</doc>
        <source-position filename="gdatetime.h" line="221" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15528">the ISO 8601 week-numbering year for @datetime</doc>
          <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none" gs:managed-name="datetime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15494">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_week_of_year" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="WeekOfYear">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15533">Returns the ISO 8601 week number for the week containing @datetime.
The ISO 8601 week number is the same for every day of the week (from
Moday through Sunday).  That can produce some unusual results
(described below).

The first week of the year is week 1.  This is the week that contains
the first Thursday of the year.  Equivalently, this is the first week
that has more than 4 of its days falling within the calendar year.

The value 0 is never returned by this function.  Days contained
within a year but occurring before the first ISO 8601 week of that
year are considered as being contained in the last week of the
previous year.  Similarly, the final days of a calendar year may be
considered as being part of the first ISO 8601 week of the next year
if 4 or more days of that week are contained within the new year.</doc>
        <source-position filename="gdatetime.h" line="223" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15553">the ISO 8601 week number for @datetime.</doc>
          <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none" gs:managed-name="datetime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15535">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_week_of_year" c:identifier="g_date_time_get_week_of_year" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="GetWeekOfYear" gs:property-getter-for="WeekOfYear" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15533">Returns the ISO 8601 week number for the week containing @datetime.
The ISO 8601 week number is the same for every day of the week (from
Moday through Sunday).  That can produce some unusual results
(described below).

The first week of the year is week 1.  This is the week that contains
the first Thursday of the year.  Equivalently, this is the first week
that has more than 4 of its days falling within the calendar year.

The value 0 is never returned by this function.  Days contained
within a year but occurring before the first ISO 8601 week of that
year are considered as being contained in the last week of the
previous year.  Similarly, the final days of a calendar year may be
considered as being part of the first ISO 8601 week of the next year
if 4 or more days of that week are contained within the new year.</doc>
        <source-position filename="gdatetime.h" line="223" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15553">the ISO 8601 week number for @datetime.</doc>
          <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none" gs:managed-name="datetime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15535">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_year" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="Year">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15558">Retrieves the year represented by @datetime in the Gregorian calendar.</doc>
        <source-position filename="gdatetime.h" line="214" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15564">the year represented by @datetime</doc>
          <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none" gs:managed-name="datetime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15560">A #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_year" c:identifier="g_date_time_get_year" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="GetYear" gs:property-getter-for="Year" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15558">Retrieves the year represented by @datetime in the Gregorian calendar.</doc>
        <source-position filename="gdatetime.h" line="214" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15564">the year represented by @datetime</doc>
          <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none" gs:managed-name="datetime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15560">A #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="get_ymd" c:identifier="g_date_time_get_ymd" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="GetYmd">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15569">Retrieves the Gregorian day, month, and year of a given #GDateTime.</doc>
        <source-position filename="gdatetime.h" line="208" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none" gs:managed-name="datetime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15571">a #GDateTime.</doc>
            <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="year" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="year">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15572">the return location for the gregorian year, or %NULL.</doc>
            <type name="gint" c:type="gint*" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="month" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="month">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15573">the return location for the month of the year, or %NULL.</doc>
            <type name="gint" c:type="gint*" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="day" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="day">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15574">the return location for the day of the month, or %NULL.</doc>
            <type name="gint" c:type="gint*" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="year" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="year">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15572">the return location for the gregorian year, or %NULL.</doc>
            <type name="gint" c:type="gint*" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="month" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="month">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15573">the return location for the month of the year, or %NULL.</doc>
            <type name="gint" c:type="gint*" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="day" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="day">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15574">the return location for the day of the month, or %NULL.</doc>
            <type name="gint" c:type="gint*" gs:managed-name="System.Int32" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <gs:managed-property name="is_daylight_savings" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="IsDaylightSavings">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15593">Determines if daylight savings time is in effect at the time and in
the time zone of @datetime.</doc>
        <source-position filename="gdatetime.h" line="256" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15600">%TRUE if daylight savings time is in effect</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none" gs:managed-name="datetime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15595">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="is_daylight_savings" c:identifier="g_date_time_is_daylight_savings" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="GetIsDaylightSavings" gs:property-getter-for="IsDaylightSavings" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15593">Determines if daylight savings time is in effect at the time and in
the time zone of @datetime.</doc>
        <source-position filename="gdatetime.h" line="256" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15600">%TRUE if daylight savings time is in effect</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none" gs:managed-name="datetime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15595">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="ref" c:identifier="g_date_time_ref" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="Ref" gs:special-func="ref" gs:pinvoke-only="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15877">Atomically increments the reference count of @datetime by one.</doc>
        <source-position filename="gdatetime.h" line="102" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15883">the #GDateTime with the reference count increased</doc>
          <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none" gs:managed-name="datetime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15879">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="to_local" c:identifier="g_date_time_to_local" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="ToLocal">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15888">Creates a new #GDateTime corresponding to the same instant in time as
@datetime, but in the local time zone.

This call is equivalent to calling g_date_time_to_timezone() with the
time zone returned by g_time_zone_new_local().</doc>
        <source-position filename="gdatetime.h" line="262" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15898">the newly created #GDateTime which
  should be freed with g_date_time_unref(), or %NULL</doc>
          <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none" gs:managed-name="datetime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15890">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="to_timeval" c:identifier="g_date_time_to_timeval" version="2.26" deprecated="1" deprecated-version="2.62" gs:dll-name="glib-2.0" gs:managed-name="ToTimeval">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15904">Stores the instant in time that @datetime represents into @tv.

The time contained in a #GTimeVal is always stored in the form of
seconds elapsed since 1970-01-01 00:00:00 UTC, regardless of the time
zone associated with @datetime.

On systems where 'long' is 32bit (ie: all 32bit systems and all
Windows systems), a #GTimeVal is incapable of storing the entire
range of values that #GDateTime is capable of expressing.  On those
systems, this function returns %FALSE to indicate that the time is
out of range.

On systems where 'long' is 64bit, this function never fails.</doc>
        <doc-deprecated xml:space="preserve">#GTimeVal is not year-2038-safe. Use
   g_date_time_to_unix() instead.</doc-deprecated>
        <source-position filename="gdatetime.h" line="245" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15923">%TRUE if successful, else %FALSE</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none" gs:managed-name="datetime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15906">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="tv" transfer-ownership="none" gs:managed-name="tv" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15907">a #GTimeVal to modify</doc>
            <type name="TimeVal" c:type="GTimeVal*" gs:managed-name="TimeVal" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="tv" transfer-ownership="none" gs:managed-name="tv" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15907">a #GTimeVal to modify</doc>
            <type name="TimeVal" c:type="GTimeVal*" gs:managed-name="TimeVal" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="to_timezone" c:identifier="g_date_time_to_timezone" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="ToTimezone">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15930">Create a new #GDateTime corresponding to the same instant in time as
@datetime, but in the time zone @tz.

This call can fail in the case that the time goes out of bounds.  For
example, converting 0001-01-01 00:00:00 UTC to a time zone west of
Greenwich will fail (due to the year 0 being out of range).</doc>
        <source-position filename="gdatetime.h" line="259" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15942">the newly created #GDateTime which
  should be freed with g_date_time_unref(), or %NULL</doc>
          <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none" gs:managed-name="datetime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15932">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="tz" transfer-ownership="none" gs:managed-name="tz" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15933">the new #GTimeZone</doc>
            <type name="TimeZone" c:type="GTimeZone*" gs:managed-name="TimeZone" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="tz" transfer-ownership="none" gs:managed-name="tz" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15933">the new #GTimeZone</doc>
            <type name="TimeZone" c:type="GTimeZone*" gs:managed-name="TimeZone" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="to_unix" c:identifier="g_date_time_to_unix" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="ToUnix">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15948">Gives the Unix time corresponding to @datetime, rounding down to the
nearest second.

Unix time is the number of seconds that have elapsed since 1970-01-01
00:00:00 UTC, regardless of the time zone associated with @datetime.</doc>
        <source-position filename="gdatetime.h" line="242" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15958">the Unix time corresponding to @datetime</doc>
          <type name="gint64" c:type="gint64" gs:managed-name="System.Int64" />
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none" gs:managed-name="datetime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15950">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="to_utc" c:identifier="g_date_time_to_utc" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="ToUtc">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15963">Creates a new #GDateTime corresponding to the same instant in time as
@datetime, but in UTC.

This call is equivalent to calling g_date_time_to_timezone() with the
time zone returned by g_time_zone_new_utc().</doc>
        <source-position filename="gdatetime.h" line="264" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15973">the newly created #GDateTime which
  should be freed with g_date_time_unref(), or %NULL</doc>
          <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none" gs:managed-name="datetime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15965">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="unref" c:identifier="g_date_time_unref" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="Unref" gs:special-func="unref" gs:pinvoke-only="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15979">Atomically decrements the reference count of @datetime by one.

When the reference count reaches zero, the resources allocated by
@datetime are freed</doc>
        <source-position filename="gdatetime.h" line="100" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none" gs:managed-name="datetime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15981">a #GDateTime</doc>
            <type name="DateTime" c:type="GDateTime*" gs:managed-name="DateTime" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <function name="compare" c:identifier="g_date_time_compare" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="Compare">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15165">A comparison function for #GDateTimes that is suitable
as a #GCompareFunc. Both #GDateTimes must be non-%NULL.</doc>
        <source-position filename="gdatetime.h" line="196" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15173">-1, 0 or 1 if @dt1 is less than, equal to or greater
  than @dt2.</doc>
          <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <parameter name="dt1" transfer-ownership="none" gs:managed-name="dt1" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15167">first #GDateTime to compare</doc>
            <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
          <parameter name="dt2" transfer-ownership="none" gs:managed-name="dt2" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15168">second #GDateTime to compare</doc>
            <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="dt1" transfer-ownership="none" gs:managed-name="dt1" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15167">first #GDateTime to compare</doc>
            <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
          <parameter name="dt2" transfer-ownership="none" gs:managed-name="dt2" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15168">second #GDateTime to compare</doc>
            <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <method name="equal" c:identifier="g_date_time_equal" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="Equals" gs:equal="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15194">Checks to see if @dt1 and @dt2 are equal.

Equal here means that they represent the same moment after converting
them to the same time zone.</doc>
        <source-position filename="gdatetime.h" line="204" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15204">%TRUE if @dt1 and @dt2 are equal</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="dt1" transfer-ownership="none" gs:managed-name="dt1" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15196">a #GDateTime</doc>
            <type name="DateTime" c:type="gconstpointer" gs:managed-name="DateTime" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="dt2" transfer-ownership="none" gs:managed-name="dt2" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15197">a #GDateTime</doc>
            <type name="DateTime" c:type="gconstpointer" gs:managed-name="DateTime" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="dt2" transfer-ownership="none" gs:managed-name="dt2" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15197">a #GDateTime</doc>
            <type name="DateTime" c:type="gconstpointer" gs:managed-name="DateTime" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="hash" c:identifier="g_date_time_hash" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="GetHashCode" gs:hash="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="15582">Hashes @datetime into a #guint, suitable for use within #GHashTable.</doc>
        <source-position filename="gdatetime.h" line="202" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="15588">a #guint containing the hash</doc>
          <type name="guint" c:type="guint" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="datetime" transfer-ownership="none" gs:managed-name="datetime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="15584">a #GDateTime</doc>
            <type name="DateTime" c:type="gconstpointer" gs:managed-name="DateTime" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_date_time_get_type" gs:access-modifiers="private" gs:dll-name="gobject-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </record>
    <callback name="DestroyNotify" c:type="GDestroyNotify" gs:dll-name="glib-2.0" gs:managed-name="DestroyNotify">
      <doc xml:space="preserve" filename="glib-2.0.c" line="343">Specifies the type of function which is called when a data element
is destroyed. It is passed the pointer to the data element and
should free any memory and resources allocated for it.</doc>
      <source-position filename="gtypes.h" line="113" />
      <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
        <type name="none" c:type="void" gs:managed-name="System.Void" />
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="345">the data element.</doc>
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </parameter>
      </parameters>
      <gs:managed-parameters>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="345">the data element.</doc>
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </parameter>
      </gs:managed-parameters>
    </callback>
    <callback name="EqualFunc" c:type="GEqualFunc" gs:dll-name="glib-2.0" gs:managed-name="EqualFunc">
      <doc xml:space="preserve" filename="glib-2.0.c" line="386">Specifies the type of a function used to test two values for
equality. The function should return %TRUE if both values are equal
and %FALSE otherwise.</doc>
      <source-position filename="gtypes.h" line="111" />
      <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
        <doc xml:space="preserve" filename="glib-2.0.c" line="395">%TRUE if @a = @b; %FALSE otherwise</doc>
        <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
      </return-value>
      <parameters>
        <parameter name="a" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="a" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="388">a value</doc>
          <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </parameter>
        <parameter name="b" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="b" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="389">a value to compare with</doc>
          <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </parameter>
      </parameters>
      <gs:managed-parameters>
        <parameter name="a" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="a" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="388">a value</doc>
          <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </parameter>
        <parameter name="b" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="b" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="389">a value to compare with</doc>
          <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </parameter>
      </gs:managed-parameters>
    </callback>
    <record name="Error" c:type="GError" glib:type-name="GError" glib:get-type="g_error_get_type" c:symbol-prefix="error" gs:managed-name="Error">
      <doc xml:space="preserve" filename="gerror.h" line="32">The `GError` structure contains information about
an error that has occurred.</doc>
      <source-position filename="gerror.h" line="48" />
      <field name="domain" writable="1" gs:managed-name="Domain">
        <doc xml:space="preserve" filename="gerror.h" line="34">error domain, e.g. #G_FILE_ERROR</doc>
        <type name="Quark" c:type="GQuark" gs:managed-name="Quark" />
      </field>
      <field name="code" writable="1" gs:managed-name="Code">
        <doc xml:space="preserve" filename="gerror.h" line="35">error code, e.g. %G_FILE_ERROR_NOENT</doc>
        <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
      </field>
      <field name="message" writable="1" gs:managed-name="Message">
        <doc xml:space="preserve" filename="gerror.h" line="36">human-readable informative error message</doc>
        <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
      </field>
      <constructor name="new_literal" c:identifier="g_error_new_literal" gs:dll-name="glib-2.0" gs:managed-name="NewLiteral">
        <doc xml:space="preserve" filename="glib-2.0.c" line="16537">Creates a new #GError; unlike g_error_new(), @message is
not a printf()-style format string. Use this function if
@message contains text you don't have control over,
that could include printf() escape sequences.</doc>
        <source-position filename="gerror.h" line="57" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="16548">a new #GError</doc>
          <type name="Error" c:type="GError*" gs:managed-name="Error" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="domain" transfer-ownership="none" gs:managed-name="domain" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="16539">error domain</doc>
            <type name="Quark" c:type="GQuark" gs:managed-name="Quark" />
          </parameter>
          <parameter name="code" transfer-ownership="none" gs:managed-name="code" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="16540">error code</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="message" transfer-ownership="none" gs:managed-name="message" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="16541">error message</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="domain" transfer-ownership="none" gs:managed-name="domain" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="16539">error domain</doc>
            <type name="Quark" c:type="GQuark" gs:managed-name="Quark" />
          </parameter>
          <parameter name="code" transfer-ownership="none" gs:managed-name="code" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="16540">error code</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="message" transfer-ownership="none" gs:managed-name="message" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="16541">error message</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <method name="copy" c:identifier="g_error_copy" gs:dll-name="glib-2.0" gs:managed-name="Copy" gs:special-func="copy" gs:pinvoke-only="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="16484">Makes a copy of @error.</doc>
        <source-position filename="gerror.h" line="69" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="16490">a new #GError</doc>
          <type name="Error" c:type="GError*" gs:managed-name="Error" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="error" transfer-ownership="none" gs:managed-name="error" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="16486">a #GError</doc>
            <type name="Error" c:type="const GError*" gs:managed-name="Error" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="free" c:identifier="g_error_free" gs:dll-name="glib-2.0" gs:managed-name="Free" gs:special-func="free" gs:pinvoke-only="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="16494">Frees a #GError and associated resources.</doc>
        <source-position filename="gerror.h" line="67" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="error" transfer-ownership="none" gs:managed-name="error" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="16496">a #GError</doc>
            <type name="Error" c:type="GError*" gs:managed-name="Error" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="matches" c:identifier="g_error_matches" gs:dll-name="glib-2.0" gs:managed-name="Matches">
        <doc xml:space="preserve" filename="glib-2.0.c" line="16502">Returns %TRUE if @error matches @domain and @code, %FALSE
otherwise. In particular, when @error is %NULL, %FALSE will
be returned.

If @domain contains a `FAILED` (or otherwise generic) error code,
you should generally not check for it explicitly, but should
instead treat any not-explicitly-recognized error code as being
equivalent to the `FAILED` code. This way, if the domain is
extended in the future to provide a more specific error code for
a certain case, your code will still work.</doc>
        <source-position filename="gerror.h" line="72" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="16519">whether @error has @domain and @code</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="error" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="error" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="16504">a #GError</doc>
            <type name="Error" c:type="const GError*" gs:managed-name="Error" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="domain" transfer-ownership="none" gs:managed-name="domain" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="16505">an error domain</doc>
            <type name="Quark" c:type="GQuark" gs:managed-name="Quark" />
          </parameter>
          <parameter name="code" transfer-ownership="none" gs:managed-name="code" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="16506">an error code</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="domain" transfer-ownership="none" gs:managed-name="domain" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="16505">an error domain</doc>
            <type name="Quark" c:type="GQuark" gs:managed-name="Quark" />
          </parameter>
          <parameter name="code" transfer-ownership="none" gs:managed-name="code" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="16506">an error code</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_error_get_type" gs:access-modifiers="private" gs:dll-name="gobject-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </record>
    <callback name="Func" c:type="GFunc" gs:dll-name="glib-2.0" gs:managed-name="Func">
      <doc xml:space="preserve" filename="glib-2.0.c" line="542">Specifies the type of functions passed to g_list_foreach() and
g_slist_foreach().</doc>
      <source-position filename="gtypes.h" line="114" />
      <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
        <type name="none" c:type="void" gs:managed-name="System.Void" />
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="544">the element's data</doc>
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="1" gs:managed-name="userData" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="545">user data passed to g_list_foreach() or g_slist_foreach()</doc>
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </parameter>
      </parameters>
      <gs:managed-parameters>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="544">the element's data</doc>
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </parameter>
      </gs:managed-parameters>
    </callback>
    <callback name="HFunc" c:type="GHFunc" gs:dll-name="glib-2.0" gs:managed-name="HFunc">
      <doc xml:space="preserve" filename="glib-2.0.c" line="552">Specifies the type of the function passed to g_hash_table_foreach().
It is called with each key/value pair, together with the @user_data
parameter which is passed to g_hash_table_foreach().</doc>
      <source-position filename="gtypes.h" line="117" />
      <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
        <type name="none" c:type="void" gs:managed-name="System.Void" />
      </return-value>
      <parameters>
        <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="key" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="554">a key</doc>
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </parameter>
        <parameter name="value" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="value" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="555">the value corresponding to the key</doc>
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="2" gs:managed-name="userData" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="556">user data passed to g_hash_table_foreach()</doc>
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </parameter>
      </parameters>
      <gs:managed-parameters>
        <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="key" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="554">a key</doc>
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </parameter>
        <parameter name="value" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="value" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="555">the value corresponding to the key</doc>
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </parameter>
      </gs:managed-parameters>
    </callback>
    <callback name="HRFunc" c:type="GHRFunc" gs:dll-name="glib-2.0" gs:managed-name="HRFunc">
      <doc xml:space="preserve" filename="glib-2.0.c" line="564">Specifies the type of the function passed to
g_hash_table_foreach_remove(). It is called with each key/value
pair, together with the @user_data parameter passed to
g_hash_table_foreach_remove(). It should return %TRUE if the
key/value pair should be removed from the #GHashTable.</doc>
      <source-position filename="ghash.h" line="39" />
      <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
        <doc xml:space="preserve" filename="glib-2.0.c" line="576">%TRUE if the key/value pair should be removed from the
    #GHashTable</doc>
        <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
      </return-value>
      <parameters>
        <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="key" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="566">a key</doc>
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </parameter>
        <parameter name="value" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="value" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="567">the value associated with the key</doc>
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="2" gs:managed-name="userData" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="568">user data passed to g_hash_table_remove()</doc>
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </parameter>
      </parameters>
      <gs:managed-parameters>
        <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="key" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="566">a key</doc>
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </parameter>
        <parameter name="value" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="value" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="567">the value associated with the key</doc>
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </parameter>
      </gs:managed-parameters>
    </callback>
    <callback name="HashFunc" c:type="GHashFunc" gs:dll-name="glib-2.0" gs:managed-name="HashFunc">
      <doc xml:space="preserve" filename="glib-2.0.c" line="581">Specifies the type of the hash function which is passed to
g_hash_table_new() when a #GHashTable is created.

The function is passed a key and should return a #guint hash value.
The functions g_direct_hash(), g_int_hash() and g_str_hash() provide
hash functions which can be used when the key is a #gpointer, #gint*,
and #gchar* respectively.

g_direct_hash() is also the appropriate hash function for keys
of the form `GINT_TO_POINTER (n)` (or similar macros).

A good hash functions should produce
hash values that are evenly distributed over a fairly large range.
The modulus is taken with the hash table size (a prime number) to
find the 'bucket' to place each key into. The function should also
be very fast, since it is called for each key lookup.

Note that the hash functions provided by GLib have these qualities,
but are not particularly robust against manufactured keys that
cause hash collisions. Therefore, you should consider choosing
a more secure hash function when using a GHashTable with keys
that originate in untrusted data (such as HTTP requests).
Using g_str_hash() in that situation might make your application
vulnerable to
[Algorithmic Complexity Attacks](https://lwn.net/Articles/474912/).

The key to choosing a good hash is unpredictability.  Even
cryptographic hashes are very easy to find collisions for when the
remainder is taken modulo a somewhat predictable prime number.  There
must be an element of randomness that an attacker is unable to guess.</doc>
      <source-position filename="gtypes.h" line="116" />
      <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
        <doc xml:space="preserve" filename="glib-2.0.c" line="616">the hash value corresponding to the key</doc>
        <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
      </return-value>
      <parameters>
        <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="key" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="583">a key</doc>
          <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </parameter>
      </parameters>
      <gs:managed-parameters>
        <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="key" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="583">a key</doc>
          <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </parameter>
      </gs:managed-parameters>
    </callback>
    <record name="HashTable" c:type="GHashTable" glib:type-name="GHashTable" glib:get-type="g_hash_table_get_type" c:symbol-prefix="hash_table" gs:inheritance-modifiers="abstract" gs:managed-name="HashTable">
      <doc xml:space="preserve" filename="glib-2.0.c" line="620">The #GHashTable struct is an opaque data structure to represent a
[Hash Table][glib-Hash-Tables]. It should only be accessed via the
following functions.</doc>
      <source-position filename="ghash.h" line="37" />
      <function name="add" c:identifier="g_hash_table_add" version="2.32" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="Add">
        <doc xml:space="preserve" filename="glib-2.0.c" line="17765">This is a convenience function for using a #GHashTable as a set.  It
is equivalent to calling g_hash_table_replace() with @key as both the
key and the value.

In particular, this means that if @key already exists in the hash table, then
the old copy of @key in the hash table is freed and @key replaces it in the
table.

When a hash table only ever contains keys that have themselves as the
corresponding value it is able to be stored more efficiently.  See
the discussion in the section description.

Starting from GLib 2.40, this function returns a boolean value to
indicate whether the newly added value was already in the hash table
or not.</doc>
        <source-position filename="ghash.h" line="75" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="17786">%TRUE if the key did not exist yet</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <parameter name="hash_table" transfer-ownership="none" gs:managed-name="hashTable" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="17767">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*" gs:managed-name="GISharp.Lib.GLib.HashTable" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </type>
          </parameter>
          <parameter name="key" transfer-ownership="full" nullable="1" allow-none="1" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="17768">a key to insert</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="hash_table" transfer-ownership="none" gs:managed-name="hashTable" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="17767">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*" gs:managed-name="GISharp.Lib.GLib.HashTable" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </type>
          </parameter>
          <parameter name="key" transfer-ownership="full" nullable="1" allow-none="1" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="17768">a key to insert</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="contains" c:identifier="g_hash_table_contains" version="2.32" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="Contains">
        <doc xml:space="preserve" filename="glib-2.0.c" line="17791">Checks if @key is in @hash_table.</doc>
        <source-position filename="ghash.h" line="96" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="17798">%TRUE if @key is in @hash_table, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <parameter name="hash_table" transfer-ownership="none" gs:managed-name="hashTable" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="17793">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*" gs:managed-name="GISharp.Lib.GLib.HashTable" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </type>
          </parameter>
          <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="17794">a key to check</doc>
            <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="hash_table" transfer-ownership="none" gs:managed-name="hashTable" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="17793">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*" gs:managed-name="GISharp.Lib.GLib.HashTable" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </type>
          </parameter>
          <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="17794">a key to check</doc>
            <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="destroy" c:identifier="g_hash_table_destroy" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="Destroy">
        <doc xml:space="preserve" filename="glib-2.0.c" line="17803">Destroys all keys and values in the #GHashTable and decrements its
reference count by 1. If keys and/or values are dynamically allocated,
you should either free them first or create the #GHashTable with destroy
notifiers using g_hash_table_new_full(). In the latter case the destroy
functions you supplied will be called on all keys and values during the
destruction phase.</doc>
        <source-position filename="ghash.h" line="65" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <parameter name="hash_table" transfer-ownership="none" gs:managed-name="hashTable" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="17805">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*" gs:managed-name="GISharp.Lib.GLib.HashTable" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </type>
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="hash_table" transfer-ownership="none" gs:managed-name="hashTable" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="17805">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*" gs:managed-name="GISharp.Lib.GLib.HashTable" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </type>
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="find" c:identifier="g_hash_table_find" version="2.4" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="Find">
        <doc xml:space="preserve" filename="glib-2.0.c" line="17816">Calls the given function for key/value pairs in the #GHashTable
until @predicate returns %TRUE. The function is passed the key
and value of each pair, and the given @user_data parameter. The
hash table may not be modified while iterating over it (you can't
add/remove items).

Note, that hash tables are really only optimized for forward
lookups, i.e. g_hash_table_lookup(). So code that frequently issues
g_hash_table_find() or g_hash_table_foreach() (e.g. in the order of
once per every entry in a hash table) should probably be reworked
to use additional or different data structures for reverse lookups
(keep in mind that an O(n) find/foreach operation issued for all n
values in a hash table ends up needing O(n*n) operations).</doc>
        <source-position filename="ghash.h" line="108" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="17836">The value of the first key/value pair is returned,
    for which @predicate evaluates to %TRUE. If no pair with the
    requested property is found, %NULL is returned.</doc>
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="hash_table" transfer-ownership="none" gs:managed-name="hashTable" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="17818">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*" gs:managed-name="GISharp.Lib.GLib.HashTable" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </type>
          </parameter>
          <parameter name="predicate" transfer-ownership="none" closure="2" gs:managed-name="predicate" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="17819">function to test the key/value pairs for a certain property</doc>
            <type name="HRFunc" c:type="GHRFunc" gs:managed-name="HRFunc" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="17820">user data to pass to the function</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="hash_table" transfer-ownership="none" gs:managed-name="hashTable" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="17818">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*" gs:managed-name="GISharp.Lib.GLib.HashTable" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </type>
          </parameter>
          <parameter name="predicate" transfer-ownership="none" closure="2" gs:managed-name="predicate" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="17819">function to test the key/value pairs for a certain property</doc>
            <type name="HRFunc" c:type="GHRFunc" gs:managed-name="HRFunc" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="foreach" c:identifier="g_hash_table_foreach" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="Foreach">
        <doc xml:space="preserve" filename="glib-2.0.c" line="17843">Calls the given function for each of the key/value pairs in the
#GHashTable.  The function is passed the key and value of each
pair, and the given @user_data parameter.  The hash table may not
be modified while iterating over it (you can't add/remove
items). To remove all items matching a predicate, use
g_hash_table_foreach_remove().

The order in which g_hash_table_foreach() iterates over the keys/values in
the hash table is not defined.

See g_hash_table_find() for performance caveats for linear
order searches in contrast to g_hash_table_lookup().</doc>
        <source-position filename="ghash.h" line="104" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <parameter name="hash_table" transfer-ownership="none" gs:managed-name="hashTable" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="17845">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*" gs:managed-name="GISharp.Lib.GLib.HashTable" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </type>
          </parameter>
          <parameter name="func" transfer-ownership="none" closure="2" gs:managed-name="func" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="17846">the function to call for each key/value pair</doc>
            <type name="HFunc" c:type="GHFunc" gs:managed-name="HFunc" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="17847">user data to pass to the function</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="hash_table" transfer-ownership="none" gs:managed-name="hashTable" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="17845">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*" gs:managed-name="GISharp.Lib.GLib.HashTable" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </type>
          </parameter>
          <parameter name="func" transfer-ownership="none" closure="2" gs:managed-name="func" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="17846">the function to call for each key/value pair</doc>
            <type name="HFunc" c:type="GHFunc" gs:managed-name="HFunc" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="foreach_remove" c:identifier="g_hash_table_foreach_remove" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="ForeachRemove">
        <doc xml:space="preserve" filename="glib-2.0.c" line="17864">Calls the given function for each key/value pair in the
#GHashTable. If the function returns %TRUE, then the key/value
pair is removed from the #GHashTable. If you supplied key or
value destroy functions when creating the #GHashTable, they are
used to free the memory allocated for the removed keys and values.

See #GHashTableIter for an alternative way to loop over the
key/value pairs in the hash table.</doc>
        <source-position filename="ghash.h" line="112" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="17879">the number of key/value pairs removed</doc>
          <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
        </return-value>
        <parameters>
          <parameter name="hash_table" transfer-ownership="none" gs:managed-name="hashTable" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="17866">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*" gs:managed-name="GISharp.Lib.GLib.HashTable" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </type>
          </parameter>
          <parameter name="func" transfer-ownership="none" closure="2" gs:managed-name="func" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="17867">the function to call for each key/value pair</doc>
            <type name="HRFunc" c:type="GHRFunc" gs:managed-name="HRFunc" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="17868">user data to pass to the function</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="hash_table" transfer-ownership="none" gs:managed-name="hashTable" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="17866">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*" gs:managed-name="GISharp.Lib.GLib.HashTable" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </type>
          </parameter>
          <parameter name="func" transfer-ownership="none" closure="2" gs:managed-name="func" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="17867">the function to call for each key/value pair</doc>
            <type name="HRFunc" c:type="GHRFunc" gs:managed-name="HRFunc" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="foreach_steal" c:identifier="g_hash_table_foreach_steal" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="ForeachSteal">
        <doc xml:space="preserve" filename="glib-2.0.c" line="17883">Calls the given function for each key/value pair in the
#GHashTable. If the function returns %TRUE, then the key/value
pair is removed from the #GHashTable, but no key or value
destroy functions are called.

See #GHashTableIter for an alternative way to loop over the
key/value pairs in the hash table.</doc>
        <source-position filename="ghash.h" line="116" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="17897">the number of key/value pairs removed.</doc>
          <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
        </return-value>
        <parameters>
          <parameter name="hash_table" transfer-ownership="none" gs:managed-name="hashTable" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="17885">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*" gs:managed-name="GISharp.Lib.GLib.HashTable" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </type>
          </parameter>
          <parameter name="func" transfer-ownership="none" closure="2" gs:managed-name="func" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="17886">the function to call for each key/value pair</doc>
            <type name="HRFunc" c:type="GHRFunc" gs:managed-name="HRFunc" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="17887">user data to pass to the function</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="hash_table" transfer-ownership="none" gs:managed-name="hashTable" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="17885">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*" gs:managed-name="GISharp.Lib.GLib.HashTable" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </type>
          </parameter>
          <parameter name="func" transfer-ownership="none" closure="2" gs:managed-name="func" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="17886">the function to call for each key/value pair</doc>
            <type name="HRFunc" c:type="GHRFunc" gs:managed-name="HRFunc" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="get_keys" c:identifier="g_hash_table_get_keys" version="2.14" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="GetKeys">
        <doc xml:space="preserve" filename="glib-2.0.c" line="17910">Retrieves every key inside @hash_table. The returned data is valid
until changes to the hash release those keys.

This iterates over every entry in the hash table to build its return value.
To iterate over the entries in a #GHashTable more efficiently, use a
#GHashTableIter.</doc>
        <source-position filename="ghash.h" line="122" />
        <return-value transfer-ownership="container" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="17921">a #GList containing all the keys
    inside the hash table. The content of the list is owned by the
    hash table and should not be modified or freed. Use g_list_free()
    when done using the list.</doc>
          <type name="GLib.List" c:type="GList*" gs:managed-name="GISharp.Lib.GLib.List" gs:is-pointer="1">
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </type>
        </return-value>
        <parameters>
          <parameter name="hash_table" transfer-ownership="none" gs:managed-name="hashTable" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="17912">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*" gs:managed-name="GISharp.Lib.GLib.HashTable" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </type>
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="hash_table" transfer-ownership="none" gs:managed-name="hashTable" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="17912">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*" gs:managed-name="GISharp.Lib.GLib.HashTable" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </type>
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="get_keys_as_array" c:identifier="g_hash_table_get_keys_as_array" version="2.40" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="GetKeysAsArray">
        <doc xml:space="preserve" filename="glib-2.0.c" line="17929">Retrieves every key inside @hash_table, as an array.

The returned array is %NULL-terminated but may contain %NULL as a
key.  Use @length to determine the true length if it's possible that
%NULL was used as the value for a key.

Note: in the common case of a string-keyed #GHashTable, the return
value of this function can be conveniently cast to (const gchar **).

This iterates over every entry in the hash table to build its return value.
To iterate over the entries in a #GHashTable more efficiently, use a
#GHashTableIter.

You should always free the return result with g_free().  In the
above-mentioned case of a string-keyed hash table, it may be
appropriate to use g_strfreev() if you call g_hash_table_steal_all()
first to transfer ownership of the keys.</doc>
        <source-position filename="ghash.h" line="126" />
        <return-value transfer-ownership="container" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="17952">a
  %NULL-terminated array containing each key from the table.</doc>
          <array length="1" zero-terminated="0" c:type="gpointer*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </array>
        </return-value>
        <parameters>
          <parameter name="hash_table" transfer-ownership="none" gs:managed-name="hashTable" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="17931">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*" gs:managed-name="GISharp.Lib.GLib.HashTable" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </type>
          </parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="length">
            <doc xml:space="preserve" filename="glib-2.0.c" line="17932">the length of the returned array</doc>
            <type name="guint" c:type="guint*" gs:managed-name="System.UInt32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="hash_table" transfer-ownership="none" gs:managed-name="hashTable" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="17931">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*" gs:managed-name="GISharp.Lib.GLib.HashTable" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </type>
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="get_values" c:identifier="g_hash_table_get_values" version="2.14" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="GetValues">
        <doc xml:space="preserve" filename="glib-2.0.c" line="17958">Retrieves every value inside @hash_table. The returned data
is valid until @hash_table is modified.

This iterates over every entry in the hash table to build its return value.
To iterate over the entries in a #GHashTable more efficiently, use a
#GHashTableIter.</doc>
        <source-position filename="ghash.h" line="124" />
        <return-value transfer-ownership="container" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="17969">a #GList containing all the values
    inside the hash table. The content of the list is owned by the
    hash table and should not be modified or freed. Use g_list_free()
    when done using the list.</doc>
          <type name="GLib.List" c:type="GList*" gs:managed-name="GISharp.Lib.GLib.List" gs:is-pointer="1">
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </type>
        </return-value>
        <parameters>
          <parameter name="hash_table" transfer-ownership="none" gs:managed-name="hashTable" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="17960">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*" gs:managed-name="GISharp.Lib.GLib.HashTable" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </type>
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="hash_table" transfer-ownership="none" gs:managed-name="hashTable" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="17960">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*" gs:managed-name="GISharp.Lib.GLib.HashTable" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </type>
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="insert" c:identifier="g_hash_table_insert" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="Insert">
        <doc xml:space="preserve" filename="glib-2.0.c" line="17977">Inserts a new key and value into a #GHashTable.

If the key already exists in the #GHashTable its current
value is replaced with the new value. If you supplied a
@value_destroy_func when creating the #GHashTable, the old
value is freed using that function. If you supplied a
@key_destroy_func when creating the #GHashTable, the passed
key is freed using that function.

Starting from GLib 2.40, this function returns a boolean value to
indicate whether the newly added value was already in the hash table
or not.</doc>
        <source-position filename="ghash.h" line="67" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="17996">%TRUE if the key did not exist yet</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <parameter name="hash_table" transfer-ownership="none" gs:managed-name="hashTable" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="17979">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*" gs:managed-name="GISharp.Lib.GLib.HashTable" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </type>
          </parameter>
          <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="17980">a key to insert</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
          <parameter name="value" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="17981">the value to associate with the key</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="hash_table" transfer-ownership="none" gs:managed-name="hashTable" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="17979">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*" gs:managed-name="GISharp.Lib.GLib.HashTable" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </type>
          </parameter>
          <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="17980">a key to insert</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
          <parameter name="value" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="17981">the value to associate with the key</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="lookup" c:identifier="g_hash_table_lookup" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="Lookup">
        <doc xml:space="preserve" filename="glib-2.0.c" line="18110">Looks up a key in a #GHashTable. Note that this function cannot
distinguish between a key that is not present and one which is present
and has the value %NULL. If you need this distinction, use
g_hash_table_lookup_extended().</doc>
        <source-position filename="ghash.h" line="93" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="18120">the associated value, or %NULL if the key is not found</doc>
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="hash_table" transfer-ownership="none" gs:managed-name="hashTable" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18112">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*" gs:managed-name="GISharp.Lib.GLib.HashTable" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </type>
          </parameter>
          <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18113">the key to look up</doc>
            <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="hash_table" transfer-ownership="none" gs:managed-name="hashTable" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18112">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*" gs:managed-name="GISharp.Lib.GLib.HashTable" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </type>
          </parameter>
          <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18113">the key to look up</doc>
            <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="lookup_extended" c:identifier="g_hash_table_lookup_extended" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="TryLookupExtended">
        <doc xml:space="preserve" filename="glib-2.0.c" line="18124">Looks up a key in the #GHashTable, returning the original key and the
associated value and a #gboolean which is %TRUE if the key was found. This
is useful if you need to free the memory allocated for the original key,
for example before calling g_hash_table_remove().

You can actually pass %NULL for @lookup_key to test
whether the %NULL key exists, provided the hash and equal functions
of @hash_table are %NULL-safe.</doc>
        <source-position filename="ghash.h" line="99" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="18141">%TRUE if the key was found in the #GHashTable</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <parameter name="hash_table" transfer-ownership="none" gs:managed-name="hashTable" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18126">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*" gs:managed-name="GISharp.Lib.GLib.HashTable" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </type>
          </parameter>
          <parameter name="lookup_key" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="lookupKey" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18127">the key to look up</doc>
            <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
          <parameter name="orig_key" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1" gs:managed-name="origKey">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18128">return location for the original key</doc>
            <type name="gpointer" c:type="gpointer*" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
          <parameter name="value" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1" gs:managed-name="value">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18129">return location for the value associated
with the key</doc>
            <type name="gpointer" c:type="gpointer*" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="hash_table" transfer-ownership="none" gs:managed-name="hashTable" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18126">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*" gs:managed-name="GISharp.Lib.GLib.HashTable" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </type>
          </parameter>
          <parameter name="lookup_key" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="lookupKey" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18127">the key to look up</doc>
            <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
          <parameter name="orig_key" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1" gs:managed-name="origKey">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18128">return location for the original key</doc>
            <type name="gpointer" c:type="gpointer*" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
          <parameter name="value" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1" gs:managed-name="value">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18129">return location for the value associated
with the key</doc>
            <type name="gpointer" c:type="gpointer*" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="new" c:identifier="g_hash_table_new" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="New">
        <doc xml:space="preserve" filename="glib-2.0.c" line="18145">Creates a new #GHashTable with a reference count of 1.

Hash values returned by @hash_func are used to determine where keys
are stored within the #GHashTable data structure. The g_direct_hash(),
g_int_hash(), g_int64_hash(), g_double_hash() and g_str_hash()
functions are provided for some common types of keys.
If @hash_func is %NULL, g_direct_hash() is used.

@key_equal_func is used when looking up keys in the #GHashTable.
The g_direct_equal(), g_int_equal(), g_int64_equal(), g_double_equal()
and g_str_equal() functions are provided for the most common types
of keys. If @key_equal_func is %NULL, keys are compared directly in
a similar fashion to g_direct_equal(), but without the overhead of
a function call. @key_equal_func is called with the key from the hash table
as its first parameter, and the user-provided key to check against as
its second.</doc>
        <source-position filename="ghash.h" line="57" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="18167">a new #GHashTable</doc>
          <type name="GLib.HashTable" c:type="GHashTable*" gs:managed-name="GISharp.Lib.GLib.HashTable" gs:is-pointer="1">
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </type>
        </return-value>
        <parameters>
          <parameter name="hash_func" transfer-ownership="none" gs:managed-name="hashFunc" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18147">a function to create a hash value from a key</doc>
            <type name="HashFunc" c:type="GHashFunc" gs:managed-name="HashFunc" />
          </parameter>
          <parameter name="key_equal_func" transfer-ownership="none" gs:managed-name="keyEqualFunc" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18148">a function to check two keys for equality</doc>
            <type name="EqualFunc" c:type="GEqualFunc" gs:managed-name="EqualFunc" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="hash_func" transfer-ownership="none" gs:managed-name="hashFunc" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18147">a function to create a hash value from a key</doc>
            <type name="HashFunc" c:type="GHashFunc" gs:managed-name="HashFunc" />
          </parameter>
          <parameter name="key_equal_func" transfer-ownership="none" gs:managed-name="keyEqualFunc" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18148">a function to check two keys for equality</doc>
            <type name="EqualFunc" c:type="GEqualFunc" gs:managed-name="EqualFunc" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="new_full" c:identifier="g_hash_table_new_full" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="NewFull">
        <doc xml:space="preserve" filename="glib-2.0.c" line="18171">Creates a new #GHashTable like g_hash_table_new() with a reference
count of 1 and allows to specify functions to free the memory
allocated for the key and value that get called when removing the
entry from the #GHashTable.

Since version 2.42 it is permissible for destroy notify functions to
recursively remove further items from the hash table. This is only
permissible if the application still holds a reference to the hash table.
This means that you may need to ensure that the hash table is empty by
calling g_hash_table_remove_all() before releasing the last reference using
g_hash_table_unref().</doc>
        <source-position filename="ghash.h" line="60" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="18194">a new #GHashTable</doc>
          <type name="GLib.HashTable" c:type="GHashTable*" gs:managed-name="GISharp.Lib.GLib.HashTable" gs:is-pointer="1">
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </type>
        </return-value>
        <parameters>
          <parameter name="hash_func" transfer-ownership="none" gs:managed-name="hashFunc" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18173">a function to create a hash value from a key</doc>
            <type name="HashFunc" c:type="GHashFunc" gs:managed-name="HashFunc" />
          </parameter>
          <parameter name="key_equal_func" transfer-ownership="none" scope="notified" destroy="3" gs:managed-name="keyEqualFunc" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18174">a function to check two keys for equality</doc>
            <type name="EqualFunc" c:type="GEqualFunc" gs:managed-name="EqualFunc" />
          </parameter>
          <parameter name="key_destroy_func" transfer-ownership="none" nullable="1" allow-none="1" scope="async" gs:managed-name="keyDestroyFunc" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18175">a function to free the memory allocated for the key
    used when removing the entry from the #GHashTable, or %NULL
    if you don't want to supply such a function.</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify" gs:managed-name="DestroyNotify" />
          </parameter>
          <parameter name="value_destroy_func" transfer-ownership="none" nullable="1" allow-none="1" scope="async" gs:managed-name="valueDestroyFunc" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18178">a function to free the memory allocated for the
    value used when removing the entry from the #GHashTable, or %NULL
    if you don't want to supply such a function.</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify" gs:managed-name="DestroyNotify" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="hash_func" transfer-ownership="none" gs:managed-name="hashFunc" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18173">a function to create a hash value from a key</doc>
            <type name="HashFunc" c:type="GHashFunc" gs:managed-name="HashFunc" />
          </parameter>
          <parameter name="key_equal_func" transfer-ownership="none" scope="notified" destroy="3" gs:managed-name="keyEqualFunc" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18174">a function to check two keys for equality</doc>
            <type name="EqualFunc" c:type="GEqualFunc" gs:managed-name="EqualFunc" />
          </parameter>
          <parameter name="key_destroy_func" transfer-ownership="none" nullable="1" allow-none="1" scope="async" gs:managed-name="keyDestroyFunc" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18175">a function to free the memory allocated for the key
    used when removing the entry from the #GHashTable, or %NULL
    if you don't want to supply such a function.</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify" gs:managed-name="DestroyNotify" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <method name="ref" c:identifier="g_hash_table_ref" version="2.10" introspectable="1" gs:dll-name="glib-2.0" gs:managed-name="Ref" gs:special-func="ref" gs:pinvoke-only="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="18198">Atomically increments the reference count of @hash_table by one.
This function is MT-safe and may be called from any thread.</doc>
        <source-position filename="ghash.h" line="147" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="18205">the passed in #GHashTable</doc>
          <type name="GLib.HashTable" c:type="GHashTable*" gs:managed-name="GISharp.Lib.GLib.HashTable" gs:is-pointer="1">
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="hash_table" transfer-ownership="none" gs:managed-name="hashTable" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18200">a valid #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*" gs:managed-name="GISharp.Lib.GLib.HashTable" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </type>
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <function name="remove" c:identifier="g_hash_table_remove" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="Remove">
        <doc xml:space="preserve" filename="glib-2.0.c" line="18210">Removes a key and its associated value from a #GHashTable.

If the #GHashTable was created using g_hash_table_new_full(), the
key and value are freed using the supplied destroy functions, otherwise
you have to make sure that any dynamically allocated values are freed
yourself.</doc>
        <source-position filename="ghash.h" line="78" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="18222">%TRUE if the key was found and removed from the #GHashTable</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <parameter name="hash_table" transfer-ownership="none" gs:managed-name="hashTable" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18212">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*" gs:managed-name="GISharp.Lib.GLib.HashTable" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </type>
          </parameter>
          <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18213">the key to remove</doc>
            <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="hash_table" transfer-ownership="none" gs:managed-name="hashTable" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18212">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*" gs:managed-name="GISharp.Lib.GLib.HashTable" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </type>
          </parameter>
          <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18213">the key to remove</doc>
            <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="remove_all" c:identifier="g_hash_table_remove_all" version="2.12" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="RemoveAll">
        <doc xml:space="preserve" filename="glib-2.0.c" line="18226">Removes all keys and their associated values from a #GHashTable.

If the #GHashTable was created using g_hash_table_new_full(),
the keys and values are freed using the supplied destroy functions,
otherwise you have to make sure that any dynamically allocated
values are freed yourself.</doc>
        <source-position filename="ghash.h" line="81" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <parameter name="hash_table" transfer-ownership="none" gs:managed-name="hashTable" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18228">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*" gs:managed-name="GISharp.Lib.GLib.HashTable" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </type>
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="hash_table" transfer-ownership="none" gs:managed-name="hashTable" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18228">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*" gs:managed-name="GISharp.Lib.GLib.HashTable" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </type>
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="replace" c:identifier="g_hash_table_replace" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="Replace">
        <doc xml:space="preserve" filename="glib-2.0.c" line="18241">Inserts a new key and value into a #GHashTable similar to
g_hash_table_insert(). The difference is that if the key
already exists in the #GHashTable, it gets replaced by the
new key. If you supplied a @value_destroy_func when creating
the #GHashTable, the old value is freed using that function.
If you supplied a @key_destroy_func when creating the
#GHashTable, the old key is freed using that function.

Starting from GLib 2.40, this function returns a boolean value to
indicate whether the newly added value was already in the hash table
or not.</doc>
        <source-position filename="ghash.h" line="71" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="18259">%TRUE if the key did not exist yet</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <parameter name="hash_table" transfer-ownership="none" gs:managed-name="hashTable" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18243">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*" gs:managed-name="GISharp.Lib.GLib.HashTable" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </type>
          </parameter>
          <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18244">a key to insert</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
          <parameter name="value" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18245">the value to associate with the key</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="hash_table" transfer-ownership="none" gs:managed-name="hashTable" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18243">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*" gs:managed-name="GISharp.Lib.GLib.HashTable" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </type>
          </parameter>
          <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18244">a key to insert</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
          <parameter name="value" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18245">the value to associate with the key</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="size" c:identifier="g_hash_table_size" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="Size">
        <doc xml:space="preserve" filename="glib-2.0.c" line="18263">Returns the number of elements contained in the #GHashTable.</doc>
        <source-position filename="ghash.h" line="120" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="18269">the number of key/value pairs in the #GHashTable.</doc>
          <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
        </return-value>
        <parameters>
          <parameter name="hash_table" transfer-ownership="none" gs:managed-name="hashTable" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18265">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*" gs:managed-name="GISharp.Lib.GLib.HashTable" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </type>
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="hash_table" transfer-ownership="none" gs:managed-name="hashTable" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18265">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*" gs:managed-name="GISharp.Lib.GLib.HashTable" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </type>
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="steal" c:identifier="g_hash_table_steal" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="Steal">
        <doc xml:space="preserve" filename="glib-2.0.c" line="18273">Removes a key and its associated value from a #GHashTable without
calling the key and value destroy functions.</doc>
        <source-position filename="ghash.h" line="83" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="18281">%TRUE if the key was found and removed from the #GHashTable</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <parameter name="hash_table" transfer-ownership="none" gs:managed-name="hashTable" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18275">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*" gs:managed-name="GISharp.Lib.GLib.HashTable" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </type>
          </parameter>
          <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18276">the key to remove</doc>
            <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="hash_table" transfer-ownership="none" gs:managed-name="hashTable" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18275">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*" gs:managed-name="GISharp.Lib.GLib.HashTable" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </type>
          </parameter>
          <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18276">the key to remove</doc>
            <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="steal_all" c:identifier="g_hash_table_steal_all" version="2.12" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="StealAll">
        <doc xml:space="preserve" filename="glib-2.0.c" line="18285">Removes all keys and their associated values from a #GHashTable
without calling the key and value destroy functions.</doc>
        <source-position filename="ghash.h" line="91" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <parameter name="hash_table" transfer-ownership="none" gs:managed-name="hashTable" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18287">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*" gs:managed-name="GISharp.Lib.GLib.HashTable" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </type>
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="hash_table" transfer-ownership="none" gs:managed-name="hashTable" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18287">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*" gs:managed-name="GISharp.Lib.GLib.HashTable" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </type>
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="steal_extended" c:identifier="g_hash_table_steal_extended" version="2.58" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="TryStealExtended">
        <doc xml:space="preserve" filename="glib-2.0.c" line="18296">Looks up a key in the #GHashTable, stealing the original key and the
associated value and returning %TRUE if the key was found. If the key was
not found, %FALSE is returned.

If found, the stolen key and value are removed from the hash table without
calling the key and value destroy functions, and ownership is transferred to
the caller of this method; as with g_hash_table_steal().

You can pass %NULL for @lookup_key, provided the hash and equal functions
of @hash_table are %NULL-safe.</doc>
        <source-position filename="ghash.h" line="86" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="18316">%TRUE if the key was found in the #GHashTable</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <parameter name="hash_table" transfer-ownership="none" gs:managed-name="hashTable" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18298">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*" gs:managed-name="GISharp.Lib.GLib.HashTable" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </type>
          </parameter>
          <parameter name="lookup_key" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="lookupKey" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18299">the key to look up</doc>
            <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
          <parameter name="stolen_key" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1" gs:managed-name="stolenKey">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18300">return location for the
   original key</doc>
            <type name="gpointer" c:type="gpointer*" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
          <parameter name="stolen_value" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1" gs:managed-name="stolenValue">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18302">return location
   for the value associated with the key</doc>
            <type name="gpointer" c:type="gpointer*" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="hash_table" transfer-ownership="none" gs:managed-name="hashTable" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18298">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*" gs:managed-name="GISharp.Lib.GLib.HashTable" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </type>
          </parameter>
          <parameter name="lookup_key" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="lookupKey" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18299">the key to look up</doc>
            <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
          <parameter name="stolen_key" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1" gs:managed-name="stolenKey">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18300">return location for the
   original key</doc>
            <type name="gpointer" c:type="gpointer*" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
          <parameter name="stolen_value" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1" optional="1" allow-none="1" gs:managed-name="stolenValue">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18302">return location
   for the value associated with the key</doc>
            <type name="gpointer" c:type="gpointer*" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <method name="unref" c:identifier="g_hash_table_unref" version="2.10" introspectable="1" gs:dll-name="glib-2.0" gs:managed-name="Unref" gs:special-func="unref" gs:pinvoke-only="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="18330">Atomically decrements the reference count of @hash_table by one.
If the reference count drops to 0, all keys and values will be
destroyed, and all memory allocated by the hash table is released.
This function is MT-safe and may be called from any thread.</doc>
        <source-position filename="ghash.h" line="149" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="hash_table" transfer-ownership="none" gs:managed-name="hashTable" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18332">a valid #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable*" gs:managed-name="GISharp.Lib.GLib.HashTable" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </type>
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_hash_table_get_type" gs:access-modifiers="private" gs:dll-name="gobject-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </record>
    <bitfield name="IOCondition" glib:type-name="GIOCondition" glib:get-type="g_io_condition_get_type" c:type="GIOCondition" gs:managed-name="IOCondition">
      <doc xml:space="preserve" filename="glib-2.0.c" line="957">A bitwise combination representing a condition to watch for on an
event source.</doc>
      <member name="in" value="1" c:identifier="G_IO_IN" glib:nick="in" gs:managed-name="In">
        <doc xml:space="preserve" filename="glib-2.0.c" line="959">There is data to read.</doc>
      </member>
      <member name="out" value="4" c:identifier="G_IO_OUT" glib:nick="out" gs:managed-name="Out">
        <doc xml:space="preserve" filename="glib-2.0.c" line="960">Data can be written (without blocking).</doc>
      </member>
      <member name="pri" value="2" c:identifier="G_IO_PRI" glib:nick="pri" gs:managed-name="Pri">
        <doc xml:space="preserve" filename="glib-2.0.c" line="961">There is urgent data to read.</doc>
      </member>
      <member name="err" value="8" c:identifier="G_IO_ERR" glib:nick="err" gs:managed-name="Err">
        <doc xml:space="preserve" filename="glib-2.0.c" line="962">Error condition.</doc>
      </member>
      <member name="hup" value="16" c:identifier="G_IO_HUP" glib:nick="hup" gs:managed-name="Hup">
        <doc xml:space="preserve" filename="glib-2.0.c" line="963">Hung up (the connection has been broken, usually for
           pipes and sockets).</doc>
      </member>
      <member name="nval" value="32" c:identifier="G_IO_NVAL" glib:nick="nval" gs:managed-name="Nval">
        <doc xml:space="preserve" filename="glib-2.0.c" line="965">Invalid request. The file descriptor is not open.</doc>
      </member>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_io_condition_get_type" gs:access-modifiers="private" gs:dll-name="gobject-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </bitfield>
    <record name="KeyFile" c:type="GKeyFile" glib:type-name="GKeyFile" glib:get-type="g_key_file_get_type" c:symbol-prefix="key_file" gs:managed-name="KeyFile">
      <doc xml:space="preserve" filename="glib-2.0.c" line="1075">The GKeyFile struct contains only private data
and should not be accessed directly.</doc>
      <source-position filename="gkeyfile.h" line="48" />
      <constructor name="new" c:identifier="g_key_file_new" version="2.6" gs:dll-name="glib-2.0" gs:managed-name="New">
        <doc xml:space="preserve" filename="glib-2.0.c" line="20303">Creates a new empty #GKeyFile object. Use
g_key_file_load_from_file(), g_key_file_load_from_data(),
g_key_file_load_from_dirs() or g_key_file_load_from_data_dirs() to
read an existing key file.</doc>
        <source-position filename="gkeyfile.h" line="58" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="20311">an empty #GKeyFile.</doc>
          <type name="KeyFile" c:type="GKeyFile*" gs:managed-name="KeyFile" gs:is-pointer="1" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </constructor>
      <method name="get_boolean" c:identifier="g_key_file_get_boolean" version="2.6" throws="1" gs:dll-name="glib-2.0" gs:managed-name="GetBoolean">
        <doc xml:space="preserve" filename="glib-2.0.c" line="19787">Returns the value associated with @key under @group_name as a
boolean.

If @key cannot be found then %FALSE is returned and @error is set
to #G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the value
associated with @key cannot be interpreted as a boolean then %FALSE
is returned and @error is set to #G_KEY_FILE_ERROR_INVALID_VALUE.</doc>
        <source-position filename="gkeyfile.h" line="161" />
        <return-value transfer-ownership="none" skip="0" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="19802">the value associated with the key as a boolean,
   or %FALSE if the key was not found or could not be parsed.</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none" gs:managed-name="keyFile" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="19789">a #GKeyFile</doc>
            <type name="KeyFile" c:type="GKeyFile*" gs:managed-name="KeyFile" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="19790">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="19791">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:managed-name="GISharp.Lib.GLib.Error" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="19790">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="19791">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_boolean_list" c:identifier="g_key_file_get_boolean_list" version="2.6" throws="1" gs:dll-name="glib-2.0" gs:managed-name="GetBooleanList">
        <doc xml:space="preserve" filename="glib-2.0.c" line="19808">Returns the values associated with @key under @group_name as
booleans.

If @key cannot be found then %NULL is returned and @error is set to
#G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the values associated
with @key cannot be interpreted as booleans then %NULL is returned
and @error is set to #G_KEY_FILE_ERROR_INVALID_VALUE.</doc>
        <source-position filename="gkeyfile.h" line="237" />
        <return-value transfer-ownership="container" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="19824">
   the values associated with the key as a list of booleans, or %NULL if the
   key was not found or could not be parsed. The returned list of booleans
   should be freed with g_free() when no longer needed.</doc>
          <array length="2" zero-terminated="0" c:type="gboolean*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
            <type name="gboolean" gs:managed-name="System.Boolean" />
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none" gs:managed-name="keyFile" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="19810">a #GKeyFile</doc>
            <type name="KeyFile" c:type="GKeyFile*" gs:managed-name="KeyFile" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="19811">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="19812">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="length">
            <doc xml:space="preserve" filename="glib-2.0.c" line="19813">the number of booleans returned</doc>
            <type name="gsize" c:type="gsize*" gs:managed-name="System.Int32" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:managed-name="GISharp.Lib.GLib.Error" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="19811">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="19812">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_comment" c:identifier="g_key_file_get_comment" version="2.6" throws="1" gs:dll-name="glib-2.0" gs:managed-name="GetComment">
        <doc xml:space="preserve" filename="glib-2.0.c" line="19832">Retrieves a comment above @key from @group_name.
If @key is %NULL then @comment will be read from above
@group_name. If both @key and @group_name are %NULL, then
@comment will be read from above the first group in the file.

Note that the returned string does not include the '#' comment markers,
but does include any whitespace after them (on each line). It includes
the line breaks between lines, but does not include the final line break.</doc>
        <source-position filename="gkeyfile.h" line="279" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="19848">a comment that should be freed with g_free()</doc>
          <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none" gs:managed-name="keyFile" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="19834">a #GKeyFile</doc>
            <type name="KeyFile" c:type="GKeyFile*" gs:managed-name="KeyFile" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="19835">a group name, or %NULL</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="19836">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:managed-name="GISharp.Lib.GLib.Error" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="group_name" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="19835">a group name, or %NULL</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="19836">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_double" c:identifier="g_key_file_get_double" version="2.12" throws="1" gs:dll-name="glib-2.0" gs:managed-name="GetDouble">
        <doc xml:space="preserve" filename="glib-2.0.c" line="19853">Returns the value associated with @key under @group_name as a
double. If @group_name is %NULL, the start_group is used.

If @key cannot be found then 0.0 is returned and @error is set to
#G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the value associated
with @key cannot be interpreted as a double then 0.0 is returned
and @error is set to #G_KEY_FILE_ERROR_INVALID_VALUE.</doc>
        <source-position filename="gkeyfile.h" line="201" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="19868">the value associated with the key as a double, or
    0.0 if the key was not found or could not be parsed.</doc>
          <type name="gdouble" c:type="gdouble" gs:managed-name="System.Double" />
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none" gs:managed-name="keyFile" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="19855">a #GKeyFile</doc>
            <type name="KeyFile" c:type="GKeyFile*" gs:managed-name="KeyFile" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="19856">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="19857">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:managed-name="GISharp.Lib.GLib.Error" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="19856">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="19857">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_double_list" c:identifier="g_key_file_get_double_list" version="2.12" throws="1" gs:dll-name="glib-2.0" gs:managed-name="GetDoubleList">
        <doc xml:space="preserve" filename="glib-2.0.c" line="19874">Returns the values associated with @key under @group_name as
doubles.

If @key cannot be found then %NULL is returned and @error is set to
#G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the values associated
with @key cannot be interpreted as doubles then %NULL is returned
and @error is set to #G_KEY_FILE_ERROR_INVALID_VALUE.</doc>
        <source-position filename="gkeyfile.h" line="261" />
        <return-value transfer-ownership="container" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="19890">
    the values associated with the key as a list of doubles, or %NULL if the
    key was not found or could not be parsed. The returned list of doubles
    should be freed with g_free() when no longer needed.</doc>
          <array length="2" zero-terminated="0" c:type="gdouble*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
            <type name="gdouble" gs:managed-name="System.Double" />
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none" gs:managed-name="keyFile" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="19876">a #GKeyFile</doc>
            <type name="KeyFile" c:type="GKeyFile*" gs:managed-name="KeyFile" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="19877">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="19878">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="length">
            <doc xml:space="preserve" filename="glib-2.0.c" line="19879">the number of doubles returned</doc>
            <type name="gsize" c:type="gsize*" gs:managed-name="System.Int32" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:managed-name="GISharp.Lib.GLib.Error" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="19877">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="19878">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <gs:managed-property name="get_groups" version="2.6" gs:dll-name="glib-2.0" gs:managed-name="Groups">
        <doc xml:space="preserve" filename="glib-2.0.c" line="19898">Returns all groups in the key file loaded with @key_file.
The array of returned groups will be %NULL-terminated, so
@length may optionally be %NULL.</doc>
        <source-position filename="gkeyfile.h" line="108" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="19907">a newly-allocated %NULL-terminated array of strings.
  Use g_strfreev() to free it.</doc>
          <array c:type="gchar**" zero-terminated="1" length="0" name="GLib.Strv" gs:managed-name="GISharp.Lib.GLib.Strv" gs:is-pointer="1">
            <type name="utf8" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none" gs:managed-name="keyFile" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="19900">a #GKeyFile</doc>
            <type name="KeyFile" c:type="GKeyFile*" gs:managed-name="KeyFile" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="length">
            <doc xml:space="preserve" filename="glib-2.0.c" line="19901">return location for the number of returned groups, or %NULL</doc>
            <type name="gsize" c:type="gsize*" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_groups" c:identifier="g_key_file_get_groups" version="2.6" gs:dll-name="glib-2.0" gs:managed-name="GetGroups" gs:property-getter-for="Groups" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="19898">Returns all groups in the key file loaded with @key_file.
The array of returned groups will be %NULL-terminated, so
@length may optionally be %NULL.</doc>
        <source-position filename="gkeyfile.h" line="108" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="19907">a newly-allocated %NULL-terminated array of strings.
  Use g_strfreev() to free it.</doc>
          <array c:type="gchar**" zero-terminated="1" length="0" name="GLib.Strv" gs:managed-name="GISharp.Lib.GLib.Strv" gs:is-pointer="1">
            <type name="utf8" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none" gs:managed-name="keyFile" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="19900">a #GKeyFile</doc>
            <type name="KeyFile" c:type="GKeyFile*" gs:managed-name="KeyFile" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="length">
            <doc xml:space="preserve" filename="glib-2.0.c" line="19901">return location for the number of returned groups, or %NULL</doc>
            <type name="gsize" c:type="gsize*" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="get_int64" c:identifier="g_key_file_get_int64" version="2.26" throws="1" gs:dll-name="glib-2.0" gs:managed-name="GetInt64">
        <doc xml:space="preserve" filename="glib-2.0.c" line="19913">Returns the value associated with @key under @group_name as a signed
64-bit integer. This is similar to g_key_file_get_integer() but can return
64-bit results without truncation.</doc>
        <source-position filename="gkeyfile.h" line="181" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="19924">the value associated with the key as a signed 64-bit integer, or
0 if the key was not found or could not be parsed.</doc>
          <type name="gint64" c:type="gint64" gs:managed-name="System.Int64" />
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none" gs:managed-name="keyFile" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="19915">a non-%NULL #GKeyFile</doc>
            <type name="KeyFile" c:type="GKeyFile*" gs:managed-name="KeyFile" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="19916">a non-%NULL group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="19917">a non-%NULL key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:managed-name="GISharp.Lib.GLib.Error" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="19916">a non-%NULL group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="19917">a non-%NULL key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_integer" c:identifier="g_key_file_get_integer" version="2.6" throws="1" gs:dll-name="glib-2.0" gs:managed-name="GetInteger">
        <doc xml:space="preserve" filename="glib-2.0.c" line="19930">Returns the value associated with @key under @group_name as an
integer.

If @key cannot be found then 0 is returned and @error is set to
#G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the value associated
with @key cannot be interpreted as an integer, or is out of range
for a #gint, then 0 is returned
and @error is set to #G_KEY_FILE_ERROR_INVALID_VALUE.</doc>
        <source-position filename="gkeyfile.h" line="171" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="19946">the value associated with the key as an integer, or
    0 if the key was not found or could not be parsed.</doc>
          <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none" gs:managed-name="keyFile" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="19932">a #GKeyFile</doc>
            <type name="KeyFile" c:type="GKeyFile*" gs:managed-name="KeyFile" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="19933">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="19934">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:managed-name="GISharp.Lib.GLib.Error" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="19933">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="19934">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_integer_list" c:identifier="g_key_file_get_integer_list" version="2.6" throws="1" gs:dll-name="glib-2.0" gs:managed-name="GetIntegerList">
        <doc xml:space="preserve" filename="glib-2.0.c" line="19952">Returns the values associated with @key under @group_name as
integers.

If @key cannot be found then %NULL is returned and @error is set to
#G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the values associated
with @key cannot be interpreted as integers, or are out of range for
#gint, then %NULL is returned
and @error is set to #G_KEY_FILE_ERROR_INVALID_VALUE.</doc>
        <source-position filename="gkeyfile.h" line="249" />
        <return-value transfer-ownership="container" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="19969">
    the values associated with the key as a list of integers, or %NULL if
    the key was not found or could not be parsed. The returned list of
    integers should be freed with g_free() when no longer needed.</doc>
          <array length="2" zero-terminated="0" c:type="gint*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
            <type name="gint" gs:managed-name="System.Int32" />
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none" gs:managed-name="keyFile" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="19954">a #GKeyFile</doc>
            <type name="KeyFile" c:type="GKeyFile*" gs:managed-name="KeyFile" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="19955">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="19956">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="length">
            <doc xml:space="preserve" filename="glib-2.0.c" line="19957">the number of integers returned</doc>
            <type name="gsize" c:type="gsize*" gs:managed-name="System.Int32" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:managed-name="GISharp.Lib.GLib.Error" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="19955">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="19956">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_keys" c:identifier="g_key_file_get_keys" version="2.6" throws="1" gs:dll-name="glib-2.0" gs:managed-name="GetKeys">
        <doc xml:space="preserve" filename="glib-2.0.c" line="19977">Returns all keys for the group name @group_name.  The array of
returned keys will be %NULL-terminated, so @length may
optionally be %NULL. In the event that the @group_name cannot
be found, %NULL is returned and @error is set to
#G_KEY_FILE_ERROR_GROUP_NOT_FOUND.</doc>
        <source-position filename="gkeyfile.h" line="111" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="19990">a newly-allocated %NULL-terminated array of strings.
    Use g_strfreev() to free it.</doc>
          <array c:type="gchar**" zero-terminated="1" length="1" name="GLib.Strv" gs:managed-name="GISharp.Lib.GLib.Strv" gs:is-pointer="1">
            <type name="utf8" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none" gs:managed-name="keyFile" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="19979">a #GKeyFile</doc>
            <type name="KeyFile" c:type="GKeyFile*" gs:managed-name="KeyFile" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="19980">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="length">
            <doc xml:space="preserve" filename="glib-2.0.c" line="19981">return location for the number of keys returned, or %NULL</doc>
            <type name="gsize" c:type="gsize*" gs:managed-name="System.Int32" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:managed-name="GISharp.Lib.GLib.Error" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="19980">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_locale_for_key" c:identifier="g_key_file_get_locale_for_key" version="2.56" gs:dll-name="glib-2.0" gs:managed-name="GetLocaleForKey">
        <doc xml:space="preserve" filename="glib-2.0.c" line="19996">Returns the actual locale which the result of
g_key_file_get_locale_string() or g_key_file_get_locale_string_list()
came from.

If calling g_key_file_get_locale_string() or
g_key_file_get_locale_string_list() with exactly the same @key_file,
@group_name, @key and @locale, the result of those functions will
have originally been tagged with the locale that is the result of
this function.</doc>
        <source-position filename="gkeyfile.h" line="150" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="20013">the locale from the file, or %NULL if the key was not
  found or the entry in the file was was untranslated</doc>
          <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none" gs:managed-name="keyFile" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="19998">a #GKeyFile</doc>
            <type name="KeyFile" c:type="GKeyFile*" gs:managed-name="KeyFile" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="19999">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20000">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="locale" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="locale" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20001">a locale identifier or %NULL</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="19999">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20000">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="locale" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="locale" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20001">a locale identifier or %NULL</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_locale_string" c:identifier="g_key_file_get_locale_string" version="2.6" throws="1" gs:dll-name="glib-2.0" gs:managed-name="GetLocaleString">
        <doc xml:space="preserve" filename="glib-2.0.c" line="20019">Returns the value associated with @key under @group_name
translated in the given @locale if available.  If @locale is
%NULL then the current locale is assumed.

If @locale is to be non-%NULL, or if the current locale will change over
the lifetime of the #GKeyFile, it must be loaded with
%G_KEY_FILE_KEEP_TRANSLATIONS in order to load strings for all locales.

If @key cannot be found then %NULL is returned and @error is set
to #G_KEY_FILE_ERROR_KEY_NOT_FOUND. If the value associated
with @key cannot be interpreted or no suitable translation can
be found then the untranslated value is returned.</doc>
        <source-position filename="gkeyfile.h" line="144" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="20040">a newly allocated string or %NULL if the specified
  key cannot be found.</doc>
          <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none" gs:managed-name="keyFile" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20021">a #GKeyFile</doc>
            <type name="KeyFile" c:type="GKeyFile*" gs:managed-name="KeyFile" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20022">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20023">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="locale" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="locale" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20024">a locale identifier or %NULL</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:managed-name="GISharp.Lib.GLib.Error" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20022">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20023">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="locale" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="locale" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20024">a locale identifier or %NULL</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_locale_string_list" c:identifier="g_key_file_get_locale_string_list" version="2.6" throws="1" gs:dll-name="glib-2.0" gs:managed-name="GetLocaleStringList">
        <doc xml:space="preserve" filename="glib-2.0.c" line="20046">Returns the values associated with @key under @group_name
translated in the given @locale if available.  If @locale is
%NULL then the current locale is assumed.

If @locale is to be non-%NULL, or if the current locale will change over
the lifetime of the #GKeyFile, it must be loaded with
%G_KEY_FILE_KEEP_TRANSLATIONS in order to load strings for all locales.

If @key cannot be found then %NULL is returned and @error is set
to #G_KEY_FILE_ERROR_KEY_NOT_FOUND. If the values associated
with @key cannot be interpreted or no suitable translations
can be found then the untranslated values are returned. The
returned array is %NULL-terminated, so @length may optionally
be %NULL.</doc>
        <source-position filename="gkeyfile.h" line="223" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="20070">a newly allocated %NULL-terminated string array
  or %NULL if the key isn't found. The string array should be freed
  with g_strfreev().</doc>
          <array length="3" zero-terminated="1" c:type="gchar**" name="GLib.Strv" gs:managed-name="GISharp.Lib.GLib.Strv" gs:is-pointer="1">
            <type name="utf8" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none" gs:managed-name="keyFile" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20048">a #GKeyFile</doc>
            <type name="KeyFile" c:type="GKeyFile*" gs:managed-name="KeyFile" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20049">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20050">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="locale" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="locale" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20051">a locale identifier or %NULL</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="length">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20052">return location for the number of returned strings or %NULL</doc>
            <type name="gsize" c:type="gsize*" gs:managed-name="System.Int32" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:managed-name="GISharp.Lib.GLib.Error" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20049">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20050">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="locale" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="locale" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20051">a locale identifier or %NULL</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <gs:managed-property name="get_start_group" version="2.6" gs:dll-name="glib-2.0" gs:managed-name="StartGroup">
        <doc xml:space="preserve" filename="glib-2.0.c" line="20077">Returns the name of the start group of the file.</doc>
        <source-position filename="gkeyfile.h" line="106" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="20083">The start group of the key file.</doc>
          <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none" gs:managed-name="keyFile" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20079">a #GKeyFile</doc>
            <type name="KeyFile" c:type="GKeyFile*" gs:managed-name="KeyFile" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_start_group" c:identifier="g_key_file_get_start_group" version="2.6" gs:dll-name="glib-2.0" gs:managed-name="GetStartGroup" gs:property-getter-for="StartGroup" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="20077">Returns the name of the start group of the file.</doc>
        <source-position filename="gkeyfile.h" line="106" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="20083">The start group of the key file.</doc>
          <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none" gs:managed-name="keyFile" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20079">a #GKeyFile</doc>
            <type name="KeyFile" c:type="GKeyFile*" gs:managed-name="KeyFile" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="get_string" c:identifier="g_key_file_get_string" version="2.6" throws="1" gs:dll-name="glib-2.0" gs:managed-name="GetString">
        <doc xml:space="preserve" filename="glib-2.0.c" line="20088">Returns the string value associated with @key under @group_name.
Unlike g_key_file_get_value(), this function handles escape sequences
like \s.

In the event the key cannot be found, %NULL is returned and
@error is set to #G_KEY_FILE_ERROR_KEY_NOT_FOUND.  In the
event that the @group_name cannot be found, %NULL is returned
and @error is set to #G_KEY_FILE_ERROR_GROUP_NOT_FOUND.</doc>
        <source-position filename="gkeyfile.h" line="134" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="20104">a newly allocated string or %NULL if the specified
  key cannot be found.</doc>
          <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none" gs:managed-name="keyFile" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20090">a #GKeyFile</doc>
            <type name="KeyFile" c:type="GKeyFile*" gs:managed-name="KeyFile" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20091">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20092">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:managed-name="GISharp.Lib.GLib.Error" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20091">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20092">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_string_list" c:identifier="g_key_file_get_string_list" version="2.6" throws="1" gs:dll-name="glib-2.0" gs:managed-name="GetStringList">
        <doc xml:space="preserve" filename="glib-2.0.c" line="20110">Returns the values associated with @key under @group_name.

In the event the key cannot be found, %NULL is returned and
@error is set to #G_KEY_FILE_ERROR_KEY_NOT_FOUND.  In the
event that the @group_name cannot be found, %NULL is returned
and @error is set to #G_KEY_FILE_ERROR_GROUP_NOT_FOUND.</doc>
        <source-position filename="gkeyfile.h" line="211" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="20125">
 a %NULL-terminated string array or %NULL if the specified
 key cannot be found. The array should be freed with g_strfreev().</doc>
          <array length="2" zero-terminated="1" c:type="gchar**" name="GLib.Strv" gs:managed-name="GISharp.Lib.GLib.Strv" gs:is-pointer="1">
            <type name="utf8" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none" gs:managed-name="keyFile" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20112">a #GKeyFile</doc>
            <type name="KeyFile" c:type="GKeyFile*" gs:managed-name="KeyFile" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20113">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20114">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="length">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20115">return location for the number of returned strings, or %NULL</doc>
            <type name="gsize" c:type="gsize*" gs:managed-name="System.Int32" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:managed-name="GISharp.Lib.GLib.Error" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20113">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20114">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_uint64" c:identifier="g_key_file_get_uint64" version="2.26" throws="1" gs:dll-name="glib-2.0" gs:managed-name="GetUint64">
        <doc xml:space="preserve" filename="glib-2.0.c" line="20132">Returns the value associated with @key under @group_name as an unsigned
64-bit integer. This is similar to g_key_file_get_integer() but can return
large positive results without truncation.</doc>
        <source-position filename="gkeyfile.h" line="191" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="20143">the value associated with the key as an unsigned 64-bit integer,
or 0 if the key was not found or could not be parsed.</doc>
          <type name="guint64" c:type="guint64" gs:managed-name="System.UInt64" />
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none" gs:managed-name="keyFile" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20134">a non-%NULL #GKeyFile</doc>
            <type name="KeyFile" c:type="GKeyFile*" gs:managed-name="KeyFile" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20135">a non-%NULL group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20136">a non-%NULL key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:managed-name="GISharp.Lib.GLib.Error" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20135">a non-%NULL group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20136">a non-%NULL key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_value" c:identifier="g_key_file_get_value" version="2.6" throws="1" gs:dll-name="glib-2.0" gs:managed-name="GetValue">
        <doc xml:space="preserve" filename="glib-2.0.c" line="20149">Returns the raw value associated with @key under @group_name.
Use g_key_file_get_string() to retrieve an unescaped UTF-8 string.

In the event the key cannot be found, %NULL is returned and
@error is set to #G_KEY_FILE_ERROR_KEY_NOT_FOUND.  In the
event that the @group_name cannot be found, %NULL is returned
and @error is set to #G_KEY_FILE_ERROR_GROUP_NOT_FOUND.</doc>
        <source-position filename="gkeyfile.h" line="124" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="20164">a newly allocated string or %NULL if the specified
 key cannot be found.</doc>
          <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none" gs:managed-name="keyFile" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20151">a #GKeyFile</doc>
            <type name="KeyFile" c:type="GKeyFile*" gs:managed-name="KeyFile" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20152">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20153">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:managed-name="GISharp.Lib.GLib.Error" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20152">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20153">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="has_group" c:identifier="g_key_file_has_group" version="2.6" gs:dll-name="glib-2.0" gs:managed-name="HasGroup">
        <doc xml:space="preserve" filename="glib-2.0.c" line="20170">Looks whether the key file has the group @group_name.</doc>
        <source-position filename="gkeyfile.h" line="116" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="20177">%TRUE if @group_name is a part of @key_file, %FALSE
otherwise.</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none" gs:managed-name="keyFile" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20172">a #GKeyFile</doc>
            <type name="KeyFile" c:type="GKeyFile*" gs:managed-name="KeyFile" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20173">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20173">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="load_from_bytes" c:identifier="g_key_file_load_from_bytes" version="2.50" throws="1" gs:dll-name="glib-2.0" gs:managed-name="LoadFromBytes">
        <doc xml:space="preserve" filename="glib-2.0.c" line="20206">Loads a key file from the data in @bytes into an empty #GKeyFile structure.
If the object cannot be created then %error is set to a #GKeyFileError.</doc>
        <source-position filename="gkeyfile.h" line="80" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="20216">%TRUE if a key file could be loaded, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none" gs:managed-name="keyFile" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20208">an empty #GKeyFile struct</doc>
            <type name="KeyFile" c:type="GKeyFile*" gs:managed-name="KeyFile" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="bytes" transfer-ownership="none" gs:managed-name="bytes" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20209">a #GBytes</doc>
            <type name="Bytes" c:type="GBytes*" gs:managed-name="Bytes" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20210">flags from #GKeyFileFlags</doc>
            <type name="KeyFileFlags" c:type="GKeyFileFlags" gs:managed-name="KeyFileFlags" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:managed-name="GISharp.Lib.GLib.Error" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="bytes" transfer-ownership="none" gs:managed-name="bytes" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20209">a #GBytes</doc>
            <type name="Bytes" c:type="GBytes*" gs:managed-name="Bytes" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20210">flags from #GKeyFileFlags</doc>
            <type name="KeyFileFlags" c:type="GKeyFileFlags" gs:managed-name="KeyFileFlags" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="load_from_data" c:identifier="g_key_file_load_from_data" version="2.6" throws="1" gs:dll-name="glib-2.0" gs:managed-name="LoadFromData">
        <doc xml:space="preserve" filename="glib-2.0.c" line="20221">Loads a key file from memory into an empty #GKeyFile structure.
If the object cannot be created then %error is set to a #GKeyFileError.</doc>
        <source-position filename="gkeyfile.h" line="74" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="20232">%TRUE if a key file could be loaded, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none" gs:managed-name="keyFile" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20223">an empty #GKeyFile struct</doc>
            <type name="KeyFile" c:type="GKeyFile*" gs:managed-name="KeyFile" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="data" transfer-ownership="none" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20224">key file loaded in memory</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="length" transfer-ownership="none" gs:managed-name="length" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20225">the length of @data in bytes (or (gsize)-1 if data is nul-terminated)</doc>
            <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20226">flags from #GKeyFileFlags</doc>
            <type name="KeyFileFlags" c:type="GKeyFileFlags" gs:managed-name="KeyFileFlags" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:managed-name="GISharp.Lib.GLib.Error" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="data" transfer-ownership="none" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20224">key file loaded in memory</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="length" transfer-ownership="none" gs:managed-name="length" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20225">the length of @data in bytes (or (gsize)-1 if data is nul-terminated)</doc>
            <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20226">flags from #GKeyFileFlags</doc>
            <type name="KeyFileFlags" c:type="GKeyFileFlags" gs:managed-name="KeyFileFlags" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="load_from_data_dirs" c:identifier="g_key_file_load_from_data_dirs" version="2.6" throws="1" gs:dll-name="glib-2.0" gs:managed-name="LoadFromDataDirs">
        <doc xml:space="preserve" filename="glib-2.0.c" line="20237">This function looks for a key file named @file in the paths
returned from g_get_user_data_dir() and g_get_system_data_dirs(),
loads the file into @key_file and returns the file's full path in
@full_path.  If the file could not be loaded then an %error is
set to either a #GFileError or #GKeyFileError.</doc>
        <source-position filename="gkeyfile.h" line="92" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="20252">%TRUE if a key file could be loaded, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none" gs:managed-name="keyFile" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20239">an empty #GKeyFile struct</doc>
            <type name="KeyFile" c:type="GKeyFile*" gs:managed-name="KeyFile" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20240">a relative path to a filename to open and parse</doc>
            <type name="filename" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Filename" gs:is-pointer="1" />
          </parameter>
          <parameter name="full_path" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="fullPath">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20241">return location for a string containing the full path
  of the file, or %NULL</doc>
            <type name="filename" c:type="gchar**" gs:managed-name="GISharp.Lib.GLib.Filename" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20243">flags from #GKeyFileFlags</doc>
            <type name="KeyFileFlags" c:type="GKeyFileFlags" gs:managed-name="KeyFileFlags" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:managed-name="GISharp.Lib.GLib.Error" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20240">a relative path to a filename to open and parse</doc>
            <type name="filename" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Filename" gs:is-pointer="1" />
          </parameter>
          <parameter name="full_path" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="fullPath">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20241">return location for a string containing the full path
  of the file, or %NULL</doc>
            <type name="filename" c:type="gchar**" gs:managed-name="GISharp.Lib.GLib.Filename" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20243">flags from #GKeyFileFlags</doc>
            <type name="KeyFileFlags" c:type="GKeyFileFlags" gs:managed-name="KeyFileFlags" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="load_from_dirs" c:identifier="g_key_file_load_from_dirs" version="2.14" throws="1" gs:dll-name="glib-2.0" gs:managed-name="LoadFromDirs">
        <doc xml:space="preserve" filename="glib-2.0.c" line="20257">This function looks for a key file named @file in the paths
specified in @search_dirs, loads the file into @key_file and
returns the file's full path in @full_path.

If the file could not be found in any of the @search_dirs,
%G_KEY_FILE_ERROR_NOT_FOUND is returned. If
the file is found but the OS returns an error when opening or reading the
file, a %G_FILE_ERROR is returned. If there is a problem parsing the file, a
%G_KEY_FILE_ERROR is returned.</doc>
        <source-position filename="gkeyfile.h" line="85" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="20277">%TRUE if a key file could be loaded, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none" gs:managed-name="keyFile" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20259">an empty #GKeyFile struct</doc>
            <type name="KeyFile" c:type="GKeyFile*" gs:managed-name="KeyFile" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20260">a relative path to a filename to open and parse</doc>
            <type name="filename" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Filename" gs:is-pointer="1" />
          </parameter>
          <parameter name="search_dirs" transfer-ownership="none" gs:managed-name="searchDirs" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20261">%NULL-terminated array of directories to search</doc>
            <array c:type="const gchar**" zero-terminated="1" gs:managed-name="GISharp.Runtime.FilenameArray" gs:is-pointer="1">
              <type name="filename" gs:managed-name="GISharp.Lib.GLib.Filename" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="full_path" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="fullPath">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20262">return location for a string containing the full path
  of the file, or %NULL</doc>
            <type name="filename" c:type="gchar**" gs:managed-name="GISharp.Lib.GLib.Filename" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20264">flags from #GKeyFileFlags</doc>
            <type name="KeyFileFlags" c:type="GKeyFileFlags" gs:managed-name="KeyFileFlags" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:managed-name="GISharp.Lib.GLib.Error" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20260">a relative path to a filename to open and parse</doc>
            <type name="filename" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Filename" gs:is-pointer="1" />
          </parameter>
          <parameter name="search_dirs" transfer-ownership="none" gs:managed-name="searchDirs" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20261">%NULL-terminated array of directories to search</doc>
            <array c:type="const gchar**" zero-terminated="1" gs:managed-name="GISharp.Runtime.FilenameArray" gs:is-pointer="1">
              <type name="filename" gs:managed-name="GISharp.Lib.GLib.Filename" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="full_path" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="fullPath">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20262">return location for a string containing the full path
  of the file, or %NULL</doc>
            <type name="filename" c:type="gchar**" gs:managed-name="GISharp.Lib.GLib.Filename" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20264">flags from #GKeyFileFlags</doc>
            <type name="KeyFileFlags" c:type="GKeyFileFlags" gs:managed-name="KeyFileFlags" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="load_from_file" c:identifier="g_key_file_load_from_file" version="2.6" throws="1" gs:dll-name="glib-2.0" gs:managed-name="LoadFromFile">
        <doc xml:space="preserve" filename="glib-2.0.c" line="20282">Loads a key file into an empty #GKeyFile structure.

If the OS returns an error when opening or reading the file, a
%G_FILE_ERROR is returned. If there is a problem parsing the file, a
%G_KEY_FILE_ERROR is returned.

This function will never return a %G_KEY_FILE_ERROR_NOT_FOUND error. If the
@file is not found, %G_FILE_ERROR_NOENT is returned.</doc>
        <source-position filename="gkeyfile.h" line="69" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="20298">%TRUE if a key file could be loaded, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none" gs:managed-name="keyFile" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20284">an empty #GKeyFile struct</doc>
            <type name="KeyFile" c:type="GKeyFile*" gs:managed-name="KeyFile" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20285">the path of a filename to load, in the GLib filename encoding</doc>
            <type name="filename" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Filename" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20286">flags from #GKeyFileFlags</doc>
            <type name="KeyFileFlags" c:type="GKeyFileFlags" gs:managed-name="KeyFileFlags" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:managed-name="GISharp.Lib.GLib.Error" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="file" transfer-ownership="none" gs:managed-name="file" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20285">the path of a filename to load, in the GLib filename encoding</doc>
            <type name="filename" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Filename" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20286">flags from #GKeyFileFlags</doc>
            <type name="KeyFileFlags" c:type="GKeyFileFlags" gs:managed-name="KeyFileFlags" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="ref" c:identifier="g_key_file_ref" version="2.32" introspectable="1" gs:dll-name="glib-2.0" gs:managed-name="Ref" gs:special-func="ref" gs:pinvoke-only="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="20316">Increases the reference count of @key_file.</doc>
        <source-position filename="gkeyfile.h" line="60" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="20322">the same @key_file.</doc>
          <type name="KeyFile" c:type="GKeyFile*" gs:managed-name="KeyFile" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none" gs:managed-name="keyFile" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20318">a #GKeyFile</doc>
            <type name="KeyFile" c:type="GKeyFile*" gs:managed-name="KeyFile" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="remove_comment" c:identifier="g_key_file_remove_comment" version="2.6" throws="1" gs:dll-name="glib-2.0" gs:managed-name="RemoveComment">
        <doc xml:space="preserve" filename="glib-2.0.c" line="20327">Removes a comment above @key from @group_name.
If @key is %NULL then @comment will be removed above @group_name.
If both @key and @group_name are %NULL, then @comment will
be removed above the first group in the file.</doc>
        <source-position filename="gkeyfile.h" line="285" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="20339">%TRUE if the comment was removed, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none" gs:managed-name="keyFile" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20329">a #GKeyFile</doc>
            <type name="KeyFile" c:type="GKeyFile*" gs:managed-name="KeyFile" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20330">a group name, or %NULL</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20331">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:managed-name="GISharp.Lib.GLib.Error" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="group_name" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20330">a group name, or %NULL</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20331">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="remove_group" c:identifier="g_key_file_remove_group" version="2.6" throws="1" gs:dll-name="glib-2.0" gs:managed-name="RemoveGroup">
        <doc xml:space="preserve" filename="glib-2.0.c" line="20344">Removes the specified group, @group_name,
from the key file.</doc>
        <source-position filename="gkeyfile.h" line="295" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="20353">%TRUE if the group was removed, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none" gs:managed-name="keyFile" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20346">a #GKeyFile</doc>
            <type name="KeyFile" c:type="GKeyFile*" gs:managed-name="KeyFile" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20347">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:managed-name="GISharp.Lib.GLib.Error" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20347">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="remove_key" c:identifier="g_key_file_remove_key" version="2.6" throws="1" gs:dll-name="glib-2.0" gs:managed-name="RemoveKey">
        <doc xml:space="preserve" filename="glib-2.0.c" line="20358">Removes @key in @group_name from the key file.</doc>
        <source-position filename="gkeyfile.h" line="290" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="20367">%TRUE if the key was removed, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none" gs:managed-name="keyFile" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20360">a #GKeyFile</doc>
            <type name="KeyFile" c:type="GKeyFile*" gs:managed-name="KeyFile" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20361">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20362">a key name to remove</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:managed-name="GISharp.Lib.GLib.Error" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20361">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20362">a key name to remove</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="save_to_file" c:identifier="g_key_file_save_to_file" version="2.40" throws="1" gs:dll-name="glib-2.0" gs:managed-name="SaveToFile">
        <doc xml:space="preserve" filename="glib-2.0.c" line="20372">Writes the contents of @key_file to @filename using
g_file_set_contents(). If you need stricter guarantees about durability of
the written file than are provided by g_file_set_contents(), use
g_file_set_contents_full() with the return value of g_key_file_to_data().

This function can fail for any of the reasons that
g_file_set_contents() may fail.</doc>
        <source-position filename="gkeyfile.h" line="102" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="20386">%TRUE if successful, else %FALSE with @error set</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none" gs:managed-name="keyFile" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20374">a #GKeyFile</doc>
            <type name="KeyFile" c:type="GKeyFile*" gs:managed-name="KeyFile" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="filename" transfer-ownership="none" gs:managed-name="filename" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20375">the name of the file to write to</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:managed-name="GISharp.Lib.GLib.Error" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="filename" transfer-ownership="none" gs:managed-name="filename" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20375">the name of the file to write to</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_boolean" c:identifier="g_key_file_set_boolean" version="2.6" gs:dll-name="glib-2.0" gs:managed-name="SetBoolean">
        <doc xml:space="preserve" filename="glib-2.0.c" line="20391">Associates a new boolean value with @key under @group_name.
If @key cannot be found then it is created.</doc>
        <source-position filename="gkeyfile.h" line="166" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none" gs:managed-name="keyFile" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20393">a #GKeyFile</doc>
            <type name="KeyFile" c:type="GKeyFile*" gs:managed-name="KeyFile" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20394">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20395">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20396">%TRUE or %FALSE</doc>
            <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20394">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20395">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20396">%TRUE or %FALSE</doc>
            <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_boolean_list" c:identifier="g_key_file_set_boolean_list" version="2.6" gs:dll-name="glib-2.0" gs:managed-name="SetBooleanList">
        <doc xml:space="preserve" filename="glib-2.0.c" line="20405">Associates a list of boolean values with @key under @group_name.
If @key cannot be found then it is created.
If @group_name is %NULL, the start_group is used.</doc>
        <source-position filename="gkeyfile.h" line="243" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none" gs:managed-name="keyFile" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20407">a #GKeyFile</doc>
            <type name="KeyFile" c:type="GKeyFile*" gs:managed-name="KeyFile" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20408">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20409">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="list" transfer-ownership="none" gs:managed-name="list" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20410">an array of boolean values</doc>
            <array length="3" zero-terminated="0" c:type="gboolean*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none" gs:managed-name="length" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20411">length of @list</doc>
            <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20408">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20409">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="list" transfer-ownership="none" gs:managed-name="list" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20410">an array of boolean values</doc>
            <array length="3" zero-terminated="0" c:type="gboolean*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
            </array>
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_comment" c:identifier="g_key_file_set_comment" version="2.6" throws="1" gs:dll-name="glib-2.0" gs:managed-name="SetComment">
        <doc xml:space="preserve" filename="glib-2.0.c" line="20421">Places a comment above @key from @group_name.

If @key is %NULL then @comment will be written above @group_name.
If both @key and @group_name  are %NULL, then @comment will be
written above the first group in the file.

Note that this function prepends a '#' comment marker to
each line of @comment.</doc>
        <source-position filename="gkeyfile.h" line="273" />
        <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="20438">%TRUE if the comment was written, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none" gs:managed-name="keyFile" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20423">a #GKeyFile</doc>
            <type name="KeyFile" c:type="GKeyFile*" gs:managed-name="KeyFile" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20424">a group name, or %NULL</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20425">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="comment" transfer-ownership="none" gs:managed-name="comment" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20426">a comment</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:managed-name="GISharp.Lib.GLib.Error" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="group_name" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20424">a group name, or %NULL</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20425">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="comment" transfer-ownership="none" gs:managed-name="comment" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20426">a comment</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_double" c:identifier="g_key_file_set_double" version="2.12" gs:dll-name="glib-2.0" gs:managed-name="SetDouble">
        <doc xml:space="preserve" filename="glib-2.0.c" line="20443">Associates a new double value with @key under @group_name.
If @key cannot be found then it is created.</doc>
        <source-position filename="gkeyfile.h" line="206" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none" gs:managed-name="keyFile" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20445">a #GKeyFile</doc>
            <type name="KeyFile" c:type="GKeyFile*" gs:managed-name="KeyFile" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20446">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20447">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20448">a double value</doc>
            <type name="gdouble" c:type="gdouble" gs:managed-name="System.Double" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20446">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20447">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20448">a double value</doc>
            <type name="gdouble" c:type="gdouble" gs:managed-name="System.Double" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_double_list" c:identifier="g_key_file_set_double_list" version="2.12" gs:dll-name="glib-2.0" gs:managed-name="SetDoubleList">
        <doc xml:space="preserve" filename="glib-2.0.c" line="20457">Associates a list of double values with @key under
@group_name.  If @key cannot be found then it is created.</doc>
        <source-position filename="gkeyfile.h" line="255" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none" gs:managed-name="keyFile" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20459">a #GKeyFile</doc>
            <type name="KeyFile" c:type="GKeyFile*" gs:managed-name="KeyFile" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20460">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20461">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="list" transfer-ownership="none" gs:managed-name="list" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20462">an array of double values</doc>
            <array length="3" zero-terminated="0" c:type="gdouble*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="gdouble" c:type="gdouble" gs:managed-name="System.Double" />
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none" gs:managed-name="length" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20463">number of double values in @list</doc>
            <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20460">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20461">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="list" transfer-ownership="none" gs:managed-name="list" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20462">an array of double values</doc>
            <array length="3" zero-terminated="0" c:type="gdouble*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="gdouble" c:type="gdouble" gs:managed-name="System.Double" />
            </array>
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_int64" c:identifier="g_key_file_set_int64" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="SetInt64">
        <doc xml:space="preserve" filename="glib-2.0.c" line="20472">Associates a new integer value with @key under @group_name.
If @key cannot be found then it is created.</doc>
        <source-position filename="gkeyfile.h" line="186" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none" gs:managed-name="keyFile" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20474">a #GKeyFile</doc>
            <type name="KeyFile" c:type="GKeyFile*" gs:managed-name="KeyFile" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20475">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20476">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20477">an integer value</doc>
            <type name="gint64" c:type="gint64" gs:managed-name="System.Int64" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20475">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20476">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20477">an integer value</doc>
            <type name="gint64" c:type="gint64" gs:managed-name="System.Int64" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_integer" c:identifier="g_key_file_set_integer" version="2.6" gs:dll-name="glib-2.0" gs:managed-name="SetInteger">
        <doc xml:space="preserve" filename="glib-2.0.c" line="20486">Associates a new integer value with @key under @group_name.
If @key cannot be found then it is created.</doc>
        <source-position filename="gkeyfile.h" line="176" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none" gs:managed-name="keyFile" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20488">a #GKeyFile</doc>
            <type name="KeyFile" c:type="GKeyFile*" gs:managed-name="KeyFile" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20489">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20490">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20491">an integer value</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20489">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20490">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20491">an integer value</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_integer_list" c:identifier="g_key_file_set_integer_list" version="2.6" gs:dll-name="glib-2.0" gs:managed-name="SetIntegerList">
        <doc xml:space="preserve" filename="glib-2.0.c" line="20500">Associates a list of integer values with @key under @group_name.
If @key cannot be found then it is created.</doc>
        <source-position filename="gkeyfile.h" line="267" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none" gs:managed-name="keyFile" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20502">a #GKeyFile</doc>
            <type name="KeyFile" c:type="GKeyFile*" gs:managed-name="KeyFile" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20503">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20504">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="list" transfer-ownership="none" gs:managed-name="list" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20505">an array of integer values</doc>
            <array length="3" zero-terminated="0" c:type="gint*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none" gs:managed-name="length" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20506">number of integer values in @list</doc>
            <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20503">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20504">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="list" transfer-ownership="none" gs:managed-name="list" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20505">an array of integer values</doc>
            <array length="3" zero-terminated="0" c:type="gint*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
            </array>
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_list_separator" c:identifier="g_key_file_set_list_separator" version="2.6" gs:dll-name="glib-2.0" gs:managed-name="SetListSeparator">
        <doc xml:space="preserve" filename="glib-2.0.c" line="20515">Sets the character which is used to separate
values in lists. Typically ';' or ',' are used
as separators. The default list separator is ';'.</doc>
        <source-position filename="gkeyfile.h" line="66" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none" gs:managed-name="keyFile" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20517">a #GKeyFile</doc>
            <type name="KeyFile" c:type="GKeyFile*" gs:managed-name="KeyFile" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="separator" transfer-ownership="none" gs:managed-name="separator" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20518">the separator</doc>
            <type name="gchar" c:type="gchar" gs:managed-name="System.SByte" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="separator" transfer-ownership="none" gs:managed-name="separator" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20518">the separator</doc>
            <type name="gchar" c:type="gchar" gs:managed-name="System.SByte" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_locale_string" c:identifier="g_key_file_set_locale_string" version="2.6" gs:dll-name="glib-2.0" gs:managed-name="SetLocaleString">
        <doc xml:space="preserve" filename="glib-2.0.c" line="20528">Associates a string value for @key and @locale under @group_name.
If the translation for @key cannot be found then it is created.</doc>
        <source-position filename="gkeyfile.h" line="155" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none" gs:managed-name="keyFile" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20530">a #GKeyFile</doc>
            <type name="KeyFile" c:type="GKeyFile*" gs:managed-name="KeyFile" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20531">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20532">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="locale" transfer-ownership="none" gs:managed-name="locale" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20533">a locale identifier</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="string" transfer-ownership="none" gs:managed-name="@string" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20534">a string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20531">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20532">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="locale" transfer-ownership="none" gs:managed-name="locale" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20533">a locale identifier</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="string" transfer-ownership="none" gs:managed-name="@string" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20534">a string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_locale_string_list" c:identifier="g_key_file_set_locale_string_list" version="2.6" gs:dll-name="glib-2.0" gs:managed-name="SetLocaleStringList">
        <doc xml:space="preserve" filename="glib-2.0.c" line="20543">Associates a list of string values for @key and @locale under
@group_name.  If the translation for @key cannot be found then
it is created.</doc>
        <source-position filename="gkeyfile.h" line="230" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none" gs:managed-name="keyFile" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20545">a #GKeyFile</doc>
            <type name="KeyFile" c:type="GKeyFile*" gs:managed-name="KeyFile" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20546">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20547">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="locale" transfer-ownership="none" gs:managed-name="locale" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20548">a locale identifier</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="list" transfer-ownership="none" gs:managed-name="list" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20549">a %NULL-terminated array of locale string values</doc>
            <array length="4" zero-terminated="0" c:type="const gchar* const*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none" gs:managed-name="length" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20550">the length of @list</doc>
            <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20546">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20547">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="locale" transfer-ownership="none" gs:managed-name="locale" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20548">a locale identifier</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="list" transfer-ownership="none" gs:managed-name="list" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20549">a %NULL-terminated array of locale string values</doc>
            <array length="4" zero-terminated="0" c:type="const gchar* const*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
            </array>
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_string" c:identifier="g_key_file_set_string" version="2.6" gs:dll-name="glib-2.0" gs:managed-name="SetString">
        <doc xml:space="preserve" filename="glib-2.0.c" line="20560">Associates a new string value with @key under @group_name.
If @key cannot be found then it is created.
If @group_name cannot be found then it is created.
Unlike g_key_file_set_value(), this function handles characters
that need escaping, such as newlines.</doc>
        <source-position filename="gkeyfile.h" line="139" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none" gs:managed-name="keyFile" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20562">a #GKeyFile</doc>
            <type name="KeyFile" c:type="GKeyFile*" gs:managed-name="KeyFile" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20563">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20564">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="string" transfer-ownership="none" gs:managed-name="@string" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20565">a string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20563">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20564">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="string" transfer-ownership="none" gs:managed-name="@string" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20565">a string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_string_list" c:identifier="g_key_file_set_string_list" version="2.6" gs:dll-name="glib-2.0" gs:managed-name="SetStringList">
        <doc xml:space="preserve" filename="glib-2.0.c" line="20577">Associates a list of string values for @key under @group_name.
If @key cannot be found then it is created.
If @group_name cannot be found then it is created.</doc>
        <source-position filename="gkeyfile.h" line="217" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none" gs:managed-name="keyFile" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20579">a #GKeyFile</doc>
            <type name="KeyFile" c:type="GKeyFile*" gs:managed-name="KeyFile" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20580">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20581">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="list" transfer-ownership="none" gs:managed-name="list" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20582">an array of string values</doc>
            <array length="3" zero-terminated="0" c:type="const gchar* const*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="utf8" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none" gs:managed-name="length" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20583">number of string values in @list</doc>
            <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20580">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20581">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="list" transfer-ownership="none" gs:managed-name="list" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20582">an array of string values</doc>
            <array length="3" zero-terminated="0" c:type="const gchar* const*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="utf8" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
            </array>
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_uint64" c:identifier="g_key_file_set_uint64" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="SetUint64">
        <doc xml:space="preserve" filename="glib-2.0.c" line="20593">Associates a new integer value with @key under @group_name.
If @key cannot be found then it is created.</doc>
        <source-position filename="gkeyfile.h" line="196" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none" gs:managed-name="keyFile" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20595">a #GKeyFile</doc>
            <type name="KeyFile" c:type="GKeyFile*" gs:managed-name="KeyFile" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20596">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20597">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20598">an integer value</doc>
            <type name="guint64" c:type="guint64" gs:managed-name="System.UInt64" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20596">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20597">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20598">an integer value</doc>
            <type name="guint64" c:type="guint64" gs:managed-name="System.UInt64" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_value" c:identifier="g_key_file_set_value" version="2.6" gs:dll-name="glib-2.0" gs:managed-name="SetValue">
        <doc xml:space="preserve" filename="glib-2.0.c" line="20607">Associates a new value with @key under @group_name.

If @key cannot be found then it is created. If @group_name cannot
be found then it is created. To set an UTF-8 string which may contain
characters that need escaping (such as newlines or spaces), use
g_key_file_set_string().</doc>
        <source-position filename="gkeyfile.h" line="129" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none" gs:managed-name="keyFile" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20609">a #GKeyFile</doc>
            <type name="KeyFile" c:type="GKeyFile*" gs:managed-name="KeyFile" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20610">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20611">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20612">a string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="group_name" transfer-ownership="none" gs:managed-name="groupName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20610">a group name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20611">a key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20612">a string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="to_data" c:identifier="g_key_file_to_data" version="2.6" throws="1" gs:dll-name="glib-2.0" gs:managed-name="ToData">
        <doc xml:space="preserve" filename="glib-2.0.c" line="20625">This function outputs @key_file as a string.

Note that this function never reports an error,
so it is safe to pass %NULL as @error.</doc>
        <source-position filename="gkeyfile.h" line="98" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="20637">a newly allocated string holding
  the contents of the #GKeyFile</doc>
          <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none" gs:managed-name="keyFile" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20627">a #GKeyFile</doc>
            <type name="KeyFile" c:type="GKeyFile*" gs:managed-name="KeyFile" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="length">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20628">return location for the length of the
  returned string, or %NULL</doc>
            <type name="gsize" c:type="gsize*" gs:managed-name="System.Int32" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:managed-name="GISharp.Lib.GLib.Error" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="length">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20628">return location for the length of the
  returned string, or %NULL</doc>
            <type name="gsize" c:type="gsize*" gs:managed-name="System.Int32" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="unref" c:identifier="g_key_file_unref" version="2.32" introspectable="1" gs:dll-name="glib-2.0" gs:managed-name="Unref" gs:special-func="unref" gs:pinvoke-only="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="20643">Decreases the reference count of @key_file by 1. If the reference count
reaches zero, frees the key file and all its allocated memory.</doc>
        <source-position filename="gkeyfile.h" line="62" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="key_file" transfer-ownership="none" gs:managed-name="keyFile" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="20645">a #GKeyFile</doc>
            <type name="KeyFile" c:type="GKeyFile*" gs:managed-name="KeyFile" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <constant name="DESKTOP_GROUP" value="Desktop Entry" c:type="G_KEY_FILE_DESKTOP_GROUP" version="2.14" gs:managed-name="DesktopGroup">
        <doc xml:space="preserve" filename="glib-2.0.c" line="3611">The name of the main group of a desktop entry file, as defined in the
[Desktop Entry Specification](http://freedesktop.org/Standards/desktop-entry-spec).
Consult the specification for more
details about the meanings of the keys below.</doc>
        <source-position filename="gkeyfile.h" line="300" />
        <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
      </constant>
      <constant name="DESKTOP_KEY_ACTIONS" value="Actions" c:type="G_KEY_FILE_DESKTOP_KEY_ACTIONS" version="2.38" gs:managed-name="DesktopKeyActions">
        <doc xml:space="preserve" filename="glib-2.0.c" line="3623">A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a string list
giving the available application actions.</doc>
        <source-position filename="gkeyfile.h" line="322" />
        <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
      </constant>
      <constant name="DESKTOP_KEY_CATEGORIES" value="Categories" c:type="G_KEY_FILE_DESKTOP_KEY_CATEGORIES" version="2.14" gs:managed-name="DesktopKeyCategories">
        <doc xml:space="preserve" filename="glib-2.0.c" line="3633">A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a list
of strings giving the categories in which the desktop entry
should be shown in a menu.</doc>
        <source-position filename="gkeyfile.h" line="317" />
        <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
      </constant>
      <constant name="DESKTOP_KEY_COMMENT" value="Comment" c:type="G_KEY_FILE_DESKTOP_KEY_COMMENT" version="2.14" gs:managed-name="DesktopKeyComment">
        <doc xml:space="preserve" filename="glib-2.0.c" line="3644">A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a localized
string giving the tooltip for the desktop entry.</doc>
        <source-position filename="gkeyfile.h" line="307" />
        <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
      </constant>
      <constant name="DESKTOP_KEY_DBUS_ACTIVATABLE" value="DBusActivatable" c:type="G_KEY_FILE_DESKTOP_KEY_DBUS_ACTIVATABLE" version="2.38" gs:managed-name="DesktopKeyDbusActivatable">
        <doc xml:space="preserve" filename="glib-2.0.c" line="3654">A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a boolean set to true
if the application is D-Bus activatable.</doc>
        <source-position filename="gkeyfile.h" line="321" />
        <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
      </constant>
      <constant name="DESKTOP_KEY_EXEC" value="Exec" c:type="G_KEY_FILE_DESKTOP_KEY_EXEC" version="2.14" gs:managed-name="DesktopKeyExec">
        <doc xml:space="preserve" filename="glib-2.0.c" line="3664">A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a string
giving the command line to execute. It is only valid for desktop
entries with the `Application` type.</doc>
        <source-position filename="gkeyfile.h" line="313" />
        <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
      </constant>
      <constant name="DESKTOP_KEY_GENERIC_NAME" value="GenericName" c:type="G_KEY_FILE_DESKTOP_KEY_GENERIC_NAME" version="2.14" gs:managed-name="DesktopKeyGenericName">
        <doc xml:space="preserve" filename="glib-2.0.c" line="3675">A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a localized
string giving the generic name of the desktop entry.</doc>
        <source-position filename="gkeyfile.h" line="305" />
        <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
      </constant>
      <constant name="DESKTOP_KEY_HIDDEN" value="Hidden" c:type="G_KEY_FILE_DESKTOP_KEY_HIDDEN" version="2.14" gs:managed-name="DesktopKeyHidden">
        <doc xml:space="preserve" filename="glib-2.0.c" line="3685">A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a boolean
stating whether the desktop entry has been deleted by the user.</doc>
        <source-position filename="gkeyfile.h" line="309" />
        <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
      </constant>
      <constant name="DESKTOP_KEY_ICON" value="Icon" c:type="G_KEY_FILE_DESKTOP_KEY_ICON" version="2.14" gs:managed-name="DesktopKeyIcon">
        <doc xml:space="preserve" filename="glib-2.0.c" line="3695">A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a localized
string giving the name of the icon to be displayed for the desktop
entry.</doc>
        <source-position filename="gkeyfile.h" line="308" />
        <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
      </constant>
      <constant name="DESKTOP_KEY_MIME_TYPE" value="MimeType" c:type="G_KEY_FILE_DESKTOP_KEY_MIME_TYPE" version="2.14" gs:managed-name="DesktopKeyMimeType">
        <doc xml:space="preserve" filename="glib-2.0.c" line="3706">A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a list
of strings giving the MIME types supported by this desktop entry.</doc>
        <source-position filename="gkeyfile.h" line="316" />
        <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
      </constant>
      <constant name="DESKTOP_KEY_NAME" value="Name" c:type="G_KEY_FILE_DESKTOP_KEY_NAME" version="2.14" gs:managed-name="DesktopKeyName">
        <doc xml:space="preserve" filename="glib-2.0.c" line="3716">A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a localized
string giving the specific name of the desktop entry.</doc>
        <source-position filename="gkeyfile.h" line="304" />
        <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
      </constant>
      <constant name="DESKTOP_KEY_NOT_SHOW_IN" value="NotShowIn" c:type="G_KEY_FILE_DESKTOP_KEY_NOT_SHOW_IN" version="2.14" gs:managed-name="DesktopKeyNotShowIn">
        <doc xml:space="preserve" filename="glib-2.0.c" line="3726">A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a list of
strings identifying the environments that should not display the
desktop entry.</doc>
        <source-position filename="gkeyfile.h" line="311" />
        <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
      </constant>
      <constant name="DESKTOP_KEY_NO_DISPLAY" value="NoDisplay" c:type="G_KEY_FILE_DESKTOP_KEY_NO_DISPLAY" version="2.14" gs:managed-name="DesktopKeyNoDisplay">
        <doc xml:space="preserve" filename="glib-2.0.c" line="3737">A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a boolean
stating whether the desktop entry should be shown in menus.</doc>
        <source-position filename="gkeyfile.h" line="306" />
        <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
      </constant>
      <constant name="DESKTOP_KEY_ONLY_SHOW_IN" value="OnlyShowIn" c:type="G_KEY_FILE_DESKTOP_KEY_ONLY_SHOW_IN" version="2.14" gs:managed-name="DesktopKeyOnlyShowIn">
        <doc xml:space="preserve" filename="glib-2.0.c" line="3747">A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a list of
strings identifying the environments that should display the
desktop entry.</doc>
        <source-position filename="gkeyfile.h" line="310" />
        <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
      </constant>
      <constant name="DESKTOP_KEY_PATH" value="Path" c:type="G_KEY_FILE_DESKTOP_KEY_PATH" version="2.14" gs:managed-name="DesktopKeyPath">
        <doc xml:space="preserve" filename="glib-2.0.c" line="3758">A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a string
containing the working directory to run the program in. It is only
valid for desktop entries with the `Application` type.</doc>
        <source-position filename="gkeyfile.h" line="314" />
        <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
      </constant>
      <constant name="DESKTOP_KEY_STARTUP_NOTIFY" value="StartupNotify" c:type="G_KEY_FILE_DESKTOP_KEY_STARTUP_NOTIFY" version="2.14" gs:managed-name="DesktopKeyStartupNotify">
        <doc xml:space="preserve" filename="glib-2.0.c" line="3769">A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a boolean
stating whether the application supports the
[Startup Notification Protocol Specification](http://www.freedesktop.org/Standards/startup-notification-spec).</doc>
        <source-position filename="gkeyfile.h" line="318" />
        <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
      </constant>
      <constant name="DESKTOP_KEY_STARTUP_WM_CLASS" value="StartupWMClass" c:type="G_KEY_FILE_DESKTOP_KEY_STARTUP_WM_CLASS" version="2.14" gs:managed-name="DesktopKeyStartupWmClass">
        <doc xml:space="preserve" filename="glib-2.0.c" line="3780">A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is string
identifying the WM class or name hint of a window that the application
will create, which can be used to emulate Startup Notification with
older applications.</doc>
        <source-position filename="gkeyfile.h" line="319" />
        <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
      </constant>
      <constant name="DESKTOP_KEY_TERMINAL" value="Terminal" c:type="G_KEY_FILE_DESKTOP_KEY_TERMINAL" version="2.14" gs:managed-name="DesktopKeyTerminal">
        <doc xml:space="preserve" filename="glib-2.0.c" line="3792">A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a boolean
stating whether the program should be run in a terminal window.
It is only valid for desktop entries with the
`Application` type.</doc>
        <source-position filename="gkeyfile.h" line="315" />
        <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
      </constant>
      <constant name="DESKTOP_KEY_TRY_EXEC" value="TryExec" c:type="G_KEY_FILE_DESKTOP_KEY_TRY_EXEC" version="2.14" gs:managed-name="DesktopKeyTryExec">
        <doc xml:space="preserve" filename="glib-2.0.c" line="3804">A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a string
giving the file name of a binary on disk used to determine if the
program is actually installed. It is only valid for desktop entries
with the `Application` type.</doc>
        <source-position filename="gkeyfile.h" line="312" />
        <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
      </constant>
      <constant name="DESKTOP_KEY_TYPE" value="Type" c:type="G_KEY_FILE_DESKTOP_KEY_TYPE" version="2.14" gs:managed-name="DesktopKeyType">
        <doc xml:space="preserve" filename="glib-2.0.c" line="3816">A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a string
giving the type of the desktop entry. Usually
#G_KEY_FILE_DESKTOP_TYPE_APPLICATION,
#G_KEY_FILE_DESKTOP_TYPE_LINK, or
#G_KEY_FILE_DESKTOP_TYPE_DIRECTORY.</doc>
        <source-position filename="gkeyfile.h" line="302" />
        <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
      </constant>
      <constant name="DESKTOP_KEY_URL" value="URL" c:type="G_KEY_FILE_DESKTOP_KEY_URL" version="2.14" gs:managed-name="DesktopKeyUrl">
        <doc xml:space="preserve" filename="glib-2.0.c" line="3829">A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a string
giving the URL to access. It is only valid for desktop entries
with the `Link` type.</doc>
        <source-position filename="gkeyfile.h" line="320" />
        <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
      </constant>
      <constant name="DESKTOP_KEY_VERSION" value="Version" c:type="G_KEY_FILE_DESKTOP_KEY_VERSION" version="2.14" gs:managed-name="DesktopKeyVersion">
        <doc xml:space="preserve" filename="glib-2.0.c" line="3840">A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a string
giving the version of the Desktop Entry Specification used for
the desktop entry file.</doc>
        <source-position filename="gkeyfile.h" line="303" />
        <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
      </constant>
      <constant name="DESKTOP_TYPE_APPLICATION" value="Application" c:type="G_KEY_FILE_DESKTOP_TYPE_APPLICATION" version="2.14" gs:managed-name="DesktopTypeApplication">
        <doc xml:space="preserve" filename="glib-2.0.c" line="3851">The value of the #G_KEY_FILE_DESKTOP_KEY_TYPE, key for desktop
entries representing applications.</doc>
        <source-position filename="gkeyfile.h" line="324" />
        <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
      </constant>
      <constant name="DESKTOP_TYPE_DIRECTORY" value="Directory" c:type="G_KEY_FILE_DESKTOP_TYPE_DIRECTORY" version="2.14" gs:managed-name="DesktopTypeDirectory">
        <doc xml:space="preserve" filename="glib-2.0.c" line="3861">The value of the #G_KEY_FILE_DESKTOP_KEY_TYPE, key for desktop
entries representing directories.</doc>
        <source-position filename="gkeyfile.h" line="326" />
        <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
      </constant>
      <constant name="DESKTOP_TYPE_LINK" value="Link" c:type="G_KEY_FILE_DESKTOP_TYPE_LINK" version="2.14" gs:managed-name="DesktopTypeLink">
        <doc xml:space="preserve" filename="glib-2.0.c" line="3871">The value of the #G_KEY_FILE_DESKTOP_KEY_TYPE, key for desktop
entries representing links to documents.</doc>
        <source-position filename="gkeyfile.h" line="325" />
        <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
      </constant>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_key_file_get_type" gs:access-modifiers="private" gs:dll-name="gobject-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </record>
    <enumeration name="KeyFileError" c:type="GKeyFileError" glib:error-domain="g-key-file-error-quark" gs:managed-name="KeyFileError">
      <doc xml:space="preserve" filename="glib-2.0.c" line="1083">Error codes returned by key file parsing.</doc>
      <source-position filename="gkeyfile.h" line="41" />
      <member name="unknown_encoding" value="0" c:identifier="G_KEY_FILE_ERROR_UNKNOWN_ENCODING" gs:managed-name="UnknownEncoding">
        <doc xml:space="preserve" filename="glib-2.0.c" line="1085">the text being parsed was in
    an unknown encoding</doc>
      </member>
      <member name="parse" value="1" c:identifier="G_KEY_FILE_ERROR_PARSE" gs:managed-name="Parse">
        <doc xml:space="preserve" filename="glib-2.0.c" line="1087">document was ill-formed</doc>
      </member>
      <member name="not_found" value="2" c:identifier="G_KEY_FILE_ERROR_NOT_FOUND" gs:managed-name="NotFound">
        <doc xml:space="preserve" filename="glib-2.0.c" line="1088">the file was not found</doc>
      </member>
      <member name="key_not_found" value="3" c:identifier="G_KEY_FILE_ERROR_KEY_NOT_FOUND" gs:managed-name="KeyNotFound">
        <doc xml:space="preserve" filename="glib-2.0.c" line="1089">a requested key was not found</doc>
      </member>
      <member name="group_not_found" value="4" c:identifier="G_KEY_FILE_ERROR_GROUP_NOT_FOUND" gs:managed-name="GroupNotFound">
        <doc xml:space="preserve" filename="glib-2.0.c" line="1090">a requested group was not found</doc>
      </member>
      <member name="invalid_value" value="5" c:identifier="G_KEY_FILE_ERROR_INVALID_VALUE" gs:managed-name="InvalidValue">
        <doc xml:space="preserve" filename="glib-2.0.c" line="1091">a value could not be parsed</doc>
      </member>
      <gs:managed-property name="get_quark" gs:dll-name="glib-2.0" gs:managed-name="Quark">
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="Quark" c:type="GQuark" gs:managed-name="Quark" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </gs:managed-property>
      <function name="get_quark" c:identifier="g_key_file_error_quark" gs:dll-name="glib-2.0" gs:managed-name="GetQuark" gs:property-getter-for="Quark" gs:access-modifiers="private">
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="Quark" c:type="GQuark" gs:managed-name="Quark" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </enumeration>
    <bitfield name="KeyFileFlags" c:type="GKeyFileFlags" gs:managed-name="KeyFileFlags">
      <doc xml:space="preserve" filename="glib-2.0.c" line="1097">Flags which influence the parsing.</doc>
      <source-position filename="gkeyfile.h" line="55" />
      <member name="none" value="0" c:identifier="G_KEY_FILE_NONE" gs:managed-name="None">
        <doc xml:space="preserve" filename="glib-2.0.c" line="1099">No flags, default behaviour</doc>
      </member>
      <member name="keep_comments" value="1" c:identifier="G_KEY_FILE_KEEP_COMMENTS" gs:managed-name="KeepComments">
        <doc xml:space="preserve" filename="glib-2.0.c" line="1100">Use this flag if you plan to write the
    (possibly modified) contents of the key file back to a file;
    otherwise all comments will be lost when the key file is
    written back.</doc>
      </member>
      <member name="keep_translations" value="2" c:identifier="G_KEY_FILE_KEEP_TRANSLATIONS" gs:managed-name="KeepTranslations">
        <doc xml:space="preserve" filename="glib-2.0.c" line="1104">Use this flag if you plan to write the
    (possibly modified) contents of the key file back to a file;
    otherwise only the translations for the current language will be
    written back.</doc>
      </member>
    </bitfield>
    <record name="LogField" c:type="GLogField" version="2.50" gs:managed-name="LogField">
      <doc xml:space="preserve" filename="gmessages.h" line="140">Structure representing a single field in a structured log entry. See
g_log_structured() for details.

Log fields may contain arbitrary values, including binary with embedded nul
bytes. If the field contains a string, the string must be UTF-8 encoded and
have a trailing nul byte. Otherwise, @length must be set to a non-negative
value.</doc>
      <source-position filename="gmessages.h" line="162" />
      <field name="key" writable="1" gs:managed-name="Key">
        <doc xml:space="preserve" filename="gmessages.h" line="142">field name (UTF-8 string)</doc>
        <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
      </field>
      <field name="value" writable="1" gs:managed-name="Value">
        <doc xml:space="preserve" filename="gmessages.h" line="143">field value (arbitrary bytes)</doc>
        <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
      </field>
      <field name="length" writable="1" gs:managed-name="Length">
        <doc xml:space="preserve" filename="gmessages.h" line="144">length of @value, in bytes, or -1 if it is nul-terminated</doc>
        <type name="gssize" c:type="gssize" gs:managed-name="System.Int32" />
      </field>
    </record>
    <bitfield name="LogLevelFlags" c:type="GLogLevelFlags" gs:managed-name="LogLevelFlags">
      <doc xml:space="preserve" filename="glib-2.0.c" line="1242">Flags specifying the level of log messages.

It is possible to change how GLib treats messages of the various
levels using g_log_set_handler() and g_log_set_fatal_mask().</doc>
      <source-position filename="gmessages.h" line="68" />
      <member name="flag_recursion" value="1" c:identifier="G_LOG_FLAG_RECURSION" gs:managed-name="FlagRecursion">
        <doc xml:space="preserve" filename="glib-2.0.c" line="1244">internal flag</doc>
      </member>
      <member name="flag_fatal" value="2" c:identifier="G_LOG_FLAG_FATAL" gs:managed-name="FlagFatal">
        <doc xml:space="preserve" filename="glib-2.0.c" line="1245">internal flag</doc>
      </member>
      <member name="level_error" value="4" c:identifier="G_LOG_LEVEL_ERROR" gs:managed-name="LevelError">
        <doc xml:space="preserve" filename="glib-2.0.c" line="1246">log level for errors, see g_error().
    This level is also used for messages produced by g_assert().</doc>
      </member>
      <member name="level_critical" value="8" c:identifier="G_LOG_LEVEL_CRITICAL" gs:managed-name="LevelCritical">
        <doc xml:space="preserve" filename="glib-2.0.c" line="1248">log level for critical warning messages, see
    g_critical().
    This level is also used for messages produced by g_return_if_fail()
    and g_return_val_if_fail().</doc>
      </member>
      <member name="level_warning" value="16" c:identifier="G_LOG_LEVEL_WARNING" gs:managed-name="LevelWarning">
        <doc xml:space="preserve" filename="glib-2.0.c" line="1252">log level for warnings, see g_warning()</doc>
      </member>
      <member name="level_message" value="32" c:identifier="G_LOG_LEVEL_MESSAGE" gs:managed-name="LevelMessage">
        <doc xml:space="preserve" filename="glib-2.0.c" line="1253">log level for messages, see g_message()</doc>
      </member>
      <member name="level_info" value="64" c:identifier="G_LOG_LEVEL_INFO" gs:managed-name="LevelInfo">
        <doc xml:space="preserve" filename="glib-2.0.c" line="1254">log level for informational messages, see g_info()</doc>
      </member>
      <member name="level_debug" value="128" c:identifier="G_LOG_LEVEL_DEBUG" gs:managed-name="LevelDebug">
        <doc xml:space="preserve" filename="glib-2.0.c" line="1255">log level for debug messages, see g_debug()</doc>
      </member>
      <member name="level_mask" value="-4" c:identifier="G_LOG_LEVEL_MASK" gs:managed-name="LevelMask">
        <doc xml:space="preserve" filename="glib-2.0.c" line="1256">a mask including all log levels</doc>
      </member>
    </bitfield>
    <callback name="LogWriterFunc" c:type="GLogWriterFunc" version="2.50" gs:dll-name="glib-2.0" gs:managed-name="LogWriterFunc">
      <doc xml:space="preserve" filename="gmessages.h" line="164">Writer function for log entries. A log entry is a collection of one or more
#GLogFields, using the standard [field names from journal
specification](https://www.freedesktop.org/software/systemd/man/systemd.journal-fields.html).
See g_log_structured() for more information.

Writer functions must ignore fields which they do not recognise, unless they
can write arbitrary binary output, as field values may be arbitrary binary.

@log_level is guaranteed to be included in @fields as the `PRIORITY` field,
but is provided separately for convenience of deciding whether or where to
output the log entry.

Writer functions should return %G_LOG_WRITER_HANDLED if they handled the log
message successfully or if they deliberately ignored it. If there was an
error handling the message (for example, if the writer function is meant to
send messages to a remote logging server and there is a network error), it
should return %G_LOG_WRITER_UNHANDLED. This allows writer functions to be
chained and fall back to simpler handlers in case of failure.</doc>
      <source-position filename="gmessages.h" line="194" />
      <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
        <doc xml:space="preserve" filename="gmessages.h" line="190">%G_LOG_WRITER_HANDLED if the log entry was handled successfully;
   %G_LOG_WRITER_UNHANDLED otherwise</doc>
        <type name="LogWriterOutput" c:type="GLogWriterOutput" gs:managed-name="LogWriterOutput" />
      </return-value>
      <parameters>
        <parameter name="log_level" transfer-ownership="none" gs:managed-name="logLevel" direction="in">
          <doc xml:space="preserve" filename="gmessages.h" line="166">log level of the message</doc>
          <type name="LogLevelFlags" c:type="GLogLevelFlags" gs:managed-name="LogLevelFlags" />
        </parameter>
        <parameter name="fields" transfer-ownership="none" gs:managed-name="fields" direction="in">
          <doc xml:space="preserve" filename="gmessages.h" line="167">fields forming the message</doc>
          <array length="2" zero-terminated="0" c:type="const GLogField*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
            <type name="LogField" c:type="GLogField" gs:managed-name="LogField" />
          </array>
        </parameter>
        <parameter name="n_fields" transfer-ownership="none" gs:managed-name="nFields" direction="in">
          <doc xml:space="preserve" filename="gmessages.h" line="168">number of @fields</doc>
          <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3" gs:managed-name="userData" direction="in">
          <doc xml:space="preserve" filename="gmessages.h" line="169">user data passed to g_log_set_writer_func()</doc>
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </parameter>
      </parameters>
      <gs:managed-parameters>
        <parameter name="log_level" transfer-ownership="none" gs:managed-name="logLevel" direction="in">
          <doc xml:space="preserve" filename="gmessages.h" line="166">log level of the message</doc>
          <type name="LogLevelFlags" c:type="GLogLevelFlags" gs:managed-name="LogLevelFlags" />
        </parameter>
        <parameter name="fields" transfer-ownership="none" gs:managed-name="fields" direction="in">
          <doc xml:space="preserve" filename="gmessages.h" line="167">fields forming the message</doc>
          <array length="2" zero-terminated="0" c:type="const GLogField*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
            <type name="LogField" c:type="GLogField" gs:managed-name="LogField" />
          </array>
        </parameter>
      </gs:managed-parameters>
    </callback>
    <enumeration name="LogWriterOutput" version="2.50" c:type="GLogWriterOutput" gs:managed-name="LogWriterOutput">
      <doc xml:space="preserve" filename="gmessages.h" line="120">Return values from #GLogWriterFuncs to indicate whether the given log entry
was successfully handled by the writer, or whether there was an error in
handling it (and hence a fallback writer should be used).

If a #GLogWriterFunc ignores a log entry, it should return
%G_LOG_WRITER_HANDLED.</doc>
      <source-position filename="gmessages.h" line="138" />
      <member name="handled" value="1" c:identifier="G_LOG_WRITER_HANDLED" gs:managed-name="Handled">
        <doc xml:space="preserve" filename="gmessages.h" line="122">Log writer has handled the log entry.</doc>
      </member>
      <member name="unhandled" value="0" c:identifier="G_LOG_WRITER_UNHANDLED" gs:managed-name="Unhandled">
        <doc xml:space="preserve" filename="gmessages.h" line="123">Log writer could not handle the log entry.</doc>
      </member>
    </enumeration>
    <record name="MainContext" c:type="GMainContext" glib:type-name="GMainContext" glib:get-type="g_main_context_get_type" c:symbol-prefix="main_context" gs:managed-name="MainContext">
      <doc xml:space="preserve" filename="gmain.h" line="42">The `GMainContext` struct is an opaque data
type representing a set of sources to be handled in a main loop.</doc>
      <source-position filename="gmain.h" line="48" />
      <constructor name="new" c:identifier="g_main_context_new" gs:dll-name="glib-2.0" gs:managed-name="New">
        <doc xml:space="preserve" filename="glib-2.0.c" line="22106">Creates a new #GMainContext structure.</doc>
        <source-position filename="gmain.h" line="356" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="22111">the new #GMainContext</doc>
          <type name="MainContext" c:type="GMainContext*" gs:managed-name="MainContext" gs:is-pointer="1" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </constructor>
      <method name="acquire" c:identifier="g_main_context_acquire" gs:dll-name="glib-2.0" gs:managed-name="Acquire">
        <doc xml:space="preserve" filename="glib-2.0.c" line="21861">Tries to become the owner of the specified context.
If some other thread is the owner of the context,
returns %FALSE immediately. Ownership is properly
recursive: the owner can require ownership again
and will release ownership when g_main_context_release()
is called as many times as g_main_context_acquire().

You must be the owner of a context before you
can call g_main_context_prepare(), g_main_context_query(),
g_main_context_check(), g_main_context_dispatch().</doc>
        <source-position filename="gmain.h" line="388" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="21876">%TRUE if the operation succeeded, and
  this thread is now the owner of @context.</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" gs:managed-name="context" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21863">a #GMainContext</doc>
            <type name="MainContext" c:type="GMainContext*" gs:managed-name="MainContext" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="add_poll" c:identifier="g_main_context_add_poll" gs:dll-name="glib-2.0" gs:managed-name="AddPoll">
        <doc xml:space="preserve" filename="glib-2.0.c" line="21881">Adds a file descriptor to the set of file descriptors polled for
this context. This will very seldom be used directly. Instead
a typical event source will use g_source_add_unix_fd() instead.</doc>
        <source-position filename="gmain.h" line="424" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="context" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21883">a #GMainContext (or %NULL for the default context)</doc>
            <type name="MainContext" c:type="GMainContext*" gs:managed-name="MainContext" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="fd" transfer-ownership="none" gs:managed-name="fd" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21884">a #GPollFD structure holding information about a file
     descriptor to watch.</doc>
            <type name="PollFD" c:type="GPollFD*" gs:managed-name="PollFD" gs:is-pointer="1" />
          </parameter>
          <parameter name="priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="priority" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21886">the priority for this file descriptor which should be
     the same as the priority used for g_source_attach() to ensure that the
     file descriptor is polled whenever the results may be needed.</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="fd" transfer-ownership="none" gs:managed-name="fd" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21884">a #GPollFD structure holding information about a file
     descriptor to watch.</doc>
            <type name="PollFD" c:type="GPollFD*" gs:managed-name="PollFD" gs:is-pointer="1" />
          </parameter>
          <parameter name="priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="priority" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21886">the priority for this file descriptor which should be
     the same as the priority used for g_source_attach() to ensure that the
     file descriptor is polled whenever the results may be needed.</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="check" c:identifier="g_main_context_check" gs:dll-name="glib-2.0" gs:managed-name="Check">
        <doc xml:space="preserve" filename="glib-2.0.c" line="21896">Passes the results of polling back to the main loop.

You must have successfully acquired the context with
g_main_context_acquire() before you may call this function.</doc>
        <source-position filename="gmain.h" line="408" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="21909">%TRUE if some sources are ready to be dispatched.</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" gs:managed-name="context" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21898">a #GMainContext</doc>
            <type name="MainContext" c:type="GMainContext*" gs:managed-name="MainContext" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="max_priority" transfer-ownership="none" gs:managed-name="maxPriority" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21899">the maximum numerical priority of sources to check</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="fds" transfer-ownership="none" gs:managed-name="fds" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21900">array of #GPollFD's that was passed to
      the last call to g_main_context_query()</doc>
            <array length="2" zero-terminated="0" c:type="GPollFD*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="PollFD" c:type="GPollFD" gs:managed-name="PollFD" />
            </array>
          </parameter>
          <parameter name="n_fds" transfer-ownership="none" gs:managed-name="nFds" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21902">return value of g_main_context_query()</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="max_priority" transfer-ownership="none" gs:managed-name="maxPriority" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21899">the maximum numerical priority of sources to check</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="fds" transfer-ownership="none" gs:managed-name="fds" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21900">array of #GPollFD's that was passed to
      the last call to g_main_context_query()</doc>
            <array length="2" zero-terminated="0" c:type="GPollFD*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="PollFD" c:type="GPollFD" gs:managed-name="PollFD" />
            </array>
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="dispatch" c:identifier="g_main_context_dispatch" gs:dll-name="glib-2.0" gs:managed-name="Dispatch">
        <doc xml:space="preserve" filename="glib-2.0.c" line="21925">Dispatches all pending sources.

You must have successfully acquired the context with
g_main_context_acquire() before you may call this function.</doc>
        <source-position filename="gmain.h" line="413" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" gs:managed-name="context" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21927">a #GMainContext</doc>
            <type name="MainContext" c:type="GMainContext*" gs:managed-name="MainContext" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="find_source_by_funcs_user_data" c:identifier="g_main_context_find_source_by_funcs_user_data" gs:dll-name="glib-2.0" gs:managed-name="FindSourceByFuncsUserData">
        <doc xml:space="preserve" filename="glib-2.0.c" line="21936">Finds a source with the given source functions and user data.  If
multiple sources exist with the same source function and user data,
the first one found will be returned.</doc>
        <source-position filename="gmain.h" line="379" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="21946">the source, if one was found, otherwise %NULL</doc>
          <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="context" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21938">a #GMainContext (if %NULL, the default context will be used).</doc>
            <type name="MainContext" c:type="GMainContext*" gs:managed-name="MainContext" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="funcs" transfer-ownership="none" gs:managed-name="funcs" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21939">the @source_funcs passed to g_source_new().</doc>
            <type name="SourceFuncs" c:type="GSourceFuncs*" gs:managed-name="SourceFuncs" gs:is-pointer="1" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21940">the user data from the callback.</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="funcs" transfer-ownership="none" gs:managed-name="funcs" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21939">the @source_funcs passed to g_source_new().</doc>
            <type name="SourceFuncs" c:type="GSourceFuncs*" gs:managed-name="SourceFuncs" gs:is-pointer="1" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21940">the user data from the callback.</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="find_source_by_id" c:identifier="g_main_context_find_source_by_id" gs:dll-name="glib-2.0" gs:managed-name="FindSourceById">
        <doc xml:space="preserve" filename="glib-2.0.c" line="21950">Finds a #GSource given a pair of context and ID.

It is a programmer error to attempt to look up a non-existent source.

More specifically: source IDs can be reissued after a source has been
destroyed and therefore it is never valid to use this function with a
source ID which may have already been removed.  An example is when
scheduling an idle to run in another thread with g_idle_add(): the
idle may already have run and been removed by the time this function
is called on its (now invalid) source ID.  This source ID may have
been reissued, leading to the operation being performed against the
wrong source.</doc>
        <source-position filename="gmain.h" line="373" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="21968">the #GSource</doc>
          <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="context" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21952">a #GMainContext (if %NULL, the default context will be used)</doc>
            <type name="MainContext" c:type="GMainContext*" gs:managed-name="MainContext" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="source_id" transfer-ownership="none" gs:managed-name="sourceId" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21953">the source ID, as returned by g_source_get_id().</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="source_id" transfer-ownership="none" gs:managed-name="sourceId" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21953">the source ID, as returned by g_source_get_id().</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="find_source_by_user_data" c:identifier="g_main_context_find_source_by_user_data" gs:dll-name="glib-2.0" gs:managed-name="FindSourceByUserData">
        <doc xml:space="preserve" filename="glib-2.0.c" line="21972">Finds a source with the given user data for the callback.  If
multiple sources exist with the same user data, the first
one found will be returned.</doc>
        <source-position filename="gmain.h" line="376" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="21981">the source, if one was found, otherwise %NULL</doc>
          <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" gs:managed-name="context" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21974">a #GMainContext</doc>
            <type name="MainContext" c:type="GMainContext*" gs:managed-name="MainContext" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21975">the user_data for the callback.</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21975">the user_data for the callback.</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="invoke_full" c:identifier="g_main_context_invoke_full" version="2.28" shadows="invoke" gs:dll-name="glib-2.0" gs:managed-name="Invoke">
        <doc xml:space="preserve" filename="glib-2.0.c" line="22048">Invokes a function in such a way that @context is owned during the
invocation of @function.

This function is the same as g_main_context_invoke() except that it
lets you specify the priority in case @function ends up being
scheduled as an idle and also lets you give a #GDestroyNotify for @data.

@notify should not assume that it is called from any particular
thread or with any particular context acquired.</doc>
        <source-position filename="gmain.h" line="774" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="context" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="22050">a #GMainContext, or %NULL</doc>
            <type name="MainContext" c:type="GMainContext*" gs:managed-name="MainContext" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="priority" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="22051">the priority at which to run @function</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="function" transfer-ownership="none" scope="notified" closure="2" destroy="3" gs:managed-name="function" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="22052">function to call</doc>
            <type name="SourceFunc" c:type="GSourceFunc" gs:managed-name="SourceFunc" />
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="22053">data to pass to @function</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
          <parameter name="notify" transfer-ownership="none" nullable="1" allow-none="1" scope="async" gs:managed-name="notify" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="22054">a function to call when @data is no longer in use, or %NULL.</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify" gs:managed-name="DestroyNotify" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="function" transfer-ownership="none" scope="notified" closure="2" destroy="3" gs:managed-name="function" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="22052">function to call</doc>
            <type name="SourceFunc" c:type="GSourceFunc" gs:managed-name="SourceFunc" />
          </parameter>
          <parameter name="priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="priority" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="22051">the priority at which to run @function</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <gs:managed-property name="is_owner" version="2.10" gs:dll-name="glib-2.0" gs:managed-name="IsOwner">
        <doc xml:space="preserve" filename="glib-2.0.c" line="22070">Determines whether this thread holds the (recursive)
ownership of this #GMainContext. This is useful to
know before waiting on another thread that may be
blocking to get ownership of @context.</doc>
        <source-position filename="gmain.h" line="392" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="22079">%TRUE if current thread is owner of @context.</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" gs:managed-name="context" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="22072">a #GMainContext</doc>
            <type name="MainContext" c:type="GMainContext*" gs:managed-name="MainContext" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="is_owner" c:identifier="g_main_context_is_owner" version="2.10" gs:dll-name="glib-2.0" gs:managed-name="GetIsOwner" gs:property-getter-for="IsOwner" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="22070">Determines whether this thread holds the (recursive)
ownership of this #GMainContext. This is useful to
know before waiting on another thread that may be
blocking to get ownership of @context.</doc>
        <source-position filename="gmain.h" line="392" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="22079">%TRUE if current thread is owner of @context.</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" gs:managed-name="context" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="22072">a #GMainContext</doc>
            <type name="MainContext" c:type="GMainContext*" gs:managed-name="MainContext" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="iteration" c:identifier="g_main_context_iteration" gs:dll-name="glib-2.0" gs:managed-name="Iteration">
        <doc xml:space="preserve" filename="glib-2.0.c" line="22084">Runs a single iteration for the given main loop. This involves
checking to see if any event sources are ready to be processed,
then if no events sources are ready and @may_block is %TRUE, waiting
for a source to become ready, then dispatching the highest priority
events sources that are ready. Otherwise, if @may_block is %FALSE
sources are not waited to become ready, only those highest priority
events sources will be dispatched (if any), that are ready at this
given moment without further waiting.

Note that even when @may_block is %TRUE, it is still possible for
g_main_context_iteration() to return %FALSE, since the wait may
be interrupted for other reasons than an event source becoming ready.</doc>
        <source-position filename="gmain.h" line="365" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="22102">%TRUE if events were dispatched.</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="context" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="22086">a #GMainContext (if %NULL, the default context will be used)</doc>
            <type name="MainContext" c:type="GMainContext*" gs:managed-name="MainContext" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="may_block" transfer-ownership="none" gs:managed-name="mayBlock" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="22087">whether the call may block.</doc>
            <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="may_block" transfer-ownership="none" gs:managed-name="mayBlock" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="22087">whether the call may block.</doc>
            <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <gs:managed-property name="is_pending" gs:dll-name="glib-2.0" gs:managed-name="IsPending">
        <doc xml:space="preserve" filename="glib-2.0.c" line="22115">Checks if any sources have pending events for the given context.</doc>
        <source-position filename="gmain.h" line="368" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="22121">%TRUE if events are pending.</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="context" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="22117">a #GMainContext (if %NULL, the default context will be used)</doc>
            <type name="MainContext" c:type="GMainContext*" gs:managed-name="MainContext" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="is_pending" c:identifier="g_main_context_pending" gs:dll-name="glib-2.0" gs:managed-name="GetIsPending" gs:property-getter-for="IsPending" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="22115">Checks if any sources have pending events for the given context.</doc>
        <source-position filename="gmain.h" line="368" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="22121">%TRUE if events are pending.</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="context" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="22117">a #GMainContext (if %NULL, the default context will be used)</doc>
            <type name="MainContext" c:type="GMainContext*" gs:managed-name="MainContext" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="pop_thread_default" c:identifier="g_main_context_pop_thread_default" version="2.22" gs:dll-name="glib-2.0" gs:managed-name="PopThreadDefault">
        <doc xml:space="preserve" filename="glib-2.0.c" line="22125">Pops @context off the thread-default context stack (verifying that
it was on the top of the stack).</doc>
        <source-position filename="gmain.h" line="441" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="context" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="22127">a #GMainContext object, or %NULL</doc>
            <type name="MainContext" c:type="GMainContext*" gs:managed-name="MainContext" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="prepare" c:identifier="g_main_context_prepare" gs:dll-name="glib-2.0" gs:managed-name="TryPrepare">
        <doc xml:space="preserve" filename="glib-2.0.c" line="22136">Prepares to poll sources within a main loop. The resulting information
for polling is determined by calling g_main_context_query ().

You must have successfully acquired the context with
g_main_context_acquire() before you may call this function.</doc>
        <source-position filename="gmain.h" line="399" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="22148">%TRUE if some source is ready to be dispatched
              prior to polling.</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" gs:managed-name="context" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="22138">a #GMainContext</doc>
            <type name="MainContext" c:type="GMainContext*" gs:managed-name="MainContext" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="priority" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="priority">
            <doc xml:space="preserve" filename="glib-2.0.c" line="22139">location to store priority of highest priority
           source already ready.</doc>
            <type name="gint" c:type="gint*" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="priority" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="priority">
            <doc xml:space="preserve" filename="glib-2.0.c" line="22139">location to store priority of highest priority
           source already ready.</doc>
            <type name="gint" c:type="gint*" gs:managed-name="System.Int32" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="push_thread_default" c:identifier="g_main_context_push_thread_default" version="2.22" gs:dll-name="glib-2.0" gs:managed-name="PushThreadDefault">
        <doc xml:space="preserve" filename="glib-2.0.c" line="22153">Acquires @context and sets it as the thread-default context for the
current thread. This will cause certain asynchronous operations
(such as most [gio][gio]-based I/O) which are
started in this thread to run under @context and deliver their
results to its main loop, rather than running under the global
default context in the main thread. Note that calling this function
changes the context returned by g_main_context_get_thread_default(),
not the one returned by g_main_context_default(), so it does not affect
the context used by functions like g_idle_add().

Normally you would call this function shortly after creating a new
thread, passing it a #GMainContext which will be run by a
#GMainLoop in that thread, to set a new default context for all
async operations in that thread. In this case you may not need to
ever call g_main_context_pop_thread_default(), assuming you want the
new #GMainContext to be the default for the whole lifecycle of the
thread.

If you don't have control over how the new thread was created (e.g.
in the new thread isn't newly created, or if the thread life
cycle is managed by a #GThreadPool), it is always suggested to wrap
the logic that needs to use the new #GMainContext inside a
g_main_context_push_thread_default() / g_main_context_pop_thread_default()
pair, otherwise threads that are re-used will end up never explicitly
releasing the #GMainContext reference they hold.

In some cases you may want to schedule a single operation in a
non-default context, or temporarily use a non-default context in
the main thread. In that case, you can wrap the call to the
asynchronous operation inside a
g_main_context_push_thread_default() /
g_main_context_pop_thread_default() pair, but it is up to you to
ensure that no other asynchronous operations accidentally get
started while the non-default context is active.

Beware that libraries that predate this function may not correctly
handle being used from a thread with a thread-default context. Eg,
see g_file_supports_thread_contexts().</doc>
        <source-position filename="gmain.h" line="439" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="context" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="22155">a #GMainContext, or %NULL for the global default context</doc>
            <type name="MainContext" c:type="GMainContext*" gs:managed-name="MainContext" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="query" c:identifier="g_main_context_query" gs:dll-name="glib-2.0" gs:managed-name="Query">
        <doc xml:space="preserve" filename="glib-2.0.c" line="22200">Determines information necessary to poll this main loop.

You must have successfully acquired the context with
g_main_context_acquire() before you may call this function.</doc>
        <source-position filename="gmain.h" line="402" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="22214">the number of records actually stored in @fds,
  or, if more than @n_fds records need to be stored, the number
  of records that need to be stored.</doc>
          <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" gs:managed-name="context" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="22202">a #GMainContext</doc>
            <type name="MainContext" c:type="GMainContext*" gs:managed-name="MainContext" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="max_priority" transfer-ownership="none" gs:managed-name="maxPriority" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="22203">maximum priority source to check</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="timeout_" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="timeout">
            <doc xml:space="preserve" filename="glib-2.0.c" line="22204">location to store timeout to be used in polling</doc>
            <type name="gint" c:type="gint*" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="fds" direction="out" caller-allocates="1" transfer-ownership="none" gs:managed-name="fds">
            <doc xml:space="preserve" filename="glib-2.0.c" line="22205">location to
      store #GPollFD records that need to be polled.</doc>
            <array length="3" zero-terminated="0" c:type="GPollFD*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="PollFD" c:type="GPollFD" gs:managed-name="PollFD" />
            </array>
          </parameter>
          <parameter name="n_fds" transfer-ownership="none" gs:managed-name="nFds" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="22207">length of @fds.</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="max_priority" transfer-ownership="none" gs:managed-name="maxPriority" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="22203">maximum priority source to check</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="timeout_" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="timeout">
            <doc xml:space="preserve" filename="glib-2.0.c" line="22204">location to store timeout to be used in polling</doc>
            <type name="gint" c:type="gint*" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="fds" direction="out" caller-allocates="1" transfer-ownership="none" gs:managed-name="fds">
            <doc xml:space="preserve" filename="glib-2.0.c" line="22205">location to
      store #GPollFD records that need to be polled.</doc>
            <array length="3" zero-terminated="0" c:type="GPollFD*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="PollFD" c:type="GPollFD" gs:managed-name="PollFD" />
            </array>
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="ref" c:identifier="g_main_context_ref" gs:dll-name="glib-2.0" gs:managed-name="Ref" gs:special-func="ref" gs:pinvoke-only="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="22220">Increases the reference count on a #GMainContext object by one.</doc>
        <source-position filename="gmain.h" line="358" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="22226">the @context that was passed in (since 2.6)</doc>
          <type name="MainContext" c:type="GMainContext*" gs:managed-name="MainContext" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" gs:managed-name="context" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="22222">a #GMainContext</doc>
            <type name="MainContext" c:type="GMainContext*" gs:managed-name="MainContext" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="release" c:identifier="g_main_context_release" gs:dll-name="glib-2.0" gs:managed-name="Release">
        <doc xml:space="preserve" filename="glib-2.0.c" line="22246">Releases ownership of a context previously acquired by this thread
with g_main_context_acquire(). If the context was acquired multiple
times, the ownership will be released only when g_main_context_release()
is called as many times as it was acquired.</doc>
        <source-position filename="gmain.h" line="390" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" gs:managed-name="context" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="22248">a #GMainContext</doc>
            <type name="MainContext" c:type="GMainContext*" gs:managed-name="MainContext" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="remove_poll" c:identifier="g_main_context_remove_poll" gs:dll-name="glib-2.0" gs:managed-name="RemovePoll">
        <doc xml:space="preserve" filename="glib-2.0.c" line="22257">Removes file descriptor from the set of file descriptors to be
polled for a particular context.</doc>
        <source-position filename="gmain.h" line="428" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" gs:managed-name="context" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="22259">a #GMainContext</doc>
            <type name="MainContext" c:type="GMainContext*" gs:managed-name="MainContext" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="fd" transfer-ownership="none" gs:managed-name="fd" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="22260">a #GPollFD descriptor previously added with g_main_context_add_poll()</doc>
            <type name="PollFD" c:type="GPollFD*" gs:managed-name="PollFD" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="fd" transfer-ownership="none" gs:managed-name="fd" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="22260">a #GPollFD descriptor previously added with g_main_context_add_poll()</doc>
            <type name="PollFD" c:type="GPollFD*" gs:managed-name="PollFD" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="unref" c:identifier="g_main_context_unref" gs:dll-name="glib-2.0" gs:managed-name="Unref" gs:special-func="unref" gs:pinvoke-only="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="22282">Decreases the reference count on a #GMainContext object by one. If
the result is zero, free the context and free all associated memory.</doc>
        <source-position filename="gmain.h" line="360" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" gs:managed-name="context" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="22284">a #GMainContext</doc>
            <type name="MainContext" c:type="GMainContext*" gs:managed-name="MainContext" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="wake_up" c:identifier="g_main_context_wakeup" gs:dll-name="glib-2.0" gs:managed-name="WakeUp">
        <doc xml:space="preserve" filename="glib-2.0.c" line="22309">If @context is currently blocking in g_main_context_iteration()
waiting for a source to become ready, cause it to stop blocking
and return.  Otherwise, cause the next invocation of
g_main_context_iteration() to return without blocking.

This API is useful for low-level control over #GMainContext; for
example, integrating it with main loop implementations such as
#GMainLoop.

Another related use for this function is when implementing a main
loop with a termination condition, computed from multiple threads:

|[&lt;!-- language="C" --&gt;
  #define NUM_TASKS 10
  static volatile gint tasks_remaining = NUM_TASKS;
  ...
 
  while (g_atomic_int_get (&amp;tasks_remaining) != 0)
    g_main_context_iteration (NULL, TRUE);
]|
 
Then in a thread:
|[&lt;!-- language="C" --&gt;
  perform_work();

  if (g_atomic_int_dec_and_test (&amp;tasks_remaining))
    g_main_context_wakeup (NULL);
]|</doc>
        <source-position filename="gmain.h" line="386" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" gs:managed-name="context" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="22311">a #GMainContext</doc>
            <type name="MainContext" c:type="GMainContext*" gs:managed-name="MainContext" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_default" gs:dll-name="glib-2.0" gs:managed-name="Default">
        <doc xml:space="preserve" filename="glib-2.0.c" line="21913">Returns the global default main context. This is the main context
used for main loop functions when a main loop is not explicitly
specified, and corresponds to the "main" main loop. See also
g_main_context_get_thread_default().</doc>
        <source-position filename="gmain.h" line="362" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="21921">the global default main context.</doc>
          <type name="MainContext" c:type="GMainContext*" gs:managed-name="MainContext" gs:is-pointer="1" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </gs:managed-property>
      <function name="get_default" c:identifier="g_main_context_default" gs:dll-name="glib-2.0" gs:managed-name="GetDefault" gs:property-getter-for="Default" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="21913">Returns the global default main context. This is the main context
used for main loop functions when a main loop is not explicitly
specified, and corresponds to the "main" main loop. See also
g_main_context_get_thread_default().</doc>
        <source-position filename="gmain.h" line="362" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="21921">the global default main context.</doc>
          <type name="MainContext" c:type="GMainContext*" gs:managed-name="MainContext" gs:is-pointer="1" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
      <gs:managed-property name="get_thread_default" version="2.32" gs:dll-name="glib-2.0" gs:managed-name="ThreadDefault">
        <doc xml:space="preserve" filename="glib-2.0.c" line="22230">Gets the thread-default #GMainContext for this thread, as with
g_main_context_get_thread_default(), but also adds a reference to
it with g_main_context_ref(). In addition, unlike
g_main_context_get_thread_default(), if the thread-default context
is the global default context, this will return that #GMainContext
(with a ref added to it) rather than returning %NULL.</doc>
        <source-position filename="gmain.h" line="445" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="22240">the thread-default #GMainContext. Unref
    with g_main_context_unref() when you are done with it.</doc>
          <type name="MainContext" c:type="GMainContext*" gs:managed-name="MainContext" gs:is-pointer="1" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </gs:managed-property>
      <function name="get_thread_default" c:identifier="g_main_context_ref_thread_default" version="2.32" gs:dll-name="glib-2.0" gs:managed-name="GetThreadDefault" gs:property-getter-for="ThreadDefault" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="22230">Gets the thread-default #GMainContext for this thread, as with
g_main_context_get_thread_default(), but also adds a reference to
it with g_main_context_ref(). In addition, unlike
g_main_context_get_thread_default(), if the thread-default context
is the global default context, this will return that #GMainContext
(with a ref added to it) rather than returning %NULL.</doc>
        <source-position filename="gmain.h" line="445" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="22240">the thread-default #GMainContext. Unref
    with g_main_context_unref() when you are done with it.</doc>
          <type name="MainContext" c:type="GMainContext*" gs:managed-name="MainContext" gs:is-pointer="1" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
      <gs:managed-property name="get_depth" gs:dll-name="glib-2.0" gs:managed-name="Depth">
        <doc xml:space="preserve" filename="glib-2.0.c" line="22354">Returns the depth of the stack of calls to
g_main_context_dispatch() on any #GMainContext in the current thread.
 That is, when called from the toplevel, it gives 0. When
called from within a callback from g_main_context_iteration()
(or g_main_loop_run(), etc.) it returns 1. When called from within
a callback to a recursive call to g_main_context_iteration(),
it returns 2. And so forth.

This function is useful in a situation like the following:
Imagine an extremely simple "garbage collected" system.

|[&lt;!-- language="C" --&gt;
static GList *free_list;

gpointer
allocate_memory (gsize size)
{
  gpointer result = g_malloc (size);
  free_list = g_list_prepend (free_list, result);
  return result;
}

void
free_allocated_memory (void)
{
  GList *l;
  for (l = free_list; l; l = l-&gt;next);
    g_free (l-&gt;data);
  g_list_free (free_list);
  free_list = NULL;
 }

[...]

while (TRUE);
 {
   g_main_context_iteration (NULL, TRUE);
   free_allocated_memory();
  }
]|

This works from an application, however, if you want to do the same
thing from a library, it gets more difficult, since you no longer
control the main loop. You might think you can simply use an idle
function to make the call to free_allocated_memory(), but that
doesn't work, since the idle function could be called from a
recursive callback. This can be fixed by using g_main_depth()

|[&lt;!-- language="C" --&gt;
gpointer
allocate_memory (gsize size)
{
  FreeListBlock *block = g_new (FreeListBlock, 1);
  block-&gt;mem = g_malloc (size);
  block-&gt;depth = g_main_depth ();
  free_list = g_list_prepend (free_list, block);
  return block-&gt;mem;
}

void
free_allocated_memory (void)
{
  GList *l;
  
  int depth = g_main_depth ();
  for (l = free_list; l; );
    {
      GList *next = l-&gt;next;
      FreeListBlock *block = l-&gt;data;
      if (block-&gt;depth &gt; depth)
        {
          g_free (block-&gt;mem);
          g_free (block);
          free_list = g_list_delete_link (free_list, l);
        }
              
      l = next;
    }
  }
]|

There is a temptation to use g_main_depth() to solve
problems with reentrancy. For instance, while waiting for data
to be received from the network in response to a menu item,
the menu item might be selected again. It might seem that
one could make the menu item's callback return immediately
and do nothing if g_main_depth() returns a value greater than 1.
However, this should be avoided since the user then sees selecting
the menu item do nothing. Furthermore, you'll find yourself adding
these checks all over your code, since there are doubtless many,
many things that the user could do. Instead, you can use the
following techniques:

1. Use gtk_widget_set_sensitive() or modal dialogs to prevent
   the user from interacting with elements while the main
   loop is recursing.

2. Avoid main loop recursion in situations where you can't handle
   arbitrary  callbacks. Instead, structure your code so that you
   simply return to the main loop and then get called again when
   there is more work to do.</doc>
        <source-position filename="gmain.h" line="432" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="22459">The main loop recursion level in the current thread</doc>
          <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </gs:managed-property>
      <function name="get_depth" c:identifier="g_main_depth" gs:dll-name="glib-2.0" gs:managed-name="GetDepth" gs:property-getter-for="Depth" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="22354">Returns the depth of the stack of calls to
g_main_context_dispatch() on any #GMainContext in the current thread.
 That is, when called from the toplevel, it gives 0. When
called from within a callback from g_main_context_iteration()
(or g_main_loop_run(), etc.) it returns 1. When called from within
a callback to a recursive call to g_main_context_iteration(),
it returns 2. And so forth.

This function is useful in a situation like the following:
Imagine an extremely simple "garbage collected" system.

|[&lt;!-- language="C" --&gt;
static GList *free_list;

gpointer
allocate_memory (gsize size)
{
  gpointer result = g_malloc (size);
  free_list = g_list_prepend (free_list, result);
  return result;
}

void
free_allocated_memory (void)
{
  GList *l;
  for (l = free_list; l; l = l-&gt;next);
    g_free (l-&gt;data);
  g_list_free (free_list);
  free_list = NULL;
 }

[...]

while (TRUE);
 {
   g_main_context_iteration (NULL, TRUE);
   free_allocated_memory();
  }
]|

This works from an application, however, if you want to do the same
thing from a library, it gets more difficult, since you no longer
control the main loop. You might think you can simply use an idle
function to make the call to free_allocated_memory(), but that
doesn't work, since the idle function could be called from a
recursive callback. This can be fixed by using g_main_depth()

|[&lt;!-- language="C" --&gt;
gpointer
allocate_memory (gsize size)
{
  FreeListBlock *block = g_new (FreeListBlock, 1);
  block-&gt;mem = g_malloc (size);
  block-&gt;depth = g_main_depth ();
  free_list = g_list_prepend (free_list, block);
  return block-&gt;mem;
}

void
free_allocated_memory (void)
{
  GList *l;
  
  int depth = g_main_depth ();
  for (l = free_list; l; );
    {
      GList *next = l-&gt;next;
      FreeListBlock *block = l-&gt;data;
      if (block-&gt;depth &gt; depth)
        {
          g_free (block-&gt;mem);
          g_free (block);
          free_list = g_list_delete_link (free_list, l);
        }
              
      l = next;
    }
  }
]|

There is a temptation to use g_main_depth() to solve
problems with reentrancy. For instance, while waiting for data
to be received from the network in response to a menu item,
the menu item might be selected again. It might seem that
one could make the menu item's callback return immediately
and do nothing if g_main_depth() returns a value greater than 1.
However, this should be avoided since the user then sees selecting
the menu item do nothing. Furthermore, you'll find yourself adding
these checks all over your code, since there are doubtless many,
many things that the user could do. Instead, you can use the
following techniques:

1. Use gtk_widget_set_sensitive() or modal dialogs to prevent
   the user from interacting with elements while the main
   loop is recursing.

2. Avoid main loop recursion in situations where you can't handle
   arbitrary  callbacks. Instead, structure your code so that you
   simply return to the main loop and then get called again when
   there is more work to do.</doc>
        <source-position filename="gmain.h" line="432" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="22459">The main loop recursion level in the current thread</doc>
          <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
      <function name="poll" c:identifier="g_poll" version="2.20" gs:dll-name="glib-2.0" gs:managed-name="Poll">
        <doc xml:space="preserve" filename="glib-2.0.c" line="25055">Polls @fds, as with the poll() system call, but portably. (On
systems that don't have poll(), it is emulated using select().)
This is used internally by #GMainContext, but it can be called
directly if you need to block until a file descriptor is ready, but
don't want to run the full main loop.

Each element of @fds is a #GPollFD describing a single file
descriptor to poll. The @fd field indicates the file descriptor,
and the @events field indicates the events to poll for. On return,
the @revents fields will be filled with the events that actually
occurred.

On POSIX systems, the file descriptors in @fds can be any sort of
file descriptor, but the situation is much more complicated on
Windows. If you need to use g_poll() in code that has to run on
Windows, the easiest solution is to construct all of your
#GPollFDs with g_io_channel_win32_make_pollfd().</doc>
        <source-position filename="gpoll.h" line="114" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="25079">the number of entries in @fds whose @revents fields
were filled in, or 0 if the operation timed out, or -1 on error or
if the call was interrupted.</doc>
          <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <parameter name="fds" transfer-ownership="none" gs:managed-name="fds" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25057">file descriptors to poll</doc>
            <array c:type="GPollFD*" length="1" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="PollFD" c:type="GPollFD" gs:managed-name="PollFD" />
            </array>
          </parameter>
          <parameter name="nfds" transfer-ownership="none" gs:managed-name="nfds" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25058">the number of file descriptors in @fds</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
          <parameter name="timeout" transfer-ownership="none" gs:default="-1" gs:managed-name="timeout" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25059">amount of time to wait, in milliseconds, or -1 to wait forever</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="fds" transfer-ownership="none" gs:managed-name="fds" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25057">file descriptors to poll</doc>
            <array c:type="GPollFD*" length="1" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="PollFD" c:type="GPollFD" gs:managed-name="PollFD" />
            </array>
          </parameter>
          <parameter name="timeout" transfer-ownership="none" gs:default="-1" gs:managed-name="timeout" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25059">amount of time to wait, in milliseconds, or -1 to wait forever</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_main_context_get_type" gs:access-modifiers="private" gs:dll-name="gobject-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </record>
    <record name="MainLoop" c:type="GMainLoop" glib:type-name="GMainLoop" glib:get-type="g_main_loop_get_type" c:symbol-prefix="main_loop" gs:managed-name="MainLoop">
      <doc xml:space="preserve" filename="gmain.h" line="50">The `GMainLoop` struct is an opaque data type
representing the main event loop of a GLib or GTK+ application.</doc>
      <source-position filename="gmain.h" line="56" />
      <constructor name="new" c:identifier="g_main_loop_new" gs:dll-name="glib-2.0" gs:managed-name="New">
        <doc xml:space="preserve" filename="glib-2.0.c" line="22483">Creates a new #GMainLoop structure.</doc>
        <source-position filename="gmain.h" line="535" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="22492">a new #GMainLoop.</doc>
          <type name="MainLoop" c:type="GMainLoop*" gs:managed-name="MainLoop" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none" nullable="1" allow-none="1" gs:default="null" gs:managed-name="context" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="22485">a #GMainContext  (if %NULL, the default context will be used).</doc>
            <type name="MainContext" c:type="GMainContext*" gs:managed-name="MainContext" gs:is-pointer="1" />
          </parameter>
          <parameter name="is_running" transfer-ownership="none" gs:default="false" gs:managed-name="isRunning" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="22486">set to %TRUE to indicate that the loop is running. This
is not very important since calling g_main_loop_run() will set this to
%TRUE anyway.</doc>
            <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="context" transfer-ownership="none" nullable="1" allow-none="1" gs:default="null" gs:managed-name="context" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="22485">a #GMainContext  (if %NULL, the default context will be used).</doc>
            <type name="MainContext" c:type="GMainContext*" gs:managed-name="MainContext" gs:is-pointer="1" />
          </parameter>
          <parameter name="is_running" transfer-ownership="none" gs:default="false" gs:managed-name="isRunning" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="22486">set to %TRUE to indicate that the loop is running. This
is not very important since calling g_main_loop_run() will set this to
%TRUE anyway.</doc>
            <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <gs:managed-property name="get_context" gs:dll-name="glib-2.0" gs:managed-name="Context">
        <doc xml:space="preserve" filename="glib-2.0.c" line="22463">Returns the #GMainContext of @loop.</doc>
        <source-position filename="gmain.h" line="548" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="22469">the #GMainContext of @loop</doc>
          <type name="MainContext" c:type="GMainContext*" gs:managed-name="MainContext" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="loop" transfer-ownership="none" gs:managed-name="loop" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="22465">a #GMainLoop.</doc>
            <type name="MainLoop" c:type="GMainLoop*" gs:managed-name="MainLoop" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_context" c:identifier="g_main_loop_get_context" gs:dll-name="glib-2.0" gs:managed-name="GetContext" gs:property-getter-for="Context" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="22463">Returns the #GMainContext of @loop.</doc>
        <source-position filename="gmain.h" line="548" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="22469">the #GMainContext of @loop</doc>
          <type name="MainContext" c:type="GMainContext*" gs:managed-name="MainContext" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="loop" transfer-ownership="none" gs:managed-name="loop" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="22465">a #GMainLoop.</doc>
            <type name="MainLoop" c:type="GMainLoop*" gs:managed-name="MainLoop" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="is_running" gs:dll-name="glib-2.0" gs:managed-name="IsRunning">
        <doc xml:space="preserve" filename="glib-2.0.c" line="22473">Checks to see if the main loop is currently being run via g_main_loop_run().</doc>
        <source-position filename="gmain.h" line="546" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="22479">%TRUE if the mainloop is currently being run.</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="loop" transfer-ownership="none" gs:managed-name="loop" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="22475">a #GMainLoop.</doc>
            <type name="MainLoop" c:type="GMainLoop*" gs:managed-name="MainLoop" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="is_running" c:identifier="g_main_loop_is_running" gs:dll-name="glib-2.0" gs:managed-name="GetIsRunning" gs:property-getter-for="IsRunning" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="22473">Checks to see if the main loop is currently being run via g_main_loop_run().</doc>
        <source-position filename="gmain.h" line="546" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="22479">%TRUE if the mainloop is currently being run.</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="loop" transfer-ownership="none" gs:managed-name="loop" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="22475">a #GMainLoop.</doc>
            <type name="MainLoop" c:type="GMainLoop*" gs:managed-name="MainLoop" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="quit" c:identifier="g_main_loop_quit" gs:dll-name="glib-2.0" gs:managed-name="Quit">
        <doc xml:space="preserve" filename="glib-2.0.c" line="22496">Stops a #GMainLoop from running. Any calls to g_main_loop_run()
for the loop will return.

Note that sources that have already been dispatched when
g_main_loop_quit() is called will still be executed.</doc>
        <source-position filename="gmain.h" line="540" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="loop" transfer-ownership="none" gs:managed-name="loop" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="22498">a #GMainLoop</doc>
            <type name="MainLoop" c:type="GMainLoop*" gs:managed-name="MainLoop" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="ref" c:identifier="g_main_loop_ref" gs:dll-name="glib-2.0" gs:managed-name="Ref" gs:special-func="ref" gs:pinvoke-only="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="22508">Increases the reference count on a #GMainLoop object by one.</doc>
        <source-position filename="gmain.h" line="542" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="22514">@loop</doc>
          <type name="MainLoop" c:type="GMainLoop*" gs:managed-name="MainLoop" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="loop" transfer-ownership="none" gs:managed-name="loop" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="22510">a #GMainLoop</doc>
            <type name="MainLoop" c:type="GMainLoop*" gs:managed-name="MainLoop" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="run" c:identifier="g_main_loop_run" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="Run">
        <doc xml:space="preserve" filename="glib-2.0.c" line="22518">Runs a main loop until g_main_loop_quit() is called on the loop.
If this is called for the thread of the loop's #GMainContext,
it will process events from the loop, otherwise it will
simply wait.</doc>
        <source-position filename="gmain.h" line="538" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="loop" transfer-ownership="none" gs:managed-name="loop" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="22520">a #GMainLoop</doc>
            <type name="MainLoop" c:type="GMainLoop*" gs:managed-name="MainLoop" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="unref" c:identifier="g_main_loop_unref" gs:dll-name="glib-2.0" gs:managed-name="Unref" gs:special-func="unref" gs:pinvoke-only="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="22529">Decreases the reference count on a #GMainLoop object by one. If
the result is zero, free the loop and free all associated memory.</doc>
        <source-position filename="gmain.h" line="544" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="loop" transfer-ownership="none" gs:managed-name="loop" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="22531">a #GMainLoop</doc>
            <type name="MainLoop" c:type="GMainLoop*" gs:managed-name="MainLoop" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_main_loop_get_type" gs:access-modifiers="private" gs:dll-name="gobject-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </record>
    <union name="Mutex" c:type="GMutex" gs:managed-name="Mutex">
      <doc xml:space="preserve" filename="glib-2.0.c" line="1307">The #GMutex struct is an opaque data structure to represent a mutex
(mutual exclusion). It can be used to protect data against shared
access.

Take for example the following function:
|[&lt;!-- language="C" --&gt;
  int
  give_me_next_number (void)
  {
    static int current_number = 0;

    // now do a very complicated calculation to calculate the new
    // number, this might for example be a random number generator
    current_number = calc_next_number (current_number);

    return current_number;
  }
]|
It is easy to see that this won't work in a multi-threaded
application. There current_number must be protected against shared
access. A #GMutex can be used as a solution to this problem:
|[&lt;!-- language="C" --&gt;
  int
  give_me_next_number (void)
  {
    static GMutex mutex;
    static int current_number = 0;
    int ret_val;

    g_mutex_lock (&amp;mutex);
    ret_val = current_number = calc_next_number (current_number);
    g_mutex_unlock (&amp;mutex);

    return ret_val;
  }
]|
Notice that the #GMutex is not initialised to any particular value.
Its placement in static storage ensures that it will be initialised
to all-zeros, which is appropriate.

If a #GMutex is placed in other contexts (eg: embedded in a struct)
then it must be explicitly initialised using g_mutex_init().

A #GMutex should only be accessed via g_mutex_ functions.</doc>
      <source-position filename="gthread.h" line="63" />
      <field name="p" readable="0" private="1" gs:managed-name="P">
        <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
      </field>
      <field name="i" readable="0" private="1" gs:managed-name="I">
        <array zero-terminated="0" fixed-size="2" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
          <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
        </array>
      </field>
      <method name="clear" c:identifier="g_mutex_clear" gs:dll-name="glib-2.0" gs:managed-name="Clear">
        <doc xml:space="preserve" filename="glib-2.0.c" line="23673">Frees the resources allocated to a mutex with g_mutex_init().

This function should not be used with a #GMutex that has been
statically allocated.

Calling g_mutex_clear() on a locked mutex leads to undefined
behaviour.

Sine: 2.32</doc>
        <source-position filename="gthread.h" line="166" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="mutex" transfer-ownership="none" gs:managed-name="mutex" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="23675">an initialized #GMutex</doc>
            <type name="Mutex" c:type="GMutex*" gs:managed-name="Mutex" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="init" c:identifier="g_mutex_init" version="2.32" gs:dll-name="glib-2.0" gs:managed-name="Init">
        <doc xml:space="preserve" filename="glib-2.0.c" line="23689">Initializes a #GMutex so that it can be used.

This function is useful to initialize a mutex that has been
allocated on the stack, or as part of a larger structure.
It is not necessary to initialize a mutex that has been
statically allocated.

|[&lt;!-- language="C" --&gt;
  typedef struct {
    GMutex m;
    ...
  } Blob;

Blob *b;

b = g_new (Blob, 1);
g_mutex_init (&amp;b-&gt;m);
]|

To undo the effect of g_mutex_init() when a mutex is no longer
needed, use g_mutex_clear().

Calling g_mutex_init() on an already initialized #GMutex leads
to undefined behaviour.</doc>
        <source-position filename="gthread.h" line="164" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="mutex" transfer-ownership="none" gs:managed-name="mutex" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="23691">an uninitialized #GMutex</doc>
            <type name="Mutex" c:type="GMutex*" gs:managed-name="Mutex" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="lock" c:identifier="g_mutex_lock" gs:dll-name="glib-2.0" gs:managed-name="Lock">
        <doc xml:space="preserve" filename="glib-2.0.c" line="23722">Locks @mutex. If @mutex is already locked by another thread, the
current thread will block until @mutex is unlocked by the other
thread.

#GMutex is neither guaranteed to be recursive nor to be
non-recursive.  As such, calling g_mutex_lock() on a #GMutex that has
already been locked by the same thread results in undefined behaviour
(including but not limited to deadlocks).</doc>
        <source-position filename="gthread.h" line="168" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="mutex" transfer-ownership="none" gs:managed-name="mutex" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="23724">a #GMutex</doc>
            <type name="Mutex" c:type="GMutex*" gs:managed-name="Mutex" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="trylock" c:identifier="g_mutex_trylock" gs:dll-name="glib-2.0" gs:managed-name="Trylock">
        <doc xml:space="preserve" filename="glib-2.0.c" line="23737">Tries to lock @mutex. If @mutex is already locked by another thread,
it immediately returns %FALSE. Otherwise it locks @mutex and returns
%TRUE.

#GMutex is neither guaranteed to be recursive nor to be
non-recursive.  As such, calling g_mutex_lock() on a #GMutex that has
already been locked by the same thread results in undefined behaviour
(including but not limited to deadlocks or arbitrary return values).</doc>
        <source-position filename="gthread.h" line="170" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="23750">%TRUE if @mutex could be locked</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="mutex" transfer-ownership="none" gs:managed-name="mutex" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="23739">a #GMutex</doc>
            <type name="Mutex" c:type="GMutex*" gs:managed-name="Mutex" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="unlock" c:identifier="g_mutex_unlock" gs:dll-name="glib-2.0" gs:managed-name="Unlock">
        <doc xml:space="preserve" filename="glib-2.0.c" line="23754">Unlocks @mutex. If another thread is blocked in a g_mutex_lock()
call for @mutex, it will become unblocked and can lock @mutex itself.

Calling g_mutex_unlock() on a mutex that is not locked by the
current thread leads to undefined behaviour.</doc>
        <source-position filename="gthread.h" line="172" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="mutex" transfer-ownership="none" gs:managed-name="mutex" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="23756">a #GMutex</doc>
            <type name="Mutex" c:type="GMutex*" gs:managed-name="Mutex" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
    </union>
    <enumeration name="NormalizeMode" c:type="GNormalizeMode" gs:managed-name="NormalizeMode">
      <doc xml:space="preserve" filename="gunicode.h" line="883">Defines how a Unicode string is transformed in a canonical
form, standardizing such issues as whether a character with
an accent is represented as a base character and combining
accent or as a single precomposed character. Unicode strings
should generally be normalized before comparing them.</doc>
      <source-position filename="gunicode.h" line="916" />
      <member name="default" value="0" c:identifier="G_NORMALIZE_DEFAULT" gs:managed-name="Default">
        <doc xml:space="preserve" filename="gunicode.h" line="885">standardize differences that do not affect the
    text content, such as the above-mentioned accent representation</doc>
      </member>
      <member name="n_f_d" value="0" c:identifier="G_NORMALIZE_NFD" gs:managed-name="NFD">
        <doc xml:space="preserve" filename="gunicode.h" line="887">another name for %G_NORMALIZE_DEFAULT</doc>
      </member>
      <member name="default_compose" value="1" c:identifier="G_NORMALIZE_DEFAULT_COMPOSE" gs:managed-name="DefaultCompose">
        <doc xml:space="preserve" filename="gunicode.h" line="888">like %G_NORMALIZE_DEFAULT, but with
    composed forms rather than a maximally decomposed form</doc>
      </member>
      <member name="n_f_c" value="1" c:identifier="G_NORMALIZE_NFC" gs:managed-name="NFC">
        <doc xml:space="preserve" filename="gunicode.h" line="890">another name for %G_NORMALIZE_DEFAULT_COMPOSE</doc>
      </member>
      <member name="all" value="2" c:identifier="G_NORMALIZE_ALL" gs:managed-name="All">
        <doc xml:space="preserve" filename="gunicode.h" line="891">beyond %G_NORMALIZE_DEFAULT also standardize the
    "compatibility" characters in Unicode, such as SUPERSCRIPT THREE
    to the standard forms (in this case DIGIT THREE). Formatting
    information may be lost but for most text operations such
    characters should be considered the same</doc>
      </member>
      <member name="n_f_k_d" value="2" c:identifier="G_NORMALIZE_NFKD" gs:managed-name="NFKD">
        <doc xml:space="preserve" filename="gunicode.h" line="896">another name for %G_NORMALIZE_ALL</doc>
      </member>
      <member name="all_compose" value="3" c:identifier="G_NORMALIZE_ALL_COMPOSE" gs:managed-name="AllCompose">
        <doc xml:space="preserve" filename="gunicode.h" line="897">like %G_NORMALIZE_ALL, but with composed
    forms rather than a maximally decomposed form</doc>
      </member>
      <member name="n_f_k_c" value="3" c:identifier="G_NORMALIZE_NFKC" gs:managed-name="NFKC">
        <doc xml:space="preserve" filename="gunicode.h" line="899">another name for %G_NORMALIZE_ALL_COMPOSE</doc>
      </member>
    </enumeration>
    <enumeration name="OptionArg" c:type="GOptionArg" gs:managed-name="OptionArg">
      <doc xml:space="preserve" filename="goption.h" line="93">The #GOptionArg enum values determine which type of extra argument the
options expect to find. If an option expects an extra argument, it can
be specified in several ways; with a short option: `-x arg`, with a long
option: `--name arg` or combined in a single argument: `--name=arg`.</doc>
      <source-position filename="goption.h" line="130" />
      <member name="none" value="0" c:identifier="G_OPTION_ARG_NONE" gs:managed-name="None">
        <doc xml:space="preserve" filename="goption.h" line="95">No extra argument. This is useful for simple flags.</doc>
      </member>
      <member name="string" value="1" c:identifier="G_OPTION_ARG_STRING" gs:managed-name="String">
        <doc xml:space="preserve" filename="goption.h" line="96">The option takes a UTF-8 string argument.</doc>
      </member>
      <member name="int" value="2" c:identifier="G_OPTION_ARG_INT" gs:managed-name="Int">
        <doc xml:space="preserve" filename="goption.h" line="97">The option takes an integer argument.</doc>
      </member>
      <member name="callback" value="3" c:identifier="G_OPTION_ARG_CALLBACK" gs:managed-name="Callback">
        <doc xml:space="preserve" filename="goption.h" line="98">The option provides a callback (of type
    #GOptionArgFunc) to parse the extra argument.</doc>
      </member>
      <member name="filename" value="4" c:identifier="G_OPTION_ARG_FILENAME" gs:managed-name="Filename">
        <doc xml:space="preserve" filename="goption.h" line="100">The option takes a filename as argument, which will
       be in the GLib filename encoding rather than UTF-8.</doc>
      </member>
      <member name="string_array" value="5" c:identifier="G_OPTION_ARG_STRING_ARRAY" gs:managed-name="StringArray">
        <doc xml:space="preserve" filename="goption.h" line="102">The option takes a string argument, multiple
    uses of the option are collected into an array of strings.</doc>
      </member>
      <member name="filename_array" value="6" c:identifier="G_OPTION_ARG_FILENAME_ARRAY" gs:managed-name="FilenameArray">
        <doc xml:space="preserve" filename="goption.h" line="104">The option takes a filename as argument,
    multiple uses of the option are collected into an array of strings.</doc>
      </member>
      <member name="double" value="7" c:identifier="G_OPTION_ARG_DOUBLE" version="2.12" gs:managed-name="Double">
        <doc xml:space="preserve" filename="goption.h" line="106">The option takes a double argument. The argument
    can be formatted either for the user's locale or for the "C" locale.</doc>
      </member>
      <member name="int64" value="8" c:identifier="G_OPTION_ARG_INT64" version="2.12" gs:managed-name="Int64">
        <doc xml:space="preserve" filename="goption.h" line="109">The option takes a 64-bit integer. Like
    %G_OPTION_ARG_INT but for larger numbers. The number can be in
    decimal base, or in hexadecimal (when prefixed with `0x`, for
    example, `0xffffffff`).</doc>
      </member>
    </enumeration>
    <callback name="OptionArgFunc" c:type="GOptionArgFunc" throws="1" gs:dll-name="glib-2.0" gs:managed-name="OptionArgFunc">
      <doc xml:space="preserve" filename="goption.h" line="132">The type of function to be passed as callback for %G_OPTION_ARG_CALLBACK
options.</doc>
      <source-position filename="goption.h" line="149" />
      <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
        <doc xml:space="preserve" filename="goption.h" line="146">%TRUE if the option was successfully parsed, %FALSE if an error
 occurred, in which case @error should be set with g_set_error()</doc>
        <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
      </return-value>
      <parameters>
        <parameter name="option_name" transfer-ownership="none" gs:managed-name="optionName" direction="in">
          <doc xml:space="preserve" filename="goption.h" line="134">The name of the option being parsed. This will be either a
 single dash followed by a single letter (for a short name) or two dashes
 followed by a long option name.</doc>
          <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </parameter>
        <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
          <doc xml:space="preserve" filename="goption.h" line="137">The value to be parsed.</doc>
          <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </parameter>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" closure="2" gs:managed-name="data" direction="in">
          <doc xml:space="preserve" filename="goption.h" line="138">User data added to the #GOptionGroup containing the option when it
 was created with g_option_group_new()</doc>
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </parameter>
        <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
          <doc>return location for a #GError</doc>
          <type name="GLib.Error" c:type="GError**" gs:managed-name="GISharp.Lib.GLib.Error" gs:is-pointer="1" />
        </gs:error-parameter>
      </parameters>
      <gs:managed-parameters>
        <parameter name="option_name" transfer-ownership="none" gs:managed-name="optionName" direction="in">
          <doc xml:space="preserve" filename="goption.h" line="134">The name of the option being parsed. This will be either a
 single dash followed by a single letter (for a short name) or two dashes
 followed by a long option name.</doc>
          <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </parameter>
        <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
          <doc xml:space="preserve" filename="goption.h" line="137">The value to be parsed.</doc>
          <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </parameter>
      </gs:managed-parameters>
    </callback>
    <record name="OptionContext" c:type="GOptionContext" disguised="1" gs:managed-name="OptionContext">
      <doc xml:space="preserve" filename="goption.h" line="31">A `GOptionContext` struct defines which options
are accepted by the commandline option parser. The struct has only private
fields and should not be directly accessed.</doc>
      <source-position filename="goption.h" line="38" />
      <method name="add_group" c:identifier="g_option_context_add_group" version="2.6" gs:dll-name="glib-2.0" gs:managed-name="AddGroup">
        <doc xml:space="preserve" filename="glib-2.0.c" line="24309">Adds a #GOptionGroup to the @context, so that parsing with @context
will recognize the options in the group. Note that this will take
ownership of the @group and thus the @group should not be freed.</doc>
        <source-position filename="goption.h" line="343" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" gs:managed-name="context" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24311">a #GOptionContext</doc>
            <type name="OptionContext" c:type="GOptionContext*" gs:managed-name="OptionContext" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="group" transfer-ownership="full" gs:managed-name="group" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24312">the group to add</doc>
            <type name="OptionGroup" c:type="GOptionGroup*" gs:managed-name="OptionGroup" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="group" transfer-ownership="full" gs:managed-name="group" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24312">the group to add</doc>
            <type name="OptionGroup" c:type="GOptionGroup*" gs:managed-name="OptionGroup" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="free" c:identifier="g_option_context_free" version="2.6" gs:dll-name="glib-2.0" gs:managed-name="Free" gs:special-func="free" gs:pinvoke-only="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="24337">Frees context and all the groups which have been
added to it.

Please note that parsed arguments need to be freed separately (see
#GOptionEntry).</doc>
        <source-position filename="goption.h" line="302" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" gs:managed-name="context" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24339">a #GOptionContext</doc>
            <type name="OptionContext" c:type="GOptionContext*" gs:managed-name="OptionContext" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_description" version="2.12" gs:dll-name="glib-2.0" gs:managed-name="Description">
        <doc xml:space="preserve" filename="glib-2.0.c" line="24351">Returns the description. See g_option_context_set_description().</doc>
        <source-position filename="goption.h" line="300" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="24357">the description</doc>
          <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" gs:managed-name="context" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24353">a #GOptionContext</doc>
            <type name="OptionContext" c:type="GOptionContext*" gs:managed-name="OptionContext" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_description" c:identifier="g_option_context_get_description" version="2.12" gs:dll-name="glib-2.0" gs:managed-name="GetDescription" gs:property-getter-for="Description" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="24351">Returns the description. See g_option_context_set_description().</doc>
        <source-position filename="goption.h" line="300" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="24357">the description</doc>
          <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" gs:managed-name="context" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24353">a #GOptionContext</doc>
            <type name="OptionContext" c:type="GOptionContext*" gs:managed-name="OptionContext" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="get_help" c:identifier="g_option_context_get_help" version="2.14" gs:dll-name="glib-2.0" gs:managed-name="GetHelp">
        <doc xml:space="preserve" filename="glib-2.0.c" line="24362">Returns a formatted, translated help text for the given context.
To obtain the text produced by `--help`, call
`g_option_context_get_help (context, TRUE, NULL)`.
To obtain the text produced by `--help-all`, call
`g_option_context_get_help (context, FALSE, NULL)`.
To obtain the help text for an option group, call
`g_option_context_get_help (context, FALSE, group)`.</doc>
        <source-position filename="goption.h" line="351" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="24376">A newly allocated string containing the help text</doc>
          <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" gs:managed-name="context" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24364">a #GOptionContext</doc>
            <type name="OptionContext" c:type="GOptionContext*" gs:managed-name="OptionContext" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="main_help" transfer-ownership="none" gs:managed-name="mainHelp" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24365">if %TRUE, only include the main group</doc>
            <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
          </parameter>
          <parameter name="group" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="group" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24366">the #GOptionGroup to create help for, or %NULL</doc>
            <type name="OptionGroup" c:type="GOptionGroup*" gs:managed-name="OptionGroup" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="main_help" transfer-ownership="none" gs:managed-name="mainHelp" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24365">if %TRUE, only include the main group</doc>
            <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
          </parameter>
          <parameter name="group" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="group" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24366">the #GOptionGroup to create help for, or %NULL</doc>
            <type name="OptionGroup" c:type="GOptionGroup*" gs:managed-name="OptionGroup" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <gs:managed-property name="get_help_enabled" version="2.6" gs:dll-name="glib-2.0" gs:managed-name="HelpEnabled">
        <doc xml:space="preserve" filename="glib-2.0.c" line="24381">Returns whether automatic `--help` generation
is turned on for @context. See g_option_context_set_help_enabled().</doc>
        <source-position filename="goption.h" line="307" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="24388">%TRUE if automatic help generation is turned on.</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" gs:managed-name="context" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24383">a #GOptionContext</doc>
            <type name="OptionContext" c:type="GOptionContext*" gs:managed-name="OptionContext" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_help_enabled" c:identifier="g_option_context_get_help_enabled" version="2.6" gs:dll-name="glib-2.0" gs:managed-name="GetHelpEnabled" gs:property-getter-for="HelpEnabled" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="24381">Returns whether automatic `--help` generation
is turned on for @context. See g_option_context_set_help_enabled().</doc>
        <source-position filename="goption.h" line="307" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="24388">%TRUE if automatic help generation is turned on.</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" gs:managed-name="context" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24383">a #GOptionContext</doc>
            <type name="OptionContext" c:type="GOptionContext*" gs:managed-name="OptionContext" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_ignore_unknown_options" version="2.6" gs:dll-name="glib-2.0" gs:managed-name="IgnoreUnknownOptions">
        <doc xml:space="preserve" filename="glib-2.0.c" line="24393">Returns whether unknown options are ignored or not. See
g_option_context_set_ignore_unknown_options().</doc>
        <source-position filename="goption.h" line="312" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="24400">%TRUE if unknown options are ignored.</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" gs:managed-name="context" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24395">a #GOptionContext</doc>
            <type name="OptionContext" c:type="GOptionContext*" gs:managed-name="OptionContext" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_ignore_unknown_options" c:identifier="g_option_context_get_ignore_unknown_options" version="2.6" gs:dll-name="glib-2.0" gs:managed-name="GetIgnoreUnknownOptions" gs:property-getter-for="IgnoreUnknownOptions" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="24393">Returns whether unknown options are ignored or not. See
g_option_context_set_ignore_unknown_options().</doc>
        <source-position filename="goption.h" line="312" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="24400">%TRUE if unknown options are ignored.</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" gs:managed-name="context" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24395">a #GOptionContext</doc>
            <type name="OptionContext" c:type="GOptionContext*" gs:managed-name="OptionContext" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_main_group" version="2.6" gs:dll-name="glib-2.0" gs:managed-name="MainGroup">
        <doc xml:space="preserve" filename="glib-2.0.c" line="24405">Returns a pointer to the main group of @context.</doc>
        <source-position filename="goption.h" line="349" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="24411">the main group of @context, or %NULL if
 @context doesn't have a main group. Note that group belongs to
 @context and should not be modified or freed.</doc>
          <type name="OptionGroup" c:type="GOptionGroup*" gs:managed-name="OptionGroup" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" gs:managed-name="context" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24407">a #GOptionContext</doc>
            <type name="OptionContext" c:type="GOptionContext*" gs:managed-name="OptionContext" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_main_group" c:identifier="g_option_context_get_main_group" version="2.6" gs:dll-name="glib-2.0" gs:managed-name="GetMainGroup" gs:property-getter-for="MainGroup" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="24405">Returns a pointer to the main group of @context.</doc>
        <source-position filename="goption.h" line="349" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="24411">the main group of @context, or %NULL if
 @context doesn't have a main group. Note that group belongs to
 @context and should not be modified or freed.</doc>
          <type name="OptionGroup" c:type="GOptionGroup*" gs:managed-name="OptionGroup" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" gs:managed-name="context" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24407">a #GOptionContext</doc>
            <type name="OptionContext" c:type="GOptionContext*" gs:managed-name="OptionContext" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_strict_posix" version="2.44" gs:dll-name="glib-2.0" gs:managed-name="StrictPosix">
        <doc xml:space="preserve" filename="glib-2.0.c" line="24418">Returns whether strict POSIX code is enabled.

See g_option_context_set_strict_posix() for more information.</doc>
        <source-position filename="goption.h" line="318" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="24426">%TRUE if strict POSIX is enabled, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" gs:managed-name="context" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24420">a #GOptionContext</doc>
            <type name="OptionContext" c:type="GOptionContext*" gs:managed-name="OptionContext" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_strict_posix" c:identifier="g_option_context_get_strict_posix" version="2.44" gs:dll-name="glib-2.0" gs:managed-name="GetStrictPosix" gs:property-getter-for="StrictPosix" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="24418">Returns whether strict POSIX code is enabled.

See g_option_context_set_strict_posix() for more information.</doc>
        <source-position filename="goption.h" line="318" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="24426">%TRUE if strict POSIX is enabled, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" gs:managed-name="context" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24420">a #GOptionContext</doc>
            <type name="OptionContext" c:type="GOptionContext*" gs:managed-name="OptionContext" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_summary" version="2.12" gs:dll-name="glib-2.0" gs:managed-name="Summary">
        <doc xml:space="preserve" filename="glib-2.0.c" line="24431">Returns the summary. See g_option_context_set_summary().</doc>
        <source-position filename="goption.h" line="295" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="24437">the summary</doc>
          <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" gs:managed-name="context" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24433">a #GOptionContext</doc>
            <type name="OptionContext" c:type="GOptionContext*" gs:managed-name="OptionContext" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_summary" c:identifier="g_option_context_get_summary" version="2.12" gs:dll-name="glib-2.0" gs:managed-name="GetSummary" gs:property-getter-for="Summary" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="24431">Returns the summary. See g_option_context_set_summary().</doc>
        <source-position filename="goption.h" line="295" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="24437">the summary</doc>
          <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" gs:managed-name="context" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24433">a #GOptionContext</doc>
            <type name="OptionContext" c:type="GOptionContext*" gs:managed-name="OptionContext" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="set_description" c:identifier="g_option_context_set_description" version="2.12" gs:dll-name="glib-2.0" gs:managed-name="SetDescription" gs:property-setter-for="Description" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="24541">Adds a string to be displayed in `--help` output after the list
of options. This text often includes a bug reporting address.

Note that the summary is translated (see
g_option_context_set_translate_func()).</doc>
        <source-position filename="goption.h" line="297" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" gs:managed-name="context" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24543">a #GOptionContext</doc>
            <type name="OptionContext" c:type="GOptionContext*" gs:managed-name="OptionContext" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="description" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="description" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24544">a string to be shown in `--help` output
  after the list of options, or %NULL</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="description" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="description" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24544">a string to be shown in `--help` output
  after the list of options, or %NULL</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_help_enabled" c:identifier="g_option_context_set_help_enabled" version="2.6" gs:dll-name="glib-2.0" gs:managed-name="SetHelpEnabled" gs:property-setter-for="HelpEnabled" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="24557">Enables or disables automatic generation of `--help` output.
By default, g_option_context_parse() recognizes `--help`, `-h`,
`-?`, `--help-all` and `--help-groupname` and creates suitable
output to stdout.</doc>
        <source-position filename="goption.h" line="304" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" gs:managed-name="context" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24559">a #GOptionContext</doc>
            <type name="OptionContext" c:type="GOptionContext*" gs:managed-name="OptionContext" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="help_enabled" transfer-ownership="none" gs:managed-name="helpEnabled" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24560">%TRUE to enable `--help`, %FALSE to disable it</doc>
            <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="help_enabled" transfer-ownership="none" gs:managed-name="helpEnabled" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24560">%TRUE to enable `--help`, %FALSE to disable it</doc>
            <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_ignore_unknown_options" c:identifier="g_option_context_set_ignore_unknown_options" version="2.6" gs:dll-name="glib-2.0" gs:managed-name="SetIgnoreUnknownOptions" gs:property-setter-for="IgnoreUnknownOptions" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="24571">Sets whether to ignore unknown options or not. If an argument is
ignored, it is left in the @argv array after parsing. By default,
g_option_context_parse() treats unknown options as error.

This setting does not affect non-option arguments (i.e. arguments
which don't start with a dash). But note that GOption cannot reliably
determine whether a non-option belongs to a preceding unknown option.</doc>
        <source-position filename="goption.h" line="309" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" gs:managed-name="context" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24573">a #GOptionContext</doc>
            <type name="OptionContext" c:type="GOptionContext*" gs:managed-name="OptionContext" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="ignore_unknown" transfer-ownership="none" gs:managed-name="ignoreUnknown" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24574">%TRUE to ignore unknown options, %FALSE to produce
   an error when unknown options are met</doc>
            <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="ignore_unknown" transfer-ownership="none" gs:managed-name="ignoreUnknown" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24574">%TRUE to ignore unknown options, %FALSE to produce
   an error when unknown options are met</doc>
            <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_main_group" c:identifier="g_option_context_set_main_group" version="2.6" gs:dll-name="glib-2.0" gs:managed-name="SetMainGroup" gs:property-setter-for="MainGroup" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="24589">Sets a #GOptionGroup as main group of the @context.
This has the same effect as calling g_option_context_add_group(),
the only difference is that the options in the main group are
treated differently when generating `--help` output.</doc>
        <source-position filename="goption.h" line="346" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" gs:managed-name="context" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24591">a #GOptionContext</doc>
            <type name="OptionContext" c:type="GOptionContext*" gs:managed-name="OptionContext" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="group" transfer-ownership="full" gs:managed-name="group" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24592">the group to set as main group</doc>
            <type name="OptionGroup" c:type="GOptionGroup*" gs:managed-name="OptionGroup" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="group" transfer-ownership="full" gs:managed-name="group" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24592">the group to set as main group</doc>
            <type name="OptionGroup" c:type="GOptionGroup*" gs:managed-name="OptionGroup" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_strict_posix" c:identifier="g_option_context_set_strict_posix" version="2.44" gs:dll-name="glib-2.0" gs:managed-name="SetStrictPosix" gs:property-setter-for="StrictPosix" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="24603">Sets strict POSIX mode.

By default, this mode is disabled.

In strict POSIX mode, the first non-argument parameter encountered
(eg: filename) terminates argument processing.  Remaining arguments
are treated as non-options and are not attempted to be parsed.

If strict POSIX mode is disabled then parsing is done in the GNU way
where option arguments can be freely mixed with non-options.

As an example, consider "ls foo -l".  With GNU style parsing, this
will list "foo" in long mode.  In strict POSIX style, this will list
the files named "foo" and "-l".

It may be useful to force strict POSIX mode when creating "verb
style" command line tools.  For example, the "gsettings" command line
tool supports the global option "--schemadir" as well as many
subcommands ("get", "set", etc.) which each have their own set of
arguments.  Using strict POSIX mode will allow parsing the global
options up to the verb name while leaving the remaining options to be
parsed by the relevant subcommand (which can be determined by
examining the verb name, which should be present in argv[1] after
parsing).</doc>
        <source-position filename="goption.h" line="315" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" gs:managed-name="context" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24605">a #GOptionContext</doc>
            <type name="OptionContext" c:type="GOptionContext*" gs:managed-name="OptionContext" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="strict_posix" transfer-ownership="none" gs:managed-name="strictPosix" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24606">the new value</doc>
            <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="strict_posix" transfer-ownership="none" gs:managed-name="strictPosix" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24606">the new value</doc>
            <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_summary" c:identifier="g_option_context_set_summary" version="2.12" gs:dll-name="glib-2.0" gs:managed-name="SetSummary" gs:property-setter-for="Summary" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="24637">Adds a string to be displayed in `--help` output before the list
of options. This is typically a summary of the program functionality.

Note that the summary is translated (see
g_option_context_set_translate_func() and
g_option_context_set_translation_domain()).</doc>
        <source-position filename="goption.h" line="292" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" gs:managed-name="context" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24639">a #GOptionContext</doc>
            <type name="OptionContext" c:type="GOptionContext*" gs:managed-name="OptionContext" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="summary" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="summary" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24640">a string to be shown in `--help` output
 before the list of options, or %NULL</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="summary" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="summary" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24640">a string to be shown in `--help` output
 before the list of options, or %NULL</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_translate_func" c:identifier="g_option_context_set_translate_func" version="2.12" gs:dll-name="glib-2.0" gs:managed-name="SetTranslateFunc">
        <doc xml:space="preserve" filename="glib-2.0.c" line="24654">Sets the function which is used to translate the contexts
user-visible strings, for `--help` output. If @func is %NULL,
strings are not translated.

Note that option groups have their own translation functions,
this function only affects the @parameter_string (see g_option_context_new()),
the summary (see g_option_context_set_summary()) and the description
(see g_option_context_set_description()).

If you are using gettext(), you only need to set the translation
domain, see g_option_context_set_translation_domain().</doc>
        <source-position filename="goption.h" line="334" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" gs:managed-name="context" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24656">a #GOptionContext</doc>
            <type name="OptionContext" c:type="GOptionContext*" gs:managed-name="OptionContext" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="func" transfer-ownership="none" nullable="1" allow-none="1" scope="notified" closure="1" destroy="2" gs:managed-name="func" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24657">the #GTranslateFunc, or %NULL</doc>
            <type name="TranslateFunc" c:type="GTranslateFunc" gs:managed-name="TranslateFunc" />
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24658">user data to pass to @func, or %NULL</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
          <parameter name="destroy_notify" transfer-ownership="none" nullable="1" allow-none="1" scope="async" gs:managed-name="destroyNotify" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24659">a function which gets called to free @data, or %NULL</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify" gs:managed-name="DestroyNotify" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="func" transfer-ownership="none" nullable="1" allow-none="1" scope="notified" closure="1" destroy="2" gs:managed-name="func" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24657">the #GTranslateFunc, or %NULL</doc>
            <type name="TranslateFunc" c:type="GTranslateFunc" gs:managed-name="TranslateFunc" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_translation_domain" c:identifier="g_option_context_set_translation_domain" version="2.12" gs:dll-name="glib-2.0" gs:managed-name="SetTranslationDomain">
        <doc xml:space="preserve" filename="glib-2.0.c" line="24677">A convenience function to use gettext() for translating
user-visible strings.</doc>
        <source-position filename="goption.h" line="339" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none" gs:managed-name="context" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24679">a #GOptionContext</doc>
            <type name="OptionContext" c:type="GOptionContext*" gs:managed-name="OptionContext" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="domain" transfer-ownership="none" gs:managed-name="domain" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24680">the domain to use</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="domain" transfer-ownership="none" gs:managed-name="domain" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24680">the domain to use</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <constructor name="new" c:identifier="g_option_context_new" version="2.6" introspectable="1" gs:custom-constructor="private" gs:dll-name="glib-2.0" gs:managed-name="New">
        <doc xml:space="preserve" filename="glib-2.0.c" line="24442">Creates a new option context.

The @parameter_string can serve multiple purposes. It can be used
to add descriptions for "rest" arguments, which are not parsed by
the #GOptionContext, typically something like "FILES" or
"FILE1 FILE2...". If you are using #G_OPTION_REMAINING for
collecting "rest" arguments, GLib handles this automatically by
using the @arg_description of the corresponding #GOptionEntry in
the usage summary.

Another usage is to give a short summary of the program
functionality, like " - frob the strings", which will be displayed
in the same line as the usage. For a longer description of the
program functionality that should be displayed as a paragraph
below the usage line, use g_option_context_set_summary().

Note that the @parameter_string is translated using the
function set with g_option_context_set_translate_func(), so
it should normally be passed untranslated.</doc>
        <source-position filename="goption.h" line="290" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="24468">a newly created #GOptionContext, which must be
   freed with g_option_context_free() after use.</doc>
          <type name="OptionContext" c:type="GOptionContext*" gs:managed-name="OptionContext" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="parameter_string" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="parameterString" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24444">a string which is displayed in
   the first line of `--help` output, after the usage summary
   `programname [OPTION...]`</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="parameter_string" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="parameterString" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24444">a string which is displayed in
   the first line of `--help` output, after the usage summary
   `programname [OPTION...]`</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
    </record>
    <record name="OptionEntry" c:type="GOptionEntry" gs:managed-name="OptionEntry">
      <doc xml:space="preserve" filename="goption.h" line="216">A GOptionEntry struct defines a single option. To have an effect, they
must be added to a #GOptionGroup with g_option_context_add_main_entries()
or g_option_group_add_entries().</doc>
      <source-position filename="goption.h" line="269" />
      <field name="long_name" writable="1" gs:managed-name="LongName">
        <doc xml:space="preserve" filename="goption.h" line="218">The long name of an option can be used to specify it
    in a commandline as `--long_name`. Every option must have a
    long name. To resolve conflicts if multiple option groups contain
    the same long name, it is also possible to specify the option as
    `--groupname-long_name`.</doc>
        <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
      </field>
      <field name="short_name" writable="1" gs:managed-name="ShortName">
        <doc xml:space="preserve" filename="goption.h" line="223">If an option has a short name, it can be specified
    `-short_name` in a commandline. @short_name must be  a printable
    ASCII character different from '-', or zero if the option has no
    short name.</doc>
        <type name="gchar" c:type="gchar" gs:managed-name="System.SByte" />
      </field>
      <field name="flags" writable="1" gs:managed-name="Flags">
        <doc xml:space="preserve" filename="goption.h" line="227">Flags from #GOptionFlags</doc>
        <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
      </field>
      <field name="arg" writable="1" gs:managed-name="Arg">
        <doc xml:space="preserve" filename="goption.h" line="228">The type of the option, as a #GOptionArg</doc>
        <type name="OptionArg" c:type="GOptionArg" gs:managed-name="OptionArg" />
      </field>
      <field name="arg_data" writable="1" gs:managed-name="ArgData">
        <doc xml:space="preserve" filename="goption.h" line="229">If the @arg type is %G_OPTION_ARG_CALLBACK, then @arg_data
    must point to a #GOptionArgFunc callback function, which will be
    called to handle the extra argument. Otherwise, @arg_data is a
    pointer to a location to store the value, the required type of
    the location depends on the @arg type:
    - %G_OPTION_ARG_NONE: %gboolean
    - %G_OPTION_ARG_STRING: %gchar*
    - %G_OPTION_ARG_INT: %gint
    - %G_OPTION_ARG_FILENAME: %gchar*
    - %G_OPTION_ARG_STRING_ARRAY: %gchar**
    - %G_OPTION_ARG_FILENAME_ARRAY: %gchar**
    - %G_OPTION_ARG_DOUBLE: %gdouble
    If @arg type is %G_OPTION_ARG_STRING or %G_OPTION_ARG_FILENAME,
    the location will contain a newly allocated string if the option
    was given. That string needs to be freed by the callee using g_free().
    Likewise if @arg type is %G_OPTION_ARG_STRING_ARRAY or
    %G_OPTION_ARG_FILENAME_ARRAY, the data should be freed using g_strfreev().</doc>
        <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
      </field>
      <field name="description" writable="1" gs:managed-name="Description">
        <doc xml:space="preserve" filename="goption.h" line="246">the description for the option in `--help`
    output. The @description is translated using the @translate_func
    of the group, see g_option_group_set_translation_domain().</doc>
        <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
      </field>
      <field name="arg_description" writable="1" gs:managed-name="ArgDescription">
        <doc xml:space="preserve" filename="goption.h" line="249">The placeholder to use for the extra argument parsed
    by the option in `--help` output. The @arg_description is translated
    using the @translate_func of the group, see
    g_option_group_set_translation_domain().</doc>
        <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
      </field>
    </record>
    <enumeration name="OptionError" c:type="GOptionError" glib:error-domain="g-option-context-error-quark" gs:managed-name="OptionError">
      <doc xml:space="preserve" filename="goption.h" line="196">Error codes returned by option parsing.</doc>
      <source-position filename="goption.h" line="211" />
      <member name="unknown_option" value="0" c:identifier="G_OPTION_ERROR_UNKNOWN_OPTION" gs:managed-name="UnknownOption">
        <doc xml:space="preserve" filename="goption.h" line="198">An option was not known to the parser.
 This error will only be reported, if the parser hasn't been instructed
 to ignore unknown options, see g_option_context_set_ignore_unknown_options().</doc>
      </member>
      <member name="bad_value" value="1" c:identifier="G_OPTION_ERROR_BAD_VALUE" gs:managed-name="BadValue">
        <doc xml:space="preserve" filename="goption.h" line="201">A value couldn't be parsed.</doc>
      </member>
      <member name="failed" value="2" c:identifier="G_OPTION_ERROR_FAILED" gs:managed-name="Failed">
        <doc xml:space="preserve" filename="goption.h" line="202">A #GOptionArgFunc callback failed.</doc>
      </member>
      <gs:managed-property name="get_quark" gs:dll-name="glib-2.0" gs:managed-name="Quark">
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="Quark" c:type="GQuark" gs:managed-name="Quark" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </gs:managed-property>
      <function name="get_quark" c:identifier="g_option_error_quark" gs:dll-name="glib-2.0" gs:managed-name="GetQuark" gs:property-getter-for="Quark" gs:access-modifiers="private">
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="Quark" c:type="GQuark" gs:managed-name="Quark" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </enumeration>
    <callback name="OptionErrorFunc" c:type="GOptionErrorFunc" throws="1" gs:dll-name="glib-2.0" gs:managed-name="OptionErrorFunc">
      <doc xml:space="preserve" filename="goption.h" line="172">The type of function to be used as callback when a parse error occurs.</doc>
      <source-position filename="goption.h" line="182" />
      <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
        <type name="none" c:type="void" gs:managed-name="System.Void" />
      </return-value>
      <parameters>
        <parameter name="context" transfer-ownership="none" gs:managed-name="context" direction="in">
          <doc xml:space="preserve" filename="goption.h" line="174">The active #GOptionContext</doc>
          <type name="OptionContext" c:type="GOptionContext*" gs:managed-name="OptionContext" gs:is-pointer="1" />
        </parameter>
        <parameter name="group" transfer-ownership="none" gs:managed-name="group" direction="in">
          <doc xml:space="preserve" filename="goption.h" line="175">The group to which the function belongs</doc>
          <type name="OptionGroup" c:type="GOptionGroup*" gs:managed-name="OptionGroup" gs:is-pointer="1" />
        </parameter>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" closure="2" gs:managed-name="data" direction="in">
          <doc xml:space="preserve" filename="goption.h" line="176">User data added to the #GOptionGroup containing the option when it
 was created with g_option_group_new()</doc>
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </parameter>
        <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
          <doc>return location for a #GError</doc>
          <type name="GLib.Error" c:type="GError**" gs:managed-name="GISharp.Lib.GLib.Error" gs:is-pointer="1" />
        </gs:error-parameter>
      </parameters>
      <gs:managed-parameters>
        <parameter name="context" transfer-ownership="none" gs:managed-name="context" direction="in">
          <doc xml:space="preserve" filename="goption.h" line="174">The active #GOptionContext</doc>
          <type name="OptionContext" c:type="GOptionContext*" gs:managed-name="OptionContext" gs:is-pointer="1" />
        </parameter>
        <parameter name="group" transfer-ownership="none" gs:managed-name="group" direction="in">
          <doc xml:space="preserve" filename="goption.h" line="175">The group to which the function belongs</doc>
          <type name="OptionGroup" c:type="GOptionGroup*" gs:managed-name="OptionGroup" gs:is-pointer="1" />
        </parameter>
      </gs:managed-parameters>
    </callback>
    <bitfield name="OptionFlags" c:type="GOptionFlags" gs:managed-name="OptionFlags">
      <doc xml:space="preserve" filename="goption.h" line="54">Flags which modify individual options.</doc>
      <source-position filename="goption.h" line="91" />
      <member name="none" value="0" c:identifier="G_OPTION_FLAG_NONE" version="2.42" gs:managed-name="None">
        <doc xml:space="preserve" filename="goption.h" line="56">No flags.</doc>
      </member>
      <member name="hidden" value="1" c:identifier="G_OPTION_FLAG_HIDDEN" gs:managed-name="Hidden">
        <doc xml:space="preserve" filename="goption.h" line="57">The option doesn't appear in `--help` output.</doc>
      </member>
      <member name="in_main" value="2" c:identifier="G_OPTION_FLAG_IN_MAIN" gs:managed-name="InMain">
        <doc xml:space="preserve" filename="goption.h" line="58">The option appears in the main section of the
    `--help` output, even if it is defined in a group.</doc>
      </member>
      <member name="reverse" value="4" c:identifier="G_OPTION_FLAG_REVERSE" gs:managed-name="Reverse">
        <doc xml:space="preserve" filename="goption.h" line="60">For options of the %G_OPTION_ARG_NONE kind, this
    flag indicates that the sense of the option is reversed.</doc>
      </member>
      <member name="no_arg" value="8" c:identifier="G_OPTION_FLAG_NO_ARG" version="2.8" gs:managed-name="NoArg">
        <doc xml:space="preserve" filename="goption.h" line="62">For options of the %G_OPTION_ARG_CALLBACK kind,
    this flag indicates that the callback does not take any argument
    (like a %G_OPTION_ARG_NONE option).</doc>
      </member>
      <member name="filename" value="16" c:identifier="G_OPTION_FLAG_FILENAME" version="2.8" gs:managed-name="Filename">
        <doc xml:space="preserve" filename="goption.h" line="65">For options of the %G_OPTION_ARG_CALLBACK
    kind, this flag indicates that the argument should be passed to the
    callback in the GLib filename encoding rather than UTF-8.</doc>
      </member>
      <member name="optional_arg" value="32" c:identifier="G_OPTION_FLAG_OPTIONAL_ARG" version="2.8" gs:managed-name="OptionalArg">
        <doc xml:space="preserve" filename="goption.h" line="68">For options of the %G_OPTION_ARG_CALLBACK
    kind, this flag indicates that the argument supply is optional.
    If no argument is given then data of %GOptionParseFunc will be
    set to NULL.</doc>
      </member>
      <member name="no_alias" value="64" c:identifier="G_OPTION_FLAG_NOALIAS" version="2.8" gs:managed-name="NoAlias">
        <doc xml:space="preserve" filename="goption.h" line="72">This flag turns off the automatic conflict
    resolution which prefixes long option names with `groupname-` if
    there is a conflict. This option should only be used in situations
    where aliasing is necessary to model some legacy commandline interface.
    It is not safe to use this option, unless all option groups are under
    your direct control.</doc>
      </member>
    </bitfield>
    <record name="OptionGroup" c:type="GOptionGroup" glib:type-name="GOptionGroup" glib:get-type="g_option_group_get_type" c:symbol-prefix="option_group" gs:managed-name="OptionGroup">
      <doc xml:space="preserve" filename="goption.h" line="40">A `GOptionGroup` struct defines the options in a single
group. The struct has only private fields and should not be directly accessed.

All options in a group share the same translation function. Libraries which
need to parse commandline options are expected to provide a function for
getting a `GOptionGroup` holding their options, which
the application can then add to its #GOptionContext.</doc>
      <source-position filename="goption.h" line="51" />
      <constructor name="new" c:identifier="g_option_group_new" version="2.6" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="New">
        <doc xml:space="preserve" filename="glib-2.0.c" line="24712">Creates a new #GOptionGroup.</doc>
        <source-position filename="goption.h" line="356" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="24728">a newly created option group. It should be added
  to a #GOptionContext or freed with g_option_group_unref().</doc>
          <type name="OptionGroup" c:type="GOptionGroup*" gs:managed-name="OptionGroup" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24714">the name for the option group, this is used to provide
  help for the options in this group with `--help-`@name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="description" transfer-ownership="none" gs:managed-name="description" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24716">a description for this group to be shown in
  `--help`. This string is translated using the translation
  domain or translation function of the group</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="help_description" transfer-ownership="none" gs:managed-name="helpDescription" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24719">a description for the `--help-`@name option.
  This string is translated using the translation domain or translation function
  of the group</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24722">user data that will be passed to the pre- and post-parse hooks,
  the error hook and to callbacks of %G_OPTION_ARG_CALLBACK options, or %NULL</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
          <parameter name="destroy" transfer-ownership="none" nullable="1" allow-none="1" scope="async" gs:managed-name="destroy" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24724">a function that will be called to free @user_data, or %NULL</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify" gs:managed-name="DestroyNotify" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24714">the name for the option group, this is used to provide
  help for the options in this group with `--help-`@name</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="description" transfer-ownership="none" gs:managed-name="description" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24716">a description for this group to be shown in
  `--help`. This string is translated using the translation
  domain or translation function of the group</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="help_description" transfer-ownership="none" gs:managed-name="helpDescription" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24719">a description for the `--help-`@name option.
  This string is translated using the translation domain or translation function
  of the group</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24722">user data that will be passed to the pre- and post-parse hooks,
  the error hook and to callbacks of %G_OPTION_ARG_CALLBACK options, or %NULL</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
          <parameter name="destroy" transfer-ownership="none" nullable="1" allow-none="1" scope="async" gs:managed-name="destroy" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24724">a function that will be called to free @user_data, or %NULL</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify" gs:managed-name="DestroyNotify" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <method name="add_entries" c:identifier="g_option_group_add_entries" version="2.6" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="AddEntries">
        <doc xml:space="preserve" filename="glib-2.0.c" line="24689">Adds the options specified in @entries to @group.</doc>
        <source-position filename="goption.h" line="375" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="group" transfer-ownership="none" gs:managed-name="group" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24691">a #GOptionGroup</doc>
            <type name="OptionGroup" c:type="GOptionGroup*" gs:managed-name="OptionGroup" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="entries" transfer-ownership="none" gs:managed-name="entries" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24692">a %NULL-terminated array of #GOptionEntrys</doc>
            <array c:type="const GOptionEntry*" zero-terminated="1" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="OptionEntry" c:type="GOptionEntry" gs:managed-name="OptionEntry" />
            </array>
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="entries" transfer-ownership="none" gs:managed-name="entries" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24692">a %NULL-terminated array of #GOptionEntrys</doc>
            <array c:type="const GOptionEntry*" zero-terminated="1" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="OptionEntry" c:type="GOptionEntry" gs:managed-name="OptionEntry" />
            </array>
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="ref" c:identifier="g_option_group_ref" version="2.44" gs:dll-name="glib-2.0" gs:managed-name="Ref" gs:special-func="ref" gs:pinvoke-only="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="24734">Increments the reference count of @group by one.</doc>
        <source-position filename="goption.h" line="371" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="24740">a #GOptionGroup</doc>
          <type name="OptionGroup" c:type="GOptionGroup*" gs:managed-name="OptionGroup" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="group" transfer-ownership="none" gs:managed-name="group" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24736">a #GOptionGroup</doc>
            <type name="OptionGroup" c:type="GOptionGroup*" gs:managed-name="OptionGroup" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="set_parse_hooks" c:identifier="g_option_group_set_parse_hooks" version="2.6" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="SetParseHooks">
        <doc xml:space="preserve" filename="glib-2.0.c" line="24760">Associates two functions with @group which will be called
from g_option_context_parse() before the first option is parsed
and after the last option has been parsed, respectively.

Note that the user data to be passed to @pre_parse_func and
@post_parse_func can be specified when constructing the group
with g_option_group_new().</doc>
        <source-position filename="goption.h" line="362" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="group" transfer-ownership="none" gs:managed-name="group" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24762">a #GOptionGroup</doc>
            <type name="OptionGroup" c:type="GOptionGroup*" gs:managed-name="OptionGroup" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="pre_parse_func" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="preParseFunc" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24763">a function to call before parsing, or %NULL</doc>
            <type name="OptionParseFunc" c:type="GOptionParseFunc" gs:managed-name="OptionParseFunc" />
          </parameter>
          <parameter name="post_parse_func" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="postParseFunc" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24764">a function to call after parsing, or %NULL</doc>
            <type name="OptionParseFunc" c:type="GOptionParseFunc" gs:managed-name="OptionParseFunc" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="pre_parse_func" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="preParseFunc" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24763">a function to call before parsing, or %NULL</doc>
            <type name="OptionParseFunc" c:type="GOptionParseFunc" gs:managed-name="OptionParseFunc" />
          </parameter>
          <parameter name="post_parse_func" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="postParseFunc" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24764">a function to call after parsing, or %NULL</doc>
            <type name="OptionParseFunc" c:type="GOptionParseFunc" gs:managed-name="OptionParseFunc" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_translate_func" c:identifier="g_option_group_set_translate_func" version="2.6" gs:dll-name="glib-2.0" gs:managed-name="SetTranslateFunc">
        <doc xml:space="preserve" filename="glib-2.0.c" line="24778">Sets the function which is used to translate user-visible strings,
for `--help` output. Different groups can use different
#GTranslateFuncs. If @func is %NULL, strings are not translated.

If you are using gettext(), you only need to set the translation
domain, see g_option_group_set_translation_domain().</doc>
        <source-position filename="goption.h" line="378" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="group" transfer-ownership="none" gs:managed-name="group" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24780">a #GOptionGroup</doc>
            <type name="OptionGroup" c:type="GOptionGroup*" gs:managed-name="OptionGroup" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="func" transfer-ownership="none" nullable="1" allow-none="1" scope="notified" closure="1" destroy="2" gs:managed-name="func" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24781">the #GTranslateFunc, or %NULL</doc>
            <type name="TranslateFunc" c:type="GTranslateFunc" gs:managed-name="TranslateFunc" />
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24782">user data to pass to @func, or %NULL</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
          <parameter name="destroy_notify" transfer-ownership="none" nullable="1" allow-none="1" scope="async" gs:managed-name="destroyNotify" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24783">a function which gets called to free @data, or %NULL</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify" gs:managed-name="DestroyNotify" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="func" transfer-ownership="none" nullable="1" allow-none="1" scope="notified" closure="1" destroy="2" gs:managed-name="func" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24781">the #GTranslateFunc, or %NULL</doc>
            <type name="TranslateFunc" c:type="GTranslateFunc" gs:managed-name="TranslateFunc" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_translation_domain" c:identifier="g_option_group_set_translation_domain" version="2.6" gs:dll-name="glib-2.0" gs:managed-name="SetTranslationDomain">
        <doc xml:space="preserve" filename="glib-2.0.c" line="24796">A convenience function to use gettext() for translating
user-visible strings.</doc>
        <source-position filename="goption.h" line="383" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="group" transfer-ownership="none" gs:managed-name="group" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24798">a #GOptionGroup</doc>
            <type name="OptionGroup" c:type="GOptionGroup*" gs:managed-name="OptionGroup" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="domain" transfer-ownership="none" gs:managed-name="domain" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24799">the domain to use</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="domain" transfer-ownership="none" gs:managed-name="domain" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24799">the domain to use</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="unref" c:identifier="g_option_group_unref" version="2.44" gs:dll-name="glib-2.0" gs:managed-name="Unref" gs:special-func="unref" gs:pinvoke-only="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="24808">Decrements the reference count of @group by one.
If the reference count drops to 0, the @group will be freed.
and all memory allocated by the @group is released.</doc>
        <source-position filename="goption.h" line="373" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="group" transfer-ownership="none" gs:managed-name="group" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="24810">a #GOptionGroup</doc>
            <type name="OptionGroup" c:type="GOptionGroup*" gs:managed-name="OptionGroup" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_option_group_get_type" gs:access-modifiers="private" gs:dll-name="gobject-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </record>
    <callback name="OptionParseFunc" c:type="GOptionParseFunc" throws="1" gs:dll-name="glib-2.0" gs:managed-name="OptionParseFunc">
      <doc xml:space="preserve" filename="goption.h" line="154">The type of function that can be called before and after parsing.</doc>
      <source-position filename="goption.h" line="167" />
      <return-value transfer-ownership="none" gs:managed-name="ret" skip="1" direction="in">
        <doc xml:space="preserve" filename="goption.h" line="164">%TRUE if the function completed successfully, %FALSE if an error
 occurred, in which case @error should be set with g_set_error()</doc>
        <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
      </return-value>
      <parameters>
        <parameter name="context" transfer-ownership="none" gs:managed-name="context" direction="in">
          <doc xml:space="preserve" filename="goption.h" line="156">The active #GOptionContext</doc>
          <type name="OptionContext" c:type="GOptionContext*" gs:managed-name="OptionContext" gs:is-pointer="1" />
        </parameter>
        <parameter name="group" transfer-ownership="none" gs:managed-name="group" direction="in">
          <doc xml:space="preserve" filename="goption.h" line="157">The group to which the function belongs</doc>
          <type name="OptionGroup" c:type="GOptionGroup*" gs:managed-name="OptionGroup" gs:is-pointer="1" />
        </parameter>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" closure="2" gs:managed-name="data" direction="in">
          <doc xml:space="preserve" filename="goption.h" line="158">User data added to the #GOptionGroup containing the option when it
 was created with g_option_group_new()</doc>
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </parameter>
        <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
          <doc>return location for a #GError</doc>
          <type name="GLib.Error" c:type="GError**" gs:managed-name="GISharp.Lib.GLib.Error" gs:is-pointer="1" />
        </gs:error-parameter>
      </parameters>
      <gs:managed-parameters>
        <parameter name="context" transfer-ownership="none" gs:managed-name="context" direction="in">
          <doc xml:space="preserve" filename="goption.h" line="156">The active #GOptionContext</doc>
          <type name="OptionContext" c:type="GOptionContext*" gs:managed-name="OptionContext" gs:is-pointer="1" />
        </parameter>
        <parameter name="group" transfer-ownership="none" gs:managed-name="group" direction="in">
          <doc xml:space="preserve" filename="goption.h" line="157">The group to which the function belongs</doc>
          <type name="OptionGroup" c:type="GOptionGroup*" gs:managed-name="OptionGroup" gs:is-pointer="1" />
        </parameter>
      </gs:managed-parameters>
    </callback>
    <record name="PollFD" c:type="GPollFD" glib:type-name="GPollFD" glib:get-type="g_pollfd_get_type" c:symbol-prefix="pollfd" gs:managed-name="PollFD">
      <doc xml:space="preserve" filename="gpoll.h" line="78">Represents a file descriptor, which events to poll for, and which events
occurred.</doc>
      <source-position filename="gpoll.h" line="102" />
      <field name="fd" writable="1" gs:managed-name="Fd">
        <doc xml:space="preserve" filename="gpoll.h" line="80">the file descriptor to poll (or a HANDLE on Win32)</doc>
        <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
      </field>
      <field name="events" writable="1" gs:managed-name="Events">
        <doc xml:space="preserve" filename="gpoll.h" line="81">a bitwise combination from #GIOCondition, specifying which
    events should be polled for. Typically for reading from a file
    descriptor you would use %G_IO_IN | %G_IO_HUP | %G_IO_ERR, and
    for writing you would use %G_IO_OUT | %G_IO_ERR.</doc>
        <type name="gushort" c:type="gushort" gs:managed-name="System.UInt16" />
      </field>
      <field name="revents" writable="1" gs:managed-name="Revents">
        <doc xml:space="preserve" filename="gpoll.h" line="85">a bitwise combination of flags from #GIOCondition, returned
    from the poll() function to indicate which events occurred.</doc>
        <type name="gushort" c:type="gushort" gs:managed-name="System.UInt16" />
      </field>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_pollfd_get_type" gs:access-modifiers="private" gs:dll-name="gobject-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </record>
    <record name="PtrArray" c:type="GPtrArray" glib:type-name="GPtrArray" glib:get-type="g_ptr_array_get_type" c:symbol-prefix="ptr_array" gs:inheritance-modifiers="abstract" gs:managed-name="PtrArray">
      <doc xml:space="preserve" filename="glib-2.0.c" line="1488">Contains the public fields of a pointer array.</doc>
      <source-position filename="garray.h" line="57" />
      <field name="pdata" writable="1" gs:managed-name="Pdata">
        <doc xml:space="preserve" filename="glib-2.0.c" line="1490">points to the array of pointers, which may be moved when the
    array grows</doc>
        <type name="gpointer" c:type="gpointer*" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
      </field>
      <field name="len" writable="1" gs:managed-name="Len">
        <doc xml:space="preserve" filename="glib-2.0.c" line="1492">number of pointers in the array</doc>
        <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
      </field>
      <function name="add" c:identifier="g_ptr_array_add" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="Add">
        <doc xml:space="preserve" filename="glib-2.0.c" line="25243">Adds a pointer to the end of the pointer array. The array will grow
in size automatically if necessary.</doc>
        <source-position filename="garray.h" line="191" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25245">a #GPtrArray</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.PtrArray" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25246">the pointer to add</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25245">a #GPtrArray</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.PtrArray" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25246">the pointer to add</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="copy" c:identifier="g_ptr_array_copy" version="2.62" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="Copy">
        <doc xml:space="preserve" filename="glib-2.0.c" line="25253">Makes a full (deep) copy of a #GPtrArray.

@func, as a #GCopyFunc, takes two arguments, the data to be copied
and a @user_data pointer. On common processor architectures, it's safe to
pass %NULL as @user_data if the copy function takes only one argument. You
may get compiler warnings from this though if compiling with GCC’s
`-Wcast-function-type` warning.

If @func is %NULL, then only the pointers (and not what they are
pointing to) are copied to the new #GPtrArray.

The copy of @array will have the same #GDestroyNotify for its elements as
@array.</doc>
        <source-position filename="garray.h" line="147" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="25273">a deep copy of the initial #GPtrArray.</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.PtrArray" gs:is-pointer="1">
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </array>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25255">#GPtrArray to duplicate</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.PtrArray" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="func" transfer-ownership="none" nullable="1" allow-none="1" closure="2" gs:managed-name="func" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25256">a copy function used to copy every element in the array</doc>
            <type name="CopyFunc" c:type="GCopyFunc" gs:managed-name="CopyFunc" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25257">user data passed to the copy function @func, or %NULL</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25255">#GPtrArray to duplicate</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.PtrArray" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="func" transfer-ownership="none" nullable="1" allow-none="1" closure="2" gs:managed-name="func" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25256">a copy function used to copy every element in the array</doc>
            <type name="CopyFunc" c:type="GCopyFunc" gs:managed-name="CopyFunc" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="extend" c:identifier="g_ptr_array_extend" version="2.62" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="Extend">
        <doc xml:space="preserve" filename="glib-2.0.c" line="25278">Adds all pointers of @array to the end of the array @array_to_extend.
The array will grow in size automatically if needed. @array_to_extend is
modified in-place.

@func, as a #GCopyFunc, takes two arguments, the data to be copied
and a @user_data pointer. On common processor architectures, it's safe to
pass %NULL as @user_data if the copy function takes only one argument. You
may get compiler warnings from this though if compiling with GCC’s
`-Wcast-function-type` warning.

If @func is %NULL, then only the pointers (and not what they are
pointing to) are copied to the new #GPtrArray.</doc>
        <source-position filename="garray.h" line="194" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <parameter name="array_to_extend" transfer-ownership="none" gs:managed-name="arrayToExtend" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25280">a #GPtrArray.</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.PtrArray" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25281">a #GPtrArray to add to the end of @array_to_extend.</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.PtrArray" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="func" transfer-ownership="none" nullable="1" allow-none="1" closure="3" gs:managed-name="func" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25282">a copy function used to copy every element in the array</doc>
            <type name="CopyFunc" c:type="GCopyFunc" gs:managed-name="CopyFunc" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25283">user data passed to the copy function @func, or %NULL</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="array_to_extend" transfer-ownership="none" gs:managed-name="arrayToExtend" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25280">a #GPtrArray.</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.PtrArray" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25281">a #GPtrArray to add to the end of @array_to_extend.</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.PtrArray" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="func" transfer-ownership="none" nullable="1" allow-none="1" closure="3" gs:managed-name="func" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25282">a copy function used to copy every element in the array</doc>
            <type name="CopyFunc" c:type="GCopyFunc" gs:managed-name="CopyFunc" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="extend_and_steal" c:identifier="g_ptr_array_extend_and_steal" version="2.62" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="ExtendAndSteal">
        <doc xml:space="preserve" filename="glib-2.0.c" line="25302">Adds all the pointers in @array to the end of @array_to_extend, transferring
ownership of each element from @array to @array_to_extend and modifying
@array_to_extend in-place. @array is then freed.

As with g_ptr_array_free(), @array will be destroyed if its reference count
is 1. If its reference count is higher, it will be decremented and the
length of @array set to zero.</doc>
        <source-position filename="garray.h" line="199" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <parameter name="array_to_extend" transfer-ownership="none" gs:managed-name="arrayToExtend" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25304">a #GPtrArray.</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.PtrArray" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="array" transfer-ownership="container" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25305">a #GPtrArray to add to the end of
    @array_to_extend.</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.PtrArray" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="array_to_extend" transfer-ownership="none" gs:managed-name="arrayToExtend" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25304">a #GPtrArray.</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.PtrArray" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="array" transfer-ownership="container" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25305">a #GPtrArray to add to the end of
    @array_to_extend.</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.PtrArray" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="find" c:identifier="g_ptr_array_find" version="2.54" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="TryFind">
        <doc xml:space="preserve" filename="glib-2.0.c" line="25320">Checks whether @needle exists in @haystack. If the element is found, %TRUE is
returned and the element’s index is returned in @index_ (if non-%NULL).
Otherwise, %FALSE is returned and @index_ is undefined. If @needle exists
multiple times in @haystack, the index of the first instance is returned.

This does pointer comparisons only. If you want to use more complex equality
checks, such as string comparisons, use g_ptr_array_find_with_equal_func().</doc>
        <source-position filename="garray.h" line="217" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="25335">%TRUE if @needle is one of the elements of @haystack</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <parameter name="haystack" transfer-ownership="none" gs:managed-name="haystack" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25322">pointer array to be searched</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.PtrArray" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="needle" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="needle" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25323">pointer to look for</doc>
            <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
          <parameter name="index_" direction="out" caller-allocates="1" transfer-ownership="none" optional="1" allow-none="1" gs:managed-name="index">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25324">return location for the index of
   the element, if found</doc>
            <type name="guint" c:type="guint*" gs:managed-name="System.UInt32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="haystack" transfer-ownership="none" gs:managed-name="haystack" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25322">pointer array to be searched</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.PtrArray" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="needle" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="needle" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25323">pointer to look for</doc>
            <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
          <parameter name="index_" direction="out" caller-allocates="1" transfer-ownership="none" optional="1" allow-none="1" gs:managed-name="index">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25324">return location for the index of
   the element, if found</doc>
            <type name="guint" c:type="guint*" gs:managed-name="System.UInt32" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="find_with_equal_func" c:identifier="g_ptr_array_find_with_equal_func" version="2.54" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="TryFindWithEqualFunc">
        <doc xml:space="preserve" filename="glib-2.0.c" line="25340">Checks whether @needle exists in @haystack, using the given @equal_func.
If the element is found, %TRUE is returned and the element’s index is
returned in @index_ (if non-%NULL). Otherwise, %FALSE is returned and @index_
is undefined. If @needle exists multiple times in @haystack, the index of
the first instance is returned.

@equal_func is called with the element from the array as its first parameter,
and @needle as its second parameter. If @equal_func is %NULL, pointer
equality is used.</doc>
        <source-position filename="garray.h" line="221" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="25360">%TRUE if @needle is one of the elements of @haystack</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <parameter name="haystack" transfer-ownership="none" gs:managed-name="haystack" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25342">pointer array to be searched</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.PtrArray" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="needle" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="needle" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25343">pointer to look for</doc>
            <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
          <parameter name="equal_func" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="equalFunc" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25344">the function to call for each element, which should
   return %TRUE when the desired element is found; or %NULL to use pointer
   equality</doc>
            <type name="EqualFunc" c:type="GEqualFunc" gs:managed-name="EqualFunc" />
          </parameter>
          <parameter name="index_" direction="out" caller-allocates="1" transfer-ownership="none" optional="1" allow-none="1" gs:managed-name="index">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25347">return location for the index of
   the element, if found</doc>
            <type name="guint" c:type="guint*" gs:managed-name="System.UInt32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="haystack" transfer-ownership="none" gs:managed-name="haystack" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25342">pointer array to be searched</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.PtrArray" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="needle" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="needle" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25343">pointer to look for</doc>
            <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
          <parameter name="equal_func" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="equalFunc" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25344">the function to call for each element, which should
   return %TRUE when the desired element is found; or %NULL to use pointer
   equality</doc>
            <type name="EqualFunc" c:type="GEqualFunc" gs:managed-name="EqualFunc" />
          </parameter>
          <parameter name="index_" direction="out" caller-allocates="1" transfer-ownership="none" optional="1" allow-none="1" gs:managed-name="index">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25347">return location for the index of
   the element, if found</doc>
            <type name="guint" c:type="guint*" gs:managed-name="System.UInt32" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="foreach" c:identifier="g_ptr_array_foreach" version="2.4" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="Foreach">
        <doc xml:space="preserve" filename="glib-2.0.c" line="25365">Calls a function for each element of a #GPtrArray. @func must not
add elements to or remove elements from the array.</doc>
        <source-position filename="garray.h" line="213" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25367">a #GPtrArray</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.PtrArray" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="func" transfer-ownership="none" closure="2" gs:managed-name="func" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25368">the function to call for each array element</doc>
            <type name="Func" c:type="GFunc" gs:managed-name="Func" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25369">user data to pass to the function</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25367">a #GPtrArray</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.PtrArray" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="func" transfer-ownership="none" closure="2" gs:managed-name="func" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25368">the function to call for each array element</doc>
            <type name="Func" c:type="GFunc" gs:managed-name="Func" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="free" c:identifier="g_ptr_array_free" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="Free">
        <doc xml:space="preserve" filename="glib-2.0.c" line="25378">Frees the memory allocated for the #GPtrArray. If @free_seg is %TRUE
it frees the memory block holding the elements as well. Pass %FALSE
if you want to free the #GPtrArray wrapper but preserve the
underlying array for use elsewhere. If the reference count of @array
is greater than one, the #GPtrArray wrapper is preserved but the
size of @array will be set to zero.

If array contents point to dynamically-allocated memory, they should
be freed separately if @free_seg is %TRUE and no #GDestroyNotify
function has been set for @array.

This function is not thread-safe. If using a #GPtrArray from multiple
threads, use only the atomic g_ptr_array_ref() and g_ptr_array_unref()
functions.</doc>
        <source-position filename="garray.h" line="156" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="25398">the pointer array if @free_seg is %FALSE, otherwise %NULL.
    The pointer array should be freed using g_free().</doc>
          <type name="gpointer" c:type="gpointer*" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25380">a #GPtrArray</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.PtrArray" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="free_seg" transfer-ownership="none" gs:managed-name="freeSeg" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25381">if %TRUE the actual pointer array is freed as well</doc>
            <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25380">a #GPtrArray</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.PtrArray" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="free_seg" transfer-ownership="none" gs:managed-name="freeSeg" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25381">if %TRUE the actual pointer array is freed as well</doc>
            <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="insert" c:identifier="g_ptr_array_insert" version="2.40" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="Insert">
        <doc xml:space="preserve" filename="glib-2.0.c" line="25417">Inserts an element into the pointer array at the given index. The
array will grow in size automatically if necessary.</doc>
        <source-position filename="garray.h" line="202" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25419">a #GPtrArray</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.PtrArray" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="index_" transfer-ownership="none" gs:managed-name="index" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25420">the index to place the new element at, or -1 to append</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25421">the pointer to add.</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25419">a #GPtrArray</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.PtrArray" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="index_" transfer-ownership="none" gs:managed-name="index" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25420">the index to place the new element at, or -1 to append</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25421">the pointer to add.</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="new" c:identifier="g_ptr_array_new" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="New">
        <doc xml:space="preserve" filename="glib-2.0.c" line="25430">Creates a new #GPtrArray with a reference count of 1.</doc>
        <source-position filename="garray.h" line="140" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="25435">the new #GPtrArray</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.PtrArray" gs:is-pointer="1">
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </array>
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
      <function name="new_full" c:identifier="g_ptr_array_new_full" version="2.30" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="NewFull">
        <doc xml:space="preserve" filename="glib-2.0.c" line="25439">Creates a new #GPtrArray with @reserved_size pointers preallocated
and a reference count of 1. This avoids frequent reallocation, if
you are going to add many pointers to the array. Note however that
the size of the array is still 0. It also set @element_free_func
for freeing each element when the array is destroyed either via
g_ptr_array_unref(), when g_ptr_array_free() is called with
@free_segment set to %TRUE or when removing elements.</doc>
        <source-position filename="garray.h" line="153" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="25453">A new #GPtrArray</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.PtrArray" gs:is-pointer="1">
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </array>
        </return-value>
        <parameters>
          <parameter name="reserved_size" transfer-ownership="none" gs:managed-name="reservedSize" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25441">number of pointers preallocated</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
          <parameter name="element_free_func" transfer-ownership="none" nullable="1" allow-none="1" scope="async" gs:managed-name="elementFreeFunc" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25442">A function to free elements with
    destroy @array or %NULL</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify" gs:managed-name="DestroyNotify" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="reserved_size" transfer-ownership="none" gs:managed-name="reservedSize" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25441">number of pointers preallocated</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
          <parameter name="element_free_func" transfer-ownership="none" nullable="1" allow-none="1" scope="async" gs:managed-name="elementFreeFunc" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25442">A function to free elements with
    destroy @array or %NULL</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify" gs:managed-name="DestroyNotify" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="new_with_free_func" c:identifier="g_ptr_array_new_with_free_func" version="2.22" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="NewWithFreeFunc">
        <doc xml:space="preserve" filename="glib-2.0.c" line="25458">Creates a new #GPtrArray with a reference count of 1 and use
@element_free_func for freeing each element when the array is destroyed
either via g_ptr_array_unref(), when g_ptr_array_free() is called with
@free_segment set to %TRUE or when removing elements.</doc>
        <source-position filename="garray.h" line="142" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="25468">A new #GPtrArray</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.PtrArray" gs:is-pointer="1">
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </array>
        </return-value>
        <parameters>
          <parameter name="element_free_func" transfer-ownership="none" nullable="1" allow-none="1" scope="async" gs:managed-name="elementFreeFunc" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25460">A function to free elements with
    destroy @array or %NULL</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify" gs:managed-name="DestroyNotify" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="element_free_func" transfer-ownership="none" nullable="1" allow-none="1" scope="async" gs:managed-name="elementFreeFunc" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25460">A function to free elements with
    destroy @array or %NULL</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify" gs:managed-name="DestroyNotify" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <method name="ref" c:identifier="g_ptr_array_ref" version="2.22" introspectable="1" gs:dll-name="glib-2.0" gs:managed-name="Ref" gs:special-func="ref" gs:pinvoke-only="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="25473">Atomically increments the reference count of @array by one.
This function is thread-safe and may be called from any thread.</doc>
        <source-position filename="garray.h" line="159" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="25480">The passed in #GPtrArray</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.PtrArray" gs:is-pointer="1">
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25475">a #GPtrArray</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.PtrArray" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <function name="remove" c:identifier="g_ptr_array_remove" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="Remove">
        <doc xml:space="preserve" filename="glib-2.0.c" line="25485">Removes the first occurrence of the given pointer from the pointer
array. The following elements are moved down one place. If @array
has a non-%NULL #GDestroyNotify function it is called for the
removed element.

It returns %TRUE if the pointer was removed, or %FALSE if the
pointer was not found.</doc>
        <source-position filename="garray.h" line="181" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="25498">%TRUE if the pointer is removed, %FALSE if the pointer
    is not found in the array</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25487">a #GPtrArray</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.PtrArray" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25488">the pointer to remove</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25487">a #GPtrArray</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.PtrArray" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25488">the pointer to remove</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="remove_fast" c:identifier="g_ptr_array_remove_fast" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="RemoveFast">
        <doc xml:space="preserve" filename="glib-2.0.c" line="25503">Removes the first occurrence of the given pointer from the pointer
array. The last element in the array is used to fill in the space,
so this function does not preserve the order of the array. But it
is faster than g_ptr_array_remove(). If @array has a non-%NULL
#GDestroyNotify function it is called for the removed element.

It returns %TRUE if the pointer was removed, or %FALSE if the
pointer was not found.</doc>
        <source-position filename="garray.h" line="184" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="25517">%TRUE if the pointer was found in the array</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25505">a #GPtrArray</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.PtrArray" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25506">the pointer to remove</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25505">a #GPtrArray</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.PtrArray" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25506">the pointer to remove</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="remove_index" c:identifier="g_ptr_array_remove_index" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="RemoveIndex">
        <doc xml:space="preserve" filename="glib-2.0.c" line="25521">Removes the pointer at the given index from the pointer array.
The following elements are moved down one place. If @array has
a non-%NULL #GDestroyNotify function it is called for the removed
element. If so, the return value from this function will potentially point
to freed memory (depending on the #GDestroyNotify implementation).</doc>
        <source-position filename="garray.h" line="169" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="25532">the pointer which was removed</doc>
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25523">a #GPtrArray</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.PtrArray" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="index_" transfer-ownership="none" gs:managed-name="index" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25524">the index of the pointer to remove</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25523">a #GPtrArray</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.PtrArray" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="index_" transfer-ownership="none" gs:managed-name="index" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25524">the index of the pointer to remove</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="remove_index_fast" c:identifier="g_ptr_array_remove_index_fast" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="RemoveIndexFast">
        <doc xml:space="preserve" filename="glib-2.0.c" line="25536">Removes the pointer at the given index from the pointer array.
The last element in the array is used to fill in the space, so
this function does not preserve the order of the array. But it
is faster than g_ptr_array_remove_index(). If @array has a non-%NULL
#GDestroyNotify function it is called for the removed element. If so, the
return value from this function will potentially point to freed memory
(depending on the #GDestroyNotify implementation).</doc>
        <source-position filename="garray.h" line="172" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="25549">the pointer which was removed</doc>
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25538">a #GPtrArray</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.PtrArray" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="index_" transfer-ownership="none" gs:managed-name="index" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25539">the index of the pointer to remove</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25538">a #GPtrArray</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.PtrArray" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="index_" transfer-ownership="none" gs:managed-name="index" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25539">the index of the pointer to remove</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="remove_range" c:identifier="g_ptr_array_remove_range" version="2.4" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="RemoveRange">
        <doc xml:space="preserve" filename="glib-2.0.c" line="25553">Removes the given number of pointers starting at the given index
from a #GPtrArray. The following elements are moved to close the
gap. If @array has a non-%NULL #GDestroyNotify function it is
called for the removed elements.</doc>
        <source-position filename="garray.h" line="187" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="25564">the @array</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.PtrArray" gs:is-pointer="1">
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </array>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25555">a @GPtrArray</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.PtrArray" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="index_" transfer-ownership="none" gs:managed-name="index" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25556">the index of the first pointer to remove</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
          <parameter name="length" transfer-ownership="none" gs:managed-name="length" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25557">the number of pointers to remove</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25555">a @GPtrArray</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.PtrArray" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="index_" transfer-ownership="none" gs:managed-name="index" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25556">the index of the first pointer to remove</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
          <parameter name="length" transfer-ownership="none" gs:managed-name="length" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25557">the number of pointers to remove</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="set_free_func" c:identifier="g_ptr_array_set_free_func" version="2.22" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="SetFreeFunc">
        <doc xml:space="preserve" filename="glib-2.0.c" line="25569">Sets a function for freeing each element when @array is destroyed
either via g_ptr_array_unref(), when g_ptr_array_free() is called
with @free_segment set to %TRUE or when removing elements.</doc>
        <source-position filename="garray.h" line="163" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25571">A #GPtrArray</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.PtrArray" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="element_free_func" transfer-ownership="none" nullable="1" allow-none="1" scope="async" gs:managed-name="elementFreeFunc" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25572">A function to free elements with
    destroy @array or %NULL</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify" gs:managed-name="DestroyNotify" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25571">A #GPtrArray</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.PtrArray" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="element_free_func" transfer-ownership="none" nullable="1" allow-none="1" scope="async" gs:managed-name="elementFreeFunc" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25572">A function to free elements with
    destroy @array or %NULL</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify" gs:managed-name="DestroyNotify" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="set_size" c:identifier="g_ptr_array_set_size" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="SetSize">
        <doc xml:space="preserve" filename="glib-2.0.c" line="25583">Sets the size of the array. When making the array larger,
newly-added elements will be set to %NULL. When making it smaller,
if @array has a non-%NULL #GDestroyNotify function then it will be
called for the removed elements.</doc>
        <source-position filename="garray.h" line="166" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25585">a #GPtrArray</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.PtrArray" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none" gs:managed-name="length" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25586">the new length of the pointer array</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25585">a #GPtrArray</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.PtrArray" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none" gs:managed-name="length" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25586">the new length of the pointer array</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="sized_new" c:identifier="g_ptr_array_sized_new" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="SizedNew">
        <doc xml:space="preserve" filename="glib-2.0.c" line="25595">Creates a new #GPtrArray with @reserved_size pointers preallocated
and a reference count of 1. This avoids frequent reallocation, if
you are going to add many pointers to the array. Note however that
the size of the array is still 0.</doc>
        <source-position filename="garray.h" line="151" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="25604">the new #GPtrArray</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.PtrArray" gs:is-pointer="1">
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </array>
        </return-value>
        <parameters>
          <parameter name="reserved_size" transfer-ownership="none" gs:managed-name="reservedSize" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25597">number of pointers preallocated</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="reserved_size" transfer-ownership="none" gs:managed-name="reservedSize" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25597">number of pointers preallocated</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="sort" c:identifier="g_ptr_array_sort" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="Sort">
        <doc xml:space="preserve" filename="glib-2.0.c" line="25608">Sorts the array, using @compare_func which should be a qsort()-style
comparison function (returns less than zero for first arg is less
than second arg, zero for equal, greater than zero if irst arg is
greater than second arg).

Note that the comparison function for g_ptr_array_sort() doesn't
take the pointers from the array as arguments, it takes pointers to
the pointers in the array. Here is a full example of usage:

|[&lt;!-- language="C" --&gt;
typedef struct
{
  gchar *name;
  gint size;
} FileListEntry;

static gint
sort_filelist (gconstpointer a, gconstpointer b)
{
  const FileListEntry *entry1 = *((FileListEntry **) a);
  const FileListEntry *entry2 = *((FileListEntry **) b);

  return g_ascii_strcasecmp (entry1-&gt;name, entry2-&gt;name);
}

…
g_autoptr (GPtrArray) file_list = NULL;

// initialize file_list array and load with many FileListEntry entries
...
// now sort it with
g_ptr_array_sort (file_list, sort_filelist);
]|

This is guaranteed to be a stable sort since version 2.32.</doc>
        <source-position filename="garray.h" line="206" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25610">a #GPtrArray</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.PtrArray" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="compare_func" transfer-ownership="none" gs:managed-name="compareFunc" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25611">comparison function</doc>
            <type name="CompareFunc" c:type="GCompareFunc" gs:managed-name="CompareFunc" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25610">a #GPtrArray</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.PtrArray" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="compare_func" transfer-ownership="none" gs:managed-name="compareFunc" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25611">comparison function</doc>
            <type name="CompareFunc" c:type="GCompareFunc" gs:managed-name="CompareFunc" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="sort_with_data" c:identifier="g_ptr_array_sort_with_data" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="SortWithData">
        <doc xml:space="preserve" filename="glib-2.0.c" line="25651">Like g_ptr_array_sort(), but the comparison function has an extra
user data argument.

Note that the comparison function for g_ptr_array_sort_with_data()
doesn't take the pointers from the array as arguments, it takes
pointers to the pointers in the array. Here is a full example of use:

|[&lt;!-- language="C" --&gt;
typedef enum { SORT_NAME, SORT_SIZE } SortMode;

typedef struct
{
  gchar *name;
  gint size;
} FileListEntry;

static gint
sort_filelist (gconstpointer a, gconstpointer b, gpointer user_data)
{
  gint order;
  const SortMode sort_mode = GPOINTER_TO_INT (user_data);
  const FileListEntry *entry1 = *((FileListEntry **) a);
  const FileListEntry *entry2 = *((FileListEntry **) b);

  switch (sort_mode)
    {
    case SORT_NAME:
      order = g_ascii_strcasecmp (entry1-&gt;name, entry2-&gt;name);
      break;
    case SORT_SIZE:
      order = entry1-&gt;size - entry2-&gt;size;
      break;
    default:
      order = 0;
      break;
    }
  return order;
}

...
g_autoptr (GPtrArray) file_list = NULL;
SortMode sort_mode;

// initialize file_list array and load with many FileListEntry entries
...
// now sort it with
sort_mode = SORT_NAME;
g_ptr_array_sort_with_data (file_list,
                            sort_filelist,
                            GINT_TO_POINTER (sort_mode));
]|

This is guaranteed to be a stable sort since version 2.32.</doc>
        <source-position filename="garray.h" line="209" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25653">a #GPtrArray</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.PtrArray" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="compare_func" transfer-ownership="none" closure="2" gs:managed-name="compareFunc" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25654">comparison function</doc>
            <type name="CompareDataFunc" c:type="GCompareDataFunc" gs:managed-name="CompareDataFunc" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25655">data to pass to @compare_func</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25653">a #GPtrArray</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.PtrArray" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="compare_func" transfer-ownership="none" closure="2" gs:managed-name="compareFunc" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25654">comparison function</doc>
            <type name="CompareDataFunc" c:type="GCompareDataFunc" gs:managed-name="CompareDataFunc" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="steal" c:identifier="g_ptr_array_steal" version="2.64" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="Steal">
        <doc xml:space="preserve" filename="glib-2.0.c" line="25713">Frees the data in the array and resets the size to zero, while
the underlying array is preserved for use elsewhere and returned
to the caller.

Even if set, the #GDestroyNotify function will never be called
on the current contents of the array and the caller is
responsible for freeing the array elements.

An example of use:
|[&lt;!-- language="C" --&gt;
g_autoptr(GPtrArray) chunk_buffer = g_ptr_array_new_with_free_func (g_bytes_unref);

// Some part of your application appends a number of chunks to the pointer array.
g_ptr_array_add (chunk_buffer, g_bytes_new_static ("hello", 5));
g_ptr_array_add (chunk_buffer, g_bytes_new_static ("world", 5));

…

// Periodically, the chunks need to be sent as an array-and-length to some
// other part of the program.
GBytes **chunks;
gsize n_chunks;

chunks = g_ptr_array_steal (chunk_buffer, &amp;n_chunks);
for (gsize i = 0; i &lt; n_chunks; i++)
  {
    // Do something with each chunk here, and then free them, since
    // g_ptr_array_steal() transfers ownership of all the elements and the
    // array to the caller.
    …

    g_bytes_unref (chunks[i]);
  }

g_free (chunks);

// After calling g_ptr_array_steal(), the pointer array can be reused for the
// next set of chunks.
g_assert (chunk_buffer-&gt;len == 0);
]|</doc>
        <source-position filename="garray.h" line="144" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="25760">the element data, which should be
    freed using g_free().</doc>
          <type name="gpointer" c:type="gpointer*" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25715">a #GPtrArray.</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.PtrArray" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="len" direction="out" caller-allocates="1" transfer-ownership="none" optional="1" allow-none="1" gs:managed-name="len">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25716">pointer to retrieve the number of
   elements of the original array</doc>
            <type name="gsize" c:type="gsize*" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25715">a #GPtrArray.</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.PtrArray" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="len" direction="out" caller-allocates="1" transfer-ownership="none" optional="1" allow-none="1" gs:managed-name="len">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25716">pointer to retrieve the number of
   elements of the original array</doc>
            <type name="gsize" c:type="gsize*" gs:managed-name="System.Int32" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="steal_index" c:identifier="g_ptr_array_steal_index" version="2.58" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="StealIndex">
        <doc xml:space="preserve" filename="glib-2.0.c" line="25766">Removes the pointer at the given index from the pointer array.
The following elements are moved down one place. The #GDestroyNotify for
@array is *not* called on the removed element; ownership is transferred to
the caller of this function.</doc>
        <source-position filename="garray.h" line="175" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="25776">the pointer which was removed</doc>
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25768">a #GPtrArray</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.PtrArray" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="index_" transfer-ownership="none" gs:managed-name="index" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25769">the index of the pointer to steal</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25768">a #GPtrArray</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.PtrArray" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="index_" transfer-ownership="none" gs:managed-name="index" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25769">the index of the pointer to steal</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="steal_index_fast" c:identifier="g_ptr_array_steal_index_fast" version="2.58" introspectable="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="StealIndexFast">
        <doc xml:space="preserve" filename="glib-2.0.c" line="25781">Removes the pointer at the given index from the pointer array.
The last element in the array is used to fill in the space, so
this function does not preserve the order of the array. But it
is faster than g_ptr_array_steal_index(). The #GDestroyNotify for @array is
*not* called on the removed element; ownership is transferred to the caller
of this function.</doc>
        <source-position filename="garray.h" line="178" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="25793">the pointer which was removed</doc>
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25783">a #GPtrArray</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.PtrArray" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="index_" transfer-ownership="none" gs:managed-name="index" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25784">the index of the pointer to steal</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25783">a #GPtrArray</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.PtrArray" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="index_" transfer-ownership="none" gs:managed-name="index" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25784">the index of the pointer to steal</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <method name="unref" c:identifier="g_ptr_array_unref" version="2.22" introspectable="1" gs:dll-name="glib-2.0" gs:managed-name="Unref" gs:special-func="unref" gs:pinvoke-only="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="25798">Atomically decrements the reference count of @array by one. If the
reference count drops to 0, the effect is the same as calling
g_ptr_array_free() with @free_segment set to %TRUE. This function
is thread-safe and may be called from any thread.</doc>
        <source-position filename="garray.h" line="161" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none" gs:managed-name="array" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="25800">A #GPtrArray</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*" zero-terminated="1" gs:managed-name="GISharp.Lib.GLib.PtrArray" gs:is-pointer="1">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </array>
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_ptr_array_get_type" gs:access-modifiers="private" gs:dll-name="gobject-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </record>
    <enumeration name="SeekType" c:type="GSeekType" gs:managed-name="SeekType">
      <doc xml:space="preserve" filename="glib-2.0.c" line="1816">An enumeration specifying the base position for a
g_io_channel_seek_position() operation.</doc>
      <source-position filename="giochannel.h" line="82" />
      <member name="current" value="0" c:identifier="G_SEEK_CUR" gs:managed-name="Current">
        <doc xml:space="preserve" filename="glib-2.0.c" line="1818">the current position in the file.</doc>
      </member>
      <member name="start" value="1" c:identifier="G_SEEK_SET" gs:managed-name="Start">
        <doc xml:space="preserve" filename="glib-2.0.c" line="1819">the start of the file.</doc>
      </member>
      <member name="end" value="2" c:identifier="G_SEEK_END" gs:managed-name="End">
        <doc xml:space="preserve" filename="glib-2.0.c" line="1820">the end of the file.</doc>
      </member>
    </enumeration>
    <record name="Source" c:type="GSource" glib:type-name="GSource" glib:get-type="g_source_get_type" c:symbol-prefix="source" gs:managed-name="Source">
      <doc xml:space="preserve" filename="gmain.h" line="58">The `GSource` struct is an opaque data type
representing an event source.</doc>
      <source-position filename="gmain.h" line="244" />
      <field name="callback_data" readable="0" private="1" gs:managed-name="CallbackData">
        <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
      </field>
      <field name="callback_funcs" readable="0" private="1" gs:managed-name="CallbackFuncs">
        <type name="SourceCallbackFuncs" c:type="GSourceCallbackFuncs*" gs:managed-name="SourceCallbackFuncs" gs:is-pointer="1" />
      </field>
      <field name="source_funcs" readable="0" private="1" gs:managed-name="SourceFuncs">
        <type name="SourceFuncs" c:type="const GSourceFuncs*" gs:managed-name="SourceFuncs" gs:is-pointer="1" />
      </field>
      <field name="ref_count" readable="0" private="1" gs:managed-name="RefCount">
        <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
      </field>
      <field name="context" readable="0" private="1" gs:managed-name="Context">
        <type name="MainContext" c:type="GMainContext*" gs:managed-name="MainContext" gs:is-pointer="1" />
      </field>
      <field name="priority" readable="0" private="1" gs:managed-name="Priority">
        <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
      </field>
      <field name="flags" readable="0" private="1" gs:managed-name="Flags">
        <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
      </field>
      <field name="source_id" readable="0" private="1" gs:managed-name="SourceId">
        <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
      </field>
      <field name="poll_fds" readable="0" private="1" gs:managed-name="PollFds">
        <type name="GLib.SList" c:type="GSList*" gs:managed-name="GISharp.Lib.GLib.SList" gs:is-pointer="1">
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </type>
      </field>
      <field name="prev" readable="0" private="1" gs:managed-name="Prev">
        <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
      </field>
      <field name="next" readable="0" private="1" gs:managed-name="Next">
        <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
      </field>
      <field name="name" readable="0" private="1" gs:managed-name="Name">
        <type name="utf8" c:type="char*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
      </field>
      <field name="priv" readable="0" private="1" gs:managed-name="Priv">
        <type name="SourcePrivate" c:type="GSourcePrivate*" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
      </field>
      <constructor name="new" c:identifier="g_source_new" gs:dll-name="glib-2.0" gs:managed-name="New">
        <doc xml:space="preserve" filename="glib-2.0.c" line="30090">Creates a new #GSource structure. The size is specified to
allow creating structures derived from #GSource that contain
additional data. The size passed in must be at least
`sizeof (GSource)`.

The source will not initially be associated with any #GMainContext
and must be added to one with g_source_attach() before it will be
executed.</doc>
        <source-position filename="gmain.h" line="553" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="30105">the newly-created #GSource.</doc>
          <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="source_funcs" transfer-ownership="none" gs:managed-name="sourceFuncs" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30092">structure containing functions that implement
               the sources behavior.</doc>
            <type name="SourceFuncs" c:type="GSourceFuncs*" gs:managed-name="SourceFuncs" gs:is-pointer="1" />
          </parameter>
          <parameter name="struct_size" transfer-ownership="none" gs:managed-name="structSize" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30094">size of the #GSource structure to create.</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="source_funcs" transfer-ownership="none" gs:managed-name="sourceFuncs" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30092">structure containing functions that implement
               the sources behavior.</doc>
            <type name="SourceFuncs" c:type="GSourceFuncs*" gs:managed-name="SourceFuncs" gs:is-pointer="1" />
          </parameter>
          <parameter name="struct_size" transfer-ownership="none" gs:managed-name="structSize" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30094">size of the #GSource structure to create.</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <method name="add_child_source" c:identifier="g_source_add_child_source" version="2.28" gs:dll-name="glib-2.0" gs:managed-name="AddChildSource">
        <doc xml:space="preserve" filename="glib-2.0.c" line="29773">Adds @child_source to @source as a "polled" source; when @source is
added to a #GMainContext, @child_source will be automatically added
with the same priority, when @child_source is triggered, it will
cause @source to dispatch (in addition to calling its own
callback), and when @source is destroyed, it will destroy
@child_source as well. (@source will also still be dispatched if
its own prepare/check functions indicate that it is ready.)

If you don't need @child_source to do anything on its own when it
triggers, you can call g_source_set_dummy_callback() on it to set a
callback that does nothing (except return %TRUE if appropriate).

@source will hold a reference on @child_source while @child_source
is attached to it.

This API is only intended to be used by implementations of #GSource.
Do not call this API on a #GSource that you did not create.</doc>
        <source-position filename="gmain.h" line="647" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="29775">a #GSource</doc>
            <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="child_source" transfer-ownership="none" gs:managed-name="childSource" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="29776">a second #GSource that @source should "poll"</doc>
            <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="child_source" transfer-ownership="none" gs:managed-name="childSource" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="29776">a second #GSource that @source should "poll"</doc>
            <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="add_poll" c:identifier="g_source_add_poll" gs:dll-name="glib-2.0" gs:managed-name="AddPoll">
        <doc xml:space="preserve" filename="glib-2.0.c" line="29800">Adds a file descriptor to the set of file descriptors polled for
this source. This is usually combined with g_source_new() to add an
event source. The event source's check function will typically test
the @revents field in the #GPollFD struct and return %TRUE if events need
to be processed.

This API is only intended to be used by implementations of #GSource.
Do not call this API on a #GSource that you did not create.

Using this API forces the linear scanning of event sources on each
main loop iteration.  Newly-written event sources should try to use
g_source_add_unix_fd() instead of this API.</doc>
        <source-position filename="gmain.h" line="640" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="29802">a #GSource</doc>
            <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="fd" transfer-ownership="none" gs:managed-name="fd" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="29803">a #GPollFD structure holding information about a file
     descriptor to watch.</doc>
            <type name="PollFD" c:type="GPollFD*" gs:managed-name="PollFD" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="fd" transfer-ownership="none" gs:managed-name="fd" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="29803">a #GPollFD structure holding information about a file
     descriptor to watch.</doc>
            <type name="PollFD" c:type="GPollFD*" gs:managed-name="PollFD" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="add_unix_fd" c:identifier="g_source_add_unix_fd" version="2.36" gs:dll-name="glib-2.0" gs:managed-name="AddUnixFd">
        <doc xml:space="preserve" filename="glib-2.0.c" line="29821">Monitors @fd for the IO events in @events.

The tag returned by this function can be used to remove or modify the
monitoring of the fd using g_source_remove_unix_fd() or
g_source_modify_unix_fd().

It is not necessary to remove the fd before destroying the source; it
will be cleaned up automatically.

This API is only intended to be used by implementations of #GSource.
Do not call this API on a #GSource that you did not create.

As the name suggests, this function is not available on Windows.</doc>
        <source-position filename="gmain.h" line="618" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="29841">an opaque tag</doc>
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="29823">a #GSource</doc>
            <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="fd" transfer-ownership="none" gs:managed-name="fd" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="29824">the fd to monitor</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="events" transfer-ownership="none" gs:managed-name="events" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="29825">an event mask</doc>
            <type name="IOCondition" c:type="GIOCondition" gs:managed-name="IOCondition" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="fd" transfer-ownership="none" gs:managed-name="fd" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="29824">the fd to monitor</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="events" transfer-ownership="none" gs:managed-name="events" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="29825">an event mask</doc>
            <type name="IOCondition" c:type="GIOCondition" gs:managed-name="IOCondition" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="attach" c:identifier="g_source_attach" gs:dll-name="glib-2.0" gs:managed-name="Attach">
        <doc xml:space="preserve" filename="glib-2.0.c" line="29846">Adds a #GSource to a @context so that it will be executed within
that context. Remove it by calling g_source_destroy().

This function is safe to call from any thread, regardless of which thread
the @context is running in.</doc>
        <source-position filename="gmain.h" line="568" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="29857">the ID (greater than 0) for the source within the
  #GMainContext.</doc>
          <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="29848">a #GSource</doc>
            <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="context" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="context" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="29849">a #GMainContext (if %NULL, the default context will be used)</doc>
            <type name="MainContext" c:type="GMainContext*" gs:managed-name="MainContext" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="context" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="context" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="29849">a #GMainContext (if %NULL, the default context will be used)</doc>
            <type name="MainContext" c:type="GMainContext*" gs:managed-name="MainContext" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="destroy" c:identifier="g_source_destroy" gs:dll-name="glib-2.0" gs:managed-name="Destroy">
        <doc xml:space="preserve" filename="glib-2.0.c" line="29862">Removes a source from its #GMainContext, if any, and mark it as
destroyed.  The source cannot be subsequently added to another
context. It is safe to call this on sources which have already been
removed from their context.

This does not unref the #GSource: if you still hold a reference, use
g_source_unref() to drop it.

This function is safe to call from any thread, regardless of which thread
the #GMainContext is running in.</doc>
        <source-position filename="gmain.h" line="571" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="29864">a #GSource</doc>
            <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_can_recurse" gs:dll-name="glib-2.0" gs:managed-name="CanRecurse">
        <doc xml:space="preserve" filename="glib-2.0.c" line="29879">Checks whether a source is allowed to be called recursively.
see g_source_set_can_recurse().</doc>
        <source-position filename="gmain.h" line="582" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="29886">whether recursion is allowed.</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="29881">a #GSource</doc>
            <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_can_recurse" c:identifier="g_source_get_can_recurse" gs:dll-name="glib-2.0" gs:managed-name="GetCanRecurse" gs:property-getter-for="CanRecurse" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="29879">Checks whether a source is allowed to be called recursively.
see g_source_set_can_recurse().</doc>
        <source-position filename="gmain.h" line="582" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="29886">whether recursion is allowed.</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="29881">a #GSource</doc>
            <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_context" gs:dll-name="glib-2.0" gs:managed-name="Context">
        <doc xml:space="preserve" filename="glib-2.0.c" line="29890">Gets the #GMainContext with which the source is associated.

You can call this on a source that has been destroyed, provided
that the #GMainContext it was attached to still exists (in which
case it will return that #GMainContext). In particular, you can
always call this function on the source returned from
g_main_current_source(). But calling this function on a source
whose #GMainContext has been destroyed is an error.</doc>
        <source-position filename="gmain.h" line="587" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="29903">the #GMainContext with which the
              source is associated, or %NULL if the context has not
              yet been added to a source.</doc>
          <type name="MainContext" c:type="GMainContext*" gs:managed-name="MainContext" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="29892">a #GSource</doc>
            <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_context" c:identifier="g_source_get_context" gs:dll-name="glib-2.0" gs:managed-name="GetContext" gs:property-getter-for="Context" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="29890">Gets the #GMainContext with which the source is associated.

You can call this on a source that has been destroyed, provided
that the #GMainContext it was attached to still exists (in which
case it will return that #GMainContext). In particular, you can
always call this function on the source returned from
g_main_current_source(). But calling this function on a source
whose #GMainContext has been destroyed is an error.</doc>
        <source-position filename="gmain.h" line="587" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="29903">the #GMainContext with which the
              source is associated, or %NULL if the context has not
              yet been added to a source.</doc>
          <type name="MainContext" c:type="GMainContext*" gs:managed-name="MainContext" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="29892">a #GSource</doc>
            <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="get_current_time" c:identifier="g_source_get_current_time" deprecated="1" deprecated-version="2.28" gs:dll-name="glib-2.0" gs:managed-name="GetCurrentTime">
        <doc xml:space="preserve" filename="glib-2.0.c" line="29909">This function ignores @source and is otherwise the same as
g_get_current_time().</doc>
        <doc-deprecated xml:space="preserve">use g_source_get_time() instead</doc-deprecated>
        <source-position filename="gmain.h" line="655" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="29911">a #GSource</doc>
            <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="timeval" transfer-ownership="none" gs:managed-name="timeval" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="29912">#GTimeVal structure in which to store current time.</doc>
            <type name="TimeVal" c:type="GTimeVal*" gs:managed-name="TimeVal" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="timeval" transfer-ownership="none" gs:managed-name="timeval" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="29912">#GTimeVal structure in which to store current time.</doc>
            <type name="TimeVal" c:type="GTimeVal*" gs:managed-name="TimeVal" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <gs:managed-property name="get_id" gs:dll-name="glib-2.0" gs:managed-name="Id">
        <doc xml:space="preserve" filename="glib-2.0.c" line="29921">Returns the numeric ID for a particular source. The ID of a source
is a positive integer which is unique within a particular main loop
context. The reverse
mapping from ID to source is done by g_main_context_find_source_by_id().

You can only call this function while the source is associated to a
#GMainContext instance; calling this function before g_source_attach()
or after g_source_destroy() yields undefined behavior. The ID returned
is unique within the #GMainContext instance passed to g_source_attach().</doc>
        <source-position filename="gmain.h" line="584" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="29935">the ID (greater than 0) for the source</doc>
          <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="29923">a #GSource</doc>
            <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_id" c:identifier="g_source_get_id" gs:dll-name="glib-2.0" gs:managed-name="GetId" gs:property-getter-for="Id" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="29921">Returns the numeric ID for a particular source. The ID of a source
is a positive integer which is unique within a particular main loop
context. The reverse
mapping from ID to source is done by g_main_context_find_source_by_id().

You can only call this function while the source is associated to a
#GMainContext instance; calling this function before g_source_attach()
or after g_source_destroy() yields undefined behavior. The ID returned
is unique within the #GMainContext instance passed to g_source_attach().</doc>
        <source-position filename="gmain.h" line="584" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="29935">the ID (greater than 0) for the source</doc>
          <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="29923">a #GSource</doc>
            <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_name" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="Name">
        <doc xml:space="preserve" filename="glib-2.0.c" line="29939">Gets a name for the source, used in debugging and profiling.  The
name may be #NULL if it has never been set with g_source_set_name().</doc>
        <source-position filename="gmain.h" line="605" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="29946">the name of the source</doc>
          <type name="utf8" c:type="const char*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="29941">a #GSource</doc>
            <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_name" c:identifier="g_source_get_name" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="GetName" gs:property-getter-for="Name" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="29939">Gets a name for the source, used in debugging and profiling.  The
name may be #NULL if it has never been set with g_source_set_name().</doc>
        <source-position filename="gmain.h" line="605" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="29946">the name of the source</doc>
          <type name="utf8" c:type="const char*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="29941">a #GSource</doc>
            <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_priority" gs:dll-name="glib-2.0" gs:managed-name="Priority">
        <doc xml:space="preserve" filename="glib-2.0.c" line="29951">Gets the priority of a source.</doc>
        <source-position filename="gmain.h" line="577" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="29957">the priority of the source</doc>
          <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="29953">a #GSource</doc>
            <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_priority" c:identifier="g_source_get_priority" gs:dll-name="glib-2.0" gs:managed-name="GetPriority" gs:property-getter-for="Priority" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="29951">Gets the priority of a source.</doc>
        <source-position filename="gmain.h" line="577" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="29957">the priority of the source</doc>
          <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="29953">a #GSource</doc>
            <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_ready_time" gs:dll-name="glib-2.0" gs:managed-name="ReadyTime">
        <doc xml:space="preserve" filename="glib-2.0.c" line="29961">Gets the "ready time" of @source, as set by
g_source_set_ready_time().

Any time before the current monotonic time (including 0) is an
indication that the source will fire immediately.</doc>
        <source-position filename="gmain.h" line="614" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="29971">the monotonic ready time, -1 for "never"</doc>
          <type name="gint64" c:type="gint64" gs:managed-name="System.Int64" />
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="29963">a #GSource</doc>
            <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_ready_time" c:identifier="g_source_get_ready_time" gs:dll-name="glib-2.0" gs:managed-name="GetReadyTime" gs:property-getter-for="ReadyTime" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="29961">Gets the "ready time" of @source, as set by
g_source_set_ready_time().

Any time before the current monotonic time (including 0) is an
indication that the source will fire immediately.</doc>
        <source-position filename="gmain.h" line="614" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="29971">the monotonic ready time, -1 for "never"</doc>
          <type name="gint64" c:type="gint64" gs:managed-name="System.Int64" />
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="29963">a #GSource</doc>
            <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_time" version="2.28" gs:dll-name="glib-2.0" gs:managed-name="Time">
        <doc xml:space="preserve" filename="glib-2.0.c" line="29975">Gets the time to be used when checking this source. The advantage of
calling this function over calling g_get_monotonic_time() directly is
that when checking multiple sources, GLib can cache a single value
instead of having to repeatedly get the system monotonic time.

The time here is the system monotonic time, if available, or some
other reasonable alternative otherwise.  See g_get_monotonic_time().</doc>
        <source-position filename="gmain.h" line="660" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="29987">the monotonic time in microseconds</doc>
          <type name="gint64" c:type="gint64" gs:managed-name="System.Int64" />
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="29977">a #GSource</doc>
            <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_time" c:identifier="g_source_get_time" version="2.28" gs:dll-name="glib-2.0" gs:managed-name="GetTime" gs:property-getter-for="Time" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="29975">Gets the time to be used when checking this source. The advantage of
calling this function over calling g_get_monotonic_time() directly is
that when checking multiple sources, GLib can cache a single value
instead of having to repeatedly get the system monotonic time.

The time here is the system monotonic time, if available, or some
other reasonable alternative otherwise.  See g_get_monotonic_time().</doc>
        <source-position filename="gmain.h" line="660" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="29987">the monotonic time in microseconds</doc>
          <type name="gint64" c:type="gint64" gs:managed-name="System.Int64" />
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="29977">a #GSource</doc>
            <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="is_destroyed" version="2.12" gs:dll-name="glib-2.0" gs:managed-name="IsDestroyed">
        <doc xml:space="preserve" filename="glib-2.0.c" line="29992">Returns whether @source has been destroyed.

This is important when you operate upon your objects
from within idle handlers, but may have freed the object
before the dispatch of your idle handler.

|[&lt;!-- language="C" --&gt;
static gboolean
idle_callback (gpointer data)
{
  SomeWidget *self = data;
   
  GDK_THREADS_ENTER ();
  // do stuff with self
  self-&gt;idle_id = 0;
  GDK_THREADS_LEAVE ();
   
  return G_SOURCE_REMOVE;
}
 
static void
some_widget_do_stuff_later (SomeWidget *self)
{
  self-&gt;idle_id = g_idle_add (idle_callback, self);
}
 
static void
some_widget_finalize (GObject *object)
{
  SomeWidget *self = SOME_WIDGET (object);
   
  if (self-&gt;idle_id)
    g_source_remove (self-&gt;idle_id);
   
  G_OBJECT_CLASS (parent_class)-&gt;finalize (object);
}
]|

This will fail in a multi-threaded application if the
widget is destroyed before the idle handler fires due
to the use after free in the callback. A solution, to
this particular problem, is to check to if the source
has already been destroy within the callback.

|[&lt;!-- language="C" --&gt;
static gboolean
idle_callback (gpointer data)
{
  SomeWidget *self = data;
  
  GDK_THREADS_ENTER ();
  if (!g_source_is_destroyed (g_main_current_source ()))
    {
      // do stuff with self
    }
  GDK_THREADS_LEAVE ();
  
  return FALSE;
}
]|

Calls to this function from a thread other than the one acquired by the
#GMainContext the #GSource is attached to are typically redundant, as the
source could be destroyed immediately after this function returns. However,
once a source is destroyed it cannot be un-destroyed, so this function can be
used for opportunistic checks from any thread.</doc>
        <source-position filename="gmain.h" line="599" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="30063">%TRUE if the source has been destroyed</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="29994">a #GSource</doc>
            <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="is_destroyed" c:identifier="g_source_is_destroyed" version="2.12" gs:dll-name="glib-2.0" gs:managed-name="GetIsDestroyed" gs:property-getter-for="IsDestroyed" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="29992">Returns whether @source has been destroyed.

This is important when you operate upon your objects
from within idle handlers, but may have freed the object
before the dispatch of your idle handler.

|[&lt;!-- language="C" --&gt;
static gboolean
idle_callback (gpointer data)
{
  SomeWidget *self = data;
   
  GDK_THREADS_ENTER ();
  // do stuff with self
  self-&gt;idle_id = 0;
  GDK_THREADS_LEAVE ();
   
  return G_SOURCE_REMOVE;
}
 
static void
some_widget_do_stuff_later (SomeWidget *self)
{
  self-&gt;idle_id = g_idle_add (idle_callback, self);
}
 
static void
some_widget_finalize (GObject *object)
{
  SomeWidget *self = SOME_WIDGET (object);
   
  if (self-&gt;idle_id)
    g_source_remove (self-&gt;idle_id);
   
  G_OBJECT_CLASS (parent_class)-&gt;finalize (object);
}
]|

This will fail in a multi-threaded application if the
widget is destroyed before the idle handler fires due
to the use after free in the callback. A solution, to
this particular problem, is to check to if the source
has already been destroy within the callback.

|[&lt;!-- language="C" --&gt;
static gboolean
idle_callback (gpointer data)
{
  SomeWidget *self = data;
  
  GDK_THREADS_ENTER ();
  if (!g_source_is_destroyed (g_main_current_source ()))
    {
      // do stuff with self
    }
  GDK_THREADS_LEAVE ();
  
  return FALSE;
}
]|

Calls to this function from a thread other than the one acquired by the
#GMainContext the #GSource is attached to are typically redundant, as the
source could be destroyed immediately after this function returns. However,
once a source is destroyed it cannot be un-destroyed, so this function can be
used for opportunistic checks from any thread.</doc>
        <source-position filename="gmain.h" line="599" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="30063">%TRUE if the source has been destroyed</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="29994">a #GSource</doc>
            <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="modify_unix_fd" c:identifier="g_source_modify_unix_fd" version="2.36" gs:dll-name="glib-2.0" gs:managed-name="ModifyUnixFd">
        <doc xml:space="preserve" filename="glib-2.0.c" line="30068">Updates the event mask to watch for the fd identified by @tag.

@tag is the tag returned from g_source_add_unix_fd().

If you want to remove a fd, don't set its event mask to zero.
Instead, call g_source_remove_unix_fd().

This API is only intended to be used by implementations of #GSource.
Do not call this API on a #GSource that you did not create.

As the name suggests, this function is not available on Windows.</doc>
        <source-position filename="gmain.h" line="622" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30070">a #GSource</doc>
            <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="tag" transfer-ownership="none" gs:managed-name="tag" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30071">the tag from g_source_add_unix_fd()</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
          <parameter name="new_events" transfer-ownership="none" gs:managed-name="newEvents" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30072">the new event mask to watch</doc>
            <type name="IOCondition" c:type="GIOCondition" gs:managed-name="IOCondition" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="tag" transfer-ownership="none" gs:managed-name="tag" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30071">the tag from g_source_add_unix_fd()</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
          <parameter name="new_events" transfer-ownership="none" gs:managed-name="newEvents" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30072">the new event mask to watch</doc>
            <type name="IOCondition" c:type="GIOCondition" gs:managed-name="IOCondition" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="query_unix_fd" c:identifier="g_source_query_unix_fd" version="2.36" gs:dll-name="glib-2.0" gs:managed-name="QueryUnixFd">
        <doc xml:space="preserve" filename="glib-2.0.c" line="30109">Queries the events reported for the fd corresponding to @tag on
@source during the last poll.

The return value of this function is only defined when the function
is called from the check or dispatch functions for @source.

This API is only intended to be used by implementations of #GSource.
Do not call this API on a #GSource that you did not create.

As the name suggests, this function is not available on Windows.</doc>
        <source-position filename="gmain.h" line="629" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="30125">the conditions reported on the fd</doc>
          <type name="IOCondition" c:type="GIOCondition" gs:managed-name="IOCondition" />
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30111">a #GSource</doc>
            <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="tag" transfer-ownership="none" gs:managed-name="tag" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30112">the tag from g_source_add_unix_fd()</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="tag" transfer-ownership="none" gs:managed-name="tag" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30112">the tag from g_source_add_unix_fd()</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="ref" c:identifier="g_source_ref" gs:dll-name="glib-2.0" gs:managed-name="Ref" gs:special-func="ref" gs:pinvoke-only="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="30130">Increases the reference count on a source by one.</doc>
        <source-position filename="gmain.h" line="563" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="30136">@source</doc>
          <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30132">a #GSource</doc>
            <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="remove_child_source" c:identifier="g_source_remove_child_source" version="2.28" gs:dll-name="glib-2.0" gs:managed-name="RemoveChildSource">
        <doc xml:space="preserve" filename="glib-2.0.c" line="30193">Detaches @child_source from @source and destroys it.

This API is only intended to be used by implementations of #GSource.
Do not call this API on a #GSource that you did not create.</doc>
        <source-position filename="gmain.h" line="650" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30195">a #GSource</doc>
            <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="child_source" transfer-ownership="none" gs:managed-name="childSource" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30196">a #GSource previously passed to
    g_source_add_child_source().</doc>
            <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="child_source" transfer-ownership="none" gs:managed-name="childSource" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30196">a #GSource previously passed to
    g_source_add_child_source().</doc>
            <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="remove_poll" c:identifier="g_source_remove_poll" gs:dll-name="glib-2.0" gs:managed-name="RemovePoll">
        <doc xml:space="preserve" filename="glib-2.0.c" line="30208">Removes a file descriptor from the set of file descriptors polled for
this source.

This API is only intended to be used by implementations of #GSource.
Do not call this API on a #GSource that you did not create.</doc>
        <source-position filename="gmain.h" line="643" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30210">a #GSource</doc>
            <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="fd" transfer-ownership="none" gs:managed-name="fd" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30211">a #GPollFD structure previously passed to g_source_add_poll().</doc>
            <type name="PollFD" c:type="GPollFD*" gs:managed-name="PollFD" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="fd" transfer-ownership="none" gs:managed-name="fd" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30211">a #GPollFD structure previously passed to g_source_add_poll().</doc>
            <type name="PollFD" c:type="GPollFD*" gs:managed-name="PollFD" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="remove_unix_fd" c:identifier="g_source_remove_unix_fd" version="2.36" gs:dll-name="glib-2.0" gs:managed-name="RemoveUnixFd">
        <doc xml:space="preserve" filename="glib-2.0.c" line="30221">Reverses the effect of a previous call to g_source_add_unix_fd().

You only need to call this if you want to remove an fd from being
watched while keeping the same source around.  In the normal case you
will just want to destroy the source.

This API is only intended to be used by implementations of #GSource.
Do not call this API on a #GSource that you did not create.

As the name suggests, this function is not available on Windows.</doc>
        <source-position filename="gmain.h" line="626" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30223">a #GSource</doc>
            <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="tag" transfer-ownership="none" gs:managed-name="tag" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30224">the tag from g_source_add_unix_fd()</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="tag" transfer-ownership="none" gs:managed-name="tag" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30224">the tag from g_source_add_unix_fd()</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_callback" c:identifier="g_source_set_callback" gs:dll-name="glib-2.0" gs:managed-name="SetCallback">
        <doc xml:space="preserve" filename="glib-2.0.c" line="30241">Sets the callback function for a source. The callback for a source is
called from the source's dispatch function.

The exact type of @func depends on the type of source; ie. you
should not count on @func being called with @data as its first
parameter. Cast @func with G_SOURCE_FUNC() to avoid warnings about
incompatible function types.

See [memory management of sources][mainloop-memory-management] for details
on how to handle memory management of @data.

Typically, you won't use this function. Instead use functions specific
to the type of source you are using, such as g_idle_add() or g_timeout_add().

It is safe to call this function multiple times on a source which has already
been attached to a context. The changes will take effect for the next time
the source is dispatched after this call returns.</doc>
        <source-position filename="gmain.h" line="590" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30243">the source</doc>
            <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="func" transfer-ownership="none" scope="notified" closure="1" destroy="2" gs:managed-name="func" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30244">a callback function</doc>
            <type name="SourceFunc" c:type="GSourceFunc" gs:managed-name="SourceFunc" />
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30245">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
          <parameter name="notify" transfer-ownership="none" nullable="1" allow-none="1" scope="async" gs:managed-name="notify" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30246">a function to call when @data is no longer in use, or %NULL.</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify" gs:managed-name="DestroyNotify" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="func" transfer-ownership="none" scope="notified" closure="1" destroy="2" gs:managed-name="func" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30244">a callback function</doc>
            <type name="SourceFunc" c:type="GSourceFunc" gs:managed-name="SourceFunc" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_callback_indirect" c:identifier="g_source_set_callback_indirect" gs:dll-name="glib-2.0" gs:managed-name="SetCallbackIndirect">
        <doc xml:space="preserve" filename="glib-2.0.c" line="30268">Sets the callback function storing the data as a refcounted callback
"object". This is used internally. Note that calling
g_source_set_callback_indirect() assumes
an initial reference count on @callback_data, and thus
@callback_funcs-&gt;unref will eventually be called once more
than @callback_funcs-&gt;ref.

It is safe to call this function multiple times on a source which has already
been attached to a context. The changes will take effect for the next time
the source is dispatched after this call returns.</doc>
        <source-position filename="gmain.h" line="635" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30270">the source</doc>
            <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="callback_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="callbackData" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30271">pointer to callback data "object"</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback_funcs" transfer-ownership="none" gs:managed-name="callbackFuncs" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30272">functions for reference counting @callback_data
                 and getting the callback and data</doc>
            <type name="SourceCallbackFuncs" c:type="GSourceCallbackFuncs*" gs:managed-name="SourceCallbackFuncs" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="callback_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="callbackData" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30271">pointer to callback data "object"</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
          <parameter name="callback_funcs" transfer-ownership="none" gs:managed-name="callbackFuncs" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30272">functions for reference counting @callback_data
                 and getting the callback and data</doc>
            <type name="SourceCallbackFuncs" c:type="GSourceCallbackFuncs*" gs:managed-name="SourceCallbackFuncs" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_can_recurse" c:identifier="g_source_set_can_recurse" gs:dll-name="glib-2.0" gs:managed-name="SetCanRecurse" gs:property-setter-for="CanRecurse" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="30288">Sets whether a source can be called recursively. If @can_recurse is
%TRUE, then while the source is being dispatched then this source
will be processed normally. Otherwise, all processing of this
source is blocked until the dispatch function returns.</doc>
        <source-position filename="gmain.h" line="579" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30290">a #GSource</doc>
            <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="can_recurse" transfer-ownership="none" gs:managed-name="canRecurse" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30291">whether recursion is allowed for this source</doc>
            <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="can_recurse" transfer-ownership="none" gs:managed-name="canRecurse" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30291">whether recursion is allowed for this source</doc>
            <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_funcs" c:identifier="g_source_set_funcs" version="2.12" gs:dll-name="glib-2.0" gs:managed-name="SetFuncs">
        <doc xml:space="preserve" filename="glib-2.0.c" line="30326">Sets the source functions (can be used to override
default implementations) of an unattached source.</doc>
        <source-position filename="gmain.h" line="596" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30328">a #GSource</doc>
            <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="funcs" transfer-ownership="none" gs:managed-name="funcs" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30329">the new #GSourceFuncs</doc>
            <type name="SourceFuncs" c:type="GSourceFuncs*" gs:managed-name="SourceFuncs" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="funcs" transfer-ownership="none" gs:managed-name="funcs" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30329">the new #GSourceFuncs</doc>
            <type name="SourceFuncs" c:type="GSourceFuncs*" gs:managed-name="SourceFuncs" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_name" c:identifier="g_source_set_name" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="SetName" gs:property-setter-for="Name" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="30338">Sets a name for the source, used in debugging and profiling.
The name defaults to #NULL.

The source name should describe in a human-readable way
what the source does. For example, "X11 event queue"
or "GTK+ repaint idle handler" or whatever it is.

It is permitted to call this function multiple times, but is not
recommended due to the potential performance impact.  For example,
one could change the name in the "check" function of a #GSourceFuncs
to include details like the event type in the source name.

Use caution if changing the name while another thread may be
accessing it with g_source_get_name(); that function does not copy
the value, and changing the value will free it while the other thread
may be attempting to use it.</doc>
        <source-position filename="gmain.h" line="602" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30340">a #GSource</doc>
            <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30341">debug name for the source</doc>
            <type name="utf8" c:type="const char*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30341">debug name for the source</doc>
            <type name="utf8" c:type="const char*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_priority" c:identifier="g_source_set_priority" gs:dll-name="glib-2.0" gs:managed-name="SetPriority" gs:property-setter-for="Priority" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="30390">Sets the priority of a source. While the main loop is being run, a
source will be dispatched if it is ready to be dispatched and no
sources at a higher (numerically smaller) priority are ready to be
dispatched.

A child source always has the same priority as its parent.  It is not
permitted to change the priority of a source once it has been added
as a child of another source.</doc>
        <source-position filename="gmain.h" line="574" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30392">a #GSource</doc>
            <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="priority" transfer-ownership="none" gs:managed-name="priority" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30393">the new priority.</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="priority" transfer-ownership="none" gs:managed-name="priority" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30393">the new priority.</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_ready_time" c:identifier="g_source_set_ready_time" version="2.36" gs:dll-name="glib-2.0" gs:managed-name="SetReadyTime" gs:property-setter-for="ReadyTime" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="30406">Sets a #GSource to be dispatched when the given monotonic time is
reached (or passed).  If the monotonic time is in the past (as it
always will be if @ready_time is 0) then the source will be
dispatched immediately.

If @ready_time is -1 then the source is never woken up on the basis
of the passage of time.

Dispatching the source does not reset the ready time.  You should do
so yourself, from the source dispatch function.

Note that if you have a pair of sources where the ready time of one
suggests that it will be delivered first but the priority for the
other suggests that it would be delivered first, and the ready time
for both sources is reached during the same main context iteration,
then the order of dispatch is undefined.

It is a no-op to call this function on a #GSource which has already been
destroyed with g_source_destroy().

This API is only intended to be used by implementations of #GSource.
Do not call this API on a #GSource that you did not create.</doc>
        <source-position filename="gmain.h" line="611" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30408">a #GSource</doc>
            <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="ready_time" transfer-ownership="none" gs:managed-name="readyTime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30409">the monotonic time at which the source will be ready,
             0 for "immediately", -1 for "never"</doc>
            <type name="gint64" c:type="gint64" gs:managed-name="System.Int64" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="ready_time" transfer-ownership="none" gs:managed-name="readyTime" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30409">the monotonic time at which the source will be ready,
             0 for "immediately", -1 for "never"</doc>
            <type name="gint64" c:type="gint64" gs:managed-name="System.Int64" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="unref" c:identifier="g_source_unref" gs:dll-name="glib-2.0" gs:managed-name="Unref" gs:special-func="unref" gs:pinvoke-only="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="30439">Decreases the reference count of a source by one. If the
resulting reference count is zero the source and associated
memory will be destroyed.</doc>
        <source-position filename="gmain.h" line="565" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30441">a #GSource</doc>
            <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <function name="remove_by_id" c:identifier="g_source_remove" gs:dll-name="glib-2.0" gs:managed-name="RemoveById">
        <doc xml:space="preserve" filename="glib-2.0.c" line="30140">Removes the source with the given ID from the default main context. You must
use g_source_destroy() for sources added to a non-default main context.

The ID of a #GSource is given by g_source_get_id(), or will be
returned by the functions g_source_attach(), g_idle_add(),
g_idle_add_full(), g_timeout_add(), g_timeout_add_full(),
g_child_watch_add(), g_child_watch_add_full(), g_io_add_watch(), and
g_io_add_watch_full().

It is a programmer error to attempt to remove a non-existent source.

More specifically: source IDs can be reissued after a source has been
destroyed and therefore it is never valid to use this function with a
source ID which may have already been removed.  An example is when
scheduling an idle to run in another thread with g_idle_add(): the
idle may already have run and been removed by the time this function
is called on its (now invalid) source ID.  This source ID may have
been reissued, leading to the operation being performed against the
wrong source.</doc>
        <source-position filename="gmain.h" line="692" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="30164">For historical reasons, this function always returns %TRUE</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none" gs:managed-name="tag" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30142">the ID of the source to remove.</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="tag" transfer-ownership="none" gs:managed-name="tag" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30142">the ID of the source to remove.</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="remove_by_funcs_user_data" c:identifier="g_source_remove_by_funcs_user_data" gs:dll-name="glib-2.0" gs:managed-name="RemoveByFuncsUserData">
        <doc xml:space="preserve" filename="glib-2.0.c" line="30168">Removes a source from the default main loop context given the
source functions and user data. If multiple sources exist with the
same source functions and user data, only one will be destroyed.</doc>
        <source-position filename="gmain.h" line="696" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="30177">%TRUE if a source was found and removed.</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <parameter name="funcs" transfer-ownership="none" gs:managed-name="funcs" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30170">The @source_funcs passed to g_source_new()</doc>
            <type name="SourceFuncs" c:type="GSourceFuncs*" gs:managed-name="SourceFuncs" gs:is-pointer="1" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30171">the user data for the callback</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="funcs" transfer-ownership="none" gs:managed-name="funcs" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30170">The @source_funcs passed to g_source_new()</doc>
            <type name="SourceFuncs" c:type="GSourceFuncs*" gs:managed-name="SourceFuncs" gs:is-pointer="1" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30171">the user data for the callback</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="remove_by_user_data" c:identifier="g_source_remove_by_user_data" gs:dll-name="glib-2.0" gs:managed-name="RemoveByUserData">
        <doc xml:space="preserve" filename="glib-2.0.c" line="30181">Removes a source from the default main loop context given the user
data for the callback. If multiple sources exist with the same user
data, only one will be destroyed.</doc>
        <source-position filename="gmain.h" line="694" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="30189">%TRUE if a source was found and removed.</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30183">the user_data for the callback.</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30183">the user_data for the callback.</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="set_name_by_id" c:identifier="g_source_set_name_by_id" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="SetNameById">
        <doc xml:space="preserve" filename="glib-2.0.c" line="30364">Sets the name of a source using its ID.

This is a convenience utility to set source names from the return
value of g_idle_add(), g_timeout_add(), etc.

It is a programmer error to attempt to set the name of a non-existent
source.

More specifically: source IDs can be reissued after a source has been
destroyed and therefore it is never valid to use this function with a
source ID which may have already been removed.  An example is when
scheduling an idle to run in another thread with g_idle_add(): the
idle may already have run and been removed by the time this function
is called on its (now invalid) source ID.  This source ID may have
been reissued, leading to the operation being performed against the
wrong source.</doc>
        <source-position filename="gmain.h" line="607" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none" gs:managed-name="tag" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30366">a #GSource ID</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30367">debug name for the source</doc>
            <type name="utf8" c:type="const char*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="tag" transfer-ownership="none" gs:managed-name="tag" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30366">a #GSource ID</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="30367">debug name for the source</doc>
            <type name="utf8" c:type="const char*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <constant name="CONTINUE" value="true" c:type="G_SOURCE_CONTINUE" version="2.32" gs:managed-name="Continue">
        <doc xml:space="preserve" filename="gmain.h" line="343">Use this macro as the return value of a #GSourceFunc to leave
the #GSource in the main loop.</doc>
        <source-position filename="gmain.h" line="351" />
        <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
      </constant>
      <constant name="REMOVE" value="false" c:type="G_SOURCE_REMOVE" version="2.32" gs:managed-name="Remove">
        <doc xml:space="preserve" filename="gmain.h" line="333">Use this macro as the return value of a #GSourceFunc to remove
the #GSource from the main loop.</doc>
        <source-position filename="gmain.h" line="341" />
        <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
      </constant>
      <gs:managed-property name="get_current" version="2.12" gs:dll-name="glib-2.0" gs:managed-name="Current">
        <doc xml:space="preserve" filename="glib-2.0.c" line="22344">Returns the currently firing source for this thread.</doc>
        <source-position filename="gmain.h" line="434" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="22349">The currently firing source or %NULL.</doc>
          <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </gs:managed-property>
      <function name="get_current" c:identifier="g_main_current_source" version="2.12" gs:dll-name="glib-2.0" gs:managed-name="GetCurrent" gs:property-getter-for="Current" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="22344">Returns the currently firing source for this thread.</doc>
        <source-position filename="gmain.h" line="434" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="22349">The currently firing source or %NULL.</doc>
          <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_source_get_type" gs:access-modifiers="private" gs:dll-name="gobject-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </record>
    <record name="SourceCallbackFuncs" c:type="GSourceCallbackFuncs" gs:managed-name="SourceCallbackFuncs">
      <doc xml:space="preserve" filename="gmain.h" line="67">The `GSourceCallbackFuncs` struct contains
functions for managing callback objects.</doc>
      <source-position filename="gmain.h" line="254" />
      <field name="ref" gs:managed-name="Ref">
        <type name="ref" gs:dll-name="glib-2.0" gs:managed-name="Ref" />
        <callback name="ref" gs:dll-name="glib-2.0" gs:managed-name="Ref">
          <source-position filename="gmain.h" line="248" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" gs:managed-name="System.Void" />
          </return-value>
          <parameters>
            <parameter name="cb_data" transfer-ownership="none" gs:managed-name="cbData" direction="in">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="cb_data" transfer-ownership="none" gs:managed-name="cbData" direction="in">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="unref" gs:managed-name="Unref">
        <type name="unref" gs:dll-name="glib-2.0" gs:managed-name="Unref" />
        <callback name="unref" gs:dll-name="glib-2.0" gs:managed-name="Unref">
          <source-position filename="gmain.h" line="249" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" gs:managed-name="System.Void" />
          </return-value>
          <parameters>
            <parameter name="cb_data" transfer-ownership="none" gs:managed-name="cbData" direction="in">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="cb_data" transfer-ownership="none" gs:managed-name="cbData" direction="in">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="get" introspectable="1" gs:managed-name="Get">
        <type name="gpointer" introspectable="1" gs:dll-name="glib-2.0" gs:managed-name="System.IntPtr">
          <source-position filename="gmain.h" line="250" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" gs:managed-name="System.Void" />
          </return-value>
          <parameters>
            <parameter name="cb_data" transfer-ownership="none" gs:managed-name="cbData" direction="in">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </parameter>
            <parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
              <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
            </parameter>
            <parameter name="func" transfer-ownership="none" closure="3" gs:managed-name="func" direction="in">
              <type name="SourceFunc" c:type="GSourceFunc*" gs:managed-name="SourceFunc" gs:is-pointer="1" />
            </parameter>
            <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
              <type name="gpointer" c:type="gpointer*" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="cb_data" transfer-ownership="none" gs:managed-name="cbData" direction="in">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </parameter>
            <parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
              <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
            </parameter>
            <parameter name="func" transfer-ownership="none" closure="3" gs:managed-name="func" direction="in">
              <type name="SourceFunc" c:type="GSourceFunc*" gs:managed-name="SourceFunc" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </type>
      </field>
    </record>
    <callback name="SourceDummyMarshal" c:type="GSourceDummyMarshal" gs:dll-name="glib-2.0" gs:managed-name="SourceDummyMarshal">
      <doc xml:space="preserve" filename="gmain.h" line="256">This is just a placeholder for #GClosureMarshal,
which cannot be used here for dependency reasons.</doc>
      <source-position filename="gmain.h" line="262" />
      <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
        <type name="none" c:type="void" gs:managed-name="System.Void" />
      </return-value>
      <parameters />
      <gs:managed-parameters />
    </callback>
    <callback name="SourceFunc" c:type="GSourceFunc" gs:dll-name="glib-2.0" gs:managed-name="SourceFunc">
      <doc xml:space="preserve" filename="gmain.h" line="158">Specifies the type of function passed to g_timeout_add(),
g_timeout_add_full(), g_idle_add(), and g_idle_add_full().

When calling g_source_set_callback(), you may need to cast a function of a
different type to this type. Use G_SOURCE_FUNC() to avoid warnings about
incompatible function types.</doc>
      <source-position filename="gmain.h" line="173" />
      <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
        <doc xml:space="preserve" filename="gmain.h" line="170">%FALSE if the source should be removed. #G_SOURCE_CONTINUE and
#G_SOURCE_REMOVE are more memorable names for the return value.</doc>
        <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
      </return-value>
      <parameters>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="0" gs:managed-name="userData" direction="in">
          <doc xml:space="preserve" filename="gmain.h" line="160">data passed to the function, set when the source was
    created with one of the above functions</doc>
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </parameter>
      </parameters>
      <gs:managed-parameters />
    </callback>
    <record name="SourceFuncs" c:type="GSourceFuncs" gs:managed-name="SourceFuncs">
      <doc xml:space="preserve" filename="gmain.h" line="79">The `GSourceFuncs` struct contains a table of
functions used to handle event sources in a generic manner.

For idle sources, the prepare and check functions always return %TRUE
to indicate that the source is always ready to be processed. The prepare
function also returns a timeout value of 0 to ensure that the poll() call
doesn't block (since that would be time wasted which could have been spent
running the idle function).

For timeout sources, the prepare and check functions both return %TRUE
if the timeout interval has expired. The prepare function also returns
a timeout value to ensure that the poll() call doesn't block too long
and miss the next timeout.

For file descriptor sources, the prepare function typically returns %FALSE,
since it must wait until poll() has been called before it knows whether
any events need to be processed. It sets the returned timeout to -1 to
indicate that it doesn't mind how long the poll() call blocks. In the
check function, it tests the results of the poll() call to see if the
required condition has been met, and returns %TRUE if so.</doc>
      <source-position filename="gmain.h" line="278" />
      <field name="prepare" gs:managed-name="Prepare">
        <type name="prepare" gs:dll-name="glib-2.0" gs:managed-name="Prepare" />
        <callback name="prepare" gs:dll-name="glib-2.0" gs:managed-name="Prepare">
          <source-position filename="gmain.h" line="266" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
          </return-value>
          <parameters>
            <parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
              <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
            </parameter>
            <parameter name="timeout_" transfer-ownership="none" gs:managed-name="timeout" direction="in">
              <type name="gint" c:type="gint*" gs:managed-name="System.Int32" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
              <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
            </parameter>
            <parameter name="timeout_" transfer-ownership="none" gs:managed-name="timeout" direction="in">
              <type name="gint" c:type="gint*" gs:managed-name="System.Int32" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="check" gs:managed-name="Check">
        <type name="check" gs:dll-name="glib-2.0" gs:managed-name="Check" />
        <callback name="check" gs:dll-name="glib-2.0" gs:managed-name="Check">
          <source-position filename="gmain.h" line="268" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
          </return-value>
          <parameters>
            <parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
              <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
              <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="dispatch" introspectable="1" gs:managed-name="Dispatch">
        <type name="gpointer" introspectable="1" gs:dll-name="glib-2.0" gs:managed-name="System.IntPtr">
          <source-position filename="gmain.h" line="269" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
          </return-value>
          <parameters>
            <parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
              <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" closure="2" gs:managed-name="callback" direction="in">
              <type name="SourceFunc" c:type="GSourceFunc" gs:managed-name="SourceFunc" />
            </parameter>
            <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="2" gs:managed-name="userData" direction="in">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
              <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
            </parameter>
            <parameter name="callback" transfer-ownership="none" closure="2" gs:managed-name="callback" direction="in">
              <type name="SourceFunc" c:type="GSourceFunc" gs:managed-name="SourceFunc" />
            </parameter>
          </gs:managed-parameters>
        </type>
      </field>
      <field name="finalize" gs:managed-name="Finalize">
        <type name="finalize" gs:dll-name="glib-2.0" gs:managed-name="Finalize" />
        <callback name="finalize" gs:dll-name="glib-2.0" gs:managed-name="Finalize">
          <source-position filename="gmain.h" line="272" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" gs:managed-name="System.Void" />
          </return-value>
          <parameters>
            <parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
              <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
              <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="closure_callback" readable="0" private="1" gs:managed-name="ClosureCallback">
        <type name="SourceFunc" c:type="GSourceFunc" gs:managed-name="SourceFunc" />
      </field>
      <field name="closure_marshal" readable="0" private="1" gs:managed-name="ClosureMarshal">
        <type name="SourceDummyMarshal" c:type="GSourceDummyMarshal" gs:managed-name="SourceDummyMarshal" />
      </field>
    </record>
    <enumeration name="TimeType" c:type="GTimeType" gs:managed-name="TimeType">
      <doc xml:space="preserve" filename="gtimezone.h" line="33">Disambiguates a given time in two ways.

First, specifies if the given time is in universal or local time.

Second, if the time is in local time, specifies if it is local
standard time or local daylight time.  This is important for the case
where the same local time occurs twice (during daylight savings time
transitions, for example).</doc>
      <source-position filename="gtimezone.h" line="53" />
      <member name="standard" value="0" c:identifier="G_TIME_TYPE_STANDARD" gs:managed-name="Standard">
        <doc xml:space="preserve" filename="gtimezone.h" line="35">the time is in local standard time</doc>
      </member>
      <member name="daylight" value="1" c:identifier="G_TIME_TYPE_DAYLIGHT" gs:managed-name="Daylight">
        <doc xml:space="preserve" filename="gtimezone.h" line="36">the time is in local daylight time</doc>
      </member>
      <member name="universal" value="2" c:identifier="G_TIME_TYPE_UNIVERSAL" gs:managed-name="Universal">
        <doc xml:space="preserve" filename="gtimezone.h" line="37">the time is in UTC</doc>
      </member>
    </enumeration>
    <record name="TimeVal" c:type="GTimeVal" deprecated="1" deprecated-version="2.62" gs:managed-name="TimeVal">
      <doc xml:space="preserve" filename="glib-2.0.c" line="2087">Represents a precise time, with seconds and microseconds.
Similar to the struct timeval returned by the gettimeofday()
UNIX system call.

GLib is attempting to unify around the use of 64-bit integers to
represent microsecond-precision time. As such, this type will be
removed from a future version of GLib. A consequence of using `glong` for
`tv_sec` is that on 32-bit systems `GTimeVal` is subject to the year 2038
problem.</doc>
      <doc-deprecated xml:space="preserve">Use #GDateTime or #guint64 instead.</doc-deprecated>
      <source-position filename="gtypes.h" line="551" />
      <field name="tv_sec" writable="1" gs:managed-name="TvSec">
        <doc xml:space="preserve" filename="glib-2.0.c" line="2089">seconds</doc>
        <type name="glong" c:type="glong" gs:managed-name="GISharp.Runtime.CLong" />
      </field>
      <field name="tv_usec" writable="1" gs:managed-name="TvUsec">
        <doc xml:space="preserve" filename="glib-2.0.c" line="2090">microseconds</doc>
        <type name="glong" c:type="glong" gs:managed-name="GISharp.Runtime.CLong" />
      </field>
      <method name="add" c:identifier="g_time_val_add" deprecated="1" deprecated-version="2.62" gs:dll-name="glib-2.0" gs:managed-name="Add">
        <doc xml:space="preserve" filename="glib-2.0.c" line="33965">Adds the given number of microseconds to @time_. @microseconds can
also be negative to decrease the value of @time_.</doc>
        <doc-deprecated xml:space="preserve">#GTimeVal is not year-2038-safe. Use `guint64` for
   representing microseconds since the epoch, or use #GDateTime.</doc-deprecated>
        <source-position filename="gtimer.h" line="67" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="time_" transfer-ownership="none" gs:managed-name="time" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="33967">a #GTimeVal</doc>
            <type name="TimeVal" c:type="GTimeVal*" gs:managed-name="TimeVal" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="microseconds" transfer-ownership="none" gs:managed-name="microseconds" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="33968">number of microseconds to add to @time</doc>
            <type name="glong" c:type="glong" gs:managed-name="GISharp.Runtime.CLong" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="microseconds" transfer-ownership="none" gs:managed-name="microseconds" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="33968">number of microseconds to add to @time</doc>
            <type name="glong" c:type="glong" gs:managed-name="GISharp.Runtime.CLong" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="to_iso8601" c:identifier="g_time_val_to_iso8601" version="2.12" deprecated="1" deprecated-version="2.62" gs:dll-name="glib-2.0" gs:managed-name="ToIso8601">
        <doc xml:space="preserve" filename="glib-2.0.c" line="34008">Converts @time_ into an RFC 3339 encoded string, relative to the
Coordinated Universal Time (UTC). This is one of the many formats
allowed by ISO 8601.

ISO 8601 allows a large number of date/time formats, with or without
punctuation and optional elements. The format returned by this function
is a complete date and time, with optional punctuation included, the
UTC time zone represented as "Z", and the @tv_usec part included if
and only if it is nonzero, i.e. either
"YYYY-MM-DDTHH:MM:SSZ" or "YYYY-MM-DDTHH:MM:SS.fffffZ".

This corresponds to the Internet date/time format defined by
[RFC 3339](https://www.ietf.org/rfc/rfc3339.txt),
and to either of the two most-precise formats defined by
the W3C Note
[Date and Time Formats](http://www.w3.org/TR/NOTE-datetime-19980827).
Both of these documents are profiles of ISO 8601.

Use g_date_time_format() or g_strdup_printf() if a different
variation of ISO 8601 format is required.

If @time_ represents a date which is too large to fit into a `struct tm`,
%NULL will be returned. This is platform dependent. Note also that since
`GTimeVal` stores the number of seconds as a `glong`, on 32-bit systems it
is subject to the year 2038 problem. Accordingly, since GLib 2.62, this
function has been deprecated. Equivalent functionality is available using:
|[
GDateTime *dt = g_date_time_new_from_unix_utc (time_val);
iso8601_string = g_date_time_format_iso8601 (dt);
g_date_time_unref (dt);
]|

The return value of g_time_val_to_iso8601() has been nullable since GLib
2.54; before then, GLib would crash under the same conditions.</doc>
        <doc-deprecated xml:space="preserve">#GTimeVal is not year-2038-safe. Use
   g_date_time_format_iso8601(dt) instead.</doc-deprecated>
        <source-position filename="gtimer.h" line="73" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="34047">a newly allocated string containing an ISO 8601 date,
   or %NULL if @time_ was too large</doc>
          <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="time_" transfer-ownership="none" gs:managed-name="time" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="34010">a #GTimeVal</doc>
            <type name="TimeVal" c:type="GTimeVal*" gs:managed-name="TimeVal" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <function name="from_iso8601" c:identifier="g_time_val_from_iso8601" version="2.12" deprecated="1" deprecated-version="2.62" gs:dll-name="glib-2.0" gs:managed-name="TryFromIso8601">
        <doc xml:space="preserve" filename="glib-2.0.c" line="33978">Converts a string containing an ISO 8601 encoded date and time
to a #GTimeVal and puts it into @time_.

@iso_date must include year, month, day, hours, minutes, and
seconds. It can optionally include fractions of a second and a time
zone indicator. (In the absence of any time zone indication, the
timestamp is assumed to be in local time.)

Any leading or trailing space in @iso_date is ignored.

This function was deprecated, along with #GTimeVal itself, in GLib 2.62.
Equivalent functionality is available using code like:
|[
GDateTime *dt = g_date_time_new_from_iso8601 (iso8601_string, NULL);
gint64 time_val = g_date_time_to_unix (dt);
g_date_time_unref (dt);
]|</doc>
        <doc-deprecated xml:space="preserve">#GTimeVal is not year-2038-safe. Use
   g_date_time_new_from_iso8601() instead.</doc-deprecated>
        <source-position filename="gtimer.h" line="70" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="34001">%TRUE if the conversion was successful.</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <parameter name="iso_date" transfer-ownership="none" gs:managed-name="isoDate" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="33980">an ISO 8601 encoded date string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="time_" direction="out" caller-allocates="1" transfer-ownership="none" gs:managed-name="time">
            <doc xml:space="preserve" filename="glib-2.0.c" line="33981">a #GTimeVal</doc>
            <type name="TimeVal" c:type="GTimeVal*" gs:managed-name="TimeVal" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="iso_date" transfer-ownership="none" gs:managed-name="isoDate" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="33980">an ISO 8601 encoded date string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="time_" direction="out" caller-allocates="1" transfer-ownership="none" gs:managed-name="time">
            <doc xml:space="preserve" filename="glib-2.0.c" line="33981">a #GTimeVal</doc>
            <type name="TimeVal" c:type="GTimeVal*" gs:managed-name="TimeVal" />
          </parameter>
        </gs:managed-parameters>
      </function>
    </record>
    <record name="TimeZone" c:type="GTimeZone" version="2.26" glib:type-name="GTimeZone" glib:get-type="g_time_zone_get_type" c:symbol-prefix="time_zone" gs:managed-name="TimeZone">
      <doc xml:space="preserve" filename="glib-2.0.c" line="2106">#GTimeZone is an opaque structure whose members cannot be accessed
directly.</doc>
      <source-position filename="gtimezone.h" line="31" />
      <constructor name="new" c:identifier="g_time_zone_new" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="New">
        <doc xml:space="preserve" filename="glib-2.0.c" line="34179">Creates a #GTimeZone corresponding to @identifier.

@identifier can either be an RFC3339/ISO 8601 time offset or
something that would pass as a valid value for the `TZ` environment
variable (including %NULL).

In Windows, @identifier can also be the unlocalized name of a time
zone for standard time, for example "Pacific Standard Time".

Valid RFC3339 time offsets are `"Z"` (for UTC) or
`"±hh:mm"`.  ISO 8601 additionally specifies
`"±hhmm"` and `"±hh"`.  Offsets are
time values to be added to Coordinated Universal Time (UTC) to get
the local time.

In UNIX, the `TZ` environment variable typically corresponds
to the name of a file in the zoneinfo database, an absolute path to a file
somewhere else, or a string in
"std offset [dst [offset],start[/time],end[/time]]" (POSIX) format.
There  are  no spaces in the specification. The name of standard
and daylight savings time zone must be three or more alphabetic
characters. Offsets are time values to be added to local time to
get Coordinated Universal Time (UTC) and should be
`"[±]hh[[:]mm[:ss]]"`.  Dates are either
`"Jn"` (Julian day with n between 1 and 365, leap
years not counted), `"n"` (zero-based Julian day
with n between 0 and 365) or `"Mm.w.d"` (day d
(0 &lt;= d &lt;= 6) of week w (1 &lt;= w &lt;= 5) of month m (1 &lt;= m &lt;= 12), day
0 is a Sunday).  Times are in local wall clock time, the default is
02:00:00.

In Windows, the "tzn[+|–]hh[:mm[:ss]][dzn]" format is used, but also
accepts POSIX format.  The Windows format uses US rules for all time
zones; daylight savings time is 60 minutes behind the standard time
with date and time of change taken from Pacific Standard Time.
Offsets are time values to be added to the local time to get
Coordinated Universal Time (UTC).

g_time_zone_new_local() calls this function with the value of the
`TZ` environment variable. This function itself is independent of
the value of `TZ`, but if @identifier is %NULL then `/etc/localtime`
will be consulted to discover the correct time zone on UNIX and the
registry will be consulted or GetTimeZoneInformation() will be used
to get the local time zone on Windows.

If intervals are not available, only time zone rules from `TZ`
environment variable or other means, then they will be computed
from year 1900 to 2037.  If the maximum year for the rules is
available and it is greater than 2037, then it will followed
instead.

See
[RFC3339 §5.6](http://tools.ietf.org/html/rfc3339#section-5.6)
for a precise definition of valid RFC3339 time offsets
(the `time-offset` expansion) and ISO 8601 for the
full list of valid time offsets.  See
[The GNU C Library manual](http://www.gnu.org/s/libc/manual/html_node/TZ-Variable.html)
for an explanation of the possible
values of the `TZ` environment variable. See
[Microsoft Time Zone Index Values](http://msdn.microsoft.com/en-us/library/ms912391%28v=winembedded.11%29.aspx)
for the list of time zones on Windows.

You should release the return value by calling g_time_zone_unref()
when you are done with it.</doc>
        <source-position filename="gtimezone.h" line="56" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="34248">the requested timezone</doc>
          <type name="TimeZone" c:type="GTimeZone*" gs:managed-name="TimeZone" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="identifier" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="identifier" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="34181">a timezone identifier</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="identifier" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="identifier" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="34181">a timezone identifier</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <gs:managed-property name="get_local" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="Local">
        <doc xml:space="preserve" filename="glib-2.0.c" line="34253">Creates a #GTimeZone corresponding to local time.  The local time
zone may change between invocations to this function; for example,
if the system administrator changes it.

This is equivalent to calling g_time_zone_new() with the value of
the `TZ` environment variable (including the possibility of %NULL).

You should release the return value by calling g_time_zone_unref()
when you are done with it.</doc>
        <source-position filename="gtimezone.h" line="60" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="34266">the local timezone</doc>
          <type name="TimeZone" c:type="GTimeZone*" gs:managed-name="TimeZone" gs:is-pointer="1" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </gs:managed-property>
      <function name="get_local" c:identifier="g_time_zone_new_local" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="GetLocal" gs:property-getter-for="Local" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="34253">Creates a #GTimeZone corresponding to local time.  The local time
zone may change between invocations to this function; for example,
if the system administrator changes it.

This is equivalent to calling g_time_zone_new() with the value of
the `TZ` environment variable (including the possibility of %NULL).

You should release the return value by calling g_time_zone_unref()
when you are done with it.</doc>
        <source-position filename="gtimezone.h" line="60" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="34266">the local timezone</doc>
          <type name="TimeZone" c:type="GTimeZone*" gs:managed-name="TimeZone" gs:is-pointer="1" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
      <constructor name="new_offset" c:identifier="g_time_zone_new_offset" version="2.58" gs:dll-name="glib-2.0" gs:managed-name="NewOffset">
        <doc xml:space="preserve" filename="glib-2.0.c" line="34271">Creates a #GTimeZone corresponding to the given constant offset from UTC,
in seconds.

This is equivalent to calling g_time_zone_new() with a string in the form
`[+|-]hh[:mm[:ss]]`.</doc>
        <source-position filename="gtimezone.h" line="62" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="34281">a timezone at the given offset from UTC</doc>
          <type name="TimeZone" c:type="GTimeZone*" gs:managed-name="TimeZone" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="seconds" transfer-ownership="none" gs:managed-name="seconds" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="34273">offset to UTC, in seconds</doc>
            <type name="gint32" c:type="gint32" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="seconds" transfer-ownership="none" gs:managed-name="seconds" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="34273">offset to UTC, in seconds</doc>
            <type name="gint32" c:type="gint32" gs:managed-name="System.Int32" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <gs:managed-property name="get_utc" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="Utc">
        <doc xml:space="preserve" filename="glib-2.0.c" line="34286">Creates a #GTimeZone corresponding to UTC.

This is equivalent to calling g_time_zone_new() with a value like
"Z", "UTC", "+00", etc.

You should release the return value by calling g_time_zone_unref()
when you are done with it.</doc>
        <source-position filename="gtimezone.h" line="58" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="34297">the universal timezone</doc>
          <type name="TimeZone" c:type="GTimeZone*" gs:managed-name="TimeZone" gs:is-pointer="1" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </gs:managed-property>
      <function name="get_utc" c:identifier="g_time_zone_new_utc" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="GetUtc" gs:property-getter-for="Utc" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="34286">Creates a #GTimeZone corresponding to UTC.

This is equivalent to calling g_time_zone_new() with a value like
"Z", "UTC", "+00", etc.

You should release the return value by calling g_time_zone_unref()
when you are done with it.</doc>
        <source-position filename="gtimezone.h" line="58" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="34297">the universal timezone</doc>
          <type name="TimeZone" c:type="GTimeZone*" gs:managed-name="TimeZone" gs:is-pointer="1" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
      <method name="adjust_time" c:identifier="g_time_zone_adjust_time" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="AdjustTime">
        <doc xml:space="preserve" filename="glib-2.0.c" line="34055">Finds an interval within @tz that corresponds to the given @time_,
possibly adjusting @time_ if required to fit into an interval.
The meaning of @time_ depends on @type.

This function is similar to g_time_zone_find_interval(), with the
difference that it always succeeds (by making the adjustments
described below).

In any of the cases where g_time_zone_find_interval() succeeds then
this function returns the same value, without modifying @time_.

This function may, however, modify @time_ in order to deal with
non-existent times.  If the non-existent local @time_ of 02:30 were
requested on March 14th 2010 in Toronto then this function would
adjust @time_ to be 03:00 and return the interval containing the
adjusted time.</doc>
        <source-position filename="gtimezone.h" line="75" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="34078">the interval containing @time_, never -1</doc>
          <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="tz" transfer-ownership="none" gs:managed-name="tz" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="34057">a #GTimeZone</doc>
            <type name="TimeZone" c:type="GTimeZone*" gs:managed-name="TimeZone" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="34058">the #GTimeType of @time_</doc>
            <type name="TimeType" c:type="GTimeType" gs:managed-name="TimeType" />
          </parameter>
          <parameter name="time_" transfer-ownership="none" gs:managed-name="time" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="34059">a pointer to a number of seconds since January 1, 1970</doc>
            <type name="gint64" c:type="gint64*" gs:managed-name="System.Int64" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="34058">the #GTimeType of @time_</doc>
            <type name="TimeType" c:type="GTimeType" gs:managed-name="TimeType" />
          </parameter>
          <parameter name="time_" transfer-ownership="none" gs:managed-name="time" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="34059">a pointer to a number of seconds since January 1, 1970</doc>
            <type name="gint64" c:type="gint64*" gs:managed-name="System.Int64" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="find_interval" c:identifier="g_time_zone_find_interval" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="FindInterval">
        <doc xml:space="preserve" filename="glib-2.0.c" line="34083">Finds an interval within @tz that corresponds to the given @time_.
The meaning of @time_ depends on @type.

If @type is %G_TIME_TYPE_UNIVERSAL then this function will always
succeed (since universal time is monotonic and continuous).

Otherwise @time_ is treated as local time.  The distinction between
%G_TIME_TYPE_STANDARD and %G_TIME_TYPE_DAYLIGHT is ignored except in
the case that the given @time_ is ambiguous.  In Toronto, for example,
01:30 on November 7th 2010 occurred twice (once inside of daylight
savings time and the next, an hour later, outside of daylight savings
time).  In this case, the different value of @type would result in a
different interval being returned.

It is still possible for this function to fail.  In Toronto, for
example, 02:00 on March 14th 2010 does not exist (due to the leap
forward to begin daylight savings time).  -1 is returned in that
case.</doc>
        <source-position filename="gtimezone.h" line="70" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="34108">the interval containing @time_, or -1 in case of failure</doc>
          <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="tz" transfer-ownership="none" gs:managed-name="tz" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="34085">a #GTimeZone</doc>
            <type name="TimeZone" c:type="GTimeZone*" gs:managed-name="TimeZone" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="34086">the #GTimeType of @time_</doc>
            <type name="TimeType" c:type="GTimeType" gs:managed-name="TimeType" />
          </parameter>
          <parameter name="time_" transfer-ownership="none" gs:managed-name="time" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="34087">a number of seconds since January 1, 1970</doc>
            <type name="gint64" c:type="gint64" gs:managed-name="System.Int64" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="34086">the #GTimeType of @time_</doc>
            <type name="TimeType" c:type="GTimeType" gs:managed-name="TimeType" />
          </parameter>
          <parameter name="time_" transfer-ownership="none" gs:managed-name="time" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="34087">a number of seconds since January 1, 1970</doc>
            <type name="gint64" c:type="gint64" gs:managed-name="System.Int64" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_abbreviation" c:identifier="g_time_zone_get_abbreviation" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="GetAbbreviation">
        <doc xml:space="preserve" filename="glib-2.0.c" line="34113">Determines the time zone abbreviation to be used during a particular
@interval of time in the time zone @tz.

For example, in Toronto this is currently "EST" during the winter
months and "EDT" during the summer months when daylight savings time
is in effect.</doc>
        <source-position filename="gtimezone.h" line="80" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="34125">the time zone abbreviation, which belongs to @tz</doc>
          <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="tz" transfer-ownership="none" gs:managed-name="tz" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="34115">a #GTimeZone</doc>
            <type name="TimeZone" c:type="GTimeZone*" gs:managed-name="TimeZone" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="interval" transfer-ownership="none" gs:managed-name="interval" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="34116">an interval within the timezone</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="interval" transfer-ownership="none" gs:managed-name="interval" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="34116">an interval within the timezone</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <gs:managed-property name="get_identifier" version="2.58" gs:dll-name="glib-2.0" gs:managed-name="Identifier">
        <doc xml:space="preserve" filename="glib-2.0.c" line="34130">Get the identifier of this #GTimeZone, as passed to g_time_zone_new().
If the identifier passed at construction time was not recognised, `UTC` will
be returned. If it was %NULL, the identifier of the local timezone at
construction time will be returned.

The identifier will be returned in the same format as provided at
construction time: if provided as a time offset, that will be returned by
this function.</doc>
        <source-position filename="gtimezone.h" line="89" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="34143">identifier for this timezone</doc>
          <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="tz" transfer-ownership="none" gs:managed-name="tz" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="34132">a #GTimeZone</doc>
            <type name="TimeZone" c:type="GTimeZone*" gs:managed-name="TimeZone" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_identifier" c:identifier="g_time_zone_get_identifier" version="2.58" gs:dll-name="glib-2.0" gs:managed-name="GetIdentifier" gs:property-getter-for="Identifier" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="34130">Get the identifier of this #GTimeZone, as passed to g_time_zone_new().
If the identifier passed at construction time was not recognised, `UTC` will
be returned. If it was %NULL, the identifier of the local timezone at
construction time will be returned.

The identifier will be returned in the same format as provided at
construction time: if provided as a time offset, that will be returned by
this function.</doc>
        <source-position filename="gtimezone.h" line="89" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="34143">identifier for this timezone</doc>
          <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="tz" transfer-ownership="none" gs:managed-name="tz" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="34132">a #GTimeZone</doc>
            <type name="TimeZone" c:type="GTimeZone*" gs:managed-name="TimeZone" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="get_offset" c:identifier="g_time_zone_get_offset" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="GetOffset">
        <doc xml:space="preserve" filename="glib-2.0.c" line="34148">Determines the offset to UTC in effect during a particular @interval
of time in the time zone @tz.

The offset is the number of seconds that you add to UTC time to
arrive at local time for @tz (ie: negative numbers for time zones
west of GMT, positive numbers for east).</doc>
        <source-position filename="gtimezone.h" line="83" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="34160">the number of seconds that should be added to UTC to get the
         local time in @tz</doc>
          <type name="gint32" c:type="gint32" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="tz" transfer-ownership="none" gs:managed-name="tz" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="34150">a #GTimeZone</doc>
            <type name="TimeZone" c:type="GTimeZone*" gs:managed-name="TimeZone" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="interval" transfer-ownership="none" gs:managed-name="interval" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="34151">an interval within the timezone</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="interval" transfer-ownership="none" gs:managed-name="interval" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="34151">an interval within the timezone</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="is_dst" c:identifier="g_time_zone_is_dst" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="IsDst">
        <doc xml:space="preserve" filename="glib-2.0.c" line="34166">Determines if daylight savings time is in effect during a particular
@interval of time in the time zone @tz.</doc>
        <source-position filename="gtimezone.h" line="86" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="34174">%TRUE if daylight savings time is in effect</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="tz" transfer-ownership="none" gs:managed-name="tz" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="34168">a #GTimeZone</doc>
            <type name="TimeZone" c:type="GTimeZone*" gs:managed-name="TimeZone" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="interval" transfer-ownership="none" gs:managed-name="interval" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="34169">an interval within the timezone</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="interval" transfer-ownership="none" gs:managed-name="interval" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="34169">an interval within the timezone</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="ref" c:identifier="g_time_zone_ref" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="Ref" gs:special-func="ref" gs:pinvoke-only="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="34302">Increases the reference count on @tz.</doc>
        <source-position filename="gtimezone.h" line="65" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="34308">a new reference to @tz.</doc>
          <type name="TimeZone" c:type="GTimeZone*" gs:managed-name="TimeZone" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="tz" transfer-ownership="none" gs:managed-name="tz" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="34304">a #GTimeZone</doc>
            <type name="TimeZone" c:type="GTimeZone*" gs:managed-name="TimeZone" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="unref" c:identifier="g_time_zone_unref" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="Unref" gs:special-func="unref" gs:pinvoke-only="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="34313">Decreases the reference count on @tz.</doc>
        <source-position filename="gtimezone.h" line="67" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="tz" transfer-ownership="none" gs:managed-name="tz" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="34315">a #GTimeZone</doc>
            <type name="TimeZone" c:type="GTimeZone*" gs:managed-name="TimeZone" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_time_zone_get_type" gs:access-modifiers="private" gs:dll-name="gobject-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </record>
    <callback name="TranslateFunc" c:type="GTranslateFunc" gs:dll-name="glib-2.0" gs:managed-name="TranslateFunc">
      <doc xml:space="preserve" filename="gtypes.h" line="145">The type of functions which are used to translate user-visible
strings, for &lt;option&gt;--help&lt;/option&gt; output.</doc>
      <source-position filename="gtypes.h" line="157" />
      <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
        <doc xml:space="preserve" filename="gtypes.h" line="154">a translation of the string for the current locale.
 The returned string is owned by GLib and must not be freed.</doc>
        <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none" gs:managed-name="str" direction="in">
          <doc xml:space="preserve" filename="gtypes.h" line="147">the untranslated string</doc>
          <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </parameter>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" closure="1" gs:managed-name="data" direction="in">
          <doc xml:space="preserve" filename="gtypes.h" line="148">user data specified when installing the function, e.g.
 in g_option_group_set_translate_func()</doc>
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </parameter>
      </parameters>
      <gs:managed-parameters>
        <parameter name="str" transfer-ownership="none" gs:managed-name="str" direction="in">
          <doc xml:space="preserve" filename="gtypes.h" line="147">the untranslated string</doc>
          <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </parameter>
      </gs:managed-parameters>
    </callback>
    <enumeration name="UnicodeBreakType" c:type="GUnicodeBreakType" gs:managed-name="UnicodeBreakType">
      <doc xml:space="preserve" filename="gunicode.h" line="159">These are the possible line break classifications.

Since new unicode versions may add new types here, applications should be ready
to handle unknown values. They may be regarded as %G_UNICODE_BREAK_UNKNOWN.

See [Unicode Line Breaking Algorithm](http://www.unicode.org/unicode/reports/tr14/).</doc>
      <source-position filename="gunicode.h" line="257" />
      <member name="mandatory" value="0" c:identifier="G_UNICODE_BREAK_MANDATORY" gs:managed-name="Mandatory">
        <doc xml:space="preserve" filename="gunicode.h" line="161">Mandatory Break (BK)</doc>
      </member>
      <member name="carriage_return" value="1" c:identifier="G_UNICODE_BREAK_CARRIAGE_RETURN" gs:managed-name="CarriageReturn">
        <doc xml:space="preserve" filename="gunicode.h" line="162">Carriage Return (CR)</doc>
      </member>
      <member name="line_feed" value="2" c:identifier="G_UNICODE_BREAK_LINE_FEED" gs:managed-name="LineFeed">
        <doc xml:space="preserve" filename="gunicode.h" line="163">Line Feed (LF)</doc>
      </member>
      <member name="combining_mark" value="3" c:identifier="G_UNICODE_BREAK_COMBINING_MARK" gs:managed-name="CombiningMark">
        <doc xml:space="preserve" filename="gunicode.h" line="164">Attached Characters and Combining Marks (CM)</doc>
      </member>
      <member name="surrogate" value="4" c:identifier="G_UNICODE_BREAK_SURROGATE" gs:managed-name="Surrogate">
        <doc xml:space="preserve" filename="gunicode.h" line="165">Surrogates (SG)</doc>
      </member>
      <member name="zero_width_space" value="5" c:identifier="G_UNICODE_BREAK_ZERO_WIDTH_SPACE" gs:managed-name="ZeroWidthSpace">
        <doc xml:space="preserve" filename="gunicode.h" line="166">Zero Width Space (ZW)</doc>
      </member>
      <member name="inseparable" value="6" c:identifier="G_UNICODE_BREAK_INSEPARABLE" gs:managed-name="Inseparable">
        <doc xml:space="preserve" filename="gunicode.h" line="167">Inseparable (IN)</doc>
      </member>
      <member name="non_breaking_glue" value="7" c:identifier="G_UNICODE_BREAK_NON_BREAKING_GLUE" gs:managed-name="NonBreakingGlue">
        <doc xml:space="preserve" filename="gunicode.h" line="168">Non-breaking ("Glue") (GL)</doc>
      </member>
      <member name="contingent" value="8" c:identifier="G_UNICODE_BREAK_CONTINGENT" gs:managed-name="Contingent">
        <doc xml:space="preserve" filename="gunicode.h" line="169">Contingent Break Opportunity (CB)</doc>
      </member>
      <member name="space" value="9" c:identifier="G_UNICODE_BREAK_SPACE" gs:managed-name="Space">
        <doc xml:space="preserve" filename="gunicode.h" line="170">Space (SP)</doc>
      </member>
      <member name="after" value="10" c:identifier="G_UNICODE_BREAK_AFTER" gs:managed-name="After">
        <doc xml:space="preserve" filename="gunicode.h" line="171">Break Opportunity After (BA)</doc>
      </member>
      <member name="before" value="11" c:identifier="G_UNICODE_BREAK_BEFORE" gs:managed-name="Before">
        <doc xml:space="preserve" filename="gunicode.h" line="172">Break Opportunity Before (BB)</doc>
      </member>
      <member name="before_and_after" value="12" c:identifier="G_UNICODE_BREAK_BEFORE_AND_AFTER" gs:managed-name="BeforeAndAfter">
        <doc xml:space="preserve" filename="gunicode.h" line="173">Break Opportunity Before and After (B2)</doc>
      </member>
      <member name="hyphen" value="13" c:identifier="G_UNICODE_BREAK_HYPHEN" gs:managed-name="Hyphen">
        <doc xml:space="preserve" filename="gunicode.h" line="174">Hyphen (HY)</doc>
      </member>
      <member name="non_starter" value="14" c:identifier="G_UNICODE_BREAK_NON_STARTER" gs:managed-name="NonStarter">
        <doc xml:space="preserve" filename="gunicode.h" line="175">Nonstarter (NS)</doc>
      </member>
      <member name="open_punctuation" value="15" c:identifier="G_UNICODE_BREAK_OPEN_PUNCTUATION" gs:managed-name="OpenPunctuation">
        <doc xml:space="preserve" filename="gunicode.h" line="176">Opening Punctuation (OP)</doc>
      </member>
      <member name="close_punctuation" value="16" c:identifier="G_UNICODE_BREAK_CLOSE_PUNCTUATION" gs:managed-name="ClosePunctuation">
        <doc xml:space="preserve" filename="gunicode.h" line="177">Closing Punctuation (CL)</doc>
      </member>
      <member name="quotation" value="17" c:identifier="G_UNICODE_BREAK_QUOTATION" gs:managed-name="Quotation">
        <doc xml:space="preserve" filename="gunicode.h" line="178">Ambiguous Quotation (QU)</doc>
      </member>
      <member name="exclamation" value="18" c:identifier="G_UNICODE_BREAK_EXCLAMATION" gs:managed-name="Exclamation">
        <doc xml:space="preserve" filename="gunicode.h" line="179">Exclamation/Interrogation (EX)</doc>
      </member>
      <member name="ideographic" value="19" c:identifier="G_UNICODE_BREAK_IDEOGRAPHIC" gs:managed-name="Ideographic">
        <doc xml:space="preserve" filename="gunicode.h" line="180">Ideographic (ID)</doc>
      </member>
      <member name="numeric" value="20" c:identifier="G_UNICODE_BREAK_NUMERIC" gs:managed-name="Numeric">
        <doc xml:space="preserve" filename="gunicode.h" line="181">Numeric (NU)</doc>
      </member>
      <member name="infix_separator" value="21" c:identifier="G_UNICODE_BREAK_INFIX_SEPARATOR" gs:managed-name="InfixSeparator">
        <doc xml:space="preserve" filename="gunicode.h" line="182">Infix Separator (Numeric) (IS)</doc>
      </member>
      <member name="symbol" value="22" c:identifier="G_UNICODE_BREAK_SYMBOL" gs:managed-name="Symbol">
        <doc xml:space="preserve" filename="gunicode.h" line="183">Symbols Allowing Break After (SY)</doc>
      </member>
      <member name="alphabetic" value="23" c:identifier="G_UNICODE_BREAK_ALPHABETIC" gs:managed-name="Alphabetic">
        <doc xml:space="preserve" filename="gunicode.h" line="184">Ordinary Alphabetic and Symbol Characters (AL)</doc>
      </member>
      <member name="prefix" value="24" c:identifier="G_UNICODE_BREAK_PREFIX" gs:managed-name="Prefix">
        <doc xml:space="preserve" filename="gunicode.h" line="185">Prefix (Numeric) (PR)</doc>
      </member>
      <member name="postfix" value="25" c:identifier="G_UNICODE_BREAK_POSTFIX" gs:managed-name="Postfix">
        <doc xml:space="preserve" filename="gunicode.h" line="186">Postfix (Numeric) (PO)</doc>
      </member>
      <member name="complex_context" value="26" c:identifier="G_UNICODE_BREAK_COMPLEX_CONTEXT" gs:managed-name="ComplexContext">
        <doc xml:space="preserve" filename="gunicode.h" line="187">Complex Content Dependent (South East Asian) (SA)</doc>
      </member>
      <member name="ambiguous" value="27" c:identifier="G_UNICODE_BREAK_AMBIGUOUS" gs:managed-name="Ambiguous">
        <doc xml:space="preserve" filename="gunicode.h" line="188">Ambiguous (Alphabetic or Ideographic) (AI)</doc>
      </member>
      <member name="unknown" value="28" c:identifier="G_UNICODE_BREAK_UNKNOWN" gs:managed-name="Unknown">
        <doc xml:space="preserve" filename="gunicode.h" line="189">Unknown (XX)</doc>
      </member>
      <member name="next_line" value="29" c:identifier="G_UNICODE_BREAK_NEXT_LINE" gs:managed-name="NextLine">
        <doc xml:space="preserve" filename="gunicode.h" line="190">Next Line (NL)</doc>
      </member>
      <member name="word_joiner" value="30" c:identifier="G_UNICODE_BREAK_WORD_JOINER" gs:managed-name="WordJoiner">
        <doc xml:space="preserve" filename="gunicode.h" line="191">Word Joiner (WJ)</doc>
      </member>
      <member name="hangul_l_jamo" value="31" c:identifier="G_UNICODE_BREAK_HANGUL_L_JAMO" gs:managed-name="HangulLJamo">
        <doc xml:space="preserve" filename="gunicode.h" line="192">Hangul L Jamo (JL)</doc>
      </member>
      <member name="hangul_v_jamo" value="32" c:identifier="G_UNICODE_BREAK_HANGUL_V_JAMO" gs:managed-name="HangulVJamo">
        <doc xml:space="preserve" filename="gunicode.h" line="193">Hangul V Jamo (JV)</doc>
      </member>
      <member name="hangul_t_jamo" value="33" c:identifier="G_UNICODE_BREAK_HANGUL_T_JAMO" gs:managed-name="HangulTJamo">
        <doc xml:space="preserve" filename="gunicode.h" line="194">Hangul T Jamo (JT)</doc>
      </member>
      <member name="hangul_lv_syllable" value="34" c:identifier="G_UNICODE_BREAK_HANGUL_LV_SYLLABLE" gs:managed-name="HangulLvSyllable">
        <doc xml:space="preserve" filename="gunicode.h" line="195">Hangul LV Syllable (H2)</doc>
      </member>
      <member name="hangul_lvt_syllable" value="35" c:identifier="G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE" gs:managed-name="HangulLvtSyllable">
        <doc xml:space="preserve" filename="gunicode.h" line="196">Hangul LVT Syllable (H3)</doc>
      </member>
      <member name="close_paranthesis" value="36" c:identifier="G_UNICODE_BREAK_CLOSE_PARANTHESIS" version="2.28" gs:managed-name="CloseParanthesis">
        <doc xml:space="preserve" filename="gunicode.h" line="197">Closing Parenthesis (CP).</doc>
      </member>
      <member name="conditional_japanese_starter" value="37" c:identifier="G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER" version="2.32" gs:managed-name="ConditionalJapaneseStarter">
        <doc xml:space="preserve" filename="gunicode.h" line="198">Conditional Japanese Starter (CJ).</doc>
      </member>
      <member name="hebrew_letter" value="38" c:identifier="G_UNICODE_BREAK_HEBREW_LETTER" version="2.32" gs:managed-name="HebrewLetter">
        <doc xml:space="preserve" filename="gunicode.h" line="199">Hebrew Letter (HL).</doc>
      </member>
      <member name="regional_indicator" value="39" c:identifier="G_UNICODE_BREAK_REGIONAL_INDICATOR" version="2.36" gs:managed-name="RegionalIndicator">
        <doc xml:space="preserve" filename="gunicode.h" line="200">Regional Indicator (RI).</doc>
      </member>
      <member name="emoji_base" value="40" c:identifier="G_UNICODE_BREAK_EMOJI_BASE" version="2.50" gs:managed-name="EmojiBase">
        <doc xml:space="preserve" filename="gunicode.h" line="201">Emoji Base (EB).</doc>
      </member>
      <member name="emoji_modifier" value="41" c:identifier="G_UNICODE_BREAK_EMOJI_MODIFIER" version="2.50" gs:managed-name="EmojiModifier">
        <doc xml:space="preserve" filename="gunicode.h" line="202">Emoji Modifier (EM).</doc>
      </member>
      <member name="zero_width_joiner" value="42" c:identifier="G_UNICODE_BREAK_ZERO_WIDTH_JOINER" version="2.50" gs:managed-name="ZeroWidthJoiner">
        <doc xml:space="preserve" filename="gunicode.h" line="203">Zero Width Joiner (ZWJ).</doc>
      </member>
    </enumeration>
    <enumeration name="UnicodeScript" c:type="GUnicodeScript" gs:managed-name="UnicodeScript">
      <doc xml:space="preserve" filename="gunicode.h" line="259">The #GUnicodeScript enumeration identifies different writing
systems. The values correspond to the names as defined in the
Unicode standard. The enumeration has been added in GLib 2.14,
and is interchangeable with #PangoScript.

Note that new types may be added in the future. Applications
should be ready to handle unknown values.
See [Unicode Standard Annex #24: Script names](http://www.unicode.org/reports/tr24/).</doc>
      <source-position filename="gunicode.h" line="629" />
      <member name="invalid_code" value="-1" c:identifier="G_UNICODE_SCRIPT_INVALID_CODE" gs:managed-name="InvalidCode">
        <doc xml:space="preserve" filename="gunicode.h" line="261">a value never returned from g_unichar_get_script()</doc>
      </member>
      <member name="common" value="0" c:identifier="G_UNICODE_SCRIPT_COMMON" gs:managed-name="Common">
        <doc xml:space="preserve" filename="gunicode.h" line="263">a character used by multiple different scripts</doc>
      </member>
      <member name="inherited" value="1" c:identifier="G_UNICODE_SCRIPT_INHERITED" gs:managed-name="Inherited">
        <doc xml:space="preserve" filename="gunicode.h" line="264">a mark glyph that takes its script from the
                              base glyph to which it is attached</doc>
      </member>
      <member name="arabic" value="2" c:identifier="G_UNICODE_SCRIPT_ARABIC" gs:managed-name="Arabic">
        <doc xml:space="preserve" filename="gunicode.h" line="266">Arabic</doc>
      </member>
      <member name="armenian" value="3" c:identifier="G_UNICODE_SCRIPT_ARMENIAN" gs:managed-name="Armenian">
        <doc xml:space="preserve" filename="gunicode.h" line="267">Armenian</doc>
      </member>
      <member name="bengali" value="4" c:identifier="G_UNICODE_SCRIPT_BENGALI" gs:managed-name="Bengali">
        <doc xml:space="preserve" filename="gunicode.h" line="268">Bengali</doc>
      </member>
      <member name="bopomofo" value="5" c:identifier="G_UNICODE_SCRIPT_BOPOMOFO" gs:managed-name="Bopomofo">
        <doc xml:space="preserve" filename="gunicode.h" line="269">Bopomofo</doc>
      </member>
      <member name="cherokee" value="6" c:identifier="G_UNICODE_SCRIPT_CHEROKEE" gs:managed-name="Cherokee">
        <doc xml:space="preserve" filename="gunicode.h" line="270">Cherokee</doc>
      </member>
      <member name="coptic" value="7" c:identifier="G_UNICODE_SCRIPT_COPTIC" gs:managed-name="Coptic">
        <doc xml:space="preserve" filename="gunicode.h" line="271">Coptic</doc>
      </member>
      <member name="cyrillic" value="8" c:identifier="G_UNICODE_SCRIPT_CYRILLIC" gs:managed-name="Cyrillic">
        <doc xml:space="preserve" filename="gunicode.h" line="272">Cyrillic</doc>
      </member>
      <member name="deseret" value="9" c:identifier="G_UNICODE_SCRIPT_DESERET" gs:managed-name="Deseret">
        <doc xml:space="preserve" filename="gunicode.h" line="273">Deseret</doc>
      </member>
      <member name="devanagari" value="10" c:identifier="G_UNICODE_SCRIPT_DEVANAGARI" gs:managed-name="Devanagari">
        <doc xml:space="preserve" filename="gunicode.h" line="274">Devanagari</doc>
      </member>
      <member name="ethiopic" value="11" c:identifier="G_UNICODE_SCRIPT_ETHIOPIC" gs:managed-name="Ethiopic">
        <doc xml:space="preserve" filename="gunicode.h" line="275">Ethiopic</doc>
      </member>
      <member name="georgian" value="12" c:identifier="G_UNICODE_SCRIPT_GEORGIAN" gs:managed-name="Georgian">
        <doc xml:space="preserve" filename="gunicode.h" line="276">Georgian</doc>
      </member>
      <member name="gothic" value="13" c:identifier="G_UNICODE_SCRIPT_GOTHIC" gs:managed-name="Gothic">
        <doc xml:space="preserve" filename="gunicode.h" line="277">Gothic</doc>
      </member>
      <member name="greek" value="14" c:identifier="G_UNICODE_SCRIPT_GREEK" gs:managed-name="Greek">
        <doc xml:space="preserve" filename="gunicode.h" line="278">Greek</doc>
      </member>
      <member name="gujarati" value="15" c:identifier="G_UNICODE_SCRIPT_GUJARATI" gs:managed-name="Gujarati">
        <doc xml:space="preserve" filename="gunicode.h" line="279">Gujarati</doc>
      </member>
      <member name="gurmukhi" value="16" c:identifier="G_UNICODE_SCRIPT_GURMUKHI" gs:managed-name="Gurmukhi">
        <doc xml:space="preserve" filename="gunicode.h" line="280">Gurmukhi</doc>
      </member>
      <member name="han" value="17" c:identifier="G_UNICODE_SCRIPT_HAN" gs:managed-name="Han">
        <doc xml:space="preserve" filename="gunicode.h" line="281">Han</doc>
      </member>
      <member name="hangul" value="18" c:identifier="G_UNICODE_SCRIPT_HANGUL" gs:managed-name="Hangul">
        <doc xml:space="preserve" filename="gunicode.h" line="282">Hangul</doc>
      </member>
      <member name="hebrew" value="19" c:identifier="G_UNICODE_SCRIPT_HEBREW" gs:managed-name="Hebrew">
        <doc xml:space="preserve" filename="gunicode.h" line="283">Hebrew</doc>
      </member>
      <member name="hiragana" value="20" c:identifier="G_UNICODE_SCRIPT_HIRAGANA" gs:managed-name="Hiragana">
        <doc xml:space="preserve" filename="gunicode.h" line="284">Hiragana</doc>
      </member>
      <member name="kannada" value="21" c:identifier="G_UNICODE_SCRIPT_KANNADA" gs:managed-name="Kannada">
        <doc xml:space="preserve" filename="gunicode.h" line="285">Kannada</doc>
      </member>
      <member name="katakana" value="22" c:identifier="G_UNICODE_SCRIPT_KATAKANA" gs:managed-name="Katakana">
        <doc xml:space="preserve" filename="gunicode.h" line="286">Katakana</doc>
      </member>
      <member name="khmer" value="23" c:identifier="G_UNICODE_SCRIPT_KHMER" gs:managed-name="Khmer">
        <doc xml:space="preserve" filename="gunicode.h" line="287">Khmer</doc>
      </member>
      <member name="lao" value="24" c:identifier="G_UNICODE_SCRIPT_LAO" gs:managed-name="Lao">
        <doc xml:space="preserve" filename="gunicode.h" line="288">Lao</doc>
      </member>
      <member name="latin" value="25" c:identifier="G_UNICODE_SCRIPT_LATIN" gs:managed-name="Latin">
        <doc xml:space="preserve" filename="gunicode.h" line="289">Latin</doc>
      </member>
      <member name="malayalam" value="26" c:identifier="G_UNICODE_SCRIPT_MALAYALAM" gs:managed-name="Malayalam">
        <doc xml:space="preserve" filename="gunicode.h" line="290">Malayalam</doc>
      </member>
      <member name="mongolian" value="27" c:identifier="G_UNICODE_SCRIPT_MONGOLIAN" gs:managed-name="Mongolian">
        <doc xml:space="preserve" filename="gunicode.h" line="291">Mongolian</doc>
      </member>
      <member name="myanmar" value="28" c:identifier="G_UNICODE_SCRIPT_MYANMAR" gs:managed-name="Myanmar">
        <doc xml:space="preserve" filename="gunicode.h" line="292">Myanmar</doc>
      </member>
      <member name="ogham" value="29" c:identifier="G_UNICODE_SCRIPT_OGHAM" gs:managed-name="Ogham">
        <doc xml:space="preserve" filename="gunicode.h" line="293">Ogham</doc>
      </member>
      <member name="old_italic" value="30" c:identifier="G_UNICODE_SCRIPT_OLD_ITALIC" gs:managed-name="OldItalic">
        <doc xml:space="preserve" filename="gunicode.h" line="294">Old Italic</doc>
      </member>
      <member name="oriya" value="31" c:identifier="G_UNICODE_SCRIPT_ORIYA" gs:managed-name="Oriya">
        <doc xml:space="preserve" filename="gunicode.h" line="295">Oriya</doc>
      </member>
      <member name="runic" value="32" c:identifier="G_UNICODE_SCRIPT_RUNIC" gs:managed-name="Runic">
        <doc xml:space="preserve" filename="gunicode.h" line="296">Runic</doc>
      </member>
      <member name="sinhala" value="33" c:identifier="G_UNICODE_SCRIPT_SINHALA" gs:managed-name="Sinhala">
        <doc xml:space="preserve" filename="gunicode.h" line="297">Sinhala</doc>
      </member>
      <member name="syriac" value="34" c:identifier="G_UNICODE_SCRIPT_SYRIAC" gs:managed-name="Syriac">
        <doc xml:space="preserve" filename="gunicode.h" line="298">Syriac</doc>
      </member>
      <member name="tamil" value="35" c:identifier="G_UNICODE_SCRIPT_TAMIL" gs:managed-name="Tamil">
        <doc xml:space="preserve" filename="gunicode.h" line="299">Tamil</doc>
      </member>
      <member name="telugu" value="36" c:identifier="G_UNICODE_SCRIPT_TELUGU" gs:managed-name="Telugu">
        <doc xml:space="preserve" filename="gunicode.h" line="300">Telugu</doc>
      </member>
      <member name="thaana" value="37" c:identifier="G_UNICODE_SCRIPT_THAANA" gs:managed-name="Thaana">
        <doc xml:space="preserve" filename="gunicode.h" line="301">Thaana</doc>
      </member>
      <member name="thai" value="38" c:identifier="G_UNICODE_SCRIPT_THAI" gs:managed-name="Thai">
        <doc xml:space="preserve" filename="gunicode.h" line="302">Thai</doc>
      </member>
      <member name="tibetan" value="39" c:identifier="G_UNICODE_SCRIPT_TIBETAN" gs:managed-name="Tibetan">
        <doc xml:space="preserve" filename="gunicode.h" line="303">Tibetan</doc>
      </member>
      <member name="canadian_aboriginal" value="40" c:identifier="G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL" gs:managed-name="CanadianAboriginal">
        <doc xml:space="preserve" filename="gunicode.h" line="304">Canadian Aboriginal</doc>
      </member>
      <member name="yi" value="41" c:identifier="G_UNICODE_SCRIPT_YI" gs:managed-name="Yi">
        <doc xml:space="preserve" filename="gunicode.h" line="306">Yi</doc>
      </member>
      <member name="tagalog" value="42" c:identifier="G_UNICODE_SCRIPT_TAGALOG" gs:managed-name="Tagalog">
        <doc xml:space="preserve" filename="gunicode.h" line="307">Tagalog</doc>
      </member>
      <member name="hanunoo" value="43" c:identifier="G_UNICODE_SCRIPT_HANUNOO" gs:managed-name="Hanunoo">
        <doc xml:space="preserve" filename="gunicode.h" line="308">Hanunoo</doc>
      </member>
      <member name="buhid" value="44" c:identifier="G_UNICODE_SCRIPT_BUHID" gs:managed-name="Buhid">
        <doc xml:space="preserve" filename="gunicode.h" line="309">Buhid</doc>
      </member>
      <member name="tagbanwa" value="45" c:identifier="G_UNICODE_SCRIPT_TAGBANWA" gs:managed-name="Tagbanwa">
        <doc xml:space="preserve" filename="gunicode.h" line="310">Tagbanwa</doc>
      </member>
      <member name="braille" value="46" c:identifier="G_UNICODE_SCRIPT_BRAILLE" gs:managed-name="Braille">
        <doc xml:space="preserve" filename="gunicode.h" line="311">Braille</doc>
      </member>
      <member name="cypriot" value="47" c:identifier="G_UNICODE_SCRIPT_CYPRIOT" gs:managed-name="Cypriot">
        <doc xml:space="preserve" filename="gunicode.h" line="312">Cypriot</doc>
      </member>
      <member name="limbu" value="48" c:identifier="G_UNICODE_SCRIPT_LIMBU" gs:managed-name="Limbu">
        <doc xml:space="preserve" filename="gunicode.h" line="313">Limbu</doc>
      </member>
      <member name="osmanya" value="49" c:identifier="G_UNICODE_SCRIPT_OSMANYA" gs:managed-name="Osmanya">
        <doc xml:space="preserve" filename="gunicode.h" line="314">Osmanya</doc>
      </member>
      <member name="shavian" value="50" c:identifier="G_UNICODE_SCRIPT_SHAVIAN" gs:managed-name="Shavian">
        <doc xml:space="preserve" filename="gunicode.h" line="315">Shavian</doc>
      </member>
      <member name="linear_b" value="51" c:identifier="G_UNICODE_SCRIPT_LINEAR_B" gs:managed-name="LinearB">
        <doc xml:space="preserve" filename="gunicode.h" line="316">Linear B</doc>
      </member>
      <member name="tai_le" value="52" c:identifier="G_UNICODE_SCRIPT_TAI_LE" gs:managed-name="TaiLe">
        <doc xml:space="preserve" filename="gunicode.h" line="317">Tai Le</doc>
      </member>
      <member name="ugaritic" value="53" c:identifier="G_UNICODE_SCRIPT_UGARITIC" gs:managed-name="Ugaritic">
        <doc xml:space="preserve" filename="gunicode.h" line="318">Ugaritic</doc>
      </member>
      <member name="new_tai_lue" value="54" c:identifier="G_UNICODE_SCRIPT_NEW_TAI_LUE" gs:managed-name="NewTaiLue">
        <doc xml:space="preserve" filename="gunicode.h" line="319">New Tai Lue</doc>
      </member>
      <member name="buginese" value="55" c:identifier="G_UNICODE_SCRIPT_BUGINESE" gs:managed-name="Buginese">
        <doc xml:space="preserve" filename="gunicode.h" line="321">Buginese</doc>
      </member>
      <member name="glagolitic" value="56" c:identifier="G_UNICODE_SCRIPT_GLAGOLITIC" gs:managed-name="Glagolitic">
        <doc xml:space="preserve" filename="gunicode.h" line="322">Glagolitic</doc>
      </member>
      <member name="tifinagh" value="57" c:identifier="G_UNICODE_SCRIPT_TIFINAGH" gs:managed-name="Tifinagh">
        <doc xml:space="preserve" filename="gunicode.h" line="323">Tifinagh</doc>
      </member>
      <member name="syloti_nagri" value="58" c:identifier="G_UNICODE_SCRIPT_SYLOTI_NAGRI" gs:managed-name="SylotiNagri">
        <doc xml:space="preserve" filename="gunicode.h" line="324">Syloti Nagri</doc>
      </member>
      <member name="old_persian" value="59" c:identifier="G_UNICODE_SCRIPT_OLD_PERSIAN" gs:managed-name="OldPersian">
        <doc xml:space="preserve" filename="gunicode.h" line="326">Old Persian</doc>
      </member>
      <member name="kharoshthi" value="60" c:identifier="G_UNICODE_SCRIPT_KHAROSHTHI" gs:managed-name="Kharoshthi">
        <doc xml:space="preserve" filename="gunicode.h" line="328">Kharoshthi</doc>
      </member>
      <member name="unknown" value="61" c:identifier="G_UNICODE_SCRIPT_UNKNOWN" gs:managed-name="Unknown">
        <doc xml:space="preserve" filename="gunicode.h" line="329">an unassigned code point</doc>
      </member>
      <member name="balinese" value="62" c:identifier="G_UNICODE_SCRIPT_BALINESE" gs:managed-name="Balinese">
        <doc xml:space="preserve" filename="gunicode.h" line="330">Balinese</doc>
      </member>
      <member name="cuneiform" value="63" c:identifier="G_UNICODE_SCRIPT_CUNEIFORM" gs:managed-name="Cuneiform">
        <doc xml:space="preserve" filename="gunicode.h" line="331">Cuneiform</doc>
      </member>
      <member name="phoenician" value="64" c:identifier="G_UNICODE_SCRIPT_PHOENICIAN" gs:managed-name="Phoenician">
        <doc xml:space="preserve" filename="gunicode.h" line="332">Phoenician</doc>
      </member>
      <member name="phags_pa" value="65" c:identifier="G_UNICODE_SCRIPT_PHAGS_PA" gs:managed-name="PhagsPa">
        <doc xml:space="preserve" filename="gunicode.h" line="333">Phags-pa</doc>
      </member>
      <member name="nko" value="66" c:identifier="G_UNICODE_SCRIPT_NKO" gs:managed-name="Nko">
        <doc xml:space="preserve" filename="gunicode.h" line="334">N'Ko</doc>
      </member>
      <member name="kayah_li" value="67" c:identifier="G_UNICODE_SCRIPT_KAYAH_LI" version="2.16" gs:managed-name="KayahLi">
        <doc xml:space="preserve" filename="gunicode.h" line="335">Kayah Li.3</doc>
      </member>
      <member name="lepcha" value="68" c:identifier="G_UNICODE_SCRIPT_LEPCHA" version="2.16" gs:managed-name="Lepcha">
        <doc xml:space="preserve" filename="gunicode.h" line="336">Lepcha.3</doc>
      </member>
      <member name="rejang" value="69" c:identifier="G_UNICODE_SCRIPT_REJANG" version="2.16" gs:managed-name="Rejang">
        <doc xml:space="preserve" filename="gunicode.h" line="337">Rejang.3</doc>
      </member>
      <member name="sundanese" value="70" c:identifier="G_UNICODE_SCRIPT_SUNDANESE" version="2.16" gs:managed-name="Sundanese">
        <doc xml:space="preserve" filename="gunicode.h" line="338">Sundanese.3</doc>
      </member>
      <member name="saurashtra" value="71" c:identifier="G_UNICODE_SCRIPT_SAURASHTRA" version="2.16" gs:managed-name="Saurashtra">
        <doc xml:space="preserve" filename="gunicode.h" line="339">Saurashtra.3</doc>
      </member>
      <member name="cham" value="72" c:identifier="G_UNICODE_SCRIPT_CHAM" version="2.16" gs:managed-name="Cham">
        <doc xml:space="preserve" filename="gunicode.h" line="340">Cham.3</doc>
      </member>
      <member name="ol_chiki" value="73" c:identifier="G_UNICODE_SCRIPT_OL_CHIKI" version="2.16" gs:managed-name="OlChiki">
        <doc xml:space="preserve" filename="gunicode.h" line="341">Ol Chiki.3</doc>
      </member>
      <member name="vai" value="74" c:identifier="G_UNICODE_SCRIPT_VAI" version="2.16" gs:managed-name="Vai">
        <doc xml:space="preserve" filename="gunicode.h" line="342">Vai.3</doc>
      </member>
      <member name="carian" value="75" c:identifier="G_UNICODE_SCRIPT_CARIAN" version="2.16" gs:managed-name="Carian">
        <doc xml:space="preserve" filename="gunicode.h" line="343">Carian.3</doc>
      </member>
      <member name="lycian" value="76" c:identifier="G_UNICODE_SCRIPT_LYCIAN" version="2.16" gs:managed-name="Lycian">
        <doc xml:space="preserve" filename="gunicode.h" line="344">Lycian.3</doc>
      </member>
      <member name="lydian" value="77" c:identifier="G_UNICODE_SCRIPT_LYDIAN" version="2.16" gs:managed-name="Lydian">
        <doc xml:space="preserve" filename="gunicode.h" line="345">Lydian.3</doc>
      </member>
      <member name="avestan" value="78" c:identifier="G_UNICODE_SCRIPT_AVESTAN" version="2.26" gs:managed-name="Avestan">
        <doc xml:space="preserve" filename="gunicode.h" line="346">Avestan.</doc>
      </member>
      <member name="bamum" value="79" c:identifier="G_UNICODE_SCRIPT_BAMUM" version="2.26" gs:managed-name="Bamum">
        <doc xml:space="preserve" filename="gunicode.h" line="347">Bamum.</doc>
      </member>
      <member name="egyptian_hieroglyphs" value="80" c:identifier="G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS" version="2.26" gs:managed-name="EgyptianHieroglyphs">
        <doc xml:space="preserve" filename="gunicode.h" line="348">Egyptian Hieroglpyhs.</doc>
      </member>
      <member name="imperial_aramaic" value="81" c:identifier="G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC" version="2.26" gs:managed-name="ImperialAramaic">
        <doc xml:space="preserve" filename="gunicode.h" line="350">Imperial Aramaic.</doc>
      </member>
      <member name="inscriptional_pahlavi" value="82" c:identifier="G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI" version="2.26" gs:managed-name="InscriptionalPahlavi">
        <doc xml:space="preserve" filename="gunicode.h" line="352">Inscriptional Pahlavi.</doc>
      </member>
      <member name="inscriptional_parthian" value="83" c:identifier="G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN" version="2.26" gs:managed-name="InscriptionalParthian">
        <doc xml:space="preserve" filename="gunicode.h" line="354">Inscriptional Parthian.</doc>
      </member>
      <member name="javanese" value="84" c:identifier="G_UNICODE_SCRIPT_JAVANESE" version="2.26" gs:managed-name="Javanese">
        <doc xml:space="preserve" filename="gunicode.h" line="356">Javanese.</doc>
      </member>
      <member name="kaithi" value="85" c:identifier="G_UNICODE_SCRIPT_KAITHI" version="2.26" gs:managed-name="Kaithi">
        <doc xml:space="preserve" filename="gunicode.h" line="357">Kaithi.</doc>
      </member>
      <member name="lisu" value="86" c:identifier="G_UNICODE_SCRIPT_LISU" version="2.26" gs:managed-name="Lisu">
        <doc xml:space="preserve" filename="gunicode.h" line="358">Lisu.</doc>
      </member>
      <member name="meetei_mayek" value="87" c:identifier="G_UNICODE_SCRIPT_MEETEI_MAYEK" version="2.26" gs:managed-name="MeeteiMayek">
        <doc xml:space="preserve" filename="gunicode.h" line="359">Meetei Mayek.</doc>
      </member>
      <member name="old_south_arabian" value="88" c:identifier="G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN" version="2.26" gs:managed-name="OldSouthArabian">
        <doc xml:space="preserve" filename="gunicode.h" line="361">Old South Arabian.</doc>
      </member>
      <member name="old_turkic" value="89" c:identifier="G_UNICODE_SCRIPT_OLD_TURKIC" version="2.28" gs:managed-name="OldTurkic">
        <doc xml:space="preserve" filename="gunicode.h" line="363">Old Turkic.</doc>
      </member>
      <member name="samaritan" value="90" c:identifier="G_UNICODE_SCRIPT_SAMARITAN" version="2.26" gs:managed-name="Samaritan">
        <doc xml:space="preserve" filename="gunicode.h" line="364">Samaritan.</doc>
      </member>
      <member name="tai_tham" value="91" c:identifier="G_UNICODE_SCRIPT_TAI_THAM" version="2.26" gs:managed-name="TaiTham">
        <doc xml:space="preserve" filename="gunicode.h" line="365">Tai Tham.</doc>
      </member>
      <member name="tai_viet" value="92" c:identifier="G_UNICODE_SCRIPT_TAI_VIET" version="2.26" gs:managed-name="TaiViet">
        <doc xml:space="preserve" filename="gunicode.h" line="366">Tai Viet.</doc>
      </member>
      <member name="batak" value="93" c:identifier="G_UNICODE_SCRIPT_BATAK" version="2.28" gs:managed-name="Batak">
        <doc xml:space="preserve" filename="gunicode.h" line="367">Batak.</doc>
      </member>
      <member name="brahmi" value="94" c:identifier="G_UNICODE_SCRIPT_BRAHMI" version="2.28" gs:managed-name="Brahmi">
        <doc xml:space="preserve" filename="gunicode.h" line="368">Brahmi.</doc>
      </member>
      <member name="mandaic" value="95" c:identifier="G_UNICODE_SCRIPT_MANDAIC" version="2.28" gs:managed-name="Mandaic">
        <doc xml:space="preserve" filename="gunicode.h" line="369">Mandaic.</doc>
      </member>
      <member name="chakma" value="96" c:identifier="G_UNICODE_SCRIPT_CHAKMA" version="2.32" gs:managed-name="Chakma">
        <doc xml:space="preserve" filename="gunicode.h" line="370">Chakma.</doc>
      </member>
      <member name="meroitic_cursive" value="97" c:identifier="G_UNICODE_SCRIPT_MEROITIC_CURSIVE" version="2.32" gs:managed-name="MeroiticCursive">
        <doc xml:space="preserve" filename="gunicode.h" line="371">Meroitic Cursive.</doc>
      </member>
      <member name="meroitic_hieroglyphs" value="98" c:identifier="G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS" version="2.32" gs:managed-name="MeroiticHieroglyphs">
        <doc xml:space="preserve" filename="gunicode.h" line="372">Meroitic Hieroglyphs.</doc>
      </member>
      <member name="miao" value="99" c:identifier="G_UNICODE_SCRIPT_MIAO" version="2.32" gs:managed-name="Miao">
        <doc xml:space="preserve" filename="gunicode.h" line="373">Miao.</doc>
      </member>
      <member name="sharada" value="100" c:identifier="G_UNICODE_SCRIPT_SHARADA" version="2.32" gs:managed-name="Sharada">
        <doc xml:space="preserve" filename="gunicode.h" line="374">Sharada.</doc>
      </member>
      <member name="sora_sompeng" value="101" c:identifier="G_UNICODE_SCRIPT_SORA_SOMPENG" version="2.32" gs:managed-name="SoraSompeng">
        <doc xml:space="preserve" filename="gunicode.h" line="375">Sora Sompeng.</doc>
      </member>
      <member name="takri" value="102" c:identifier="G_UNICODE_SCRIPT_TAKRI" version="2.32" gs:managed-name="Takri">
        <doc xml:space="preserve" filename="gunicode.h" line="376">Takri.</doc>
      </member>
      <member name="bassa_vah" value="103" c:identifier="G_UNICODE_SCRIPT_BASSA_VAH" version="2.42" gs:managed-name="BassaVah">
        <doc xml:space="preserve" filename="gunicode.h" line="377">Bassa.</doc>
      </member>
      <member name="caucasian_albanian" value="104" c:identifier="G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN" version="2.42" gs:managed-name="CaucasianAlbanian">
        <doc xml:space="preserve" filename="gunicode.h" line="378">Caucasian Albanian.</doc>
      </member>
      <member name="duployan" value="105" c:identifier="G_UNICODE_SCRIPT_DUPLOYAN" version="2.42" gs:managed-name="Duployan">
        <doc xml:space="preserve" filename="gunicode.h" line="379">Duployan.</doc>
      </member>
      <member name="elbasan" value="106" c:identifier="G_UNICODE_SCRIPT_ELBASAN" version="2.42" gs:managed-name="Elbasan">
        <doc xml:space="preserve" filename="gunicode.h" line="380">Elbasan.</doc>
      </member>
      <member name="grantha" value="107" c:identifier="G_UNICODE_SCRIPT_GRANTHA" version="2.42" gs:managed-name="Grantha">
        <doc xml:space="preserve" filename="gunicode.h" line="381">Grantha.</doc>
      </member>
      <member name="khojki" value="108" c:identifier="G_UNICODE_SCRIPT_KHOJKI" version="2.42" gs:managed-name="Khojki">
        <doc xml:space="preserve" filename="gunicode.h" line="382">Kjohki.</doc>
      </member>
      <member name="khudawadi" value="109" c:identifier="G_UNICODE_SCRIPT_KHUDAWADI" version="2.42" gs:managed-name="Khudawadi">
        <doc xml:space="preserve" filename="gunicode.h" line="383">Khudawadi, Sindhi.</doc>
      </member>
      <member name="linear_a" value="110" c:identifier="G_UNICODE_SCRIPT_LINEAR_A" version="2.42" gs:managed-name="LinearA">
        <doc xml:space="preserve" filename="gunicode.h" line="384">Linear A.</doc>
      </member>
      <member name="mahajani" value="111" c:identifier="G_UNICODE_SCRIPT_MAHAJANI" version="2.42" gs:managed-name="Mahajani">
        <doc xml:space="preserve" filename="gunicode.h" line="385">Mahajani.</doc>
      </member>
      <member name="manichaean" value="112" c:identifier="G_UNICODE_SCRIPT_MANICHAEAN" version="2.42" gs:managed-name="Manichaean">
        <doc xml:space="preserve" filename="gunicode.h" line="386">Manichaean.</doc>
      </member>
      <member name="mende_kikakui" value="113" c:identifier="G_UNICODE_SCRIPT_MENDE_KIKAKUI" version="2.42" gs:managed-name="MendeKikakui">
        <doc xml:space="preserve" filename="gunicode.h" line="387">Mende Kikakui.</doc>
      </member>
      <member name="modi" value="114" c:identifier="G_UNICODE_SCRIPT_MODI" version="2.42" gs:managed-name="Modi">
        <doc xml:space="preserve" filename="gunicode.h" line="388">Modi.</doc>
      </member>
      <member name="mro" value="115" c:identifier="G_UNICODE_SCRIPT_MRO" version="2.42" gs:managed-name="Mro">
        <doc xml:space="preserve" filename="gunicode.h" line="389">Mro.</doc>
      </member>
      <member name="nabataean" value="116" c:identifier="G_UNICODE_SCRIPT_NABATAEAN" version="2.42" gs:managed-name="Nabataean">
        <doc xml:space="preserve" filename="gunicode.h" line="390">Nabataean.</doc>
      </member>
      <member name="old_north_arabian" value="117" c:identifier="G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN" version="2.42" gs:managed-name="OldNorthArabian">
        <doc xml:space="preserve" filename="gunicode.h" line="391">Old North Arabian.</doc>
      </member>
      <member name="old_permic" value="118" c:identifier="G_UNICODE_SCRIPT_OLD_PERMIC" version="2.42" gs:managed-name="OldPermic">
        <doc xml:space="preserve" filename="gunicode.h" line="392">Old Permic.</doc>
      </member>
      <member name="pahawh_hmong" value="119" c:identifier="G_UNICODE_SCRIPT_PAHAWH_HMONG" version="2.42" gs:managed-name="PahawhHmong">
        <doc xml:space="preserve" filename="gunicode.h" line="393">Pahawh Hmong.</doc>
      </member>
      <member name="palmyrene" value="120" c:identifier="G_UNICODE_SCRIPT_PALMYRENE" version="2.42" gs:managed-name="Palmyrene">
        <doc xml:space="preserve" filename="gunicode.h" line="394">Palmyrene.</doc>
      </member>
      <member name="pau_cin_hau" value="121" c:identifier="G_UNICODE_SCRIPT_PAU_CIN_HAU" version="2.42" gs:managed-name="PauCinHau">
        <doc xml:space="preserve" filename="gunicode.h" line="395">Pau Cin Hau.</doc>
      </member>
      <member name="psalter_pahlavi" value="122" c:identifier="G_UNICODE_SCRIPT_PSALTER_PAHLAVI" version="2.42" gs:managed-name="PsalterPahlavi">
        <doc xml:space="preserve" filename="gunicode.h" line="396">Psalter Pahlavi.</doc>
      </member>
      <member name="siddham" value="123" c:identifier="G_UNICODE_SCRIPT_SIDDHAM" version="2.42" gs:managed-name="Siddham">
        <doc xml:space="preserve" filename="gunicode.h" line="397">Siddham.</doc>
      </member>
      <member name="tirhuta" value="124" c:identifier="G_UNICODE_SCRIPT_TIRHUTA" version="2.42" gs:managed-name="Tirhuta">
        <doc xml:space="preserve" filename="gunicode.h" line="398">Tirhuta.</doc>
      </member>
      <member name="warang_citi" value="125" c:identifier="G_UNICODE_SCRIPT_WARANG_CITI" version="2.42" gs:managed-name="WarangCiti">
        <doc xml:space="preserve" filename="gunicode.h" line="399">Warang Citi.</doc>
      </member>
      <member name="ahom" value="126" c:identifier="G_UNICODE_SCRIPT_AHOM" version="2.48" gs:managed-name="Ahom">
        <doc xml:space="preserve" filename="gunicode.h" line="400">Ahom.</doc>
      </member>
      <member name="anatolian_hieroglyphs" value="127" c:identifier="G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS" version="2.48" gs:managed-name="AnatolianHieroglyphs">
        <doc xml:space="preserve" filename="gunicode.h" line="401">Anatolian Hieroglyphs.</doc>
      </member>
      <member name="hatran" value="128" c:identifier="G_UNICODE_SCRIPT_HATRAN" version="2.48" gs:managed-name="Hatran">
        <doc xml:space="preserve" filename="gunicode.h" line="402">Hatran.</doc>
      </member>
      <member name="multani" value="129" c:identifier="G_UNICODE_SCRIPT_MULTANI" version="2.48" gs:managed-name="Multani">
        <doc xml:space="preserve" filename="gunicode.h" line="403">Multani.</doc>
      </member>
      <member name="old_hungarian" value="130" c:identifier="G_UNICODE_SCRIPT_OLD_HUNGARIAN" version="2.48" gs:managed-name="OldHungarian">
        <doc xml:space="preserve" filename="gunicode.h" line="404">Old Hungarian.</doc>
      </member>
      <member name="signwriting" value="131" c:identifier="G_UNICODE_SCRIPT_SIGNWRITING" version="2.48" gs:managed-name="Signwriting">
        <doc xml:space="preserve" filename="gunicode.h" line="405">Signwriting.</doc>
      </member>
      <member name="adlam" value="132" c:identifier="G_UNICODE_SCRIPT_ADLAM" version="2.50" gs:managed-name="Adlam">
        <doc xml:space="preserve" filename="gunicode.h" line="406">Adlam.</doc>
      </member>
      <member name="bhaiksuki" value="133" c:identifier="G_UNICODE_SCRIPT_BHAIKSUKI" version="2.50" gs:managed-name="Bhaiksuki">
        <doc xml:space="preserve" filename="gunicode.h" line="407">Bhaiksuki.</doc>
      </member>
      <member name="marchen" value="134" c:identifier="G_UNICODE_SCRIPT_MARCHEN" version="2.50" gs:managed-name="Marchen">
        <doc xml:space="preserve" filename="gunicode.h" line="408">Marchen.</doc>
      </member>
      <member name="newa" value="135" c:identifier="G_UNICODE_SCRIPT_NEWA" version="2.50" gs:managed-name="Newa">
        <doc xml:space="preserve" filename="gunicode.h" line="409">Newa.</doc>
      </member>
      <member name="osage" value="136" c:identifier="G_UNICODE_SCRIPT_OSAGE" version="2.50" gs:managed-name="Osage">
        <doc xml:space="preserve" filename="gunicode.h" line="410">Osage.</doc>
      </member>
      <member name="tangut" value="137" c:identifier="G_UNICODE_SCRIPT_TANGUT" version="2.50" gs:managed-name="Tangut">
        <doc xml:space="preserve" filename="gunicode.h" line="411">Tangut.</doc>
      </member>
      <member name="masaram_gondi" value="138" c:identifier="G_UNICODE_SCRIPT_MASARAM_GONDI" version="2.54" gs:managed-name="MasaramGondi">
        <doc xml:space="preserve" filename="gunicode.h" line="412">Masaram Gondi.</doc>
      </member>
      <member name="nushu" value="139" c:identifier="G_UNICODE_SCRIPT_NUSHU" version="2.54" gs:managed-name="Nushu">
        <doc xml:space="preserve" filename="gunicode.h" line="413">Nushu.</doc>
      </member>
      <member name="soyombo" value="140" c:identifier="G_UNICODE_SCRIPT_SOYOMBO" version="2.54" gs:managed-name="Soyombo">
        <doc xml:space="preserve" filename="gunicode.h" line="414">Soyombo.</doc>
      </member>
      <member name="zanabazar_square" value="141" c:identifier="G_UNICODE_SCRIPT_ZANABAZAR_SQUARE" version="2.54" gs:managed-name="ZanabazarSquare">
        <doc xml:space="preserve" filename="gunicode.h" line="415">Zanabazar Square.</doc>
      </member>
      <member name="dogra" value="142" c:identifier="G_UNICODE_SCRIPT_DOGRA" version="2.58" gs:managed-name="Dogra">
        <doc xml:space="preserve" filename="gunicode.h" line="416">Dogra.</doc>
      </member>
      <member name="gunjala_gondi" value="143" c:identifier="G_UNICODE_SCRIPT_GUNJALA_GONDI" version="2.58" gs:managed-name="GunjalaGondi">
        <doc xml:space="preserve" filename="gunicode.h" line="417">Gunjala Gondi.</doc>
      </member>
      <member name="hanifi_rohingya" value="144" c:identifier="G_UNICODE_SCRIPT_HANIFI_ROHINGYA" version="2.58" gs:managed-name="HanifiRohingya">
        <doc xml:space="preserve" filename="gunicode.h" line="418">Hanifi Rohingya.</doc>
      </member>
      <member name="makasar" value="145" c:identifier="G_UNICODE_SCRIPT_MAKASAR" version="2.58" gs:managed-name="Makasar">
        <doc xml:space="preserve" filename="gunicode.h" line="419">Makasar.</doc>
      </member>
      <member name="medefaidrin" value="146" c:identifier="G_UNICODE_SCRIPT_MEDEFAIDRIN" version="2.58" gs:managed-name="Medefaidrin">
        <doc xml:space="preserve" filename="gunicode.h" line="420">Medefaidrin.</doc>
      </member>
      <member name="old_sogdian" value="147" c:identifier="G_UNICODE_SCRIPT_OLD_SOGDIAN" version="2.58" gs:managed-name="OldSogdian">
        <doc xml:space="preserve" filename="gunicode.h" line="421">Old Sogdian.</doc>
      </member>
      <member name="sogdian" value="148" c:identifier="G_UNICODE_SCRIPT_SOGDIAN" version="2.58" gs:managed-name="Sogdian">
        <doc xml:space="preserve" filename="gunicode.h" line="422">Sogdian.</doc>
      </member>
      <member name="elymaic" value="149" c:identifier="G_UNICODE_SCRIPT_ELYMAIC" version="2.62" gs:managed-name="Elymaic">
        <doc xml:space="preserve" filename="gunicode.h" line="423">Elym.</doc>
      </member>
      <member name="nandinagari" value="150" c:identifier="G_UNICODE_SCRIPT_NANDINAGARI" version="2.62" gs:managed-name="Nandinagari">
        <doc xml:space="preserve" filename="gunicode.h" line="424">Nand.</doc>
      </member>
      <member name="nyiakeng_puachue_hmong" value="151" c:identifier="G_UNICODE_SCRIPT_NYIAKENG_PUACHUE_HMONG" version="2.62" gs:managed-name="NyiakengPuachueHmong">
        <doc xml:space="preserve" filename="gunicode.h" line="425">Rohg.</doc>
      </member>
      <member name="wancho" value="152" c:identifier="G_UNICODE_SCRIPT_WANCHO" version="2.62" gs:managed-name="Wancho">
        <doc xml:space="preserve" filename="gunicode.h" line="426">Wcho.</doc>
      </member>
      <member name="chorasmian" value="153" c:identifier="G_UNICODE_SCRIPT_CHORASMIAN" version="2.66" gs:managed-name="Chorasmian">
        <doc xml:space="preserve" filename="gunicode.h" line="427">Chorasmian.</doc>
      </member>
      <member name="dives_akuru" value="154" c:identifier="G_UNICODE_SCRIPT_DIVES_AKURU" version="2.66" gs:managed-name="DivesAkuru">
        <doc xml:space="preserve" filename="gunicode.h" line="428">Dives Akuru.</doc>
      </member>
      <member name="khitan_small_script" value="155" c:identifier="G_UNICODE_SCRIPT_KHITAN_SMALL_SCRIPT" version="2.66" gs:managed-name="KhitanSmallScript">
        <doc xml:space="preserve" filename="gunicode.h" line="429">Khitan small script.</doc>
      </member>
      <member name="yezidi" value="156" c:identifier="G_UNICODE_SCRIPT_YEZIDI" version="2.66" gs:managed-name="Yezidi">
        <doc xml:space="preserve" filename="gunicode.h" line="430">Yezidi.</doc>
      </member>
      <function name="from_iso15924" c:identifier="g_unicode_script_from_iso15924" version="2.30" gs:dll-name="glib-2.0" gs:managed-name="FromIso15924">
        <doc xml:space="preserve" filename="glib-2.0.c" line="35646">Looks up the Unicode script for @iso15924.  ISO 15924 assigns four-letter
codes to scripts.  For example, the code for Arabic is 'Arab'.
This function accepts four letter codes encoded as a @guint32 in a
big-endian fashion.  That is, the code expected for Arabic is
0x41726162 (0x41 is ASCII code for 'A', 0x72 is ASCII code for 'r', etc).

See
[Codes for the representation of names of scripts](http://unicode.org/iso15924/codelists.html)
for details.</doc>
        <source-position filename="gunicode.h" line="634" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="35660">the Unicode script for @iso15924, or
  of %G_UNICODE_SCRIPT_INVALID_CODE if @iso15924 is zero and
  %G_UNICODE_SCRIPT_UNKNOWN if @iso15924 is unknown.</doc>
          <type name="UnicodeScript" c:type="GUnicodeScript" gs:managed-name="UnicodeScript" />
        </return-value>
        <parameters>
          <parameter name="iso15924" transfer-ownership="none" gs:managed-name="iso15924" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35648">a Unicode script</doc>
            <type name="guint32" c:type="guint32" gs:managed-name="System.UInt32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="iso15924" transfer-ownership="none" gs:managed-name="iso15924" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35648">a Unicode script</doc>
            <type name="guint32" c:type="guint32" gs:managed-name="System.UInt32" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <method name="to_iso15924" c:identifier="g_unicode_script_to_iso15924" version="2.30" gs:dll-name="glib-2.0" gs:managed-name="ToIso15924" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="35667">Looks up the ISO 15924 code for @script.  ISO 15924 assigns four-letter
codes to scripts.  For example, the code for Arabic is 'Arab'.  The
four letter codes are encoded as a @guint32 by this function in a
big-endian fashion.  That is, the code returned for Arabic is
0x41726162 (0x41 is ASCII code for 'A', 0x72 is ASCII code for 'r', etc).

See
[Codes for the representation of names of scripts](http://unicode.org/iso15924/codelists.html)
for details.</doc>
        <source-position filename="gunicode.h" line="632" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="35681">the ISO 15924 code for @script, encoded as an integer,
  of zero if @script is %G_UNICODE_SCRIPT_INVALID_CODE or
  ISO 15924 code 'Zzzz' (script code for UNKNOWN) if @script is not understood.</doc>
          <type name="guint32" c:type="guint32" gs:managed-name="System.UInt32" />
        </return-value>
        <parameters>
          <instance-parameter name="script" transfer-ownership="none" gs:managed-name="script" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35669">a Unicode script</doc>
            <type name="UnicodeScript" c:type="GUnicodeScript" gs:managed-name="UnicodeScript" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="script" transfer-ownership="none" gs:managed-name="script" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35669">a Unicode script</doc>
            <type name="UnicodeScript" c:type="GUnicodeScript" gs:managed-name="UnicodeScript" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
    </enumeration>
    <enumeration name="UnicodeType" c:type="GUnicodeType" gs:managed-name="UnicodeType">
      <doc xml:space="preserve" filename="gunicode.h" line="79">These are the possible character classifications from the
Unicode specification.
See [Unicode Character Database](http://www.unicode.org/reports/tr44/#General_Category_Values).</doc>
      <source-position filename="gunicode.h" line="148" />
      <member name="control" value="0" c:identifier="G_UNICODE_CONTROL" gs:managed-name="Control">
        <doc xml:space="preserve" filename="gunicode.h" line="81">General category "Other, Control" (Cc)</doc>
      </member>
      <member name="format" value="1" c:identifier="G_UNICODE_FORMAT" gs:managed-name="Format">
        <doc xml:space="preserve" filename="gunicode.h" line="82">General category "Other, Format" (Cf)</doc>
      </member>
      <member name="unassigned" value="2" c:identifier="G_UNICODE_UNASSIGNED" gs:managed-name="Unassigned">
        <doc xml:space="preserve" filename="gunicode.h" line="83">General category "Other, Not Assigned" (Cn)</doc>
      </member>
      <member name="private_use" value="3" c:identifier="G_UNICODE_PRIVATE_USE" gs:managed-name="PrivateUse">
        <doc xml:space="preserve" filename="gunicode.h" line="84">General category "Other, Private Use" (Co)</doc>
      </member>
      <member name="surrogate" value="4" c:identifier="G_UNICODE_SURROGATE" gs:managed-name="Surrogate">
        <doc xml:space="preserve" filename="gunicode.h" line="85">General category "Other, Surrogate" (Cs)</doc>
      </member>
      <member name="lowercase_letter" value="5" c:identifier="G_UNICODE_LOWERCASE_LETTER" gs:managed-name="LowercaseLetter">
        <doc xml:space="preserve" filename="gunicode.h" line="86">General category "Letter, Lowercase" (Ll)</doc>
      </member>
      <member name="modifier_letter" value="6" c:identifier="G_UNICODE_MODIFIER_LETTER" gs:managed-name="ModifierLetter">
        <doc xml:space="preserve" filename="gunicode.h" line="87">General category "Letter, Modifier" (Lm)</doc>
      </member>
      <member name="other_letter" value="7" c:identifier="G_UNICODE_OTHER_LETTER" gs:managed-name="OtherLetter">
        <doc xml:space="preserve" filename="gunicode.h" line="88">General category "Letter, Other" (Lo)</doc>
      </member>
      <member name="titlecase_letter" value="8" c:identifier="G_UNICODE_TITLECASE_LETTER" gs:managed-name="TitlecaseLetter">
        <doc xml:space="preserve" filename="gunicode.h" line="89">General category "Letter, Titlecase" (Lt)</doc>
      </member>
      <member name="uppercase_letter" value="9" c:identifier="G_UNICODE_UPPERCASE_LETTER" gs:managed-name="UppercaseLetter">
        <doc xml:space="preserve" filename="gunicode.h" line="90">General category "Letter, Uppercase" (Lu)</doc>
      </member>
      <member name="spacing_mark" value="10" c:identifier="G_UNICODE_SPACING_MARK" gs:managed-name="SpacingMark">
        <doc xml:space="preserve" filename="gunicode.h" line="91">General category "Mark, Spacing" (Mc)</doc>
      </member>
      <member name="enclosing_mark" value="11" c:identifier="G_UNICODE_ENCLOSING_MARK" gs:managed-name="EnclosingMark">
        <doc xml:space="preserve" filename="gunicode.h" line="92">General category "Mark, Enclosing" (Me)</doc>
      </member>
      <member name="non_spacing_mark" value="12" c:identifier="G_UNICODE_NON_SPACING_MARK" gs:managed-name="NonSpacingMark">
        <doc xml:space="preserve" filename="gunicode.h" line="93">General category "Mark, Nonspacing" (Mn)</doc>
      </member>
      <member name="decimal_number" value="13" c:identifier="G_UNICODE_DECIMAL_NUMBER" gs:managed-name="DecimalNumber">
        <doc xml:space="preserve" filename="gunicode.h" line="94">General category "Number, Decimal Digit" (Nd)</doc>
      </member>
      <member name="letter_number" value="14" c:identifier="G_UNICODE_LETTER_NUMBER" gs:managed-name="LetterNumber">
        <doc xml:space="preserve" filename="gunicode.h" line="95">General category "Number, Letter" (Nl)</doc>
      </member>
      <member name="other_number" value="15" c:identifier="G_UNICODE_OTHER_NUMBER" gs:managed-name="OtherNumber">
        <doc xml:space="preserve" filename="gunicode.h" line="96">General category "Number, Other" (No)</doc>
      </member>
      <member name="connect_punctuation" value="16" c:identifier="G_UNICODE_CONNECT_PUNCTUATION" gs:managed-name="ConnectPunctuation">
        <doc xml:space="preserve" filename="gunicode.h" line="97">General category "Punctuation, Connector" (Pc)</doc>
      </member>
      <member name="dash_punctuation" value="17" c:identifier="G_UNICODE_DASH_PUNCTUATION" gs:managed-name="DashPunctuation">
        <doc xml:space="preserve" filename="gunicode.h" line="98">General category "Punctuation, Dash" (Pd)</doc>
      </member>
      <member name="close_punctuation" value="18" c:identifier="G_UNICODE_CLOSE_PUNCTUATION" gs:managed-name="ClosePunctuation">
        <doc xml:space="preserve" filename="gunicode.h" line="99">General category "Punctuation, Close" (Pe)</doc>
      </member>
      <member name="final_punctuation" value="19" c:identifier="G_UNICODE_FINAL_PUNCTUATION" gs:managed-name="FinalPunctuation">
        <doc xml:space="preserve" filename="gunicode.h" line="100">General category "Punctuation, Final quote" (Pf)</doc>
      </member>
      <member name="initial_punctuation" value="20" c:identifier="G_UNICODE_INITIAL_PUNCTUATION" gs:managed-name="InitialPunctuation">
        <doc xml:space="preserve" filename="gunicode.h" line="101">General category "Punctuation, Initial quote" (Pi)</doc>
      </member>
      <member name="other_punctuation" value="21" c:identifier="G_UNICODE_OTHER_PUNCTUATION" gs:managed-name="OtherPunctuation">
        <doc xml:space="preserve" filename="gunicode.h" line="102">General category "Punctuation, Other" (Po)</doc>
      </member>
      <member name="open_punctuation" value="22" c:identifier="G_UNICODE_OPEN_PUNCTUATION" gs:managed-name="OpenPunctuation">
        <doc xml:space="preserve" filename="gunicode.h" line="103">General category "Punctuation, Open" (Ps)</doc>
      </member>
      <member name="currency_symbol" value="23" c:identifier="G_UNICODE_CURRENCY_SYMBOL" gs:managed-name="CurrencySymbol">
        <doc xml:space="preserve" filename="gunicode.h" line="104">General category "Symbol, Currency" (Sc)</doc>
      </member>
      <member name="modifier_symbol" value="24" c:identifier="G_UNICODE_MODIFIER_SYMBOL" gs:managed-name="ModifierSymbol">
        <doc xml:space="preserve" filename="gunicode.h" line="105">General category "Symbol, Modifier" (Sk)</doc>
      </member>
      <member name="math_symbol" value="25" c:identifier="G_UNICODE_MATH_SYMBOL" gs:managed-name="MathSymbol">
        <doc xml:space="preserve" filename="gunicode.h" line="106">General category "Symbol, Math" (Sm)</doc>
      </member>
      <member name="other_symbol" value="26" c:identifier="G_UNICODE_OTHER_SYMBOL" gs:managed-name="OtherSymbol">
        <doc xml:space="preserve" filename="gunicode.h" line="107">General category "Symbol, Other" (So)</doc>
      </member>
      <member name="line_separator" value="27" c:identifier="G_UNICODE_LINE_SEPARATOR" gs:managed-name="LineSeparator">
        <doc xml:space="preserve" filename="gunicode.h" line="108">General category "Separator, Line" (Zl)</doc>
      </member>
      <member name="paragraph_separator" value="28" c:identifier="G_UNICODE_PARAGRAPH_SEPARATOR" gs:managed-name="ParagraphSeparator">
        <doc xml:space="preserve" filename="gunicode.h" line="109">General category "Separator, Paragraph" (Zp)</doc>
      </member>
      <member name="space_separator" value="29" c:identifier="G_UNICODE_SPACE_SEPARATOR" gs:managed-name="SpaceSeparator">
        <doc xml:space="preserve" filename="gunicode.h" line="110">General category "Separator, Space" (Zs)</doc>
      </member>
    </enumeration>
    <record name="Variant" c:type="GVariant" version="2.24" glib:type-name="GVariant" glib:get-type="intern" c:symbol-prefix="variant" gs:managed-name="Variant">
      <doc xml:space="preserve" filename="glib-2.0.c" line="6210">#GVariant is a variant datatype; it can contain one or more values
along with information about the type of the values.

A #GVariant may contain simple types, like an integer, or a boolean value;
or complex types, like an array of two strings, or a dictionary of key
value pairs. A #GVariant is also immutable: once it's been created neither
its type nor its content can be modified further.

GVariant is useful whenever data needs to be serialized, for example when
sending method parameters in DBus, or when saving settings using GSettings.

When creating a new #GVariant, you pass the data you want to store in it
along with a string representing the type of data you wish to pass to it.

For instance, if you want to create a #GVariant holding an integer value you
can use:

|[&lt;!-- language="C" --&gt;
  GVariant *v = g_variant_new ("u", 40);
]|

The string "u" in the first argument tells #GVariant that the data passed to
the constructor (40) is going to be an unsigned integer.

More advanced examples of #GVariant in use can be found in documentation for
[GVariant format strings][gvariant-format-strings-pointers].

The range of possible values is determined by the type.

The type system used by #GVariant is #GVariantType.

#GVariant instances always have a type and a value (which are given
at construction time).  The type and value of a #GVariant instance
can never change other than by the #GVariant itself being
destroyed.  A #GVariant cannot contain a pointer.

#GVariant is reference counted using g_variant_ref() and
g_variant_unref().  #GVariant also has floating reference counts --
see g_variant_ref_sink().

#GVariant is completely threadsafe.  A #GVariant instance can be
concurrently accessed in any way from any number of threads without
problems.

#GVariant is heavily optimised for dealing with data in serialised
form.  It works particularly well with data located in memory-mapped
files.  It can perform nearly all deserialisation operations in a
small constant time, usually touching only a single memory page.
Serialised #GVariant data can also be sent over the network.

#GVariant is largely compatible with D-Bus.  Almost all types of
#GVariant instances can be sent over D-Bus.  See #GVariantType for
exceptions.  (However, #GVariant's serialisation format is not the same
as the serialisation format of a D-Bus message body: use #GDBusMessage,
in the gio library, for those.)

For space-efficiency, the #GVariant serialisation format does not
automatically include the variant's length, type or endianness,
which must either be implied from context (such as knowledge that a
particular file format always contains a little-endian
%G_VARIANT_TYPE_VARIANT which occupies the whole length of the file)
or supplied out-of-band (for instance, a length, type and/or endianness
indicator could be placed at the beginning of a file, network message
or network stream).

A #GVariant's size is limited mainly by any lower level operating
system constraints, such as the number of bits in #gsize.  For
example, it is reasonable to have a 2GB file mapped into memory
with #GMappedFile, and call g_variant_new_from_data() on it.

For convenience to C programmers, #GVariant features powerful
varargs-based value construction and destruction.  This feature is
designed to be embedded in other libraries.

There is a Python-inspired text language for describing #GVariant
values.  #GVariant includes a printer for this language and a parser
with type inferencing.

## Memory Use

#GVariant tries to be quite efficient with respect to memory use.
This section gives a rough idea of how much memory is used by the
current implementation.  The information here is subject to change
in the future.

The memory allocated by #GVariant can be grouped into 4 broad
purposes: memory for serialised data, memory for the type
information cache, buffer management memory and memory for the
#GVariant structure itself.

## Serialised Data Memory

This is the memory that is used for storing GVariant data in
serialised form.  This is what would be sent over the network or
what would end up on disk, not counting any indicator of the
endianness, or of the length or type of the top-level variant.

The amount of memory required to store a boolean is 1 byte. 16,
32 and 64 bit integers and double precision floating point numbers
use their "natural" size.  Strings (including object path and
signature strings) are stored with a nul terminator, and as such
use the length of the string plus 1 byte.

Maybe types use no space at all to represent the null value and
use the same amount of space (sometimes plus one byte) as the
equivalent non-maybe-typed value to represent the non-null case.

Arrays use the amount of space required to store each of their
members, concatenated.  Additionally, if the items stored in an
array are not of a fixed-size (ie: strings, other arrays, etc)
then an additional framing offset is stored for each item.  The
size of this offset is either 1, 2 or 4 bytes depending on the
overall size of the container.  Additionally, extra padding bytes
are added as required for alignment of child values.

Tuples (including dictionary entries) use the amount of space
required to store each of their members, concatenated, plus one
framing offset (as per arrays) for each non-fixed-sized item in
the tuple, except for the last one.  Additionally, extra padding
bytes are added as required for alignment of child values.

Variants use the same amount of space as the item inside of the
variant, plus 1 byte, plus the length of the type string for the
item inside the variant.

As an example, consider a dictionary mapping strings to variants.
In the case that the dictionary is empty, 0 bytes are required for
the serialisation.

If we add an item "width" that maps to the int32 value of 500 then
we will use 4 byte to store the int32 (so 6 for the variant
containing it) and 6 bytes for the string.  The variant must be
aligned to 8 after the 6 bytes of the string, so that's 2 extra
bytes.  6 (string) + 2 (padding) + 6 (variant) is 14 bytes used
for the dictionary entry.  An additional 1 byte is added to the
array as a framing offset making a total of 15 bytes.

If we add another entry, "title" that maps to a nullable string
that happens to have a value of null, then we use 0 bytes for the
null value (and 3 bytes for the variant to contain it along with
its type string) plus 6 bytes for the string.  Again, we need 2
padding bytes.  That makes a total of 6 + 2 + 3 = 11 bytes.

We now require extra padding between the two items in the array.
After the 14 bytes of the first item, that's 2 bytes required.
We now require 2 framing offsets for an extra two
bytes. 14 + 2 + 11 + 2 = 29 bytes to encode the entire two-item
dictionary.

## Type Information Cache

For each GVariant type that currently exists in the program a type
information structure is kept in the type information cache.  The
type information structure is required for rapid deserialisation.

Continuing with the above example, if a #GVariant exists with the
type "a{sv}" then a type information struct will exist for
"a{sv}", "{sv}", "s", and "v".  Multiple uses of the same type
will share the same type information.  Additionally, all
single-digit types are stored in read-only static memory and do
not contribute to the writable memory footprint of a program using
#GVariant.

Aside from the type information structures stored in read-only
memory, there are two forms of type information.  One is used for
container types where there is a single element type: arrays and
maybe types.  The other is used for container types where there
are multiple element types: tuples and dictionary entries.

Array type info structures are 6 * sizeof (void *), plus the
memory required to store the type string itself.  This means that
on 32-bit systems, the cache entry for "a{sv}" would require 30
bytes of memory (plus malloc overhead).

Tuple type info structures are 6 * sizeof (void *), plus 4 *
sizeof (void *) for each item in the tuple, plus the memory
required to store the type string itself.  A 2-item tuple, for
example, would have a type information structure that consumed
writable memory in the size of 14 * sizeof (void *) (plus type
string)  This means that on 32-bit systems, the cache entry for
"{sv}" would require 61 bytes of memory (plus malloc overhead).

This means that in total, for our "a{sv}" example, 91 bytes of
type information would be allocated.

The type information cache, additionally, uses a #GHashTable to
store and look up the cached items and stores a pointer to this
hash table in static storage.  The hash table is freed when there
are zero items in the type cache.

Although these sizes may seem large it is important to remember
that a program will probably only have a very small number of
different types of values in it and that only one type information
structure is required for many different values of the same type.

## Buffer Management Memory

#GVariant uses an internal buffer management structure to deal
with the various different possible sources of serialised data
that it uses.  The buffer is responsible for ensuring that the
correct call is made when the data is no longer in use by
#GVariant.  This may involve a g_free() or a g_slice_free() or
even g_mapped_file_unref().

One buffer management structure is used for each chunk of
serialised data.  The size of the buffer management structure
is 4 * (void *).  On 32-bit systems, that's 16 bytes.

## GVariant structure

The size of a #GVariant structure is 6 * (void *).  On 32-bit
systems, that's 24 bytes.

#GVariant structures only exist if they are explicitly created
with API calls.  For example, if a #GVariant is constructed out of
serialised data for the example given above (with the dictionary)
then although there are 9 individual values that comprise the
entire dictionary (two keys, two values, two variants containing
the values, two dictionary entries, plus the dictionary itself),
only 1 #GVariant instance exists -- the one referring to the
dictionary.

If calls are made to start accessing the other values then
#GVariant instances will exist for those values only for as long
as they are in use (ie: until you call g_variant_unref()).  The
type information is shared.  The serialised data and the buffer
management structure for that serialised data is shared by the
child.

## Summary

To put the entire example together, for our dictionary mapping
strings to variants (with two entries, as given above), we are
using 91 bytes of memory for type information, 29 bytes of memory
for the serialised data, 16 bytes for buffer management and 24
bytes for the #GVariant instance, or a total of 160 bytes, plus
malloc overhead.  If we were to use g_variant_get_child_value() to
access the two dictionary entries, we would use an additional 48
bytes.  If we were to have other dictionaries of the same type, we
would use more memory for the serialised data and buffer
management for those dictionaries, but the type information would
be shared.</doc>
      <source-position filename="gvariant.h" line="34" />
      <constructor name="new_array" c:identifier="g_variant_new_array" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="NewArray">
        <doc xml:space="preserve" filename="glib-2.0.c" line="39140">Creates a new #GVariant array from @children.

@child_type must be non-%NULL if @n_children is zero.  Otherwise, the
child type is determined by inspecting the first element of the
@children array.  If @child_type is non-%NULL then it must be a
definite type.

The items of the array are taken from the @children array.  No entry
in the @children array may be %NULL.

All items in the array must have the same type, which must be the
same as @child_type, if given.

If the @children are floating references (see g_variant_ref_sink()), the
new instance takes ownership of them as if via g_variant_ref_sink().</doc>
        <source-position filename="gvariant.h" line="189" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="39163">a floating reference to a new #GVariant array</doc>
          <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="child_type" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="childType" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39142">the element type of the new array</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </parameter>
          <parameter name="children" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="children" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39143">an array of
           #GVariant pointers, the children</doc>
            <array length="2" zero-terminated="0" c:type="GVariant* const*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="n_children" transfer-ownership="none" gs:managed-name="nChildren" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39145">the length of @children</doc>
            <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="child_type" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="childType" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39142">the element type of the new array</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </parameter>
          <parameter name="children" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="children" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39143">an array of
           #GVariant pointers, the children</doc>
            <array length="2" zero-terminated="0" c:type="GVariant* const*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
            </array>
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <constructor name="new_boolean" c:identifier="g_variant_new_boolean" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="NewBoolean">
        <doc xml:space="preserve" filename="glib-2.0.c" line="39168">Creates a new boolean #GVariant instance -- either %TRUE or %FALSE.</doc>
        <source-position filename="gvariant.h" line="81" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="39174">a floating reference to a new boolean #GVariant instance</doc>
          <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39170">a #gboolean value</doc>
            <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39170">a #gboolean value</doc>
            <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <constructor name="new_byte" c:identifier="g_variant_new_byte" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="NewByte">
        <doc xml:space="preserve" filename="glib-2.0.c" line="39179">Creates a new byte #GVariant instance.</doc>
        <source-position filename="gvariant.h" line="83" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="39185">a floating reference to a new byte #GVariant instance</doc>
          <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39181">a #guint8 value</doc>
            <type name="guint8" c:type="guint8" gs:managed-name="System.Byte" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39181">a #guint8 value</doc>
            <type name="guint8" c:type="guint8" gs:managed-name="System.Byte" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <constructor name="new_bytestring" c:identifier="g_variant_new_bytestring" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="NewBytestring">
        <doc xml:space="preserve" filename="glib-2.0.c" line="39190">Creates an array-of-bytes #GVariant with the contents of @string.
This function is just like g_variant_new_string() except that the
string need not be valid UTF-8.

The nul terminator character at the end of the string is stored in
the array.</doc>
        <source-position filename="gvariant.h" line="124" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="39202">a floating reference to a new bytestring #GVariant instance</doc>
          <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="string" transfer-ownership="none" gs:managed-name="@string" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39192">a normal
         nul-terminated string in no particular encoding</doc>
            <array c:type="const gchar*" zero-terminated="1" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="guint8" gs:managed-name="System.Byte" />
            </array>
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="string" transfer-ownership="none" gs:managed-name="@string" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39192">a normal
         nul-terminated string in no particular encoding</doc>
            <array c:type="const gchar*" zero-terminated="1" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="guint8" gs:managed-name="System.Byte" />
            </array>
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <constructor name="new_bytestring_array" c:identifier="g_variant_new_bytestring_array" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="NewBytestringArray">
        <doc xml:space="preserve" filename="glib-2.0.c" line="39207">Constructs an array of bytestring #GVariant from the given array of
strings.

If @length is -1 then @strv is %NULL-terminated.</doc>
        <source-position filename="gvariant.h" line="126" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="39217">a new floating #GVariant instance</doc>
          <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="strv" transfer-ownership="none" gs:managed-name="strv" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39209">an array of strings</doc>
            <array length="1" zero-terminated="0" c:type="const gchar* const*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none" gs:managed-name="length" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39210">the length of @strv, or -1</doc>
            <type name="gssize" c:type="gssize" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="strv" transfer-ownership="none" gs:managed-name="strv" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39209">an array of strings</doc>
            <array length="1" zero-terminated="0" c:type="const gchar* const*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
            </array>
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <constructor name="new_dict_entry" c:identifier="g_variant_new_dict_entry" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="NewDictEntry">
        <doc xml:space="preserve" filename="glib-2.0.c" line="39222">Creates a new dictionary entry #GVariant. @key and @value must be
non-%NULL. @key must be a value of a basic type (ie: not a container).

If the @key or @value are floating references (see g_variant_ref_sink()),
the new instance takes ownership of them as if via g_variant_ref_sink().</doc>
        <source-position filename="gvariant.h" line="196" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="39233">a floating reference to a new dictionary entry #GVariant</doc>
          <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39224">a basic #GVariant, the key</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39225">a #GVariant, the value</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39224">a basic #GVariant, the key</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39225">a #GVariant, the value</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <constructor name="new_double" c:identifier="g_variant_new_double" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="NewDouble">
        <doc xml:space="preserve" filename="glib-2.0.c" line="39238">Creates a new double #GVariant instance.</doc>
        <source-position filename="gvariant.h" line="99" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="39244">a floating reference to a new double #GVariant instance</doc>
          <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39240">a #gdouble floating point value</doc>
            <type name="gdouble" c:type="gdouble" gs:managed-name="System.Double" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39240">a #gdouble floating point value</doc>
            <type name="gdouble" c:type="gdouble" gs:managed-name="System.Double" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <constructor name="new_fixed_array" c:identifier="g_variant_new_fixed_array" version="2.32" gs:dll-name="glib-2.0" gs:managed-name="NewFixedArray">
        <doc xml:space="preserve" filename="glib-2.0.c" line="39249">Constructs a new array #GVariant instance, where the elements are
of @element_type type.

@elements must be an array with fixed-sized elements.  Numeric types are
fixed-size as are tuples containing only other fixed-sized types.

@element_size must be the size of a single element in the array.
For example, if calling this function for an array of 32-bit integers,
you might say sizeof(gint32). This value isn't used except for the purpose
of a double-check that the form of the serialised data matches the caller's
expectation.

@n_elements must be the length of the @elements array.</doc>
        <source-position filename="gvariant.h" line="129" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="39270">a floating reference to a new array #GVariant instance</doc>
          <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="element_type" transfer-ownership="none" gs:managed-name="elementType" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39251">the #GVariantType of each element</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </parameter>
          <parameter name="elements" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="elements" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39252">a pointer to the fixed array of contiguous elements</doc>
            <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
          <parameter name="n_elements" transfer-ownership="none" gs:managed-name="nElements" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39253">the number of elements</doc>
            <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="element_size" transfer-ownership="none" gs:managed-name="elementSize" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39254">the size of each element</doc>
            <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="element_type" transfer-ownership="none" gs:managed-name="elementType" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39251">the #GVariantType of each element</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </parameter>
          <parameter name="elements" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="elements" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39252">a pointer to the fixed array of contiguous elements</doc>
            <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
          <parameter name="n_elements" transfer-ownership="none" gs:managed-name="nElements" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39253">the number of elements</doc>
            <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="element_size" transfer-ownership="none" gs:managed-name="elementSize" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39254">the size of each element</doc>
            <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <constructor name="new_from_bytes" c:identifier="g_variant_new_from_bytes" version="2.36" gs:dll-name="glib-2.0" gs:managed-name="NewFromBytes">
        <doc xml:space="preserve" filename="glib-2.0.c" line="39275">Constructs a new serialised-mode #GVariant instance.  This is the
inner interface for creation of new serialised values that gets
called from various functions in gvariant.c.

A reference is taken on @bytes.

The data in @bytes must be aligned appropriately for the @type being loaded.
Otherwise this function will internally create a copy of the memory (since
GLib 2.60) or (in older versions) fail and exit the process.</doc>
        <source-position filename="gvariant.h" line="257" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="39291">a new #GVariant with a floating reference</doc>
          <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39277">a #GVariantType</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </parameter>
          <parameter name="bytes" transfer-ownership="none" gs:managed-name="bytes" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39278">a #GBytes</doc>
            <type name="Bytes" c:type="GBytes*" gs:managed-name="Bytes" gs:is-pointer="1" />
          </parameter>
          <parameter name="trusted" transfer-ownership="none" gs:managed-name="trusted" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39279">if the contents of @bytes are trusted</doc>
            <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39277">a #GVariantType</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </parameter>
          <parameter name="bytes" transfer-ownership="none" gs:managed-name="bytes" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39278">a #GBytes</doc>
            <type name="Bytes" c:type="GBytes*" gs:managed-name="Bytes" gs:is-pointer="1" />
          </parameter>
          <parameter name="trusted" transfer-ownership="none" gs:managed-name="trusted" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39279">if the contents of @bytes are trusted</doc>
            <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <constructor name="new_from_data" c:identifier="g_variant_new_from_data" version="2.24" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="NewFromData">
        <doc xml:space="preserve" filename="glib-2.0.c" line="39296">Creates a new #GVariant instance from serialised data.

@type is the type of #GVariant instance that will be constructed.
The interpretation of @data depends on knowing the type.

@data is not modified by this function and must remain valid with an
unchanging value until such a time as @notify is called with
@user_data.  If the contents of @data change before that time then
the result is undefined.

If @data is trusted to be serialised data in normal form then
@trusted should be %TRUE.  This applies to serialised data created
within this process or read from a trusted location on the disk (such
as a file installed in /usr/lib alongside your application).  You
should set trusted to %FALSE if @data is read from the network, a
file in the user's home directory, etc.

If @data was not stored in this machine's native endianness, any multi-byte
numeric values in the returned variant will also be in non-native
endianness. g_variant_byteswap() can be used to recover the original values.

@notify will be called with @user_data when @data is no longer
needed.  The exact time of this call is unspecified and might even be
before this function returns.

Note: @data must be backed by memory that is aligned appropriately for the
@type being loaded. Otherwise this function will internally create a copy of
the memory (since GLib 2.60) or (in older versions) fail and exit the
process.</doc>
        <source-position filename="gvariant.h" line="261" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="39335">a new floating #GVariant of type @type</doc>
          <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39298">a definite #GVariantType</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </parameter>
          <parameter name="data" transfer-ownership="none" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39299">the serialised data</doc>
            <array length="2" zero-terminated="0" c:type="gconstpointer" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="guint8" gs:managed-name="System.Byte" />
            </array>
          </parameter>
          <parameter name="size" transfer-ownership="none" gs:managed-name="size" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39300">the size of @data</doc>
            <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="trusted" transfer-ownership="none" gs:managed-name="trusted" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39301">%TRUE if @data is definitely in normal form</doc>
            <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
          </parameter>
          <parameter name="notify" transfer-ownership="none" scope="async" gs:managed-name="notify" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39302">function to call when @data is no longer needed</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify" gs:managed-name="DestroyNotify" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39303">data for @notify</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39298">a definite #GVariantType</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </parameter>
          <parameter name="data" transfer-ownership="none" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39299">the serialised data</doc>
            <array length="2" zero-terminated="0" c:type="gconstpointer" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="guint8" gs:managed-name="System.Byte" />
            </array>
          </parameter>
          <parameter name="trusted" transfer-ownership="none" gs:managed-name="trusted" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39301">%TRUE if @data is definitely in normal form</doc>
            <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
          </parameter>
          <parameter name="notify" transfer-ownership="none" scope="async" gs:managed-name="notify" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39302">function to call when @data is no longer needed</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify" gs:managed-name="DestroyNotify" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39303">data for @notify</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <constructor name="new_handle" c:identifier="g_variant_new_handle" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="NewHandle">
        <doc xml:space="preserve" filename="glib-2.0.c" line="39340">Creates a new handle #GVariant instance.

By convention, handles are indexes into an array of file descriptors
that are sent alongside a D-Bus message.  If you're not interacting
with D-Bus, you probably don't need them.</doc>
        <source-position filename="gvariant.h" line="97" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="39350">a floating reference to a new handle #GVariant instance</doc>
          <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39342">a #gint32 value</doc>
            <type name="gint32" c:type="gint32" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39342">a #gint32 value</doc>
            <type name="gint32" c:type="gint32" gs:managed-name="System.Int32" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <constructor name="new_int16" c:identifier="g_variant_new_int16" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="NewInt16">
        <doc xml:space="preserve" filename="glib-2.0.c" line="39355">Creates a new int16 #GVariant instance.</doc>
        <source-position filename="gvariant.h" line="85" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="39361">a floating reference to a new int16 #GVariant instance</doc>
          <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39357">a #gint16 value</doc>
            <type name="gint16" c:type="gint16" gs:managed-name="System.Int16" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39357">a #gint16 value</doc>
            <type name="gint16" c:type="gint16" gs:managed-name="System.Int16" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <constructor name="new_int32" c:identifier="g_variant_new_int32" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="NewInt32">
        <doc xml:space="preserve" filename="glib-2.0.c" line="39366">Creates a new int32 #GVariant instance.</doc>
        <source-position filename="gvariant.h" line="89" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="39372">a floating reference to a new int32 #GVariant instance</doc>
          <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39368">a #gint32 value</doc>
            <type name="gint32" c:type="gint32" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39368">a #gint32 value</doc>
            <type name="gint32" c:type="gint32" gs:managed-name="System.Int32" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <constructor name="new_int64" c:identifier="g_variant_new_int64" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="NewInt64">
        <doc xml:space="preserve" filename="glib-2.0.c" line="39377">Creates a new int64 #GVariant instance.</doc>
        <source-position filename="gvariant.h" line="93" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="39383">a floating reference to a new int64 #GVariant instance</doc>
          <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39379">a #gint64 value</doc>
            <type name="gint64" c:type="gint64" gs:managed-name="System.Int64" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39379">a #gint64 value</doc>
            <type name="gint64" c:type="gint64" gs:managed-name="System.Int64" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <constructor name="new_maybe" c:identifier="g_variant_new_maybe" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="NewMaybe">
        <doc xml:space="preserve" filename="glib-2.0.c" line="39388">Depending on if @child is %NULL, either wraps @child inside of a
maybe container or creates a Nothing instance for the given @type.

At least one of @child_type and @child must be non-%NULL.
If @child_type is non-%NULL then it must be a definite type.
If they are both non-%NULL then @child_type must be the type
of @child.

If @child is a floating reference (see g_variant_ref_sink()), the new
instance takes ownership of @child.</doc>
        <source-position filename="gvariant.h" line="186" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="39404">a floating reference to a new #GVariant maybe instance</doc>
          <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="child_type" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="childType" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39390">the #GVariantType of the child, or %NULL</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </parameter>
          <parameter name="child" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="child" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39391">the child value, or %NULL</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="child_type" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="childType" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39390">the #GVariantType of the child, or %NULL</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </parameter>
          <parameter name="child" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="child" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39391">the child value, or %NULL</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <constructor name="new_object_path" c:identifier="g_variant_new_object_path" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="NewObjectPath">
        <doc xml:space="preserve" filename="glib-2.0.c" line="39409">Creates a D-Bus object path #GVariant with the contents of @string.
@string must be a valid D-Bus object path.  Use
g_variant_is_object_path() if you're not sure.</doc>
        <source-position filename="gvariant.h" line="108" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="39417">a floating reference to a new object path #GVariant instance</doc>
          <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="object_path" transfer-ownership="none" gs:managed-name="objectPath" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39411">a normal C nul-terminated string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="object_path" transfer-ownership="none" gs:managed-name="objectPath" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39411">a normal C nul-terminated string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <constructor name="new_objv" c:identifier="g_variant_new_objv" version="2.30" gs:dll-name="glib-2.0" gs:managed-name="NewObjv">
        <doc xml:space="preserve" filename="glib-2.0.c" line="39422">Constructs an array of object paths #GVariant from the given array of
strings.

Each string must be a valid #GVariant object path; see
g_variant_is_object_path().

If @length is -1 then @strv is %NULL-terminated.</doc>
        <source-position filename="gvariant.h" line="121" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="39435">a new floating #GVariant instance</doc>
          <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="strv" transfer-ownership="none" gs:managed-name="strv" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39424">an array of strings</doc>
            <array length="1" zero-terminated="0" c:type="const gchar* const*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="utf8" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none" gs:managed-name="length" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39425">the length of @strv, or -1</doc>
            <type name="gssize" c:type="gssize" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="strv" transfer-ownership="none" gs:managed-name="strv" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39424">an array of strings</doc>
            <array length="1" zero-terminated="0" c:type="const gchar* const*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="utf8" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
            </array>
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <constructor name="new_signature" c:identifier="g_variant_new_signature" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="NewSignature">
        <doc xml:space="preserve" filename="glib-2.0.c" line="39530">Creates a D-Bus type signature #GVariant with the contents of
@string.  @string must be a valid D-Bus type signature.  Use
g_variant_is_signature() if you're not sure.</doc>
        <source-position filename="gvariant.h" line="112" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="39538">a floating reference to a new signature #GVariant instance</doc>
          <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="signature" transfer-ownership="none" gs:managed-name="signature" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39532">a normal C nul-terminated string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="signature" transfer-ownership="none" gs:managed-name="signature" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39532">a normal C nul-terminated string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <constructor name="new_string" c:identifier="g_variant_new_string" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="NewString">
        <doc xml:space="preserve" filename="glib-2.0.c" line="39543">Creates a string #GVariant with the contents of @string.

@string must be valid UTF-8, and must not be %NULL. To encode
potentially-%NULL strings, use g_variant_new() with `ms` as the
[format string][gvariant-format-strings-maybe-types].</doc>
        <source-position filename="gvariant.h" line="101" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="39553">a floating reference to a new string #GVariant instance</doc>
          <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="string" transfer-ownership="none" gs:managed-name="@string" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39545">a normal UTF-8 nul-terminated string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="string" transfer-ownership="none" gs:managed-name="@string" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39545">a normal UTF-8 nul-terminated string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <constructor name="new_strv" c:identifier="g_variant_new_strv" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="NewStrv">
        <doc xml:space="preserve" filename="glib-2.0.c" line="39558">Constructs an array of strings #GVariant from the given array of
strings.

If @length is -1 then @strv is %NULL-terminated.</doc>
        <source-position filename="gvariant.h" line="118" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="39568">a new floating #GVariant instance</doc>
          <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="strv" transfer-ownership="none" gs:managed-name="strv" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39560">an array of strings</doc>
            <array length="1" zero-terminated="0" c:type="const gchar* const*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="utf8" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none" gs:managed-name="length" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39561">the length of @strv, or -1</doc>
            <type name="gssize" c:type="gssize" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="strv" transfer-ownership="none" gs:managed-name="strv" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39560">an array of strings</doc>
            <array length="1" zero-terminated="0" c:type="const gchar* const*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="utf8" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
            </array>
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <constructor name="new_tuple" c:identifier="g_variant_new_tuple" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="NewTuple">
        <doc xml:space="preserve" filename="glib-2.0.c" line="39595">Creates a new tuple #GVariant out of the items in @children.  The
type is determined from the types of @children.  No entry in the
@children array may be %NULL.

If @n_children is 0 then the unit tuple is constructed.

If the @children are floating references (see g_variant_ref_sink()), the
new instance takes ownership of them as if via g_variant_ref_sink().</doc>
        <source-position filename="gvariant.h" line="193" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="39609">a floating reference to a new #GVariant tuple</doc>
          <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="children" transfer-ownership="none" gs:managed-name="children" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39597">the items to make the tuple out of</doc>
            <array length="1" zero-terminated="0" c:type="GVariant* const*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="n_children" transfer-ownership="none" gs:managed-name="nChildren" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39598">the length of @children</doc>
            <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="children" transfer-ownership="none" gs:managed-name="children" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39597">the items to make the tuple out of</doc>
            <array length="1" zero-terminated="0" c:type="GVariant* const*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
            </array>
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <constructor name="new_uint16" c:identifier="g_variant_new_uint16" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="NewUint16">
        <doc xml:space="preserve" filename="glib-2.0.c" line="39614">Creates a new uint16 #GVariant instance.</doc>
        <source-position filename="gvariant.h" line="87" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="39620">a floating reference to a new uint16 #GVariant instance</doc>
          <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39616">a #guint16 value</doc>
            <type name="guint16" c:type="guint16" gs:managed-name="System.UInt16" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39616">a #guint16 value</doc>
            <type name="guint16" c:type="guint16" gs:managed-name="System.UInt16" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <constructor name="new_uint32" c:identifier="g_variant_new_uint32" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="NewUint32">
        <doc xml:space="preserve" filename="glib-2.0.c" line="39625">Creates a new uint32 #GVariant instance.</doc>
        <source-position filename="gvariant.h" line="91" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="39631">a floating reference to a new uint32 #GVariant instance</doc>
          <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39627">a #guint32 value</doc>
            <type name="guint32" c:type="guint32" gs:managed-name="System.UInt32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39627">a #guint32 value</doc>
            <type name="guint32" c:type="guint32" gs:managed-name="System.UInt32" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <constructor name="new_uint64" c:identifier="g_variant_new_uint64" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="NewUint64">
        <doc xml:space="preserve" filename="glib-2.0.c" line="39636">Creates a new uint64 #GVariant instance.</doc>
        <source-position filename="gvariant.h" line="95" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="39642">a floating reference to a new uint64 #GVariant instance</doc>
          <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39638">a #guint64 value</doc>
            <type name="guint64" c:type="guint64" gs:managed-name="System.UInt64" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39638">a #guint64 value</doc>
            <type name="guint64" c:type="guint64" gs:managed-name="System.UInt64" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <constructor name="new_variant" c:identifier="g_variant_new_variant" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="NewVariant">
        <doc xml:space="preserve" filename="glib-2.0.c" line="39696">Boxes @value.  The result is a #GVariant instance representing a
variant containing the original value.

If @child is a floating reference (see g_variant_ref_sink()), the new
instance takes ownership of @child.</doc>
        <source-position filename="gvariant.h" line="116" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="39706">a floating reference to a new variant #GVariant instance</doc>
          <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39698">a #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39698">a #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <method name="byteswap" c:identifier="g_variant_byteswap" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="Byteswap">
        <doc xml:space="preserve" filename="glib-2.0.c" line="37658">Performs a byteswapping operation on the contents of @value.  The
result is that all multi-byte numeric data contained in @value is
byteswapped.  That includes 16, 32, and 64bit signed and unsigned
integers as well as file handles and double precision floating point
values.

This function is an identity mapping on any value that does not
contain multi-byte numeric data.  That include strings, booleans,
bytes and containers containing only these things (recursively).

The returned value is always in normal form and is marked as trusted.</doc>
        <source-position filename="gvariant.h" line="254" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="37674">the byteswapped form of @value</doc>
          <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37660">a #GVariant</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="check_format_string" c:identifier="g_variant_check_format_string" version="2.34" gs:dll-name="glib-2.0" gs:managed-name="CheckFormatString">
        <doc xml:space="preserve" filename="glib-2.0.c" line="37679">Checks if calling g_variant_get() with @format_string on @value would
be valid from a type-compatibility standpoint.  @format_string is
assumed to be a valid format string (from a syntactic standpoint).

If @copy_only is %TRUE then this function additionally checks that it
would be safe to call g_variant_unref() on @value immediately after
the call to g_variant_get() without invalidating the result.  This is
only possible if deep copies are made (ie: there are no pointers to
the data inside of the soon-to-be-freed #GVariant instance).  If this
check fails then a g_critical() is printed and %FALSE is returned.

This function is meant to be used by functions that wish to provide
varargs accessors to #GVariant values of uncertain values (eg:
g_variant_lookup() or g_menu_model_get_item_attribute()).</doc>
        <source-position filename="gvariant.h" line="412" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="37700">%TRUE if @format_string is safe to use</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37681">a #GVariant</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="format_string" transfer-ownership="none" gs:managed-name="formatString" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37682">a valid #GVariant format string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="copy_only" transfer-ownership="none" gs:managed-name="copyOnly" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37683">%TRUE to ensure the format string makes deep copies</doc>
            <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="format_string" transfer-ownership="none" gs:managed-name="formatString" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37682">a valid #GVariant format string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="copy_only" transfer-ownership="none" gs:managed-name="copyOnly" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37683">%TRUE to ensure the format string makes deep copies</doc>
            <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="classify" c:identifier="g_variant_classify" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="Classify">
        <doc xml:space="preserve" filename="glib-2.0.c" line="37705">Classifies @value according to its top-level type.</doc>
        <source-position filename="gvariant.h" line="79" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="37711">the #GVariantClass of @value</doc>
          <type name="VariantClass" c:type="GVariantClass" gs:managed-name="VariantClass" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37707">a #GVariant</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <function name="compare" c:identifier="g_variant_compare" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="Compare" gs:special-func="compare">
        <doc xml:space="preserve" filename="glib-2.0.c" line="37716">Compares @one and @two.

The types of @one and @two are #gconstpointer only to allow use of
this function with #GTree, #GPtrArray, etc.  They must each be a
#GVariant.

Comparison is only defined for basic types (ie: booleans, numbers,
strings).  For booleans, %FALSE is less than %TRUE.  Numbers are
ordered in the usual way.  Strings are in ASCII lexographical order.

It is a programmer error to attempt to compare container values or
two values that have types that are not exactly equal.  For example,
you cannot compare a 32-bit signed integer with a 32-bit unsigned
integer.  Also note that this function is not particularly
well-behaved when it comes to comparison of doubles; in particular,
the handling of incomparable values (ie: NaN) is undefined.

If you only require an equality comparison, g_variant_equal() is more
general.</doc>
        <source-position filename="gvariant.h" line="434" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="37741">negative value if a &lt; b;
         zero if a = b;
         positive value if a &gt; b.</doc>
          <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <parameter name="one" transfer-ownership="none" gs:managed-name="one" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37718">a basic-typed #GVariant instance</doc>
            <type name="Variant" c:type="gconstpointer" gs:managed-name="Variant" gs:is-pointer="1" />
          </parameter>
          <parameter name="two" transfer-ownership="none" gs:managed-name="two" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37719">a #GVariant instance of the same type</doc>
            <type name="Variant" c:type="gconstpointer" gs:managed-name="Variant" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="one" transfer-ownership="none" gs:managed-name="one" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37718">a basic-typed #GVariant instance</doc>
            <type name="Variant" c:type="gconstpointer" gs:managed-name="Variant" gs:is-pointer="1" />
          </parameter>
          <parameter name="two" transfer-ownership="none" gs:managed-name="two" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37719">a #GVariant instance of the same type</doc>
            <type name="Variant" c:type="gconstpointer" gs:managed-name="Variant" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <method name="dup_bytestring" c:identifier="g_variant_dup_bytestring" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="DupBytestring">
        <doc xml:space="preserve" filename="glib-2.0.c" line="37965">Similar to g_variant_get_bytestring() except that instead of
returning a constant string, the string is duplicated.

The return value must be freed using g_free().</doc>
        <source-position filename="gvariant.h" line="176" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="37976">
         a newly allocated string</doc>
          <array length="0" zero-terminated="1" c:type="gchar*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
            <type name="guint8" gs:managed-name="System.Byte" />
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37967">an array-of-bytes #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="length">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37968">a pointer to a #gsize, to store
         the length (not including the nul terminator)</doc>
            <type name="gsize" c:type="gsize*" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="dup_bytestring_array" c:identifier="g_variant_dup_bytestring_array" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="DupBytestringArray">
        <doc xml:space="preserve" filename="glib-2.0.c" line="37982">Gets the contents of an array of array of bytes #GVariant.  This call
makes a deep copy; the return result should be released with
g_strfreev().

If @length is non-%NULL then the number of elements in the result is
stored there.  In any case, the resulting array will be
%NULL-terminated.

For an empty array, @length will be set to 0 and a pointer to a
%NULL pointer will be returned.</doc>
        <source-position filename="gvariant.h" line="182" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="37998">an array of strings</doc>
          <array length="0" zero-terminated="0" c:type="gchar**" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
            <type name="utf8" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37984">an array of array of bytes #GVariant ('aay')</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="length">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37985">the length of the result, or %NULL</doc>
            <type name="gsize" c:type="gsize*" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="dup_objv" c:identifier="g_variant_dup_objv" version="2.30" gs:dll-name="glib-2.0" gs:managed-name="DupObjv">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38003">Gets the contents of an array of object paths #GVariant.  This call
makes a deep copy; the return result should be released with
g_strfreev().

If @length is non-%NULL then the number of elements in the result
is stored there.  In any case, the resulting array will be
%NULL-terminated.

For an empty array, @length will be set to 0 and a pointer to a
%NULL pointer will be returned.</doc>
        <source-position filename="gvariant.h" line="171" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38019">an array of strings</doc>
          <array length="0" zero-terminated="1" c:type="gchar**" name="GLib.Strv" gs:managed-name="GISharp.Lib.GLib.Strv" gs:is-pointer="1">
            <type name="utf8" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38005">an array of object paths #GVariant</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="length">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38006">the length of the result, or %NULL</doc>
            <type name="gsize" c:type="gsize*" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="dup_string" c:identifier="g_variant_dup_string" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="DupString">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38024">Similar to g_variant_get_string() except that instead of returning
a constant string, the string is duplicated.

The string will always be UTF-8 encoded.

The return value must be freed using g_free().</doc>
        <source-position filename="gvariant.h" line="159" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38036">a newly allocated string, UTF-8 encoded</doc>
          <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38026">a string #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="length">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38027">a pointer to a #gsize, to store the length</doc>
            <type name="gsize" c:type="gsize*" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="length">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38027">a pointer to a #gsize, to store the length</doc>
            <type name="gsize" c:type="gsize*" gs:managed-name="System.Int32" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="dup_strv" c:identifier="g_variant_dup_strv" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="DupStrv">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38041">Gets the contents of an array of strings #GVariant.  This call
makes a deep copy; the return result should be released with
g_strfreev().

If @length is non-%NULL then the number of elements in the result
is stored there.  In any case, the resulting array will be
%NULL-terminated.

For an empty array, @length will be set to 0 and a pointer to a
%NULL pointer will be returned.</doc>
        <source-position filename="gvariant.h" line="165" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38057">an array of strings</doc>
          <array length="0" zero-terminated="1" c:type="gchar**" name="GLib.Strv" gs:managed-name="GISharp.Lib.GLib.Strv" gs:is-pointer="1">
            <type name="utf8" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38043">an array of strings #GVariant</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="length">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38044">the length of the result, or %NULL</doc>
            <type name="gsize" c:type="gsize*" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="equal" c:identifier="g_variant_equal" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="Equals" gs:equal="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38062">Checks if @one and @two have the same type and value.

The types of @one and @two are #gconstpointer only to allow use of
this function with #GHashTable.  They must each be a #GVariant.</doc>
        <source-position filename="gvariant.h" line="246" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38072">%TRUE if @one and @two are equal</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="one" transfer-ownership="none" gs:managed-name="one" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38064">a #GVariant instance</doc>
            <type name="Variant" c:type="gconstpointer" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="two" transfer-ownership="none" gs:managed-name="two" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38065">a #GVariant instance</doc>
            <type name="Variant" c:type="gconstpointer" gs:managed-name="Variant" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="two" transfer-ownership="none" gs:managed-name="two" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38065">a #GVariant instance</doc>
            <type name="Variant" c:type="gconstpointer" gs:managed-name="Variant" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <gs:managed-property name="get_boolean" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="Boolean">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38104">Returns the boolean value of @value.

It is an error to call this function with a @value of any type
other than %G_VARIANT_TYPE_BOOLEAN.</doc>
        <source-position filename="gvariant.h" line="134" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38113">%TRUE or %FALSE</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38106">a boolean #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_boolean" c:identifier="g_variant_get_boolean" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="GetBoolean" gs:property-getter-for="Boolean" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38104">Returns the boolean value of @value.

It is an error to call this function with a @value of any type
other than %G_VARIANT_TYPE_BOOLEAN.</doc>
        <source-position filename="gvariant.h" line="134" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38113">%TRUE or %FALSE</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38106">a boolean #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_byte" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="Byte">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38118">Returns the byte value of @value.

It is an error to call this function with a @value of any type
other than %G_VARIANT_TYPE_BYTE.</doc>
        <source-position filename="gvariant.h" line="136" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38127">a #guint8</doc>
          <type name="guint8" c:type="guint8" gs:managed-name="System.Byte" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38120">a byte #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_byte" c:identifier="g_variant_get_byte" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="GetByte" gs:property-getter-for="Byte" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38118">Returns the byte value of @value.

It is an error to call this function with a @value of any type
other than %G_VARIANT_TYPE_BYTE.</doc>
        <source-position filename="gvariant.h" line="136" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38127">a #guint8</doc>
          <type name="guint8" c:type="guint8" gs:managed-name="System.Byte" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38120">a byte #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_bytestring" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="Bytestring">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38132">Returns the string value of a #GVariant instance with an
array-of-bytes type.  The string has no particular encoding.

If the array does not end with a nul terminator character, the empty
string is returned.  For this reason, you can always trust that a
non-%NULL nul-terminated string will be returned by this function.

If the array contains a nul terminator character somewhere other than
the last byte then the returned string is the string, up to the first
such nul character.

g_variant_get_fixed_array() should be used instead if the array contains
arbitrary data that could not be nul-terminated or could contain nul bytes.

It is an error to call this function with a @value that is not an
array of bytes.

The return value remains valid as long as @value exists.</doc>
        <source-position filename="gvariant.h" line="174" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38155">
         the constant string</doc>
          <array c:type="const gchar*" zero-terminated="1" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
            <type name="guint8" gs:managed-name="System.Byte" />
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38134">an array-of-bytes #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_bytestring" c:identifier="g_variant_get_bytestring" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="GetBytestring" gs:property-getter-for="Bytestring" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38132">Returns the string value of a #GVariant instance with an
array-of-bytes type.  The string has no particular encoding.

If the array does not end with a nul terminator character, the empty
string is returned.  For this reason, you can always trust that a
non-%NULL nul-terminated string will be returned by this function.

If the array contains a nul terminator character somewhere other than
the last byte then the returned string is the string, up to the first
such nul character.

g_variant_get_fixed_array() should be used instead if the array contains
arbitrary data that could not be nul-terminated or could contain nul bytes.

It is an error to call this function with a @value that is not an
array of bytes.

The return value remains valid as long as @value exists.</doc>
        <source-position filename="gvariant.h" line="174" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38155">
         the constant string</doc>
          <array c:type="const gchar*" zero-terminated="1" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
            <type name="guint8" gs:managed-name="System.Byte" />
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38134">an array-of-bytes #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_bytestring_array" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="BytestringArray">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38161">Gets the contents of an array of array of bytes #GVariant.  This call
makes a shallow copy; the return result should be released with
g_free(), but the individual strings must not be modified.

If @length is non-%NULL then the number of elements in the result is
stored there.  In any case, the resulting array will be
%NULL-terminated.

For an empty array, @length will be set to 0 and a pointer to a
%NULL pointer will be returned.</doc>
        <source-position filename="gvariant.h" line="179" />
        <return-value transfer-ownership="container" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38177">an array of constant strings</doc>
          <array length="0" zero-terminated="0" c:type="const gchar**" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
            <type name="utf8" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38163">an array of array of bytes #GVariant ('aay')</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="length">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38164">the length of the result, or %NULL</doc>
            <type name="gsize" c:type="gsize*" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_bytestring_array" c:identifier="g_variant_get_bytestring_array" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="GetBytestringArray" gs:property-getter-for="BytestringArray" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38161">Gets the contents of an array of array of bytes #GVariant.  This call
makes a shallow copy; the return result should be released with
g_free(), but the individual strings must not be modified.

If @length is non-%NULL then the number of elements in the result is
stored there.  In any case, the resulting array will be
%NULL-terminated.

For an empty array, @length will be set to 0 and a pointer to a
%NULL pointer will be returned.</doc>
        <source-position filename="gvariant.h" line="179" />
        <return-value transfer-ownership="container" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38177">an array of constant strings</doc>
          <array length="0" zero-terminated="0" c:type="const gchar**" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
            <type name="utf8" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38163">an array of array of bytes #GVariant ('aay')</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="length">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38164">the length of the result, or %NULL</doc>
            <type name="gsize" c:type="gsize*" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="get_child_value" c:identifier="g_variant_get_child_value" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="GetChildValue">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38203">Reads a child item out of a container #GVariant instance.  This
includes variants, maybes, arrays, tuples and dictionary
entries.  It is an error to call this function on any other type of
#GVariant.

It is an error if @index_ is greater than the number of child items
in the container.  See g_variant_n_children().

The returned value is never floating.  You should free it with
g_variant_unref() when you're done with it.

Note that values borrowed from the returned child are not guaranteed to
still be valid after the child is freed even if you still hold a reference
to @value, if @value has not been serialised at the time this function is
called. To avoid this, you can serialize @value by calling
g_variant_get_data() and optionally ignoring the return value.

There may be implementation specific restrictions on deeply nested values,
which would result in the unit tuple being returned as the child value,
instead of further nested children. #GVariant is guaranteed to handle
nesting up to at least 64 levels.

This function is O(1).</doc>
        <source-position filename="gvariant.h" line="209" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38232">the child at the specified index</doc>
          <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38205">a container #GVariant</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="index_" transfer-ownership="none" gs:managed-name="index" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38206">the index of the child to fetch</doc>
            <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="index_" transfer-ownership="none" gs:managed-name="index" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38206">the index of the child to fetch</doc>
            <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <gs:managed-property name="get_data" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="Data">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38237">Returns a pointer to the serialised form of a #GVariant instance.
The returned data may not be in fully-normalised form if read from an
untrusted source.  The returned data must not be freed; it remains
valid for as long as @value exists.

If @value is a fixed-sized value that was deserialised from a
corrupted serialised container then %NULL may be returned.  In this
case, the proper thing to do is typically to use the appropriate
number of nul bytes in place of @value.  If @value is not fixed-sized
then %NULL is never returned.

In the case that @value is already in serialised form, this function
is O(1).  If the value is not already in serialised form,
serialisation occurs implicitly and is approximately O(n) in the size
of the result.

To deserialise the data returned by this function, in addition to the
serialised data, you must know the type of the #GVariant, and (if the
machine might be different) the endianness of the machine that stored
it. As a result, file formats or network messages that incorporate
serialised #GVariants must include this information either
implicitly (for instance "the file always contains a
%G_VARIANT_TYPE_VARIANT and it is always in little-endian order") or
explicitly (by storing the type and/or endianness in addition to the
serialised data).</doc>
        <source-position filename="gvariant.h" line="228" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38267">the serialised form of @value, or %NULL</doc>
          <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38239">a #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_data" c:identifier="g_variant_get_data" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="GetData" gs:property-getter-for="Data" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38237">Returns a pointer to the serialised form of a #GVariant instance.
The returned data may not be in fully-normalised form if read from an
untrusted source.  The returned data must not be freed; it remains
valid for as long as @value exists.

If @value is a fixed-sized value that was deserialised from a
corrupted serialised container then %NULL may be returned.  In this
case, the proper thing to do is typically to use the appropriate
number of nul bytes in place of @value.  If @value is not fixed-sized
then %NULL is never returned.

In the case that @value is already in serialised form, this function
is O(1).  If the value is not already in serialised form,
serialisation occurs implicitly and is approximately O(n) in the size
of the result.

To deserialise the data returned by this function, in addition to the
serialised data, you must know the type of the #GVariant, and (if the
machine might be different) the endianness of the machine that stored
it. As a result, file formats or network messages that incorporate
serialised #GVariants must include this information either
implicitly (for instance "the file always contains a
%G_VARIANT_TYPE_VARIANT and it is always in little-endian order") or
explicitly (by storing the type and/or endianness in addition to the
serialised data).</doc>
        <source-position filename="gvariant.h" line="228" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38267">the serialised form of @value, or %NULL</doc>
          <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38239">a #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_data_as_bytes" version="2.36" gs:dll-name="glib-2.0" gs:managed-name="DataAsBytes">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38272">Returns a pointer to the serialised form of a #GVariant instance.
The semantics of this function are exactly the same as
g_variant_get_data(), except that the returned #GBytes holds
a reference to the variant data.</doc>
        <source-position filename="gvariant.h" line="230" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38281">A new #GBytes representing the variant data</doc>
          <type name="Bytes" c:type="GBytes*" gs:managed-name="Bytes" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38274">a #GVariant</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_data_as_bytes" c:identifier="g_variant_get_data_as_bytes" version="2.36" gs:dll-name="glib-2.0" gs:managed-name="GetDataAsBytes" gs:property-getter-for="DataAsBytes" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38272">Returns a pointer to the serialised form of a #GVariant instance.
The semantics of this function are exactly the same as
g_variant_get_data(), except that the returned #GBytes holds
a reference to the variant data.</doc>
        <source-position filename="gvariant.h" line="230" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38281">A new #GBytes representing the variant data</doc>
          <type name="Bytes" c:type="GBytes*" gs:managed-name="Bytes" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38274">a #GVariant</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_double" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="Double">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38286">Returns the double precision floating point value of @value.

It is an error to call this function with a @value of any type
other than %G_VARIANT_TYPE_DOUBLE.</doc>
        <source-position filename="gvariant.h" line="152" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38295">a #gdouble</doc>
          <type name="gdouble" c:type="gdouble" gs:managed-name="System.Double" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38288">a double #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_double" c:identifier="g_variant_get_double" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="GetDouble" gs:property-getter-for="Double" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38286">Returns the double precision floating point value of @value.

It is an error to call this function with a @value of any type
other than %G_VARIANT_TYPE_DOUBLE.</doc>
        <source-position filename="gvariant.h" line="152" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38295">a #gdouble</doc>
          <type name="gdouble" c:type="gdouble" gs:managed-name="System.Double" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38288">a double #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_handle" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="Handle">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38339">Returns the 32-bit signed integer value of @value.

It is an error to call this function with a @value of any type other
than %G_VARIANT_TYPE_HANDLE.

By convention, handles are indexes into an array of file descriptors
that are sent alongside a D-Bus message.  If you're not interacting
with D-Bus, you probably don't need them.</doc>
        <source-position filename="gvariant.h" line="150" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38352">a #gint32</doc>
          <type name="gint32" c:type="gint32" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38341">a handle #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_handle" c:identifier="g_variant_get_handle" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="GetHandle" gs:property-getter-for="Handle" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38339">Returns the 32-bit signed integer value of @value.

It is an error to call this function with a @value of any type other
than %G_VARIANT_TYPE_HANDLE.

By convention, handles are indexes into an array of file descriptors
that are sent alongside a D-Bus message.  If you're not interacting
with D-Bus, you probably don't need them.</doc>
        <source-position filename="gvariant.h" line="150" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38352">a #gint32</doc>
          <type name="gint32" c:type="gint32" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38341">a handle #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_int16" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="Int16">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38357">Returns the 16-bit signed integer value of @value.

It is an error to call this function with a @value of any type
other than %G_VARIANT_TYPE_INT16.</doc>
        <source-position filename="gvariant.h" line="138" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38366">a #gint16</doc>
          <type name="gint16" c:type="gint16" gs:managed-name="System.Int16" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38359">an int16 #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_int16" c:identifier="g_variant_get_int16" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="GetInt16" gs:property-getter-for="Int16" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38357">Returns the 16-bit signed integer value of @value.

It is an error to call this function with a @value of any type
other than %G_VARIANT_TYPE_INT16.</doc>
        <source-position filename="gvariant.h" line="138" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38366">a #gint16</doc>
          <type name="gint16" c:type="gint16" gs:managed-name="System.Int16" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38359">an int16 #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_int32" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="Int32">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38371">Returns the 32-bit signed integer value of @value.

It is an error to call this function with a @value of any type
other than %G_VARIANT_TYPE_INT32.</doc>
        <source-position filename="gvariant.h" line="142" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38380">a #gint32</doc>
          <type name="gint32" c:type="gint32" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38373">an int32 #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_int32" c:identifier="g_variant_get_int32" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="GetInt32" gs:property-getter-for="Int32" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38371">Returns the 32-bit signed integer value of @value.

It is an error to call this function with a @value of any type
other than %G_VARIANT_TYPE_INT32.</doc>
        <source-position filename="gvariant.h" line="142" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38380">a #gint32</doc>
          <type name="gint32" c:type="gint32" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38373">an int32 #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_int64" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="Int64">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38385">Returns the 64-bit signed integer value of @value.

It is an error to call this function with a @value of any type
other than %G_VARIANT_TYPE_INT64.</doc>
        <source-position filename="gvariant.h" line="146" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38394">a #gint64</doc>
          <type name="gint64" c:type="gint64" gs:managed-name="System.Int64" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38387">an int64 #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_int64" c:identifier="g_variant_get_int64" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="GetInt64" gs:property-getter-for="Int64" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38385">Returns the 64-bit signed integer value of @value.

It is an error to call this function with a @value of any type
other than %G_VARIANT_TYPE_INT64.</doc>
        <source-position filename="gvariant.h" line="146" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38394">a #gint64</doc>
          <type name="gint64" c:type="gint64" gs:managed-name="System.Int64" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38387">an int64 #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_maybe" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="Maybe">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38399">Given a maybe-typed #GVariant instance, extract its value.  If the
value is Nothing, then this function returns %NULL.</doc>
        <source-position filename="gvariant.h" line="200" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38406">the contents of @value, or %NULL</doc>
          <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38401">a maybe-typed value</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_maybe" c:identifier="g_variant_get_maybe" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="GetMaybe" gs:property-getter-for="Maybe" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38399">Given a maybe-typed #GVariant instance, extract its value.  If the
value is Nothing, then this function returns %NULL.</doc>
        <source-position filename="gvariant.h" line="200" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38406">the contents of @value, or %NULL</doc>
          <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38401">a maybe-typed value</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_normal_form" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="NormalForm">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38411">Gets a #GVariant instance that has the same value as @value and is
trusted to be in normal form.

If @value is already trusted to be in normal form then a new
reference to @value is returned.

If @value is not already trusted, then it is scanned to check if it
is in normal form.  If it is found to be in normal form then it is
marked as trusted and a new reference to it is returned.

If @value is found not to be in normal form then a new trusted
#GVariant is created with the same value as @value.

It makes sense to call this function if you've received #GVariant
data from untrusted sources and you want to ensure your serialised
output is definitely in normal form.

If @value is already in normal form, a new reference will be returned
(which will be floating if @value is floating). If it is not in normal form,
the newly created #GVariant will be returned with a single non-floating
reference. Typically, g_variant_take_ref() should be called on the return
value from this function to guarantee ownership of a single non-floating
reference to it.</doc>
        <source-position filename="gvariant.h" line="250" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38439">a trusted #GVariant</doc>
          <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38413">a #GVariant</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_normal_form" c:identifier="g_variant_get_normal_form" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="GetNormalForm" gs:property-getter-for="NormalForm" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38411">Gets a #GVariant instance that has the same value as @value and is
trusted to be in normal form.

If @value is already trusted to be in normal form then a new
reference to @value is returned.

If @value is not already trusted, then it is scanned to check if it
is in normal form.  If it is found to be in normal form then it is
marked as trusted and a new reference to it is returned.

If @value is found not to be in normal form then a new trusted
#GVariant is created with the same value as @value.

It makes sense to call this function if you've received #GVariant
data from untrusted sources and you want to ensure your serialised
output is definitely in normal form.

If @value is already in normal form, a new reference will be returned
(which will be floating if @value is floating). If it is not in normal form,
the newly created #GVariant will be returned with a single non-floating
reference. Typically, g_variant_take_ref() should be called on the return
value from this function to guarantee ownership of a single non-floating
reference to it.</doc>
        <source-position filename="gvariant.h" line="250" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38439">a trusted #GVariant</doc>
          <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38413">a #GVariant</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_objv" version="2.30" gs:dll-name="glib-2.0" gs:managed-name="Objv">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38444">Gets the contents of an array of object paths #GVariant.  This call
makes a shallow copy; the return result should be released with
g_free(), but the individual strings must not be modified.

If @length is non-%NULL then the number of elements in the result
is stored there.  In any case, the resulting array will be
%NULL-terminated.

For an empty array, @length will be set to 0 and a pointer to a
%NULL pointer will be returned.</doc>
        <source-position filename="gvariant.h" line="168" />
        <return-value transfer-ownership="container" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38460">an array of constant strings</doc>
          <array length="0" zero-terminated="1" c:type="const gchar**" name="GLib.Strv" gs:managed-name="GISharp.Lib.GLib.Strv" gs:is-pointer="1">
            <type name="utf8" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38446">an array of object paths #GVariant</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="length">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38447">the length of the result, or %NULL</doc>
            <type name="gsize" c:type="gsize*" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_objv" c:identifier="g_variant_get_objv" version="2.30" gs:dll-name="glib-2.0" gs:managed-name="GetObjv" gs:property-getter-for="Objv" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38444">Gets the contents of an array of object paths #GVariant.  This call
makes a shallow copy; the return result should be released with
g_free(), but the individual strings must not be modified.

If @length is non-%NULL then the number of elements in the result
is stored there.  In any case, the resulting array will be
%NULL-terminated.

For an empty array, @length will be set to 0 and a pointer to a
%NULL pointer will be returned.</doc>
        <source-position filename="gvariant.h" line="168" />
        <return-value transfer-ownership="container" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38460">an array of constant strings</doc>
          <array length="0" zero-terminated="1" c:type="const gchar**" name="GLib.Strv" gs:managed-name="GISharp.Lib.GLib.Strv" gs:is-pointer="1">
            <type name="utf8" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38446">an array of object paths #GVariant</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="length">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38447">the length of the result, or %NULL</doc>
            <type name="gsize" c:type="gsize*" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_size" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="Size">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38465">Determines the number of bytes that would be required to store @value
with g_variant_store().

If @value has a fixed-sized type then this function always returned
that fixed size.

In the case that @value is already in serialised form or the size has
already been calculated (ie: this function has been called before)
then this function is O(1).  Otherwise, the size is calculated, an
operation which is approximately O(n) in the number of values
involved.</doc>
        <source-position filename="gvariant.h" line="226" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38481">the serialised size of @value</doc>
          <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38467">a #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_size" c:identifier="g_variant_get_size" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="GetSize" gs:property-getter-for="Size" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38465">Determines the number of bytes that would be required to store @value
with g_variant_store().

If @value has a fixed-sized type then this function always returned
that fixed size.

In the case that @value is already in serialised form or the size has
already been calculated (ie: this function has been called before)
then this function is O(1).  Otherwise, the size is calculated, an
operation which is approximately O(n) in the number of values
involved.</doc>
        <source-position filename="gvariant.h" line="226" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38481">the serialised size of @value</doc>
          <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38467">a #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="get_string" c:identifier="g_variant_get_string" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="GetString">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38486">Returns the string value of a #GVariant instance with a string
type.  This includes the types %G_VARIANT_TYPE_STRING,
%G_VARIANT_TYPE_OBJECT_PATH and %G_VARIANT_TYPE_SIGNATURE.

The string will always be UTF-8 encoded, will never be %NULL, and will never
contain nul bytes.

If @length is non-%NULL then the length of the string (in bytes) is
returned there.  For trusted values, this information is already
known.  Untrusted values will be validated and, if valid, a strlen() will be
performed. If invalid, a default value will be returned — for
%G_VARIANT_TYPE_OBJECT_PATH, this is `"/"`, and for other types it is the
empty string.

It is an error to call this function with a @value of any type
other than those three.

The return value remains valid as long as @value exists.</doc>
        <source-position filename="gvariant.h" line="156" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38511">the constant string, UTF-8 encoded</doc>
          <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38488">a string #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="length">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38489">a pointer to a #gsize,
         to store the length</doc>
            <type name="gsize" c:type="gsize*" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="length">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38489">a pointer to a #gsize,
         to store the length</doc>
            <type name="gsize" c:type="gsize*" gs:managed-name="System.Int32" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <gs:managed-property name="get_strv" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="Strv">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38516">Gets the contents of an array of strings #GVariant.  This call
makes a shallow copy; the return result should be released with
g_free(), but the individual strings must not be modified.

If @length is non-%NULL then the number of elements in the result
is stored there.  In any case, the resulting array will be
%NULL-terminated.

For an empty array, @length will be set to 0 and a pointer to a
%NULL pointer will be returned.</doc>
        <source-position filename="gvariant.h" line="162" />
        <return-value transfer-ownership="container" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38532">an array of constant strings</doc>
          <array length="0" zero-terminated="1" c:type="const gchar**" name="GLib.Strv" gs:managed-name="GISharp.Lib.GLib.Strv" gs:is-pointer="1">
            <type name="utf8" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38518">an array of strings #GVariant</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="length">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38519">the length of the result, or %NULL</doc>
            <type name="gsize" c:type="gsize*" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_strv" c:identifier="g_variant_get_strv" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="GetStrv" gs:property-getter-for="Strv" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38516">Gets the contents of an array of strings #GVariant.  This call
makes a shallow copy; the return result should be released with
g_free(), but the individual strings must not be modified.

If @length is non-%NULL then the number of elements in the result
is stored there.  In any case, the resulting array will be
%NULL-terminated.

For an empty array, @length will be set to 0 and a pointer to a
%NULL pointer will be returned.</doc>
        <source-position filename="gvariant.h" line="162" />
        <return-value transfer-ownership="container" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38532">an array of constant strings</doc>
          <array length="0" zero-terminated="1" c:type="const gchar**" name="GLib.Strv" gs:managed-name="GISharp.Lib.GLib.Strv" gs:is-pointer="1">
            <type name="utf8" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38518">an array of strings #GVariant</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="length">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38519">the length of the result, or %NULL</doc>
            <type name="gsize" c:type="gsize*" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_type" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="Type">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38537">Determines the type of @value.

The return value is valid for the lifetime of @value and must not
be freed.</doc>
        <source-position filename="gvariant.h" line="70" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38546">a #GVariantType</doc>
          <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38539">a #GVariant</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_type" c:identifier="g_variant_get_type" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="GetType_" gs:property-getter-for="Type" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38537">Determines the type of @value.

The return value is valid for the lifetime of @value and must not
be freed.</doc>
        <source-position filename="gvariant.h" line="70" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38546">a #GVariantType</doc>
          <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38539">a #GVariant</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_type_string" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="TypeString">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38551">Returns the type string of @value.  Unlike the result of calling
g_variant_type_peek_string(), this string is nul-terminated.  This
string belongs to #GVariant and must not be freed.</doc>
        <source-position filename="gvariant.h" line="72" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38559">the type string for the type of @value</doc>
          <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38553">a #GVariant</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_type_string" c:identifier="g_variant_get_type_string" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="GetTypeString" gs:property-getter-for="TypeString" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38551">Returns the type string of @value.  Unlike the result of calling
g_variant_type_peek_string(), this string is nul-terminated.  This
string belongs to #GVariant and must not be freed.</doc>
        <source-position filename="gvariant.h" line="72" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38559">the type string for the type of @value</doc>
          <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38553">a #GVariant</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_uint16" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="Uint16">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38564">Returns the 16-bit unsigned integer value of @value.

It is an error to call this function with a @value of any type
other than %G_VARIANT_TYPE_UINT16.</doc>
        <source-position filename="gvariant.h" line="140" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38573">a #guint16</doc>
          <type name="guint16" c:type="guint16" gs:managed-name="System.UInt16" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38566">a uint16 #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_uint16" c:identifier="g_variant_get_uint16" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="GetUint16" gs:property-getter-for="Uint16" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38564">Returns the 16-bit unsigned integer value of @value.

It is an error to call this function with a @value of any type
other than %G_VARIANT_TYPE_UINT16.</doc>
        <source-position filename="gvariant.h" line="140" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38573">a #guint16</doc>
          <type name="guint16" c:type="guint16" gs:managed-name="System.UInt16" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38566">a uint16 #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_uint32" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="Uint32">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38578">Returns the 32-bit unsigned integer value of @value.

It is an error to call this function with a @value of any type
other than %G_VARIANT_TYPE_UINT32.</doc>
        <source-position filename="gvariant.h" line="144" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38587">a #guint32</doc>
          <type name="guint32" c:type="guint32" gs:managed-name="System.UInt32" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38580">a uint32 #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_uint32" c:identifier="g_variant_get_uint32" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="GetUint32" gs:property-getter-for="Uint32" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38578">Returns the 32-bit unsigned integer value of @value.

It is an error to call this function with a @value of any type
other than %G_VARIANT_TYPE_UINT32.</doc>
        <source-position filename="gvariant.h" line="144" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38587">a #guint32</doc>
          <type name="guint32" c:type="guint32" gs:managed-name="System.UInt32" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38580">a uint32 #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_uint64" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="Uint64">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38592">Returns the 64-bit unsigned integer value of @value.

It is an error to call this function with a @value of any type
other than %G_VARIANT_TYPE_UINT64.</doc>
        <source-position filename="gvariant.h" line="148" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38601">a #guint64</doc>
          <type name="guint64" c:type="guint64" gs:managed-name="System.UInt64" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38594">a uint64 #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_uint64" c:identifier="g_variant_get_uint64" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="GetUint64" gs:property-getter-for="Uint64" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38592">Returns the 64-bit unsigned integer value of @value.

It is an error to call this function with a @value of any type
other than %G_VARIANT_TYPE_UINT64.</doc>
        <source-position filename="gvariant.h" line="148" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38601">a #guint64</doc>
          <type name="guint64" c:type="guint64" gs:managed-name="System.UInt64" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38594">a uint64 #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_variant" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="Variant">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38643">Unboxes @value.  The result is the #GVariant instance that was
contained in @value.</doc>
        <source-position filename="gvariant.h" line="154" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38650">the item contained in the variant</doc>
          <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38645">a variant #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_variant" c:identifier="g_variant_get_variant" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="GetVariant" gs:property-getter-for="Variant" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38643">Unboxes @value.  The result is the #GVariant instance that was
contained in @value.</doc>
        <source-position filename="gvariant.h" line="154" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38650">the item contained in the variant</doc>
          <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38645">a variant #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="hash" c:identifier="g_variant_hash" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="GetHashCode" gs:hash="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38655">Generates a hash value for a #GVariant instance.

The output of this function is guaranteed to be the same for a given
value only per-process.  It may change between different processor
architectures or even different versions of GLib.  Do not use this
function as a basis for building protocols or file formats.

The type of @value is #gconstpointer only to allow use of this
function with #GHashTable.  @value must be a #GVariant.</doc>
        <source-position filename="gvariant.h" line="244" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38669">a hash value corresponding to @value</doc>
          <type name="guint" c:type="guint" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38657">a basic #GVariant value as a #gconstpointer</doc>
            <type name="Variant" c:type="gconstpointer" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="is_container" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="IsContainer">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38674">Checks if @value is a container.</doc>
        <source-position filename="gvariant.h" line="77" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38680">%TRUE if @value is a container</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38676">a #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="is_container" c:identifier="g_variant_is_container" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="GetIsContainer" gs:property-getter-for="IsContainer" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38674">Checks if @value is a container.</doc>
        <source-position filename="gvariant.h" line="77" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38680">%TRUE if @value is a container</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38676">a #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="is_floating" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="IsFloating">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38685">Checks whether @value has a floating reference count.

This function should only ever be used to assert that a given variant
is or is not floating, or for debug purposes. To acquire a reference
to a variant that might be floating, always use g_variant_ref_sink()
or g_variant_take_ref().

See g_variant_ref_sink() for more information about floating reference
counts.</doc>
        <source-position filename="gvariant.h" line="65" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38699">whether @value is floating</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38687">a #GVariant</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="is_floating" c:identifier="g_variant_is_floating" version="2.26" gs:dll-name="glib-2.0" gs:managed-name="GetIsFloating" gs:property-getter-for="IsFloating" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38685">Checks whether @value has a floating reference count.

This function should only ever be used to assert that a given variant
is or is not floating, or for debug purposes. To acquire a reference
to a variant that might be floating, always use g_variant_ref_sink()
or g_variant_take_ref().

See g_variant_ref_sink() for more information about floating reference
counts.</doc>
        <source-position filename="gvariant.h" line="65" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38699">whether @value is floating</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38687">a #GVariant</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="is_normal_form" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="IsNormalForm">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38704">Checks if @value is in normal form.

The main reason to do this is to detect if a given chunk of
serialised data is in normal form: load the data into a #GVariant
using g_variant_new_from_data() and then use this function to
check.

If @value is found to be in normal form then it will be marked as
being trusted.  If the value was already marked as being trusted then
this function will immediately return %TRUE.

There may be implementation specific restrictions on deeply nested values.
GVariant is guaranteed to handle nesting up to at least 64 levels.</doc>
        <source-position filename="gvariant.h" line="252" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38722">%TRUE if @value is in normal form</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38706">a #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="is_normal_form" c:identifier="g_variant_is_normal_form" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="GetIsNormalForm" gs:property-getter-for="IsNormalForm" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38704">Checks if @value is in normal form.

The main reason to do this is to detect if a given chunk of
serialised data is in normal form: load the data into a #GVariant
using g_variant_new_from_data() and then use this function to
check.

If @value is found to be in normal form then it will be marked as
being trusted.  If the value was already marked as being trusted then
this function will immediately return %TRUE.

There may be implementation specific restrictions on deeply nested values.
GVariant is guaranteed to handle nesting up to at least 64 levels.</doc>
        <source-position filename="gvariant.h" line="252" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38722">%TRUE if @value is in normal form</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38706">a #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="is_of_type" c:identifier="g_variant_is_of_type" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="IsOfType">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38745">Checks if a value has a type matching the provided type.</doc>
        <source-position filename="gvariant.h" line="74" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38752">%TRUE if the type of @value matches @type</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38747">a #GVariant instance</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38748">a #GVariantType</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38748">a #GVariantType</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="lookup_value" c:identifier="g_variant_lookup_value" version="2.28" gs:dll-name="glib-2.0" gs:managed-name="LookupValue">
        <doc xml:space="preserve" filename="glib-2.0.c" line="39047">Looks up a value in a dictionary #GVariant.

This function works with dictionaries of the type a{s*} (and equally
well with type a{o*}, but we only further discuss the string case
for sake of clarity).

In the event that @dictionary has the type a{sv}, the @expected_type
string specifies what type of value is expected to be inside of the
variant. If the value inside the variant has a different type then
%NULL is returned. In the event that @dictionary has a value type other
than v then @expected_type must directly match the value type and it is
used to unpack the value directly or an error occurs.

In either case, if @key is not found in @dictionary, %NULL is returned.

If the key is found and the value has the correct type, it is
returned.  If @expected_type was specified then any non-%NULL return
value will have this type.

This function is currently implemented with a linear scan.  If you
plan to do many lookups then #GVariantDict may be more efficient.</doc>
        <source-position filename="gvariant.h" line="217" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="39075">the value of the dictionary key, or %NULL</doc>
          <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="dictionary" transfer-ownership="none" gs:managed-name="dictionary" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39049">a dictionary #GVariant</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39050">the key to look up in the dictionary</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="expected_type" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="expectedType" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39051">a #GVariantType, or %NULL</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39050">the key to look up in the dictionary</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="expected_type" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="expectedType" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39051">a #GVariantType, or %NULL</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="n_children" c:identifier="g_variant_n_children" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="NChildren">
        <doc xml:space="preserve" filename="glib-2.0.c" line="39080">Determines the number of children in a container #GVariant instance.
This includes variants, maybes, arrays, tuples and dictionary
entries.  It is an error to call this function on any other type of
#GVariant.

For variants, the return value is always 1.  For values with maybe
types, it is always zero or one.  For arrays, it is the length of the
array.  For tuples it is the number of tuple items (which depends
only on the type).  For dictionary entries, it is always 2

This function is O(1).</doc>
        <source-position filename="gvariant.h" line="202" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="39096">the number of children in the container</doc>
          <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39082">a container #GVariant</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="print" c:identifier="g_variant_print" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="Print">
        <doc xml:space="preserve" filename="glib-2.0.c" line="39808">Pretty-prints @value in the format understood by g_variant_parse().

The format is described [here][gvariant-text].

If @type_annotate is %TRUE, then type information is included in
the output.</doc>
        <source-position filename="gvariant.h" line="236" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="39821">a newly-allocated string holding the result.</doc>
          <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39810">a #GVariant</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="type_annotate" transfer-ownership="none" gs:managed-name="typeAnnotate" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39811">%TRUE if type information should be included in
                the output</doc>
            <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="type_annotate" transfer-ownership="none" gs:managed-name="typeAnnotate" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39811">%TRUE if type information should be included in
                the output</doc>
            <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="ref" c:identifier="g_variant_ref" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="Ref" gs:special-func="ref" gs:pinvoke-only="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="39843">Increases the reference count of @value.</doc>
        <source-position filename="gvariant.h" line="61" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="39849">the same @value</doc>
          <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39845">a #GVariant</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="ref_sink" c:identifier="g_variant_ref_sink" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="RefSink">
        <doc xml:space="preserve" filename="glib-2.0.c" line="39854">#GVariant uses a floating reference count system.  All functions with
names starting with `g_variant_new_` return floating
references.

Calling g_variant_ref_sink() on a #GVariant with a floating reference
will convert the floating reference into a full reference.  Calling
g_variant_ref_sink() on a non-floating #GVariant results in an
additional normal reference being added.

In other words, if the @value is floating, then this call "assumes
ownership" of the floating reference, converting it to a normal
reference.  If the @value is not floating, then this call adds a
new normal reference increasing the reference count by one.

All calls that result in a #GVariant instance being inserted into a
container will call g_variant_ref_sink() on the instance.  This means
that if the value was just created (and has only its floating
reference) then the container will assume sole ownership of the value
at that point and the caller will not need to unreference it.  This
makes certain common styles of programming much easier while still
maintaining normal refcounting semantics in situations where values
are not floating.</doc>
        <source-position filename="gvariant.h" line="63" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="39881">the same @value</doc>
          <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39856">a #GVariant</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="store" c:identifier="g_variant_store" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="Store">
        <doc xml:space="preserve" filename="glib-2.0.c" line="39886">Stores the serialised form of @value at @data.  @data should be
large enough.  See g_variant_get_size().

The stored data is in machine native byte order but may not be in
fully-normalised form if read from an untrusted source.  See
g_variant_get_normal_form() for a solution.

As with g_variant_get_data(), to be able to deserialise the
serialised variant successfully, its type and (if the destination
machine might be different) its endianness must also be available.

This function is approximately O(n) in the size of @data.</doc>
        <source-position filename="gvariant.h" line="232" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39888">the #GVariant to store</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="data" transfer-ownership="none" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39889">the location to store the serialised data at</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="data" transfer-ownership="none" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39889">the location to store the serialised data at</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="take_ref" c:identifier="g_variant_take_ref" gs:dll-name="glib-2.0" gs:managed-name="TakeRef">
        <doc xml:space="preserve" filename="glib-2.0.c" line="39908">If @value is floating, sink it.  Otherwise, do nothing.

Typically you want to use g_variant_ref_sink() in order to
automatically do the correct thing with respect to floating or
non-floating references, but there is one specific scenario where
this function is helpful.

The situation where this function is helpful is when creating an API
that allows the user to provide a callback function that returns a
#GVariant.  We certainly want to allow the user the flexibility to
return a non-floating reference from this callback (for the case
where the value that is being returned already exists).

At the same time, the style of the #GVariant API makes it likely that
for newly-created #GVariant instances, the user can be saved some
typing if they are allowed to return a #GVariant with a floating
reference.

Using this function on the return value of the user's callback allows
the user to do whichever is more convenient for them.  The caller
will always receives exactly one full reference to the value: either
the one that was returned in the first place, or a floating reference
that has been converted to a full reference.

This function has an odd interaction when combined with
g_variant_ref_sink() running at the same time in another thread on
the same #GVariant instance.  If g_variant_ref_sink() runs first then
the result will be that the floating reference is converted to a hard
reference.  If g_variant_take_ref() runs first then the result will
be that the floating reference is converted to a hard reference and
an additional reference on top of that one is added.  It is best to
avoid this situation.</doc>
        <source-position filename="gvariant.h" line="67" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="39945">the same @value</doc>
          <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39910">a #GVariant</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="unref" c:identifier="g_variant_unref" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="Unref" gs:special-func="unref" gs:pinvoke-only="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="40446">Decreases the reference count of @value.  When its reference count
drops to 0, the memory used by the variant is freed.</doc>
        <source-position filename="gvariant.h" line="59" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="40448">a #GVariant</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <function name="is_object_path" c:identifier="g_variant_is_object_path" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="IsObjectPath">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38727">Determines if a given string is a valid D-Bus object path.  You
should ensure that a string is a valid D-Bus object path before
passing it to g_variant_new_object_path().

A valid object path starts with `/` followed by zero or more
sequences of characters separated by `/` characters.  Each sequence
must contain only the characters `[A-Z][a-z][0-9]_`.  No sequence
(including the one following the final `/` character) may be empty.</doc>
        <source-position filename="gvariant.h" line="110" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38740">%TRUE if @string is a D-Bus object path</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <parameter name="string" transfer-ownership="none" gs:managed-name="@string" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38729">a normal C nul-terminated string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="string" transfer-ownership="none" gs:managed-name="@string" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38729">a normal C nul-terminated string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="is_signature" c:identifier="g_variant_is_signature" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="IsSignature">
        <doc xml:space="preserve" filename="glib-2.0.c" line="38757">Determines if a given string is a valid D-Bus type signature.  You
should ensure that a string is a valid D-Bus type signature before
passing it to g_variant_new_signature().

D-Bus type signatures consist of zero or more definite #GVariantType
strings in sequence.</doc>
        <source-position filename="gvariant.h" line="114" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="38768">%TRUE if @string is a D-Bus type signature</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <parameter name="string" transfer-ownership="none" gs:managed-name="@string" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38759">a normal C nul-terminated string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="string" transfer-ownership="none" gs:managed-name="@string" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="38759">a normal C nul-terminated string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="parse" c:identifier="g_variant_parse" throws="1" gs:dll-name="glib-2.0" gs:managed-name="Parse">
        <doc xml:space="preserve" filename="glib-2.0.c" line="39711">Parses a #GVariant from a text representation.

A single #GVariant is parsed from the content of @text.

The format is described [here][gvariant-text].

The memory at @limit will never be accessed and the parser behaves as
if the character at @limit is the nul terminator.  This has the
effect of bounding @text.

If @endptr is non-%NULL then @text is permitted to contain data
following the value that this function parses and @endptr will be
updated to point to the first character past the end of the text
parsed by this function.  If @endptr is %NULL and there is extra data
then an error is returned.

If @type is non-%NULL then the value will be parsed to have that
type.  This may result in additional parse errors (in the case that
the parsed value doesn't fit the type) but may also result in fewer
errors (in the case that the type would have been ambiguous, such as
with empty arrays).

In the event that the parsing is successful, the resulting #GVariant
is returned. It is never floating, and must be freed with
g_variant_unref().

In case of any error, %NULL will be returned.  If @error is non-%NULL
then it will be set to reflect the error that occurred.

Officially, the language understood by the parser is "any string
produced by g_variant_print()".

There may be implementation specific restrictions on deeply nested values,
which would result in a %G_VARIANT_PARSE_ERROR_RECURSION error. #GVariant is
guaranteed to handle nesting up to at least 64 levels.</doc>
        <source-position filename="gvariant.h" line="417" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="39755">a non-floating reference to a #GVariant, or %NULL</doc>
          <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39713">a #GVariantType, or %NULL</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </parameter>
          <parameter name="text" transfer-ownership="none" gs:managed-name="text" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39714">a string containing a GVariant in text form</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="limit" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="limit" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39715">a pointer to the end of @text, or %NULL</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="endptr" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="endptr" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39716">a location to store the end pointer, or %NULL</doc>
            <type name="utf8" c:type="const gchar**" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:managed-name="GISharp.Lib.GLib.Error" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="type" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39713">a #GVariantType, or %NULL</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </parameter>
          <parameter name="text" transfer-ownership="none" gs:managed-name="text" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39714">a string containing a GVariant in text form</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="limit" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="limit" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39715">a pointer to the end of @text, or %NULL</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="endptr" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="endptr" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39716">a location to store the end pointer, or %NULL</doc>
            <type name="utf8" c:type="const gchar**" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="parse_error_print_context" c:identifier="g_variant_parse_error_print_context" version="2.40" gs:dll-name="glib-2.0" gs:managed-name="ParseErrorPrintContext">
        <doc xml:space="preserve" filename="glib-2.0.c" line="39759">Pretty-prints a message showing the context of a #GVariant parse
error within the string for which parsing was attempted.

The resulting string is suitable for output to the console or other
monospace media where newlines are treated in the usual way.

The message will typically look something like one of the following:

|[
unterminated string constant:
  (1, 2, 3, 'abc
            ^^^^
]|

or

|[
unable to find a common type:
  [1, 2, 3, 'str']
   ^        ^^^^^
]|

The format of the message may change in a future version.

@error must have come from a failed attempt to g_variant_parse() and
@source_str must be exactly the same string that caused the error.
If @source_str was not nul-terminated when you passed it to
g_variant_parse() then you must add nul termination before using this
function.</doc>
        <source-position filename="gvariant.h" line="430" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="39794">the printed message</doc>
          <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="error" transfer-ownership="none" gs:managed-name="error" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39761">a #GError from the #GVariantParseError domain</doc>
            <type name="Error" c:type="GError*" gs:managed-name="Error" gs:is-pointer="1" />
          </parameter>
          <parameter name="source_str" transfer-ownership="none" gs:managed-name="sourceStr" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39762">the string that was given to the parser</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="error" transfer-ownership="none" gs:managed-name="error" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39761">a #GError from the #GVariantParseError domain</doc>
            <type name="Error" c:type="GError*" gs:managed-name="Error" gs:is-pointer="1" />
          </parameter>
          <parameter name="source_str" transfer-ownership="none" gs:managed-name="sourceStr" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39762">the string that was given to the parser</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="parse_error_quark" c:identifier="g_variant_parse_error_quark" gs:dll-name="glib-2.0" gs:managed-name="ParseErrorQuark">
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="Quark" c:type="GQuark" gs:managed-name="Quark" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
      <function name="parser_get_error_quark" c:identifier="g_variant_parser_get_error_quark" deprecated="1" gs:dll-name="glib-2.0" gs:managed-name="ParserGetErrorQuark">
        <doc xml:space="preserve" filename="glib-2.0.c" line="39799">Same as g_variant_error_quark().</doc>
        <doc-deprecated xml:space="preserve">Use g_variant_parse_error_quark() instead.</doc-deprecated>
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="Quark" c:type="GQuark" gs:managed-name="Quark" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </record>
    <record name="VariantBuilder" c:type="GVariantBuilder" glib:type-name="GVariantBuilder" glib:get-type="g_variant_builder_get_type" c:symbol-prefix="variant_builder" gs:managed-name="VariantBuilder">
      <doc xml:space="preserve" filename="glib-2.0.c" line="2630">A utility type for constructing container-type #GVariant instances.

This is an opaque structure and may only be accessed using the
following functions.

#GVariantBuilder is not threadsafe in any way.  Do not attempt to
access it from more than one thread.</doc>
      <source-position filename="gvariant.h" line="309" />
      <union name="u" c:type="u" gs:managed-name="U">
        <source-position filename="gvariant.h" line="308" />
        <record name="s" c:type="s" gs:managed-name="S">
          <source-position filename="gvariant.h" line="306" />
          <field name="partial_magic" writable="1" gs:managed-name="PartialMagic">
            <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
          </field>
          <field name="type" writable="1" gs:managed-name="Type">
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </field>
          <field name="y" writable="1" gs:managed-name="Y">
            <array zero-terminated="0" fixed-size="14" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
            </array>
          </field>
        </record>
        <field name="x" writable="1" gs:managed-name="X">
          <array zero-terminated="0" fixed-size="16" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
            <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
          </array>
        </field>
      </union>
      <constructor name="new" c:identifier="g_variant_builder_new" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="New">
        <doc xml:space="preserve" filename="glib-2.0.c" line="37563">Allocates and initialises a new #GVariantBuilder.

You should call g_variant_builder_unref() on the return value when it
is no longer needed.  The memory will not be automatically freed by
any other call.

In most cases it is easier to place a #GVariantBuilder directly on
the stack of the calling function and initialise it with
g_variant_builder_init().</doc>
        <source-position filename="gvariant.h" line="366" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="37577">a #GVariantBuilder</doc>
          <type name="VariantBuilder" c:type="GVariantBuilder*" gs:managed-name="VariantBuilder" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37565">a container type</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37565">a container type</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <method name="add" c:identifier="g_variant_builder_add_value" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="Add">
        <doc xml:space="preserve" filename="glib-2.0.c" line="37439">Adds @value to @builder.

It is an error to call this function in any way that would create an
inconsistent value to be constructed.  Some examples of this are
putting different types of items into an array, putting the wrong
types or number of items in a tuple, putting more than one value into
a variant, etc.

If @value is a floating reference (see g_variant_ref_sink()),
the @builder instance takes ownership of @value.</doc>
        <source-position filename="gvariant.h" line="384" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none" gs:managed-name="builder" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37441">a #GVariantBuilder</doc>
            <type name="VariantBuilder" c:type="GVariantBuilder*" gs:managed-name="VariantBuilder" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37442">a #GVariant</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37442">a #GVariant</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="close" c:identifier="g_variant_builder_close" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="Close">
        <doc xml:space="preserve" filename="glib-2.0.c" line="37482">Closes the subcontainer inside the given @builder that was opened by
the most recent call to g_variant_builder_open().

It is an error to call this function in any way that would create an
inconsistent value to be constructed (ie: too few values added to the
subcontainer).</doc>
        <source-position filename="gvariant.h" line="382" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none" gs:managed-name="builder" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37484">a #GVariantBuilder</doc>
            <type name="VariantBuilder" c:type="GVariantBuilder*" gs:managed-name="VariantBuilder" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="end" c:identifier="g_variant_builder_end" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="End">
        <doc xml:space="preserve" filename="glib-2.0.c" line="37497">Ends the builder process and returns the constructed value.

It is not permissible to use @builder in any way after this call
except for reference counting operations (in the case of a
heap-allocated #GVariantBuilder) or by reinitialising it with
g_variant_builder_init() (in the case of stack-allocated). This
means that for the stack-allocated builders there is no need to
call g_variant_builder_clear() after the call to
g_variant_builder_end().

It is an error to call this function in any way that would create an
inconsistent value to be constructed (ie: insufficient number of
items added to a container with a specific number of children
required).  It is also an error to call this function if the builder
was created with an indefinite array or maybe type and no children
have been added; in this case it is impossible to infer the type of
the empty array.</doc>
        <source-position filename="gvariant.h" line="375" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="37519">a new, floating, #GVariant</doc>
          <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none" gs:managed-name="builder" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37499">a #GVariantBuilder</doc>
            <type name="VariantBuilder" c:type="GVariantBuilder*" gs:managed-name="VariantBuilder" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="open" c:identifier="g_variant_builder_open" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="Open">
        <doc xml:space="preserve" filename="glib-2.0.c" line="37582">Opens a subcontainer inside the given @builder.  When done adding
items to the subcontainer, g_variant_builder_close() must be called. @type
is the type of the container: so to build a tuple of several values, @type
must include the tuple itself.

It is an error to call this function in any way that would cause an
inconsistent value to be constructed (ie: adding too many values or
a value of an incorrect type).

Example of building a nested variant:
|[&lt;!-- language="C" --&gt;
GVariantBuilder builder;
guint32 some_number = get_number ();
g_autoptr (GHashTable) some_dict = get_dict ();
GHashTableIter iter;
const gchar *key;
const GVariant *value;
g_autoptr (GVariant) output = NULL;

g_variant_builder_init (&amp;builder, G_VARIANT_TYPE ("(ua{sv})"));
g_variant_builder_add (&amp;builder, "u", some_number);
g_variant_builder_open (&amp;builder, G_VARIANT_TYPE ("a{sv}"));

g_hash_table_iter_init (&amp;iter, some_dict);
while (g_hash_table_iter_next (&amp;iter, (gpointer *) &amp;key, (gpointer *) &amp;value))
  {
    g_variant_builder_open (&amp;builder, G_VARIANT_TYPE ("{sv}"));
    g_variant_builder_add (&amp;builder, "s", key);
    g_variant_builder_add (&amp;builder, "v", value);
    g_variant_builder_close (&amp;builder);
  }

g_variant_builder_close (&amp;builder);

output = g_variant_builder_end (&amp;builder);
]|</doc>
        <source-position filename="gvariant.h" line="379" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none" gs:managed-name="builder" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37584">a #GVariantBuilder</doc>
            <type name="VariantBuilder" c:type="GVariantBuilder*" gs:managed-name="VariantBuilder" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37585">the #GVariantType of the container</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37585">the #GVariantType of the container</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="ref" c:identifier="g_variant_builder_ref" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="Ref" gs:special-func="ref" gs:pinvoke-only="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="37628">Increases the reference count on @builder.

Don't call this on stack-allocated #GVariantBuilder instances or bad
things will happen.</doc>
        <source-position filename="gvariant.h" line="370" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="37637">a new reference to @builder</doc>
          <type name="VariantBuilder" c:type="GVariantBuilder*" gs:managed-name="VariantBuilder" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="none" gs:managed-name="builder" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37630">a #GVariantBuilder allocated by g_variant_builder_new()</doc>
            <type name="VariantBuilder" c:type="GVariantBuilder*" gs:managed-name="VariantBuilder" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="unref" c:identifier="g_variant_builder_unref" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="Unref" gs:special-func="unref" gs:pinvoke-only="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="37642">Decreases the reference count on @builder.

In the event that there are no more references, releases all memory
associated with the #GVariantBuilder.

Don't call this on stack-allocated #GVariantBuilder instances or bad
things will happen.</doc>
        <source-position filename="gvariant.h" line="368" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="builder" transfer-ownership="full" gs:managed-name="builder" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37644">a #GVariantBuilder allocated by g_variant_builder_new()</doc>
            <type name="VariantBuilder" c:type="GVariantBuilder*" gs:managed-name="VariantBuilder" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_variant_builder_get_type" gs:access-modifiers="private" gs:dll-name="gobject-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </record>
    <enumeration name="VariantClass" version="2.24" c:type="GVariantClass" gs:managed-name="VariantClass">
      <doc xml:space="preserve" filename="glib-2.0.c" line="2643">The range of possible top-level types of #GVariant instances.</doc>
      <source-position filename="gvariant.h" line="56" />
      <member name="boolean" value="98" c:identifier="G_VARIANT_CLASS_BOOLEAN" gs:managed-name="Boolean">
        <doc xml:space="preserve" filename="glib-2.0.c" line="2645">The #GVariant is a boolean.</doc>
      </member>
      <member name="byte" value="121" c:identifier="G_VARIANT_CLASS_BYTE" gs:managed-name="Byte">
        <doc xml:space="preserve" filename="glib-2.0.c" line="2646">The #GVariant is a byte.</doc>
      </member>
      <member name="int16" value="110" c:identifier="G_VARIANT_CLASS_INT16" gs:managed-name="Int16">
        <doc xml:space="preserve" filename="glib-2.0.c" line="2647">The #GVariant is a signed 16 bit integer.</doc>
      </member>
      <member name="uint16" value="113" c:identifier="G_VARIANT_CLASS_UINT16" gs:managed-name="Uint16">
        <doc xml:space="preserve" filename="glib-2.0.c" line="2648">The #GVariant is an unsigned 16 bit integer.</doc>
      </member>
      <member name="int32" value="105" c:identifier="G_VARIANT_CLASS_INT32" gs:managed-name="Int32">
        <doc xml:space="preserve" filename="glib-2.0.c" line="2649">The #GVariant is a signed 32 bit integer.</doc>
      </member>
      <member name="uint32" value="117" c:identifier="G_VARIANT_CLASS_UINT32" gs:managed-name="Uint32">
        <doc xml:space="preserve" filename="glib-2.0.c" line="2650">The #GVariant is an unsigned 32 bit integer.</doc>
      </member>
      <member name="int64" value="120" c:identifier="G_VARIANT_CLASS_INT64" gs:managed-name="Int64">
        <doc xml:space="preserve" filename="glib-2.0.c" line="2651">The #GVariant is a signed 64 bit integer.</doc>
      </member>
      <member name="uint64" value="116" c:identifier="G_VARIANT_CLASS_UINT64" gs:managed-name="Uint64">
        <doc xml:space="preserve" filename="glib-2.0.c" line="2652">The #GVariant is an unsigned 64 bit integer.</doc>
      </member>
      <member name="handle" value="104" c:identifier="G_VARIANT_CLASS_HANDLE" gs:managed-name="Handle">
        <doc xml:space="preserve" filename="glib-2.0.c" line="2653">The #GVariant is a file handle index.</doc>
      </member>
      <member name="double" value="100" c:identifier="G_VARIANT_CLASS_DOUBLE" gs:managed-name="Double">
        <doc xml:space="preserve" filename="glib-2.0.c" line="2654">The #GVariant is a double precision floating
                         point value.</doc>
      </member>
      <member name="string" value="115" c:identifier="G_VARIANT_CLASS_STRING" gs:managed-name="String">
        <doc xml:space="preserve" filename="glib-2.0.c" line="2656">The #GVariant is a normal string.</doc>
      </member>
      <member name="object_path" value="111" c:identifier="G_VARIANT_CLASS_OBJECT_PATH" gs:managed-name="ObjectPath">
        <doc xml:space="preserve" filename="glib-2.0.c" line="2657">The #GVariant is a D-Bus object path
                              string.</doc>
      </member>
      <member name="signature" value="103" c:identifier="G_VARIANT_CLASS_SIGNATURE" gs:managed-name="Signature">
        <doc xml:space="preserve" filename="glib-2.0.c" line="2659">The #GVariant is a D-Bus signature string.</doc>
      </member>
      <member name="variant" value="118" c:identifier="G_VARIANT_CLASS_VARIANT" gs:managed-name="Variant">
        <doc xml:space="preserve" filename="glib-2.0.c" line="2660">The #GVariant is a variant.</doc>
      </member>
      <member name="maybe" value="109" c:identifier="G_VARIANT_CLASS_MAYBE" gs:managed-name="Maybe">
        <doc xml:space="preserve" filename="glib-2.0.c" line="2661">The #GVariant is a maybe-typed value.</doc>
      </member>
      <member name="array" value="97" c:identifier="G_VARIANT_CLASS_ARRAY" gs:managed-name="Array">
        <doc xml:space="preserve" filename="glib-2.0.c" line="2662">The #GVariant is an array.</doc>
      </member>
      <member name="tuple" value="40" c:identifier="G_VARIANT_CLASS_TUPLE" gs:managed-name="Tuple">
        <doc xml:space="preserve" filename="glib-2.0.c" line="2663">The #GVariant is a tuple.</doc>
      </member>
      <member name="dict_entry" value="123" c:identifier="G_VARIANT_CLASS_DICT_ENTRY" gs:managed-name="DictEntry">
        <doc xml:space="preserve" filename="glib-2.0.c" line="2664">The #GVariant is a dictionary entry.</doc>
      </member>
    </enumeration>
    <record name="VariantDict" c:type="GVariantDict" version="2.40" glib:type-name="GVariantDict" glib:get-type="g_variant_dict_get_type" c:symbol-prefix="variant_dict" gs:managed-name="VariantDict">
      <doc xml:space="preserve" filename="glib-2.0.c" line="2672">#GVariantDict is a mutable interface to #GVariant dictionaries.

It can be used for doing a sequence of dictionary lookups in an
efficient way on an existing #GVariant dictionary or it can be used
to construct new dictionaries with a hashtable-like interface.  It
can also be used for taking existing dictionaries and modifying them
in order to create new ones.

#GVariantDict can only be used with %G_VARIANT_TYPE_VARDICT
dictionaries.

It is possible to use #GVariantDict allocated on the stack or on the
heap.  When using a stack-allocated #GVariantDict, you begin with a
call to g_variant_dict_init() and free the resources with a call to
g_variant_dict_clear().

Heap-allocated #GVariantDict follows normal refcounting rules: you
allocate it with g_variant_dict_new() and use g_variant_dict_ref()
and g_variant_dict_unref().

g_variant_dict_end() is used to convert the #GVariantDict back into a
dictionary-type #GVariant.  When used with stack-allocated instances,
this also implicitly frees all associated memory, but for
heap-allocated instances, you must still call g_variant_dict_unref()
afterwards.

You will typically want to use a heap-allocated #GVariantDict when
you expose it as part of an API.  For most other uses, the
stack-allocated form will be more convenient.

Consider the following two examples that do the same thing in each
style: take an existing dictionary and look up the "count" uint32
key, adding 1 to it if it is found, or returning an error if the
key is not found.  Each returns the new dictionary as a floating
#GVariant.

## Using a stack-allocated GVariantDict

|[&lt;!-- language="C" --&gt;
  GVariant *
  add_to_count (GVariant  *orig,
                GError   **error)
  {
    GVariantDict dict;
    guint32 count;

    g_variant_dict_init (&amp;dict, orig);
    if (!g_variant_dict_lookup (&amp;dict, "count", "u", &amp;count))
      {
        g_set_error (...);
        g_variant_dict_clear (&amp;dict);
        return NULL;
      }

    g_variant_dict_insert (&amp;dict, "count", "u", count + 1);

    return g_variant_dict_end (&amp;dict);
  }
]|

## Using heap-allocated GVariantDict

|[&lt;!-- language="C" --&gt;
  GVariant *
  add_to_count (GVariant  *orig,
                GError   **error)
  {
    GVariantDict *dict;
    GVariant *result;
    guint32 count;

    dict = g_variant_dict_new (orig);

    if (g_variant_dict_lookup (dict, "count", "u", &amp;count))
      {
        g_variant_dict_insert (dict, "count", "u", count + 1);
        result = g_variant_dict_end (dict);
      }
    else
      {
        g_set_error (...);
        result = NULL;
      }

    g_variant_dict_unref (dict);

    return result;
  }
]|</doc>
      <source-position filename="gvariant.h" line="449" />
      <union name="u" c:type="u" gs:managed-name="U">
        <source-position filename="gvariant.h" line="448" />
        <record name="s" c:type="s" gs:managed-name="S">
          <source-position filename="gvariant.h" line="446" />
          <field name="asv" writable="1" gs:managed-name="Asv">
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </field>
          <field name="partial_magic" writable="1" gs:managed-name="PartialMagic">
            <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
          </field>
          <field name="y" writable="1" gs:managed-name="Y">
            <array zero-terminated="0" fixed-size="14" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
            </array>
          </field>
        </record>
        <field name="x" writable="1" gs:managed-name="X">
          <array zero-terminated="0" fixed-size="16" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
            <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
          </array>
        </field>
      </union>
      <constructor name="new" c:identifier="g_variant_dict_new" version="2.40" gs:dll-name="glib-2.0" gs:managed-name="New">
        <doc xml:space="preserve" filename="glib-2.0.c" line="37902">Allocates and initialises a new #GVariantDict.

You should call g_variant_dict_unref() on the return value when it
is no longer needed.  The memory will not be automatically freed by
any other call.

In some cases it may be easier to place a #GVariantDict directly on
the stack of the calling function and initialise it with
g_variant_dict_init().  This is particularly useful when you are
using #GVariantDict to construct a #GVariant.</doc>
        <source-position filename="gvariant.h" line="481" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="37918">a #GVariantDict</doc>
          <type name="VariantDict" c:type="GVariantDict*" gs:managed-name="VariantDict" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="from_asv" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="fromAsv" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37904">the #GVariant with which to initialise the
  dictionary</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="from_asv" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="fromAsv" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37904">the #GVariant with which to initialise the
  dictionary</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <method name="contains" c:identifier="g_variant_dict_contains" version="2.40" gs:dll-name="glib-2.0" gs:managed-name="Contains">
        <doc xml:space="preserve" filename="glib-2.0.c" line="37771">Checks if @key exists in @dict.</doc>
        <source-position filename="gvariant.h" line="497" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="37778">%TRUE if @key is in @dict</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="dict" transfer-ownership="none" gs:managed-name="dict" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37773">a #GVariantDict</doc>
            <type name="VariantDict" c:type="GVariantDict*" gs:managed-name="VariantDict" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37774">the key to look up in the dictionary</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37774">the key to look up in the dictionary</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="end" c:identifier="g_variant_dict_end" version="2.40" gs:dll-name="glib-2.0" gs:managed-name="End">
        <doc xml:space="preserve" filename="glib-2.0.c" line="37783">Returns the current value of @dict as a #GVariant of type
%G_VARIANT_TYPE_VARDICT, clearing it in the process.

It is not permissible to use @dict in any way after this call except
for reference counting operations (in the case of a heap-allocated
#GVariantDict) or by reinitialising it with g_variant_dict_init() (in
the case of stack-allocated).</doc>
        <source-position filename="gvariant.h" line="514" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="37795">a new, floating, #GVariant</doc>
          <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="dict" transfer-ownership="none" gs:managed-name="dict" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37785">a #GVariantDict</doc>
            <type name="VariantDict" c:type="GVariantDict*" gs:managed-name="VariantDict" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="insert" c:identifier="g_variant_dict_insert_value" version="2.40" gs:dll-name="glib-2.0" gs:managed-name="Insert">
        <doc xml:space="preserve" filename="glib-2.0.c" line="37842">Inserts (or replaces) a key in a #GVariantDict.

@value is consumed if it is floating.</doc>
        <source-position filename="gvariant.h" line="505" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="dict" transfer-ownership="none" gs:managed-name="dict" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37844">a #GVariantDict</doc>
            <type name="VariantDict" c:type="GVariantDict*" gs:managed-name="VariantDict" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37845">the key to insert a value for</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37846">the value to insert</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37845">the key to insert a value for</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37846">the value to insert</doc>
            <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="lookup" c:identifier="g_variant_dict_lookup_value" version="2.40" gs:dll-name="glib-2.0" gs:managed-name="Lookup">
        <doc xml:space="preserve" filename="glib-2.0.c" line="37879">Looks up a value in a #GVariantDict.

If @key is not found in @dictionary, %NULL is returned.

The @expected_type string specifies what type of value is expected.
If the value associated with @key has a different type then %NULL is
returned.

If the key is found and the value has the correct type, it is
returned.  If @expected_type was specified then any non-%NULL return
value will have this type.</doc>
        <source-position filename="gvariant.h" line="493" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="37897">the value of the dictionary key, or %NULL</doc>
          <type name="Variant" c:type="GVariant*" gs:managed-name="Variant" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="dict" transfer-ownership="none" gs:managed-name="dict" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37881">a #GVariantDict</doc>
            <type name="VariantDict" c:type="GVariantDict*" gs:managed-name="VariantDict" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37882">the key to look up in the dictionary</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="expected_type" transfer-ownership="none" nullable="1" allow-none="1" gs:default="null" gs:managed-name="expectedType" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37883">a #GVariantType, or %NULL</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37882">the key to look up in the dictionary</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="expected_type" transfer-ownership="none" nullable="1" allow-none="1" gs:default="null" gs:managed-name="expectedType" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37883">a #GVariantType, or %NULL</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="ref" c:identifier="g_variant_dict_ref" version="2.40" gs:dll-name="glib-2.0" gs:managed-name="Ref" gs:special-func="ref" gs:pinvoke-only="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="37923">Increases the reference count on @dict.

Don't call this on stack-allocated #GVariantDict instances or bad
things will happen.</doc>
        <source-position filename="gvariant.h" line="516" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="37932">a new reference to @dict</doc>
          <type name="VariantDict" c:type="GVariantDict*" gs:managed-name="VariantDict" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="dict" transfer-ownership="none" gs:managed-name="dict" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37925">a heap-allocated #GVariantDict</doc>
            <type name="VariantDict" c:type="GVariantDict*" gs:managed-name="VariantDict" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="remove" c:identifier="g_variant_dict_remove" version="2.40" gs:dll-name="glib-2.0" gs:managed-name="Remove">
        <doc xml:space="preserve" filename="glib-2.0.c" line="37937">Removes a key and its associated value from a #GVariantDict.</doc>
        <source-position filename="gvariant.h" line="509" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="37944">%TRUE if the key was found and removed</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="dict" transfer-ownership="none" gs:managed-name="dict" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37939">a #GVariantDict</doc>
            <type name="VariantDict" c:type="GVariantDict*" gs:managed-name="VariantDict" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37940">the key to remove</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37940">the key to remove</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="unref" c:identifier="g_variant_dict_unref" version="2.40" gs:dll-name="glib-2.0" gs:managed-name="Unref" gs:special-func="unref" gs:pinvoke-only="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="37949">Decreases the reference count on @dict.

In the event that there are no more references, releases all memory
associated with the #GVariantDict.

Don't call this on stack-allocated #GVariantDict instances or bad
things will happen.</doc>
        <source-position filename="gvariant.h" line="518" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="dict" transfer-ownership="full" gs:managed-name="dict" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37951">a heap-allocated #GVariantDict</doc>
            <type name="VariantDict" c:type="GVariantDict*" gs:managed-name="VariantDict" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_variant_dict_get_type" gs:access-modifiers="private" gs:dll-name="gobject-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </record>
    <enumeration name="VariantParseError" c:type="GVariantParseError" glib:error-domain="g-variant-parse-error-quark" gs:managed-name="VariantParseError">
      <doc xml:space="preserve" filename="glib-2.0.c" line="2777">Error codes returned by parsing text-format GVariants.</doc>
      <source-position filename="gvariant.h" line="332" />
      <member name="failed" value="0" c:identifier="G_VARIANT_PARSE_ERROR_FAILED" gs:managed-name="Failed">
        <doc xml:space="preserve" filename="glib-2.0.c" line="2779">generic error (unused)</doc>
      </member>
      <member name="basic_type_expected" value="1" c:identifier="G_VARIANT_PARSE_ERROR_BASIC_TYPE_EXPECTED" gs:managed-name="BasicTypeExpected">
        <doc xml:space="preserve" filename="glib-2.0.c" line="2780">a non-basic #GVariantType was given where a basic type was expected</doc>
      </member>
      <member name="cannot_infer_type" value="2" c:identifier="G_VARIANT_PARSE_ERROR_CANNOT_INFER_TYPE" gs:managed-name="CannotInferType">
        <doc xml:space="preserve" filename="glib-2.0.c" line="2781">cannot infer the #GVariantType</doc>
      </member>
      <member name="definite_type_expected" value="3" c:identifier="G_VARIANT_PARSE_ERROR_DEFINITE_TYPE_EXPECTED" gs:managed-name="DefiniteTypeExpected">
        <doc xml:space="preserve" filename="glib-2.0.c" line="2782">an indefinite #GVariantType was given where a definite type was expected</doc>
      </member>
      <member name="input_not_at_end" value="4" c:identifier="G_VARIANT_PARSE_ERROR_INPUT_NOT_AT_END" gs:managed-name="InputNotAtEnd">
        <doc xml:space="preserve" filename="glib-2.0.c" line="2783">extra data after parsing finished</doc>
      </member>
      <member name="invalid_character" value="5" c:identifier="G_VARIANT_PARSE_ERROR_INVALID_CHARACTER" gs:managed-name="InvalidCharacter">
        <doc xml:space="preserve" filename="glib-2.0.c" line="2784">invalid character in number or unicode escape</doc>
      </member>
      <member name="invalid_format_string" value="6" c:identifier="G_VARIANT_PARSE_ERROR_INVALID_FORMAT_STRING" gs:managed-name="InvalidFormatString">
        <doc xml:space="preserve" filename="glib-2.0.c" line="2785">not a valid #GVariant format string</doc>
      </member>
      <member name="invalid_object_path" value="7" c:identifier="G_VARIANT_PARSE_ERROR_INVALID_OBJECT_PATH" gs:managed-name="InvalidObjectPath">
        <doc xml:space="preserve" filename="glib-2.0.c" line="2786">not a valid object path</doc>
      </member>
      <member name="invalid_signature" value="8" c:identifier="G_VARIANT_PARSE_ERROR_INVALID_SIGNATURE" gs:managed-name="InvalidSignature">
        <doc xml:space="preserve" filename="glib-2.0.c" line="2787">not a valid type signature</doc>
      </member>
      <member name="invalid_type_string" value="9" c:identifier="G_VARIANT_PARSE_ERROR_INVALID_TYPE_STRING" gs:managed-name="InvalidTypeString">
        <doc xml:space="preserve" filename="glib-2.0.c" line="2788">not a valid #GVariant type string</doc>
      </member>
      <member name="no_common_type" value="10" c:identifier="G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE" gs:managed-name="NoCommonType">
        <doc xml:space="preserve" filename="glib-2.0.c" line="2789">could not find a common type for array entries</doc>
      </member>
      <member name="number_out_of_range" value="11" c:identifier="G_VARIANT_PARSE_ERROR_NUMBER_OUT_OF_RANGE" gs:managed-name="NumberOutOfRange">
        <doc xml:space="preserve" filename="glib-2.0.c" line="2790">the numerical value is out of range of the given type</doc>
      </member>
      <member name="number_too_big" value="12" c:identifier="G_VARIANT_PARSE_ERROR_NUMBER_TOO_BIG" gs:managed-name="NumberTooBig">
        <doc xml:space="preserve" filename="glib-2.0.c" line="2791">the numerical value is out of range for any type</doc>
      </member>
      <member name="type_error" value="13" c:identifier="G_VARIANT_PARSE_ERROR_TYPE_ERROR" gs:managed-name="TypeError">
        <doc xml:space="preserve" filename="glib-2.0.c" line="2792">cannot parse as variant of the specified type</doc>
      </member>
      <member name="unexpected_token" value="14" c:identifier="G_VARIANT_PARSE_ERROR_UNEXPECTED_TOKEN" gs:managed-name="UnexpectedToken">
        <doc xml:space="preserve" filename="glib-2.0.c" line="2793">an unexpected token was encountered</doc>
      </member>
      <member name="unknown_keyword" value="15" c:identifier="G_VARIANT_PARSE_ERROR_UNKNOWN_KEYWORD" gs:managed-name="UnknownKeyword">
        <doc xml:space="preserve" filename="glib-2.0.c" line="2794">an unknown keyword was encountered</doc>
      </member>
      <member name="unterminated_string_constant" value="16" c:identifier="G_VARIANT_PARSE_ERROR_UNTERMINATED_STRING_CONSTANT" gs:managed-name="UnterminatedStringConstant">
        <doc xml:space="preserve" filename="glib-2.0.c" line="2795">unterminated string constant</doc>
      </member>
      <member name="value_expected" value="17" c:identifier="G_VARIANT_PARSE_ERROR_VALUE_EXPECTED" gs:managed-name="ValueExpected">
        <doc xml:space="preserve" filename="glib-2.0.c" line="2796">no value given</doc>
      </member>
      <member name="recursion" value="18" c:identifier="G_VARIANT_PARSE_ERROR_RECURSION" version="2.64" gs:managed-name="Recursion">
        <doc xml:space="preserve" filename="glib-2.0.c" line="2797">variant was too deeply nested; #GVariant is only guaranteed to handle nesting up to 64 levels ()</doc>
      </member>
    </enumeration>
    <record name="VariantType" c:type="GVariantType" glib:type-name="GVariantType" glib:get-type="g_variant_type_get_gtype" c:symbol-prefix="variant_type" gs:managed-name="VariantType">
      <doc xml:space="preserve" filename="glib-2.0.c" line="6461">This section introduces the GVariant type system. It is based, in
large part, on the D-Bus type system, with two major changes and
some minor lifting of restrictions. The
[D-Bus specification](http://dbus.freedesktop.org/doc/dbus-specification.html),
therefore, provides a significant amount of
information that is useful when working with GVariant.

The first major change with respect to the D-Bus type system is the
introduction of maybe (or "nullable") types.  Any type in GVariant can be
converted to a maybe type, in which case, "nothing" (or "null") becomes a
valid value.  Maybe types have been added by introducing the
character "m" to type strings.

The second major change is that the GVariant type system supports the
concept of "indefinite types" -- types that are less specific than
the normal types found in D-Bus.  For example, it is possible to speak
of "an array of any type" in GVariant, where the D-Bus type system
would require you to speak of "an array of integers" or "an array of
strings".  Indefinite types have been added by introducing the
characters "*", "?" and "r" to type strings.

Finally, all arbitrary restrictions relating to the complexity of
types are lifted along with the restriction that dictionary entries
may only appear nested inside of arrays.

Just as in D-Bus, GVariant types are described with strings ("type
strings").  Subject to the differences mentioned above, these strings
are of the same form as those found in DBus.  Note, however: D-Bus
always works in terms of messages and therefore individual type
strings appear nowhere in its interface.  Instead, "signatures"
are a concatenation of the strings of the type of each argument in a
message.  GVariant deals with single values directly so GVariant type
strings always describe the type of exactly one value.  This means
that a D-Bus signature string is generally not a valid GVariant type
string -- except in the case that it is the signature of a message
containing exactly one argument.

An indefinite type is similar in spirit to what may be called an
abstract type in other type systems.  No value can exist that has an
indefinite type as its type, but values can exist that have types
that are subtypes of indefinite types.  That is to say,
g_variant_get_type() will never return an indefinite type, but
calling g_variant_is_of_type() with an indefinite type may return
%TRUE.  For example, you cannot have a value that represents "an
array of no particular type", but you can have an "array of integers"
which certainly matches the type of "an array of no particular type",
since "array of integers" is a subtype of "array of no particular
type".

This is similar to how instances of abstract classes may not
directly exist in other type systems, but instances of their
non-abstract subtypes may.  For example, in GTK, no object that has
the type of #GtkBin can exist (since #GtkBin is an abstract class),
but a #GtkWindow can certainly be instantiated, and you would say
that the #GtkWindow is a #GtkBin (since #GtkWindow is a subclass of
#GtkBin).

## GVariant Type Strings

A GVariant type string can be any of the following:

- any basic type string (listed below)

- "v", "r" or "*"

- one of the characters 'a' or 'm', followed by another type string

- the character '(', followed by a concatenation of zero or more other
  type strings, followed by the character ')'

- the character '{', followed by a basic type string (see below),
  followed by another type string, followed by the character '}'

A basic type string describes a basic type (as per
g_variant_type_is_basic()) and is always a single character in length.
The valid basic type strings are "b", "y", "n", "q", "i", "u", "x", "t",
"h", "d", "s", "o", "g" and "?".

The above definition is recursive to arbitrary depth. "aaaaai" and
"(ui(nq((y)))s)" are both valid type strings, as is
"a(aa(ui)(qna{ya(yd)}))". In order to not hit memory limits, #GVariant
imposes a limit on recursion depth of 65 nested containers. This is the
limit in the D-Bus specification (64) plus one to allow a #GDBusMessage to
be nested in a top-level tuple.

The meaning of each of the characters is as follows:
- `b`: the type string of %G_VARIANT_TYPE_BOOLEAN; a boolean value.
- `y`: the type string of %G_VARIANT_TYPE_BYTE; a byte.
- `n`: the type string of %G_VARIANT_TYPE_INT16; a signed 16 bit integer.
- `q`: the type string of %G_VARIANT_TYPE_UINT16; an unsigned 16 bit integer.
- `i`: the type string of %G_VARIANT_TYPE_INT32; a signed 32 bit integer.
- `u`: the type string of %G_VARIANT_TYPE_UINT32; an unsigned 32 bit integer.
- `x`: the type string of %G_VARIANT_TYPE_INT64; a signed 64 bit integer.
- `t`: the type string of %G_VARIANT_TYPE_UINT64; an unsigned 64 bit integer.
- `h`: the type string of %G_VARIANT_TYPE_HANDLE; a signed 32 bit value
  that, by convention, is used as an index into an array of file
  descriptors that are sent alongside a D-Bus message.
- `d`: the type string of %G_VARIANT_TYPE_DOUBLE; a double precision
  floating point value.
- `s`: the type string of %G_VARIANT_TYPE_STRING; a string.
- `o`: the type string of %G_VARIANT_TYPE_OBJECT_PATH; a string in the form
  of a D-Bus object path.
- `g`: the type string of %G_VARIANT_TYPE_SIGNATURE; a string in the form of
  a D-Bus type signature.
- `?`: the type string of %G_VARIANT_TYPE_BASIC; an indefinite type that
  is a supertype of any of the basic types.
- `v`: the type string of %G_VARIANT_TYPE_VARIANT; a container type that
  contain any other type of value.
- `a`: used as a prefix on another type string to mean an array of that
  type; the type string "ai", for example, is the type of an array of
  signed 32-bit integers.
- `m`: used as a prefix on another type string to mean a "maybe", or
  "nullable", version of that type; the type string "ms", for example,
  is the type of a value that maybe contains a string, or maybe contains
  nothing.
- `()`: used to enclose zero or more other concatenated type strings to
  create a tuple type; the type string "(is)", for example, is the type of
  a pair of an integer and a string.
- `r`: the type string of %G_VARIANT_TYPE_TUPLE; an indefinite type that is
  a supertype of any tuple type, regardless of the number of items.
- `{}`: used to enclose a basic type string concatenated with another type
  string to create a dictionary entry type, which usually appears inside of
  an array to form a dictionary; the type string "a{sd}", for example, is
  the type of a dictionary that maps strings to double precision floating
  point values.

  The first type (the basic type) is the key type and the second type is
  the value type. The reason that the first type is restricted to being a
  basic type is so that it can easily be hashed.
- `*`: the type string of %G_VARIANT_TYPE_ANY; the indefinite type that is
  a supertype of all types.  Note that, as with all type strings, this
  character represents exactly one type. It cannot be used inside of tuples
  to mean "any number of items".

Any type string of a container that contains an indefinite type is,
itself, an indefinite type. For example, the type string "a*"
(corresponding to %G_VARIANT_TYPE_ARRAY) is an indefinite type
that is a supertype of every array type. "(*s)" is a supertype
of all tuples that contain exactly two items where the second
item is a string.

"a{?*}" is an indefinite type that is a supertype of all arrays
containing dictionary entries where the key is any basic type and
the value is any type at all.  This is, by definition, a dictionary,
so this type string corresponds to %G_VARIANT_TYPE_DICTIONARY. Note
that, due to the restriction that the key of a dictionary entry must
be a basic type, "{**}" is not a valid type string.</doc>
      <source-position filename="gvarianttype.h" line="41" />
      <constructor name="new" c:identifier="g_variant_type_new" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="New">
        <doc xml:space="preserve" filename="glib-2.0.c" line="40275">Creates a new #GVariantType corresponding to the type string given
by @type_string.  It is appropriate to call g_variant_type_free() on
the return value.

It is a programmer error to call this function with an invalid type
string.  Use g_variant_type_string_is_valid() if you are unsure.</doc>
        <source-position filename="gvarianttype.h" line="308" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="40286">a new #GVariantType</doc>
          <type name="VariantType" c:type="GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="type_string" transfer-ownership="none" gs:managed-name="typeString" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="40277">a valid GVariant type string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="type_string" transfer-ownership="none" gs:managed-name="typeString" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="40277">a valid GVariant type string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <constructor name="new_array" c:identifier="g_variant_type_new_array" gs:dll-name="glib-2.0" gs:managed-name="NewArray">
        <doc xml:space="preserve" filename="glib-2.0.c" line="40291">Constructs the type corresponding to an array of elements of the
type @type.

It is appropriate to call g_variant_type_free() on the return value.</doc>
        <source-position filename="gvarianttype.h" line="364" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="40300">a new array #GVariantType

Since 2.24</doc>
          <type name="VariantType" c:type="GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="element" transfer-ownership="none" gs:managed-name="element" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="40293">a #GVariantType</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="element" transfer-ownership="none" gs:managed-name="element" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="40293">a #GVariantType</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <constructor name="new_dict_entry" c:identifier="g_variant_type_new_dict_entry" gs:dll-name="glib-2.0" gs:managed-name="NewDictEntry">
        <doc xml:space="preserve" filename="glib-2.0.c" line="40306">Constructs the type corresponding to a dictionary entry with a key
of type @key and a value of type @value.

It is appropriate to call g_variant_type_free() on the return value.</doc>
        <source-position filename="gvarianttype.h" line="371" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="40316">a new dictionary entry #GVariantType

Since 2.24</doc>
          <type name="VariantType" c:type="GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="40308">a basic #GVariantType</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="40309">a #GVariantType</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="40308">a basic #GVariantType</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="40309">a #GVariantType</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <constructor name="new_maybe" c:identifier="g_variant_type_new_maybe" gs:dll-name="glib-2.0" gs:managed-name="NewMaybe">
        <doc xml:space="preserve" filename="glib-2.0.c" line="40322">Constructs the type corresponding to a maybe instance containing
type @type or Nothing.

It is appropriate to call g_variant_type_free() on the return value.</doc>
        <source-position filename="gvarianttype.h" line="366" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="40331">a new maybe #GVariantType

Since 2.24</doc>
          <type name="VariantType" c:type="GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="element" transfer-ownership="none" gs:managed-name="element" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="40324">a #GVariantType</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="element" transfer-ownership="none" gs:managed-name="element" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="40324">a #GVariantType</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <constructor name="new_tuple" c:identifier="g_variant_type_new_tuple" gs:dll-name="glib-2.0" gs:managed-name="NewTuple">
        <doc xml:space="preserve" filename="glib-2.0.c" line="40337">Constructs a new tuple type, from @items.

@length is the number of items in @items, or -1 to indicate that
@items is %NULL-terminated.

It is appropriate to call g_variant_type_free() on the return value.</doc>
        <source-position filename="gvarianttype.h" line="368" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="40349">a new tuple #GVariantType

Since 2.24</doc>
          <type name="VariantType" c:type="GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="items" transfer-ownership="none" gs:managed-name="items" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="40339">an array of #GVariantTypes, one for each item</doc>
            <array length="1" zero-terminated="0" c:type="const GVariantType* const*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="VariantType" c:type="GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none" gs:managed-name="length" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="40340">the length of @items, or -1</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="items" transfer-ownership="none" gs:managed-name="items" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="40339">an array of #GVariantTypes, one for each item</doc>
            <array length="1" zero-terminated="0" c:type="const GVariantType* const*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="VariantType" c:type="GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
            </array>
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <method name="copy" c:identifier="g_variant_type_copy" gs:dll-name="glib-2.0" gs:managed-name="Copy" gs:special-func="copy" gs:pinvoke-only="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="39949">Makes a copy of a #GVariantType.  It is appropriate to call
g_variant_type_free() on the return value.  @type may not be %NULL.</doc>
        <source-position filename="gvarianttype.h" line="306" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="39956">a new #GVariantType

Since 2.24</doc>
          <type name="VariantType" c:type="GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39951">a #GVariantType</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="dup_string" c:identifier="g_variant_type_dup_string" gs:dll-name="glib-2.0" gs:managed-name="DupString">
        <doc xml:space="preserve" filename="glib-2.0.c" line="39962">Returns a newly-allocated copy of the type string corresponding to
@type.  The returned string is nul-terminated.  It is appropriate to
call g_free() on the return value.</doc>
        <source-position filename="gvarianttype.h" line="316" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="39970">the corresponding type string

Since 2.24</doc>
          <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39964">a #GVariantType</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="element" c:identifier="g_variant_type_element" gs:dll-name="glib-2.0" gs:managed-name="Element">
        <doc xml:space="preserve" filename="glib-2.0.c" line="39976">Determines the element type of an array or maybe type.

This function may only be used with array or maybe types.</doc>
        <source-position filename="gvarianttype.h" line="350" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="39984">the element type of @type

Since 2.24</doc>
          <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39978">an array or maybe #GVariantType</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="equal" c:identifier="g_variant_type_equal" gs:dll-name="glib-2.0" gs:managed-name="Equals" gs:equal="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="39990">Compares @type1 and @type2 for equality.

Only returns %TRUE if the types are exactly equal.  Even if one type
is an indefinite type and the other is a subtype of it, %FALSE will
be returned if they are not exactly equal.  If you want to check for
subtypes, use g_variant_type_is_subtype_of().

The argument types of @type1 and @type2 are only #gconstpointer to
allow use with #GHashTable without function pointer casting.  For
both arguments, a valid #GVariantType must be provided.</doc>
        <source-position filename="gvarianttype.h" line="340" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="40006">%TRUE if @type1 and @type2 are exactly equal

Since 2.24</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="type1" transfer-ownership="none" gs:managed-name="type1" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39992">a #GVariantType</doc>
            <type name="VariantType" c:type="gconstpointer" gs:managed-name="VariantType" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="type2" transfer-ownership="none" gs:managed-name="type2" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39993">a #GVariantType</doc>
            <type name="VariantType" c:type="gconstpointer" gs:managed-name="VariantType" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="type2" transfer-ownership="none" gs:managed-name="type2" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="39993">a #GVariantType</doc>
            <type name="VariantType" c:type="gconstpointer" gs:managed-name="VariantType" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="first" c:identifier="g_variant_type_first" gs:dll-name="glib-2.0" gs:managed-name="First">
        <doc xml:space="preserve" filename="glib-2.0.c" line="40012">Determines the first item type of a tuple or dictionary entry
type.

This function may only be used with tuple or dictionary entry types,
but must not be used with the generic tuple type
%G_VARIANT_TYPE_TUPLE.

In the case of a dictionary entry type, this returns the type of
the key.

%NULL is returned in case of @type being %G_VARIANT_TYPE_UNIT.

This call, together with g_variant_type_next() provides an iterator
interface over tuple and dictionary entry types.</doc>
        <source-position filename="gvarianttype.h" line="352" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="40031">the first item type of @type, or %NULL

Since 2.24</doc>
          <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="40014">a tuple or dictionary entry #GVariantType</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="free" c:identifier="g_variant_type_free" gs:dll-name="glib-2.0" gs:managed-name="Free" gs:special-func="free" gs:pinvoke-only="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="40037">Frees a #GVariantType that was allocated with
g_variant_type_copy(), g_variant_type_new() or one of the container
type constructor functions.

In the case that @type is %NULL, this function does nothing.

Since 2.24</doc>
        <source-position filename="gvarianttype.h" line="304" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="40039">a #GVariantType, or %NULL</doc>
            <type name="VariantType" c:type="GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_string_length" gs:dll-name="glib-2.0" gs:managed-name="StringLength">
        <doc xml:space="preserve" filename="glib-2.0.c" line="40051">Returns the length of the type string corresponding to the given
@type.  This function must be used to determine the valid extent of
the memory region returned by g_variant_type_peek_string().</doc>
        <source-position filename="gvarianttype.h" line="312" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="40059">the length of the corresponding type string

Since 2.24</doc>
          <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="40053">a #GVariantType</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_string_length" c:identifier="g_variant_type_get_string_length" gs:dll-name="glib-2.0" gs:managed-name="GetStringLength" gs:property-getter-for="StringLength" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="40051">Returns the length of the type string corresponding to the given
@type.  This function must be used to determine the valid extent of
the memory region returned by g_variant_type_peek_string().</doc>
        <source-position filename="gvarianttype.h" line="312" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="40059">the length of the corresponding type string

Since 2.24</doc>
          <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="40053">a #GVariantType</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="hash" c:identifier="g_variant_type_hash" gs:dll-name="glib-2.0" gs:managed-name="GetHashCode" gs:hash="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="40065">Hashes @type.

The argument type of @type is only #gconstpointer to allow use with
#GHashTable without function pointer casting.  A valid
#GVariantType must be provided.</doc>
        <source-position filename="gvarianttype.h" line="338" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="40075">the hash value

Since 2.24</doc>
          <type name="guint" c:type="guint" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="40067">a #GVariantType</doc>
            <type name="VariantType" c:type="gconstpointer" gs:managed-name="VariantType" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="is_array" gs:dll-name="glib-2.0" gs:managed-name="IsArray">
        <doc xml:space="preserve" filename="glib-2.0.c" line="40081">Determines if the given @type is an array type.  This is true if the
type string for @type starts with an 'a'.

This function returns %TRUE for any indefinite type for which every
definite subtype is an array type -- %G_VARIANT_TYPE_ARRAY, for
example.</doc>
        <source-position filename="gvarianttype.h" line="328" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="40092">%TRUE if @type is an array type

Since 2.24</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="40083">a #GVariantType</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="is_array" c:identifier="g_variant_type_is_array" gs:dll-name="glib-2.0" gs:managed-name="GetIsArray" gs:property-getter-for="IsArray" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="40081">Determines if the given @type is an array type.  This is true if the
type string for @type starts with an 'a'.

This function returns %TRUE for any indefinite type for which every
definite subtype is an array type -- %G_VARIANT_TYPE_ARRAY, for
example.</doc>
        <source-position filename="gvarianttype.h" line="328" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="40092">%TRUE if @type is an array type

Since 2.24</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="40083">a #GVariantType</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="is_basic" gs:dll-name="glib-2.0" gs:managed-name="IsBasic">
        <doc xml:space="preserve" filename="glib-2.0.c" line="40098">Determines if the given @type is a basic type.

Basic types are booleans, bytes, integers, doubles, strings, object
paths and signatures.

Only a basic type may be used as the key of a dictionary entry.

This function returns %FALSE for all indefinite types except
%G_VARIANT_TYPE_BASIC.</doc>
        <source-position filename="gvarianttype.h" line="324" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="40112">%TRUE if @type is a basic type

Since 2.24</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="40100">a #GVariantType</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="is_basic" c:identifier="g_variant_type_is_basic" gs:dll-name="glib-2.0" gs:managed-name="GetIsBasic" gs:property-getter-for="IsBasic" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="40098">Determines if the given @type is a basic type.

Basic types are booleans, bytes, integers, doubles, strings, object
paths and signatures.

Only a basic type may be used as the key of a dictionary entry.

This function returns %FALSE for all indefinite types except
%G_VARIANT_TYPE_BASIC.</doc>
        <source-position filename="gvarianttype.h" line="324" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="40112">%TRUE if @type is a basic type

Since 2.24</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="40100">a #GVariantType</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="is_container" gs:dll-name="glib-2.0" gs:managed-name="IsContainer">
        <doc xml:space="preserve" filename="glib-2.0.c" line="40118">Determines if the given @type is a container type.

Container types are any array, maybe, tuple, or dictionary
entry types plus the variant type.

This function returns %TRUE for any indefinite type for which every
definite subtype is a container -- %G_VARIANT_TYPE_ARRAY, for
example.</doc>
        <source-position filename="gvarianttype.h" line="322" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="40131">%TRUE if @type is a container type

Since 2.24</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="40120">a #GVariantType</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="is_container" c:identifier="g_variant_type_is_container" gs:dll-name="glib-2.0" gs:managed-name="GetIsContainer" gs:property-getter-for="IsContainer" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="40118">Determines if the given @type is a container type.

Container types are any array, maybe, tuple, or dictionary
entry types plus the variant type.

This function returns %TRUE for any indefinite type for which every
definite subtype is a container -- %G_VARIANT_TYPE_ARRAY, for
example.</doc>
        <source-position filename="gvarianttype.h" line="322" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="40131">%TRUE if @type is a container type

Since 2.24</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="40120">a #GVariantType</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="is_definite" gs:dll-name="glib-2.0" gs:managed-name="IsDefinite">
        <doc xml:space="preserve" filename="glib-2.0.c" line="40137">Determines if the given @type is definite (ie: not indefinite).

A type is definite if its type string does not contain any indefinite
type characters ('*', '?', or 'r').

A #GVariant instance may not have an indefinite type, so calling
this function on the result of g_variant_get_type() will always
result in %TRUE being returned.  Calling this function on an
indefinite type like %G_VARIANT_TYPE_ARRAY, however, will result in
%FALSE being returned.</doc>
        <source-position filename="gvarianttype.h" line="320" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="40152">%TRUE if @type is definite

Since 2.24</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="40139">a #GVariantType</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="is_definite" c:identifier="g_variant_type_is_definite" gs:dll-name="glib-2.0" gs:managed-name="GetIsDefinite" gs:property-getter-for="IsDefinite" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="40137">Determines if the given @type is definite (ie: not indefinite).

A type is definite if its type string does not contain any indefinite
type characters ('*', '?', or 'r').

A #GVariant instance may not have an indefinite type, so calling
this function on the result of g_variant_get_type() will always
result in %TRUE being returned.  Calling this function on an
indefinite type like %G_VARIANT_TYPE_ARRAY, however, will result in
%FALSE being returned.</doc>
        <source-position filename="gvarianttype.h" line="320" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="40152">%TRUE if @type is definite

Since 2.24</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="40139">a #GVariantType</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="is_dict_entry" gs:dll-name="glib-2.0" gs:managed-name="IsDictEntry">
        <doc xml:space="preserve" filename="glib-2.0.c" line="40158">Determines if the given @type is a dictionary entry type.  This is
true if the type string for @type starts with a '{'.

This function returns %TRUE for any indefinite type for which every
definite subtype is a dictionary entry type --
%G_VARIANT_TYPE_DICT_ENTRY, for example.</doc>
        <source-position filename="gvarianttype.h" line="332" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="40169">%TRUE if @type is a dictionary entry type

Since 2.24</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="40160">a #GVariantType</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="is_dict_entry" c:identifier="g_variant_type_is_dict_entry" gs:dll-name="glib-2.0" gs:managed-name="GetIsDictEntry" gs:property-getter-for="IsDictEntry" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="40158">Determines if the given @type is a dictionary entry type.  This is
true if the type string for @type starts with a '{'.

This function returns %TRUE for any indefinite type for which every
definite subtype is a dictionary entry type --
%G_VARIANT_TYPE_DICT_ENTRY, for example.</doc>
        <source-position filename="gvarianttype.h" line="332" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="40169">%TRUE if @type is a dictionary entry type

Since 2.24</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="40160">a #GVariantType</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="is_maybe" gs:dll-name="glib-2.0" gs:managed-name="IsMaybe">
        <doc xml:space="preserve" filename="glib-2.0.c" line="40175">Determines if the given @type is a maybe type.  This is true if the
type string for @type starts with an 'm'.

This function returns %TRUE for any indefinite type for which every
definite subtype is a maybe type -- %G_VARIANT_TYPE_MAYBE, for
example.</doc>
        <source-position filename="gvarianttype.h" line="326" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="40186">%TRUE if @type is a maybe type

Since 2.24</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="40177">a #GVariantType</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="is_maybe" c:identifier="g_variant_type_is_maybe" gs:dll-name="glib-2.0" gs:managed-name="GetIsMaybe" gs:property-getter-for="IsMaybe" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="40175">Determines if the given @type is a maybe type.  This is true if the
type string for @type starts with an 'm'.

This function returns %TRUE for any indefinite type for which every
definite subtype is a maybe type -- %G_VARIANT_TYPE_MAYBE, for
example.</doc>
        <source-position filename="gvarianttype.h" line="326" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="40186">%TRUE if @type is a maybe type

Since 2.24</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="40177">a #GVariantType</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="is_subtype_of" c:identifier="g_variant_type_is_subtype_of" gs:dll-name="glib-2.0" gs:managed-name="IsSubtypeOf">
        <doc xml:space="preserve" filename="glib-2.0.c" line="40192">Checks if @type is a subtype of @supertype.

This function returns %TRUE if @type is a subtype of @supertype.  All
types are considered to be subtypes of themselves.  Aside from that,
only indefinite types can have subtypes.</doc>
        <source-position filename="gvarianttype.h" line="345" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="40203">%TRUE if @type is a subtype of @supertype

Since 2.24</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="40194">a #GVariantType</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="supertype" transfer-ownership="none" gs:managed-name="supertype" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="40195">a #GVariantType</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="supertype" transfer-ownership="none" gs:managed-name="supertype" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="40195">a #GVariantType</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <gs:managed-property name="is_tuple" gs:dll-name="glib-2.0" gs:managed-name="IsTuple">
        <doc xml:space="preserve" filename="glib-2.0.c" line="40209">Determines if the given @type is a tuple type.  This is true if the
type string for @type starts with a '(' or if @type is
%G_VARIANT_TYPE_TUPLE.

This function returns %TRUE for any indefinite type for which every
definite subtype is a tuple type -- %G_VARIANT_TYPE_TUPLE, for
example.</doc>
        <source-position filename="gvarianttype.h" line="330" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="40221">%TRUE if @type is a tuple type

Since 2.24</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="40211">a #GVariantType</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="is_tuple" c:identifier="g_variant_type_is_tuple" gs:dll-name="glib-2.0" gs:managed-name="GetIsTuple" gs:property-getter-for="IsTuple" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="40209">Determines if the given @type is a tuple type.  This is true if the
type string for @type starts with a '(' or if @type is
%G_VARIANT_TYPE_TUPLE.

This function returns %TRUE for any indefinite type for which every
definite subtype is a tuple type -- %G_VARIANT_TYPE_TUPLE, for
example.</doc>
        <source-position filename="gvarianttype.h" line="330" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="40221">%TRUE if @type is a tuple type

Since 2.24</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="40211">a #GVariantType</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="is_variant" gs:dll-name="glib-2.0" gs:managed-name="IsVariant">
        <doc xml:space="preserve" filename="glib-2.0.c" line="40227">Determines if the given @type is the variant type.</doc>
        <source-position filename="gvarianttype.h" line="334" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="40233">%TRUE if @type is the variant type

Since 2.24</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="40229">a #GVariantType</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="is_variant" c:identifier="g_variant_type_is_variant" gs:dll-name="glib-2.0" gs:managed-name="GetIsVariant" gs:property-getter-for="IsVariant" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="40227">Determines if the given @type is the variant type.</doc>
        <source-position filename="gvarianttype.h" line="334" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="40233">%TRUE if @type is the variant type

Since 2.24</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="40229">a #GVariantType</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="key" c:identifier="g_variant_type_key" gs:dll-name="glib-2.0" gs:managed-name="Key">
        <doc xml:space="preserve" filename="glib-2.0.c" line="40239">Determines the key type of a dictionary entry type.

This function may only be used with a dictionary entry type.  Other
than the additional restriction, this call is equivalent to
g_variant_type_first().</doc>
        <source-position filename="gvarianttype.h" line="358" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="40249">the key type of the dictionary entry

Since 2.24</doc>
          <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="40241">a dictionary entry #GVariantType</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="n_items" c:identifier="g_variant_type_n_items" gs:dll-name="glib-2.0" gs:managed-name="NItems">
        <doc xml:space="preserve" filename="glib-2.0.c" line="40255">Determines the number of items contained in a tuple or
dictionary entry type.

This function may only be used with tuple or dictionary entry types,
but must not be used with the generic tuple type
%G_VARIANT_TYPE_TUPLE.

In the case of a dictionary entry type, this function will always
return 2.</doc>
        <source-position filename="gvarianttype.h" line="356" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="40269">the number of items in @type

Since 2.24</doc>
          <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="40257">a tuple or dictionary entry #GVariantType</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="next" c:identifier="g_variant_type_next" gs:dll-name="glib-2.0" gs:managed-name="Next">
        <doc xml:space="preserve" filename="glib-2.0.c" line="40355">Determines the next item type of a tuple or dictionary entry
type.

@type must be the result of a previous call to
g_variant_type_first() or g_variant_type_next().

If called on the key type of a dictionary entry then this call
returns the value type.  If called on the value type of a dictionary
entry then this call returns %NULL.

For tuples, %NULL is returned when @type is the last item in a tuple.</doc>
        <source-position filename="gvarianttype.h" line="354" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="40371">the next #GVariantType after @type, or %NULL

Since 2.24</doc>
          <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="40357">a #GVariantType from a previous call</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="value" c:identifier="g_variant_type_value" gs:dll-name="glib-2.0" gs:managed-name="Value">
        <doc xml:space="preserve" filename="glib-2.0.c" line="40432">Determines the value type of a dictionary entry type.

This function may only be used with a dictionary entry type.</doc>
        <source-position filename="gvarianttype.h" line="360" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="40440">the value type of the dictionary entry

Since 2.24</doc>
          <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="40434">a dictionary entry #GVariantType</doc>
            <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <function name="checked_" c:identifier="g_variant_type_checked_" gs:dll-name="glib-2.0" gs:managed-name="Checked">
        <source-position filename="gvarianttype.h" line="376" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="VariantType" c:type="const GVariantType*" gs:managed-name="VariantType" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="arg0" transfer-ownership="none" gs:managed-name="arg0" direction="in">
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="arg0" transfer-ownership="none" gs:managed-name="arg0" direction="in">
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="string_get_depth_" c:identifier="g_variant_type_string_get_depth_" gs:dll-name="glib-2.0" gs:managed-name="StringGetDepth">
        <source-position filename="gvarianttype.h" line="378" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <parameter name="type_string" transfer-ownership="none" gs:managed-name="typeString" direction="in">
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="type_string" transfer-ownership="none" gs:managed-name="typeString" direction="in">
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="string_is_valid" c:identifier="g_variant_type_string_is_valid" gs:dll-name="glib-2.0" gs:managed-name="StringIsValid">
        <doc xml:space="preserve" filename="glib-2.0.c" line="40393">Checks if @type_string is a valid GVariant type string.  This call is
equivalent to calling g_variant_type_string_scan() and confirming
that the following character is a nul terminator.</doc>
        <source-position filename="gvarianttype.h" line="296" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="40401">%TRUE if @type_string is exactly one valid type string

Since 2.24</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <parameter name="type_string" transfer-ownership="none" gs:managed-name="typeString" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="40395">a pointer to any string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="type_string" transfer-ownership="none" gs:managed-name="typeString" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="40395">a pointer to any string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="string_scan" c:identifier="g_variant_type_string_scan" version="2.24" gs:dll-name="glib-2.0" gs:managed-name="TryStringScan">
        <doc xml:space="preserve" filename="glib-2.0.c" line="40407">Scan for a single complete and valid GVariant type string in @string.
The memory pointed to by @limit (or bytes beyond it) is never
accessed.

If a valid type string is found, @endptr is updated to point to the
first character past the end of the string that was found and %TRUE
is returned.

If there is no valid type string starting at @string, or if the type
string does not end before @limit then %FALSE is returned.

For the simple case of checking if a string is a valid type string,
see g_variant_type_string_is_valid().</doc>
        <source-position filename="gvarianttype.h" line="298" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="40427">%TRUE if a valid type string was found</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <parameter name="string" transfer-ownership="none" gs:managed-name="@string" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="40409">a pointer to any string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="limit" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="limit" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="40410">the end of @string, or %NULL</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="endptr" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="endptr">
            <doc xml:space="preserve" filename="glib-2.0.c" line="40411">location to store the end pointer, or %NULL</doc>
            <type name="utf8" c:type="const gchar**" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="string" transfer-ownership="none" gs:managed-name="@string" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="40409">a pointer to any string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="limit" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="limit" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="40410">the end of @string, or %NULL</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="endptr" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="endptr">
            <doc xml:space="preserve" filename="glib-2.0.c" line="40411">location to store the end pointer, or %NULL</doc>
            <type name="utf8" c:type="const gchar**" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_variant_type_get_gtype" gs:access-modifiers="private" gs:dll-name="gobject-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </record>
    <docsection name="arcbox" gs:managed-name="Arcbox">
      <doc xml:space="preserve" filename="glib-2.0.c" line="4828">An "atomically reference counted box", or "ArcBox", is an opaque wrapper
data type that is guaranteed to be as big as the size of a given data type,
and which augments the given data type with thread safe reference counting
semantics for its memory management.

ArcBox is useful if you have a plain old data type, like a structure
typically placed on the stack, and you wish to provide additional API
to use it on the heap; or if you want to implement a new type to be
passed around by reference without necessarily implementing copy/free
semantics or your own reference counting.

The typical use is:

|[&lt;!-- language="C" --&gt;
typedef struct {
  char *name;
  char *address;
  char *city;
  char *state;
  int age;
} Person;

Person *
person_new (void)
{
  return g_atomic_rc_box_new0 (Person);
}
]|

Every time you wish to acquire a reference on the memory, you should
call g_atomic_rc_box_acquire(); similarly, when you wish to release a reference
you should call g_atomic_rc_box_release():

|[&lt;!-- language="C" --&gt;
// Add a Person to the Database; the Database acquires ownership
// of the Person instance
void
add_person_to_database (Database *db, Person *p)
{
  db-&gt;persons = g_list_prepend (db-&gt;persons, g_atomic_rc_box_acquire (p));
}

// Removes a Person from the Database; the reference acquired by
// add_person_to_database() is released here
void
remove_person_from_database (Database *db, Person *p)
{
  db-&gt;persons = g_list_remove (db-&gt;persons, p);
  g_atomic_rc_box_release (p);
}
]|

If you have additional memory allocated inside the structure, you can
use g_atomic_rc_box_release_full(), which takes a function pointer, which
will be called if the reference released was the last:

|[&lt;!-- language="C" --&gt;
void
person_clear (Person *p)
{
  g_free (p-&gt;name);
  g_free (p-&gt;address);
  g_free (p-&gt;city);
  g_free (p-&gt;state);
}

void
remove_person_from_database (Database *db, Person *p)
{
  db-&gt;persons = g_list_remove (db-&gt;persons, p);
  g_atomic_rc_box_release_full (p, (GDestroyNotify) person_clear);
}
]|

If you wish to transfer the ownership of a reference counted data
type without increasing the reference count, you can use g_steal_pointer():

|[&lt;!-- language="C" --&gt;
  Person *p = g_atomic_rc_box_new (Person);

  fill_person_details (p);

  add_person_to_database (db, g_steal_pointer (&amp;p));
]|

## Thread safety

The reference counting operations on data allocated using g_atomic_rc_box_alloc(),
g_atomic_rc_box_new(), and g_atomic_rc_box_dup() are guaranteed to be atomic, and thus
can be safely be performed by different threads. It is important to note that
only the reference acquisition and release are atomic; changes to the content
of the data are your responsibility.

## Automatic pointer clean up

If you want to add g_autoptr() support to your plain old data type through
reference counting, you can use the G_DEFINE_AUTOPTR_CLEANUP_FUNC() and
g_atomic_rc_box_release():

|[&lt;!-- language="C" --&gt;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (MyDataStruct, g_atomic_rc_box_release)
]|

If you need to clear the contents of the data, you will need to use an
ancillary function that calls g_rc_box_release_full():

|[&lt;!-- language="C" --&gt;
static void
my_data_struct_release (MyDataStruct *data)
{
  // my_data_struct_clear() is defined elsewhere
  g_atomic_rc_box_release_full (data, (GDestroyNotify) my_data_struct_clear);
}

G_DEFINE_AUTOPTR_CLEANUP_FUNC (MyDataStruct, my_data_struct_release)
]|</doc>
    </docsection>
    <docsection name="arrays" gs:managed-name="Arrays">
      <doc xml:space="preserve" filename="glib-2.0.c" line="4954">Arrays are similar to standard C arrays, except that they grow
automatically as elements are added.

Array elements can be of any size (though all elements of one array
are the same size), and the array can be automatically cleared to
'0's and zero-terminated.

To create a new array use g_array_new().

To add elements to an array with a cost of O(n) at worst, use
g_array_append_val(), g_array_append_vals(), g_array_prepend_val(),
g_array_prepend_vals(), g_array_insert_val() and g_array_insert_vals().

To access an element of an array in O(1) (to read it or to write it),
use g_array_index().

To set the size of an array, use g_array_set_size().

To free an array, use g_array_unref() or g_array_free().

All the sort functions are internally calling a quick-sort (or similar)
function with an average cost of O(n log(n)) and a worst case
cost of O(n^2).

Here is an example that stores integers in a #GArray:
|[&lt;!-- language="C" --&gt;
  GArray *garray;
  gint i;
  // We create a new array to store gint values.
  // We don't want it zero-terminated or cleared to 0's.
  garray = g_array_new (FALSE, FALSE, sizeof (gint));
  for (i = 0; i &lt; 10000; i++)
    g_array_append_val (garray, i);
  for (i = 0; i &lt; 10000; i++)
    if (g_array_index (garray, gint, i) != i)
      g_print ("ERROR: got %d instead of %d\n",
               g_array_index (garray, gint, i), i);
  g_array_free (garray, TRUE);
]|</doc>
    </docsection>
    <docsection name="arrays_byte" gs:managed-name="ArraysByte">
      <doc xml:space="preserve" filename="glib-2.0.c" line="5002">#GByteArray is a mutable array of bytes based on #GArray, to provide arrays
of bytes which grow automatically as elements are added.

To create a new #GByteArray use g_byte_array_new(). To add elements to a
#GByteArray, use g_byte_array_append(), and g_byte_array_prepend().

To set the size of a #GByteArray, use g_byte_array_set_size().

To free a #GByteArray, use g_byte_array_free().

An example for using a #GByteArray:
|[&lt;!-- language="C" --&gt;
  GByteArray *gbarray;
  gint i;

  gbarray = g_byte_array_new ();
  for (i = 0; i &lt; 10000; i++)
    g_byte_array_append (gbarray, (guint8*) "abcd", 4);

  for (i = 0; i &lt; 10000; i++)
    {
      g_assert (gbarray-&gt;data[4*i] == 'a');
      g_assert (gbarray-&gt;data[4*i+1] == 'b');
      g_assert (gbarray-&gt;data[4*i+2] == 'c');
      g_assert (gbarray-&gt;data[4*i+3] == 'd');
    }

  g_byte_array_free (gbarray, TRUE);
]|

See #GBytes if you are interested in an immutable object representing a
sequence of bytes.</doc>
    </docsection>
    <docsection name="arrays_pointer" gs:managed-name="ArraysPointer">
      <doc xml:space="preserve" filename="glib-2.0.c" line="5042">Pointer Arrays are similar to Arrays but are used only for storing
pointers.

If you remove elements from the array, elements at the end of the
array are moved into the space previously occupied by the removed
element. This means that you should not rely on the index of particular
elements remaining the same. You should also be careful when deleting
elements while iterating over the array.

To create a pointer array, use g_ptr_array_new().

To add elements to a pointer array, use g_ptr_array_add().

To remove elements from a pointer array, use g_ptr_array_remove(),
g_ptr_array_remove_index() or g_ptr_array_remove_index_fast().

To access an element of a pointer array, use g_ptr_array_index().

To set the size of a pointer array, use g_ptr_array_set_size().

To free a pointer array, use g_ptr_array_free().

An example using a #GPtrArray:
|[&lt;!-- language="C" --&gt;
  GPtrArray *array;
  gchar *string1 = "one";
  gchar *string2 = "two";
  gchar *string3 = "three";

  array = g_ptr_array_new ();
  g_ptr_array_add (array, (gpointer) string1);
  g_ptr_array_add (array, (gpointer) string2);
  g_ptr_array_add (array, (gpointer) string3);

  if (g_ptr_array_index (array, 0) != (gpointer) string1)
    g_print ("ERROR: got %p instead of %p\n",
             g_ptr_array_index (array, 0), string1);

  g_ptr_array_free (array, TRUE);
]|</doc>
    </docsection>
    <docsection name="async_queues" gs:managed-name="AsyncQueues">
      <doc xml:space="preserve" filename="glib-2.0.c" line="5091">Often you need to communicate between different threads. In general
it's safer not to do this by shared memory, but by explicit message
passing. These messages only make sense asynchronously for
multi-threaded applications though, as a synchronous operation could
as well be done in the same thread.

Asynchronous queues are an exception from most other GLib data
structures, as they can be used simultaneously from multiple threads
without explicit locking and they bring their own builtin reference
counting. This is because the nature of an asynchronous queue is that
it will always be used by at least 2 concurrent threads.

For using an asynchronous queue you first have to create one with
g_async_queue_new(). #GAsyncQueue structs are reference counted,
use g_async_queue_ref() and g_async_queue_unref() to manage your
references.

A thread which wants to send a message to that queue simply calls
g_async_queue_push() to push the message to the queue.

A thread which is expecting messages from an asynchronous queue
simply calls g_async_queue_pop() for that queue. If no message is
available in the queue at that point, the thread is now put to sleep
until a message arrives. The message will be removed from the queue
and returned. The functions g_async_queue_try_pop() and
g_async_queue_timeout_pop() can be used to only check for the presence
of messages or to only wait a certain time for messages respectively.

For almost every function there exist two variants, one that locks
the queue and one that doesn't. That way you can hold the queue lock
(acquire it with g_async_queue_lock() and release it with
g_async_queue_unlock()) over multiple queue accessing instructions.
This can be necessary to ensure the integrity of the queue, but should
only be used when really necessary, as it can make your life harder
if used unwisely. Normally you should only use the locking function
variants (those without the _unlocked suffix).

In many cases, it may be more convenient to use #GThreadPool when
you need to distribute work to a set of worker threads instead of
using #GAsyncQueue manually. #GThreadPool uses a GAsyncQueue
internally.</doc>
    </docsection>
    <docsection name="atomic_operations" gs:managed-name="AtomicOperations">
      <doc xml:space="preserve" filename="glib-2.0.c" line="5141">The following is a collection of compiler macros to provide atomic
access to integer and pointer-sized values.

The macros that have 'int' in the name will operate on pointers to
#gint and #guint.  The macros with 'pointer' in the name will operate
on pointers to any pointer-sized value, including #gsize.  There is
no support for 64bit operations on platforms with 32bit pointers
because it is not generally possible to perform these operations
atomically.

The get, set and exchange operations for integers and pointers
nominally operate on #gint and #gpointer, respectively.  Of the
arithmetic operations, the 'add' operation operates on (and returns)
signed integer values (#gint and #gssize) and the 'and', 'or', and
'xor' operations operate on (and return) unsigned integer values
(#guint and #gsize).

All of the operations act as a full compiler and (where appropriate)
hardware memory barrier.  Acquire and release or producer and
consumer barrier semantics are not available through this API.

It is very important that all accesses to a particular integer or
pointer be performed using only this API and that different sizes of
operation are not mixed or used on overlapping memory regions.  Never
read or assign directly from or to a value -- always use this API.

For simple reference counting purposes you should use
g_atomic_int_inc() and g_atomic_int_dec_and_test().  Other uses that
fall outside of simple reference counting patterns are prone to
subtle bugs and occasionally undefined behaviour.  It is also worth
noting that since all of these operations require global
synchronisation of the entire machine, they can be quite slow.  In
the case of performing multiple atomic operations it can often be
faster to simply acquire a mutex lock around the critical area,
perform the operations normally and then release the lock.</doc>
    </docsection>
    <docsection name="base64" gs:managed-name="Base64">
      <doc xml:space="preserve" filename="glib-2.0.c" line="5185">Base64 is an encoding that allows a sequence of arbitrary bytes to be
encoded as a sequence of printable ASCII characters. For the definition
of Base64, see
[RFC 1421](http://www.ietf.org/rfc/rfc1421.txt)
or
[RFC 2045](http://www.ietf.org/rfc/rfc2045.txt).
Base64 is most commonly used as a MIME transfer encoding
for email.

GLib supports incremental encoding using g_base64_encode_step() and
g_base64_encode_close(). Incremental decoding can be done with
g_base64_decode_step(). To encode or decode data in one go, use
g_base64_encode() or g_base64_decode(). To avoid memory allocation when
decoding, you can use g_base64_decode_inplace().

Support for Base64 encoding has been added in GLib 2.12.</doc>
    </docsection>
    <docsection name="bookmarkfile" gs:managed-name="Bookmarkfile">
      <doc xml:space="preserve" filename="glib-2.0.c" line="5209">GBookmarkFile lets you parse, edit or create files containing bookmarks
to URI, along with some meta-data about the resource pointed by the URI
like its MIME type, the application that is registering the bookmark and
the icon that should be used to represent the bookmark. The data is stored
using the
[Desktop Bookmark Specification](http://www.gnome.org/~ebassi/bookmark-spec).

The syntax of the bookmark files is described in detail inside the
Desktop Bookmark Specification, here is a quick summary: bookmark
files use a sub-class of the XML Bookmark Exchange Language
specification, consisting of valid UTF-8 encoded XML, under the
&lt;xbel&gt; root element; each bookmark is stored inside a
&lt;bookmark&gt; element, using its URI: no relative paths can
be used inside a bookmark file. The bookmark may have a user defined
title and description, to be used instead of the URI. Under the
&lt;metadata&gt; element, with its owner attribute set to
`http://freedesktop.org`, is stored the meta-data about a resource
pointed by its URI. The meta-data consists of the resource's MIME
type; the applications that have registered a bookmark; the groups
to which a bookmark belongs to; a visibility flag, used to set the
bookmark as "private" to the applications and groups that has it
registered; the URI and MIME type of an icon, to be used when
displaying the bookmark inside a GUI.

Here is an example of a bookmark file:
[bookmarks.xbel](https://git.gnome.org/browse/glib/tree/glib/tests/bookmarks.xbel)

A bookmark file might contain more than one bookmark; each bookmark
is accessed through its URI.

The important caveat of bookmark files is that when you add a new
bookmark you must also add the application that is registering it, using
g_bookmark_file_add_application() or g_bookmark_file_set_application_info().
If a bookmark has no applications then it won't be dumped when creating
the on disk representation, using g_bookmark_file_to_data() or
g_bookmark_file_to_file().

The #GBookmarkFile parser was added in GLib 2.12.</doc>
    </docsection>
    <docsection name="byte_order" gs:managed-name="ByteOrder">
      <doc xml:space="preserve" filename="glib-2.0.c" line="5255">These macros provide a portable way to determine the host byte order
and to convert values between different byte orders.

The byte order is the order in which bytes are stored to create larger
data types such as the #gint and #glong values.
The host byte order is the byte order used on the current machine.

Some processors store the most significant bytes (i.e. the bytes that
hold the largest part of the value) first. These are known as big-endian
processors. Other processors (notably the x86 family) store the most
significant byte last. These are known as little-endian processors.

Finally, to complicate matters, some other processors store the bytes in
a rather curious order known as PDP-endian. For a 4-byte word, the 3rd
most significant byte is stored first, then the 4th, then the 1st and
finally the 2nd.

Obviously there is a problem when these different processors communicate
with each other, for example over networks or by using binary file formats.
This is where these macros come in. They are typically used to convert
values into a byte order which has been agreed on for use when
communicating between different processors. The Internet uses what is
known as 'network byte order' as the standard byte order (which is in
fact the big-endian byte order).

Note that the byte order conversion macros may evaluate their arguments
multiple times, thus you should not use them with arguments which have
side-effects.</doc>
    </docsection>
    <docsection name="checkedmath" gs:managed-name="Checkedmath">
      <doc xml:space="preserve" filename="glib-2.0.c" line="5291">GLib offers a set of macros for doing additions and multiplications
of unsigned integers, with checks for overflows.

The helpers all have three arguments.  A pointer to the destination
is always the first argument and the operands to the operation are
the other two.

Following standard GLib convention, the helpers return %TRUE in case
of success (ie: no overflow).

The helpers may be macros, normal functions or inlines.  They may be
implemented with inline assembly or compiler intrinsics where
available.</doc>
    </docsection>
    <docsection name="checksum" gs:managed-name="Checksum">
      <doc xml:space="preserve" filename="glib-2.0.c" line="5314">GLib provides a generic API for computing checksums (or "digests")
for a sequence of arbitrary bytes, using various hashing algorithms
like MD5, SHA-1 and SHA-256. Checksums are commonly used in various
environments and specifications.

GLib supports incremental checksums using the GChecksum data
structure, by calling g_checksum_update() as long as there's data
available and then using g_checksum_get_string() or
g_checksum_get_digest() to compute the checksum and return it either
as a string in hexadecimal form, or as a raw sequence of bytes. To
compute the checksum for binary blobs and NUL-terminated strings in
one go, use the convenience functions g_compute_checksum_for_data()
and g_compute_checksum_for_string(), respectively.

Support for checksums has been added in GLib 2.16</doc>
    </docsection>
    <docsection name="conversions" gs:managed-name="Conversions">
      <doc xml:space="preserve" filename="glib-2.0.c" line="5337">The g_convert() family of function wraps the functionality of iconv().
In addition to pure character set conversions, GLib has functions to
deal with the extra complications of encodings for file names.

## File Name Encodings

Historically, UNIX has not had a defined encoding for file names:
a file name is valid as long as it does not have path separators
in it ("/"). However, displaying file names may require conversion:
from the character set in which they were created, to the character
set in which the application operates. Consider the Spanish file name
"Presentación.sxi". If the application which created it uses
ISO-8859-1 for its encoding,
|[
Character:  P  r  e  s  e  n  t  a  c  i  ó  n  .  s  x  i
Hex code:   50 72 65 73 65 6e 74 61 63 69 f3 6e 2e 73 78 69
]|
However, if the application use UTF-8, the actual file name on
disk would look like this:
|[
Character:  P  r  e  s  e  n  t  a  c  i  ó     n  .  s  x  i
Hex code:   50 72 65 73 65 6e 74 61 63 69 c3 b3 6e 2e 73 78 69
]|
Glib uses UTF-8 for its strings, and GUI toolkits like GTK+ that use
GLib do the same thing. If you get a file name from the file system,
for example, from readdir() or from g_dir_read_name(), and you wish
to display the file name to the user, you  will need to convert it
into UTF-8. The opposite case is when the user types the name of a
file they wish to save: the toolkit will give you that string in
UTF-8 encoding, and you will need to convert it to the character
set used for file names before you can create the file with open()
or fopen().

By default, GLib assumes that file names on disk are in UTF-8
encoding. This is a valid assumption for file systems which
were created relatively recently: most applications use UTF-8
encoding for their strings, and that is also what they use for
the file names they create. However, older file systems may
still contain file names created in "older" encodings, such as
ISO-8859-1. In this case, for compatibility reasons, you may want
to instruct GLib to use that particular encoding for file names
rather than UTF-8. You can do this by specifying the encoding for
file names in the [`G_FILENAME_ENCODING`][G_FILENAME_ENCODING]
environment variable. For example, if your installation uses
ISO-8859-1 for file names, you can put this in your `~/.profile`:
|[
export G_FILENAME_ENCODING=ISO-8859-1
]|
GLib provides the functions g_filename_to_utf8() and
g_filename_from_utf8() to perform the necessary conversions.
These functions convert file names from the encoding specified
in `G_FILENAME_ENCODING` to UTF-8 and vice-versa. This
[diagram][file-name-encodings-diagram] illustrates how
these functions are used to convert between UTF-8 and the
encoding for file names in the file system.

## Conversion between file name encodings # {#file-name-encodings-diagram)

![](file-name-encodings.png)

## Checklist for Application Writers

This section is a practical summary of the detailed
things to do to make sure your applications process file
name encodings correctly.

1. If you get a file name from the file system from a function
   such as readdir() or gtk_file_chooser_get_filename(), you do
   not need to do any conversion to pass that file name to
   functions like open(), rename(), or fopen() -- those are "raw"
   file names which the file system understands.

2. If you need to display a file name, convert it to UTF-8 first
   by using g_filename_to_utf8(). If conversion fails, display a
   string like "Unknown file name". Do not convert this string back
   into the encoding used for file names if you wish to pass it to
   the file system; use the original file name instead.

   For example, the document window of a word processor could display
   "Unknown file name" in its title bar but still let the user save
   the file, as it would keep the raw file name internally. This
   can happen if the user has not set the `G_FILENAME_ENCODING`
   environment variable even though he has files whose names are
   not encoded in UTF-8.

3. If your user interface lets the user type a file name for saving
   or renaming, convert it to the encoding used for file names in
   the file system by using g_filename_from_utf8(). Pass the converted
   file name to functions like fopen(). If conversion fails, ask the
   user to enter a different file name. This can happen if the user
   types Japanese characters when `G_FILENAME_ENCODING` is set to
   `ISO-8859-1`, for example.</doc>
    </docsection>
    <docsection name="datalist" gs:managed-name="Datalist">
      <doc xml:space="preserve" filename="glib-2.0.c" line="5437">Keyed data lists provide lists of arbitrary data elements which can
be accessed either with a string or with a #GQuark corresponding to
the string.

The #GQuark methods are quicker, since the strings have to be
converted to #GQuarks anyway.

Data lists are used for associating arbitrary data with #GObjects,
using g_object_set_data() and related functions.

To create a datalist, use g_datalist_init().

To add data elements to a datalist use g_datalist_id_set_data(),
g_datalist_id_set_data_full(), g_datalist_set_data() and
g_datalist_set_data_full().

To get data elements from a datalist use g_datalist_id_get_data()
and g_datalist_get_data().

To iterate over all data elements in a datalist use
g_datalist_foreach() (not thread-safe).

To remove data elements from a datalist use
g_datalist_id_remove_data() and g_datalist_remove_data().

To remove all data elements from a datalist, use g_datalist_clear().</doc>
    </docsection>
    <docsection name="datasets" gs:managed-name="Datasets">
      <doc xml:space="preserve" filename="glib-2.0.c" line="5472">Datasets associate groups of data elements with particular memory
locations. These are useful if you need to associate data with a
structure returned from an external library. Since you cannot modify
the structure, you use its location in memory as the key into a
dataset, where you can associate any number of data elements with it.

There are two forms of most of the dataset functions. The first form
uses strings to identify the data elements associated with a
location. The second form uses #GQuark identifiers, which are
created with a call to g_quark_from_string() or
g_quark_from_static_string(). The second form is quicker, since it
does not require looking up the string in the hash table of #GQuark
identifiers.

There is no function to create a dataset. It is automatically
created as soon as you add elements to it.

To add data elements to a dataset use g_dataset_id_set_data(),
g_dataset_id_set_data_full(), g_dataset_set_data() and
g_dataset_set_data_full().

To get data elements from a dataset use g_dataset_id_get_data() and
g_dataset_get_data().

To iterate over all data elements in a dataset use
g_dataset_foreach() (not thread-safe).

To remove data elements from a dataset use
g_dataset_id_remove_data() and g_dataset_remove_data().

To destroy a dataset, use g_dataset_destroy().</doc>
    </docsection>
    <docsection name="date" gs:managed-name="Date">
      <doc xml:space="preserve" filename="glib-2.0.c" line="5512">The #GDate data structure represents a day between January 1, Year 1,
and sometime a few thousand years in the future (right now it will go
to the year 65535 or so, but g_date_set_parse() only parses up to the
year 8000 or so - just count on "a few thousand"). #GDate is meant to
represent everyday dates, not astronomical dates or historical dates
or ISO timestamps or the like. It extrapolates the current Gregorian
calendar forward and backward in time; there is no attempt to change
the calendar to match time periods or locations. #GDate does not store
time information; it represents a day.

The #GDate implementation has several nice features; it is only a
64-bit struct, so storing large numbers of dates is very efficient. It
can keep both a Julian and day-month-year representation of the date,
since some calculations are much easier with one representation or the
other. A Julian representation is simply a count of days since some
fixed day in the past; for #GDate the fixed day is January 1, 1 AD.
("Julian" dates in the #GDate API aren't really Julian dates in the
technical sense; technically, Julian dates count from the start of the
Julian period, Jan 1, 4713 BC).

#GDate is simple to use. First you need a "blank" date; you can get a
dynamically allocated date from g_date_new(), or you can declare an
automatic variable or array and initialize it by
calling g_date_clear(). A cleared date is safe; it's safe to call
g_date_set_dmy() and the other mutator functions to initialize the
value of a cleared date. However, a cleared date is initially
invalid, meaning that it doesn't represent a day that exists.
It is undefined to call any of the date calculation routines on an
invalid date. If you obtain a date from a user or other
unpredictable source, you should check its validity with the
g_date_valid() predicate. g_date_valid() is also used to check for
errors with g_date_set_parse() and other functions that can
fail. Dates can be invalidated by calling g_date_clear() again.

It is very important to use the API to access the #GDate
struct. Often only the day-month-year or only the Julian
representation is valid. Sometimes neither is valid. Use the API.

GLib also features #GDateTime which represents a precise time.</doc>
    </docsection>
    <docsection name="date-time" gs:managed-name="DateTime">
      <doc xml:space="preserve" filename="glib-2.0.c" line="5559">#GDateTime is a structure that combines a Gregorian date and time
into a single structure.  It provides many conversion and methods to
manipulate dates and times.  Time precision is provided down to
microseconds and the time can range (proleptically) from 0001-01-01
00:00:00 to 9999-12-31 23:59:59.999999.  #GDateTime follows POSIX
time in the sense that it is oblivious to leap seconds.

#GDateTime is an immutable object; once it has been created it cannot
be modified further.  All modifiers will create a new #GDateTime.
Nearly all such functions can fail due to the date or time going out
of range, in which case %NULL will be returned.

#GDateTime is reference counted: the reference count is increased by calling
g_date_time_ref() and decreased by calling g_date_time_unref(). When the
reference count drops to 0, the resources allocated by the #GDateTime
structure are released.

Many parts of the API may produce non-obvious results.  As an
example, adding two months to January 31st will yield March 31st
whereas adding one month and then one month again will yield either
March 28th or March 29th.  Also note that adding 24 hours is not
always the same as adding one day (since days containing daylight
savings time transitions are either 23 or 25 hours in length).

#GDateTime is available since GLib 2.26.</doc>
    </docsection>
    <docsection name="error_reporting" gs:managed-name="ErrorReporting">
      <doc xml:space="preserve" filename="glib-2.0.c" line="5593">GLib provides a standard method of reporting errors from a called
function to the calling code. (This is the same problem solved by
exceptions in other languages.) It's important to understand that
this method is both a data type (the #GError struct) and a [set of
rules][gerror-rules]. If you use #GError incorrectly, then your code will not
properly interoperate with other code that uses #GError, and users
of your API will probably get confused. In most cases, [using #GError is
preferred over numeric error codes][gerror-comparison], but there are
situations where numeric error codes are useful for performance.

First and foremost: #GError should only be used to report recoverable
runtime errors, never to report programming errors. If the programmer
has screwed up, then you should use g_warning(), g_return_if_fail(),
g_assert(), g_error(), or some similar facility. (Incidentally,
remember that the g_error() function should only be used for
programming errors, it should not be used to print any error
reportable via #GError.)

Examples of recoverable runtime errors are "file not found" or
"failed to parse input." Examples of programming errors are "NULL
passed to strcmp()" or "attempted to free the same pointer twice."
These two kinds of errors are fundamentally different: runtime errors
should be handled or reported to the user, programming errors should
be eliminated by fixing the bug in the program. This is why most
functions in GLib and GTK+ do not use the #GError facility.

Functions that can fail take a return location for a #GError as their
last argument. On error, a new #GError instance will be allocated and
returned to the caller via this argument. For example:
|[&lt;!-- language="C" --&gt;
gboolean g_file_get_contents (const gchar  *filename,
                              gchar       **contents,
                              gsize        *length,
                              GError      **error);
]|
If you pass a non-%NULL value for the `error` argument, it should
point to a location where an error can be placed. For example:
|[&lt;!-- language="C" --&gt;
gchar *contents;
GError *err = NULL;

g_file_get_contents ("foo.txt", &amp;contents, NULL, &amp;err);
g_assert ((contents == NULL &amp;&amp; err != NULL) || (contents != NULL &amp;&amp; err == NULL));
if (err != NULL)
  {
    // Report error to user, and free error
    g_assert (contents == NULL);
    fprintf (stderr, "Unable to read file: %s\n", err-&gt;message);
    g_error_free (err);
  }
else
  {
    // Use file contents
    g_assert (contents != NULL);
  }
]|
Note that `err != NULL` in this example is a reliable indicator
of whether g_file_get_contents() failed. Additionally,
g_file_get_contents() returns a boolean which
indicates whether it was successful.

Because g_file_get_contents() returns %FALSE on failure, if you
are only interested in whether it failed and don't need to display
an error message, you can pass %NULL for the @error argument:
|[&lt;!-- language="C" --&gt;
if (g_file_get_contents ("foo.txt", &amp;contents, NULL, NULL)) // ignore errors
  // no error occurred
  ;
else
  // error
  ;
]|

The #GError object contains three fields: @domain indicates the module
the error-reporting function is located in, @code indicates the specific
error that occurred, and @message is a user-readable error message with
as many details as possible. Several functions are provided to deal
with an error received from a called function: g_error_matches()
returns %TRUE if the error matches a given domain and code,
g_propagate_error() copies an error into an error location (so the
calling function will receive it), and g_clear_error() clears an
error location by freeing the error and resetting the location to
%NULL. To display an error to the user, simply display the @message,
perhaps along with additional context known only to the calling
function (the file being opened, or whatever - though in the
g_file_get_contents() case, the @message already contains a filename).

Note, however, that many error messages are too technical to display to the
user in an application, so prefer to use g_error_matches() to categorize errors
from called functions, and build an appropriate error message for the context
within your application. Error messages from a #GError are more appropriate
to be printed in system logs or on the command line. They are typically
translated.

When implementing a function that can report errors, the basic
tool is g_set_error(). Typically, if a fatal error occurs you
want to g_set_error(), then return immediately. g_set_error()
does nothing if the error location passed to it is %NULL.
Here's an example:
|[&lt;!-- language="C" --&gt;
gint
foo_open_file (GError **error)
{
  gint fd;
  int saved_errno;

  g_return_val_if_fail (error == NULL || *error == NULL, -1);

  fd = open ("file.txt", O_RDONLY);
  saved_errno = errno;

  if (fd &lt; 0)
    {
      g_set_error (error,
                   FOO_ERROR,                 // error domain
                   FOO_ERROR_BLAH,            // error code
                   "Failed to open file: %s", // error message format string
                   g_strerror (saved_errno));
      return -1;
    }
  else
    return fd;
}
]|

Things are somewhat more complicated if you yourself call another
function that can report a #GError. If the sub-function indicates
fatal errors in some way other than reporting a #GError, such as
by returning %TRUE on success, you can simply do the following:
|[&lt;!-- language="C" --&gt;
gboolean
my_function_that_can_fail (GError **err)
{
  g_return_val_if_fail (err == NULL || *err == NULL, FALSE);

  if (!sub_function_that_can_fail (err))
    {
      // assert that error was set by the sub-function
      g_assert (err == NULL || *err != NULL);
      return FALSE;
    }

  // otherwise continue, no error occurred
  g_assert (err == NULL || *err == NULL);
}
]|

If the sub-function does not indicate errors other than by
reporting a #GError (or if its return value does not reliably indicate
errors) you need to create a temporary #GError
since the passed-in one may be %NULL. g_propagate_error() is
intended for use in this case.
|[&lt;!-- language="C" --&gt;
gboolean
my_function_that_can_fail (GError **err)
{
  GError *tmp_error;

  g_return_val_if_fail (err == NULL || *err == NULL, FALSE);

  tmp_error = NULL;
  sub_function_that_can_fail (&amp;tmp_error);

  if (tmp_error != NULL)
    {
      // store tmp_error in err, if err != NULL,
      // otherwise call g_error_free() on tmp_error
      g_propagate_error (err, tmp_error);
      return FALSE;
    }

  // otherwise continue, no error occurred
}
]|

Error pileups are always a bug. For example, this code is incorrect:
|[&lt;!-- language="C" --&gt;
gboolean
my_function_that_can_fail (GError **err)
{
  GError *tmp_error;

  g_return_val_if_fail (err == NULL || *err == NULL, FALSE);

  tmp_error = NULL;
  sub_function_that_can_fail (&amp;tmp_error);
  other_function_that_can_fail (&amp;tmp_error);

  if (tmp_error != NULL)
    {
      g_propagate_error (err, tmp_error);
      return FALSE;
    }
}
]|
@tmp_error should be checked immediately after sub_function_that_can_fail(),
and either cleared or propagated upward. The rule is: after each error,
you must either handle the error, or return it to the calling function.

Note that passing %NULL for the error location is the equivalent
of handling an error by always doing nothing about it. So the
following code is fine, assuming errors in sub_function_that_can_fail()
are not fatal to my_function_that_can_fail():
|[&lt;!-- language="C" --&gt;
gboolean
my_function_that_can_fail (GError **err)
{
  GError *tmp_error;

  g_return_val_if_fail (err == NULL || *err == NULL, FALSE);

  sub_function_that_can_fail (NULL); // ignore errors

  tmp_error = NULL;
  other_function_that_can_fail (&amp;tmp_error);

  if (tmp_error != NULL)
    {
      g_propagate_error (err, tmp_error);
      return FALSE;
    }
}
]|

Note that passing %NULL for the error location ignores errors;
it's equivalent to
`try { sub_function_that_can_fail (); } catch (...) {}`
in C++. It does not mean to leave errors unhandled; it means
to handle them by doing nothing.

Error domains and codes are conventionally named as follows:

- The error domain is called &lt;NAMESPACE&gt;_&lt;MODULE&gt;_ERROR,
  for example %G_SPAWN_ERROR or %G_THREAD_ERROR:
  |[&lt;!-- language="C" --&gt;
  #define G_SPAWN_ERROR g_spawn_error_quark ()

  G_DEFINE_QUARK (g-spawn-error-quark, g_spawn_error)
  ]|

- The quark function for the error domain is called
  &lt;namespace&gt;_&lt;module&gt;_error_quark,
  for example g_spawn_error_quark() or g_thread_error_quark().

- The error codes are in an enumeration called
  &lt;Namespace&gt;&lt;Module&gt;Error;
  for example, #GThreadError or #GSpawnError.

- Members of the error code enumeration are called
  &lt;NAMESPACE&gt;_&lt;MODULE&gt;_ERROR_&lt;CODE&gt;,
  for example %G_SPAWN_ERROR_FORK or %G_THREAD_ERROR_AGAIN.

- If there's a "generic" or "unknown" error code for unrecoverable
  errors it doesn't make sense to distinguish with specific codes,
  it should be called &lt;NAMESPACE&gt;_&lt;MODULE&gt;_ERROR_FAILED,
  for example %G_SPAWN_ERROR_FAILED. In the case of error code
  enumerations that may be extended in future releases, you should
  generally not handle this error code explicitly, but should
  instead treat any unrecognized error code as equivalent to
  FAILED.

## Comparison of #GError and traditional error handling # {#gerror-comparison}

#GError has several advantages over traditional numeric error codes:
importantly, tools like
[gobject-introspection](https://developer.gnome.org/gi/stable/) understand
#GErrors and convert them to exceptions in bindings; the message includes
more information than just a code; and use of a domain helps prevent
misinterpretation of error codes.

#GError has disadvantages though: it requires a memory allocation, and
formatting the error message string has a performance overhead. This makes it
unsuitable for use in retry loops where errors are a common case, rather than
being unusual. For example, using %G_IO_ERROR_WOULD_BLOCK means hitting these
overheads in the normal control flow. String formatting overhead can be
eliminated by using g_set_error_literal() in some cases.

These performance issues can be compounded if a function wraps the #GErrors
returned by the functions it calls: this multiplies the number of allocations
and string formatting operations. This can be partially mitigated by using
g_prefix_error().

## Rules for use of #GError # {#gerror-rules}

Summary of rules for use of #GError:

- Do not report programming errors via #GError.

- The last argument of a function that returns an error should
  be a location where a #GError can be placed (i.e. "#GError** error").
  If #GError is used with varargs, the #GError** should be the last
  argument before the "...".

- The caller may pass %NULL for the #GError** if they are not interested
  in details of the exact error that occurred.

- If %NULL is passed for the #GError** argument, then errors should
  not be returned to the caller, but your function should still
  abort and return if an error occurs. That is, control flow should
  not be affected by whether the caller wants to get a #GError.

- If a #GError is reported, then your function by definition had a
  fatal failure and did not complete whatever it was supposed to do.
  If the failure was not fatal, then you handled it and you should not
  report it. If it was fatal, then you must report it and discontinue
  whatever you were doing immediately.

- If a #GError is reported, out parameters are not guaranteed to
  be set to any defined value.

- A #GError* must be initialized to %NULL before passing its address
  to a function that can report errors.

- "Piling up" errors is always a bug. That is, if you assign a
  new #GError to a #GError* that is non-%NULL, thus overwriting
  the previous error, it indicates that you should have aborted
  the operation instead of continuing. If you were able to continue,
  you should have cleared the previous error with g_clear_error().
  g_set_error() will complain if you pile up errors.

- By convention, if you return a boolean value indicating success
  then %TRUE means success and %FALSE means failure. Avoid creating
  functions which have a boolean return value and a GError parameter,
  but where the boolean does something other than signal whether the
  GError is set.  Among other problems, it requires C callers to allocate
  a temporary error.  Instead, provide a "gboolean *" out parameter.
  There are functions in GLib itself such as g_key_file_has_key() that
  are deprecated because of this. If %FALSE is returned, the error must
  be set to a non-%NULL value.  One exception to this is that in situations
  that are already considered to be undefined behaviour (such as when a
  g_return_val_if_fail() check fails), the error need not be set.
  Instead of checking separately whether the error is set, callers
  should ensure that they do not provoke undefined behaviour, then
  assume that the error will be set on failure.

- A %NULL return value is also frequently used to mean that an error
  occurred. You should make clear in your documentation whether %NULL
  is a valid return value in non-error cases; if %NULL is a valid value,
  then users must check whether an error was returned to see if the
  function succeeded.

- When implementing a function that can report errors, you may want
  to add a check at the top of your function that the error return
  location is either %NULL or contains a %NULL error (e.g.
  `g_return_if_fail (error == NULL || *error == NULL);`).</doc>
    </docsection>
    <docsection name="fileutils" gs:managed-name="Fileutils">
      <doc xml:space="preserve" filename="glib-2.0.c" line="5946">Do not use these APIs unless you are porting a POSIX application to Windows.
A more high-level file access API is provided as GIO — see the documentation
for #GFile.

There is a group of functions which wrap the common POSIX functions
dealing with filenames (g_open(), g_rename(), g_mkdir(), g_stat(),
g_unlink(), g_remove(), g_fopen(), g_freopen()). The point of these
wrappers is to make it possible to handle file names with any Unicode
characters in them on Windows without having to use ifdefs and the
wide character API in the application code.

On some Unix systems, these APIs may be defined as identical to their POSIX
counterparts. For this reason, you must check for and include the necessary
header files (such as `fcntl.h`) before using functions like g_creat(). You
must also define the relevant feature test macros.

The pathname argument should be in the GLib file name encoding.
On POSIX this is the actual on-disk encoding which might correspond
to the locale settings of the process (or the `G_FILENAME_ENCODING`
environment variable), or not.

On Windows the GLib file name encoding is UTF-8. Note that the
Microsoft C library does not use UTF-8, but has separate APIs for
current system code page and wide characters (UTF-16). The GLib
wrappers call the wide character API if present (on modern Windows
systems), otherwise convert to/from the system code page.

Another group of functions allows to open and read directories
in the GLib file name encoding. These are g_dir_open(),
g_dir_read_name(), g_dir_rewind(), g_dir_close().</doc>
    </docsection>
    <docsection name="ghostutils" gs:managed-name="Ghostutils">
      <doc xml:space="preserve" filename="glib-2.0.c" line="5984">Functions for manipulating internet hostnames; in particular, for
converting between Unicode and ASCII-encoded forms of
Internationalized Domain Names (IDNs).

The
[Internationalized Domain Names for Applications (IDNA)](http://www.ietf.org/rfc/rfc3490.txt)
standards allow for the use
of Unicode domain names in applications, while providing
backward-compatibility with the old ASCII-only DNS, by defining an
ASCII-Compatible Encoding of any given Unicode name, which can be
used with non-IDN-aware applications and protocols. (For example,
"Παν語.org" maps to "xn--4wa8awb4637h.org".)</doc>
    </docsection>
    <docsection name="gunix" gs:managed-name="Gunix">
      <doc xml:space="preserve" filename="glib-2.0.c" line="6077">Most of GLib is intended to be portable; in contrast, this set of
functions is designed for programs which explicitly target UNIX,
or are using it to build higher level abstractions which would be
conditionally compiled if the platform matches G_OS_UNIX.

To use these functions, you must explicitly include the
"glib-unix.h" header.</doc>
    </docsection>
    <docsection name="hash_tables" gs:managed-name="HashTables">
      <doc xml:space="preserve" filename="glib-2.0.c" line="6617">A #GHashTable provides associations between keys and values which is
optimized so that given a key, the associated value can be found,
inserted or removed in amortized O(1). All operations going through
each element take O(n) time (list all keys/values, table resize, etc.).

Note that neither keys nor values are copied when inserted into the
#GHashTable, so they must exist for the lifetime of the #GHashTable.
This means that the use of static strings is OK, but temporary
strings (i.e. those created in buffers and those returned by GTK
widgets) should be copied with g_strdup() before being inserted.

If keys or values are dynamically allocated, you must be careful to
ensure that they are freed when they are removed from the
#GHashTable, and also when they are overwritten by new insertions
into the #GHashTable. It is also not advisable to mix static strings
and dynamically-allocated strings in a #GHashTable, because it then
becomes difficult to determine whether the string should be freed.

To create a #GHashTable, use g_hash_table_new().

To insert a key and value into a #GHashTable, use
g_hash_table_insert().

To look up a value corresponding to a given key, use
g_hash_table_lookup() and g_hash_table_lookup_extended().

g_hash_table_lookup_extended() can also be used to simply
check if a key is present in the hash table.

To remove a key and value, use g_hash_table_remove().

To call a function for each key and value pair use
g_hash_table_foreach() or use an iterator to iterate over the
key/value pairs in the hash table, see #GHashTableIter. The iteration order
of a hash table is not defined, and you must not rely on iterating over
keys/values in the same order as they were inserted.

To destroy a #GHashTable use g_hash_table_destroy().

A common use-case for hash tables is to store information about a
set of keys, without associating any particular value with each
key. GHashTable optimizes one way of doing so: If you store only
key-value pairs where key == value, then GHashTable does not
allocate memory to store the values, which can be a considerable
space saving, if your set is large. The functions
g_hash_table_add() and g_hash_table_contains() are designed to be
used when using #GHashTable this way.

#GHashTable is not designed to be statically initialised with keys and
values known at compile time. To build a static hash table, use a tool such
as [gperf](https://www.gnu.org/software/gperf/).</doc>
    </docsection>
    <docsection name="hmac" gs:managed-name="Hmac">
      <doc xml:space="preserve" filename="glib-2.0.c" line="6677">HMACs should be used when producing a cookie or hash based on data
and a key. Simple mechanisms for using SHA1 and other algorithms to
digest a key and data together are vulnerable to various security
issues.
[HMAC](http://en.wikipedia.org/wiki/HMAC)
uses algorithms like SHA1 in a secure way to produce a digest of a
key and data.

Both the key and data are arbitrary byte arrays of bytes or characters.

Support for HMAC Digests has been added in GLib 2.30, and support for SHA-512
in GLib 2.42. Support for SHA-384 was added in GLib 2.52.</doc>
    </docsection>
    <docsection name="hooks" gs:managed-name="Hooks">
      <doc xml:space="preserve" filename="glib-2.0.c" line="6697">The #GHookList, #GHook and their related functions provide support for
lists of hook functions. Functions can be added and removed from the lists,
and the list of hook functions can be invoked.</doc>
    </docsection>
    <docsection name="i18n" gs:managed-name="I18n">
      <doc xml:space="preserve" filename="glib-2.0.c" line="6708">GLib doesn't force any particular localization method upon its users.
But since GLib itself is localized using the gettext() mechanism, it seems
natural to offer the de-facto standard gettext() support macros in an
easy-to-use form.

In order to use these macros in an application, you must include
`&lt;glib/gi18n.h&gt;`. For use in a library, you must include
`&lt;glib/gi18n-lib.h&gt;`
after defining the %GETTEXT_PACKAGE macro suitably for your library:
|[&lt;!-- language="C" --&gt;
#define GETTEXT_PACKAGE "gtk20"
#include &lt;glib/gi18n-lib.h&gt;
]|
For an application, note that you also have to call bindtextdomain(),
bind_textdomain_codeset(), textdomain() and setlocale() early on in your
main() to make gettext() work. For example:
|[&lt;!-- language="C" --&gt;
#include &lt;glib/gi18n.h&gt;
#include &lt;locale.h&gt;

int
main (int argc, char **argv)
{
  setlocale (LC_ALL, "");
  bindtextdomain (GETTEXT_PACKAGE, DATADIR "/locale");
  bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
  textdomain (GETTEXT_PACKAGE);

  // Rest of your application.
}
]|
where `DATADIR` is as typically provided by automake or Meson.

For a library, you only have to call bindtextdomain() and
bind_textdomain_codeset() in your initialization function. If your library
doesn't have an initialization function, you can call the functions before
the first translated message.

The
[gettext manual](http://www.gnu.org/software/gettext/manual/gettext.html#Maintainers)
covers details of how to integrate gettext into a project’s build system and
workflow.</doc>
    </docsection>
    <docsection name="iochannels" gs:managed-name="Iochannels">
      <doc xml:space="preserve" filename="glib-2.0.c" line="6759">The #GIOChannel data type aims to provide a portable method for
using file descriptors, pipes, and sockets, and integrating them
into the [main event loop][glib-The-Main-Event-Loop]. Currently,
full support is available on UNIX platforms, support for Windows
is only partially complete.

To create a new #GIOChannel on UNIX systems use
g_io_channel_unix_new(). This works for plain file descriptors,
pipes and sockets. Alternatively, a channel can be created for a
file in a system independent manner using g_io_channel_new_file().

Once a #GIOChannel has been created, it can be used in a generic
manner with the functions g_io_channel_read_chars(),
g_io_channel_write_chars(), g_io_channel_seek_position(), and
g_io_channel_shutdown().

To add a #GIOChannel to the [main event loop][glib-The-Main-Event-Loop],
use g_io_add_watch() or g_io_add_watch_full(). Here you specify which
events you are interested in on the #GIOChannel, and provide a
function to be called whenever these events occur.

#GIOChannel instances are created with an initial reference count of 1.
g_io_channel_ref() and g_io_channel_unref() can be used to
increment or decrement the reference count respectively. When the
reference count falls to 0, the #GIOChannel is freed. (Though it
isn't closed automatically, unless it was created using
g_io_channel_new_file().) Using g_io_add_watch() or
g_io_add_watch_full() increments a channel's reference count.

The new functions g_io_channel_read_chars(),
g_io_channel_read_line(), g_io_channel_read_line_string(),
g_io_channel_read_to_end(), g_io_channel_write_chars(),
g_io_channel_seek_position(), and g_io_channel_flush() should not be
mixed with the deprecated functions g_io_channel_read(),
g_io_channel_write(), and g_io_channel_seek() on the same channel.</doc>
    </docsection>
    <docsection name="keyfile" gs:managed-name="Keyfile">
      <doc xml:space="preserve" filename="glib-2.0.c" line="6804">#GKeyFile lets you parse, edit or create files containing groups of
key-value pairs, which we call "key files" for lack of a better name.
Several freedesktop.org specifications use key files now, e.g the
[Desktop Entry Specification](http://freedesktop.org/Standards/desktop-entry-spec)
and the
[Icon Theme Specification](http://freedesktop.org/Standards/icon-theme-spec).

The syntax of key files is described in detail in the
[Desktop Entry Specification](http://freedesktop.org/Standards/desktop-entry-spec),
here is a quick summary: Key files
consists of groups of key-value pairs, interspersed with comments.

|[
# this is just an example
# there can be comments before the first group

[First Group]

Name=Key File Example\tthis value shows\nescaping

# localized strings are stored in multiple key-value pairs
Welcome=Hello
Welcome[de]=Hallo
Welcome[fr_FR]=Bonjour
Welcome[it]=Ciao
Welcome[be@latin]=Hello

[Another Group]

Numbers=2;20;-200;0

Booleans=true;false;true;true
]|

Lines beginning with a '#' and blank lines are considered comments.

Groups are started by a header line containing the group name enclosed
in '[' and ']', and ended implicitly by the start of the next group or
the end of the file. Each key-value pair must be contained in a group.

Key-value pairs generally have the form `key=value`, with the
exception of localized strings, which have the form
`key[locale]=value`, with a locale identifier of the
form `lang_COUNTRY@MODIFIER` where `COUNTRY` and `MODIFIER`
are optional.
Space before and after the '=' character are ignored. Newline, tab,
carriage return and backslash characters in value are escaped as \n,
\t, \r, and \\\\, respectively. To preserve leading spaces in values,
these can also be escaped as \s.

Key files can store strings (possibly with localized variants), integers,
booleans and lists of these. Lists are separated by a separator character,
typically ';' or ','. To use the list separator character in a value in
a list, it has to be escaped by prefixing it with a backslash.

This syntax is obviously inspired by the .ini files commonly met
on Windows, but there are some important differences:

- .ini files use the ';' character to begin comments,
  key files use the '#' character.

- Key files do not allow for ungrouped keys meaning only
  comments can precede the first group.

- Key files are always encoded in UTF-8.

- Key and Group names are case-sensitive. For example, a group called
  [GROUP] is a different from [group].

- .ini files don't have a strongly typed boolean entry type,
   they only have GetProfileInt(). In key files, only
   true and false (in lower case) are allowed.

Note that in contrast to the
[Desktop Entry Specification](http://freedesktop.org/Standards/desktop-entry-spec),
groups in key files may contain the same
key multiple times; the last entry wins. Key files may also contain
multiple groups with the same name; they are merged together.
Another difference is that keys and group names in key files are not
restricted to ASCII characters.

Here is an example of loading a key file and reading a value:
|[&lt;!-- language="C" --&gt;
g_autoptr(GError) error = NULL;
g_autoptr(GKeyFile) key_file = g_key_file_new ();

if (!g_key_file_load_from_file (key_file, "key-file.ini", flags, &amp;error))
  {
    if (!g_error_matches (error, G_FILE_ERROR, G_FILE_ERROR_NOENT))
      g_warning ("Error loading key file: %s", error-&gt;message);
    return;
  }

g_autofree gchar *val = g_key_file_get_string (key_file, "Group Name", "SomeKey", &amp;error);
if (val == NULL &amp;&amp;
    !g_error_matches (error, G_KEY_FILE_ERROR, G_KEY_FILE_ERROR_KEY_NOT_FOUND))
  {
    g_warning ("Error finding key in key file: %s", error-&gt;message);
    return;
  }
else if (val == NULL)
  {
    // Fall back to a default value.
    val = g_strdup ("default-value");
  }
]|

Here is an example of creating and saving a key file:
|[&lt;!-- language="C" --&gt;
g_autoptr(GKeyFile) key_file = g_key_file_new ();
const gchar *val = …;
g_autoptr(GError) error = NULL;

g_key_file_set_string (key_file, "Group Name", "SomeKey", val);

// Save as a file.
if (!g_key_file_save_to_file (key_file, "key-file.ini", &amp;error))
  {
    g_warning ("Error saving key file: %s", error-&gt;message);
    return;
  }

// Or store to a GBytes for use elsewhere.
gsize data_len;
g_autofree guint8 *data = (guint8 *) g_key_file_to_data (key_file, &amp;data_len, &amp;error);
if (data == NULL)
  {
    g_warning ("Error saving key file: %s", error-&gt;message);
    return;
  }
g_autoptr(GBytes) bytes = g_bytes_new_take (g_steal_pointer (&amp;data), data_len);
]|</doc>
    </docsection>
    <docsection name="linked_lists_double" gs:managed-name="LinkedListsDouble">
      <doc xml:space="preserve" filename="glib-2.0.c" line="6944">The #GList structure and its associated functions provide a standard
doubly-linked list data structure. The benefit of this data-structure
is to provide insertion/deletion operations in O(1) complexity where
access/search operations are in O(n). The benefit of #GList over
#GSList (singly linked list) is that the worst case on access/search
operations is divided by two which comes at a cost in space as we need
to retain two pointers in place of one.

Each element in the list contains a piece of data, together with
pointers which link to the previous and next elements in the list.
Using these pointers it is possible to move through the list in both
directions (unlike the singly-linked [GSList][glib-Singly-Linked-Lists],
which only allows movement through the list in the forward direction).

The double linked list does not keep track of the number of items
and does not keep track of both the start and end of the list. If
you want fast access to both the start and the end of the list,
and/or the number of items in the list, use a
[GQueue][glib-Double-ended-Queues] instead.

The data contained in each element can be either integer values, by
using one of the [Type Conversion Macros][glib-Type-Conversion-Macros],
or simply pointers to any type of data.

List elements are allocated from the [slice allocator][glib-Memory-Slices],
which is more efficient than allocating elements individually.

Note that most of the #GList functions expect to be passed a pointer
to the first element in the list. The functions which insert
elements return the new start of the list, which may have changed.

There is no function to create a #GList. %NULL is considered to be
a valid, empty list so you simply set a #GList* to %NULL to initialize
it.

To add elements, use g_list_append(), g_list_prepend(),
g_list_insert() and g_list_insert_sorted().

To visit all elements in the list, use a loop over the list:
|[&lt;!-- language="C" --&gt;
GList *l;
for (l = list; l != NULL; l = l-&gt;next)
  {
    // do something with l-&gt;data
  }
]|

To call a function for each element in the list, use g_list_foreach().

To loop over the list and modify it (e.g. remove a certain element)
a while loop is more appropriate, for example:
|[&lt;!-- language="C" --&gt;
GList *l = list;
while (l != NULL)
  {
    GList *next = l-&gt;next;
    if (should_be_removed (l))
      {
        // possibly free l-&gt;data
        list = g_list_delete_link (list, l);
      }
    l = next;
  }
]|

To remove elements, use g_list_remove().

To navigate in a list, use g_list_first(), g_list_last(),
g_list_next(), g_list_previous().

To find elements in the list use g_list_nth(), g_list_nth_data(),
g_list_find() and g_list_find_custom().

To find the index of an element use g_list_position() and
g_list_index().

To free the entire list, use g_list_free() or g_list_free_full().</doc>
    </docsection>
    <docsection name="linked_lists_single" gs:managed-name="LinkedListsSingle">
      <doc xml:space="preserve" filename="glib-2.0.c" line="7029">The #GSList structure and its associated functions provide a
standard singly-linked list data structure. The benefit of this
data-structure is to provide insertion/deletion operations in O(1)
complexity where access/search operations are in O(n). The benefit
of #GSList over #GList (doubly linked list) is that they are lighter
in space as they only need to retain one pointer but it double the
cost of the worst case access/search operations.

Each element in the list contains a piece of data, together with a
pointer which links to the next element in the list. Using this
pointer it is possible to move through the list in one direction
only (unlike the [double-linked lists][glib-Doubly-Linked-Lists],
which allow movement in both directions).

The data contained in each element can be either integer values, by
using one of the [Type Conversion Macros][glib-Type-Conversion-Macros],
or simply pointers to any type of data.

List elements are allocated from the [slice allocator][glib-Memory-Slices],
which is more efficient than allocating elements individually.

Note that most of the #GSList functions expect to be passed a
pointer to the first element in the list. The functions which insert
elements return the new start of the list, which may have changed.

There is no function to create a #GSList. %NULL is considered to be
the empty list so you simply set a #GSList* to %NULL.

To add elements, use g_slist_append(), g_slist_prepend(),
g_slist_insert() and g_slist_insert_sorted().

To remove elements, use g_slist_remove().

To find elements in the list use g_slist_last(), g_slist_next(),
g_slist_nth(), g_slist_nth_data(), g_slist_find() and
g_slist_find_custom().

To find the index of an element use g_slist_position() and
g_slist_index().

To call a function for each element in the list use
g_slist_foreach().

To free the entire list, use g_slist_free().</doc>
    </docsection>
    <docsection name="macros" gs:managed-name="Macros">
      <doc xml:space="preserve" filename="glib-2.0.c" line="7081">These macros provide a few commonly-used features.</doc>
    </docsection>
    <docsection name="macros_misc" gs:managed-name="MacrosMisc">
      <doc xml:space="preserve" filename="glib-2.0.c" line="7090">These macros provide more specialized features which are not
needed so often by application programmers.</doc>
    </docsection>
    <docsection name="main" gs:managed-name="Main">
      <doc xml:space="preserve" filename="glib-2.0.c" line="7100">The main event loop manages all the available sources of events for
GLib and GTK+ applications. These events can come from any number of
different types of sources such as file descriptors (plain files,
pipes or sockets) and timeouts. New types of event sources can also
be added using g_source_attach().

To allow multiple independent sets of sources to be handled in
different threads, each source is associated with a #GMainContext.
A #GMainContext can only be running in a single thread, but
sources can be added to it and removed from it from other threads. All
functions which operate on a #GMainContext or a built-in #GSource are
thread-safe.

Each event source is assigned a priority. The default priority,
#G_PRIORITY_DEFAULT, is 0. Values less than 0 denote higher priorities.
Values greater than 0 denote lower priorities. Events from high priority
sources are always processed before events from lower priority sources.

Idle functions can also be added, and assigned a priority. These will
be run whenever no events with a higher priority are ready to be processed.

The #GMainLoop data type represents a main event loop. A GMainLoop is
created with g_main_loop_new(). After adding the initial event sources,
g_main_loop_run() is called. This continuously checks for new events from
each of the event sources and dispatches them. Finally, the processing of
an event from one of the sources leads to a call to g_main_loop_quit() to
exit the main loop, and g_main_loop_run() returns.

It is possible to create new instances of #GMainLoop recursively.
This is often used in GTK+ applications when showing modal dialog
boxes. Note that event sources are associated with a particular
#GMainContext, and will be checked and dispatched for all main
loops associated with that GMainContext.

GTK+ contains wrappers of some of these functions, e.g. gtk_main(),
gtk_main_quit() and gtk_events_pending().

## Creating new source types

One of the unusual features of the #GMainLoop functionality
is that new types of event source can be created and used in
addition to the builtin type of event source. A new event source
type is used for handling GDK events. A new source type is created
by "deriving" from the #GSource structure. The derived type of
source is represented by a structure that has the #GSource structure
as a first element, and other elements specific to the new source
type. To create an instance of the new source type, call
g_source_new() passing in the size of the derived structure and
a table of functions. These #GSourceFuncs determine the behavior of
the new source type.

New source types basically interact with the main context
in two ways. Their prepare function in #GSourceFuncs can set a timeout
to determine the maximum amount of time that the main loop will sleep
before checking the source again. In addition, or as well, the source
can add file descriptors to the set that the main context checks using
g_source_add_poll().

## Customizing the main loop iteration

Single iterations of a #GMainContext can be run with
g_main_context_iteration(). In some cases, more detailed control
of exactly how the details of the main loop work is desired, for
instance, when integrating the #GMainLoop with an external main loop.
In such cases, you can call the component functions of
g_main_context_iteration() directly. These functions are
g_main_context_prepare(), g_main_context_query(),
g_main_context_check() and g_main_context_dispatch().

## State of a Main Context # {#mainloop-states}

The operation of these functions can best be seen in terms
of a state diagram, as shown in this image.

![](mainloop-states.gif)

On UNIX, the GLib mainloop is incompatible with fork(). Any program
using the mainloop must either exec() or exit() from the child
without returning to the mainloop.

## Memory management of sources # {#mainloop-memory-management}

There are two options for memory management of the user data passed to a
#GSource to be passed to its callback on invocation. This data is provided
in calls to g_timeout_add(), g_timeout_add_full(), g_idle_add(), etc. and
more generally, using g_source_set_callback(). This data is typically an
object which ‘owns’ the timeout or idle callback, such as a widget or a
network protocol implementation. In many cases, it is an error for the
callback to be invoked after this owning object has been destroyed, as that
results in use of freed memory.

The first, and preferred, option is to store the source ID returned by
functions such as g_timeout_add() or g_source_attach(), and explicitly
remove that source from the main context using g_source_remove() when the
owning object is finalized. This ensures that the callback can only be
invoked while the object is still alive.

The second option is to hold a strong reference to the object in the
callback, and to release it in the callback’s #GDestroyNotify. This ensures
that the object is kept alive until after the source is finalized, which is
guaranteed to be after it is invoked for the final time. The #GDestroyNotify
is another callback passed to the ‘full’ variants of #GSource functions (for
example, g_timeout_add_full()). It is called when the source is finalized,
and is designed for releasing references like this.

One important caveat of this second approach is that it will keep the object
alive indefinitely if the main loop is stopped before the #GSource is
invoked, which may be undesirable.</doc>
    </docsection>
    <docsection name="markup" gs:managed-name="Markup">
      <doc xml:space="preserve" filename="glib-2.0.c" line="7216">The "GMarkup" parser is intended to parse a simple markup format
that's a subset of XML. This is a small, efficient, easy-to-use
parser. It should not be used if you expect to interoperate with
other applications generating full-scale XML, and must not be used if you
expect to parse untrusted input. However, it's very
useful for application data files, config files, etc. where you
know your application will be the only one writing the file.
Full-scale XML parsers should be able to parse the subset used by
GMarkup, so you can easily migrate to full-scale XML at a later
time if the need arises.

GMarkup is not guaranteed to signal an error on all invalid XML;
the parser may accept documents that an XML parser would not.
However, XML documents which are not well-formed (which is a
weaker condition than being valid. See the
[XML specification](http://www.w3.org/TR/REC-xml/)
for definitions of these terms.) are not considered valid GMarkup
documents.

Simplifications to XML include:

- Only UTF-8 encoding is allowed

- No user-defined entities

- Processing instructions, comments and the doctype declaration
  are "passed through" but are not interpreted in any way

- No DTD or validation

The markup format does support:

- Elements

- Attributes

- 5 standard entities: &amp;amp; &amp;lt; &amp;gt; &amp;quot; &amp;apos;

- Character references

- Sections marked as CDATA</doc>
    </docsection>
    <docsection name="memory" gs:managed-name="Memory">
      <doc xml:space="preserve" filename="glib-2.0.c" line="7266">These functions provide support for allocating and freeing memory.

If any call to allocate memory using functions g_new(), g_new0(), g_renew(),
g_malloc(), g_malloc0(), g_malloc0_n(), g_realloc(), and g_realloc_n()
fails, the application is terminated. This also means that there is no
need to check if the call succeeded. On the other hand, the `g_try_...()` family
of functions returns %NULL on failure that can be used as a check
for unsuccessful memory allocation. The application is not terminated
in this case.

As all GLib functions and data structures use `g_malloc()` internally, unless
otherwise specified, any allocation failure will result in the application
being terminated.

It's important to match g_malloc() (and wrappers such as g_new()) with
g_free(), g_slice_alloc() (and wrappers such as g_slice_new()) with
g_slice_free(), plain malloc() with free(), and (if you're using C++)
new with delete and new[] with delete[]. Otherwise bad things can happen,
since these allocators may use different memory pools (and new/delete call
constructors and destructors).

Since GLib 2.46 g_malloc() is hardcoded to always use the system malloc
implementation.</doc>
    </docsection>
    <docsection name="memory_slices" gs:managed-name="MemorySlices">
      <doc xml:space="preserve" filename="glib-2.0.c" line="7297">Memory slices provide a space-efficient and multi-processing scalable
way to allocate equal-sized pieces of memory, just like the original
#GMemChunks (from GLib 2.8), while avoiding their excessive
memory-waste, scalability and performance problems.

To achieve these goals, the slice allocator uses a sophisticated,
layered design that has been inspired by Bonwick's slab allocator
([Bonwick94](http://citeseer.ist.psu.edu/bonwick94slab.html)
Jeff Bonwick, The slab allocator: An object-caching kernel
memory allocator. USENIX 1994, and
[Bonwick01](http://citeseer.ist.psu.edu/bonwick01magazines.html)
Bonwick and Jonathan Adams, Magazines and vmem: Extending the
slab allocator to many cpu's and arbitrary resources. USENIX 2001)

It uses posix_memalign() to optimize allocations of many equally-sized
chunks, and has per-thread free lists (the so-called magazine layer)
to quickly satisfy allocation requests of already known structure sizes.
This is accompanied by extra caching logic to keep freed memory around
for some time before returning it to the system. Memory that is unused
due to alignment constraints is used for cache colorization (random
distribution of chunk addresses) to improve CPU cache utilization. The
caching layer of the slice allocator adapts itself to high lock contention
to improve scalability.

The slice allocator can allocate blocks as small as two pointers, and
unlike malloc(), it does not reserve extra space per block. For large block
sizes, g_slice_new() and g_slice_alloc() will automatically delegate to the
system malloc() implementation. For newly written code it is recommended
to use the new `g_slice` API instead of g_malloc() and
friends, as long as objects are not resized during their lifetime and the
object size used at allocation time is still available when freeing.

Here is an example for using the slice allocator:
|[&lt;!-- language="C" --&gt;
gchar *mem[10000];
gint i;

// Allocate 10000 blocks.
for (i = 0; i &lt; 10000; i++)
  {
    mem[i] = g_slice_alloc (50);

    // Fill in the memory with some junk.
    for (j = 0; j &lt; 50; j++)
      mem[i][j] = i * j;
  }

// Now free all of the blocks.
for (i = 0; i &lt; 10000; i++)
  g_slice_free1 (50, mem[i]);
]|

And here is an example for using the using the slice allocator
with data structures:
|[&lt;!-- language="C" --&gt;
GRealArray *array;

// Allocate one block, using the g_slice_new() macro.
array = g_slice_new (GRealArray);

// We can now use array just like a normal pointer to a structure.
array-&gt;data            = NULL;
array-&gt;len             = 0;
array-&gt;alloc           = 0;
array-&gt;zero_terminated = (zero_terminated ? 1 : 0);
array-&gt;clear           = (clear ? 1 : 0);
array-&gt;elt_size        = elt_size;

// We can free the block, so it can be reused.
g_slice_free (GRealArray, array);
]|</doc>
    </docsection>
    <docsection name="messages" gs:managed-name="Messages">
      <doc xml:space="preserve" filename="glib-2.0.c" line="7377">These functions provide support for outputting messages.

The g_return family of macros (g_return_if_fail(),
g_return_val_if_fail(), g_return_if_reached(),
g_return_val_if_reached()) should only be used for programming
errors, a typical use case is checking for invalid parameters at
the beginning of a public function. They should not be used if
you just mean "if (error) return", they should only be used if
you mean "if (bug in program) return". The program behavior is
generally considered undefined after one of these checks fails.
They are not intended for normal control flow, only to give a
perhaps-helpful warning before giving up.

Structured logging output is supported using g_log_structured(). This differs
from the traditional g_log() API in that log messages are handled as a
collection of key–value pairs representing individual pieces of information,
rather than as a single string containing all the information in an arbitrary
format.

The convenience macros g_info(), g_message(), g_debug(), g_warning() and g_error()
will use the traditional g_log() API unless you define the symbol
%G_LOG_USE_STRUCTURED before including `glib.h`. But note that even messages
logged through the traditional g_log() API are ultimatively passed to
g_log_structured(), so that all log messages end up in same destination.
If %G_LOG_USE_STRUCTURED is defined, g_test_expect_message() will become
ineffective for the wrapper macros g_warning() and friends (see
[Testing for Messages][testing-for-messages]).

The support for structured logging was motivated by the following needs (some
of which were supported previously; others weren’t):
 * Support for multiple logging levels.
 * Structured log support with the ability to add `MESSAGE_ID`s (see
   g_log_structured()).
 * Moving the responsibility for filtering log messages from the program to
   the log viewer — instead of libraries and programs installing log handlers
   (with g_log_set_handler()) which filter messages before output, all log
   messages are outputted, and the log viewer program (such as `journalctl`)
   must filter them. This is based on the idea that bugs are sometimes hard
   to reproduce, so it is better to log everything possible and then use
   tools to analyse the logs than it is to not be able to reproduce a bug to
   get additional log data. Code which uses logging in performance-critical
   sections should compile out the g_log_structured() calls in
   release builds, and compile them in in debugging builds.
 * A single writer function which handles all log messages in a process, from
   all libraries and program code; rather than multiple log handlers with
   poorly defined interactions between them. This allows a program to easily
   change its logging policy by changing the writer function, for example to
   log to an additional location or to change what logging output fallbacks
   are used. The log writer functions provided by GLib are exposed publicly
   so they can be used from programs’ log writers. This allows log writer
   policy and implementation to be kept separate.
 * If a library wants to add standard information to all of its log messages
   (such as library state) or to redact private data (such as passwords or
   network credentials), it should use a wrapper function around its
   g_log_structured() calls or implement that in the single log writer
   function.
 * If a program wants to pass context data from a g_log_structured() call to
   its log writer function so that, for example, it can use the correct
   server connection to submit logs to, that user data can be passed as a
   zero-length #GLogField to g_log_structured_array().
 * Color output needed to be supported on the terminal, to make reading
   through logs easier.

## Using Structured Logging ## {#using-structured-logging}

To use structured logging (rather than the old-style logging), either use
the g_log_structured() and g_log_structured_array() functions; or define
`G_LOG_USE_STRUCTURED` before including any GLib header, and use the
g_message(), g_debug(), g_error() (etc.) macros.

You do not need to define `G_LOG_USE_STRUCTURED` to use g_log_structured(),
but it is a good idea to avoid confusion.

## Log Domains ## {#log-domains}

Log domains may be used to broadly split up the origins of log messages.
Typically, there are one or a few log domains per application or library.
%G_LOG_DOMAIN should be used to define the default log domain for the current
compilation unit — it is typically defined at the top of a source file, or in
the preprocessor flags for a group of source files.

Log domains must be unique, and it is recommended that they are the
application or library name, optionally followed by a hyphen and a sub-domain
name. For example, `bloatpad` or `bloatpad-io`.

## Debug Message Output ## {#debug-message-output}

The default log functions (g_log_default_handler() for the old-style API and
g_log_writer_default() for the structured API) both drop debug and
informational messages by default, unless the log domains of those messages
are listed in the `G_MESSAGES_DEBUG` environment variable (or it is set to
`all`).

It is recommended that custom log writer functions re-use the
`G_MESSAGES_DEBUG` environment variable, rather than inventing a custom one,
so that developers can re-use the same debugging techniques and tools across
projects.

## Testing for Messages ## {#testing-for-messages}

With the old g_log() API, g_test_expect_message() and
g_test_assert_expected_messages() could be used in simple cases to check
whether some code under test had emitted a given log message. These
functions have been deprecated with the structured logging API, for several
reasons:
 * They relied on an internal queue which was too inflexible for many use
   cases, where messages might be emitted in several orders, some
   messages might not be emitted deterministically, or messages might be
   emitted by unrelated log domains.
 * They do not support structured log fields.
 * Examining the log output of code is a bad approach to testing it, and
   while it might be necessary for legacy code which uses g_log(), it should
   be avoided for new code using g_log_structured().

They will continue to work as before if g_log() is in use (and
%G_LOG_USE_STRUCTURED is not defined). They will do nothing if used with the
structured logging API.

Examining the log output of code is discouraged: libraries should not emit to
`stderr` during defined behaviour, and hence this should not be tested. If
the log emissions of a library during undefined behaviour need to be tested,
they should be limited to asserting that the library aborts and prints a
suitable error message before aborting. This should be done with
g_test_trap_assert_stderr().

If it is really necessary to test the structured log messages emitted by a
particular piece of code – and the code cannot be restructured to be more
suitable to more conventional unit testing – you should write a custom log
writer function (see g_log_set_writer_func()) which appends all log messages
to a queue. When you want to check the log messages, examine and clear the
queue, ignoring irrelevant log messages (for example, from log domains other
than the one under test).</doc>
    </docsection>
    <docsection name="misc_utils" gs:managed-name="MiscUtils">
      <doc xml:space="preserve" filename="glib-2.0.c" line="7517">These are portable utility functions.</doc>
    </docsection>
    <docsection name="numerical" gs:managed-name="Numerical">
      <doc xml:space="preserve" filename="glib-2.0.c" line="7526">GLib offers mathematical constants such as #G_PI for the value of pi;
many platforms have these in the C library, but some don't, the GLib
versions always exist.

The #GFloatIEEE754 and #GDoubleIEEE754 unions are used to access the
sign, mantissa and exponent of IEEE floats and doubles. These unions are
defined as appropriate for a given platform. IEEE floats and doubles are
supported (used for storage) by at least Intel, PPC and Sparc. See
[IEEE 754-2008](http://en.wikipedia.org/wiki/IEEE_float)
for more information about IEEE number formats.</doc>
    </docsection>
    <docsection name="option" gs:managed-name="Option">
      <doc xml:space="preserve" filename="glib-2.0.c" line="7544">The GOption commandline parser is intended to be a simpler replacement
for the popt library. It supports short and long commandline options,
as shown in the following example:

`testtreemodel -r 1 --max-size 20 --rand --display=:1.0 -vb -- file1 file2`

The example demonstrates a number of features of the GOption
commandline parser:

- Options can be single letters, prefixed by a single dash.

- Multiple short options can be grouped behind a single dash.

- Long options are prefixed by two consecutive dashes.

- Options can have an extra argument, which can be a number, a string or
  a filename. For long options, the extra argument can be appended with
  an equals sign after the option name, which is useful if the extra
  argument starts with a dash, which would otherwise cause it to be
  interpreted as another option.

- Non-option arguments are returned to the application as rest arguments.

- An argument consisting solely of two dashes turns off further parsing,
  any remaining arguments (even those starting with a dash) are returned
  to the application as rest arguments.

Another important feature of GOption is that it can automatically
generate nicely formatted help output. Unless it is explicitly turned
off with g_option_context_set_help_enabled(), GOption will recognize
the `--help`, `-?`, `--help-all` and `--help-groupname` options
(where `groupname` is the name of a #GOptionGroup) and write a text
similar to the one shown in the following example to stdout.

|[
Usage:
  testtreemodel [OPTION...] - test tree model performance
 
Help Options:
  -h, --help               Show help options
  --help-all               Show all help options
  --help-gtk               Show GTK+ Options
 
Application Options:
  -r, --repeats=N          Average over N repetitions
  -m, --max-size=M         Test up to 2^M items
  --display=DISPLAY        X display to use
  -v, --verbose            Be verbose
  -b, --beep               Beep when done
  --rand                   Randomize the data
]|

GOption groups options in #GOptionGroups, which makes it easy to
incorporate options from multiple sources. The intended use for this is
to let applications collect option groups from the libraries it uses,
add them to their #GOptionContext, and parse all options by a single call
to g_option_context_parse(). See gtk_get_option_group() for an example.

If an option is declared to be of type string or filename, GOption takes
care of converting it to the right encoding; strings are returned in
UTF-8, filenames are returned in the GLib filename encoding. Note that
this only works if setlocale() has been called before
g_option_context_parse().

Here is a complete example of setting up GOption to parse the example
commandline above and produce the example help output.
|[&lt;!-- language="C" --&gt;
static gint repeats = 2;
static gint max_size = 8;
static gboolean verbose = FALSE;
static gboolean beep = FALSE;
static gboolean randomize = FALSE;

static GOptionEntry entries[] =
{
  { "repeats", 'r', 0, G_OPTION_ARG_INT, &amp;repeats, "Average over N repetitions", "N" },
  { "max-size", 'm', 0, G_OPTION_ARG_INT, &amp;max_size, "Test up to 2^M items", "M" },
  { "verbose", 'v', 0, G_OPTION_ARG_NONE, &amp;verbose, "Be verbose", NULL },
  { "beep", 'b', 0, G_OPTION_ARG_NONE, &amp;beep, "Beep when done", NULL },
  { "rand", 0, 0, G_OPTION_ARG_NONE, &amp;randomize, "Randomize the data", NULL },
  { NULL }
};

int
main (int argc, char *argv[])
{
  GError *error = NULL;
  GOptionContext *context;

  context = g_option_context_new ("- test tree model performance");
  g_option_context_add_main_entries (context, entries, GETTEXT_PACKAGE);
  g_option_context_add_group (context, gtk_get_option_group (TRUE));
  if (!g_option_context_parse (context, &amp;argc, &amp;argv, &amp;error))
    {
      g_print ("option parsing failed: %s\n", error-&gt;message);
      exit (1);
    }

  ...

}
]|

On UNIX systems, the argv that is passed to main() has no particular
encoding, even to the extent that different parts of it may have
different encodings.  In general, normal arguments and flags will be
in the current locale and filenames should be considered to be opaque
byte strings.  Proper use of %G_OPTION_ARG_FILENAME vs
%G_OPTION_ARG_STRING is therefore important.

Note that on Windows, filenames do have an encoding, but using
#GOptionContext with the argv as passed to main() will result in a
program that can only accept commandline arguments with characters
from the system codepage.  This can cause problems when attempting to
deal with filenames containing Unicode characters that fall outside
of the codepage.

A solution to this is to use g_win32_get_command_line() and
g_option_context_parse_strv() which will properly handle full Unicode
filenames.  If you are using #GApplication, this is done
automatically for you.

The following example shows how you can use #GOptionContext directly
in order to correctly deal with Unicode filenames on Windows:

|[&lt;!-- language="C" --&gt;
int
main (int argc, char **argv)
{
  GError *error = NULL;
  GOptionContext *context;
  gchar **args;

#ifdef G_OS_WIN32
  args = g_win32_get_command_line ();
#else
  args = g_strdupv (argv);
#endif

  // set up context

  if (!g_option_context_parse_strv (context, &amp;args, &amp;error))
    {
      // error happened
    }

  ...

  g_strfreev (args);

  ...
}
]|</doc>
    </docsection>
    <docsection name="patterns" gs:managed-name="Patterns">
      <doc xml:space="preserve" filename="glib-2.0.c" line="7705">The g_pattern_match* functions match a string
against a pattern containing '*' and '?' wildcards with similar
semantics as the standard glob() function: '*' matches an arbitrary,
possibly empty, string, '?' matches an arbitrary character.

Note that in contrast to glob(), the '/' character can be matched by
the wildcards, there are no '[...]' character ranges and '*' and '?'
can not be escaped to include them literally in a pattern.

When multiple strings must be matched against the same pattern, it
is better to compile the pattern to a #GPatternSpec using
g_pattern_spec_new() and use g_pattern_match_string() instead of
g_pattern_match_simple(). This avoids the overhead of repeated
pattern compilation.</doc>
    </docsection>
    <docsection name="quarks" gs:managed-name="Quarks">
      <doc xml:space="preserve" filename="glib-2.0.c" line="7728">Quarks are associations between strings and integer identifiers.
Given either the string or the #GQuark identifier it is possible to
retrieve the other.

Quarks are used for both [datasets][glib-Datasets] and
[keyed data lists][glib-Keyed-Data-Lists].

To create a new quark from a string, use g_quark_from_string() or
g_quark_from_static_string().

To find the string corresponding to a given #GQuark, use
g_quark_to_string().

To find the #GQuark corresponding to a given string, use
g_quark_try_string().

Another use for the string pool maintained for the quark functions
is string interning, using g_intern_string() or
g_intern_static_string(). An interned string is a canonical
representation for a string. One important advantage of interned
strings is that they can be compared for equality by a simple
pointer comparison, rather than using strcmp().</doc>
    </docsection>
    <docsection name="queue" gs:managed-name="Queue">
      <doc xml:space="preserve" filename="glib-2.0.c" line="7759">The #GQueue structure and its associated functions provide a standard
queue data structure. Internally, GQueue uses the same data structure
as #GList to store elements with the same complexity over
insertion/deletion (O(1)) and access/search (O(n)) operations.

The data contained in each element can be either integer values, by
using one of the [Type Conversion Macros][glib-Type-Conversion-Macros],
or simply pointers to any type of data.

As with all other GLib data structures, #GQueue is not thread-safe.
For a thread-safe queue, use #GAsyncQueue.

To create a new GQueue, use g_queue_new().

To initialize a statically-allocated GQueue, use #G_QUEUE_INIT or
g_queue_init().

To add elements, use g_queue_push_head(), g_queue_push_head_link(),
g_queue_push_tail() and g_queue_push_tail_link().

To remove elements, use g_queue_pop_head() and g_queue_pop_tail().

To free the entire queue, use g_queue_free().</doc>
    </docsection>
    <docsection name="random_numbers" gs:managed-name="RandomNumbers">
      <doc xml:space="preserve" filename="glib-2.0.c" line="7790">The following functions allow you to use a portable, fast and good
pseudo-random number generator (PRNG).

Do not use this API for cryptographic purposes such as key
generation, nonces, salts or one-time pads.

This PRNG is suitable for non-cryptographic use such as in games
(shuffling a card deck, generating levels), generating data for
a test suite, etc. If you need random data for cryptographic
purposes, it is recommended to use platform-specific APIs such
as `/dev/random` on UNIX, or CryptGenRandom() on Windows.

GRand uses the Mersenne Twister PRNG, which was originally
developed by Makoto Matsumoto and Takuji Nishimura. Further
information can be found at
[this page](http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html).

If you just need a random number, you simply call the g_random_*
functions, which will create a globally used #GRand and use the
according g_rand_* functions internally. Whenever you need a
stream of reproducible random numbers, you better create a
#GRand yourself and use the g_rand_* functions directly, which
will also be slightly faster. Initializing a #GRand with a
certain seed will produce exactly the same series of random
numbers on all platforms. This can thus be used as a seed for
e.g. games.

The g_rand*_range functions will return high quality equally
distributed random numbers, whereas for example the
`(g_random_int()%max)` approach often
doesn't yield equally distributed numbers.

GLib changed the seeding algorithm for the pseudo-random number
generator Mersenne Twister, as used by #GRand. This was necessary,
because some seeds would yield very bad pseudo-random streams.
Also the pseudo-random integers generated by g_rand*_int_range()
will have a slightly better equal distribution with the new
version of GLib.

The original seeding and generation algorithms, as found in
GLib 2.0.x, can be used instead of the new ones by setting the
environment variable `G_RANDOM_VERSION` to the value of '2.0'.
Use the GLib-2.0 algorithms only if you have sequences of numbers
generated with Glib-2.0 that you need to reproduce exactly.</doc>
    </docsection>
    <docsection name="rcbox" gs:managed-name="Rcbox">
      <doc xml:space="preserve" filename="glib-2.0.c" line="7842">A "reference counted box", or "RcBox", is an opaque wrapper data type
that is guaranteed to be as big as the size of a given data type, and
which augments the given data type with reference counting semantics
for its memory management.

RcBox is useful if you have a plain old data type, like a structure
typically placed on the stack, and you wish to provide additional API
to use it on the heap; or if you want to implement a new type to be
passed around by reference without necessarily implementing copy/free
semantics or your own reference counting.

The typical use is:

|[&lt;!-- language="C" --&gt;
typedef struct {
  char *name;
  char *address;
  char *city;
  char *state;
  int age;
} Person;

Person *
person_new (void)
{
  return g_rc_box_new0 (Person);
}
]|

Every time you wish to acquire a reference on the memory, you should
call g_rc_box_acquire(); similarly, when you wish to release a reference
you should call g_rc_box_release():

|[&lt;!-- language="C" --&gt;
// Add a Person to the Database; the Database acquires ownership
// of the Person instance
void
add_person_to_database (Database *db, Person *p)
{
  db-&gt;persons = g_list_prepend (db-&gt;persons, g_rc_box_acquire (p));
}

// Removes a Person from the Database; the reference acquired by
// add_person_to_database() is released here
void
remove_person_from_database (Database *db, Person *p)
{
  db-&gt;persons = g_list_remove (db-&gt;persons, p);
  g_rc_box_release (p);
}
]|

If you have additional memory allocated inside the structure, you can
use g_rc_box_release_full(), which takes a function pointer, which
will be called if the reference released was the last:

|[&lt;!-- language="C" --&gt;
void
person_clear (Person *p)
{
  g_free (p-&gt;name);
  g_free (p-&gt;address);
  g_free (p-&gt;city);
  g_free (p-&gt;state);
}

void
remove_person_from_database (Database *db, Person *p)
{
  db-&gt;persons = g_list_remove (db-&gt;persons, p);
  g_rc_box_release_full (p, (GDestroyNotify) person_clear);
}
]|

If you wish to transfer the ownership of a reference counted data
type without increasing the reference count, you can use g_steal_pointer():

|[&lt;!-- language="C" --&gt;
  Person *p = g_rc_box_new (Person);

  // fill_person_details() is defined elsewhere
  fill_person_details (p);

  // add_person_to_database_no_ref() is defined elsewhere; it adds
  // a Person to the Database without taking a reference
  add_person_to_database_no_ref (db, g_steal_pointer (&amp;p));
]|

## Thread safety

The reference counting operations on data allocated using g_rc_box_alloc(),
g_rc_box_new(), and g_rc_box_dup() are not thread safe; it is your code's
responsibility to ensure that references are acquired are released on the
same thread.

If you need thread safe reference counting, see the [atomic reference counted
data][arcbox] API.

## Automatic pointer clean up

If you want to add g_autoptr() support to your plain old data type through
reference counting, you can use the G_DEFINE_AUTOPTR_CLEANUP_FUNC() and
g_rc_box_release():

|[&lt;!-- language="C" --&gt;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (MyDataStruct, g_rc_box_release)
]|

If you need to clear the contents of the data, you will need to use an
ancillary function that calls g_rc_box_release_full():

|[&lt;!-- language="C" --&gt;
static void
my_data_struct_release (MyDataStruct *data)
{
  // my_data_struct_clear() is defined elsewhere
  g_rc_box_release_full (data, (GDestroyNotify) my_data_struct_clear);
}

G_DEFINE_AUTOPTR_CLEANUP_FUNC (MyDataStruct, my_data_struct_release)
]|</doc>
    </docsection>
    <docsection name="refcount" gs:managed-name="Refcount">
      <doc xml:space="preserve" filename="glib-2.0.c" line="7973">Reference counting is a garbage collection mechanism that is based on
assigning a counter to a data type, or any memory area; the counter is
increased whenever a new reference to that data type is acquired, and
decreased whenever the reference is released. Once the last reference
is released, the resources associated to that data type are freed.

GLib uses reference counting in many of its data types, and provides
the #grefcount and #gatomicrefcount types to implement safe and atomic
reference counting semantics in new data types.

It is important to note that #grefcount and #gatomicrefcount should be
considered completely opaque types; you should always use the provided
API to increase and decrease the counters, and you should never check
their content directly, or compare their content with other values.</doc>
    </docsection>
    <docsection name="refstring" gs:managed-name="Refstring">
      <doc xml:space="preserve" filename="glib-2.0.c" line="7997">Reference counted strings are normal C strings that have been augmented
with a reference counter to manage their resources. You allocate a new
reference counted string and acquire and release references as needed,
instead of copying the string among callers; when the last reference on
the string is released, the resources allocated for it are freed.

Typically, reference counted strings can be used when parsing data from
files and storing them into data structures that are passed to various
callers:

|[&lt;!-- language="C" --&gt;
PersonDetails *
person_details_from_data (const char *data)
{
  // Use g_autoptr() to simplify error cases
  g_autoptr(GRefString) full_name = NULL;
  g_autoptr(GRefString) address =  NULL;
  g_autoptr(GRefString) city = NULL;
  g_autoptr(GRefString) state = NULL;
  g_autoptr(GRefString) zip_code = NULL;

  // parse_person_details() is defined elsewhere; returns refcounted strings
  if (!parse_person_details (data, &amp;full_name, &amp;address, &amp;city, &amp;state, &amp;zip_code))
    return NULL;

  if (!validate_zip_code (zip_code))
    return NULL;

  // add_address_to_cache() and add_full_name_to_cache() are defined
  // elsewhere; they add strings to various caches, using refcounted
  // strings to avoid copying data over and over again
  add_address_to_cache (address, city, state, zip_code);
  add_full_name_to_cache (full_name);

  // person_details_new() is defined elsewhere; it takes a reference
  // on each string
  PersonDetails *res = person_details_new (full_name,
                                           address,
                                           city,
                                           state,
                                           zip_code);

  return res;
}
]|

In the example above, we have multiple functions taking the same strings
for different uses; with typical C strings, we'd have to copy the strings
every time the life time rules of the data differ from the life time of
the string parsed from the original buffer. With reference counted strings,
each caller can take a reference on the data, and keep it as long as it
needs to own the string.

Reference counted strings can also be "interned" inside a global table
owned by GLib; while an interned string has at least a reference, creating
a new interned reference counted string with the same contents will return
a reference to the existing string instead of creating a new reference
counted string instance. Once the string loses its last reference, it will
be automatically removed from the global interned strings table.</doc>
    </docsection>
    <docsection name="scanner" gs:managed-name="Scanner">
      <doc xml:space="preserve" filename="glib-2.0.c" line="8066">The #GScanner and its associated functions provide a
general purpose lexical scanner.</doc>
    </docsection>
    <docsection name="sequence" gs:managed-name="Sequence">
      <doc xml:space="preserve" filename="glib-2.0.c" line="8076">The #GSequence data structure has the API of a list, but is
implemented internally with a balanced binary tree. This means that
most of the operations  (access, search, insertion, deletion, ...) on
#GSequence are O(log(n)) in average and O(n) in worst case for time
complexity. But, note that maintaining a balanced sorted list of n
elements is done in time O(n log(n)).
The data contained in each element can be either integer values, by using
of the [Type Conversion Macros][glib-Type-Conversion-Macros], or simply
pointers to any type of data.

A #GSequence is accessed through "iterators", represented by a
#GSequenceIter. An iterator represents a position between two
elements of the sequence. For example, the "begin" iterator
represents the gap immediately before the first element of the
sequence, and the "end" iterator represents the gap immediately
after the last element. In an empty sequence, the begin and end
iterators are the same.

Some methods on #GSequence operate on ranges of items. For example
g_sequence_foreach_range() will call a user-specified function on
each element with the given range. The range is delimited by the
gaps represented by the passed-in iterators, so if you pass in the
begin and end iterators, the range in question is the entire
sequence.

The function g_sequence_get() is used with an iterator to access the
element immediately following the gap that the iterator represents.
The iterator is said to "point" to that element.

Iterators are stable across most operations on a #GSequence. For
example an iterator pointing to some element of a sequence will
continue to point to that element even after the sequence is sorted.
Even moving an element to another sequence using for example
g_sequence_move_range() will not invalidate the iterators pointing
to it. The only operation that will invalidate an iterator is when
the element it points to is removed from any sequence.

To sort the data, either use g_sequence_insert_sorted() or
g_sequence_insert_sorted_iter() to add data to the #GSequence or, if
you want to add a large amount of data, it is more efficient to call
g_sequence_sort() or g_sequence_sort_iter() after doing unsorted
insertions.</doc>
    </docsection>
    <docsection name="shell" gs:managed-name="Shell">
      <doc xml:space="preserve" filename="glib-2.0.c" line="8126">GLib provides the functions g_shell_quote() and g_shell_unquote()
to handle shell-like quoting in strings. The function g_shell_parse_argv()
parses a string similar to the way a POSIX shell (/bin/sh) would.

Note that string handling in shells has many obscure and historical
corner-cases which these functions do not necessarily reproduce. They
are good enough in practice, though.</doc>
    </docsection>
    <docsection name="spawn" gs:managed-name="Spawn">
      <doc xml:space="preserve" filename="glib-2.0.c" line="8141">GLib supports spawning of processes with an API that is more
convenient than the bare UNIX fork() and exec().

The g_spawn family of functions has synchronous (g_spawn_sync())
and asynchronous variants (g_spawn_async(), g_spawn_async_with_pipes()),
as well as convenience variants that take a complete shell-like
commandline (g_spawn_command_line_sync(), g_spawn_command_line_async()).

See #GSubprocess in GIO for a higher-level API that provides
stream interfaces for communication with child processes.

An example of using g_spawn_async_with_pipes():
|[&lt;!-- language="C" --&gt;
const gchar * const argv[] = { "my-favourite-program", "--args", NULL };
gint child_stdout, child_stderr;
GPid child_pid;
g_autoptr(GError) error = NULL;

// Spawn child process.
g_spawn_async_with_pipes (NULL, argv, NULL, G_SPAWN_DO_NOT_REAP_CHILD, NULL,
                          NULL, &amp;child_pid, NULL, &amp;child_stdout,
                          &amp;child_stderr, &amp;error);
if (error != NULL)
  {
    g_error ("Spawning child failed: %s", error-&gt;message);
    return;
  }

// Add a child watch function which will be called when the child process
// exits.
g_child_watch_add (child_pid, child_watch_cb, NULL);

// You could watch for output on @child_stdout and @child_stderr using
// #GUnixInputStream or #GIOChannel here.

static void
child_watch_cb (GPid     pid,
                gint     status,
                gpointer user_data)
{
  g_message ("Child %" G_PID_FORMAT " exited %s", pid,
             g_spawn_check_exit_status (status, NULL) ? "normally" : "abnormally");

  // Free any resources associated with the child here, such as I/O channels
  // on its stdout and stderr FDs. If you have no code to put in the
  // child_watch_cb() callback, you can remove it and the g_child_watch_add()
  // call, but you must also remove the G_SPAWN_DO_NOT_REAP_CHILD flag,
  // otherwise the child process will stay around as a zombie until this
  // process exits.

  g_spawn_close_pid (pid);
}
]|</doc>
    </docsection>
    <docsection name="string_chunks" gs:managed-name="StringChunks">
      <doc xml:space="preserve" filename="glib-2.0.c" line="8202">String chunks are used to store groups of strings. Memory is
allocated in blocks, and as strings are added to the #GStringChunk
they are copied into the next free position in a block. When a block
is full a new block is allocated.

When storing a large number of strings, string chunks are more
efficient than using g_strdup() since fewer calls to malloc() are
needed, and less memory is wasted in memory allocation overheads.

By adding strings with g_string_chunk_insert_const() it is also
possible to remove duplicates.

To create a new #GStringChunk use g_string_chunk_new().

To add strings to a #GStringChunk use g_string_chunk_insert().

To add strings to a #GStringChunk, but without duplicating strings
which are already in the #GStringChunk, use
g_string_chunk_insert_const().

To free the entire #GStringChunk use g_string_chunk_free(). It is
not possible to free individual strings.</doc>
    </docsection>
    <docsection name="string_utils" gs:managed-name="StringUtils">
      <doc xml:space="preserve" filename="glib-2.0.c" line="8232">This section describes a number of utility functions for creating,
duplicating, and manipulating strings.

Note that the functions g_printf(), g_fprintf(), g_sprintf(),
g_vprintf(), g_vfprintf(), g_vsprintf() and g_vasprintf()
are declared in the header `gprintf.h` which is not included in `glib.h`
(otherwise using `glib.h` would drag in `stdio.h`), so you'll have to
explicitly include `&lt;glib/gprintf.h&gt;` in order to use the GLib
printf() functions.

## String precision pitfalls # {#string-precision}

While you may use the printf() functions to format UTF-8 strings,
notice that the precision of a \%Ns parameter is interpreted
as the number of bytes, not characters to print. On top of that,
the GNU libc implementation of the printf() functions has the
"feature" that it checks that the string given for the \%Ns
parameter consists of a whole number of characters in the current
encoding. So, unless you are sure you are always going to be in an
UTF-8 locale or your know your text is restricted to ASCII, avoid
using \%Ns. If your intention is to format strings for a
certain number of columns, then \%Ns is not a correct solution
anyway, since it fails to take wide characters (see g_unichar_iswide())
into account.

Note also that there are various printf() parameters which are platform
dependent. GLib provides platform independent macros for these parameters
which should be used instead. A common example is %G_GUINT64_FORMAT, which
should be used instead of `%llu` or similar parameters for formatting
64-bit integers. These macros are all named `G_*_FORMAT`; see
[Basic Types][glib-Basic-Types].</doc>
    </docsection>
    <docsection name="strings" gs:managed-name="Strings">
      <doc xml:space="preserve" filename="glib-2.0.c" line="8271">A #GString is an object that handles the memory management of a C
string for you.  The emphasis of #GString is on text, typically
UTF-8.  Crucially, the "str" member of a #GString is guaranteed to
have a trailing nul character, and it is therefore always safe to
call functions such as strchr() or g_strdup() on it.

However, a #GString can also hold arbitrary binary data, because it
has a "len" member, which includes any possible embedded nul
characters in the data.  Conceptually then, #GString is like a
#GByteArray with the addition of many convenience methods for text,
and a guaranteed nul terminator.</doc>
    </docsection>
    <docsection name="testing" gs:managed-name="Testing">
      <doc xml:space="preserve" filename="glib-2.0.c" line="8291">GLib provides a framework for writing and maintaining unit tests
in parallel to the code they are testing. The API is designed according
to established concepts found in the other test frameworks (JUnit, NUnit,
RUnit), which in turn is based on smalltalk unit testing concepts.

- Test case: Tests (test methods) are grouped together with their
  fixture into test cases.

- Fixture: A test fixture consists of fixture data and setup and
  teardown methods to establish the environment for the test
  functions. We use fresh fixtures, i.e. fixtures are newly set
  up and torn down around each test invocation to avoid dependencies
  between tests.

- Test suite: Test cases can be grouped into test suites, to allow
  subsets of the available tests to be run. Test suites can be
  grouped into other test suites as well.

The API is designed to handle creation and registration of test suites
and test cases implicitly. A simple call like
|[&lt;!-- language="C" --&gt;
  g_test_add_func ("/misc/assertions", test_assertions);
]|
creates a test suite called "misc" with a single test case named
"assertions", which consists of running the test_assertions function.

In addition to the traditional g_assert_true(), the test framework provides
an extended set of assertions for comparisons: g_assert_cmpfloat(),
g_assert_cmpfloat_with_epsilon(), g_assert_cmpint(), g_assert_cmpuint(),
g_assert_cmphex(), g_assert_cmpstr(), g_assert_cmpmem() and
g_assert_cmpvariant(). The
advantage of these variants over plain g_assert_true() is that the assertion
messages can be more elaborate, and include the values of the compared
entities.

Note that g_assert() should not be used in unit tests, since it is a no-op
when compiling with `G_DISABLE_ASSERT`. Use g_assert() in production code,
and g_assert_true() in unit tests.

A full example of creating a test suite with two tests using fixtures:
|[&lt;!-- language="C" --&gt;
#include &lt;glib.h&gt;
#include &lt;locale.h&gt;

typedef struct {
  MyObject *obj;
  OtherObject *helper;
} MyObjectFixture;

static void
my_object_fixture_set_up (MyObjectFixture *fixture,
                          gconstpointer user_data)
{
  fixture-&gt;obj = my_object_new ();
  my_object_set_prop1 (fixture-&gt;obj, "some-value");
  my_object_do_some_complex_setup (fixture-&gt;obj, user_data);

  fixture-&gt;helper = other_object_new ();
}

static void
my_object_fixture_tear_down (MyObjectFixture *fixture,
                             gconstpointer user_data)
{
  g_clear_object (&amp;fixture-&gt;helper);
  g_clear_object (&amp;fixture-&gt;obj);
}

static void
test_my_object_test1 (MyObjectFixture *fixture,
                      gconstpointer user_data)
{
  g_assert_cmpstr (my_object_get_property (fixture-&gt;obj), ==, "initial-value");
}

static void
test_my_object_test2 (MyObjectFixture *fixture,
                      gconstpointer user_data)
{
  my_object_do_some_work_using_helper (fixture-&gt;obj, fixture-&gt;helper);
  g_assert_cmpstr (my_object_get_property (fixture-&gt;obj), ==, "updated-value");
}

int
main (int argc, char *argv[])
{
  setlocale (LC_ALL, "");

  g_test_init (&amp;argc, &amp;argv, NULL);

  // Define the tests.
  g_test_add ("/my-object/test1", MyObjectFixture, "some-user-data",
              my_object_fixture_set_up, test_my_object_test1,
              my_object_fixture_tear_down);
  g_test_add ("/my-object/test2", MyObjectFixture, "some-user-data",
              my_object_fixture_set_up, test_my_object_test2,
              my_object_fixture_tear_down);

  return g_test_run ();
}
]|

### Integrating GTest in your project

If you are using the [Meson](http://mesonbuild.com) build system, you will
typically use the provided `test()` primitive to call the test binaries,
e.g.:

|[&lt;!-- language="plain" --&gt;
  test(
    'foo',
    executable('foo', 'foo.c', dependencies: deps),
    env: [
      'G_TEST_SRCDIR=@0@'.format(meson.current_source_dir()),
      'G_TEST_BUILDDIR=@0@'.format(meson.current_build_dir()),
    ],
  )

  test(
    'bar',
    executable('bar', 'bar.c', dependencies: deps),
    env: [
      'G_TEST_SRCDIR=@0@'.format(meson.current_source_dir()),
      'G_TEST_BUILDDIR=@0@'.format(meson.current_build_dir()),
    ],
  )
]|

If you are using Autotools, you're strongly encouraged to use the Automake
[TAP](https://testanything.org/) harness; GLib provides template files for
easily integrating with it:

  - [glib-tap.mk](https://gitlab.gnome.org/GNOME/glib/blob/glib-2-58/glib-tap.mk)
  - [tap-test](https://gitlab.gnome.org/GNOME/glib/blob/glib-2-58/tap-test)
  - [tap-driver.sh](https://gitlab.gnome.org/GNOME/glib/blob/glib-2-58/tap-driver.sh)

You can copy these files in your own project's root directory, and then
set up your `Makefile.am` file to reference them, for instance:

|[&lt;!-- language="plain" --&gt;
include $(top_srcdir)/glib-tap.mk

# test binaries
test_programs = \
  foo \
  bar

# data distributed in the tarball
dist_test_data = \
  foo.data.txt \
  bar.data.txt

# data not distributed in the tarball
test_data = \
  blah.data.txt
]|

Make sure to distribute the TAP files, using something like the following
in your top-level `Makefile.am`:

|[&lt;!-- language="plain" --&gt;
EXTRA_DIST += \
  tap-driver.sh \
  tap-test
]|

`glib-tap.mk` will be distributed implicitly due to being included in a
`Makefile.am`. All three files should be added to version control.

If you don't have access to the Autotools TAP harness, you can use the
[gtester][gtester] and [gtester-report][gtester-report] tools, and use
the [glib.mk](https://gitlab.gnome.org/GNOME/glib/blob/glib-2-58/glib.mk)
Automake template provided by GLib. Note, however, that since GLib 2.62,
[gtester][gtester] and [gtester-report][gtester-report] have been deprecated
in favour of using TAP. The `--tap` argument to tests is enabled by default
as of GLib 2.62.</doc>
    </docsection>
    <docsection name="thread_pools" gs:managed-name="ThreadPools">
      <doc xml:space="preserve" filename="glib-2.0.c" line="8475">Sometimes you wish to asynchronously fork out the execution of work
and continue working in your own thread. If that will happen often,
the overhead of starting and destroying a thread each time might be
too high. In such cases reusing already started threads seems like a
good idea. And it indeed is, but implementing this can be tedious
and error-prone.

Therefore GLib provides thread pools for your convenience. An added
advantage is, that the threads can be shared between the different
subsystems of your program, when they are using GLib.

To create a new thread pool, you use g_thread_pool_new().
It is destroyed by g_thread_pool_free().

If you want to execute a certain task within a thread pool,
you call g_thread_pool_push().

To get the current number of running threads you call
g_thread_pool_get_num_threads(). To get the number of still
unprocessed tasks you call g_thread_pool_unprocessed(). To control
the maximal number of threads for a thread pool, you use
g_thread_pool_get_max_threads() and g_thread_pool_set_max_threads().

Finally you can control the number of unused threads, that are kept
alive by GLib for future use. The current number can be fetched with
g_thread_pool_get_num_unused_threads(). The maximal number can be
controlled by g_thread_pool_get_max_unused_threads() and
g_thread_pool_set_max_unused_threads(). All currently unused threads
can be stopped by calling g_thread_pool_stop_unused_threads().</doc>
    </docsection>
    <docsection name="threads" gs:managed-name="Threads">
      <doc xml:space="preserve" filename="glib-2.0.c" line="8513">Threads act almost like processes, but unlike processes all threads
of one process share the same memory. This is good, as it provides
easy communication between the involved threads via this shared
memory, and it is bad, because strange things (so called
"Heisenbugs") might happen if the program is not carefully designed.
In particular, due to the concurrent nature of threads, no
assumptions on the order of execution of code running in different
threads can be made, unless order is explicitly forced by the
programmer through synchronization primitives.

The aim of the thread-related functions in GLib is to provide a
portable means for writing multi-threaded software. There are
primitives for mutexes to protect the access to portions of memory
(#GMutex, #GRecMutex and #GRWLock). There is a facility to use
individual bits for locks (g_bit_lock()). There are primitives
for condition variables to allow synchronization of threads (#GCond).
There are primitives for thread-private data - data that every
thread has a private instance of (#GPrivate). There are facilities
for one-time initialization (#GOnce, g_once_init_enter()). Finally,
there are primitives to create and manage threads (#GThread).

The GLib threading system used to be initialized with g_thread_init().
This is no longer necessary. Since version 2.32, the GLib threading
system is automatically initialized at the start of your program,
and all thread-creation functions and synchronization primitives
are available right away.

Note that it is not safe to assume that your program has no threads
even if you don't call g_thread_new() yourself. GLib and GIO can
and will create threads for their own purposes in some cases, such
as when using g_unix_signal_source_new() or when using GDBus.

Originally, UNIX did not have threads, and therefore some traditional
UNIX APIs are problematic in threaded programs. Some notable examples
are

- C library functions that return data in statically allocated
  buffers, such as strtok() or strerror(). For many of these,
  there are thread-safe variants with a _r suffix, or you can
  look at corresponding GLib APIs (like g_strsplit() or g_strerror()).

- The functions setenv() and unsetenv() manipulate the process
  environment in a not thread-safe way, and may interfere with getenv()
  calls in other threads. Note that getenv() calls may be hidden behind
  other APIs. For example, GNU gettext() calls getenv() under the
  covers. In general, it is best to treat the environment as readonly.
  If you absolutely have to modify the environment, do it early in
  main(), when no other threads are around yet.

- The setlocale() function changes the locale for the entire process,
  affecting all threads. Temporary changes to the locale are often made
  to change the behavior of string scanning or formatting functions
  like scanf() or printf(). GLib offers a number of string APIs
  (like g_ascii_formatd() or g_ascii_strtod()) that can often be
  used as an alternative. Or you can use the uselocale() function
  to change the locale only for the current thread.

- The fork() function only takes the calling thread into the child's
  copy of the process image. If other threads were executing in critical
  sections they could have left mutexes locked which could easily
  cause deadlocks in the new child. For this reason, you should
  call exit() or exec() as soon as possible in the child and only
  make signal-safe library calls before that.

- The daemon() function uses fork() in a way contrary to what is
  described above. It should not be used with GLib programs.

GLib itself is internally completely thread-safe (all global data is
automatically locked), but individual data structure instances are
not automatically locked for performance reasons. For example,
you must coordinate accesses to the same #GHashTable from multiple
threads. The two notable exceptions from this rule are #GMainLoop
and #GAsyncQueue, which are thread-safe and need no further
application-level locking to be accessed from multiple threads.
Most refcounting functions such as g_object_ref() are also thread-safe.

A common use for #GThreads is to move a long-running blocking operation out
of the main thread and into a worker thread. For GLib functions, such as
single GIO operations, this is not necessary, and complicates the code.
Instead, the `…_async()` version of the function should be used from the main
thread, eliminating the need for locking and synchronisation between multiple
threads. If an operation does need to be moved to a worker thread, consider
using g_task_run_in_thread(), or a #GThreadPool. #GThreadPool is often a
better choice than #GThread, as it handles thread reuse and task queueing;
#GTask uses this internally.

However, if multiple blocking operations need to be performed in sequence,
and it is not possible to use #GTask for them, moving them to a worker thread
can clarify the code.</doc>
    </docsection>
    <docsection name="timers" gs:managed-name="Timers">
      <doc xml:space="preserve" filename="glib-2.0.c" line="8612">#GTimer records a start time, and counts microseconds elapsed since
that time. This is done somewhat differently on different platforms,
and can be tricky to get exactly right, so #GTimer provides a
portable/convenient interface.</doc>
    </docsection>
    <docsection name="timezone" gs:managed-name="Timezone">
      <doc xml:space="preserve" filename="glib-2.0.c" line="8624">#GTimeZone is a structure that represents a time zone, at no
particular point in time.  It is refcounted and immutable.

Each time zone has an identifier (for example, ‘Europe/London’) which is
platform dependent. See g_time_zone_new() for information on the identifier
formats. The identifier of a time zone can be retrieved using
g_time_zone_get_identifier().

A time zone contains a number of intervals.  Each interval has
an abbreviation to describe it (for example, ‘PDT’), an offset to UTC and a
flag indicating if the daylight savings time is in effect during that
interval.  A time zone always has at least one interval — interval 0. Note
that interval abbreviations are not the same as time zone identifiers
(apart from ‘UTC’), and cannot be passed to g_time_zone_new().

Every UTC time is contained within exactly one interval, but a given
local time may be contained within zero, one or two intervals (due to
incontinuities associated with daylight savings time).

An interval may refer to a specific period of time (eg: the duration
of daylight savings time during 2010) or it may refer to many periods
of time that share the same properties (eg: all periods of daylight
savings time).  It is also possible (usually for political reasons)
that some properties (like the abbreviation) change between intervals
without other properties changing.

#GTimeZone is available since GLib 2.26.</doc>
    </docsection>
    <docsection name="trash_stack" gs:managed-name="TrashStack">
      <doc xml:space="preserve" filename="glib-2.0.c" line="8660">A #GTrashStack is an efficient way to keep a stack of unused allocated
memory chunks. Each memory chunk is required to be large enough to hold
a #gpointer. This allows the stack to be maintained without any space
overhead, since the stack pointers can be stored inside the memory chunks.

There is no function to create a #GTrashStack. A %NULL #GTrashStack*
is a perfectly valid empty stack.

There is no longer any good reason to use #GTrashStack.  If you have
extra pieces of memory, free() them and allocate them again later.</doc>
    </docsection>
    <docsection name="trees-binary" gs:managed-name="TreesBinary">
      <doc xml:space="preserve" filename="glib-2.0.c" line="8680">The #GTree structure and its associated functions provide a sorted
collection of key/value pairs optimized for searching and traversing
in order. This means that most of the operations  (access, search,
insertion, deletion, ...) on #GTree are O(log(n)) in average and O(n)
in worst case for time complexity. But, note that maintaining a
balanced sorted #GTree of n elements is done in time O(n log(n)).

To create a new #GTree use g_tree_new().

To insert a key/value pair into a #GTree use g_tree_insert()
(O(n log(n))).

To remove a key/value pair use g_tree_remove() (O(n log(n))).

To look up the value corresponding to a given key, use
g_tree_lookup() and g_tree_lookup_extended().

To find out the number of nodes in a #GTree, use g_tree_nnodes(). To
get the height of a #GTree, use g_tree_height().

To traverse a #GTree, calling a function for each node visited in
the traversal, use g_tree_foreach().

To destroy a #GTree, use g_tree_destroy().</doc>
    </docsection>
    <docsection name="trees-nary" gs:managed-name="TreesNary">
      <doc xml:space="preserve" filename="glib-2.0.c" line="8713">The #GNode struct and its associated functions provide a N-ary tree
data structure, where nodes in the tree can contain arbitrary data.

To create a new tree use g_node_new().

To insert a node into a tree use g_node_insert(),
g_node_insert_before(), g_node_append() and g_node_prepend().

To create a new node and insert it into a tree use
g_node_insert_data(), g_node_insert_data_after(),
g_node_insert_data_before(), g_node_append_data()
and g_node_prepend_data().

To reverse the children of a node use g_node_reverse_children().

To find a node use g_node_get_root(), g_node_find(),
g_node_find_child(), g_node_child_index(), g_node_child_position(),
g_node_first_child(), g_node_last_child(), g_node_nth_child(),
g_node_first_sibling(), g_node_prev_sibling(), g_node_next_sibling()
or g_node_last_sibling().

To get information about a node or tree use G_NODE_IS_LEAF(),
G_NODE_IS_ROOT(), g_node_depth(), g_node_n_nodes(),
g_node_n_children(), g_node_is_ancestor() or g_node_max_height().

To traverse a tree, calling a function for each node visited in the
traversal, use g_node_traverse() or g_node_children_foreach().

To remove a node or subtree from a tree use g_node_unlink() or
g_node_destroy().</doc>
    </docsection>
    <docsection name="type_conversion" gs:managed-name="TypeConversion">
      <doc xml:space="preserve" filename="glib-2.0.c" line="8751">Many times GLib, GTK+, and other libraries allow you to pass "user
data" to a callback, in the form of a void pointer. From time to time
you want to pass an integer instead of a pointer. You could allocate
an integer, with something like:
|[&lt;!-- language="C" --&gt;
  int *ip = g_new (int, 1);
  *ip = 42;
]|
But this is inconvenient, and it's annoying to have to free the
memory at some later time.

Pointers are always at least 32 bits in size (on all platforms GLib
intends to support). Thus you can store at least 32-bit integer values
in a pointer value. Naively, you might try this, but it's incorrect:
|[&lt;!-- language="C" --&gt;
  gpointer p;
  int i;
  p = (void*) 42;
  i = (int) p;
]|
Again, that example was not correct, don't copy it.
The problem is that on some systems you need to do this:
|[&lt;!-- language="C" --&gt;
  gpointer p;
  int i;
  p = (void*) (long) 42;
  i = (int) (long) p;
]|
The GLib macros GPOINTER_TO_INT(), GINT_TO_POINTER(), etc. take care
to do the right thing on every platform.

Warning: You may not store pointers in integers. This is not
portable in any way, shape or form. These macros only allow storing
integers in pointers, and only preserve 32 bits of the integer; values
outside the range of a 32-bit integer will be mangled.</doc>
    </docsection>
    <docsection name="types" gs:managed-name="Types">
      <doc xml:space="preserve" filename="glib-2.0.c" line="8794">GLib defines a number of commonly used types, which can be divided
into several groups:
- New types which are not part of standard C (but are defined in
  various C standard library header files) — #gboolean, #gssize.
- Integer types which are guaranteed to be the same size across
  all platforms — #gint8, #guint8, #gint16, #guint16, #gint32,
  #guint32, #gint64, #guint64.
- Types which are easier to use than their standard C counterparts -
  #gpointer, #gconstpointer, #guchar, #guint, #gushort, #gulong.
- Types which correspond exactly to standard C types, but are
  included for completeness — #gchar, #gint, #gshort, #glong,
  #gfloat, #gdouble.
- Types which correspond exactly to standard C99 types, but are available
  to use even if your compiler does not support C99 — #gsize, #goffset,
  #gintptr, #guintptr.

GLib also defines macros for the limits of some of the standard
integer and floating point types, as well as macros for suitable
printf() formats for these types.

Note that depending on the platform and build configuration, the format
macros might not be compatible with the system provided printf() function,
because GLib might use a different printf() implementation internally.
The format macros will always work with GLib API (like g_print()), and with
any C99 compatible printf() implementation.</doc>
    </docsection>
    <docsection name="unicode" gs:managed-name="Unicode">
      <doc xml:space="preserve" filename="glib-2.0.c" line="8828">This section describes a number of functions for dealing with
Unicode characters and strings. There are analogues of the
traditional `ctype.h` character classification and case conversion
functions, UTF-8 analogues of some string utility functions,
functions to perform normalization, case conversion and collation
on UTF-8 strings and finally functions to convert between the UTF-8,
UTF-16 and UCS-4 encodings of Unicode.

The implementations of the Unicode functions in GLib are based
on the Unicode Character Data tables, which are available from
[www.unicode.org](http://www.unicode.org/).

 * Unicode 4.0 was added in GLib 2.8
 * Unicode 4.1 was added in GLib 2.10
 * Unicode 5.0 was added in GLib 2.12
 * Unicode 5.1 was added in GLib 2.16.3
 * Unicode 6.0 was added in GLib 2.30
 * Unicode 6.1 was added in GLib 2.32
 * Unicode 6.2 was added in GLib 2.36
 * Unicode 6.3 was added in GLib 2.40
 * Unicode 7.0 was added in GLib 2.42
 * Unicode 8.0 was added in GLib 2.48
 * Unicode 9.0 was added in GLib 2.50.1
 * Unicode 10.0 was added in GLib 2.54
 * Unicode 11.10 was added in GLib 2.58
 * Unicode 12.0 was added in GLib 2.62
 * Unicode 12.1 was added in GLib 2.62
 * Unicode 13.0 was added in GLib 2.66</doc>
    </docsection>
    <docsection name="uuid" gs:managed-name="Uuid">
      <doc xml:space="preserve" filename="glib-2.0.c" line="8866">A UUID, or Universally unique identifier, is intended to uniquely
identify information in a distributed environment. For the
definition of UUID, see [RFC 4122](https://tools.ietf.org/html/rfc4122.html).

The creation of UUIDs does not require a centralized authority.

UUIDs are of relatively small size (128 bits, or 16 bytes). The
common string representation (ex:
1d6c0810-2bd6-45f3-9890-0268422a6f14) needs 37 bytes.

The UUID specification defines 5 versions, and calling
g_uuid_string_random() will generate a unique (or rather random)
UUID of the most common version, version 4.</doc>
    </docsection>
    <docsection name="version" gs:managed-name="Version">
      <doc xml:space="preserve" filename="glib-2.0.c" line="8889">GLib provides version information, primarily useful in configure
checks for builds that have a configure script. Applications will
not typically use the features described here.

The GLib headers annotate deprecated APIs in a way that produces
compiler warnings if these deprecated APIs are used. The warnings
can be turned off by defining the macro %GLIB_DISABLE_DEPRECATION_WARNINGS
before including the glib.h header.

GLib also provides support for building applications against
defined subsets of deprecated or new GLib APIs. Define the macro
%GLIB_VERSION_MIN_REQUIRED to specify up to what version of GLib
you want to receive warnings about deprecated APIs. Define the
macro %GLIB_VERSION_MAX_ALLOWED to specify the newest version of
GLib whose API you want to use.</doc>
    </docsection>
    <docsection name="warnings" gs:managed-name="Warnings">
      <doc xml:space="preserve" filename="glib-2.0.c" line="8912">GLib defines several warning functions and assertions which can be used to
warn of programmer errors when calling functions, and print error messages
from command line programs.

The g_return_if_fail(), g_return_val_if_fail(), g_return_if_reached() and
g_return_val_if_reached() macros are intended as pre-condition assertions, to
be used at the top of a public function to check that the function’s
arguments are acceptable. Any failure of such a pre-condition assertion is
considered a programming error on the part of the caller of the public API,
and the program is considered to be in an undefined state afterwards. They
are similar to the libc assert() function, but provide more context on
failures.

For example:
|[&lt;!-- language="C" --&gt;
gboolean
g_dtls_connection_shutdown (GDtlsConnection  *conn,
                            gboolean          shutdown_read,
                            gboolean          shutdown_write,
                            GCancellable     *cancellable,
                            GError          **error)
{
  // local variable declarations

  g_return_val_if_fail (G_IS_DTLS_CONNECTION (conn), FALSE);
  g_return_val_if_fail (cancellable == NULL || G_IS_CANCELLABLE (cancellable), FALSE);
  g_return_val_if_fail (error == NULL || *error == NULL, FALSE);

  // function body

  return return_val;
}
]|

g_print(), g_printerr() and g_set_print_handler() are intended to be used for
output from command line applications, since they output to standard output
and standard error by default — whereas functions like g_message() and
g_log() may be redirected to special purpose message windows, files, or the
system journal.</doc>
    </docsection>
    <docsection name="windows" gs:managed-name="Windows">
      <doc xml:space="preserve" filename="glib-2.0.c" line="8959">These functions provide some level of UNIX emulation on the
Windows platform. If your application really needs the POSIX
APIs, we suggest you try the Cygwin project.</doc>
    </docsection>
    <gs:static-class name="IdleSource" gs:managed-name="IdleSource">
      <function name="new" c:identifier="g_idle_source_new" gs:dll-name="glib-2.0" gs:managed-name="New">
        <doc xml:space="preserve" filename="glib-2.0.c" line="18970">Creates a new idle source.

The source will not initially be associated with any #GMainContext
and must be added to one with g_source_attach() before it will be
executed. Note that the default priority for idle sources is
%G_PRIORITY_DEFAULT_IDLE, as compared to other sources which
have a default priority of %G_PRIORITY_DEFAULT.</doc>
        <source-position filename="gmain.h" line="669" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="18981">the newly-created idle source</doc>
          <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </gs:static-class>
    <gs:static-class name="UnicharExtensions" gs:managed-name="UnicharExtensions">
      <constant name="MAX_DECOMPOSITION_LENGTH" value="18" c:type="G_UNICHAR_MAX_DECOMPOSITION_LENGTH" version="2.32" gs:access-modifiers="private" gs:managed-name="maxDecompositionLength">
        <doc xml:space="preserve" filename="gunicode.h" line="729">The maximum length (in codepoints) of a compatibility or canonical
decomposition of a single Unicode character.

This is as defined by Unicode 6.1.</doc>
        <source-position filename="gunicode.h" line="739" />
        <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
      </constant>
      <method name="break_type" c:identifier="g_unichar_break_type" gs:dll-name="glib-2.0" gs:managed-name="BreakType" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="35137">Determines the break type of @c. @c should be a Unicode character
(to derive a character from UTF-8 encoded text, use
g_utf8_get_char()). The break type is used to find word and line
breaks ("text boundaries"), Pango implements the Unicode boundary
resolution algorithms and normally you would use a function such
as pango_break() instead of caring about break types yourself.</doc>
        <source-position filename="gunicode.h" line="696" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="35148">the break type of @c</doc>
          <type name="UnicodeBreakType" c:type="GUnicodeBreakType" gs:managed-name="UnicodeBreakType" />
        </return-value>
        <parameters>
          <instance-parameter name="c" transfer-ownership="none" gs:managed-name="c" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35139">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="c" transfer-ownership="none" gs:managed-name="c" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35139">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="combining_class" c:identifier="g_unichar_combining_class" version="2.14" gs:dll-name="glib-2.0" gs:managed-name="CombiningClass" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="35152">Determines the canonical combining class of a Unicode character.</doc>
        <source-position filename="gunicode.h" line="700" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="35158">the combining class of the character</doc>
          <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="uc" transfer-ownership="none" gs:managed-name="uc" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35154">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="uc" transfer-ownership="none" gs:managed-name="uc" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35154">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="compose" c:identifier="g_unichar_compose" version="2.30" gs:dll-name="glib-2.0" gs:managed-name="TryCompose" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="35163">Performs a single composition step of the
Unicode canonical composition algorithm.

This function includes algorithmic Hangul Jamo composition,
but it is not exactly the inverse of g_unichar_decompose().
No composition can have either of @a or @b equal to zero.
To be precise, this function composes if and only if
there exists a Primary Composite P which is canonically
equivalent to the sequence &lt;@a,@b&gt;.  See the Unicode
Standard for the definition of Primary Composite.

If @a and @b do not compose a new character, @ch is set to zero.

See
[UAX#15](http://unicode.org/reports/tr15/)
for details.</doc>
        <source-position filename="gunicode.h" line="715" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="35186">%TRUE if the characters could be composed</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none" gs:managed-name="a" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35165">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
          <parameter name="b" transfer-ownership="none" gs:managed-name="b" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35166">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </parameter>
          <parameter name="ch" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="ch">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35167">return location for the composed character</doc>
            <type name="gunichar" c:type="gunichar*" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="a" transfer-ownership="none" gs:managed-name="a" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35165">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
          <parameter name="b" transfer-ownership="none" gs:managed-name="b" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35166">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </parameter>
          <parameter name="ch" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="ch">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35167">return location for the composed character</doc>
            <type name="gunichar" c:type="gunichar*" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="decompose" c:identifier="g_unichar_decompose" version="2.30" gs:dll-name="glib-2.0" gs:managed-name="TryDecompose" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="35191">Performs a single decomposition step of the
Unicode canonical decomposition algorithm.

This function does not include compatibility
decompositions. It does, however, include algorithmic
Hangul Jamo decomposition, as well as 'singleton'
decompositions which replace a character by a single
other character. In the case of singletons *@b will
be set to zero.

If @ch is not decomposable, *@a is set to @ch and *@b
is set to zero.

Note that the way Unicode decomposition pairs are
defined, it is guaranteed that @b would not decompose
further, but @a may itself decompose.  To get the full
canonical decomposition for @ch, one would need to
recursively call this function on @a.  Or use
g_unichar_fully_decompose().

See
[UAX#15](http://unicode.org/reports/tr15/)
for details.</doc>
        <source-position filename="gunicode.h" line="719" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="35221">%TRUE if the character could be decomposed</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="ch" transfer-ownership="none" gs:managed-name="ch" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35193">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
          <parameter name="a" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="a">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35194">return location for the first component of @ch</doc>
            <type name="gunichar" c:type="gunichar*" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </parameter>
          <parameter name="b" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="b">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35195">return location for the second component of @ch</doc>
            <type name="gunichar" c:type="gunichar*" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="ch" transfer-ownership="none" gs:managed-name="ch" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35193">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
          <parameter name="a" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="a">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35194">return location for the first component of @ch</doc>
            <type name="gunichar" c:type="gunichar*" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </parameter>
          <parameter name="b" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="b">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35195">return location for the second component of @ch</doc>
            <type name="gunichar" c:type="gunichar*" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="digit_value" c:identifier="g_unichar_digit_value" gs:dll-name="glib-2.0" gs:managed-name="DigitValue" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="35226">Determines the numeric value of a character as a decimal
digit.</doc>
        <source-position filename="gunicode.h" line="685" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="35233">If @c is a decimal digit (according to
g_unichar_isdigit()), its numeric value. Otherwise, -1.</doc>
          <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="c" transfer-ownership="none" gs:managed-name="c" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35228">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="c" transfer-ownership="none" gs:managed-name="c" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35228">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="fully_decompose" c:identifier="g_unichar_fully_decompose" version="2.30" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="FullyDecompose" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="35238">Computes the canonical or compatibility decomposition of a
Unicode character.  For compatibility decomposition,
pass %TRUE for @compat; for canonical decomposition
pass %FALSE for @compat.

The decomposed sequence is placed in @result.  Only up to
@result_len characters are written into @result.  The length
of the full decomposition (irrespective of @result_len) is
returned by the function.  For canonical decomposition,
currently all decompositions are of length at most 4, but
this may change in the future (very unlikely though).
At any rate, Unicode does guarantee that a buffer of length
18 is always enough for both compatibility and canonical
decompositions, so that is the size recommended. This is provided
as %G_UNICHAR_MAX_DECOMPOSITION_LENGTH.

See
[UAX#15](http://unicode.org/reports/tr15/)
for details.</doc>
        <source-position filename="gunicode.h" line="724" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="35265">the length of the full decomposition.</doc>
          <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="ch" transfer-ownership="none" gs:managed-name="ch" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35240">a Unicode character.</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
          <parameter name="compat" transfer-ownership="none" gs:managed-name="compat" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35241">whether perform canonical or compatibility decomposition</doc>
            <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
          </parameter>
          <parameter name="result" direction="out" caller-allocates="1" transfer-ownership="none" optional="1" allow-none="1" gs:managed-name="result">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35242">location to store decomposed result, or %NULL</doc>
            <array length="2" zero-terminated="0" c:type="gunichar*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
            </array>
          </parameter>
          <parameter name="result_len" transfer-ownership="none" gs:managed-name="resultLen" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35243">length of @result</doc>
            <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="ch" transfer-ownership="none" gs:managed-name="ch" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35240">a Unicode character.</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
          <parameter name="compat" transfer-ownership="none" gs:managed-name="compat" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35241">whether perform canonical or compatibility decomposition</doc>
            <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
          </parameter>
          <parameter name="result" direction="out" caller-allocates="1" transfer-ownership="none" optional="1" allow-none="1" gs:managed-name="result">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35242">location to store decomposed result, or %NULL</doc>
            <array length="2" zero-terminated="0" c:type="gunichar*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
            </array>
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_mirror_char" c:identifier="g_unichar_get_mirror_char" version="2.4" gs:dll-name="glib-2.0" gs:managed-name="TryGetMirrorChar" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="35270">In Unicode, some characters are "mirrored". This means that their
images are mirrored horizontally in text that is laid out from right
to left. For instance, "(" would become its mirror image, ")", in
right-to-left text.

If @ch has the Unicode mirrored property and there is another unicode
character that typically has a glyph that is the mirror image of @ch's
glyph and @mirrored_ch is set, it puts that character in the address
pointed to by @mirrored_ch.  Otherwise the original character is put.</doc>
        <source-position filename="gunicode.h" line="703" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="35285">%TRUE if @ch has a mirrored character, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="ch" transfer-ownership="none" gs:managed-name="ch" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35272">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
          <parameter name="mirrored_ch" transfer-ownership="none" direction="out" gs:managed-name="mirroredCh">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35273">location to store the mirrored character</doc>
            <type name="gunichar" c:type="gunichar*" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="ch" transfer-ownership="none" gs:managed-name="ch" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35272">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
          <parameter name="mirrored_ch" transfer-ownership="none" direction="out" gs:managed-name="mirroredCh">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35273">location to store the mirrored character</doc>
            <type name="gunichar" c:type="gunichar*" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_script" c:identifier="g_unichar_get_script" version="2.14" gs:dll-name="glib-2.0" gs:managed-name="GetScript" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="35290">Looks up the #GUnicodeScript for a particular character (as defined
by Unicode Standard Annex \#24). No check is made for @ch being a
valid Unicode character; if you pass in invalid character, the
result is undefined.

This function is equivalent to pango_script_for_unichar() and the
two are interchangeable.</doc>
        <source-position filename="gunicode.h" line="707" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="35302">the #GUnicodeScript for the character.</doc>
          <type name="UnicodeScript" c:type="GUnicodeScript" gs:managed-name="UnicodeScript" />
        </return-value>
        <parameters>
          <instance-parameter name="ch" transfer-ownership="none" gs:managed-name="ch" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35292">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="ch" transfer-ownership="none" gs:managed-name="ch" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35292">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="is_alpha_numeric" c:identifier="g_unichar_isalnum" gs:dll-name="glib-2.0" gs:managed-name="IsAlphaNumeric" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="35307">Determines whether a character is alphanumeric.
Given some UTF-8 text, obtain a character value
with g_utf8_get_char().</doc>
        <source-position filename="gunicode.h" line="639" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="35315">%TRUE if @c is an alphanumeric character</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="c" transfer-ownership="none" gs:managed-name="c" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35309">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="c" transfer-ownership="none" gs:managed-name="c" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35309">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="is_alpha" c:identifier="g_unichar_isalpha" gs:dll-name="glib-2.0" gs:managed-name="IsAlpha" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="35319">Determines whether a character is alphabetic (i.e. a letter).
Given some UTF-8 text, obtain a character value with
g_utf8_get_char().</doc>
        <source-position filename="gunicode.h" line="641" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="35327">%TRUE if @c is an alphabetic character</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="c" transfer-ownership="none" gs:managed-name="c" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35321">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="c" transfer-ownership="none" gs:managed-name="c" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35321">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="is_control" c:identifier="g_unichar_iscntrl" gs:dll-name="glib-2.0" gs:managed-name="IsControl" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="35331">Determines whether a character is a control character.
Given some UTF-8 text, obtain a character value with
g_utf8_get_char().</doc>
        <source-position filename="gunicode.h" line="643" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="35339">%TRUE if @c is a control character</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="c" transfer-ownership="none" gs:managed-name="c" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35333">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="c" transfer-ownership="none" gs:managed-name="c" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35333">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="is_defined" c:identifier="g_unichar_isdefined" gs:dll-name="glib-2.0" gs:managed-name="IsDefined" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="35343">Determines if a given character is assigned in the Unicode
standard.</doc>
        <source-position filename="gunicode.h" line="663" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="35350">%TRUE if the character has an assigned value</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="c" transfer-ownership="none" gs:managed-name="c" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35345">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="c" transfer-ownership="none" gs:managed-name="c" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35345">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="is_digit" c:identifier="g_unichar_isdigit" gs:dll-name="glib-2.0" gs:managed-name="IsDigit" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="35354">Determines whether a character is numeric (i.e. a digit).  This
covers ASCII 0-9 and also digits in other languages/scripts.  Given
some UTF-8 text, obtain a character value with g_utf8_get_char().</doc>
        <source-position filename="gunicode.h" line="645" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="35362">%TRUE if @c is a digit</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="c" transfer-ownership="none" gs:managed-name="c" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35356">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="c" transfer-ownership="none" gs:managed-name="c" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35356">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="is_graph" c:identifier="g_unichar_isgraph" gs:dll-name="glib-2.0" gs:managed-name="IsGraph" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="35366">Determines whether a character is printable and not a space
(returns %FALSE for control characters, format characters, and
spaces). g_unichar_isprint() is similar, but returns %TRUE for
spaces. Given some UTF-8 text, obtain a character value with
g_utf8_get_char().</doc>
        <source-position filename="gunicode.h" line="647" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="35376">%TRUE if @c is printable unless it's a space</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="c" transfer-ownership="none" gs:managed-name="c" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35368">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="c" transfer-ownership="none" gs:managed-name="c" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35368">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="is_lower" c:identifier="g_unichar_islower" gs:dll-name="glib-2.0" gs:managed-name="IsLower" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="35380">Determines whether a character is a lowercase letter.
Given some UTF-8 text, obtain a character value with
g_utf8_get_char().</doc>
        <source-position filename="gunicode.h" line="649" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="35388">%TRUE if @c is a lowercase letter</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="c" transfer-ownership="none" gs:managed-name="c" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35382">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="c" transfer-ownership="none" gs:managed-name="c" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35382">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="is_mark" c:identifier="g_unichar_ismark" version="2.14" gs:dll-name="glib-2.0" gs:managed-name="IsMark" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="35392">Determines whether a character is a mark (non-spacing mark,
combining mark, or enclosing mark in Unicode speak).
Given some UTF-8 text, obtain a character value
with g_utf8_get_char().

Note: in most cases where isalpha characters are allowed,
ismark characters should be allowed to as they are essential
for writing most European languages as well as many non-Latin
scripts.</doc>
        <source-position filename="gunicode.h" line="671" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="35406">%TRUE if @c is a mark character</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="c" transfer-ownership="none" gs:managed-name="c" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35394">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="c" transfer-ownership="none" gs:managed-name="c" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35394">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="is_printable" c:identifier="g_unichar_isprint" gs:dll-name="glib-2.0" gs:managed-name="IsPrintable" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="35411">Determines whether a character is printable.
Unlike g_unichar_isgraph(), returns %TRUE for spaces.
Given some UTF-8 text, obtain a character value with
g_utf8_get_char().</doc>
        <source-position filename="gunicode.h" line="651" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="35420">%TRUE if @c is printable</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="c" transfer-ownership="none" gs:managed-name="c" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35413">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="c" transfer-ownership="none" gs:managed-name="c" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35413">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="is_punctuation" c:identifier="g_unichar_ispunct" gs:dll-name="glib-2.0" gs:managed-name="IsPunctuation" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="35424">Determines whether a character is punctuation or a symbol.
Given some UTF-8 text, obtain a character value with
g_utf8_get_char().</doc>
        <source-position filename="gunicode.h" line="653" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="35432">%TRUE if @c is a punctuation or symbol character</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="c" transfer-ownership="none" gs:managed-name="c" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35426">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="c" transfer-ownership="none" gs:managed-name="c" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35426">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="is_space" c:identifier="g_unichar_isspace" gs:dll-name="glib-2.0" gs:managed-name="IsSpace" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="35436">Determines whether a character is a space, tab, or line separator
(newline, carriage return, etc.).  Given some UTF-8 text, obtain a
character value with g_utf8_get_char().

(Note: don't use this to do word breaking; you have to use
Pango or equivalent to get word breaking right, the algorithm
is fairly complex.)</doc>
        <source-position filename="gunicode.h" line="655" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="35448">%TRUE if @c is a space character</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="c" transfer-ownership="none" gs:managed-name="c" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35438">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="c" transfer-ownership="none" gs:managed-name="c" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35438">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="is_title" c:identifier="g_unichar_istitle" gs:dll-name="glib-2.0" gs:managed-name="IsTitle" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="35452">Determines if a character is titlecase. Some characters in
Unicode which are composites, such as the DZ digraph
have three case variants instead of just two. The titlecase
form is used at the beginning of a word where only the
first letter is capitalized. The titlecase form of the DZ
digraph is U+01F2 LATIN CAPITAL LETTTER D WITH SMALL LETTER Z.</doc>
        <source-position filename="gunicode.h" line="661" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="35463">%TRUE if the character is titlecase</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="c" transfer-ownership="none" gs:managed-name="c" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35454">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="c" transfer-ownership="none" gs:managed-name="c" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35454">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="is_upper" c:identifier="g_unichar_isupper" gs:dll-name="glib-2.0" gs:managed-name="IsUpper" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="35467">Determines if a character is uppercase.</doc>
        <source-position filename="gunicode.h" line="657" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="35473">%TRUE if @c is an uppercase character</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="c" transfer-ownership="none" gs:managed-name="c" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35469">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="c" transfer-ownership="none" gs:managed-name="c" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35469">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="is_wide" c:identifier="g_unichar_iswide" gs:dll-name="glib-2.0" gs:managed-name="IsWide" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="35477">Determines if a character is typically rendered in a double-width
cell.</doc>
        <source-position filename="gunicode.h" line="665" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="35484">%TRUE if the character is wide</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="c" transfer-ownership="none" gs:managed-name="c" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35479">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="c" transfer-ownership="none" gs:managed-name="c" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35479">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="is_wide_cjk" c:identifier="g_unichar_iswide_cjk" version="2.12" gs:dll-name="glib-2.0" gs:managed-name="IsWideCjk" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="35488">Determines if a character is typically rendered in a double-width
cell under legacy East Asian locales.  If a character is wide according to
g_unichar_iswide(), then it is also reported wide with this function, but
the converse is not necessarily true. See the
[Unicode Standard Annex #11](http://www.unicode.org/reports/tr11/)
for details.

If a character passes the g_unichar_iswide() test then it will also pass
this test, but not the other way around.  Note that some characters may
pass both this test and g_unichar_iszerowidth().</doc>
        <source-position filename="gunicode.h" line="667" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="35503">%TRUE if the character is wide in legacy East Asian locales</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="c" transfer-ownership="none" gs:managed-name="c" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35490">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="c" transfer-ownership="none" gs:managed-name="c" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35490">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="is_hex_digit" c:identifier="g_unichar_isxdigit" gs:dll-name="glib-2.0" gs:managed-name="IsHexDigit" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="35508">Determines if a character is a hexadecimal digit.</doc>
        <source-position filename="gunicode.h" line="659" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="35514">%TRUE if the character is a hexadecimal digit</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="c" transfer-ownership="none" gs:managed-name="c" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35510">a Unicode character.</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="c" transfer-ownership="none" gs:managed-name="c" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35510">a Unicode character.</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="is_zero_width" c:identifier="g_unichar_iszerowidth" version="2.14" gs:dll-name="glib-2.0" gs:managed-name="IsZeroWidth" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="35518">Determines if a given character typically takes zero width when rendered.
The return value is %TRUE for all non-spacing and enclosing marks
(e.g., combining accents), format characters, zero-width
space, but not U+00AD SOFT HYPHEN.

A typical use of this function is with one of g_unichar_iswide() or
g_unichar_iswide_cjk() to determine the number of cells a string occupies
when displayed on a grid display (terminals).  However, note that not all
terminals support zero-width rendering of zero-width marks.</doc>
        <source-position filename="gunicode.h" line="669" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="35532">%TRUE if the character has zero width</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="c" transfer-ownership="none" gs:managed-name="c" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35520">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="c" transfer-ownership="none" gs:managed-name="c" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35520">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="to_utf8" c:identifier="g_unichar_to_utf8" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="ToUtf8" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="35537">Converts a single character to UTF-8.</doc>
        <source-position filename="gunicode.h" line="861" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="35546">number of bytes written</doc>
          <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="c" transfer-ownership="none" gs:managed-name="c" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35539">a Unicode character code</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
          <parameter name="outbuf" direction="out" caller-allocates="1" transfer-ownership="none" optional="1" allow-none="1" gs:managed-name="outbuf">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35540">output buffer, must have at
      least 6 bytes of space. If %NULL, the length will be computed and
      returned and nothing will be written to @outbuf.</doc>
            <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="c" transfer-ownership="none" gs:managed-name="c" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35539">a Unicode character code</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
          <parameter name="outbuf" direction="out" caller-allocates="1" transfer-ownership="none" optional="1" allow-none="1" gs:managed-name="outbuf">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35540">output buffer, must have at
      least 6 bytes of space. If %NULL, the length will be computed and
      returned and nothing will be written to @outbuf.</doc>
            <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="to_lower" c:identifier="g_unichar_tolower" gs:dll-name="glib-2.0" gs:managed-name="ToLower" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="35550">Converts a character to lower case.</doc>
        <source-position filename="gunicode.h" line="678" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="35556">the result of converting @c to lower case.
              If @c is not an upperlower or titlecase character,
              or has no lowercase equivalent @c is returned unchanged.</doc>
          <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
        </return-value>
        <parameters>
          <instance-parameter name="c" transfer-ownership="none" gs:managed-name="c" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35552">a Unicode character.</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="c" transfer-ownership="none" gs:managed-name="c" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35552">a Unicode character.</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="to_title" c:identifier="g_unichar_totitle" gs:dll-name="glib-2.0" gs:managed-name="ToTitle" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="35562">Converts a character to the titlecase.</doc>
        <source-position filename="gunicode.h" line="680" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="35568">the result of converting @c to titlecase.
              If @c is not an uppercase or lowercase character,
              @c is returned unchanged.</doc>
          <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
        </return-value>
        <parameters>
          <instance-parameter name="c" transfer-ownership="none" gs:managed-name="c" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35564">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="c" transfer-ownership="none" gs:managed-name="c" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35564">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="to_upper" c:identifier="g_unichar_toupper" gs:dll-name="glib-2.0" gs:managed-name="ToUpper" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="35574">Converts a character to uppercase.</doc>
        <source-position filename="gunicode.h" line="676" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="35580">the result of converting @c to uppercase.
              If @c is not a lowercase or titlecase character,
              or has no upper case equivalent @c is returned unchanged.</doc>
          <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
        </return-value>
        <parameters>
          <instance-parameter name="c" transfer-ownership="none" gs:managed-name="c" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35576">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="c" transfer-ownership="none" gs:managed-name="c" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35576">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="type" c:identifier="g_unichar_type" gs:dll-name="glib-2.0" gs:managed-name="Type" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="35586">Classifies a Unicode character by type.</doc>
        <source-position filename="gunicode.h" line="692" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="35592">the type of the character.</doc>
          <type name="UnicodeType" c:type="GUnicodeType" gs:managed-name="UnicodeType" />
        </return-value>
        <parameters>
          <instance-parameter name="c" transfer-ownership="none" gs:managed-name="c" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35588">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="c" transfer-ownership="none" gs:managed-name="c" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35588">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="validate" c:identifier="g_unichar_validate" gs:dll-name="glib-2.0" gs:managed-name="Validate" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="35596">Checks whether @ch is a valid Unicode character. Some possible
integer values of @ch will not be valid. 0 is considered a valid
character, though it's normally a string terminator.</doc>
        <source-position filename="gunicode.h" line="711" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="35604">%TRUE if @ch is a valid Unicode character</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="ch" transfer-ownership="none" gs:managed-name="ch" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35598">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="ch" transfer-ownership="none" gs:managed-name="ch" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35598">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="hex_digit_value" c:identifier="g_unichar_xdigit_value" gs:dll-name="glib-2.0" gs:managed-name="HexDigitValue" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="35608">Determines the numeric value of a character as a hexadecimal
digit.</doc>
        <source-position filename="gunicode.h" line="688" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="35615">If @c is a hex digit (according to
g_unichar_isxdigit()), its numeric value. Otherwise, -1.</doc>
          <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="c" transfer-ownership="none" gs:managed-name="c" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35610">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="c" transfer-ownership="none" gs:managed-name="c" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35610">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
    </gs:static-class>
    <gs:static-class name="Version" gs:managed-name="Version">
      <constant name="MAJOR" value="2" c:type="GLIB_MAJOR_VERSION" gs:access-modifiers="private" gs:managed-name="major">
        <doc xml:space="preserve" filename="glib-2.0.c" line="1136">The major version number of the GLib library.

Like #glib_major_version, but from the headers used at
application compile time, rather than from the library
linked against at application run time.</doc>
        <source-position filename="glibconfig.h" line="111" />
        <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
      </constant>
      <constant name="MINOR" value="66" c:type="GLIB_MINOR_VERSION" gs:access-modifiers="private" gs:managed-name="minor">
        <doc xml:space="preserve" filename="glib-2.0.c" line="1158">The minor version number of the GLib library.

Like #gtk_minor_version, but from the headers used at
application compile time, rather than from the library
linked against at application run time.</doc>
        <source-position filename="glibconfig.h" line="112" />
        <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
      </constant>
      <constant name="MICRO" value="2" c:type="GLIB_MICRO_VERSION" gs:access-modifiers="private" gs:managed-name="micro">
        <doc xml:space="preserve" filename="glib-2.0.c" line="1147">The micro version number of the GLib library.

Like #gtk_micro_version, but from the headers used at
application compile time, rather than from the library
linked against at application run time.</doc>
        <source-position filename="glibconfig.h" line="113" />
        <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
      </constant>
      <function name="check" c:identifier="glib_check_version" version="2.6" gs:dll-name="glib-2.0" gs:managed-name="Check">
        <doc xml:space="preserve" filename="glib-2.0.c" line="41149">Checks that the GLib library in use is compatible with the
given version. Generally you would pass in the constants
#GLIB_MAJOR_VERSION, #GLIB_MINOR_VERSION, #GLIB_MICRO_VERSION
as the three arguments to this function; that produces
a check that the library in use is compatible with
the version of GLib the application or module was compiled
against.

Compatibility is defined by two things: first the version
of the running library is newer than the version
@required_major.required_minor.@required_micro. Second
the running library must be binary compatible with the
version @required_major.required_minor.@required_micro
(same major version.)</doc>
        <source-position filename="gversion.h" line="43" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="41170">%NULL if the GLib library is compatible with the
    given version, or a string describing the version mismatch.
    The returned string is owned by GLib and must not be modified
    or freed.</doc>
          <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="required_major" transfer-ownership="none" gs:managed-name="requiredMajor" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="41151">the required major version</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
          <parameter name="required_minor" transfer-ownership="none" gs:managed-name="requiredMinor" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="41152">the required minor version</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
          <parameter name="required_micro" transfer-ownership="none" gs:managed-name="requiredMicro" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="41153">the required micro version</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="required_major" transfer-ownership="none" gs:managed-name="requiredMajor" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="41151">the required major version</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
          <parameter name="required_minor" transfer-ownership="none" gs:managed-name="requiredMinor" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="41152">the required minor version</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
          <parameter name="required_micro" transfer-ownership="none" gs:managed-name="requiredMicro" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="41153">the required micro version</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </gs:managed-parameters>
      </function>
    </gs:static-class>
    <gs:static-class name="LogWriter" gs:managed-name="LogWriter">
      <function name="set_writer_func" c:identifier="g_log_set_writer_func" version="2.50" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="SetWriterFunc">
        <doc xml:space="preserve" filename="glib-2.0.c" line="21516">Set a writer function which will be called to format and write out each log
message. Each program should set a writer function, or the default writer
(g_log_writer_default()) will be used.

Libraries **must not** call this function — only programs are allowed to
install a writer function, as there must be a single, central point where
log messages are formatted and outputted.

There can only be one writer function. It is an error to set more than one.</doc>
        <source-position filename="gmessages.h" line="214" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <parameter name="func" transfer-ownership="none" nullable="1" allow-none="1" scope="notified" closure="1" destroy="2" gs:managed-name="func" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21518">log writer function, which must not be %NULL</doc>
            <type name="LogWriterFunc" c:type="GLogWriterFunc" gs:managed-name="LogWriterFunc" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21519">user data to pass to @func</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
          <parameter name="user_data_free" transfer-ownership="none" scope="async" destroy="0" gs:managed-name="userDataFree" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21520">function to free @user_data once it’s
   finished with, if non-%NULL</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify" gs:managed-name="DestroyNotify" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="func" transfer-ownership="none" nullable="1" allow-none="1" scope="notified" closure="1" destroy="2" gs:managed-name="func" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21518">log writer function, which must not be %NULL</doc>
            <type name="LogWriterFunc" c:type="GLogWriterFunc" gs:managed-name="LogWriterFunc" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="default" c:identifier="g_log_writer_default" version="2.50" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="Default">
        <doc xml:space="preserve" filename="glib-2.0.c" line="21678">Format a structured log message and output it to the default log destination
for the platform. On Linux, this is typically the systemd journal, falling
back to `stdout` or `stderr` if running from the terminal or if output is
being redirected to a file.

Support for other platform-specific logging mechanisms may be added in
future. Distributors of GLib may modify this function to impose their own
(documented) platform-specific log writing policies.

This is suitable for use as a #GLogWriterFunc, and is the default writer used
if no other is set using g_log_set_writer_func().

As with g_log_default_handler(), this function drops debug and informational
messages unless their log domain (or `all`) is listed in the space-separated
`G_MESSAGES_DEBUG` environment variable.</doc>
        <source-position filename="gmessages.h" line="240" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="21703">%G_LOG_WRITER_HANDLED on success, %G_LOG_WRITER_UNHANDLED otherwise</doc>
          <type name="LogWriterOutput" c:type="GLogWriterOutput" gs:managed-name="LogWriterOutput" />
        </return-value>
        <parameters>
          <parameter name="log_level" transfer-ownership="none" gs:managed-name="logLevel" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21680">log level, either from #GLogLevelFlags, or a user-defined
   level</doc>
            <type name="LogLevelFlags" c:type="GLogLevelFlags" gs:managed-name="LogLevelFlags" />
          </parameter>
          <parameter name="fields" transfer-ownership="none" gs:managed-name="fields" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21682">key–value pairs of structured data forming
   the log message</doc>
            <array length="2" zero-terminated="0" c:type="const GLogField*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="LogField" c:type="GLogField" gs:managed-name="LogField" />
            </array>
          </parameter>
          <parameter name="n_fields" transfer-ownership="none" gs:managed-name="nFields" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21684">number of elements in the @fields array</doc>
            <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21685">user data passed to g_log_set_writer_func()</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="log_level" transfer-ownership="none" gs:managed-name="logLevel" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21680">log level, either from #GLogLevelFlags, or a user-defined
   level</doc>
            <type name="LogLevelFlags" c:type="GLogLevelFlags" gs:managed-name="LogLevelFlags" />
          </parameter>
          <parameter name="fields" transfer-ownership="none" gs:managed-name="fields" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21682">key–value pairs of structured data forming
   the log message</doc>
            <array length="2" zero-terminated="0" c:type="const GLogField*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="LogField" c:type="GLogField" gs:managed-name="LogField" />
            </array>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21685">user data passed to g_log_set_writer_func()</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="format_fields" c:identifier="g_log_writer_format_fields" version="2.50" gs:dll-name="glib-2.0" gs:managed-name="FormatFields">
        <doc xml:space="preserve" filename="glib-2.0.c" line="21708">Format a structured log message as a string suitable for outputting to the
terminal (or elsewhere). This will include the values of all fields it knows
how to interpret, which includes `MESSAGE` and `GLIB_DOMAIN` (see the
documentation for g_log_structured()). It does not include values from
unknown fields.

The returned string does **not** have a trailing new-line character. It is
encoded in the character set of the current locale, which is not necessarily
UTF-8.</doc>
        <source-position filename="gmessages.h" line="224" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="21728">string containing the formatted log message, in
   the character set of the current locale</doc>
          <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="log_level" transfer-ownership="none" gs:managed-name="logLevel" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21710">log level, either from #GLogLevelFlags, or a user-defined
   level</doc>
            <type name="LogLevelFlags" c:type="GLogLevelFlags" gs:managed-name="LogLevelFlags" />
          </parameter>
          <parameter name="fields" transfer-ownership="none" gs:managed-name="fields" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21712">key–value pairs of structured data forming
   the log message</doc>
            <array length="2" zero-terminated="0" c:type="const GLogField*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="LogField" c:type="GLogField" gs:managed-name="LogField" />
            </array>
          </parameter>
          <parameter name="n_fields" transfer-ownership="none" gs:managed-name="nFields" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21714">number of elements in the @fields array</doc>
            <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="use_color" transfer-ownership="none" gs:managed-name="useColor" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21715">%TRUE to use ANSI color escape sequences when formatting the
   message, %FALSE to not</doc>
            <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="log_level" transfer-ownership="none" gs:managed-name="logLevel" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21710">log level, either from #GLogLevelFlags, or a user-defined
   level</doc>
            <type name="LogLevelFlags" c:type="GLogLevelFlags" gs:managed-name="LogLevelFlags" />
          </parameter>
          <parameter name="fields" transfer-ownership="none" gs:managed-name="fields" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21712">key–value pairs of structured data forming
   the log message</doc>
            <array length="2" zero-terminated="0" c:type="const GLogField*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="LogField" c:type="GLogField" gs:managed-name="LogField" />
            </array>
          </parameter>
          <parameter name="use_color" transfer-ownership="none" gs:managed-name="useColor" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21715">%TRUE to use ANSI color escape sequences when formatting the
   message, %FALSE to not</doc>
            <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="is_journald" c:identifier="g_log_writer_is_journald" version="2.50" gs:dll-name="glib-2.0" gs:managed-name="IsJournald">
        <doc xml:space="preserve" filename="glib-2.0.c" line="21734">Check whether the given @output_fd file descriptor is a connection to the
systemd journal, or something else (like a log file or `stdout` or
`stderr`).

Invalid file descriptors are accepted and return %FALSE, which allows for
the following construct without needing any additional error handling:
|[&lt;!-- language="C" --&gt;
  is_journald = g_log_writer_is_journald (fileno (stderr));
]|</doc>
        <source-position filename="gmessages.h" line="221" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="21748">%TRUE if @output_fd points to the journal, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <parameter name="output_fd" transfer-ownership="none" gs:managed-name="outputFd" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21736">output file descriptor to check</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="output_fd" transfer-ownership="none" gs:managed-name="outputFd" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21736">output file descriptor to check</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="journald" c:identifier="g_log_writer_journald" version="2.50" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="Journald">
        <doc xml:space="preserve" filename="glib-2.0.c" line="21753">Format a structured log message and send it to the systemd journal as a set
of key–value pairs. All fields are sent to the journal, but if a field has
length zero (indicating program-specific data) then only its key will be
sent.

This is suitable for use as a #GLogWriterFunc.

If GLib has been compiled without systemd support, this function is still
defined, but will always return %G_LOG_WRITER_UNHANDLED.</doc>
        <source-position filename="gmessages.h" line="230" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="21772">%G_LOG_WRITER_HANDLED on success, %G_LOG_WRITER_UNHANDLED otherwise</doc>
          <type name="LogWriterOutput" c:type="GLogWriterOutput" gs:managed-name="LogWriterOutput" />
        </return-value>
        <parameters>
          <parameter name="log_level" transfer-ownership="none" gs:managed-name="logLevel" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21755">log level, either from #GLogLevelFlags, or a user-defined
   level</doc>
            <type name="LogLevelFlags" c:type="GLogLevelFlags" gs:managed-name="LogLevelFlags" />
          </parameter>
          <parameter name="fields" transfer-ownership="none" gs:managed-name="fields" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21757">key–value pairs of structured data forming
   the log message</doc>
            <array length="2" zero-terminated="0" c:type="const GLogField*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="LogField" c:type="GLogField" gs:managed-name="LogField" />
            </array>
          </parameter>
          <parameter name="n_fields" transfer-ownership="none" gs:managed-name="nFields" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21759">number of elements in the @fields array</doc>
            <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21760">user data passed to g_log_set_writer_func()</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="log_level" transfer-ownership="none" gs:managed-name="logLevel" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21755">log level, either from #GLogLevelFlags, or a user-defined
   level</doc>
            <type name="LogLevelFlags" c:type="GLogLevelFlags" gs:managed-name="LogLevelFlags" />
          </parameter>
          <parameter name="fields" transfer-ownership="none" gs:managed-name="fields" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21757">key–value pairs of structured data forming
   the log message</doc>
            <array length="2" zero-terminated="0" c:type="const GLogField*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="LogField" c:type="GLogField" gs:managed-name="LogField" />
            </array>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21760">user data passed to g_log_set_writer_func()</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="standard_streams" c:identifier="g_log_writer_standard_streams" version="2.50" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="StandardStreams">
        <doc xml:space="preserve" filename="glib-2.0.c" line="21777">Format a structured log message and print it to either `stdout` or `stderr`,
depending on its log level. %G_LOG_LEVEL_INFO and %G_LOG_LEVEL_DEBUG messages
are sent to `stdout`; all other log levels are sent to `stderr`. Only fields
which are understood by this function are included in the formatted string
which is printed.

If the output stream supports ANSI color escape sequences, they will be used
in the output.

A trailing new-line character is added to the log message when it is printed.

This is suitable for use as a #GLogWriterFunc.</doc>
        <source-position filename="gmessages.h" line="235" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="21799">%G_LOG_WRITER_HANDLED on success, %G_LOG_WRITER_UNHANDLED otherwise</doc>
          <type name="LogWriterOutput" c:type="GLogWriterOutput" gs:managed-name="LogWriterOutput" />
        </return-value>
        <parameters>
          <parameter name="log_level" transfer-ownership="none" gs:managed-name="logLevel" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21779">log level, either from #GLogLevelFlags, or a user-defined
   level</doc>
            <type name="LogLevelFlags" c:type="GLogLevelFlags" gs:managed-name="LogLevelFlags" />
          </parameter>
          <parameter name="fields" transfer-ownership="none" gs:managed-name="fields" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21781">key–value pairs of structured data forming
   the log message</doc>
            <array length="2" zero-terminated="0" c:type="const GLogField*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="LogField" c:type="GLogField" gs:managed-name="LogField" />
            </array>
          </parameter>
          <parameter name="n_fields" transfer-ownership="none" gs:managed-name="nFields" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21783">number of elements in the @fields array</doc>
            <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21784">user data passed to g_log_set_writer_func()</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="log_level" transfer-ownership="none" gs:managed-name="logLevel" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21779">log level, either from #GLogLevelFlags, or a user-defined
   level</doc>
            <type name="LogLevelFlags" c:type="GLogLevelFlags" gs:managed-name="LogLevelFlags" />
          </parameter>
          <parameter name="fields" transfer-ownership="none" gs:managed-name="fields" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21781">key–value pairs of structured data forming
   the log message</doc>
            <array length="2" zero-terminated="0" c:type="const GLogField*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="LogField" c:type="GLogField" gs:managed-name="LogField" />
            </array>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21784">user data passed to g_log_set_writer_func()</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="supports_color" c:identifier="g_log_writer_supports_color" version="2.50" gs:dll-name="glib-2.0" gs:managed-name="SupportsColor">
        <doc xml:space="preserve" filename="glib-2.0.c" line="21804">Check whether the given @output_fd file descriptor supports ANSI color
escape sequences. If so, they can safely be used when formatting log
messages.</doc>
        <source-position filename="gmessages.h" line="219" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="21812">%TRUE if ANSI color escapes are supported, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <parameter name="output_fd" transfer-ownership="none" gs:managed-name="outputFd" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21806">output file descriptor to check</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="output_fd" transfer-ownership="none" gs:managed-name="outputFd" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="21806">output file descriptor to check</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
        </gs:managed-parameters>
      </function>
    </gs:static-class>
    <gs:static-class name="Idle" gs:managed-name="Idle">
      <function name="add_full" c:identifier="g_idle_add_full" shadows="add" gs:dll-name="glib-2.0" gs:managed-name="Add">
        <doc xml:space="preserve" filename="glib-2.0.c" line="18935">Adds a function to be called whenever there are no higher priority
events pending.  If the function returns %FALSE it is automatically
removed from the list of event sources and will not be called again.

See [memory management of sources][mainloop-memory-management] for details
on how to handle the return value and memory management of @data.

This internally creates a main loop source using g_idle_source_new()
and attaches it to the global #GMainContext using g_source_attach(), so
the callback will be invoked in whichever thread is running that main
context. You can do these steps manually if you need greater control or to
use a custom main context.</doc>
        <source-position filename="gmain.h" line="766" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="18956">the ID (greater than 0) of the event source.</doc>
          <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
        </return-value>
        <parameters>
          <parameter name="priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.DefaultIdle" gs:managed-name="priority" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18937">the priority of the idle source. Typically this will be in the
           range between #G_PRIORITY_DEFAULT_IDLE and #G_PRIORITY_HIGH_IDLE.</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="function" transfer-ownership="none" scope="notified" closure="2" destroy="3" gs:managed-name="function" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18939">function to call</doc>
            <type name="SourceFunc" c:type="GSourceFunc" gs:managed-name="SourceFunc" />
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18940">data to pass to @function</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
          <parameter name="notify" transfer-ownership="none" nullable="1" allow-none="1" scope="async" gs:managed-name="notify" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18941">function to call when the idle is removed, or %NULL</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify" gs:managed-name="DestroyNotify" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="function" transfer-ownership="none" scope="notified" closure="2" destroy="3" gs:managed-name="function" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18939">function to call</doc>
            <type name="SourceFunc" c:type="GSourceFunc" gs:managed-name="SourceFunc" />
          </parameter>
          <parameter name="priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.DefaultIdle" gs:managed-name="priority" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18937">the priority of the idle source. Typically this will be in the
           range between #G_PRIORITY_DEFAULT_IDLE and #G_PRIORITY_HIGH_IDLE.</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="remove_by_data" c:identifier="g_idle_remove_by_data" gs:dll-name="glib-2.0" gs:managed-name="RemoveByData">
        <doc xml:space="preserve" filename="glib-2.0.c" line="18960">Removes the idle function with the given data.</doc>
        <source-position filename="gmain.h" line="771" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="18966">%TRUE if an idle source was found and removed.</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18962">the data for the idle source's callback.</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="18962">the data for the idle source's callback.</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
    </gs:static-class>
    <gs:static-class name="UnixSignal" gs:managed-name="UnixSignal">
      <function name="add_full" c:identifier="g_unix_signal_add_full" shadows="add" version="2.30" gs:dll-name="glib-2.0" gs:managed-name="Add">
        <doc xml:space="preserve" filename="glib-2.0.c" line="35823">A convenience function for g_unix_signal_source_new(), which
attaches to the default #GMainContext.  You can remove the watch
using g_source_remove().</doc>
        <source-position filename="glib-unix.h" line="73" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="35836">An ID (greater than 0) for the event source</doc>
          <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
        </return-value>
        <parameters>
          <parameter name="priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="priority" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35825">the priority of the signal source. Typically this will be in
           the range between #G_PRIORITY_DEFAULT and #G_PRIORITY_HIGH.</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="signum" transfer-ownership="none" gs:managed-name="signum" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35827">Signal number</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="handler" transfer-ownership="none" scope="notified" closure="3" destroy="4" gs:managed-name="handler" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35828">Callback</doc>
            <type name="SourceFunc" c:type="GSourceFunc" gs:managed-name="SourceFunc" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="userData" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35829">Data for @handler</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
          <parameter name="notify" transfer-ownership="none" scope="async" gs:managed-name="notify" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35830">#GDestroyNotify for @handler</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify" gs:managed-name="DestroyNotify" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="signum" transfer-ownership="none" gs:managed-name="signum" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35827">Signal number</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="handler" transfer-ownership="none" scope="notified" closure="3" destroy="4" gs:managed-name="handler" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35828">Callback</doc>
            <type name="SourceFunc" c:type="GSourceFunc" gs:managed-name="SourceFunc" />
          </parameter>
          <parameter name="priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="priority" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35825">the priority of the signal source. Typically this will be in
           the range between #G_PRIORITY_DEFAULT and #G_PRIORITY_HIGH.</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
        </gs:managed-parameters>
      </function>
    </gs:static-class>
    <gs:static-class name="TimeoutSource" gs:managed-name="TimeoutSource">
      <function name="new" c:identifier="g_timeout_source_new" gs:dll-name="glib-2.0" gs:managed-name="New">
        <doc xml:space="preserve" filename="glib-2.0.c" line="34490">Creates a new timeout source.

The source will not initially be associated with any #GMainContext
and must be added to one with g_source_attach() before it will be
executed.

The interval given is in terms of monotonic time, not wall clock
time.  See g_get_monotonic_time().</doc>
        <source-position filename="gmain.h" line="673" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="34503">the newly-created timeout source</doc>
          <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="interval" transfer-ownership="none" gs:managed-name="interval" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="34492">the timeout interval in milliseconds.</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="interval" transfer-ownership="none" gs:managed-name="interval" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="34492">the timeout interval in milliseconds.</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="new_seconds" c:identifier="g_timeout_source_new_seconds" version="2.14" gs:dll-name="glib-2.0" gs:managed-name="NewSeconds">
        <doc xml:space="preserve" filename="glib-2.0.c" line="34507">Creates a new timeout source.

The source will not initially be associated with any #GMainContext
and must be added to one with g_source_attach() before it will be
executed.

The scheduling granularity/accuracy of this timeout source will be
in seconds.

The interval given is in terms of monotonic time, not wall clock time.
See g_get_monotonic_time().</doc>
        <source-position filename="gmain.h" line="675" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="34523">the newly-created timeout source</doc>
          <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="interval" transfer-ownership="none" gs:managed-name="interval" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="34509">the timeout interval in seconds</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="interval" transfer-ownership="none" gs:managed-name="interval" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="34509">the timeout interval in seconds</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </gs:managed-parameters>
      </function>
    </gs:static-class>
    <gs:static-class name="UnixSignalSource" gs:managed-name="UnixSignalSource">
      <function name="new" c:identifier="g_unix_signal_source_new" version="2.30" gs:dll-name="glib-2.0" gs:managed-name="New">
        <doc xml:space="preserve" filename="glib-2.0.c" line="35841">Create a #GSource that will be dispatched upon delivery of the UNIX
signal @signum.  In GLib versions before 2.36, only `SIGHUP`, `SIGINT`,
`SIGTERM` can be monitored.  In GLib 2.36, `SIGUSR1` and `SIGUSR2`
were added. In GLib 2.54, `SIGWINCH` was added.

Note that unlike the UNIX default, all sources which have created a
watch will be dispatched, regardless of which underlying thread
invoked g_unix_signal_source_new().

For example, an effective use of this function is to handle `SIGTERM`
cleanly; flushing any outstanding files, and then calling
g_main_loop_quit ().  It is not safe to do any of this a regular
UNIX signal handler; your handler may be invoked while malloc() or
another library function is running, causing reentrancy if you
attempt to use it from the handler.  None of the GLib/GObject API
is safe against this kind of reentrancy.

The interaction of this source when combined with native UNIX
functions like sigprocmask() is not defined.

The source will not initially be associated with any #GMainContext
and must be added to one with g_source_attach() before it will be
executed.</doc>
        <source-position filename="glib-unix.h" line="70" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="35869">A newly created #GSource</doc>
          <type name="Source" c:type="GSource*" gs:managed-name="Source" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="signum" transfer-ownership="none" gs:managed-name="signum" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35843">A signal number</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="signum" transfer-ownership="none" gs:managed-name="signum" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="35843">A signal number</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
        </gs:managed-parameters>
      </function>
    </gs:static-class>
    <gs:static-class name="Priority" gs:managed-name="Priority">
      <constant name="DEFAULT" value="0" c:type="G_PRIORITY_DEFAULT" gs:managed-name="Default">
        <doc xml:space="preserve" filename="gmain.h" line="291">Use this for default priority event sources.

In GLib this priority is used when adding timeout functions
with g_timeout_add(). In GDK this priority is used for events
from the X server.</doc>
        <source-position filename="gmain.h" line="300" />
        <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
      </constant>
      <constant name="DEFAULT_IDLE" value="200" c:type="G_PRIORITY_DEFAULT_IDLE" gs:managed-name="DefaultIdle">
        <doc xml:space="preserve" filename="gmain.h" line="314">Use this for default priority idle functions.

In GLib this priority is used when adding idle functions with
g_idle_add().</doc>
        <source-position filename="gmain.h" line="322" />
        <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
      </constant>
      <constant name="HIGH" value="-100" c:type="G_PRIORITY_HIGH" gs:managed-name="High">
        <doc xml:space="preserve" filename="gmain.h" line="282">Use this for high priority event sources.

It is not used within GLib or GTK+.</doc>
        <source-position filename="gmain.h" line="289" />
        <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
      </constant>
      <constant name="HIGH_IDLE" value="100" c:type="G_PRIORITY_HIGH_IDLE" gs:managed-name="HighIdle">
        <doc xml:space="preserve" filename="gmain.h" line="302">Use this for high priority idle functions.

GTK+ uses #G_PRIORITY_HIGH_IDLE + 10 for resizing operations,
and #G_PRIORITY_HIGH_IDLE + 20 for redrawing operations. (This is
done to ensure that any pending resizes are processed before any
pending redraws, so that widgets are not redrawn twice unnecessarily.)</doc>
        <source-position filename="gmain.h" line="312" />
        <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
      </constant>
      <constant name="LOW" value="300" c:type="G_PRIORITY_LOW" gs:managed-name="Low">
        <doc xml:space="preserve" filename="gmain.h" line="324">Use this for very low priority background tasks.

It is not used within GLib or GTK+.</doc>
        <source-position filename="gmain.h" line="331" />
        <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
      </constant>
    </gs:static-class>
    <gs:static-class name="Timeout" gs:managed-name="Timeout">
      <function name="add_full" c:identifier="g_timeout_add_full" shadows="add" gs:dll-name="glib-2.0" gs:managed-name="Add">
        <doc xml:space="preserve" filename="glib-2.0.c" line="34365">Sets a function to be called at regular intervals, with the given
priority.  The function is called repeatedly until it returns
%FALSE, at which point the timeout is automatically destroyed and
the function will not be called again.  The @notify function is
called when the timeout is destroyed.  The first call to the
function will be at the end of the first @interval.

Note that timeout functions may be delayed, due to the processing of other
event sources. Thus they should not be relied on for precise timing.
After each call to the timeout function, the time of the next
timeout is recalculated based on the current time and the given interval
(it does not try to 'catch up' time lost in delays).

See [memory management of sources][mainloop-memory-management] for details
on how to handle the return value and memory management of @data.

This internally creates a main loop source using g_timeout_source_new()
and attaches it to the global #GMainContext using g_source_attach(), so
the callback will be invoked in whichever thread is running that main
context. You can do these steps manually if you need greater control or to
use a custom main context.

The interval given is in terms of monotonic time, not wall clock time.
See g_get_monotonic_time().</doc>
        <source-position filename="gmain.h" line="733" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="34400">the ID (greater than 0) of the event source.</doc>
          <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
        </return-value>
        <parameters>
          <parameter name="priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="priority" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="34367">the priority of the timeout source. Typically this will be in
           the range between #G_PRIORITY_DEFAULT and #G_PRIORITY_HIGH.</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="interval" transfer-ownership="none" gs:managed-name="interval" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="34369">the time between calls to the function, in milliseconds
            (1/1000ths of a second)</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
          <parameter name="function" transfer-ownership="none" scope="notified" closure="3" destroy="4" gs:managed-name="function" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="34371">function to call</doc>
            <type name="SourceFunc" c:type="GSourceFunc" gs:managed-name="SourceFunc" />
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="34372">data to pass to @function</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
          <parameter name="notify" transfer-ownership="none" nullable="1" allow-none="1" scope="async" gs:managed-name="notify" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="34373">function to call when the timeout is removed, or %NULL</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify" gs:managed-name="DestroyNotify" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="interval" transfer-ownership="none" gs:managed-name="interval" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="34369">the time between calls to the function, in milliseconds
            (1/1000ths of a second)</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
          <parameter name="function" transfer-ownership="none" scope="notified" closure="3" destroy="4" gs:managed-name="function" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="34371">function to call</doc>
            <type name="SourceFunc" c:type="GSourceFunc" gs:managed-name="SourceFunc" />
          </parameter>
          <parameter name="priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="priority" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="34367">the priority of the timeout source. Typically this will be in
           the range between #G_PRIORITY_DEFAULT and #G_PRIORITY_HIGH.</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="add_seconds_full" c:identifier="g_timeout_add_seconds_full" shadows="add_seconds" version="2.14" gs:dll-name="glib-2.0" gs:managed-name="AddSeconds">
        <doc xml:space="preserve" filename="glib-2.0.c" line="34437">Sets a function to be called at regular intervals, with @priority.
The function is called repeatedly until it returns %FALSE, at which
point the timeout is automatically destroyed and the function will
not be called again.

Unlike g_timeout_add(), this function operates at whole second granularity.
The initial starting point of the timer is determined by the implementation
and the implementation is expected to group multiple timers together so that
they fire all at the same time.
To allow this grouping, the @interval to the first timer is rounded
and can deviate up to one second from the specified interval.
Subsequent timer iterations will generally run at the specified interval.

Note that timeout functions may be delayed, due to the processing of other
event sources. Thus they should not be relied on for precise timing.
After each call to the timeout function, the time of the next
timeout is recalculated based on the current time and the given @interval

See [memory management of sources][mainloop-memory-management] for details
on how to handle the return value and memory management of @data.

If you want timing more precise than whole seconds, use g_timeout_add()
instead.

The grouping of timers to fire at the same time results in a more power
and CPU efficient behavior so if your timer is in multiples of seconds
and you don't require the first timer exactly one second from now, the
use of g_timeout_add_seconds() is preferred over g_timeout_add().

This internally creates a main loop source using
g_timeout_source_new_seconds() and attaches it to the main loop context
using g_source_attach(). You can do these steps manually if you need
greater control.

It is safe to call this function from any thread.

The interval given is in terms of monotonic time, not wall clock
time.  See g_get_monotonic_time().</doc>
        <source-position filename="gmain.h" line="743" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="34485">the ID (greater than 0) of the event source.</doc>
          <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
        </return-value>
        <parameters>
          <parameter name="priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="priority" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="34439">the priority of the timeout source. Typically this will be in
           the range between #G_PRIORITY_DEFAULT and #G_PRIORITY_HIGH.</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="interval" transfer-ownership="none" gs:managed-name="interval" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="34441">the time between calls to the function, in seconds</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
          <parameter name="function" transfer-ownership="none" scope="notified" closure="3" destroy="4" gs:managed-name="function" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="34442">function to call</doc>
            <type name="SourceFunc" c:type="GSourceFunc" gs:managed-name="SourceFunc" />
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="34443">data to pass to @function</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
          <parameter name="notify" transfer-ownership="none" nullable="1" allow-none="1" scope="async" gs:managed-name="notify" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="34444">function to call when the timeout is removed, or %NULL</doc>
            <type name="DestroyNotify" c:type="GDestroyNotify" gs:managed-name="DestroyNotify" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="interval" transfer-ownership="none" gs:managed-name="interval" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="34441">the time between calls to the function, in seconds</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
          <parameter name="function" transfer-ownership="none" scope="notified" closure="3" destroy="4" gs:managed-name="function" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="34442">function to call</doc>
            <type name="SourceFunc" c:type="GSourceFunc" gs:managed-name="SourceFunc" />
          </parameter>
          <parameter name="priority" transfer-ownership="none" gs:default="GISharp.Lib.GLib.Priority.Default" gs:managed-name="priority" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="34439">the priority of the timeout source. Typically this will be in
           the range between #G_PRIORITY_DEFAULT and #G_PRIORITY_HIGH.</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
        </gs:managed-parameters>
      </function>
    </gs:static-class>
    <gs:static-class name="Utility" gs:managed-name="Utility">
      <gs:managed-property name="get_application_name" version="2.2" gs:dll-name="glib-2.0" gs:managed-name="ApplicationName">
        <doc xml:space="preserve" filename="glib-2.0.c" line="17137">Gets a human-readable name for the application, as set by
g_set_application_name(). This name should be localized if
possible, and is intended for display to the user.  Contrast with
g_get_prgname(), which gets a non-localized name. If
g_set_application_name() has not been called, returns the result of
g_get_prgname() (which may be %NULL if g_set_prgname() has also not
been called).</doc>
        <source-position filename="gutils.h" line="65" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="17148">human-readable application
  name. May return %NULL</doc>
          <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </gs:managed-property>
      <function name="get_application_name" c:identifier="g_get_application_name" version="2.2" gs:dll-name="glib-2.0" gs:managed-name="GetApplicationName" gs:property-getter-for="ApplicationName" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="17137">Gets a human-readable name for the application, as set by
g_set_application_name(). This name should be localized if
possible, and is intended for display to the user.  Contrast with
g_get_prgname(), which gets a non-localized name. If
g_set_application_name() has not been called, returns the result of
g_get_prgname() (which may be %NULL if g_set_prgname() has also not
been called).</doc>
        <source-position filename="gutils.h" line="65" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="17148">human-readable application
  name. May return %NULL</doc>
          <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
      <function name="set_application_name" c:identifier="g_set_application_name" version="2.2" gs:dll-name="glib-2.0" gs:managed-name="SetApplicationName" gs:property-setter-for="ApplicationName" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="28823">Sets a human-readable name for the application. This name should be
localized if possible, and is intended for display to the user.
Contrast with g_set_prgname(), which sets a non-localized name.
g_set_prgname() will be called automatically by gtk_init(),
but g_set_application_name() will not.

Note that for thread safety reasons, this function can only
be called once.

The application name will be used in contexts such as error messages,
or when displaying an application's name in the task list.</doc>
        <source-position filename="gutils.h" line="67" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <parameter name="application_name" transfer-ownership="none" gs:managed-name="applicationName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="28825">localized name of the application</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="application_name" transfer-ownership="none" gs:managed-name="applicationName" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="28825">localized name of the application</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <gs:managed-property name="get_program_name" gs:dll-name="glib-2.0" gs:managed-name="ProgramName">
        <doc xml:space="preserve" filename="glib-2.0.c" line="17480">Gets the name of the program. This name should not be localized,
in contrast to g_get_application_name().

If you are using #GApplication the program name is set in
g_application_run(). In case of GDK or GTK+ it is set in
gdk_init(), which is called by gtk_init() and the
#GtkApplication::startup handler. The program name is found by
taking the last component of @argv[0].</doc>
        <source-position filename="gutils.h" line="61" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="17492">the name of the program,
  or %NULL if it has not been set yet. The returned string belongs
  to GLib and must not be modified or freed.</doc>
          <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </gs:managed-property>
      <function name="get_program_name" c:identifier="g_get_prgname" gs:dll-name="glib-2.0" gs:managed-name="GetProgramName" gs:property-getter-for="ProgramName" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="17480">Gets the name of the program. This name should not be localized,
in contrast to g_get_application_name().

If you are using #GApplication the program name is set in
g_application_run(). In case of GDK or GTK+ it is set in
gdk_init(), which is called by gtk_init() and the
#GtkApplication::startup handler. The program name is found by
taking the last component of @argv[0].</doc>
        <source-position filename="gutils.h" line="61" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="17492">the name of the program,
  or %NULL if it has not been set yet. The returned string belongs
  to GLib and must not be modified or freed.</doc>
          <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
      <function name="set_program_name" c:identifier="g_set_prgname" gs:dll-name="glib-2.0" gs:managed-name="SetProgramName" gs:property-setter-for="ProgramName" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="glib-2.0.c" line="28873">Sets the name of the program. This name should not be localized,
in contrast to g_set_application_name().

If you are using #GApplication the program name is set in
g_application_run(). In case of GDK or GTK+ it is set in
gdk_init(), which is called by gtk_init() and the
#GtkApplication::startup handler. The program name is found by
taking the last component of @argv[0].

Note that for thread-safety reasons this function can only be called once.</doc>
        <source-position filename="gutils.h" line="63" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <parameter name="prgname" transfer-ownership="none" gs:managed-name="prgname" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="28875">the name of the program.</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="prgname" transfer-ownership="none" gs:managed-name="prgname" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="28875">the name of the program.</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
    </gs:static-class>
    <gs:static-class name="Utf8Extensions" gs:managed-name="Utf8Extensions">
      <method name="casefold" c:identifier="g_utf8_casefold" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="Casefold" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="36792">Converts a string into a form that is independent of case. The
result will not correspond to any particular case, but can be
compared for equality or ordered with the results of calling
g_utf8_casefold() on other strings.

Note that calling g_utf8_casefold() followed by g_utf8_collate() is
only an approximation to the correct linguistic case insensitive
ordering, though it is a fairly good one. Getting this exactly
right would require a more sophisticated collation function that
takes case sensitivity into account. GLib does not currently
provide such a function.</doc>
        <source-position filename="gunicode.h" line="880" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="36809">a newly allocated string, that is a
  case independent form of @str.</doc>
          <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="str" transfer-ownership="none" gs:managed-name="str" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="36794">a UTF-8 encoded string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="len" transfer-ownership="none" gs:managed-name="len" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="36795">length of @str, in bytes, or -1 if @str is nul-terminated.</doc>
            <type name="gssize" c:type="gssize" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="str" transfer-ownership="none" gs:managed-name="str" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="36794">a UTF-8 encoded string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="len" transfer-ownership="none" gs:managed-name="len" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="36795">length of @str, in bytes, or -1 if @str is nul-terminated.</doc>
            <type name="gssize" c:type="gssize" gs:managed-name="System.Int32" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="collate" c:identifier="g_utf8_collate" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="Collate" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="36814">Compares two strings for ordering using the linguistically
correct rules for the [current locale][setlocale].
When sorting a large number of strings, it will be significantly
faster to obtain collation keys with g_utf8_collate_key() and
compare the keys with strcmp() when sorting instead of sorting
the original strings.</doc>
        <source-position filename="gunicode.h" line="924" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="36826">&lt; 0 if @str1 compares before @str2,
  0 if they compare equal, &gt; 0 if @str1 compares after @str2.</doc>
          <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="str1" transfer-ownership="none" gs:managed-name="str1" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="36816">a UTF-8 encoded string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="str2" transfer-ownership="none" gs:managed-name="str2" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="36817">a UTF-8 encoded string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="str1" transfer-ownership="none" gs:managed-name="str1" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="36816">a UTF-8 encoded string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="str2" transfer-ownership="none" gs:managed-name="str2" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="36817">a UTF-8 encoded string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="collate_key" c:identifier="g_utf8_collate_key" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="CollateKey" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="36831">Converts a string into a collation key that can be compared
with other collation keys produced by the same function using
strcmp().

The results of comparing the collation keys of two strings
with strcmp() will always be the same as comparing the two
original keys with g_utf8_collate().

Note that this function depends on the [current locale][setlocale].</doc>
        <source-position filename="gunicode.h" line="927" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="36846">a newly allocated string. This string should
  be freed with g_free() when you are done with it.</doc>
          <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="str" transfer-ownership="none" gs:managed-name="str" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="36833">a UTF-8 encoded string.</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="len" transfer-ownership="none" gs:managed-name="len" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="36834">length of @str, in bytes, or -1 if @str is nul-terminated.</doc>
            <type name="gssize" c:type="gssize" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="str" transfer-ownership="none" gs:managed-name="str" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="36833">a UTF-8 encoded string.</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="len" transfer-ownership="none" gs:managed-name="len" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="36834">length of @str, in bytes, or -1 if @str is nul-terminated.</doc>
            <type name="gssize" c:type="gssize" gs:managed-name="System.Int32" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="collate_key_for_filename" c:identifier="g_utf8_collate_key_for_filename" version="2.8" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="CollateKeyForFilename" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="36851">Converts a string into a collation key that can be compared
with other collation keys produced by the same function using strcmp().

In order to sort filenames correctly, this function treats the dot '.'
as a special case. Most dictionary orderings seem to consider it
insignificant, thus producing the ordering "event.c" "eventgenerator.c"
"event.h" instead of "event.c" "event.h" "eventgenerator.c". Also, we
would like to treat numbers intelligently so that "file1" "file10" "file5"
is sorted as "file1" "file5" "file10".

Note that this function depends on the [current locale][setlocale].</doc>
        <source-position filename="gunicode.h" line="930" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="36868">a newly allocated string. This string should
  be freed with g_free() when you are done with it.</doc>
          <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="str" transfer-ownership="none" gs:managed-name="str" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="36853">a UTF-8 encoded string.</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="len" transfer-ownership="none" gs:managed-name="len" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="36854">length of @str, in bytes, or -1 if @str is nul-terminated.</doc>
            <type name="gssize" c:type="gssize" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="str" transfer-ownership="none" gs:managed-name="str" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="36853">a UTF-8 encoded string.</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="len" transfer-ownership="none" gs:managed-name="len" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="36854">length of @str, in bytes, or -1 if @str is nul-terminated.</doc>
            <type name="gssize" c:type="gssize" gs:managed-name="System.Int32" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="find_next_char" c:identifier="g_utf8_find_next_char" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="FindNextChar" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="36874">Finds the start of the next UTF-8 character in the string after @p.

@p does not have to be at the beginning of a UTF-8 character. No check
is made to see if the character found is actually valid other than
it starts with an appropriate byte.

If @end is %NULL, the return value will never be %NULL: if the end of the
string is reached, a pointer to the terminating nul byte is returned. If
@end is non-%NULL, the return value will be %NULL if the end of the string
is reached.</doc>
        <source-position filename="gunicode.h" line="785" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="36891">a pointer to the found character or %NULL if @end is
   set and is reached</doc>
          <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="p" transfer-ownership="none" gs:managed-name="p" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="36876">a pointer to a position within a UTF-8 encoded string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="end" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="end" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="36877">a pointer to the byte following the end of the string,
    or %NULL to indicate that the string is nul-terminated</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="p" transfer-ownership="none" gs:managed-name="p" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="36876">a pointer to a position within a UTF-8 encoded string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="end" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="end" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="36877">a pointer to the byte following the end of the string,
    or %NULL to indicate that the string is nul-terminated</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="find_prev_char" c:identifier="g_utf8_find_prev_char" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="FindPrevChar" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="36896">Given a position @p with a UTF-8 encoded string @str, find the start
of the previous UTF-8 character starting before @p. Returns %NULL if no
UTF-8 characters are present in @str before @p.

@p does not have to be at the beginning of a UTF-8 character. No check
is made to see if the character found is actually valid other than
it starts with an appropriate byte.</doc>
        <source-position filename="gunicode.h" line="788" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="36909">a pointer to the found character or %NULL.</doc>
          <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="str" transfer-ownership="none" gs:managed-name="str" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="36898">pointer to the beginning of a UTF-8 encoded string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="p" transfer-ownership="none" gs:managed-name="p" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="36899">pointer to some position within @str</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="str" transfer-ownership="none" gs:managed-name="str" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="36898">pointer to the beginning of a UTF-8 encoded string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="p" transfer-ownership="none" gs:managed-name="p" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="36899">pointer to some position within @str</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_char" c:identifier="g_utf8_get_char" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="GetChar" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="36913">Converts a sequence of bytes encoded as UTF-8 to a Unicode character.

If @p does not point to a valid UTF-8 encoded character, results
are undefined. If you are not sure that the bytes are complete
valid Unicode characters, you should use g_utf8_get_char_validated()
instead.</doc>
        <source-position filename="gunicode.h" line="771" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="36924">the resulting character</doc>
          <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
        </return-value>
        <parameters>
          <instance-parameter name="p" transfer-ownership="none" gs:managed-name="p" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="36915">a pointer to Unicode character encoded as UTF-8</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="p" transfer-ownership="none" gs:managed-name="p" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="36915">a pointer to Unicode character encoded as UTF-8</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_char_validated" c:identifier="g_utf8_get_char_validated" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="GetCharValidated" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="36928">Convert a sequence of bytes encoded as UTF-8 to a Unicode character.
This function checks for incomplete characters, for invalid characters
such as characters that are out of the range of Unicode, and for
overlong encodings of valid characters.

Note that g_utf8_get_char_validated() returns (gunichar)-2 if
@max_len is positive and any of the bytes in the first UTF-8 character
sequence are nul.</doc>
        <source-position filename="gunicode.h" line="773" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="36942">the resulting character. If @p points to a partial
    sequence at the end of a string that could begin a valid
    character (or if @max_len is zero), returns (gunichar)-2;
    otherwise, if @p does not point to a valid UTF-8 encoded
    Unicode character, returns (gunichar)-1.</doc>
          <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
        </return-value>
        <parameters>
          <instance-parameter name="p" transfer-ownership="none" gs:managed-name="p" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="36930">a pointer to Unicode character encoded as UTF-8</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="max_len" transfer-ownership="none" gs:managed-name="maxLen" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="36931">the maximum number of bytes to read, or -1 if @p is nul-terminated</doc>
            <type name="gssize" c:type="gssize" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="p" transfer-ownership="none" gs:managed-name="p" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="36930">a pointer to Unicode character encoded as UTF-8</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="max_len" transfer-ownership="none" gs:managed-name="maxLen" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="36931">the maximum number of bytes to read, or -1 if @p is nul-terminated</doc>
            <type name="gssize" c:type="gssize" gs:managed-name="System.Int32" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="make_valid" c:identifier="g_utf8_make_valid" version="2.52" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="MakeValid" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="36950">If the provided string is valid UTF-8, return a copy of it. If not,
return a copy in which bytes that could not be interpreted as valid Unicode
are replaced with the Unicode replacement character (U+FFFD).

For example, this is an appropriate function to use if you have received
a string that was incorrectly declared to be UTF-8, and you need a valid
UTF-8 version of it that can be logged or displayed to the user, with the
assumption that it is close enough to ASCII or UTF-8 to be mostly
readable as-is.</doc>
        <source-position filename="gunicode.h" line="934" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="36966">a valid UTF-8 string whose content resembles @str</doc>
          <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="str" transfer-ownership="none" gs:managed-name="str" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="36952">string to coerce into UTF-8</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="len" transfer-ownership="none" gs:managed-name="len" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="36953">the maximum length of @str to use, in bytes. If @len &lt; 0,
    then the string is nul-terminated.</doc>
            <type name="gssize" c:type="gssize" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="str" transfer-ownership="none" gs:managed-name="str" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="36952">string to coerce into UTF-8</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="len" transfer-ownership="none" gs:managed-name="len" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="36953">the maximum length of @str to use, in bytes. If @len &lt; 0,
    then the string is nul-terminated.</doc>
            <type name="gssize" c:type="gssize" gs:managed-name="System.Int32" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="normalize" c:identifier="g_utf8_normalize" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="Normalize" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="36971">Converts a string into canonical form, standardizing
such issues as whether a character with an accent
is represented as a base character and combining
accent or as a single precomposed character. The
string has to be valid UTF-8, otherwise %NULL is
returned. You should generally call g_utf8_normalize()
before comparing two Unicode strings.

The normalization mode %G_NORMALIZE_DEFAULT only
standardizes differences that do not affect the
text content, such as the above-mentioned accent
representation. %G_NORMALIZE_ALL also standardizes
the "compatibility" characters in Unicode, such
as SUPERSCRIPT THREE to the standard forms
(in this case DIGIT THREE). Formatting information
may be lost but for most text operations such
characters should be considered the same.

%G_NORMALIZE_DEFAULT_COMPOSE and %G_NORMALIZE_ALL_COMPOSE
are like %G_NORMALIZE_DEFAULT and %G_NORMALIZE_ALL,
but returned a result with composed forms rather
than a maximally decomposed form. This is often
useful if you intend to convert the string to
a legacy encoding or pass it to a system with
less capable Unicode handling.</doc>
        <source-position filename="gunicode.h" line="919" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="37003">a newly allocated string, that
  is the normalized form of @str, or %NULL if @str
  is not valid UTF-8.</doc>
          <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="str" transfer-ownership="none" gs:managed-name="str" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="36973">a UTF-8 encoded string.</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="len" transfer-ownership="none" gs:managed-name="len" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="36974">length of @str, in bytes, or -1 if @str is nul-terminated.</doc>
            <type name="gssize" c:type="gssize" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="mode" transfer-ownership="none" gs:managed-name="mode" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="36975">the type of normalization to perform.</doc>
            <type name="NormalizeMode" c:type="GNormalizeMode" gs:managed-name="NormalizeMode" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="str" transfer-ownership="none" gs:managed-name="str" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="36973">a UTF-8 encoded string.</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="len" transfer-ownership="none" gs:managed-name="len" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="36974">length of @str, in bytes, or -1 if @str is nul-terminated.</doc>
            <type name="gssize" c:type="gssize" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="mode" transfer-ownership="none" gs:managed-name="mode" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="36975">the type of normalization to perform.</doc>
            <type name="NormalizeMode" c:type="GNormalizeMode" gs:managed-name="NormalizeMode" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="offset_to_pointer" c:identifier="g_utf8_offset_to_pointer" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="OffsetToPointer" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="37009">Converts from an integer character offset to a pointer to a position
within the string.

Since 2.10, this function allows to pass a negative @offset to
step backwards. It is usually worth stepping backwards from the end
instead of forwards if @offset is in the last fourth of the string,
since moving forward is about 3 times faster than moving backward.

Note that this function doesn't abort when reaching the end of @str.
Therefore you should be sure that @offset is within string boundaries
before calling that function. Call g_utf8_strlen() when unsure.
This limitation exists as this function is called frequently during
text rendering and therefore has to be as fast as possible.</doc>
        <source-position filename="gunicode.h" line="777" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="37028">the resulting pointer</doc>
          <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="str" transfer-ownership="none" gs:managed-name="str" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37011">a UTF-8 encoded string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none" gs:managed-name="offset" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37012">a character offset within @str</doc>
            <type name="glong" c:type="glong" gs:managed-name="GISharp.Runtime.CLong" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="str" transfer-ownership="none" gs:managed-name="str" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37011">a UTF-8 encoded string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none" gs:managed-name="offset" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37012">a character offset within @str</doc>
            <type name="glong" c:type="glong" gs:managed-name="GISharp.Runtime.CLong" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="pointer_to_offset" c:identifier="g_utf8_pointer_to_offset" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="PointerToOffset" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="37032">Converts from a pointer to position within a string to an integer
character offset.

Since 2.10, this function allows @pos to be before @str, and returns
a negative offset in this case.</doc>
        <source-position filename="gunicode.h" line="780" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="37043">the resulting character offset</doc>
          <type name="glong" c:type="glong" gs:managed-name="GISharp.Runtime.CLong" />
        </return-value>
        <parameters>
          <instance-parameter name="str" transfer-ownership="none" gs:managed-name="str" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37034">a UTF-8 encoded string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="pos" transfer-ownership="none" gs:managed-name="pos" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37035">a pointer to a position within @str</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="str" transfer-ownership="none" gs:managed-name="str" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37034">a UTF-8 encoded string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="pos" transfer-ownership="none" gs:managed-name="pos" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37035">a pointer to a position within @str</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="prev_char" c:identifier="g_utf8_prev_char" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="PrevChar" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="37047">Finds the previous UTF-8 character in the string before @p.

@p does not have to be at the beginning of a UTF-8 character. No check
is made to see if the character found is actually valid other than
it starts with an appropriate byte. If @p might be the first
character of the string, you must use g_utf8_find_prev_char() instead.</doc>
        <source-position filename="gunicode.h" line="783" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="37058">a pointer to the found character</doc>
          <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="p" transfer-ownership="none" gs:managed-name="p" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37049">a pointer to a position within a UTF-8 encoded string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="p" transfer-ownership="none" gs:managed-name="p" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37049">a pointer to a position within a UTF-8 encoded string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="strchr" c:identifier="g_utf8_strchr" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="Strchr" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="37062">Finds the leftmost occurrence of the given Unicode character
in a UTF-8 encoded string, while limiting the search to @len bytes.
If @len is -1, allow unbounded search.</doc>
        <source-position filename="gunicode.h" line="808" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="37072">%NULL if the string does not contain the character,
    otherwise, a pointer to the start of the leftmost occurrence
    of the character in the string.</doc>
          <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="p" transfer-ownership="none" gs:managed-name="p" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37064">a nul-terminated UTF-8 encoded string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="len" transfer-ownership="none" gs:managed-name="len" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37065">the maximum length of @p</doc>
            <type name="gssize" c:type="gssize" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="c" transfer-ownership="none" gs:managed-name="c" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37066">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="p" transfer-ownership="none" gs:managed-name="p" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37064">a nul-terminated UTF-8 encoded string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="len" transfer-ownership="none" gs:managed-name="len" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37065">the maximum length of @p</doc>
            <type name="gssize" c:type="gssize" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="c" transfer-ownership="none" gs:managed-name="c" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37066">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="strdown" c:identifier="g_utf8_strdown" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="Strdown" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="37078">Converts all Unicode characters in the string that have a case
to lowercase. The exact manner that this is done depends
on the current locale, and may result in the number of
characters in the string changing.</doc>
        <source-position filename="gunicode.h" line="877" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="37088">a newly allocated string, with all characters
   converted to lowercase.</doc>
          <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="str" transfer-ownership="none" gs:managed-name="str" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37080">a UTF-8 encoded string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="len" transfer-ownership="none" gs:managed-name="len" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37081">length of @str, in bytes, or -1 if @str is nul-terminated.</doc>
            <type name="gssize" c:type="gssize" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="str" transfer-ownership="none" gs:managed-name="str" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37080">a UTF-8 encoded string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="len" transfer-ownership="none" gs:managed-name="len" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37081">length of @str, in bytes, or -1 if @str is nul-terminated.</doc>
            <type name="gssize" c:type="gssize" gs:managed-name="System.Int32" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="strlen" c:identifier="g_utf8_strlen" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="Strlen" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="37093">Computes the length of the string in characters, not including
the terminating nul character. If the @max'th byte falls in the
middle of a character, the last (partial) character is not counted.</doc>
        <source-position filename="gunicode.h" line="792" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="37106">the length of the string in characters</doc>
          <type name="glong" c:type="glong" gs:managed-name="GISharp.Runtime.CLong" />
        </return-value>
        <parameters>
          <instance-parameter name="p" transfer-ownership="none" gs:managed-name="p" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37095">pointer to the start of a UTF-8 encoded string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="max" transfer-ownership="none" gs:managed-name="max" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37096">the maximum number of bytes to examine. If @max
      is less than 0, then the string is assumed to be
      nul-terminated. If @max is 0, @p will not be examined and
      may be %NULL. If @max is greater than 0, up to @max
      bytes are examined</doc>
            <type name="gssize" c:type="gssize" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="p" transfer-ownership="none" gs:managed-name="p" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37095">pointer to the start of a UTF-8 encoded string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="max" transfer-ownership="none" gs:managed-name="max" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37096">the maximum number of bytes to examine. If @max
      is less than 0, then the string is assumed to be
      nul-terminated. If @max is 0, @p will not be examined and
      may be %NULL. If @max is greater than 0, up to @max
      bytes are examined</doc>
            <type name="gssize" c:type="gssize" gs:managed-name="System.Int32" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="strncpy" c:identifier="g_utf8_strncpy" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="Strncpy" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="37110">Like the standard C strncpy() function, but copies a given number
of characters instead of a given number of bytes. The @src string
must be valid UTF-8 encoded text. (Use g_utf8_validate() on all
text before trying to use UTF-8 utility functions with it.)

Note you must ensure @dest is at least 4 * @n to fit the
largest possible UTF-8 characters</doc>
        <source-position filename="gunicode.h" line="801" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="37124">@dest</doc>
          <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="dest" transfer-ownership="none" gs:managed-name="dest" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37112">buffer to fill with characters from @src</doc>
            <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="src" transfer-ownership="none" gs:managed-name="src" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37113">UTF-8 encoded string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="n" transfer-ownership="none" gs:managed-name="n" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37114">character count</doc>
            <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="dest" transfer-ownership="none" gs:managed-name="dest" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37112">buffer to fill with characters from @src</doc>
            <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="src" transfer-ownership="none" gs:managed-name="src" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37113">UTF-8 encoded string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="n" transfer-ownership="none" gs:managed-name="n" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37114">character count</doc>
            <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="strrchr" c:identifier="g_utf8_strrchr" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="Strrchr" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="37128">Find the rightmost occurrence of the given Unicode character
in a UTF-8 encoded string, while limiting the search to @len bytes.
If @len is -1, allow unbounded search.</doc>
        <source-position filename="gunicode.h" line="812" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="37138">%NULL if the string does not contain the character,
    otherwise, a pointer to the start of the rightmost occurrence
    of the character in the string.</doc>
          <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="p" transfer-ownership="none" gs:managed-name="p" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37130">a nul-terminated UTF-8 encoded string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="len" transfer-ownership="none" gs:managed-name="len" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37131">the maximum length of @p</doc>
            <type name="gssize" c:type="gssize" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="c" transfer-ownership="none" gs:managed-name="c" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37132">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="p" transfer-ownership="none" gs:managed-name="p" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37130">a nul-terminated UTF-8 encoded string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="len" transfer-ownership="none" gs:managed-name="len" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37131">the maximum length of @p</doc>
            <type name="gssize" c:type="gssize" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="c" transfer-ownership="none" gs:managed-name="c" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37132">a Unicode character</doc>
            <type name="gunichar" c:type="gunichar" gs:managed-name="GISharp.Lib.GLib.Unichar" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="strreverse" c:identifier="g_utf8_strreverse" version="2.2" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="Strreverse" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="37144">Reverses a UTF-8 string. @str must be valid UTF-8 encoded text.
(Use g_utf8_validate() on all text before trying to use UTF-8
utility functions with it.)

This function is intended for programmatic uses of reversed strings.
It pays no attention to decomposed characters, combining marks, byte
order marks, directional indicators (LRM, LRO, etc) and similar
characters which might need special handling when reversing a string
for display purposes.

Note that unlike g_strreverse(), this function returns
newly-allocated memory, which should be freed with g_free() when
no longer needed.</doc>
        <source-position filename="gunicode.h" line="816" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="37164">a newly-allocated string which is the reverse of @str</doc>
          <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="str" transfer-ownership="none" gs:managed-name="str" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37146">a UTF-8 encoded string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="len" transfer-ownership="none" gs:managed-name="len" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37147">the maximum length of @str to use, in bytes. If @len &lt; 0,
    then the string is nul-terminated.</doc>
            <type name="gssize" c:type="gssize" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="str" transfer-ownership="none" gs:managed-name="str" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37146">a UTF-8 encoded string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="len" transfer-ownership="none" gs:managed-name="len" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37147">the maximum length of @str to use, in bytes. If @len &lt; 0,
    then the string is nul-terminated.</doc>
            <type name="gssize" c:type="gssize" gs:managed-name="System.Int32" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="strup" c:identifier="g_utf8_strup" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="Strup" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="37169">Converts all Unicode characters in the string that have a case
to uppercase. The exact manner that this is done depends
on the current locale, and may result in the number of
characters in the string increasing. (For instance, the
German ess-zet will be changed to SS.)</doc>
        <source-position filename="gunicode.h" line="874" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="37180">a newly allocated string, with all characters
   converted to uppercase.</doc>
          <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="str" transfer-ownership="none" gs:managed-name="str" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37171">a UTF-8 encoded string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="len" transfer-ownership="none" gs:managed-name="len" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37172">length of @str, in bytes, or -1 if @str is nul-terminated.</doc>
            <type name="gssize" c:type="gssize" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="str" transfer-ownership="none" gs:managed-name="str" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37171">a UTF-8 encoded string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="len" transfer-ownership="none" gs:managed-name="len" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37172">length of @str, in bytes, or -1 if @str is nul-terminated.</doc>
            <type name="gssize" c:type="gssize" gs:managed-name="System.Int32" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="substring" c:identifier="g_utf8_substring" version="2.30" gs:pinvoke-only="0" gs:dll-name="glib-2.0" gs:managed-name="Substring" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="37185">Copies a substring out of a UTF-8 encoded string.
The substring will contain @end_pos - @start_pos characters.</doc>
        <source-position filename="gunicode.h" line="796" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="37194">a newly allocated copy of the requested
    substring. Free with g_free() when no longer needed.</doc>
          <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="str" transfer-ownership="none" gs:managed-name="str" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37187">a UTF-8 encoded string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="start_pos" transfer-ownership="none" gs:managed-name="startPos" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37188">a character offset within @str</doc>
            <type name="glong" c:type="glong" gs:managed-name="GISharp.Runtime.CLong" />
          </parameter>
          <parameter name="end_pos" transfer-ownership="none" gs:managed-name="endPos" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37189">another character offset within @str</doc>
            <type name="glong" c:type="glong" gs:managed-name="GISharp.Runtime.CLong" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="str" transfer-ownership="none" gs:managed-name="str" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37187">a UTF-8 encoded string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="start_pos" transfer-ownership="none" gs:managed-name="startPos" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37188">a character offset within @str</doc>
            <type name="glong" c:type="glong" gs:managed-name="GISharp.Runtime.CLong" />
          </parameter>
          <parameter name="end_pos" transfer-ownership="none" gs:managed-name="endPos" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37189">another character offset within @str</doc>
            <type name="glong" c:type="glong" gs:managed-name="GISharp.Runtime.CLong" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="to_ucs4" c:identifier="g_utf8_to_ucs4" throws="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="ToUcs4" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="37200">Convert a string from UTF-8 to a 32-bit fixed width
representation as UCS-4. A trailing 0 character will be added to the
string after the converted text.</doc>
        <source-position filename="gunicode.h" line="826" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="37222">a pointer to a newly allocated UCS-4 string.
    This value must be freed with g_free(). If an error occurs,
    %NULL will be returned and @error set.</doc>
          <type name="gunichar" c:type="gunichar*" gs:managed-name="GISharp.Lib.GLib.Unichar" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="str" transfer-ownership="none" gs:managed-name="str" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37202">a UTF-8 encoded string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="len" transfer-ownership="none" gs:managed-name="len" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37203">the maximum length of @str to use, in bytes. If @len &lt; 0,
    then the string is nul-terminated.</doc>
            <type name="glong" c:type="glong" gs:managed-name="GISharp.Runtime.CLong" />
          </parameter>
          <parameter name="items_read" direction="out" caller-allocates="1" transfer-ownership="none" optional="1" allow-none="1" gs:managed-name="itemsRead">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37205">location to store number of
   bytes read, or %NULL.
    If %NULL, then %G_CONVERT_ERROR_PARTIAL_INPUT will be
    returned in case @str contains a trailing partial
    character. If an error occurs then the index of the
    invalid input is stored here.</doc>
            <type name="glong" c:type="glong*" gs:managed-name="GISharp.Runtime.CLong" />
          </parameter>
          <parameter name="items_written" direction="out" caller-allocates="1" transfer-ownership="none" optional="1" allow-none="1" gs:managed-name="itemsWritten">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37211">location to store number
    of characters written or %NULL. The value here stored does not include
    the trailing 0 character.</doc>
            <type name="glong" c:type="glong*" gs:managed-name="GISharp.Runtime.CLong" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:managed-name="GISharp.Lib.GLib.Error" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="str" transfer-ownership="none" gs:managed-name="str" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37202">a UTF-8 encoded string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="len" transfer-ownership="none" gs:managed-name="len" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37203">the maximum length of @str to use, in bytes. If @len &lt; 0,
    then the string is nul-terminated.</doc>
            <type name="glong" c:type="glong" gs:managed-name="GISharp.Runtime.CLong" />
          </parameter>
          <parameter name="items_read" direction="out" caller-allocates="1" transfer-ownership="none" optional="1" allow-none="1" gs:managed-name="itemsRead">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37205">location to store number of
   bytes read, or %NULL.
    If %NULL, then %G_CONVERT_ERROR_PARTIAL_INPUT will be
    returned in case @str contains a trailing partial
    character. If an error occurs then the index of the
    invalid input is stored here.</doc>
            <type name="glong" c:type="glong*" gs:managed-name="GISharp.Runtime.CLong" />
          </parameter>
          <parameter name="items_written" direction="out" caller-allocates="1" transfer-ownership="none" optional="1" allow-none="1" gs:managed-name="itemsWritten">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37211">location to store number
    of characters written or %NULL. The value here stored does not include
    the trailing 0 character.</doc>
            <type name="glong" c:type="glong*" gs:managed-name="GISharp.Runtime.CLong" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="to_ucs4_fast" c:identifier="g_utf8_to_ucs4_fast" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="ToUcs4Fast" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="37228">Convert a string from UTF-8 to a 32-bit fixed width
representation as UCS-4, assuming valid UTF-8 input.
This function is roughly twice as fast as g_utf8_to_ucs4()
but does no error checking on the input. A trailing 0 character
will be added to the string after the converted text.</doc>
        <source-position filename="gunicode.h" line="832" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="37242">a pointer to a newly allocated UCS-4 string.
    This value must be freed with g_free().</doc>
          <type name="gunichar" c:type="gunichar*" gs:managed-name="GISharp.Lib.GLib.Unichar" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="str" transfer-ownership="none" gs:managed-name="str" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37230">a UTF-8 encoded string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="len" transfer-ownership="none" gs:managed-name="len" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37231">the maximum length of @str to use, in bytes. If @len &lt; 0,
    then the string is nul-terminated.</doc>
            <type name="glong" c:type="glong" gs:managed-name="GISharp.Runtime.CLong" />
          </parameter>
          <parameter name="items_written" direction="out" caller-allocates="1" transfer-ownership="none" optional="1" allow-none="1" gs:managed-name="itemsWritten">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37233">location to store the
    number of characters in the result, or %NULL.</doc>
            <type name="glong" c:type="glong*" gs:managed-name="GISharp.Runtime.CLong" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="str" transfer-ownership="none" gs:managed-name="str" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37230">a UTF-8 encoded string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="len" transfer-ownership="none" gs:managed-name="len" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37231">the maximum length of @str to use, in bytes. If @len &lt; 0,
    then the string is nul-terminated.</doc>
            <type name="glong" c:type="glong" gs:managed-name="GISharp.Runtime.CLong" />
          </parameter>
          <parameter name="items_written" direction="out" caller-allocates="1" transfer-ownership="none" optional="1" allow-none="1" gs:managed-name="itemsWritten">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37233">location to store the
    number of characters in the result, or %NULL.</doc>
            <type name="glong" c:type="glong*" gs:managed-name="GISharp.Runtime.CLong" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="to_utf16" c:identifier="g_utf8_to_utf16" throws="1" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="ToUtf16" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="37247">Convert a string from UTF-8 to UTF-16. A 0 character will be
added to the result after the converted text.</doc>
        <source-position filename="gunicode.h" line="820" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="37266">a pointer to a newly allocated UTF-16 string.
    This value must be freed with g_free(). If an error occurs,
    %NULL will be returned and @error set.</doc>
          <type name="guint16" c:type="gunichar2*" gs:managed-name="System.UInt16" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="str" transfer-ownership="none" gs:managed-name="str" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37249">a UTF-8 encoded string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="len" transfer-ownership="none" gs:managed-name="len" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37250">the maximum length (number of bytes) of @str to use.
    If @len &lt; 0, then the string is nul-terminated.</doc>
            <type name="glong" c:type="glong" gs:managed-name="GISharp.Runtime.CLong" />
          </parameter>
          <parameter name="items_read" direction="out" caller-allocates="1" transfer-ownership="none" optional="1" allow-none="1" gs:managed-name="itemsRead">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37252">location to store number of
    bytes read, or %NULL. If %NULL, then %G_CONVERT_ERROR_PARTIAL_INPUT will
    be returned in case @str contains a trailing partial character. If
    an error occurs then the index of the invalid input is stored here.</doc>
            <type name="glong" c:type="glong*" gs:managed-name="GISharp.Runtime.CLong" />
          </parameter>
          <parameter name="items_written" direction="out" caller-allocates="1" transfer-ownership="none" optional="1" allow-none="1" gs:managed-name="itemsWritten">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37256">location to store number
    of #gunichar2 written, or %NULL. The value stored here does not include
    the trailing 0.</doc>
            <type name="glong" c:type="glong*" gs:managed-name="GISharp.Runtime.CLong" />
          </parameter>
          <gs:error-parameter name="error" direction="inout" transfer-ownership="full" gs:managed-name="error">
            <doc>return location for a #GError</doc>
            <type name="GLib.Error" c:type="GError**" gs:managed-name="GISharp.Lib.GLib.Error" gs:is-pointer="1" />
          </gs:error-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="str" transfer-ownership="none" gs:managed-name="str" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37249">a UTF-8 encoded string</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="len" transfer-ownership="none" gs:managed-name="len" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37250">the maximum length (number of bytes) of @str to use.
    If @len &lt; 0, then the string is nul-terminated.</doc>
            <type name="glong" c:type="glong" gs:managed-name="GISharp.Runtime.CLong" />
          </parameter>
          <parameter name="items_read" direction="out" caller-allocates="1" transfer-ownership="none" optional="1" allow-none="1" gs:managed-name="itemsRead">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37252">location to store number of
    bytes read, or %NULL. If %NULL, then %G_CONVERT_ERROR_PARTIAL_INPUT will
    be returned in case @str contains a trailing partial character. If
    an error occurs then the index of the invalid input is stored here.</doc>
            <type name="glong" c:type="glong*" gs:managed-name="GISharp.Runtime.CLong" />
          </parameter>
          <parameter name="items_written" direction="out" caller-allocates="1" transfer-ownership="none" optional="1" allow-none="1" gs:managed-name="itemsWritten">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37256">location to store number
    of #gunichar2 written, or %NULL. The value stored here does not include
    the trailing 0.</doc>
            <type name="glong" c:type="glong*" gs:managed-name="GISharp.Runtime.CLong" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="validate" c:identifier="g_utf8_validate" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="TryValidate" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="37272">Validates UTF-8 encoded text. @str is the text to validate;
if @str is nul-terminated, then @max_len can be -1, otherwise
@max_len should be the number of bytes to validate.
If @end is non-%NULL, then the end of the valid range
will be stored there (i.e. the start of the first invalid
character if some bytes were invalid, or the end of the text
being validated otherwise).

Note that g_utf8_validate() returns %FALSE if @max_len is
positive and any of the @max_len bytes are nul.

Returns %TRUE if all of @str was valid. Many GLib and GTK+
routines require valid UTF-8 as input; so data read from a file
or the network should be checked with g_utf8_validate() before
doing anything else with it.</doc>
        <source-position filename="gunicode.h" line="865" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="37294">%TRUE if the text was valid UTF-8</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="str" transfer-ownership="none" gs:managed-name="str" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37274">a pointer to character data</doc>
            <array length="1" zero-terminated="0" c:type="const gchar*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="guint8" gs:managed-name="System.Byte" />
            </array>
          </instance-parameter>
          <parameter name="max_len" transfer-ownership="none" gs:managed-name="maxLen" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37275">max bytes to validate, or -1 to go until NUL</doc>
            <type name="gssize" c:type="gssize" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="end" direction="out" caller-allocates="0" transfer-ownership="none" optional="1" allow-none="1" gs:managed-name="end">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37276">return location for end of valid data</doc>
            <type name="utf8" c:type="const gchar**" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="str" transfer-ownership="none" gs:managed-name="str" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37274">a pointer to character data</doc>
            <array length="1" zero-terminated="0" c:type="const gchar*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="guint8" gs:managed-name="System.Byte" />
            </array>
          </instance-parameter>
          <parameter name="max_len" transfer-ownership="none" gs:managed-name="maxLen" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37275">max bytes to validate, or -1 to go until NUL</doc>
            <type name="gssize" c:type="gssize" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="end" direction="out" caller-allocates="0" transfer-ownership="none" optional="1" allow-none="1" gs:managed-name="end">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37276">return location for end of valid data</doc>
            <type name="utf8" c:type="const gchar**" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="validate_len" c:identifier="g_utf8_validate_len" version="2.60" gs:pinvoke-only="1" gs:dll-name="glib-2.0" gs:managed-name="TryValidateLen" gs:extension-method="1">
        <doc xml:space="preserve" filename="glib-2.0.c" line="37298">Validates UTF-8 encoded text.

As with g_utf8_validate(), but @max_len must be set, and hence this function
will always return %FALSE if any of the bytes of @str are nul.</doc>
        <source-position filename="gunicode.h" line="869" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="glib-2.0.c" line="37309">%TRUE if the text was valid UTF-8</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="str" transfer-ownership="none" gs:managed-name="str" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37300">a pointer to character data</doc>
            <array length="1" zero-terminated="0" c:type="const gchar*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="guint8" gs:managed-name="System.Byte" />
            </array>
          </instance-parameter>
          <parameter name="max_len" transfer-ownership="none" gs:managed-name="maxLen" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37301">max bytes to validate</doc>
            <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="end" direction="out" caller-allocates="0" transfer-ownership="none" optional="1" allow-none="1" gs:managed-name="end">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37302">return location for end of valid data</doc>
            <type name="utf8" c:type="const gchar**" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="str" transfer-ownership="none" gs:managed-name="str" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37300">a pointer to character data</doc>
            <array length="1" zero-terminated="0" c:type="const gchar*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="guint8" gs:managed-name="System.Byte" />
            </array>
          </instance-parameter>
          <parameter name="max_len" transfer-ownership="none" gs:managed-name="maxLen" direction="in">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37301">max bytes to validate</doc>
            <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="end" direction="out" caller-allocates="0" transfer-ownership="none" optional="1" allow-none="1" gs:managed-name="end">
            <doc xml:space="preserve" filename="glib-2.0.c" line="37302">return location for end of valid data</doc>
            <type name="utf8" c:type="const gchar**" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
    </gs:static-class>
  </namespace>
</repository>