// SPDX-License-Identifier: MIT
// ATTENTION: This file is automatically generated. Do not edit manually.
#nullable enable
namespace GISharp.Lib.GIRepository
{
    /// <include file="UnionInfo.xmldoc" path="declaration/member[@name='UnionInfo']/*" />
    public unsafe partial class UnionInfo : GISharp.Lib.GIRepository.RegisteredTypeInfo
    {
        /// <summary>
        /// The unmanaged data structure.
        /// </summary>
        public new struct UnmanagedStruct
        {
        }

        /// <include file="UnionInfo.xmldoc" path="declaration/member[@name='UnionInfo.Alignment']/*" />
        public System.Int32 Alignment { get => GetAlignment(); }

        /// <include file="UnionInfo.xmldoc" path="declaration/member[@name='UnionInfo.DiscriminatorOffset']/*" />
        public System.Int32 DiscriminatorOffset { get => GetDiscriminatorOffset(); }

        /// <include file="UnionInfo.xmldoc" path="declaration/member[@name='UnionInfo.DiscriminatorType']/*" />
        public GISharp.Lib.GIRepository.TypeInfo DiscriminatorType { get => GetDiscriminatorType(); }

        /// <include file="UnionInfo.xmldoc" path="declaration/member[@name='UnionInfo.NFields']/*" />
        private System.Int32 NFields { get => GetNFields(); }

        /// <include file="UnionInfo.xmldoc" path="declaration/member[@name='UnionInfo.NMethods']/*" />
        private System.Int32 NMethods { get => GetNMethods(); }

        /// <include file="UnionInfo.xmldoc" path="declaration/member[@name='UnionInfo.Size']/*" />
        public System.Int32 Size { get => GetSize(); }

        /// <include file="UnionInfo.xmldoc" path="declaration/member[@name='UnionInfo.IsDiscriminated']/*" />
        public System.Boolean IsDiscriminated { get => GetIsDiscriminated(); }

        /// <summary>
        /// For internal runtime use only.
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        public UnionInfo(System.IntPtr handle, GISharp.Runtime.Transfer ownership) : base(handle, ownership)
        {
        }

        /// <summary>
        /// Obtain the type information for method named @name.
        /// </summary>
        /// <param name="info">
        /// a #GIUnionInfo
        /// </param>
        /// <param name="name">
        /// a method name
        /// </param>
        /// <returns>
        /// the #GIFunctionInfo, free it with g_base_info_unref()
        /// when done.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FunctionInfo" type="GIFunctionInfo*" managed-name="FunctionInfo" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GIRepository.FunctionInfo.UnmanagedStruct* g_union_info_find_method(
        /* <type name="UnionInfo" type="GIUnionInfo*" managed-name="UnionInfo" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.UnionInfo.UnmanagedStruct* info,
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.Byte* name);
        partial void CheckFindMethodArgs(GISharp.Lib.GLib.UnownedUtf8 name);

        /// <include file="UnionInfo.xmldoc" path="declaration/member[@name='UnionInfo.FindMethod(GISharp.Lib.GLib.UnownedUtf8)']/*" />
        public GISharp.Lib.GIRepository.FunctionInfo FindMethod(GISharp.Lib.GLib.UnownedUtf8 name)
        {
            CheckFindMethodArgs(name);
            var info_ = (GISharp.Lib.GIRepository.UnionInfo.UnmanagedStruct*)UnsafeHandle;
            var name_ = (System.Byte*)name.UnsafeHandle;
            var ret_ = g_union_info_find_method(info_,name_);
            var ret = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GIRepository.FunctionInfo>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Obtain the required alignment of the union.
        /// </summary>
        /// <param name="info">
        /// a #GIUnionInfo
        /// </param>
        /// <returns>
        /// required alignment in bytes
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gsize" type="gsize" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        private static extern nuint g_union_info_get_alignment(
        /* <type name="UnionInfo" type="GIUnionInfo*" managed-name="UnionInfo" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.UnionInfo.UnmanagedStruct* info);
        partial void CheckGetAlignmentArgs();

        private System.Int32 GetAlignment()
        {
            CheckGetAlignmentArgs();
            var info_ = (GISharp.Lib.GIRepository.UnionInfo.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_union_info_get_alignment(info_);
            var ret = (System.Int32)ret_;
            return ret;
        }

        /// <summary>
        /// Obtain discriminator value assigned for n-th union field, i.e. n-th
        /// union field is the active one if discriminator contains this
        /// constant.
        /// </summary>
        /// <param name="info">
        /// a #GIUnionInfo
        /// </param>
        /// <param name="n">
        /// a union field index
        /// </param>
        /// <returns>
        /// the #GIConstantInfo, free it with g_base_info_unref()
        /// when done.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="ConstantInfo" type="GIConstantInfo*" managed-name="ConstantInfo" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GIRepository.ConstantInfo.UnmanagedStruct* g_union_info_get_discriminator(
        /* <type name="UnionInfo" type="GIUnionInfo*" managed-name="UnionInfo" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.UnionInfo.UnmanagedStruct* info,
        /* <type name="gint" type="gint" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        System.Int32 n);
        partial void CheckGetDiscriminatorArgs(System.Int32 n);

        /// <include file="UnionInfo.xmldoc" path="declaration/member[@name='UnionInfo.GetDiscriminator(System.Int32)']/*" />
        public GISharp.Lib.GIRepository.ConstantInfo GetDiscriminator(System.Int32 n)
        {
            CheckGetDiscriminatorArgs(n);
            var info_ = (GISharp.Lib.GIRepository.UnionInfo.UnmanagedStruct*)UnsafeHandle;
            var n_ = (System.Int32)n;
            var ret_ = g_union_info_get_discriminator(info_,n_);
            var ret = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GIRepository.ConstantInfo>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Returns offset of the discriminator field in the structure.
        /// </summary>
        /// <param name="info">
        /// a #GIUnionInfo
        /// </param>
        /// <returns>
        /// offset in bytes of the discriminator
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gint" type="gint" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        private static extern System.Int32 g_union_info_get_discriminator_offset(
        /* <type name="UnionInfo" type="GIUnionInfo*" managed-name="UnionInfo" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.UnionInfo.UnmanagedStruct* info);
        partial void CheckGetDiscriminatorOffsetArgs();

        private System.Int32 GetDiscriminatorOffset()
        {
            CheckGetDiscriminatorOffsetArgs();
            var info_ = (GISharp.Lib.GIRepository.UnionInfo.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_union_info_get_discriminator_offset(info_);
            var ret = (System.Int32)ret_;
            return ret;
        }

        /// <summary>
        /// Obtain the type information of the union discriminator.
        /// </summary>
        /// <param name="info">
        /// a #GIUnionInfo
        /// </param>
        /// <returns>
        /// the #GITypeInfo, free it with g_base_info_unref()
        /// when done.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="TypeInfo" type="GITypeInfo*" managed-name="TypeInfo" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GIRepository.TypeInfo.UnmanagedStruct* g_union_info_get_discriminator_type(
        /* <type name="UnionInfo" type="GIUnionInfo*" managed-name="UnionInfo" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.UnionInfo.UnmanagedStruct* info);
        partial void CheckGetDiscriminatorTypeArgs();

        private GISharp.Lib.GIRepository.TypeInfo GetDiscriminatorType()
        {
            CheckGetDiscriminatorTypeArgs();
            var info_ = (GISharp.Lib.GIRepository.UnionInfo.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_union_info_get_discriminator_type(info_);
            var ret = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GIRepository.TypeInfo>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Obtain the type information for field with specified index.
        /// </summary>
        /// <param name="info">
        /// a #GIUnionInfo
        /// </param>
        /// <param name="n">
        /// a field index
        /// </param>
        /// <returns>
        /// the #GIFieldInfo, free it with g_base_info_unref()
        /// when done.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FieldInfo" type="GIFieldInfo*" managed-name="FieldInfo" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GIRepository.FieldInfo.UnmanagedStruct* g_union_info_get_field(
        /* <type name="UnionInfo" type="GIUnionInfo*" managed-name="UnionInfo" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.UnionInfo.UnmanagedStruct* info,
        /* <type name="gint" type="gint" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        System.Int32 n);
        partial void CheckGetFieldArgs(System.Int32 n);

        private GISharp.Lib.GIRepository.FieldInfo GetField(System.Int32 n)
        {
            CheckGetFieldArgs(n);
            var info_ = (GISharp.Lib.GIRepository.UnionInfo.UnmanagedStruct*)UnsafeHandle;
            var n_ = (System.Int32)n;
            var ret_ = g_union_info_get_field(info_,n_);
            var ret = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GIRepository.FieldInfo>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Obtain the type information for method with specified index.
        /// </summary>
        /// <param name="info">
        /// a #GIUnionInfo
        /// </param>
        /// <param name="n">
        /// a method index
        /// </param>
        /// <returns>
        /// the #GIFunctionInfo, free it with g_base_info_unref()
        /// when done.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FunctionInfo" type="GIFunctionInfo*" managed-name="FunctionInfo" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GIRepository.FunctionInfo.UnmanagedStruct* g_union_info_get_method(
        /* <type name="UnionInfo" type="GIUnionInfo*" managed-name="UnionInfo" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.UnionInfo.UnmanagedStruct* info,
        /* <type name="gint" type="gint" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        System.Int32 n);
        partial void CheckGetMethodArgs(System.Int32 n);

        private GISharp.Lib.GIRepository.FunctionInfo GetMethod(System.Int32 n)
        {
            CheckGetMethodArgs(n);
            var info_ = (GISharp.Lib.GIRepository.UnionInfo.UnmanagedStruct*)UnsafeHandle;
            var n_ = (System.Int32)n;
            var ret_ = g_union_info_get_method(info_,n_);
            var ret = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GIRepository.FunctionInfo>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Obtain the number of fields this union has.
        /// </summary>
        /// <param name="info">
        /// a #GIUnionInfo
        /// </param>
        /// <returns>
        /// number of fields
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gint" type="gint" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        private static extern System.Int32 g_union_info_get_n_fields(
        /* <type name="UnionInfo" type="GIUnionInfo*" managed-name="UnionInfo" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.UnionInfo.UnmanagedStruct* info);
        partial void CheckGetNFieldsArgs();

        private System.Int32 GetNFields()
        {
            CheckGetNFieldsArgs();
            var info_ = (GISharp.Lib.GIRepository.UnionInfo.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_union_info_get_n_fields(info_);
            var ret = (System.Int32)ret_;
            return ret;
        }

        /// <summary>
        /// Obtain the number of methods this union has.
        /// </summary>
        /// <param name="info">
        /// a #GIUnionInfo
        /// </param>
        /// <returns>
        /// number of methods
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gint" type="gint" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        private static extern System.Int32 g_union_info_get_n_methods(
        /* <type name="UnionInfo" type="GIUnionInfo*" managed-name="UnionInfo" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.UnionInfo.UnmanagedStruct* info);
        partial void CheckGetNMethodsArgs();

        private System.Int32 GetNMethods()
        {
            CheckGetNMethodsArgs();
            var info_ = (GISharp.Lib.GIRepository.UnionInfo.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_union_info_get_n_methods(info_);
            var ret = (System.Int32)ret_;
            return ret;
        }

        /// <summary>
        /// Obtain the total size of the union.
        /// </summary>
        /// <param name="info">
        /// a #GIUnionInfo
        /// </param>
        /// <returns>
        /// size of the union in bytes
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gsize" type="gsize" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        private static extern nuint g_union_info_get_size(
        /* <type name="UnionInfo" type="GIUnionInfo*" managed-name="UnionInfo" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.UnionInfo.UnmanagedStruct* info);
        partial void CheckGetSizeArgs();

        private System.Int32 GetSize()
        {
            CheckGetSizeArgs();
            var info_ = (GISharp.Lib.GIRepository.UnionInfo.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_union_info_get_size(info_);
            var ret = (System.Int32)ret_;
            return ret;
        }

        /// <summary>
        /// Return true if this union contains discriminator field.
        /// </summary>
        /// <param name="info">
        /// a #GIUnionInfo
        /// </param>
        /// <returns>
        /// %TRUE if this is a discriminated union, %FALSE otherwise
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("girepository-1.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_union_info_is_discriminated(
        /* <type name="UnionInfo" type="GIUnionInfo*" managed-name="UnionInfo" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GIRepository.UnionInfo.UnmanagedStruct* info);
        partial void CheckGetIsDiscriminatedArgs();

        private System.Boolean GetIsDiscriminated()
        {
            CheckGetIsDiscriminatedArgs();
            var info_ = (GISharp.Lib.GIRepository.UnionInfo.UnmanagedStruct*)UnsafeHandle;
            var ret_ = g_union_info_is_discriminated(info_);
            var ret = GISharp.Runtime.BooleanExtensions.IsTrue(ret_);
            return ret;
        }
    }
}