// SPDX-License-Identifier: MIT
// ATTENTION: This file is automatically generated. Do not edit manually.
#nullable enable
namespace GISharp.Lib.GObject
{
    /// <include file="Closure.xmldoc" path="declaration/member[@name='Closure']/*" />
    [GISharp.Runtime.GTypeAttribute("GClosure", IsProxyForUnmanagedType = true)]
    public sealed unsafe partial class Closure : GISharp.Lib.GObject.Boxed
    {
        private static readonly GISharp.Lib.GObject.GType _GType = g_closure_get_type();

        /// <summary>
        /// The unmanaged data structure.
        /// </summary>
        public struct UnmanagedStruct
        {
#pragma warning disable CS0169, CS0649
            /// <include file="Closure.xmldoc" path="declaration/member[@name='UnmanagedStruct.RefCount']/*" />
            private readonly System.UInt32 RefCount;

            /// <include file="Closure.xmldoc" path="declaration/member[@name='UnmanagedStruct.MetaMarshalNouse']/*" />
            private readonly System.UInt32 MetaMarshalNouse;

            /// <include file="Closure.xmldoc" path="declaration/member[@name='UnmanagedStruct.NGuards']/*" />
            private readonly System.UInt32 NGuards;

            /// <include file="Closure.xmldoc" path="declaration/member[@name='UnmanagedStruct.NFnotifiers']/*" />
            private readonly System.UInt32 NFnotifiers;

            /// <include file="Closure.xmldoc" path="declaration/member[@name='UnmanagedStruct.NInotifiers']/*" />
            private readonly System.UInt32 NInotifiers;

            /// <include file="Closure.xmldoc" path="declaration/member[@name='UnmanagedStruct.InInotify']/*" />
            private readonly System.UInt32 InInotify;

            /// <include file="Closure.xmldoc" path="declaration/member[@name='UnmanagedStruct.Floating']/*" />
            private readonly System.UInt32 Floating;

            /// <include file="Closure.xmldoc" path="declaration/member[@name='UnmanagedStruct.DerivativeFlag']/*" />
            private readonly System.UInt32 DerivativeFlag;

            /// <include file="Closure.xmldoc" path="declaration/member[@name='UnmanagedStruct.InMarshal']/*" />
            public readonly System.UInt32 InMarshal;

            /// <include file="Closure.xmldoc" path="declaration/member[@name='UnmanagedStruct.IsInvalid']/*" />
            public readonly System.UInt32 IsInvalid;

            /// <include file="Closure.xmldoc" path="declaration/member[@name='UnmanagedStruct.Marshal']/*" />
            public readonly System.IntPtr Marshal;

            /// <include file="Closure.xmldoc" path="declaration/member[@name='UnmanagedStruct.Data']/*" />
            private readonly System.IntPtr Data;

            /// <include file="Closure.xmldoc" path="declaration/member[@name='UnmanagedStruct.Notifiers']/*" />
            private readonly GISharp.Lib.GObject.ClosureNotifyData* Notifiers;
#pragma warning restore CS0169, CS0649
        }

        /// <summary>
        /// For internal runtime use only.
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        public Closure(System.IntPtr handle, GISharp.Runtime.Transfer ownership) : base(handle)
        {
            if (ownership == GISharp.Runtime.Transfer.None)
            {
                this.handle = (System.IntPtr)g_closure_ref((UnmanagedStruct*)handle);
            }
        }

        static partial void CheckNewObjectArgs(System.UInt32 sizeofClosure, GISharp.Lib.GObject.Object @object);

        /// <summary>
        /// A variant of g_closure_new_simple() which stores @object in the
        /// @data field of the closure and calls g_object_watch_closure() on
        /// @object and the created closure. This function is mainly useful
        /// when implementing new types of closures.
        /// </summary>
        /// <param name="sizeofClosure">
        /// the size of the structure to allocate, must be at least
        ///  `sizeof (GClosure)`
        /// </param>
        /// <param name="object">
        /// a #GObject pointer to store in the @data field of the newly
        ///  allocated #GClosure
        /// </param>
        /// <returns>
        /// a newly allocated #GClosure
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Closure" type="GClosure*" managed-name="Closure" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GObject.Closure.UnmanagedStruct* g_closure_new_object(
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        System.UInt32 sizeofClosure,
        /* <type name="Object" type="GObject*" managed-name="Object" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Object.UnmanagedStruct* @object);

        static GISharp.Lib.GObject.Closure.UnmanagedStruct* NewObject(System.UInt32 sizeofClosure, GISharp.Lib.GObject.Object @object)
        {
            CheckNewObjectArgs(sizeofClosure, @object);
            var sizeofClosure_ = (System.UInt32)sizeofClosure;
            var @object_ = (GISharp.Lib.GObject.Object.UnmanagedStruct*)@object.UnsafeHandle;
            var ret_ = g_closure_new_object(sizeofClosure_,@object_);
            return ret_;
        }

        /// <include file="Closure.xmldoc" path="declaration/member[@name='Closure.Closure(System.UInt32,GISharp.Lib.GObject.Object)']/*" />
        public Closure(System.UInt32 sizeofClosure, GISharp.Lib.GObject.Object @object) : this((System.IntPtr)NewObject(sizeofClosure, @object), GISharp.Runtime.Transfer.Full)
        {
        }

        static partial void CheckNewSimpleArgs(System.UInt32 sizeofClosure, System.IntPtr data);

        /// <summary>
        /// Allocates a struct of the given size and initializes the initial
        /// part as a #GClosure. This function is mainly useful when
        /// implementing new types of closures.
        /// </summary>
        /// <remarks>
        /// |[&lt;!-- language="C" --&gt;
        /// typedef struct _MyClosure MyClosure;
        /// struct _MyClosure
        /// {
        ///   GClosure closure;
        ///   // extra data goes here
        /// };
        /// 
        /// static void
        /// my_closure_finalize (gpointer  notify_data,
        ///                      GClosure *closure)
        /// {
        ///   MyClosure *my_closure = (MyClosure *)closure;
        /// 
        ///   // free extra data here
        /// }
        /// 
        /// MyClosure *my_closure_new (gpointer data)
        /// {
        ///   GClosure *closure;
        ///   MyClosure *my_closure;
        /// 
        ///   closure = g_closure_new_simple (sizeof (MyClosure), data);
        ///   my_closure = (MyClosure *) closure;
        /// 
        ///   // initialize extra data here
        /// 
        ///   g_closure_add_finalize_notifier (closure, notify_data,
        ///                                    my_closure_finalize);
        ///   return my_closure;
        /// }
        /// ]|
        /// </remarks>
        /// <param name="sizeofClosure">
        /// the size of the structure to allocate, must be at least
        ///                  `sizeof (GClosure)`
        /// </param>
        /// <param name="data">
        /// data to store in the @data field of the newly allocated #GClosure
        /// </param>
        /// <returns>
        /// a floating reference to a new #GClosure
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Closure" type="GClosure*" managed-name="Closure" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GObject.Closure.UnmanagedStruct* g_closure_new_simple(
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        System.UInt32 sizeofClosure,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr data);

        static GISharp.Lib.GObject.Closure.UnmanagedStruct* NewSimple(System.UInt32 sizeofClosure, System.IntPtr data)
        {
            CheckNewSimpleArgs(sizeofClosure, data);
            var sizeofClosure_ = (System.UInt32)sizeofClosure;
            var data_ = (System.IntPtr)data;
            var ret_ = g_closure_new_simple(sizeofClosure_,data_);
            return ret_;
        }

        /// <include file="Closure.xmldoc" path="declaration/member[@name='Closure.Closure(System.UInt32,System.IntPtr)']/*" />
        public Closure(System.UInt32 sizeofClosure, System.IntPtr data) : this((System.IntPtr)NewSimple(sizeofClosure, data), GISharp.Runtime.Transfer.None)
        {
        }

        static partial void CheckGetGTypeArgs();
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="GType" type="GType" managed-name="GISharp.Lib.GObject.GType" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GObject.GType g_closure_get_type();

        /// <summary>
        /// Sets a flag on the closure to indicate that its calling
        /// environment has become invalid, and thus causes any future
        /// invocations of g_closure_invoke() on this @closure to be
        /// ignored. Also, invalidation notifiers installed on the closure will
        /// be called at this point. Note that unless you are holding a
        /// reference to the closure yourself, the invalidation notifiers may
        /// unref the closure and cause it to be destroyed, so if you need to
        /// access the closure after calling g_closure_invalidate(), make sure
        /// that you've previously called g_closure_ref().
        /// </summary>
        /// <remarks>
        /// Note that g_closure_invalidate() will also be called when the
        /// reference count of a closure drops to zero (unless it has already
        /// been invalidated before).
        /// </remarks>
        /// <param name="closure">
        /// #GClosure to invalidate
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_closure_invalidate(
        /* <type name="Closure" type="GClosure*" managed-name="Closure" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Closure.UnmanagedStruct* closure);
        partial void CheckInvalidateArgs();

        /// <include file="Closure.xmldoc" path="declaration/member[@name='Closure.Invalidate()']/*" />
        public void Invalidate()
        {
            CheckInvalidateArgs();
            var closure_ = (GISharp.Lib.GObject.Closure.UnmanagedStruct*)UnsafeHandle;
            g_closure_invalidate(closure_);
        }

        /// <summary>
        /// Invokes the closure, i.e. executes the callback represented by the @closure.
        /// </summary>
        /// <param name="closure">
        /// a #GClosure
        /// </param>
        /// <param name="returnValue">
        /// a #GValue to store the return
        ///                value. May be %NULL if the callback of @closure
        ///                doesn't return a value.
        /// </param>
        /// <param name="nParamValues">
        /// the length of the @param_values array
        /// </param>
        /// <param name="paramValues">
        /// an array of
        ///                #GValues holding the arguments on which to
        ///                invoke the callback of @closure
        /// </param>
        /// <param name="invocationHint">
        /// a context-dependent invocation hint
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_closure_invoke(
        /* <type name="Closure" type="GClosure*" managed-name="Closure" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Closure.UnmanagedStruct* closure,
        /* <type name="Value" type="GValue*" managed-name="Value" /> */
        /* direction:out caller-allocates:1 transfer-ownership:none optional:1 allow-none:1 */
        GISharp.Lib.GObject.Value* returnValue,
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        System.UInt32 nParamValues,
        /* <array length="1" zero-terminated="0" type="const GValue*" managed-name="GISharp.Runtime.CArray" is-pointer="1">
*   <type name="Value" type="GValue" managed-name="Value" />
* </array> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Value* paramValues,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr invocationHint);
        partial void CheckInvokeArgs(System.ReadOnlySpan<GISharp.Lib.GObject.Value> paramValues, System.IntPtr invocationHint);

        /// <include file="Closure.xmldoc" path="declaration/member[@name='Closure.Invoke(GISharp.Lib.GObject.Value,System.ReadOnlySpan&lt;GISharp.Lib.GObject.Value&gt;,System.IntPtr)']/*" />
        public void Invoke(out GISharp.Lib.GObject.Value returnValue, System.ReadOnlySpan<GISharp.Lib.GObject.Value> paramValues, System.IntPtr invocationHint)
        {
            fixed (GISharp.Lib.GObject.Value* paramValuesData_ = paramValues)
            {
                fixed (GISharp.Lib.GObject.Value* returnValue_ = &returnValue)
                {
                    CheckInvokeArgs(paramValues, invocationHint);
                    var closure_ = (GISharp.Lib.GObject.Closure.UnmanagedStruct*)UnsafeHandle;
                    var paramValues_ = (GISharp.Lib.GObject.Value*)paramValuesData_;
                    var nParamValues_ = (System.UInt32)paramValues.Length;
                    var invocationHint_ = (System.IntPtr)invocationHint;
                    g_closure_invoke(closure_, returnValue_, nParamValues_, paramValues_, invocationHint_);
                }
            }
        }

        /// <summary>
        /// Increments the reference count on a closure to force it staying
        /// alive while the caller holds a pointer to it.
        /// </summary>
        /// <param name="closure">
        /// #GClosure to increment the reference count on
        /// </param>
        /// <returns>
        /// The @closure passed in, for convenience
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Closure" type="GClosure*" managed-name="Closure" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GObject.Closure.UnmanagedStruct* g_closure_ref(
        /* <type name="Closure" type="GClosure*" managed-name="Closure" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Closure.UnmanagedStruct* closure);

        /// <summary>
        /// Takes ownership of the unmanaged pointer without freeing it.
        /// The managed object can no longer be used (will throw disposed exception).
        /// </summary>
        public override System.IntPtr Take() => (System.IntPtr)g_closure_ref((GISharp.Lib.GObject.Closure.UnmanagedStruct*)UnsafeHandle);

        /// <summary>
        /// Takes over the initial ownership of a closure.  Each closure is
        /// initially created in a "floating" state, which means that the initial
        /// reference count is not owned by any caller. g_closure_sink() checks
        /// to see if the object is still floating, and if so, unsets the
        /// floating state and decreases the reference count. If the closure
        /// is not floating, g_closure_sink() does nothing. The reason for the
        /// existence of the floating state is to prevent cumbersome code
        /// sequences like:
        /// |[&lt;!-- language="C" --&gt;
        /// closure = g_cclosure_new (cb_func, cb_data);
        /// g_source_set_closure (source, closure);
        /// g_closure_unref (closure); // GObject doesn't really need this
        /// ]|
        /// Because g_source_set_closure() (and similar functions) take ownership of the
        /// initial reference count, if it is unowned, we instead can write:
        /// |[&lt;!-- language="C" --&gt;
        /// g_source_set_closure (source, g_cclosure_new (cb_func, cb_data));
        /// ]|
        /// </summary>
        /// <remarks>
        /// Generally, this function is used together with g_closure_ref(). An example
        /// of storing a closure for later notification looks like:
        /// |[&lt;!-- language="C" --&gt;
        /// static GClosure *notify_closure = NULL;
        /// void
        /// foo_notify_set_closure (GClosure *closure)
        /// {
        ///   if (notify_closure)
        ///     g_closure_unref (notify_closure);
        ///   notify_closure = closure;
        ///   if (notify_closure)
        ///     {
        ///       g_closure_ref (notify_closure);
        ///       g_closure_sink (notify_closure);
        ///     }
        /// }
        /// ]|
        /// 
        /// Because g_closure_sink() may decrement the reference count of a closure
        /// (if it hasn't been called on @closure yet) just like g_closure_unref(),
        /// g_closure_ref() should be called prior to this function.
        /// </remarks>
        /// <param name="closure">
        /// #GClosure to decrement the initial reference count on, if it's
        ///           still being held
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_closure_sink(
        /* <type name="Closure" type="GClosure*" managed-name="Closure" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Closure.UnmanagedStruct* closure);
        partial void CheckSinkArgs();

        /// <include file="Closure.xmldoc" path="declaration/member[@name='Closure.Sink()']/*" />
        public void Sink()
        {
            CheckSinkArgs();
            var closure_ = (GISharp.Lib.GObject.Closure.UnmanagedStruct*)UnsafeHandle;
            g_closure_sink(closure_);
        }

        /// <summary>
        /// Decrements the reference count of a closure after it was previously
        /// incremented by the same caller. If no other callers are using the
        /// closure, then the closure will be destroyed and freed.
        /// </summary>
        /// <param name="closure">
        /// #GClosure to decrement the reference count on
        /// </param>
        [System.Runtime.InteropServices.DllImportAttribute("gobject-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:in */
        private static extern void g_closure_unref(
        /* <type name="Closure" type="GClosure*" managed-name="Closure" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Closure.UnmanagedStruct* closure);

        /// <inheritdoc/>
        protected override void Dispose(bool disposing)
        {
            if (handle != System.IntPtr.Zero)
            {
                g_closure_unref((UnmanagedStruct*)handle);
            }

            base.Dispose(disposing);
        }
    }
}