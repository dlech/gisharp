<?xml version="1.0" encoding="utf-8"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2" xmlns="http://www.gtk.org/introspection/core/1.0" xmlns:c="http://www.gtk.org/introspection/c/1.0" xmlns:glib="http://www.gtk.org/introspection/glib/1.0" xmlns:gs="http://gisharp.org/introspection/gisharp/1.0">
  <include name="GLib" version="2.0" gs:managed-name="GLib" />
  <package name="gobject-2.0" gs:managed-name="Gobject2.0" />
  <c:include name="glib-object.h" gs:managed-name="GlibObject.h" />
  <namespace name="GObject" version="2.0" shared-library="/usr/local/opt/glib/lib/libgobject-2.0.0.dylib" c:identifier-prefixes="G" c:symbol-prefixes="g" gs:managed-name="GObject">
    <alias name="Type" c:type="GType" gs:managed-name="Type">
      <doc xml:space="preserve" filename="gtype.h" line="377">A numerical value which represents the unique identifier of a registered
type.</doc>
      <source-position filename="gtype.h" line="384" />
      <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
    </alias>
    <callback name="BaseFinalizeFunc" c:type="GBaseFinalizeFunc" gs:dll-name="gobject-2.0" gs:managed-name="BaseFinalizeFunc" gs:pinvoke-only="1">
      <doc xml:space="preserve" filename="gtype.h" line="773">A callback function used by the type system to finalize those portions
of a derived types class structure that were setup from the corresponding
GBaseInitFunc() function. Class finalization basically works the inverse
way in which class initialization is performed.
See GClassInitFunc() for a discussion of the class initialization process.</doc>
      <source-position filename="gtype.h" line="783" />
      <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
        <type name="none" c:type="void" gs:managed-name="System.Void" />
      </return-value>
      <parameters>
        <parameter name="g_class" transfer-ownership="none" gs:managed-name="gClass" direction="in">
          <doc xml:space="preserve" filename="gtype.h" line="775">The #GTypeClass structure to finalize</doc>
          <type name="TypeClass" c:type="gpointer" gs:managed-name="TypeClass" gs:is-pointer="1" />
        </parameter>
      </parameters>
      <gs:managed-parameters>
        <parameter name="g_class" transfer-ownership="none" gs:managed-name="gClass" direction="in">
          <doc xml:space="preserve" filename="gtype.h" line="775">The #GTypeClass structure to finalize</doc>
          <type name="TypeClass" c:type="gpointer" gs:managed-name="TypeClass" gs:is-pointer="1" />
        </parameter>
      </gs:managed-parameters>
    </callback>
    <callback name="BaseInitFunc" c:type="GBaseInitFunc" gs:dll-name="gobject-2.0" gs:managed-name="BaseInitFunc" gs:pinvoke-only="1">
      <doc xml:space="preserve" filename="gtype.h" line="759">A callback function used by the type system to do base initialization
of the class structures of derived types. It is called as part of the
initialization process of all derived classes and should reallocate
or reset all dynamic class members copied over from the parent class.
For example, class members (such as strings) that are not sufficiently
handled by a plain memory copy of the parent class into the derived class
have to be altered. See GClassInitFunc() for a discussion of the class
initialization process.</doc>
      <source-position filename="gtype.h" line="772" />
      <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
        <type name="none" c:type="void" gs:managed-name="System.Void" />
      </return-value>
      <parameters>
        <parameter name="g_class" transfer-ownership="none" gs:managed-name="gClass" direction="in">
          <doc xml:space="preserve" filename="gtype.h" line="761">The #GTypeClass structure to initialize</doc>
          <type name="TypeClass" c:type="gpointer" gs:managed-name="TypeClass" gs:is-pointer="1" />
        </parameter>
      </parameters>
      <gs:managed-parameters>
        <parameter name="g_class" transfer-ownership="none" gs:managed-name="gClass" direction="in">
          <doc xml:space="preserve" filename="gtype.h" line="761">The #GTypeClass structure to initialize</doc>
          <type name="TypeClass" c:type="gpointer" gs:managed-name="TypeClass" gs:is-pointer="1" />
        </parameter>
      </gs:managed-parameters>
    </callback>
    <class name="Binding" c:symbol-prefix="binding" c:type="GBinding" version="2.26" parent="Object" glib:type-name="GBinding" glib:get-type="g_binding_get_type" gs:managed-name="Binding">
      <doc xml:space="preserve" filename="gobject-2.0.c" line="162">#GBinding is the representation of a binding between a property on a
#GObject instance (or source) and another property on another #GObject
instance (or target). Whenever the source property changes, the same
value is applied to the target property; for instance, the following
binding:

|[&lt;!-- language="C" --&gt;
  g_object_bind_property (object1, "property-a",
                          object2, "property-b",
                          G_BINDING_DEFAULT);
]|

will cause the property named "property-b" of @object2 to be updated
every time g_object_set() or the specific accessor changes the value of
the property "property-a" of @object1.

It is possible to create a bidirectional binding between two properties
of two #GObject instances, so that if either property changes, the
other is updated as well, for instance:

|[&lt;!-- language="C" --&gt;
  g_object_bind_property (object1, "property-a",
                          object2, "property-b",
                          G_BINDING_BIDIRECTIONAL);
]|

will keep the two properties in sync.

It is also possible to set a custom transformation function (in both
directions, in case of a bidirectional binding) to apply a custom
transformation from the source value to the target value before
applying it; for instance, the following binding:

|[&lt;!-- language="C" --&gt;
  g_object_bind_property_full (adjustment1, "value",
                               adjustment2, "value",
                               G_BINDING_BIDIRECTIONAL,
                               celsius_to_fahrenheit,
                               fahrenheit_to_celsius,
                               NULL, NULL);
]|

will keep the "value" property of the two adjustments in sync; the
@celsius_to_fahrenheit function will be called whenever the "value"
property of @adjustment1 changes and will transform the current value
of the property before applying it to the "value" property of @adjustment2.

Vice versa, the @fahrenheit_to_celsius function will be called whenever
the "value" property of @adjustment2 changes, and will transform the
current value of the property before applying it to the "value" property
of @adjustment1.

Note that #GBinding does not resolve cycles by itself; a cycle like

|[
  object1:propertyA -&gt; object2:propertyB
  object2:propertyB -&gt; object3:propertyC
  object3:propertyC -&gt; object1:propertyA
]|

might lead to an infinite loop. The loop, in this particular case,
can be avoided if the objects emit the #GObject::notify signal only
if the value has effectively been changed. A binding is implemented
using the #GObject::notify signal, so it is susceptible to all the
various ways of blocking a signal emission, like g_signal_stop_emission()
or g_signal_handler_block().

A binding will be severed, and the resources it allocates freed, whenever
either one of the #GObject instances it refers to are finalized, or when
the #GBinding instance loses its last reference.

Bindings for languages with garbage collection can use
g_binding_unbind() to explicitly release a binding between the source
and target properties, instead of relying on the last reference on the
binding, source, and target instances to drop.

#GBinding is available since GObject 2.26</doc>
      <gs:managed-property name="get_flags" version="2.26" gs:dll-name="gobject-2.0" gs:managed-name="Flags">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="813">Retrieves the flags passed when constructing the #GBinding.</doc>
        <source-position filename="gbinding.h" line="110" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="819">the #GBindingFlags used by the #GBinding</doc>
          <type name="BindingFlags" c:type="GBindingFlags" gs:managed-name="BindingFlags" />
        </return-value>
        <parameters>
          <instance-parameter name="binding" transfer-ownership="none" gs:managed-name="binding" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="815">a #GBinding</doc>
            <type name="Binding" c:type="GBinding*" gs:managed-name="Binding" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_flags" c:identifier="g_binding_get_flags" version="2.26" gs:dll-name="gobject-2.0" gs:managed-name="GetFlags" gs:property-getter-for="Flags" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="813">Retrieves the flags passed when constructing the #GBinding.</doc>
        <source-position filename="gbinding.h" line="110" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="819">the #GBindingFlags used by the #GBinding</doc>
          <type name="BindingFlags" c:type="GBindingFlags" gs:managed-name="BindingFlags" />
        </return-value>
        <parameters>
          <instance-parameter name="binding" transfer-ownership="none" gs:managed-name="binding" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="815">a #GBinding</doc>
            <type name="Binding" c:type="GBinding*" gs:managed-name="Binding" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_source" version="2.26" gs:dll-name="gobject-2.0" gs:managed-name="Source">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="824">Retrieves the #GObject instance used as the source of the binding.</doc>
        <source-position filename="gbinding.h" line="112" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="830">the source #GObject</doc>
          <type name="Object" c:type="GObject*" gs:managed-name="Object" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="binding" transfer-ownership="none" gs:managed-name="binding" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="826">a #GBinding</doc>
            <type name="Binding" c:type="GBinding*" gs:managed-name="Binding" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_source" c:identifier="g_binding_get_source" version="2.26" gs:dll-name="gobject-2.0" gs:managed-name="GetSource" gs:property-getter-for="Source" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="824">Retrieves the #GObject instance used as the source of the binding.</doc>
        <source-position filename="gbinding.h" line="112" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="830">the source #GObject</doc>
          <type name="Object" c:type="GObject*" gs:managed-name="Object" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="binding" transfer-ownership="none" gs:managed-name="binding" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="826">a #GBinding</doc>
            <type name="Binding" c:type="GBinding*" gs:managed-name="Binding" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_source_property" version="2.26" gs:dll-name="gobject-2.0" gs:managed-name="SourceProperty">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="835">Retrieves the name of the property of #GBinding:source used as the source
of the binding.</doc>
        <source-position filename="gbinding.h" line="116" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="842">the name of the source property</doc>
          <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="binding" transfer-ownership="none" gs:managed-name="binding" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="837">a #GBinding</doc>
            <type name="Binding" c:type="GBinding*" gs:managed-name="Binding" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_source_property" c:identifier="g_binding_get_source_property" version="2.26" gs:dll-name="gobject-2.0" gs:managed-name="GetSourceProperty" gs:property-getter-for="SourceProperty" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="835">Retrieves the name of the property of #GBinding:source used as the source
of the binding.</doc>
        <source-position filename="gbinding.h" line="116" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="842">the name of the source property</doc>
          <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="binding" transfer-ownership="none" gs:managed-name="binding" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="837">a #GBinding</doc>
            <type name="Binding" c:type="GBinding*" gs:managed-name="Binding" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_target" version="2.26" gs:dll-name="gobject-2.0" gs:managed-name="Target">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="847">Retrieves the #GObject instance used as the target of the binding.</doc>
        <source-position filename="gbinding.h" line="114" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="853">the target #GObject</doc>
          <type name="Object" c:type="GObject*" gs:managed-name="Object" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="binding" transfer-ownership="none" gs:managed-name="binding" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="849">a #GBinding</doc>
            <type name="Binding" c:type="GBinding*" gs:managed-name="Binding" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_target" c:identifier="g_binding_get_target" version="2.26" gs:dll-name="gobject-2.0" gs:managed-name="GetTarget" gs:property-getter-for="Target" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="847">Retrieves the #GObject instance used as the target of the binding.</doc>
        <source-position filename="gbinding.h" line="114" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="853">the target #GObject</doc>
          <type name="Object" c:type="GObject*" gs:managed-name="Object" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="binding" transfer-ownership="none" gs:managed-name="binding" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="849">a #GBinding</doc>
            <type name="Binding" c:type="GBinding*" gs:managed-name="Binding" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_target_property" version="2.26" gs:dll-name="gobject-2.0" gs:managed-name="TargetProperty">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="858">Retrieves the name of the property of #GBinding:target used as the target
of the binding.</doc>
        <source-position filename="gbinding.h" line="118" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="865">the name of the target property</doc>
          <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="binding" transfer-ownership="none" gs:managed-name="binding" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="860">a #GBinding</doc>
            <type name="Binding" c:type="GBinding*" gs:managed-name="Binding" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_target_property" c:identifier="g_binding_get_target_property" version="2.26" gs:dll-name="gobject-2.0" gs:managed-name="GetTargetProperty" gs:property-getter-for="TargetProperty" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="858">Retrieves the name of the property of #GBinding:target used as the target
of the binding.</doc>
        <source-position filename="gbinding.h" line="118" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="865">the name of the target property</doc>
          <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="binding" transfer-ownership="none" gs:managed-name="binding" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="860">a #GBinding</doc>
            <type name="Binding" c:type="GBinding*" gs:managed-name="Binding" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="unbind" c:identifier="g_binding_unbind" version="2.38" gs:dll-name="gobject-2.0" gs:managed-name="Unbind">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="870">Explicitly releases the binding between the source and the target
property expressed by @binding.

This function will release the reference that is being held on
the @binding instance; if you want to hold on to the #GBinding instance
after calling g_binding_unbind(), you will need to hold a reference
to it.</doc>
        <source-position filename="gbinding.h" line="120" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="binding" transfer-ownership="none" gs:managed-name="binding" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="872">a #GBinding</doc>
            <type name="Binding" c:type="GBinding*" gs:managed-name="Binding" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <property name="flags" version="2.26" writable="1" construct-only="1" transfer-ownership="none" gs:managed-name="Flags_">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="5">Flags to be used to control the #GBinding</doc>
        <type name="BindingFlags" gs:managed-name="BindingFlags" />
      </property>
      <property name="source" version="2.26" writable="1" construct-only="1" transfer-ownership="none" gs:managed-name="Source_">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="14">The #GObject that should be used as the source of the binding</doc>
        <type name="Object" gs:managed-name="Object" />
      </property>
      <property name="source-property" version="2.26" writable="1" construct-only="1" transfer-ownership="none" gs:managed-name="SourceProperty_">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="23">The name of the property of #GBinding:source that should be used
as the source of the binding.

This should be in [canonical form][canonical-parameter-names] to get the
best performance.</doc>
        <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
      </property>
      <property name="target" version="2.26" writable="1" construct-only="1" transfer-ownership="none" gs:managed-name="Target_">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="36">The #GObject that should be used as the target of the binding</doc>
        <type name="Object" gs:managed-name="Object" />
      </property>
      <property name="target-property" version="2.26" writable="1" construct-only="1" transfer-ownership="none" gs:managed-name="TargetProperty_">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="45">The name of the property of #GBinding:target that should be used
as the target of the binding.

This should be in [canonical form][canonical-parameter-names] to get the
best performance.</doc>
        <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
      </property>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_binding_get_type" gs:access-modifiers="private" gs:dll-name="gobject-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </class>
    <bitfield name="BindingFlags" version="2.26" glib:type-name="GBindingFlags" glib:get-type="g_binding_flags_get_type" c:type="GBindingFlags" gs:managed-name="BindingFlags">
      <doc xml:space="preserve" filename="gbinding.h" line="73">Flags to be passed to g_object_bind_property() or
g_object_bind_property_full().

This enumeration can be extended at later date.</doc>
      <member name="default" value="0" c:identifier="G_BINDING_DEFAULT" glib:nick="default" gs:managed-name="Default">
        <doc xml:space="preserve" filename="gbinding.h" line="75">The default binding; if the source property
  changes, the target property is updated with its value.</doc>
      </member>
      <member name="bidirectional" value="1" c:identifier="G_BINDING_BIDIRECTIONAL" glib:nick="bidirectional" gs:managed-name="Bidirectional">
        <doc xml:space="preserve" filename="gbinding.h" line="77">Bidirectional binding; if either the
  property of the source or the property of the target changes,
  the other is updated.</doc>
      </member>
      <member name="sync_create" value="2" c:identifier="G_BINDING_SYNC_CREATE" glib:nick="sync-create" gs:managed-name="SyncCreate">
        <doc xml:space="preserve" filename="gbinding.h" line="80">Synchronize the values of the source and
  target properties when creating the binding; the direction of
  the synchronization is always from the source to the target.</doc>
      </member>
      <member name="invert_boolean" value="4" c:identifier="G_BINDING_INVERT_BOOLEAN" glib:nick="invert-boolean" gs:managed-name="InvertBoolean">
        <doc xml:space="preserve" filename="gbinding.h" line="83">If the two properties being bound are
  booleans, setting one to %TRUE will result in the other being
  set to %FALSE and vice versa. This flag will only work for
  boolean properties, and cannot be used when passing custom
  transformation functions to g_object_bind_property_full().</doc>
      </member>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_binding_flags_get_type" gs:access-modifiers="private" gs:dll-name="gobject-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </bitfield>
    <callback name="ClassFinalizeFunc" c:type="GClassFinalizeFunc" gs:dll-name="gobject-2.0" gs:managed-name="ClassFinalizeFunc" gs:pinvoke-only="1">
      <doc xml:space="preserve" filename="gtype.h" line="887">A callback function used by the type system to finalize a class.
This function is rarely needed, as dynamically allocated class resources
should be handled by GBaseInitFunc() and GBaseFinalizeFunc().
Also, specification of a GClassFinalizeFunc() in the #GTypeInfo
structure of a static type is invalid, because classes of static types
will never be finalized (they are artificially kept alive when their
reference count drops to zero).</doc>
      <source-position filename="gtype.h" line="900" />
      <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
        <type name="none" c:type="void" gs:managed-name="System.Void" />
      </return-value>
      <parameters>
        <parameter name="g_class" transfer-ownership="none" gs:managed-name="gClass" direction="in">
          <doc xml:space="preserve" filename="gtype.h" line="889">The #GTypeClass structure to finalize</doc>
          <type name="TypeClass" c:type="gpointer" gs:managed-name="TypeClass" gs:is-pointer="1" />
        </parameter>
        <parameter name="class_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="classData" direction="in">
          <doc xml:space="preserve" filename="gtype.h" line="890">The @class_data member supplied via the #GTypeInfo structure</doc>
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </parameter>
      </parameters>
      <gs:managed-parameters>
        <parameter name="g_class" transfer-ownership="none" gs:managed-name="gClass" direction="in">
          <doc xml:space="preserve" filename="gtype.h" line="889">The #GTypeClass structure to finalize</doc>
          <type name="TypeClass" c:type="gpointer" gs:managed-name="TypeClass" gs:is-pointer="1" />
        </parameter>
        <parameter name="class_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="classData" direction="in">
          <doc xml:space="preserve" filename="gtype.h" line="890">The @class_data member supplied via the #GTypeInfo structure</doc>
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </parameter>
      </gs:managed-parameters>
    </callback>
    <callback name="ClassInitFunc" c:type="GClassInitFunc" gs:dll-name="gobject-2.0" gs:managed-name="ClassInitFunc" gs:pinvoke-only="1">
      <doc xml:space="preserve" filename="gtype.h" line="784">A callback function used by the type system to initialize the class
of a specific type. This function should initialize all static class
members.

The initialization process of a class involves:

- Copying common members from the parent class over to the
  derived class structure.
- Zero initialization of the remaining members not copied
  over from the parent class.
- Invocation of the GBaseInitFunc() initializers of all parent
  types and the class' type.
- Invocation of the class' GClassInitFunc() initializer.

Since derived classes are partially initialized through a memory copy
of the parent class, the general rule is that GBaseInitFunc() and
GBaseFinalizeFunc() should take care of necessary reinitialization
and release of those class members that were introduced by the type
that specified these GBaseInitFunc()/GBaseFinalizeFunc().
GClassInitFunc() should only care about initializing static
class members, while dynamic class members (such as allocated strings
or reference counted resources) are better handled by a GBaseInitFunc()
for this type, so proper initialization of the dynamic class members
is performed for class initialization of derived types as well.

An example may help to correspond the intend of the different class
initializers:

|[&lt;!-- language="C" --&gt;
typedef struct {
  GObjectClass parent_class;
  gint         static_integer;
  gchar       *dynamic_string;
} TypeAClass;
static void
type_a_base_class_init (TypeAClass *class)
{
  class-&gt;dynamic_string = g_strdup ("some string");
}
static void
type_a_base_class_finalize (TypeAClass *class)
{
  g_free (class-&gt;dynamic_string);
}
static void
type_a_class_init (TypeAClass *class)
{
  class-&gt;static_integer = 42;
}

typedef struct {
  TypeAClass   parent_class;
  gfloat       static_float;
  GString     *dynamic_gstring;
} TypeBClass;
static void
type_b_base_class_init (TypeBClass *class)
{
  class-&gt;dynamic_gstring = g_string_new ("some other string");
}
static void
type_b_base_class_finalize (TypeBClass *class)
{
  g_string_free (class-&gt;dynamic_gstring);
}
static void
type_b_class_init (TypeBClass *class)
{
  class-&gt;static_float = 3.14159265358979323846;
}
]|
Initialization of TypeBClass will first cause initialization of
TypeAClass (derived classes reference their parent classes, see
g_type_class_ref() on this).

Initialization of TypeAClass roughly involves zero-initializing its fields,
then calling its GBaseInitFunc() type_a_base_class_init() to allocate
its dynamic members (dynamic_string), and finally calling its GClassInitFunc()
type_a_class_init() to initialize its static members (static_integer).
The first step in the initialization process of TypeBClass is then
a plain memory copy of the contents of TypeAClass into TypeBClass and
zero-initialization of the remaining fields in TypeBClass.
The dynamic members of TypeAClass within TypeBClass now need
reinitialization which is performed by calling type_a_base_class_init()
with an argument of TypeBClass.

After that, the GBaseInitFunc() of TypeBClass, type_b_base_class_init()
is called to allocate the dynamic members of TypeBClass (dynamic_gstring),
and finally the GClassInitFunc() of TypeBClass, type_b_class_init(),
is called to complete the initialization process with the static members
(static_float).

Corresponding finalization counter parts to the GBaseInitFunc() functions
have to be provided to release allocated resources at class finalization
time.</doc>
      <source-position filename="gtype.h" line="885" />
      <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
        <type name="none" c:type="void" gs:managed-name="System.Void" />
      </return-value>
      <parameters>
        <parameter name="g_class" transfer-ownership="none" gs:managed-name="gClass" direction="in">
          <doc xml:space="preserve" filename="gtype.h" line="786">The #GTypeClass structure to initialize.</doc>
          <type name="TypeClass" c:type="gpointer" gs:managed-name="TypeClass" gs:is-pointer="1" />
        </parameter>
        <parameter name="class_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="classData" direction="in">
          <doc xml:space="preserve" filename="gtype.h" line="787">The @class_data member supplied via the #GTypeInfo structure.</doc>
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </parameter>
      </parameters>
      <gs:managed-parameters>
        <parameter name="g_class" transfer-ownership="none" gs:managed-name="gClass" direction="in">
          <doc xml:space="preserve" filename="gtype.h" line="786">The #GTypeClass structure to initialize.</doc>
          <type name="TypeClass" c:type="gpointer" gs:managed-name="TypeClass" gs:is-pointer="1" />
        </parameter>
        <parameter name="class_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="classData" direction="in">
          <doc xml:space="preserve" filename="gtype.h" line="787">The @class_data member supplied via the #GTypeInfo structure.</doc>
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </parameter>
      </gs:managed-parameters>
    </callback>
    <record name="Closure" c:type="GClosure" glib:type-name="GClosure" glib:get-type="g_closure_get_type" c:symbol-prefix="closure" gs:managed-name="Closure">
      <doc xml:space="preserve" filename="gobject-2.0.c" line="275">A #GClosure represents a callback supplied by the programmer. It
will generally comprise a function of some kind and a marshaller
used to call it. It is the responsibility of the marshaller to
convert the arguments for the invocation from #GValues into
a suitable form, perform the callback on the converted arguments,
and transform the return value back into a #GValue.

In the case of C programs, a closure usually just holds a pointer
to a function and maybe a data argument, and the marshaller
converts between #GValue and native C types. The GObject
library provides the #GCClosure type for this purpose. Bindings for
other languages need marshallers which convert between #GValues
and suitable representations in the runtime of the language in
order to use functions written in that language as callbacks. Use
g_closure_set_marshal() to set the marshaller on such a custom
closure implementation.

Within GObject, closures play an important role in the
implementation of signals. When a signal is registered, the
@c_marshaller argument to g_signal_new() specifies the default C
marshaller for any closure which is connected to this
signal. GObject provides a number of C marshallers for this
purpose, see the g_cclosure_marshal_*() functions. Additional C
marshallers can be generated with the [glib-genmarshal][glib-genmarshal]
utility.  Closures can be explicitly connected to signals with
g_signal_connect_closure(), but it usually more convenient to let
GObject create a closure automatically by using one of the
g_signal_connect_*() functions which take a callback function/user
data pair.

Using closures has a number of important advantages over a simple
callback function/data pointer combination:

- Closures allow the callee to get the types of the callback parameters,
  which means that language bindings don't have to write individual glue
  for each callback type.

- The reference counting of #GClosure makes it easy to handle reentrancy
  right; if a callback is removed while it is being invoked, the closure
  and its parameters won't be freed until the invocation finishes.

- g_closure_invalidate() and invalidation notifiers allow callbacks to be
  automatically removed when the objects they point to go away.</doc>
      <source-position filename="gclosure.h" line="213" />
      <field name="ref_count" readable="0" bits="15" private="1" gs:managed-name="RefCount">
        <type name="guint" c:type="volatile guint" gs:managed-name="System.UInt32" />
      </field>
      <field name="meta_marshal_nouse" readable="0" bits="1" private="1" gs:managed-name="MetaMarshalNouse">
        <type name="guint" c:type="volatile guint" gs:managed-name="System.UInt32" />
      </field>
      <field name="n_guards" readable="0" bits="1" private="1" gs:managed-name="NGuards">
        <type name="guint" c:type="volatile guint" gs:managed-name="System.UInt32" />
      </field>
      <field name="n_fnotifiers" readable="0" bits="2" private="1" gs:managed-name="NFnotifiers">
        <type name="guint" c:type="volatile guint" gs:managed-name="System.UInt32" />
      </field>
      <field name="n_inotifiers" readable="0" bits="8" private="1" gs:managed-name="NInotifiers">
        <type name="guint" c:type="volatile guint" gs:managed-name="System.UInt32" />
      </field>
      <field name="in_inotify" readable="0" bits="1" private="1" gs:managed-name="InInotify">
        <type name="guint" c:type="volatile guint" gs:managed-name="System.UInt32" />
      </field>
      <field name="floating" readable="0" bits="1" private="1" gs:managed-name="Floating">
        <type name="guint" c:type="volatile guint" gs:managed-name="System.UInt32" />
      </field>
      <field name="derivative_flag" readable="0" bits="1" private="1" gs:managed-name="DerivativeFlag">
        <type name="guint" c:type="volatile guint" gs:managed-name="System.UInt32" />
      </field>
      <field name="in_marshal" writable="1" bits="1" gs:managed-name="InMarshal">
        <doc xml:space="preserve" filename="gclosure.h" line="168">Indicates whether the closure is currently being invoked with
 g_closure_invoke()</doc>
        <type name="guint" c:type="volatile guint" gs:managed-name="System.UInt32" />
      </field>
      <field name="is_invalid" writable="1" bits="1" gs:managed-name="IsInvalid">
        <doc xml:space="preserve" filename="gclosure.h" line="170">Indicates whether the closure has been invalidated by
 g_closure_invalidate()</doc>
        <type name="guint" c:type="volatile guint" gs:managed-name="System.UInt32" />
      </field>
      <field name="marshal" gs:managed-name="Marshal">
        <type name="marshal" gs:dll-name="gobject-2.0" gs:managed-name="Marshal" />
        <callback name="marshal" gs:dll-name="gobject-2.0" gs:managed-name="Marshal">
          <source-position filename="gclosure.h" line="193" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" gs:managed-name="System.Void" />
          </return-value>
          <parameters>
            <parameter name="closure" transfer-ownership="none" gs:managed-name="closure" direction="in">
              <type name="Closure" c:type="GClosure*" gs:managed-name="Closure" gs:is-pointer="1" />
            </parameter>
            <parameter name="return_value" transfer-ownership="none" gs:managed-name="returnValue" direction="in">
              <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
            </parameter>
            <parameter name="n_param_values" transfer-ownership="none" gs:managed-name="nParamValues" direction="in">
              <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
            </parameter>
            <parameter name="param_values" transfer-ownership="none" gs:managed-name="paramValues" direction="in">
              <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
            </parameter>
            <parameter name="invocation_hint" transfer-ownership="none" gs:managed-name="invocationHint" direction="in">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </parameter>
            <parameter name="marshal_data" transfer-ownership="none" gs:managed-name="marshalData" direction="in">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="closure" transfer-ownership="none" gs:managed-name="closure" direction="in">
              <type name="Closure" c:type="GClosure*" gs:managed-name="Closure" gs:is-pointer="1" />
            </parameter>
            <parameter name="return_value" transfer-ownership="none" gs:managed-name="returnValue" direction="in">
              <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
            </parameter>
            <parameter name="n_param_values" transfer-ownership="none" gs:managed-name="nParamValues" direction="in">
              <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
            </parameter>
            <parameter name="param_values" transfer-ownership="none" gs:managed-name="paramValues" direction="in">
              <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
            </parameter>
            <parameter name="invocation_hint" transfer-ownership="none" gs:managed-name="invocationHint" direction="in">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </parameter>
            <parameter name="marshal_data" transfer-ownership="none" gs:managed-name="marshalData" direction="in">
              <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="data" readable="0" private="1" gs:managed-name="Data">
        <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
      </field>
      <field name="notifiers" readable="0" private="1" gs:managed-name="Notifiers">
        <type name="ClosureNotifyData" c:type="GClosureNotifyData*" gs:managed-name="ClosureNotifyData" gs:is-pointer="1" />
      </field>
      <constructor name="new_object" c:identifier="g_closure_new_object" gs:dll-name="gobject-2.0" gs:managed-name="NewObject">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="1927">A variant of g_closure_new_simple() which stores @object in the
@data field of the closure and calls g_object_watch_closure() on
@object and the created closure. This function is mainly useful
when implementing new types of closures.</doc>
        <source-position filename="gobject.h" line="616" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="1939">a newly allocated #GClosure</doc>
          <type name="Closure" c:type="GClosure*" gs:managed-name="Closure" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="sizeof_closure" transfer-ownership="none" gs:managed-name="sizeofClosure" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1929">the size of the structure to allocate, must be at least
 `sizeof (GClosure)`</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
          <parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1931">a #GObject pointer to store in the @data field of the newly
 allocated #GClosure</doc>
            <type name="Object" c:type="GObject*" gs:managed-name="Object" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="sizeof_closure" transfer-ownership="none" gs:managed-name="sizeofClosure" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1929">the size of the structure to allocate, must be at least
 `sizeof (GClosure)`</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
          <parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1931">a #GObject pointer to store in the @data field of the newly
 allocated #GClosure</doc>
            <type name="Object" c:type="GObject*" gs:managed-name="Object" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <constructor name="new_simple" c:identifier="g_closure_new_simple" gs:dll-name="gobject-2.0" gs:managed-name="NewSimple">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="1943">Allocates a struct of the given size and initializes the initial
part as a #GClosure. This function is mainly useful when
implementing new types of closures.

|[&lt;!-- language="C" --&gt;
typedef struct _MyClosure MyClosure;
struct _MyClosure
{
  GClosure closure;
  // extra data goes here
};

static void
my_closure_finalize (gpointer  notify_data,
                     GClosure *closure)
{
  MyClosure *my_closure = (MyClosure *)closure;

  // free extra data here
}

MyClosure *my_closure_new (gpointer data)
{
  GClosure *closure;
  MyClosure *my_closure;

  closure = g_closure_new_simple (sizeof (MyClosure), data);
  my_closure = (MyClosure *) closure;

  // initialize extra data here

  g_closure_add_finalize_notifier (closure, notify_data,
                                   my_closure_finalize);
  return my_closure;
}
]|</doc>
        <source-position filename="gclosure.h" line="246" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="1986">a floating reference to a new #GClosure</doc>
          <type name="Closure" c:type="GClosure*" gs:managed-name="Closure" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="sizeof_closure" transfer-ownership="none" gs:managed-name="sizeofClosure" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1945">the size of the structure to allocate, must be at least
                 `sizeof (GClosure)`</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1947">data to store in the @data field of the newly allocated #GClosure</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="sizeof_closure" transfer-ownership="none" gs:managed-name="sizeofClosure" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1945">the size of the structure to allocate, must be at least
                 `sizeof (GClosure)`</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1947">data to store in the @data field of the newly allocated #GClosure</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <method name="invalidate" c:identifier="g_closure_invalidate" gs:dll-name="gobject-2.0" gs:managed-name="Invalidate">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="1891">Sets a flag on the closure to indicate that its calling
environment has become invalid, and thus causes any future
invocations of g_closure_invoke() on this @closure to be
ignored. Also, invalidation notifiers installed on the closure will
be called at this point. Note that unless you are holding a
reference to the closure yourself, the invalidation notifiers may
unref the closure and cause it to be destroyed, so if you need to
access the closure after calling g_closure_invalidate(), make sure
that you've previously called g_closure_ref().

Note that g_closure_invalidate() will also be called when the
reference count of a closure drops to zero (unless it has already
been invalidated before).</doc>
        <source-position filename="gclosure.h" line="278" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="closure" transfer-ownership="none" gs:managed-name="closure" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1893">#GClosure to invalidate</doc>
            <type name="Closure" c:type="GClosure*" gs:managed-name="Closure" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="invoke" c:identifier="g_closure_invoke" gs:dll-name="gobject-2.0" gs:managed-name="Invoke">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="1911">Invokes the closure, i.e. executes the callback represented by the @closure.</doc>
        <source-position filename="gclosure.h" line="280" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="closure" transfer-ownership="none" gs:managed-name="closure" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1913">a #GClosure</doc>
            <type name="Closure" c:type="GClosure*" gs:managed-name="Closure" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="return_value" direction="out" caller-allocates="1" transfer-ownership="none" optional="1" allow-none="1" gs:managed-name="returnValue">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1914">a #GValue to store the return
               value. May be %NULL if the callback of @closure
               doesn't return a value.</doc>
            <type name="Value" c:type="GValue*" gs:managed-name="Value" />
          </parameter>
          <parameter name="n_param_values" transfer-ownership="none" gs:managed-name="nParamValues" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1917">the length of the @param_values array</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
          <parameter name="param_values" transfer-ownership="none" gs:managed-name="paramValues" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1918">an array of
               #GValues holding the arguments on which to
               invoke the callback of @closure</doc>
            <array length="1" zero-terminated="0" c:type="const GValue*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="Value" c:type="GValue" gs:managed-name="Value" />
            </array>
          </parameter>
          <parameter name="invocation_hint" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="invocationHint" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1921">a context-dependent invocation hint</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="return_value" direction="out" caller-allocates="1" transfer-ownership="none" optional="1" allow-none="1" gs:managed-name="returnValue">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1914">a #GValue to store the return
               value. May be %NULL if the callback of @closure
               doesn't return a value.</doc>
            <type name="Value" c:type="GValue*" gs:managed-name="Value" />
          </parameter>
          <parameter name="param_values" transfer-ownership="none" gs:managed-name="paramValues" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1918">an array of
               #GValues holding the arguments on which to
               invoke the callback of @closure</doc>
            <array length="1" zero-terminated="0" c:type="const GValue*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="Value" c:type="GValue" gs:managed-name="Value" />
            </array>
          </parameter>
          <parameter name="invocation_hint" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="invocationHint" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1921">a context-dependent invocation hint</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="ref" c:identifier="g_closure_ref" gs:dll-name="gobject-2.0" gs:managed-name="Ref" gs:special-func="ref" gs:pinvoke-only="1">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="1990">Increments the reference count on a closure to force it staying
alive while the caller holds a pointer to it.</doc>
        <source-position filename="gclosure.h" line="239" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="1997">The @closure passed in, for convenience</doc>
          <type name="Closure" c:type="GClosure*" gs:managed-name="Closure" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="closure" transfer-ownership="none" gs:managed-name="closure" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="1992">#GClosure to increment the reference count on</doc>
            <type name="Closure" c:type="GClosure*" gs:managed-name="Closure" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="sink" c:identifier="g_closure_sink" gs:dll-name="gobject-2.0" gs:managed-name="Sink">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2065">Takes over the initial ownership of a closure.  Each closure is
initially created in a "floating" state, which means that the initial
reference count is not owned by any caller. g_closure_sink() checks
to see if the object is still floating, and if so, unsets the
floating state and decreases the reference count. If the closure
is not floating, g_closure_sink() does nothing. The reason for the
existence of the floating state is to prevent cumbersome code
sequences like:
|[&lt;!-- language="C" --&gt;
closure = g_cclosure_new (cb_func, cb_data);
g_source_set_closure (source, closure);
g_closure_unref (closure); // GObject doesn't really need this
]|
Because g_source_set_closure() (and similar functions) take ownership of the
initial reference count, if it is unowned, we instead can write:
|[&lt;!-- language="C" --&gt;
g_source_set_closure (source, g_cclosure_new (cb_func, cb_data));
]|

Generally, this function is used together with g_closure_ref(). An example
of storing a closure for later notification looks like:
|[&lt;!-- language="C" --&gt;
static GClosure *notify_closure = NULL;
void
foo_notify_set_closure (GClosure *closure)
{
  if (notify_closure)
    g_closure_unref (notify_closure);
  notify_closure = closure;
  if (notify_closure)
    {
      g_closure_ref (notify_closure);
      g_closure_sink (notify_closure);
    }
}
]|

Because g_closure_sink() may decrement the reference count of a closure
(if it hasn't been called on @closure yet) just like g_closure_unref(),
g_closure_ref() should be called prior to this function.</doc>
        <source-position filename="gclosure.h" line="241" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="closure" transfer-ownership="none" gs:managed-name="closure" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2067">#GClosure to decrement the initial reference count on, if it's
          still being held</doc>
            <type name="Closure" c:type="GClosure*" gs:managed-name="Closure" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="unref" c:identifier="g_closure_unref" gs:dll-name="gobject-2.0" gs:managed-name="Unref" gs:special-func="unref" gs:pinvoke-only="1">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2113">Decrements the reference count of a closure after it was previously
incremented by the same caller. If no other callers are using the
closure, then the closure will be destroyed and freed.</doc>
        <source-position filename="gclosure.h" line="243" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="closure" transfer-ownership="none" gs:managed-name="closure" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2115">#GClosure to decrement the reference count on</doc>
            <type name="Closure" c:type="GClosure*" gs:managed-name="Closure" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_closure_get_type" gs:access-modifiers="private" gs:dll-name="gobject-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </record>
    <callback name="ClosureNotify" c:type="GClosureNotify" gs:dll-name="gobject-2.0" gs:managed-name="ClosureNotify" gs:pinvoke-only="1">
      <doc xml:space="preserve" filename="gclosure.h" line="87">The type used for the various notification callbacks which can be registered
on closures.</doc>
      <source-position filename="gclosure.h" line="95" />
      <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
        <type name="none" c:type="void" gs:managed-name="System.Void" />
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
          <doc xml:space="preserve" filename="gclosure.h" line="89">data specified when registering the notification callback</doc>
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </parameter>
        <parameter name="closure" transfer-ownership="none" gs:managed-name="closure" direction="in">
          <doc xml:space="preserve" filename="gclosure.h" line="90">the #GClosure on which the notification is emitted</doc>
          <type name="Closure" c:type="GClosure*" gs:managed-name="Closure" gs:is-pointer="1" />
        </parameter>
      </parameters>
      <gs:managed-parameters>
        <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
          <doc xml:space="preserve" filename="gclosure.h" line="89">data specified when registering the notification callback</doc>
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </parameter>
        <parameter name="closure" transfer-ownership="none" gs:managed-name="closure" direction="in">
          <doc xml:space="preserve" filename="gclosure.h" line="90">the #GClosure on which the notification is emitted</doc>
          <type name="Closure" c:type="GClosure*" gs:managed-name="Closure" gs:is-pointer="1" />
        </parameter>
      </gs:managed-parameters>
    </callback>
    <record name="ClosureNotifyData" c:type="GClosureNotifyData" gs:managed-name="ClosureNotifyData">
      <source-position filename="gclosure.h" line="165" />
      <field name="data" writable="1" gs:managed-name="Data">
        <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
      </field>
      <field name="notify" writable="1" gs:managed-name="Notify">
        <type name="ClosureNotify" c:type="GClosureNotify" gs:managed-name="ClosureNotify" />
      </field>
    </record>
    <callback name="InstanceInitFunc" c:type="GInstanceInitFunc" gs:dll-name="gobject-2.0" gs:managed-name="InstanceInitFunc" gs:pinvoke-only="1">
      <doc xml:space="preserve" filename="gtype.h" line="902">A callback function used by the type system to initialize a new
instance of a type. This function initializes all instance members and
allocates any resources required by it.

Initialization of a derived instance involves calling all its parent
types instance initializers, so the class member of the instance
is altered during its initialization to always point to the class that
belongs to the type the current initializer was introduced for.

The extended members of @instance are guaranteed to have been filled with
zeros before this function is called.</doc>
      <source-position filename="gtype.h" line="920" />
      <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
        <type name="none" c:type="void" gs:managed-name="System.Void" />
      </return-value>
      <parameters>
        <parameter name="instance" transfer-ownership="none" gs:managed-name="instance" direction="in">
          <doc xml:space="preserve" filename="gtype.h" line="904">The instance to initialize</doc>
          <type name="TypeInstance" c:type="GTypeInstance*" gs:managed-name="TypeInstance" gs:is-pointer="1" />
        </parameter>
        <parameter name="g_class" transfer-ownership="none" gs:managed-name="gClass" direction="in">
          <doc xml:space="preserve" filename="gtype.h" line="905">The class of the type the instance is
   created for</doc>
          <type name="TypeClass" c:type="gpointer" gs:managed-name="TypeClass" gs:is-pointer="1" />
        </parameter>
      </parameters>
      <gs:managed-parameters>
        <parameter name="instance" transfer-ownership="none" gs:managed-name="instance" direction="in">
          <doc xml:space="preserve" filename="gtype.h" line="904">The instance to initialize</doc>
          <type name="TypeInstance" c:type="GTypeInstance*" gs:managed-name="TypeInstance" gs:is-pointer="1" />
        </parameter>
        <parameter name="g_class" transfer-ownership="none" gs:managed-name="gClass" direction="in">
          <doc xml:space="preserve" filename="gtype.h" line="905">The class of the type the instance is
   created for</doc>
          <type name="TypeClass" c:type="gpointer" gs:managed-name="TypeClass" gs:is-pointer="1" />
        </parameter>
      </gs:managed-parameters>
    </callback>
    <callback name="InterfaceFinalizeFunc" c:type="GInterfaceFinalizeFunc" gs:dll-name="gobject-2.0" gs:managed-name="InterfaceFinalizeFunc" gs:pinvoke-only="1">
      <doc xml:space="preserve" filename="gtype.h" line="936">A callback function used by the type system to finalize an interface.
This function should destroy any internal data and release any resources
allocated by the corresponding GInterfaceInitFunc() function.</doc>
      <source-position filename="gtype.h" line="945" />
      <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
        <type name="none" c:type="void" gs:managed-name="System.Void" />
      </return-value>
      <parameters>
        <parameter name="g_iface" transfer-ownership="none" gs:managed-name="gIface" direction="in">
          <doc xml:space="preserve" filename="gtype.h" line="938">The interface structure to finalize</doc>
          <type name="TypeInterface" c:type="gpointer" gs:managed-name="TypeInterface" gs:is-pointer="1" />
        </parameter>
        <parameter name="iface_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="ifaceData" direction="in">
          <doc xml:space="preserve" filename="gtype.h" line="939">The @interface_data supplied via the #GInterfaceInfo structure</doc>
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </parameter>
      </parameters>
      <gs:managed-parameters>
        <parameter name="g_iface" transfer-ownership="none" gs:managed-name="gIface" direction="in">
          <doc xml:space="preserve" filename="gtype.h" line="938">The interface structure to finalize</doc>
          <type name="TypeInterface" c:type="gpointer" gs:managed-name="TypeInterface" gs:is-pointer="1" />
        </parameter>
        <parameter name="iface_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="ifaceData" direction="in">
          <doc xml:space="preserve" filename="gtype.h" line="939">The @interface_data supplied via the #GInterfaceInfo structure</doc>
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </parameter>
      </gs:managed-parameters>
    </callback>
    <record name="InterfaceInfo" c:type="GInterfaceInfo" gs:managed-name="InterfaceInfo">
      <doc xml:space="preserve" filename="gtype.h" line="1076">A structure that provides information to the type system which is
used specifically for managing interface types.</doc>
      <source-position filename="gtype.h" line="1090" />
      <field name="interface_init" writable="1" gs:managed-name="InterfaceInit">
        <doc xml:space="preserve" filename="gtype.h" line="1078">location of the interface initialization function</doc>
        <type name="InterfaceInitFunc" c:type="GInterfaceInitFunc" gs:managed-name="InterfaceInitFunc" />
      </field>
      <field name="interface_finalize" writable="1" gs:managed-name="InterfaceFinalize">
        <doc xml:space="preserve" filename="gtype.h" line="1079">location of the interface finalization function</doc>
        <type name="InterfaceFinalizeFunc" c:type="GInterfaceFinalizeFunc" gs:managed-name="InterfaceFinalizeFunc" />
      </field>
      <field name="interface_data" writable="1" gs:managed-name="InterfaceData">
        <doc xml:space="preserve" filename="gtype.h" line="1080">user-supplied data passed to the interface init/finalize functions</doc>
        <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
      </field>
    </record>
    <callback name="InterfaceInitFunc" c:type="GInterfaceInitFunc" gs:dll-name="gobject-2.0" gs:managed-name="InterfaceInitFunc" gs:pinvoke-only="1">
      <doc xml:space="preserve" filename="gtype.h" line="922">A callback function used by the type system to initialize a new
interface.  This function should initialize all internal data and
allocate any resources required by the interface.

The members of @iface_data are guaranteed to have been filled with
zeros before this function is called.</doc>
      <source-position filename="gtype.h" line="934" />
      <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
        <type name="none" c:type="void" gs:managed-name="System.Void" />
      </return-value>
      <parameters>
        <parameter name="g_iface" transfer-ownership="none" gs:managed-name="gIface" direction="in">
          <doc xml:space="preserve" filename="gtype.h" line="924">The interface structure to initialize</doc>
          <type name="TypeInterface" c:type="gpointer" gs:managed-name="TypeInterface" gs:is-pointer="1" />
        </parameter>
        <parameter name="iface_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="ifaceData" direction="in">
          <doc xml:space="preserve" filename="gtype.h" line="925">The @interface_data supplied via the #GInterfaceInfo structure</doc>
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </parameter>
      </parameters>
      <gs:managed-parameters>
        <parameter name="g_iface" transfer-ownership="none" gs:managed-name="gIface" direction="in">
          <doc xml:space="preserve" filename="gtype.h" line="924">The interface structure to initialize</doc>
          <type name="TypeInterface" c:type="gpointer" gs:managed-name="TypeInterface" gs:is-pointer="1" />
        </parameter>
        <parameter name="iface_data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="ifaceData" direction="in">
          <doc xml:space="preserve" filename="gtype.h" line="925">The @interface_data supplied via the #GInterfaceInfo structure</doc>
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </parameter>
      </gs:managed-parameters>
    </callback>
    <class name="Object" c:symbol-prefix="object" c:type="GObject" glib:type-name="GObject" glib:get-type="g_object_get_type" glib:type-struct="ObjectClass" gs:managed-name="Object">
      <doc xml:space="preserve" filename="gobject.h" line="239">All the fields in the GObject structure are private
to the #GObject implementation and should never be accessed directly.</doc>
      <source-position filename="gobject.h" line="354" />
      <constructor name="newv" c:identifier="g_object_newv" deprecated="1" deprecated-version="2.54" gs:dll-name="gobject-2.0" gs:managed-name="Newv">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3032">Creates a new instance of a #GObject subtype and sets its properties.

Construction parameters (see #G_PARAM_CONSTRUCT, #G_PARAM_CONSTRUCT_ONLY)
which are not explicitly specified are set to their default values.</doc>
        <doc-deprecated xml:space="preserve">Use g_object_new_with_properties() instead.
deprecated. See #GParameter for more information.</doc-deprecated>
        <source-position filename="gobject.h" line="431" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3043">a new instance of
@object_type</doc>
          <type name="Object" c:type="gpointer" gs:managed-name="Object" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="object_type" transfer-ownership="none" gs:managed-name="objectType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3034">the type id of the #GObject subtype to instantiate</doc>
            <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
          </parameter>
          <parameter name="n_parameters" transfer-ownership="none" gs:managed-name="nParameters" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3035">the length of the @parameters array</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
          <parameter name="parameters" transfer-ownership="none" gs:managed-name="parameters" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3036">an array of #GParameter</doc>
            <array length="1" zero-terminated="0" c:type="GParameter*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="Parameter" c:type="GParameter" gs:managed-name="Parameter" />
            </array>
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="object_type" transfer-ownership="none" gs:managed-name="objectType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3034">the type id of the #GObject subtype to instantiate</doc>
            <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
          </parameter>
          <parameter name="parameters" transfer-ownership="none" gs:managed-name="parameters" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3036">an array of #GParameter</doc>
            <array length="1" zero-terminated="0" c:type="GParameter*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="Parameter" c:type="GParameter" gs:managed-name="Parameter" />
            </array>
          </parameter>
        </gs:managed-parameters>
      </constructor>
      <function name="compat_control" c:identifier="g_object_compat_control" gs:dll-name="gobject-2.0" gs:managed-name="CompatControl">
        <source-position filename="gobject.h" line="647" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <parameter name="what" transfer-ownership="none" gs:managed-name="what" direction="in">
            <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="what" transfer-ownership="none" gs:managed-name="what" direction="in">
            <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="interface_find_property" c:identifier="g_object_interface_find_property" version="2.4" gs:dll-name="gobject-2.0" gs:managed-name="InterfaceFindProperty">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2885">Find the #GParamSpec with the given name for an
interface. Generally, the interface vtable passed in as @g_iface
will be the default vtable from g_type_default_interface_ref(), or,
if you know the interface has already been loaded,
g_type_default_interface_peek().</doc>
        <source-position filename="gobject.h" line="410" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="2898">the #GParamSpec for the property of the
         interface with the name @property_name, or %NULL if no
         such property exists.</doc>
          <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="g_iface" transfer-ownership="none" gs:managed-name="gIface" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2887">any interface vtable for the
 interface, or the default vtable for the interface</doc>
            <type name="TypeInterface" c:type="gpointer" gs:managed-name="TypeInterface" gs:is-pointer="1" />
          </parameter>
          <parameter name="property_name" transfer-ownership="none" gs:managed-name="propertyName" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2889">name of a property to look up.</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="g_iface" transfer-ownership="none" gs:managed-name="gIface" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2887">any interface vtable for the
 interface, or the default vtable for the interface</doc>
            <type name="TypeInterface" c:type="gpointer" gs:managed-name="TypeInterface" gs:is-pointer="1" />
          </parameter>
          <parameter name="property_name" transfer-ownership="none" gs:managed-name="propertyName" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2889">name of a property to look up.</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="interface_install_property" c:identifier="g_object_interface_install_property" version="2.4" gs:dll-name="gobject-2.0" gs:managed-name="InterfaceInstallProperty">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2904">Add a property to an interface; this is only useful for interfaces
that are added to GObject-derived types. Adding a property to an
interface forces all objects classes with that interface to have a
compatible property. The compatible property could be a newly
created #GParamSpec, but normally
g_object_class_override_property() will be used so that the object
class only needs to provide an implementation and inherits the
property description, default value, bounds, and so forth from the
interface property.

This function is meant to be called from the interface's default
vtable initialization function (the @class_init member of
#GTypeInfo.) It must not be called after after @class_init has
been called for any object types implementing this interface.

If @pspec is a floating reference, it will be consumed.</doc>
        <source-position filename="gobject.h" line="407" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <parameter name="g_iface" transfer-ownership="none" gs:managed-name="gIface" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2906">any interface vtable for the
   interface, or the default
 vtable for the interface.</doc>
            <type name="TypeInterface" c:type="gpointer" gs:managed-name="TypeInterface" gs:is-pointer="1" />
          </parameter>
          <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2909">the #GParamSpec for the new property</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="g_iface" transfer-ownership="none" gs:managed-name="gIface" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2906">any interface vtable for the
   interface, or the default
 vtable for the interface.</doc>
            <type name="TypeInterface" c:type="gpointer" gs:managed-name="TypeInterface" gs:is-pointer="1" />
          </parameter>
          <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2909">the #GParamSpec for the new property</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="interface_list_properties" c:identifier="g_object_interface_list_properties" version="2.4" gs:dll-name="gobject-2.0" gs:managed-name="InterfaceListProperties">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2932">Lists the properties of an interface.Generally, the interface
vtable passed in as @g_iface will be the default vtable from
g_type_default_interface_ref(), or, if you know the interface has
already been loaded, g_type_default_interface_peek().</doc>
        <source-position filename="gobject.h" line="413" />
        <return-value transfer-ownership="container" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="2944">a
         pointer to an array of pointers to #GParamSpec
         structures. The paramspecs are owned by GLib, but the
         array should be freed with g_free() when you are done with
         it.</doc>
          <array length="1" zero-terminated="0" c:type="GParamSpec**" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
            <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
          </array>
        </return-value>
        <parameters>
          <parameter name="g_iface" transfer-ownership="none" gs:managed-name="gIface" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2934">any interface vtable for the
 interface, or the default vtable for the interface</doc>
            <type name="TypeInterface" c:type="gpointer" gs:managed-name="TypeInterface" gs:is-pointer="1" />
          </parameter>
          <parameter name="n_properties_p" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="nPropertiesP">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2936">location to store number of properties returned.</doc>
            <type name="guint" c:type="guint*" gs:managed-name="System.UInt32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="g_iface" transfer-ownership="none" gs:managed-name="gIface" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2934">any interface vtable for the
 interface, or the default vtable for the interface</doc>
            <type name="TypeInterface" c:type="gpointer" gs:managed-name="TypeInterface" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <virtual-method name="constructed" gs:dll-name="gobject-2.0" gs:managed-name="DoConstructed">
        <source-position filename="gobject.h" line="347" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <type name="Object" c:type="GObject*" gs:managed-name="Object" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </virtual-method>
      <virtual-method name="dispatch_properties_changed" gs:dll-name="gobject-2.0" gs:managed-name="DoDispatchPropertiesChanged">
        <source-position filename="gobject.h" line="339" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <type name="Object" c:type="GObject*" gs:managed-name="Object" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="n_pspecs" transfer-ownership="none" gs:managed-name="nPspecs" direction="in">
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
          <parameter name="pspecs" transfer-ownership="none" gs:managed-name="pspecs" direction="in">
            <type name="ParamSpec" c:type="GParamSpec**" gs:managed-name="ParamSpec" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="n_pspecs" transfer-ownership="none" gs:managed-name="nPspecs" direction="in">
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
          <parameter name="pspecs" transfer-ownership="none" gs:managed-name="pspecs" direction="in">
            <type name="ParamSpec" c:type="GParamSpec**" gs:managed-name="ParamSpec" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="dispose" gs:dll-name="gobject-2.0" gs:managed-name="DoDispose">
        <source-position filename="gobject.h" line="336" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <type name="Object" c:type="GObject*" gs:managed-name="Object" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </virtual-method>
      <virtual-method name="finalize" gs:dll-name="gobject-2.0" gs:managed-name="DoFinalize">
        <source-position filename="gobject.h" line="337" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <type name="Object" c:type="GObject*" gs:managed-name="Object" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </virtual-method>
      <virtual-method name="get_property" gs:dll-name="gobject-2.0" gs:managed-name="DoGetProperty">
        <source-position filename="gobject.h" line="332" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <type name="Object" c:type="GObject*" gs:managed-name="Object" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="property_id" transfer-ownership="none" gs:managed-name="propertyId" direction="in">
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </parameter>
          <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="property_id" transfer-ownership="none" gs:managed-name="propertyId" direction="in">
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </parameter>
          <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="notify" invoker="notify" gs:dll-name="gobject-2.0" gs:managed-name="DoNotify">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3050">Emits a "notify" signal for the property @property_name on @object.

When possible, eg. when signaling a property change from within the class
that registered the property, you should use g_object_notify_by_pspec()
instead.

Note that emission of the notify signal may be blocked with
g_object_freeze_notify(). In this case, the signal emissions are queued
and will be emitted (in reverse order) when g_object_thaw_notify() is
called.</doc>
        <source-position filename="gobject.h" line="343" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3052">a #GObject</doc>
            <type name="Object" c:type="GObject*" gs:managed-name="Object" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="set_property" gs:dll-name="gobject-2.0" gs:managed-name="DoSetProperty">
        <source-position filename="gobject.h" line="328" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <type name="Object" c:type="GObject*" gs:managed-name="Object" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="property_id" transfer-ownership="none" gs:managed-name="propertyId" direction="in">
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </parameter>
          <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="property_id" transfer-ownership="none" gs:managed-name="propertyId" direction="in">
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </parameter>
          <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <method name="bind_property" c:identifier="g_object_bind_property" version="2.26" gs:dll-name="gobject-2.0" gs:managed-name="BindProperty">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2367">Creates a binding between @source_property on @source and @target_property
on @target. Whenever the @source_property is changed the @target_property is
updated using the same value. For instance:

|[
  g_object_bind_property (action, "active", widget, "sensitive", 0);
]|

Will result in the "sensitive" property of the widget #GObject instance to be
updated with the same value of the "active" property of the action #GObject
instance.

If @flags contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
if @target_property on @target changes then the @source_property on @source
will be updated as well.

The binding will automatically be removed when either the @source or the
@target instances are finalized. To remove the binding without affecting the
@source and the @target you can just call g_object_unref() on the returned
#GBinding instance.

A #GObject can have multiple bindings.</doc>
        <source-position filename="gbinding.h" line="123" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="2398">the #GBinding instance representing the
    binding between the two #GObject instances. The binding is released
    whenever the #GBinding reference count reaches zero.</doc>
          <type name="Binding" c:type="GBinding*" gs:managed-name="Binding" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2369">the source #GObject</doc>
            <type name="Object" c:type="gpointer" gs:managed-name="Object" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="source_property" transfer-ownership="none" gs:managed-name="sourceProperty" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2370">the property on @source to bind</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="target" transfer-ownership="none" gs:managed-name="target" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2371">the target #GObject</doc>
            <type name="Object" c:type="gpointer" gs:managed-name="Object" gs:is-pointer="1" />
          </parameter>
          <parameter name="target_property" transfer-ownership="none" gs:managed-name="targetProperty" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2372">the property on @target to bind</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2373">flags to pass to #GBinding</doc>
            <type name="BindingFlags" c:type="GBindingFlags" gs:managed-name="BindingFlags" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="source_property" transfer-ownership="none" gs:managed-name="sourceProperty" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2370">the property on @source to bind</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="target" transfer-ownership="none" gs:managed-name="target" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2371">the target #GObject</doc>
            <type name="Object" c:type="gpointer" gs:managed-name="Object" gs:is-pointer="1" />
          </parameter>
          <parameter name="target_property" transfer-ownership="none" gs:managed-name="targetProperty" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2372">the property on @target to bind</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2373">flags to pass to #GBinding</doc>
            <type name="BindingFlags" c:type="GBindingFlags" gs:managed-name="BindingFlags" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="bind_property_with_closures" c:identifier="g_object_bind_property_with_closures" shadows="bind_property_full" version="2.26" gs:dll-name="gobject-2.0" gs:managed-name="BindPropertyFull">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2454">Creates a binding between @source_property on @source and @target_property
on @target, allowing you to set the transformation functions to be used by
the binding.

This function is the language bindings friendly version of
g_object_bind_property_full(), using #GClosures instead of
function pointers.</doc>
        <source-position filename="gbinding.h" line="139" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="2474">the #GBinding instance representing the
    binding between the two #GObject instances. The binding is released
    whenever the #GBinding reference count reaches zero.</doc>
          <type name="Binding" c:type="GBinding*" gs:managed-name="Binding" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none" gs:managed-name="source" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2456">the source #GObject</doc>
            <type name="Object" c:type="gpointer" gs:managed-name="Object" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="source_property" transfer-ownership="none" gs:managed-name="sourceProperty" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2457">the property on @source to bind</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="target" transfer-ownership="none" gs:managed-name="target" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2458">the target #GObject</doc>
            <type name="Object" c:type="gpointer" gs:managed-name="Object" gs:is-pointer="1" />
          </parameter>
          <parameter name="target_property" transfer-ownership="none" gs:managed-name="targetProperty" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2459">the property on @target to bind</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2460">flags to pass to #GBinding</doc>
            <type name="BindingFlags" c:type="GBindingFlags" gs:managed-name="BindingFlags" />
          </parameter>
          <parameter name="transform_to" transfer-ownership="none" gs:managed-name="transformTo" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2461">a #GClosure wrapping the transformation function
    from the @source to the @target, or %NULL to use the default</doc>
            <type name="Closure" c:type="GClosure*" gs:managed-name="Closure" gs:is-pointer="1" />
          </parameter>
          <parameter name="transform_from" transfer-ownership="none" gs:managed-name="transformFrom" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2463">a #GClosure wrapping the transformation function
    from the @target to the @source, or %NULL to use the default</doc>
            <type name="Closure" c:type="GClosure*" gs:managed-name="Closure" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="source_property" transfer-ownership="none" gs:managed-name="sourceProperty" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2457">the property on @source to bind</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="target" transfer-ownership="none" gs:managed-name="target" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2458">the target #GObject</doc>
            <type name="Object" c:type="gpointer" gs:managed-name="Object" gs:is-pointer="1" />
          </parameter>
          <parameter name="target_property" transfer-ownership="none" gs:managed-name="targetProperty" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2459">the property on @target to bind</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="flags" transfer-ownership="none" gs:managed-name="flags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2460">flags to pass to #GBinding</doc>
            <type name="BindingFlags" c:type="GBindingFlags" gs:managed-name="BindingFlags" />
          </parameter>
          <parameter name="transform_to" transfer-ownership="none" gs:managed-name="transformTo" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2461">a #GClosure wrapping the transformation function
    from the @source to the @target, or %NULL to use the default</doc>
            <type name="Closure" c:type="GClosure*" gs:managed-name="Closure" gs:is-pointer="1" />
          </parameter>
          <parameter name="transform_from" transfer-ownership="none" gs:managed-name="transformFrom" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2463">a #GClosure wrapping the transformation function
    from the @target to the @source, or %NULL to use the default</doc>
            <type name="Closure" c:type="GClosure*" gs:managed-name="Closure" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="force_floating" c:identifier="g_object_force_floating" version="2.10" gs:dll-name="gobject-2.0" gs:managed-name="ForceFloating">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2738">This function is intended for #GObject implementations to re-enforce
a [floating][floating-ref] object reference. Doing this is seldom
required: all #GInitiallyUnowneds are created with a floating reference
which usually just needs to be sunken by calling g_object_ref_sink().</doc>
        <source-position filename="gobject.h" line="634" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2740">a #GObject</doc>
            <type name="Object" c:type="GObject*" gs:managed-name="Object" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="freeze_notify" c:identifier="g_object_freeze_notify" gs:dll-name="gobject-2.0" gs:managed-name="FreezeNotify">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2751">Increases the freeze count on @object. If the freeze count is
non-zero, the emission of "notify" signals on @object is
stopped. The signals are queued until the freeze count is decreased
to zero. Duplicate notifications are squashed so that at most one
#GObject::notify signal is emitted for each property modified while the
object is frozen.

This is necessary for accessors that modify multiple properties to prevent
premature notification while the object is still being modified.</doc>
        <source-position filename="gobject.h" line="484" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2753">a #GObject</doc>
            <type name="Object" c:type="GObject*" gs:managed-name="Object" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="get_data" c:identifier="g_object_get_data" gs:dll-name="gobject-2.0" gs:managed-name="GetData">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2803">Gets a named field from the objects table of associations (see g_object_set_data()).</doc>
        <source-position filename="gobject.h" line="577" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="2810">the data if found,
         or %NULL if no such data exists.</doc>
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2805">#GObject containing the associations</doc>
            <type name="Object" c:type="GObject*" gs:managed-name="Object" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2806">name of the key for that association</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2806">name of the key for that association</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_property" c:identifier="g_object_get_property" gs:dll-name="gobject-2.0" gs:managed-name="GetProperty">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2815">Gets a property of an object.

The @value can be:

 - an empty #GValue initialized by %G_VALUE_INIT, which will be
   automatically initialized with the expected type of the property
   (since GLib 2.60)
 - a #GValue initialized with the expected type of the property
 - a #GValue initialized with a type to which the expected type
   of the property can be transformed

In general, a copy is made of the property contents and the caller is
responsible for freeing the memory by calling g_value_unset().

Note that g_object_get_property() is really intended for language
bindings, g_object_get() is much more convenient for C programming.</doc>
        <source-position filename="gobject.h" line="480" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2817">a #GObject</doc>
            <type name="Object" c:type="GObject*" gs:managed-name="Object" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="property_name" transfer-ownership="none" gs:managed-name="propertyName" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2818">the name of the property to get</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2819">return location for the property value</doc>
            <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="property_name" transfer-ownership="none" gs:managed-name="propertyName" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2818">the name of the property to get</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2819">return location for the property value</doc>
            <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_qdata" c:identifier="g_object_get_qdata" gs:dll-name="gobject-2.0" gs:managed-name="GetQdata">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2840">This function gets back user data pointers stored via
g_object_set_qdata().</doc>
        <source-position filename="gobject.h" line="548" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="2848">The user data pointer set, or %NULL</doc>
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2842">The GObject to get a stored user data pointer from</doc>
            <type name="Object" c:type="GObject*" gs:managed-name="Object" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="quark" transfer-ownership="none" gs:managed-name="quark" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2843">A #GQuark, naming the user data pointer</doc>
            <type name="GLib.Quark" c:type="GQuark" gs:managed-name="GISharp.Lib.GLib.Quark" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="quark" transfer-ownership="none" gs:managed-name="quark" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2843">A #GQuark, naming the user data pointer</doc>
            <type name="GLib.Quark" c:type="GQuark" gs:managed-name="GISharp.Lib.GLib.Quark" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="getv" c:identifier="g_object_getv" version="2.54" gs:dll-name="gobject-2.0" gs:managed-name="Getv">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2869">Gets @n_properties properties for an @object.
Obtained properties will be set to @values. All properties must be valid.
Warnings will be emitted and undefined behaviour may result if invalid
properties are passed in.</doc>
        <source-position filename="gobject.h" line="467" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2871">a #GObject</doc>
            <type name="Object" c:type="GObject*" gs:managed-name="Object" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="n_properties" transfer-ownership="none" gs:managed-name="nProperties" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2872">the number of properties</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
          <parameter name="names" transfer-ownership="none" gs:managed-name="names" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2873">the names of each property to get</doc>
            <array length="0" zero-terminated="0" c:type="const gchar**" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="values" transfer-ownership="none" gs:managed-name="values" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2874">the values of each property to get</doc>
            <array length="0" zero-terminated="0" c:type="GValue*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="Value" c:type="GValue" gs:managed-name="Value" />
            </array>
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="names" transfer-ownership="none" gs:managed-name="names" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2873">the names of each property to get</doc>
            <array length="0" zero-terminated="0" c:type="const gchar**" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
            </array>
          </parameter>
          <parameter name="values" transfer-ownership="none" gs:managed-name="values" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2874">the values of each property to get</doc>
            <array length="0" zero-terminated="0" c:type="GValue*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="Value" c:type="GValue" gs:managed-name="Value" />
            </array>
          </parameter>
        </gs:managed-parameters>
      </method>
      <gs:managed-property name="is_floating" version="2.10" gs:dll-name="gobject-2.0" gs:managed-name="IsFloating">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2952">Checks whether @object has a [floating][floating-ref] reference.</doc>
        <source-position filename="gobject.h" line="494" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="2959">%TRUE if @object has a floating reference</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2954">a #GObject</doc>
            <type name="Object" c:type="gpointer" gs:managed-name="Object" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="is_floating" c:identifier="g_object_is_floating" version="2.10" gs:dll-name="gobject-2.0" gs:managed-name="GetIsFloating" gs:property-getter-for="IsFloating" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2952">Checks whether @object has a [floating][floating-ref] reference.</doc>
        <source-position filename="gobject.h" line="494" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="2959">%TRUE if @object has a floating reference</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2954">a #GObject</doc>
            <type name="Object" c:type="gpointer" gs:managed-name="Object" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="notify" c:identifier="g_object_notify" gs:dll-name="gobject-2.0" gs:managed-name="Notify">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3050">Emits a "notify" signal for the property @property_name on @object.

When possible, eg. when signaling a property change from within the class
that registered the property, you should use g_object_notify_by_pspec()
instead.

Note that emission of the notify signal may be blocked with
g_object_freeze_notify(). In this case, the signal emissions are queued
and will be emitted (in reverse order) when g_object_thaw_notify() is
called.</doc>
        <source-position filename="gobject.h" line="486" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3052">a #GObject</doc>
            <type name="Object" c:type="GObject*" gs:managed-name="Object" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="property_name" transfer-ownership="none" gs:managed-name="propertyName" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3053">the name of a property installed on the class of @object.</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="property_name" transfer-ownership="none" gs:managed-name="propertyName" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3053">the name of a property installed on the class of @object.</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="notify_by_pspec" c:identifier="g_object_notify_by_pspec" version="2.26" gs:dll-name="gobject-2.0" gs:managed-name="NotifyByPspec">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3068">Emits a "notify" signal for the property specified by @pspec on @object.

This function omits the property name lookup, hence it is faster than
g_object_notify().

One way to avoid using g_object_notify() from within the
class that registered the properties, and using g_object_notify_by_pspec()
instead, is to store the GParamSpec used with
g_object_class_install_property() inside a static array, e.g.:

|[&lt;!-- language="C" --&gt;
  enum
  {
    PROP_0,
    PROP_FOO,
    PROP_LAST
  };

  static GParamSpec *properties[PROP_LAST];

  static void
  my_object_class_init (MyObjectClass *klass)
  {
    properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
                                             0, 100,
                                             50,
                                             G_PARAM_READWRITE);
    g_object_class_install_property (gobject_class,
                                     PROP_FOO,
                                     properties[PROP_FOO]);
  }
]|

and then notify a change on the "foo" property with:

|[&lt;!-- language="C" --&gt;
  g_object_notify_by_pspec (self, properties[PROP_FOO]);
]|</doc>
        <source-position filename="gobject.h" line="489" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3070">a #GObject</doc>
            <type name="Object" c:type="GObject*" gs:managed-name="Object" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3071">the #GParamSpec of a property installed on the class of @object.</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3071">the #GParamSpec of a property installed on the class of @object.</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="ref" c:identifier="g_object_ref" gs:dll-name="gobject-2.0" gs:managed-name="Ref" gs:special-func="ref" gs:pinvoke-only="1">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3116">Increases the reference count of @object.

Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
of @object will be propagated to the return type (using the GCC typeof()
extension), so any casting the caller needs to do on the return type must be
explicit.</doc>
        <source-position filename="gobject.h" line="498" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3127">the same @object</doc>
          <type name="Object" c:type="gpointer" gs:managed-name="Object" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3118">a #GObject</doc>
            <type name="Object" c:type="gpointer" gs:managed-name="Object" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="ref_sink" c:identifier="g_object_ref_sink" version="2.10" gs:dll-name="gobject-2.0" gs:managed-name="RefSink">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3131">Increase the reference count of @object, and possibly remove the
[floating][floating-ref] reference, if @object has a floating reference.

In other words, if the object is floating, then this call "assumes
ownership" of the floating reference, converting it to a normal
reference by clearing the floating flag while leaving the reference
count unchanged.  If the object is not floating, then this call
adds a new normal reference increasing the reference count by one.

Since GLib 2.56, the type of @object will be propagated to the return type
under the same conditions as for g_object_ref().</doc>
        <source-position filename="gobject.h" line="496" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3148">@object</doc>
          <type name="Object" c:type="gpointer" gs:managed-name="Object" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3133">a #GObject</doc>
            <type name="Object" c:type="gpointer" gs:managed-name="Object" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="run_dispose" c:identifier="g_object_run_dispose" gs:dll-name="gobject-2.0" gs:managed-name="RunDispose">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3240">Releases all references to other objects. This can be used to break
reference cycles.

This function should only be called from object system implementations.</doc>
        <source-position filename="gobject.h" line="636" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3242">a #GObject</doc>
            <type name="Object" c:type="GObject*" gs:managed-name="Object" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="set_data" c:identifier="g_object_set_data" gs:dll-name="gobject-2.0" gs:managed-name="SetData">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3271">Each object carries around a table of associations from
strings to pointers.  This function lets you set an association.

If the object already had an association with that name,
the old association will be destroyed.

Internally, the @key is converted to a #GQuark using g_quark_from_string().
This means a copy of @key is kept permanently (even after @object has been
finalized) — so it is recommended to only use a small, bounded set of values
for @key in your program, to avoid the #GQuark storage growing unbounded.</doc>
        <source-position filename="gobject.h" line="580" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3273">#GObject containing the associations.</doc>
            <type name="Object" c:type="GObject*" gs:managed-name="Object" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3274">name of the key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3275">data to associate with that key</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3274">name of the key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3275">data to associate with that key</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_property" c:identifier="g_object_set_property" gs:dll-name="gobject-2.0" gs:managed-name="SetProperty">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3305">Sets a property on an object.</doc>
        <source-position filename="gobject.h" line="476" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3307">a #GObject</doc>
            <type name="Object" c:type="GObject*" gs:managed-name="Object" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="property_name" transfer-ownership="none" gs:managed-name="propertyName" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3308">the name of the property to set</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3309">the value</doc>
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="property_name" transfer-ownership="none" gs:managed-name="propertyName" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3308">the name of the property to set</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3309">the value</doc>
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="steal_data" c:identifier="g_object_steal_data" gs:dll-name="gobject-2.0" gs:managed-name="StealData">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3375">Remove a specified datum from the object's data associations,
without invoking the association's destroy handler.</doc>
        <source-position filename="gobject.h" line="589" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3383">the data if found, or %NULL
         if no such data exists.</doc>
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3377">#GObject containing the associations</doc>
            <type name="Object" c:type="GObject*" gs:managed-name="Object" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3378">name of the key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="key" transfer-ownership="none" gs:managed-name="key" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3378">name of the key</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="steal_qdata" c:identifier="g_object_steal_qdata" gs:dll-name="gobject-2.0" gs:managed-name="StealQdata">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3388">This function gets back user data pointers stored via
g_object_set_qdata() and removes the @data from object
without invoking its destroy() function (if any was
set).
Usually, calling this function is only required to update
user data pointers with a destroy notifier, for example:
|[&lt;!-- language="C" --&gt;
void
object_add_to_user_list (GObject     *object,
                         const gchar *new_string)
{
  // the quark, naming the object data
  GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
  // retrieve the old string list
  GList *list = g_object_steal_qdata (object, quark_string_list);

  // prepend new string
  list = g_list_prepend (list, g_strdup (new_string));
  // this changed 'list', so we need to set it again
  g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
}
static void
free_string_list (gpointer data)
{
  GList *node, *list = data;

  for (node = list; node; node = node-&gt;next)
    g_free (node-&gt;data);
  g_list_free (list);
}
]|
Using g_object_get_qdata() in the above example, instead of
g_object_steal_qdata() would have left the destroy function set,
and thus the partial string list would have been freed upon
g_object_set_qdata_full().</doc>
        <source-position filename="gobject.h" line="560" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3429">The user data pointer set, or %NULL</doc>
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3390">The GObject to get a stored user data pointer from</doc>
            <type name="Object" c:type="GObject*" gs:managed-name="Object" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="quark" transfer-ownership="none" gs:managed-name="quark" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3391">A #GQuark, naming the user data pointer</doc>
            <type name="GLib.Quark" c:type="GQuark" gs:managed-name="GISharp.Lib.GLib.Quark" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="quark" transfer-ownership="none" gs:managed-name="quark" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3391">A #GQuark, naming the user data pointer</doc>
            <type name="GLib.Quark" c:type="GQuark" gs:managed-name="GISharp.Lib.GLib.Quark" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="thaw_notify" c:identifier="g_object_thaw_notify" gs:dll-name="gobject-2.0" gs:managed-name="ThawNotify">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3433">Reverts the effect of a previous call to
g_object_freeze_notify(). The freeze count is decreased on @object
and when it reaches zero, queued "notify" signals are emitted.

Duplicate notifications for each property are squashed so that at most one
#GObject::notify signal is emitted for each property, in the reverse order
in which they have been queued.

It is an error to call this function when the freeze count is zero.</doc>
        <source-position filename="gobject.h" line="492" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3435">a #GObject</doc>
            <type name="Object" c:type="GObject*" gs:managed-name="Object" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="unref" c:identifier="g_object_unref" gs:dll-name="gobject-2.0" gs:managed-name="Unref" gs:special-func="unref" gs:pinvoke-only="1">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3449">Decreases the reference count of @object. When its reference count
drops to 0, the object is finalized (i.e. its memory is freed).

If the pointer to the #GObject may be reused in future (for example, if it is
an instance variable of another object), it is recommended to clear the
pointer to %NULL rather than retain a dangling pointer to a potentially
invalid #GObject instance. Use g_clear_object() for this.</doc>
        <source-position filename="gobject.h" line="500" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3451">a #GObject</doc>
            <type name="Object" c:type="gpointer" gs:managed-name="Object" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="watch_closure" c:identifier="g_object_watch_closure" gs:dll-name="gobject-2.0" gs:managed-name="WatchClosure">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3463">This function essentially limits the life time of the @closure to
the life time of the object. That is, when the object is finalized,
the @closure is invalidated by calling g_closure_invalidate() on
it, in order to prevent invocations of the closure with a finalized
(nonexisting) object. Also, g_object_ref() and g_object_unref() are
added as marshal guards to the @closure, to ensure that an extra
reference count is held on @object during invocation of the
@closure.  Usually, this function will be called on closures that
use this @object as closure data.</doc>
        <source-position filename="gobject.h" line="607" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3465">#GObject restricting lifetime of @closure</doc>
            <type name="Object" c:type="GObject*" gs:managed-name="Object" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="closure" transfer-ownership="none" gs:managed-name="closure" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3466">#GClosure to watch</doc>
            <type name="Closure" c:type="GClosure*" gs:managed-name="Closure" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="closure" transfer-ownership="none" gs:managed-name="closure" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3466">#GClosure to watch</doc>
            <type name="Closure" c:type="GClosure*" gs:managed-name="Closure" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <field name="g_type_instance" gs:managed-name="GTypeInstance">
        <type name="TypeInstance" c:type="GTypeInstance" gs:managed-name="TypeInstance" />
      </field>
      <field name="ref_count" readable="0" private="1" gs:managed-name="RefCount">
        <type name="guint" c:type="volatile guint" gs:managed-name="System.UInt32" />
      </field>
      <field name="qdata" readable="0" private="1" gs:managed-name="Qdata">
        <type name="GLib.Data" c:type="GData*" gs:managed-name="GISharp.Lib.GLib.Data" gs:is-pointer="1" />
      </field>
      <glib:signal name="notify" when="first" no-recurse="1" detailed="1" action="1" no-hooks="1" gs:dll-name="gobject-2.0" gs:managed-name="NotifySignal">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="58">The notify signal is emitted on an object when one of its properties has
its value set through g_object_set_property(), g_object_set(), et al.

Note that getting this signal doesn’t itself guarantee that the value of
the property has actually changed. When it is emitted is determined by the
derived GObject class. If the implementor did not create the property with
%G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
in ::notify being emitted, even if the new value is the same as the old.
If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
and common practice is to do that only when the value has actually changed.

This signal is typically used to obtain change notification for a
single property, by specifying the property name as a detail in the
g_signal_connect() call, like this:
|[&lt;!-- language="C" --&gt;
g_signal_connect (text_view-&gt;buffer, "notify::paste-target-list",
                  G_CALLBACK (gtk_text_view_target_list_notify),
                  text_view)
]|
It is important to note that you must use
[canonical parameter names][canonical-parameter-names] as
detail strings for the notify signal.</doc>
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc>the instance on which the signal was invoked</doc>
            <type name="Object" c:name="gpointer" gs:is-pointer="1" gs:managed-name="Object" />
          </instance-parameter>
          <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="61">the #GParamSpec of the property which changed.</doc>
            <type name="ParamSpec" gs:managed-name="ParamSpec" gs:is-pointer="1" />
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="1" gs:managed-name="userData" direction="in">
            <type name="gpointer" c:name="gpointer" gs:is-pointer="1" gs:managed-name="System.IntPtr" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
            <doc>the instance on which the signal was invoked</doc>
            <type name="Object" c:name="gpointer" gs:is-pointer="1" gs:managed-name="Object" />
          </instance-parameter>
          <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="61">the #GParamSpec of the property which changed.</doc>
            <type name="ParamSpec" gs:managed-name="ParamSpec" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </glib:signal>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_object_get_type" gs:access-modifiers="private" gs:dll-name="gobject-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </class>
    <record name="ObjectClass" c:type="GObjectClass" glib:is-gtype-struct-for="Object" gs:managed-name="ObjectClass">
      <doc xml:space="preserve" filename="gobject.h" line="253">The class structure for the GObject type.

|[&lt;!-- language="C" --&gt;
// Example of implementing a singleton using a constructor.
static MySingleton *the_singleton = NULL;

static GObject*
my_singleton_constructor (GType                  type,
                          guint                  n_construct_params,
                          GObjectConstructParam *construct_params)
{
  GObject *object;
  
  if (!the_singleton)
    {
      object = G_OBJECT_CLASS (parent_class)-&gt;constructor (type,
                                                           n_construct_params,
                                                           construct_params);
      the_singleton = MY_SINGLETON (object);
    }
  else
    object = g_object_ref (G_OBJECT (the_singleton));

  return object;
}
]|</doc>
      <source-position filename="gobject.h" line="354" />
      <field name="g_type_class" gs:managed-name="GTypeClass">
        <doc xml:space="preserve" filename="gobject.h" line="255">the parent class</doc>
        <type name="TypeClass" c:type="GTypeClass" gs:managed-name="TypeClass" />
      </field>
      <field name="construct_properties" readable="0" private="1" gs:managed-name="ConstructProperties">
        <type name="GLib.SList" c:type="GSList*" gs:managed-name="GISharp.Lib.GLib.SList" gs:is-pointer="1">
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </type>
      </field>
      <field name="constructor" introspectable="1" gs:managed-name="Constructor">
        <type name="gpointer" introspectable="1" gs:dll-name="gobject-2.0" gs:managed-name="System.IntPtr">
          <source-position filename="gobject.h" line="324" />
          <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
            <type name="Object" c:type="GObject*" gs:managed-name="Object" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
              <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
            </parameter>
            <parameter name="n_construct_properties" transfer-ownership="none" gs:managed-name="nConstructProperties" direction="in">
              <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
            </parameter>
            <parameter name="construct_properties" transfer-ownership="none" gs:managed-name="constructProperties" direction="in">
              <type name="ObjectConstructParam" c:type="GObjectConstructParam*" gs:managed-name="ObjectConstructParam" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
              <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
            </parameter>
            <parameter name="n_construct_properties" transfer-ownership="none" gs:managed-name="nConstructProperties" direction="in">
              <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
            </parameter>
            <parameter name="construct_properties" transfer-ownership="none" gs:managed-name="constructProperties" direction="in">
              <type name="ObjectConstructParam" c:type="GObjectConstructParam*" gs:managed-name="ObjectConstructParam" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </type>
      </field>
      <field name="set_property" gs:managed-name="SetProperty">
        <type name="set_property" gs:dll-name="gobject-2.0" gs:managed-name="SetProperty" />
        <callback name="set_property" gs:dll-name="gobject-2.0" gs:managed-name="SetProperty">
          <source-position filename="gobject.h" line="328" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" gs:managed-name="System.Void" />
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
              <type name="Object" c:type="GObject*" gs:managed-name="Object" gs:is-pointer="1" />
            </parameter>
            <parameter name="property_id" transfer-ownership="none" gs:managed-name="propertyId" direction="in">
              <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
            </parameter>
            <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
              <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
            </parameter>
            <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
              <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
              <type name="Object" c:type="GObject*" gs:managed-name="Object" gs:is-pointer="1" />
            </parameter>
            <parameter name="property_id" transfer-ownership="none" gs:managed-name="propertyId" direction="in">
              <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
            </parameter>
            <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
              <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
            </parameter>
            <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
              <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="get_property" gs:managed-name="GetProperty">
        <type name="get_property" gs:dll-name="gobject-2.0" gs:managed-name="GetProperty" />
        <callback name="get_property" gs:dll-name="gobject-2.0" gs:managed-name="GetProperty">
          <source-position filename="gobject.h" line="332" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" gs:managed-name="System.Void" />
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
              <type name="Object" c:type="GObject*" gs:managed-name="Object" gs:is-pointer="1" />
            </parameter>
            <parameter name="property_id" transfer-ownership="none" gs:managed-name="propertyId" direction="in">
              <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
            </parameter>
            <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
              <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
            </parameter>
            <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
              <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
              <type name="Object" c:type="GObject*" gs:managed-name="Object" gs:is-pointer="1" />
            </parameter>
            <parameter name="property_id" transfer-ownership="none" gs:managed-name="propertyId" direction="in">
              <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
            </parameter>
            <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
              <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
            </parameter>
            <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
              <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="dispose" gs:managed-name="Dispose">
        <type name="dispose" gs:dll-name="gobject-2.0" gs:managed-name="Dispose" />
        <callback name="dispose" gs:dll-name="gobject-2.0" gs:managed-name="Dispose">
          <source-position filename="gobject.h" line="336" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" gs:managed-name="System.Void" />
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
              <type name="Object" c:type="GObject*" gs:managed-name="Object" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
              <type name="Object" c:type="GObject*" gs:managed-name="Object" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="finalize" gs:managed-name="Finalize">
        <type name="finalize" gs:dll-name="gobject-2.0" gs:managed-name="Finalize" />
        <callback name="finalize" gs:dll-name="gobject-2.0" gs:managed-name="Finalize">
          <source-position filename="gobject.h" line="337" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" gs:managed-name="System.Void" />
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
              <type name="Object" c:type="GObject*" gs:managed-name="Object" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
              <type name="Object" c:type="GObject*" gs:managed-name="Object" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="dispatch_properties_changed" gs:managed-name="DispatchPropertiesChanged">
        <type name="dispatch_properties_changed" gs:dll-name="gobject-2.0" gs:managed-name="DispatchPropertiesChanged" />
        <callback name="dispatch_properties_changed" gs:dll-name="gobject-2.0" gs:managed-name="DispatchPropertiesChanged">
          <source-position filename="gobject.h" line="339" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" gs:managed-name="System.Void" />
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
              <type name="Object" c:type="GObject*" gs:managed-name="Object" gs:is-pointer="1" />
            </parameter>
            <parameter name="n_pspecs" transfer-ownership="none" gs:managed-name="nPspecs" direction="in">
              <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
            </parameter>
            <parameter name="pspecs" transfer-ownership="none" gs:managed-name="pspecs" direction="in">
              <type name="ParamSpec" c:type="GParamSpec**" gs:managed-name="ParamSpec" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
              <type name="Object" c:type="GObject*" gs:managed-name="Object" gs:is-pointer="1" />
            </parameter>
            <parameter name="n_pspecs" transfer-ownership="none" gs:managed-name="nPspecs" direction="in">
              <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
            </parameter>
            <parameter name="pspecs" transfer-ownership="none" gs:managed-name="pspecs" direction="in">
              <type name="ParamSpec" c:type="GParamSpec**" gs:managed-name="ParamSpec" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="notify" gs:managed-name="Notify">
        <type name="notify" gs:dll-name="gobject-2.0" gs:managed-name="Notify" />
        <callback name="notify" gs:dll-name="gobject-2.0" gs:managed-name="Notify">
          <source-position filename="gobject.h" line="343" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" gs:managed-name="System.Void" />
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
              <doc xml:space="preserve" filename="gobject-2.0.c" line="3052">a #GObject</doc>
              <type name="Object" c:type="GObject*" gs:managed-name="Object" gs:is-pointer="1" />
            </parameter>
            <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
              <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
              <doc xml:space="preserve" filename="gobject-2.0.c" line="3052">a #GObject</doc>
              <type name="Object" c:type="GObject*" gs:managed-name="Object" gs:is-pointer="1" />
            </parameter>
            <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
              <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="constructed" gs:managed-name="Constructed">
        <type name="constructed" gs:dll-name="gobject-2.0" gs:managed-name="Constructed" />
        <callback name="constructed" gs:dll-name="gobject-2.0" gs:managed-name="Constructed">
          <source-position filename="gobject.h" line="347" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" gs:managed-name="System.Void" />
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
              <type name="Object" c:type="GObject*" gs:managed-name="Object" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="object" transfer-ownership="none" gs:managed-name="@object" direction="in">
              <type name="Object" c:type="GObject*" gs:managed-name="Object" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="flags" readable="0" private="1" gs:managed-name="Flags">
        <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
      </field>
      <field name="pdummy" readable="0" private="1" gs:managed-name="Pdummy">
        <array zero-terminated="0" fixed-size="6" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </array>
      </field>
      <method name="find_property" c:identifier="g_object_class_find_property" gs:dll-name="gobject-2.0" gs:managed-name="FindProperty">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2481">Looks up the #GParamSpec for a property of a class.</doc>
        <source-position filename="gobject.h" line="392" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="2488">the #GParamSpec for the property, or
         %NULL if the class doesn't have a property of that name</doc>
          <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="oclass" transfer-ownership="none" gs:managed-name="oclass" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2483">a #GObjectClass</doc>
            <type name="ObjectClass" c:type="GObjectClass*" gs:managed-name="ObjectClass" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="property_name" transfer-ownership="none" gs:managed-name="propertyName" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2484">the name of the property to look up</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="property_name" transfer-ownership="none" gs:managed-name="propertyName" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2484">the name of the property to look up</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="install_properties" c:identifier="g_object_class_install_properties" version="2.26" gs:dll-name="gobject-2.0" gs:managed-name="InstallProperties">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2493">Installs new properties from an array of #GParamSpecs.

All properties should be installed during the class initializer.  It
is possible to install properties after that, but doing so is not
recommend, and specifically, is not guaranteed to be thread-safe vs.
use of properties on the same type on other threads.

The property id of each property is the index of each #GParamSpec in
the @pspecs array.

The property id of 0 is treated specially by #GObject and it should not
be used to store a #GParamSpec.

This function should be used if you plan to use a static array of
#GParamSpecs and g_object_notify_by_pspec(). For instance, this
class initialization:

|[&lt;!-- language="C" --&gt;
enum {
  PROP_0, PROP_FOO, PROP_BAR, N_PROPERTIES
};

static GParamSpec *obj_properties[N_PROPERTIES] = { NULL, };

static void
my_object_class_init (MyObjectClass *klass)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);

  obj_properties[PROP_FOO] =
    g_param_spec_int ("foo", "Foo", "Foo",
                      -1, G_MAXINT,
                      0,
                      G_PARAM_READWRITE);

  obj_properties[PROP_BAR] =
    g_param_spec_string ("bar", "Bar", "Bar",
                         NULL,
                         G_PARAM_READWRITE);

  gobject_class-&gt;set_property = my_object_set_property;
  gobject_class-&gt;get_property = my_object_get_property;
  g_object_class_install_properties (gobject_class,
                                     N_PROPERTIES,
                                     obj_properties);
}
]|

allows calling g_object_notify_by_pspec() to notify of property changes:

|[&lt;!-- language="C" --&gt;
void
my_object_set_foo (MyObject *self, gint foo)
{
  if (self-&gt;foo != foo)
    {
      self-&gt;foo = foo;
      g_object_notify_by_pspec (G_OBJECT (self), obj_properties[PROP_FOO]);
    }
 }
]|</doc>
        <source-position filename="gobject.h" line="402" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="oclass" transfer-ownership="none" gs:managed-name="oclass" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2495">a #GObjectClass</doc>
            <type name="ObjectClass" c:type="GObjectClass*" gs:managed-name="ObjectClass" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="n_pspecs" transfer-ownership="none" gs:managed-name="nPspecs" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2496">the length of the #GParamSpecs array</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
          <parameter name="pspecs" transfer-ownership="none" gs:managed-name="pspecs" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2497">the #GParamSpecs array
  defining the new properties</doc>
            <array length="0" zero-terminated="0" c:type="GParamSpec**" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
            </array>
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="pspecs" transfer-ownership="none" gs:managed-name="pspecs" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2497">the #GParamSpecs array
  defining the new properties</doc>
            <array length="0" zero-terminated="0" c:type="GParamSpec**" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
              <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
            </array>
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="install_property" c:identifier="g_object_class_install_property" gs:dll-name="gobject-2.0" gs:managed-name="InstallProperty">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2566">Installs a new property.

All properties should be installed during the class initializer.  It
is possible to install properties after that, but doing so is not
recommend, and specifically, is not guaranteed to be thread-safe vs.
use of properties on the same type on other threads.

Note that it is possible to redefine a property in a derived class,
by installing a property with the same name. This can be useful at times,
e.g. to change the range of allowed values or the default value.</doc>
        <source-position filename="gobject.h" line="388" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="oclass" transfer-ownership="none" gs:managed-name="oclass" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2568">a #GObjectClass</doc>
            <type name="ObjectClass" c:type="GObjectClass*" gs:managed-name="ObjectClass" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="property_id" transfer-ownership="none" gs:managed-name="propertyId" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2569">the id for the new property</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
          <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2570">the #GParamSpec for the new property</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="property_id" transfer-ownership="none" gs:managed-name="propertyId" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2569">the id for the new property</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
          <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2570">the #GParamSpec for the new property</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="list_properties" c:identifier="g_object_class_list_properties" gs:dll-name="gobject-2.0" gs:managed-name="ListProperties">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2585">Get an array of #GParamSpec* for all properties of a class.</doc>
        <source-position filename="gobject.h" line="395" />
        <return-value transfer-ownership="container" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="2592">an array of
         #GParamSpec* which should be freed after use</doc>
          <array length="0" zero-terminated="0" c:type="GParamSpec**" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
            <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="oclass" transfer-ownership="none" gs:managed-name="oclass" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2587">a #GObjectClass</doc>
            <type name="ObjectClass" c:type="GObjectClass*" gs:managed-name="ObjectClass" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="n_properties" direction="out" caller-allocates="0" transfer-ownership="full" gs:managed-name="nProperties">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2588">return location for the length of the returned array</doc>
            <type name="guint" c:type="guint*" gs:managed-name="System.UInt32" />
          </parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="override_property" c:identifier="g_object_class_override_property" version="2.4" gs:dll-name="gobject-2.0" gs:managed-name="OverrideProperty">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="2597">Registers @property_id as referring to a property with the name
@name in a parent class or in an interface implemented by @oclass.
This allows this class to "override" a property implementation in
a parent class or to provide the implementation of a property from
an interface.

Internally, overriding is implemented by creating a property of type
#GParamSpecOverride; generally operations that query the properties of
the object class, such as g_object_class_find_property() or
g_object_class_list_properties() will return the overridden
property. However, in one case, the @construct_properties argument of
the @constructor virtual function, the #GParamSpecOverride is passed
instead, so that the @param_id field of the #GParamSpec will be
correct.  For virtually all uses, this makes no difference. If you
need to get the overridden property, you can call
g_param_spec_get_redirect_target().</doc>
        <source-position filename="gobject.h" line="398" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="oclass" transfer-ownership="none" gs:managed-name="oclass" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2599">a #GObjectClass</doc>
            <type name="ObjectClass" c:type="GObjectClass*" gs:managed-name="ObjectClass" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="property_id" transfer-ownership="none" gs:managed-name="propertyId" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2600">the new property ID</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2601">the name of a property registered in a parent class or
 in an interface of this class.</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="property_id" transfer-ownership="none" gs:managed-name="propertyId" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2600">the new property ID</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="2601">the name of a property registered in a parent class or
 in an interface of this class.</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
    </record>
    <bitfield name="ParamFlags" c:type="GParamFlags" gs:managed-name="ParamFlags">
      <doc xml:space="preserve" filename="gparam.h" line="116">Through the #GParamFlags flag values, certain aspects of parameters
can be configured. See also #G_PARAM_STATIC_STRINGS.</doc>
      <source-position filename="gparam.h" line="166" />
      <member name="readable" value="1" c:identifier="G_PARAM_READABLE" gs:managed-name="Readable">
        <doc xml:space="preserve" filename="gparam.h" line="118">the parameter is readable</doc>
      </member>
      <member name="writable" value="2" c:identifier="G_PARAM_WRITABLE" gs:managed-name="Writable">
        <doc xml:space="preserve" filename="gparam.h" line="119">the parameter is writable</doc>
      </member>
      <member name="readwrite" value="3" c:identifier="G_PARAM_READWRITE" gs:managed-name="Readwrite">
        <doc xml:space="preserve" filename="gparam.h" line="120">alias for %G_PARAM_READABLE | %G_PARAM_WRITABLE</doc>
      </member>
      <member name="construct" value="4" c:identifier="G_PARAM_CONSTRUCT" gs:managed-name="Construct">
        <doc xml:space="preserve" filename="gparam.h" line="121">the parameter will be set upon object construction</doc>
      </member>
      <member name="construct_only" value="8" c:identifier="G_PARAM_CONSTRUCT_ONLY" gs:managed-name="ConstructOnly">
        <doc xml:space="preserve" filename="gparam.h" line="122">the parameter can only be set upon object construction</doc>
      </member>
      <member name="lax_validation" value="16" c:identifier="G_PARAM_LAX_VALIDATION" gs:managed-name="LaxValidation">
        <doc xml:space="preserve" filename="gparam.h" line="123">upon parameter conversion (see g_param_value_convert())
 strict validation is not required</doc>
      </member>
      <member name="static_name" value="32" c:identifier="G_PARAM_STATIC_NAME" version="2.8" gs:managed-name="StaticName">
        <doc xml:space="preserve" filename="gparam.h" line="125">the string used as name when constructing the
 parameter is guaranteed to remain valid and
 unmodified for the lifetime of the parameter.</doc>
      </member>
      <member name="private" value="32" c:identifier="G_PARAM_PRIVATE" gs:managed-name="Private">
        <doc xml:space="preserve" filename="gparam.h" line="141">internal</doc>
      </member>
      <member name="static_nick" value="64" c:identifier="G_PARAM_STATIC_NICK" version="2.8" gs:managed-name="StaticNick">
        <doc xml:space="preserve" filename="gparam.h" line="129">the string used as nick when constructing the
 parameter is guaranteed to remain valid and
 unmmodified for the lifetime of the parameter.</doc>
      </member>
      <member name="static_blurb" value="128" c:identifier="G_PARAM_STATIC_BLURB" version="2.8" gs:managed-name="StaticBlurb">
        <doc xml:space="preserve" filename="gparam.h" line="133">the string used as blurb when constructing the
 parameter is guaranteed to remain valid and
 unmodified for the lifetime of the parameter.</doc>
      </member>
      <member name="explicit_notify" value="1073741824" c:identifier="G_PARAM_EXPLICIT_NOTIFY" version="2.42" gs:managed-name="ExplicitNotify">
        <doc xml:space="preserve" filename="gparam.h" line="137">calls to g_object_set_property() for this
  property will not automatically result in a "notify" signal being
  emitted: the implementation must call g_object_notify() themselves
  in case the property actually changes.</doc>
      </member>
      <member name="deprecated" value="2147483648" c:identifier="G_PARAM_DEPRECATED" version="2.26" gs:managed-name="Deprecated">
        <doc xml:space="preserve" filename="gparam.h" line="142">the parameter is deprecated and will be removed
 in a future version. A warning will be generated if it is used
 while running with G_ENABLE_DIAGNOSTIC=1.</doc>
      </member>
    </bitfield>
    <class name="ParamSpec" c:symbol-prefix="param_spec" c:type="GParamSpec" abstract="1" glib:type-name="GParam" glib:get-type="intern" glib:type-struct="ParamSpecClass" glib:fundamental="1" glib:ref-func="g_param_spec_ref_sink" glib:unref-func="g_param_spec_uref" glib:set-value-func="g_value_set_param" glib:get-value-func="g_value_get_param" gs:managed-name="ParamSpec">
      <doc xml:space="preserve" filename="gobject-2.0.c" line="409">#GParamSpec is an object structure that encapsulates the metadata
required to specify parameters, such as e.g. #GObject properties.

## Parameter names # {#canonical-parameter-names}

A property name consists of one or more segments consisting of ASCII letters
and digits, separated by either the `-` or `_` character. The first
character of a property name must be a letter. These are the same rules as
for signal naming (see g_signal_new()).

When creating and looking up a #GParamSpec, either separator can be
used, but they cannot be mixed. Using `-` is considerably more
efficient, and is the ‘canonical form’. Using `_` is discouraged.</doc>
      <source-position filename="gparam.h" line="260" />
      <function name="is_valid_name" c:identifier="g_param_spec_is_valid_name" version="2.66" gs:dll-name="gobject-2.0" gs:managed-name="IsValidName">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3800">Validate a property name for a #GParamSpec. This can be useful for
dynamically-generated properties which need to be validated at run-time
before actually trying to create them.

See [canonical parameter names][canonical-parameter-names] for details of
the rules for valid names.</doc>
        <source-position filename="gparam.h" line="399" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3811">%TRUE if @name is a valid property name, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3802">the canonical name of the property</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="name" transfer-ownership="none" gs:managed-name="name" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3802">the canonical name of the property</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <virtual-method name="finalize" gs:dll-name="gobject-2.0" gs:managed-name="DoFinalize">
        <source-position filename="gparam.h" line="248" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </virtual-method>
      <virtual-method name="value_set_default" gs:dll-name="gobject-2.0" gs:managed-name="DoValueSetDefault">
        <source-position filename="gparam.h" line="251" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="value_validate" gs:dll-name="gobject-2.0" gs:managed-name="DoValueValidate">
        <source-position filename="gparam.h" line="253" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <virtual-method name="values_cmp" gs:dll-name="gobject-2.0" gs:managed-name="DoValuesCmp">
        <source-position filename="gparam.h" line="255" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="value1" transfer-ownership="none" gs:managed-name="value1" direction="in">
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </parameter>
          <parameter name="value2" transfer-ownership="none" gs:managed-name="value2" direction="in">
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="value1" transfer-ownership="none" gs:managed-name="value1" direction="in">
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </parameter>
          <parameter name="value2" transfer-ownership="none" gs:managed-name="value2" direction="in">
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </virtual-method>
      <gs:managed-property name="get_blurb" gs:dll-name="gobject-2.0" gs:managed-name="Blurb">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3635">Get the short description of a #GParamSpec.</doc>
        <source-position filename="gparam.h" line="328" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3641">the short description of @pspec.</doc>
          <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3637">a valid #GParamSpec</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_blurb" c:identifier="g_param_spec_get_blurb" gs:dll-name="gobject-2.0" gs:managed-name="GetBlurb" gs:property-getter-for="Blurb" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3635">Get the short description of a #GParamSpec.</doc>
        <source-position filename="gparam.h" line="328" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3641">the short description of @pspec.</doc>
          <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3637">a valid #GParamSpec</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_default_value" version="2.38" gs:dll-name="gobject-2.0" gs:managed-name="DefaultValue">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3645">Gets the default value of @pspec as a pointer to a #GValue.

The #GValue will remain valid for the life of @pspec.</doc>
        <source-position filename="gparam.h" line="345" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3653">a pointer to a #GValue which must not be modified</doc>
          <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3647">a #GParamSpec</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_default_value" c:identifier="g_param_spec_get_default_value" version="2.38" gs:dll-name="gobject-2.0" gs:managed-name="GetDefaultValue" gs:property-getter-for="DefaultValue" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3645">Gets the default value of @pspec as a pointer to a #GValue.

The #GValue will remain valid for the life of @pspec.</doc>
        <source-position filename="gparam.h" line="345" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3653">a pointer to a #GValue which must not be modified</doc>
          <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3647">a #GParamSpec</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_name" gs:dll-name="gobject-2.0" gs:managed-name="Name">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3658">Get the name of a #GParamSpec.

The name is always an "interned" string (as per g_intern_string()).
This allows for pointer-value comparisons.</doc>
        <source-position filename="gparam.h" line="324" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3667">the name of @pspec.</doc>
          <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3660">a valid #GParamSpec</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_name" c:identifier="g_param_spec_get_name" gs:dll-name="gobject-2.0" gs:managed-name="GetName" gs:property-getter-for="Name" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3658">Get the name of a #GParamSpec.

The name is always an "interned" string (as per g_intern_string()).
This allows for pointer-value comparisons.</doc>
        <source-position filename="gparam.h" line="324" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3667">the name of @pspec.</doc>
          <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3660">a valid #GParamSpec</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_name_quark" version="2.46" gs:dll-name="gobject-2.0" gs:managed-name="NameQuark">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3671">Gets the GQuark for the name.</doc>
        <source-position filename="gparam.h" line="348" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3677">the GQuark for @pspec-&gt;name.</doc>
          <type name="GLib.Quark" c:type="GQuark" gs:managed-name="GISharp.Lib.GLib.Quark" />
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3673">a #GParamSpec</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_name_quark" c:identifier="g_param_spec_get_name_quark" version="2.46" gs:dll-name="gobject-2.0" gs:managed-name="GetNameQuark" gs:property-getter-for="NameQuark" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3671">Gets the GQuark for the name.</doc>
        <source-position filename="gparam.h" line="348" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3677">the GQuark for @pspec-&gt;name.</doc>
          <type name="GLib.Quark" c:type="GQuark" gs:managed-name="GISharp.Lib.GLib.Quark" />
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3673">a #GParamSpec</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_nick" gs:dll-name="gobject-2.0" gs:managed-name="Nick">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3682">Get the nickname of a #GParamSpec.</doc>
        <source-position filename="gparam.h" line="326" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3688">the nickname of @pspec.</doc>
          <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3684">a valid #GParamSpec</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_nick" c:identifier="g_param_spec_get_nick" gs:dll-name="gobject-2.0" gs:managed-name="GetNick" gs:property-getter-for="Nick" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3682">Get the nickname of a #GParamSpec.</doc>
        <source-position filename="gparam.h" line="326" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3688">the nickname of @pspec.</doc>
          <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3684">a valid #GParamSpec</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="get_qdata" c:identifier="g_param_spec_get_qdata" gs:dll-name="gobject-2.0" gs:managed-name="GetQdata">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3692">Gets back user data pointers stored via g_param_spec_set_qdata().</doc>
        <source-position filename="gparam.h" line="288" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3699">the user data pointer set, or %NULL</doc>
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3694">a valid #GParamSpec</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="quark" transfer-ownership="none" gs:managed-name="quark" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3695">a #GQuark, naming the user data pointer</doc>
            <type name="GLib.Quark" c:type="GQuark" gs:managed-name="GISharp.Lib.GLib.Quark" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="quark" transfer-ownership="none" gs:managed-name="quark" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3695">a #GQuark, naming the user data pointer</doc>
            <type name="GLib.Quark" c:type="GQuark" gs:managed-name="GISharp.Lib.GLib.Quark" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <gs:managed-property name="get_redirect_target" version="2.4" gs:dll-name="gobject-2.0" gs:managed-name="RedirectTarget">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3703">If the paramspec redirects operations to another paramspec,
returns that paramspec. Redirect is used typically for
providing a new implementation of a property in a derived
type while preserving all the properties from the parent
type. Redirection is established by creating a property
of type #GParamSpecOverride. See g_object_class_override_property()
for an example of the use of this capability.</doc>
        <source-position filename="gparam.h" line="303" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3716">paramspec to which requests on this
         paramspec should be redirected, or %NULL if none.</doc>
          <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3705">a #GParamSpec</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_redirect_target" c:identifier="g_param_spec_get_redirect_target" version="2.4" gs:dll-name="gobject-2.0" gs:managed-name="GetRedirectTarget" gs:property-getter-for="RedirectTarget" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3703">If the paramspec redirects operations to another paramspec,
returns that paramspec. Redirect is used typically for
providing a new implementation of a property in a derived
type while preserving all the properties from the parent
type. Redirection is established by creating a property
of type #GParamSpecOverride. See g_object_class_override_property()
for an example of the use of this capability.</doc>
        <source-position filename="gparam.h" line="303" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="3716">paramspec to which requests on this
         paramspec should be redirected, or %NULL if none.</doc>
          <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="3705">a #GParamSpec</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="set_qdata" c:identifier="g_param_spec_set_qdata" gs:dll-name="gobject-2.0" gs:managed-name="SetQdata">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="3998">Sets an opaque, named pointer on a #GParamSpec. The name is
specified through a #GQuark (retrieved e.g. via
g_quark_from_static_string()), and the pointer can be gotten back
from the @pspec with g_param_spec_get_qdata().  Setting a
previously set user data pointer, overrides (frees) the old pointer
set, using %NULL as pointer essentially removes the data stored.</doc>
        <source-position filename="gparam.h" line="291" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4000">the #GParamSpec to set store a user data pointer</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="quark" transfer-ownership="none" gs:managed-name="quark" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4001">a #GQuark, naming the user data pointer</doc>
            <type name="GLib.Quark" c:type="GQuark" gs:managed-name="GISharp.Lib.GLib.Quark" />
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4002">an opaque user data pointer</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="quark" transfer-ownership="none" gs:managed-name="quark" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4001">a #GQuark, naming the user data pointer</doc>
            <type name="GLib.Quark" c:type="GQuark" gs:managed-name="GISharp.Lib.GLib.Quark" />
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="data" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4002">an opaque user data pointer</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="sink" c:identifier="g_param_spec_sink" gs:dll-name="gobject-2.0" gs:managed-name="Sink">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="4029">The initial reference count of a newly created #GParamSpec is 1,
even though no one has explicitly called g_param_spec_ref() on it
yet. So the initial reference count is flagged as "floating", until
someone calls `g_param_spec_ref (pspec); g_param_spec_sink
(pspec);` in sequence on it, taking over the initial
reference count (thus ending up with a @pspec that has a reference
count of 1 still, but is not flagged "floating" anymore).</doc>
        <source-position filename="gparam.h" line="284" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4031">a valid #GParamSpec</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="steal_qdata" c:identifier="g_param_spec_steal_qdata" gs:dll-name="gobject-2.0" gs:managed-name="StealQdata">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="4043">Gets back user data pointers stored via g_param_spec_set_qdata()
and removes the @data from @pspec without invoking its destroy()
function (if any was set).  Usually, calling this function is only
required to update user data pointers with a destroy notifier.</doc>
        <source-position filename="gparam.h" line="300" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="4053">the user data pointer set, or %NULL</doc>
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4045">the #GParamSpec to get a stored user data pointer from</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="quark" transfer-ownership="none" gs:managed-name="quark" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4046">a #GQuark, naming the user data pointer</doc>
            <type name="GLib.Quark" c:type="GQuark" gs:managed-name="GISharp.Lib.GLib.Quark" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="quark" transfer-ownership="none" gs:managed-name="quark" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="4046">a #GQuark, naming the user data pointer</doc>
            <type name="GLib.Quark" c:type="GQuark" gs:managed-name="GISharp.Lib.GLib.Quark" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <field name="g_type_instance" gs:managed-name="GTypeInstance">
        <doc xml:space="preserve" filename="gparam.h" line="198">private #GTypeInstance portion</doc>
        <type name="TypeInstance" c:type="GTypeInstance" gs:managed-name="TypeInstance" />
      </field>
      <field name="name" gs:managed-name="Name">
        <doc xml:space="preserve" filename="gparam.h" line="199">name of this parameter: always an interned string</doc>
        <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
      </field>
      <field name="flags" gs:managed-name="Flags">
        <doc xml:space="preserve" filename="gparam.h" line="200">#GParamFlags flags for this parameter</doc>
        <type name="ParamFlags" c:type="GParamFlags" gs:managed-name="ParamFlags" />
      </field>
      <field name="value_type" gs:managed-name="ValueType">
        <doc xml:space="preserve" filename="gparam.h" line="201">the #GValue type for this parameter</doc>
        <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
      </field>
      <field name="owner_type" gs:managed-name="OwnerType">
        <doc xml:space="preserve" filename="gparam.h" line="202">#GType type that uses (introduces) this parameter</doc>
        <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
      </field>
      <field name="_nick" readable="0" private="1" gs:managed-name="Nick">
        <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
      </field>
      <field name="_blurb" readable="0" private="1" gs:managed-name="Blurb">
        <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
      </field>
      <field name="qdata" readable="0" private="1" gs:managed-name="Qdata">
        <type name="GLib.Data" c:type="GData*" gs:managed-name="GISharp.Lib.GLib.Data" gs:is-pointer="1" />
      </field>
      <field name="ref_count" readable="0" private="1" gs:managed-name="RefCount">
        <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
      </field>
      <field name="param_id" readable="0" private="1" gs:managed-name="ParamId">
        <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
      </field>
    </class>
    <record name="ParamSpecClass" c:type="GParamSpecClass" glib:is-gtype-struct-for="ParamSpec" gs:managed-name="ParamSpecClass">
      <doc xml:space="preserve" filename="gparam.h" line="223">The class structure for the GParamSpec type.
Normally, GParamSpec classes are filled by
g_param_type_register_static().</doc>
      <source-position filename="gparam.h" line="260" />
      <field name="g_type_class" gs:managed-name="GTypeClass">
        <doc xml:space="preserve" filename="gparam.h" line="225">the parent class</doc>
        <type name="TypeClass" c:type="GTypeClass" gs:managed-name="TypeClass" />
      </field>
      <field name="value_type" gs:managed-name="ValueType">
        <doc xml:space="preserve" filename="gparam.h" line="226">the #GValue type for this parameter</doc>
        <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
      </field>
      <field name="finalize" gs:managed-name="Finalize">
        <type name="finalize" gs:dll-name="gobject-2.0" gs:managed-name="Finalize" />
        <callback name="finalize" gs:dll-name="gobject-2.0" gs:managed-name="Finalize">
          <source-position filename="gparam.h" line="248" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" gs:managed-name="System.Void" />
          </return-value>
          <parameters>
            <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
              <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
              <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="value_set_default" gs:managed-name="ValueSetDefault">
        <type name="value_set_default" gs:dll-name="gobject-2.0" gs:managed-name="ValueSetDefault" />
        <callback name="value_set_default" gs:dll-name="gobject-2.0" gs:managed-name="ValueSetDefault">
          <source-position filename="gparam.h" line="251" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" gs:managed-name="System.Void" />
          </return-value>
          <parameters>
            <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
              <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
            </parameter>
            <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
              <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
              <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
            </parameter>
            <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
              <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="value_validate" gs:managed-name="ValueValidate">
        <type name="value_validate" gs:dll-name="gobject-2.0" gs:managed-name="ValueValidate" />
        <callback name="value_validate" gs:dll-name="gobject-2.0" gs:managed-name="ValueValidate">
          <source-position filename="gparam.h" line="253" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
          </return-value>
          <parameters>
            <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
              <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
            </parameter>
            <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
              <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
              <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
            </parameter>
            <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
              <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="values_cmp" gs:managed-name="ValuesCmp">
        <type name="values_cmp" gs:dll-name="gobject-2.0" gs:managed-name="ValuesCmp" />
        <callback name="values_cmp" gs:dll-name="gobject-2.0" gs:managed-name="ValuesCmp">
          <source-position filename="gparam.h" line="255" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </return-value>
          <parameters>
            <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
              <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
            </parameter>
            <parameter name="value1" transfer-ownership="none" gs:managed-name="value1" direction="in">
              <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
            </parameter>
            <parameter name="value2" transfer-ownership="none" gs:managed-name="value2" direction="in">
              <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="pspec" transfer-ownership="none" gs:managed-name="pspec" direction="in">
              <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
            </parameter>
            <parameter name="value1" transfer-ownership="none" gs:managed-name="value1" direction="in">
              <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
            </parameter>
            <parameter name="value2" transfer-ownership="none" gs:managed-name="value2" direction="in">
              <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="dummy" readable="0" private="1" gs:managed-name="Dummy">
        <array zero-terminated="0" fixed-size="4" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </array>
      </field>
    </record>
    <record name="Parameter" c:type="GParameter" deprecated="1" deprecated-version="2.54" gs:managed-name="Parameter">
      <doc xml:space="preserve" filename="gparam.h" line="261">The GParameter struct is an auxiliary structure used
to hand parameter name/value pairs to g_object_newv().</doc>
      <doc-deprecated xml:space="preserve">This type is not introspectable.</doc-deprecated>
      <source-position filename="gparam.h" line="275" />
      <field name="name" writable="1" gs:managed-name="Name">
        <doc xml:space="preserve" filename="gparam.h" line="263">the parameter name</doc>
        <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
      </field>
      <field name="value" writable="1" gs:managed-name="Value">
        <doc xml:space="preserve" filename="gparam.h" line="264">the parameter value</doc>
        <type name="Value" c:type="GValue" gs:managed-name="Value" />
      </field>
    </record>
    <bitfield name="SignalFlags" c:type="GSignalFlags" gs:managed-name="SignalFlags">
      <doc xml:space="preserve" filename="gsignal.h" line="100">The signal flags are used to specify a signal's behaviour, the overall
signal description outlines how especially the RUN flags control the
stages of a signal emission.</doc>
      <source-position filename="gsignal.h" line="138" />
      <member name="run_first" value="1" c:identifier="G_SIGNAL_RUN_FIRST" gs:managed-name="RunFirst">
        <doc xml:space="preserve" filename="gsignal.h" line="102">Invoke the object method handler in the first emission stage.</doc>
      </member>
      <member name="run_last" value="2" c:identifier="G_SIGNAL_RUN_LAST" gs:managed-name="RunLast">
        <doc xml:space="preserve" filename="gsignal.h" line="103">Invoke the object method handler in the third emission stage.</doc>
      </member>
      <member name="run_cleanup" value="4" c:identifier="G_SIGNAL_RUN_CLEANUP" gs:managed-name="RunCleanup">
        <doc xml:space="preserve" filename="gsignal.h" line="104">Invoke the object method handler in the last emission stage.</doc>
      </member>
      <member name="no_recurse" value="8" c:identifier="G_SIGNAL_NO_RECURSE" gs:managed-name="NoRecurse">
        <doc xml:space="preserve" filename="gsignal.h" line="105">Signals being emitted for an object while currently being in
 emission for this very object will not be emitted recursively,
 but instead cause the first emission to be restarted.</doc>
      </member>
      <member name="detailed" value="16" c:identifier="G_SIGNAL_DETAILED" gs:managed-name="Detailed">
        <doc xml:space="preserve" filename="gsignal.h" line="108">This signal supports "::detail" appendices to the signal name
 upon handler connections and emissions.</doc>
      </member>
      <member name="action" value="32" c:identifier="G_SIGNAL_ACTION" gs:managed-name="Action">
        <doc xml:space="preserve" filename="gsignal.h" line="110">Action signals are signals that may freely be emitted on alive
 objects from user code via g_signal_emit() and friends, without
 the need of being embedded into extra code that performs pre or
 post emission adjustments on the object. They can also be thought
 of as object methods which can be called generically by
 third-party code.</doc>
      </member>
      <member name="no_hooks" value="64" c:identifier="G_SIGNAL_NO_HOOKS" gs:managed-name="NoHooks">
        <doc xml:space="preserve" filename="gsignal.h" line="116">No emissions hooks are supported for this signal.</doc>
      </member>
      <member name="must_collect" value="128" c:identifier="G_SIGNAL_MUST_COLLECT" version="2.30" gs:managed-name="MustCollect">
        <doc xml:space="preserve" filename="gsignal.h" line="117">Varargs signal emission will always collect the
  arguments, even if there are no signal handlers connected.</doc>
      </member>
      <member name="deprecated" value="256" c:identifier="G_SIGNAL_DEPRECATED" version="2.32" gs:managed-name="Deprecated">
        <doc xml:space="preserve" filename="gsignal.h" line="119">The signal is deprecated and will be removed
  in a future version. A warning will be generated if it is connected while
  running with G_ENABLE_DIAGNOSTIC=1.</doc>
      </member>
    </bitfield>
    <record name="TypeClass" c:type="GTypeClass" gs:managed-name="TypeClass">
      <doc xml:space="preserve" filename="gtype.h" line="403">An opaque structure used as the base of all classes.</doc>
      <source-position filename="gtype.h" line="412" />
      <field name="g_type" readable="0" private="1" gs:managed-name="GType">
        <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
      </field>
      <method name="add_private" c:identifier="g_type_class_add_private" version="2.4" deprecated="1" deprecated-version="2.58" gs:dll-name="gobject-2.0" gs:managed-name="AddPrivate">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="5235">Registers a private structure for an instantiatable type.

When an object is allocated, the private structures for
the type and all of its parent types are allocated
sequentially in the same memory block as the public
structures, and are zero-filled.

Note that the accumulated size of the private structures of
a type and all its parent types cannot exceed 64 KiB.

This function should be called in the type's class_init() function.
The private structure can be retrieved using the
G_TYPE_INSTANCE_GET_PRIVATE() macro.

The following example shows attaching a private structure
MyObjectPrivate to an object MyObject defined in the standard
GObject fashion in the type's class_init() function.

Note the use of a structure member "priv" to avoid the overhead
of repeatedly calling MY_OBJECT_GET_PRIVATE().

|[&lt;!-- language="C" --&gt;
typedef struct _MyObject        MyObject;
typedef struct _MyObjectPrivate MyObjectPrivate;

struct _MyObject {
 GObject parent;

 MyObjectPrivate *priv;
};

struct _MyObjectPrivate {
  int some_field;
};

static void
my_object_class_init (MyObjectClass *klass)
{
  g_type_class_add_private (klass, sizeof (MyObjectPrivate));
}

static void
my_object_init (MyObject *my_object)
{
  my_object-&gt;priv = G_TYPE_INSTANCE_GET_PRIVATE (my_object,
                                                 MY_TYPE_OBJECT,
                                                 MyObjectPrivate);
  // my_object-&gt;priv-&gt;some_field will be automatically initialised to 0
}

static int
my_object_get_some_field (MyObject *my_object)
{
  MyObjectPrivate *priv;

  g_return_val_if_fail (MY_IS_OBJECT (my_object), 0);

  priv = my_object-&gt;priv;

  return priv-&gt;some_field;
}
]|</doc>
        <doc-deprecated xml:space="preserve">Use the G_ADD_PRIVATE() macro with the `G_DEFINE_*`
  family of macros to add instance private data to a type</doc-deprecated>
        <source-position filename="gtype.h" line="1304" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="g_class" transfer-ownership="none" gs:managed-name="gClass" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5237">class structure for an instantiatable
   type</doc>
            <type name="TypeClass" c:type="gpointer" gs:managed-name="TypeClass" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="private_size" transfer-ownership="none" gs:managed-name="privateSize" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5239">size of private structure</doc>
            <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="private_size" transfer-ownership="none" gs:managed-name="privateSize" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5239">size of private structure</doc>
            <type name="gsize" c:type="gsize" gs:managed-name="System.Int32" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="get_private" c:identifier="g_type_class_get_private" gs:dll-name="gobject-2.0" gs:managed-name="GetPrivate">
        <source-position filename="gtype.h" line="1320" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="klass" transfer-ownership="none" gs:managed-name="klass" direction="in">
            <type name="TypeClass" c:type="GTypeClass*" gs:managed-name="TypeClass" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="private_type" transfer-ownership="none" gs:managed-name="privateType" direction="in">
            <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="private_type" transfer-ownership="none" gs:managed-name="privateType" direction="in">
            <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="peek_parent" c:identifier="g_type_class_peek_parent" gs:dll-name="gobject-2.0" gs:managed-name="PeekParent">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="5344">This is a convenience function often needed in class initializers.
It returns the class structure of the immediate parent type of the
class passed in.  Since derived classes hold a reference count on
their parent classes as long as they are instantiated, the returned
class will always exist.

This function is essentially equivalent to:
g_type_class_peek (g_type_parent (G_TYPE_FROM_CLASS (g_class)))</doc>
        <source-position filename="gtype.h" line="721" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="5358">the parent class
    of @g_class</doc>
          <type name="TypeClass" c:type="gpointer" gs:managed-name="TypeClass" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="g_class" transfer-ownership="none" gs:managed-name="gClass" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5346">the #GTypeClass structure to
    retrieve the parent class for</doc>
            <type name="TypeClass" c:type="gpointer" gs:managed-name="TypeClass" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="unref" c:identifier="g_type_class_unref" gs:dll-name="gobject-2.0" gs:managed-name="Unref" gs:special-func="unref" gs:pinvoke-only="1">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="5390">Decrements the reference count of the class structure being passed in.
Once the last reference count of a class has been released, classes
may be finalized by the type system, so further dereferencing of a
class pointer after g_type_class_unref() are invalid.</doc>
        <source-position filename="gtype.h" line="719" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="g_class" transfer-ownership="none" gs:managed-name="gClass" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5392">a #GTypeClass structure to unref</doc>
            <type name="TypeClass" c:type="gpointer" gs:managed-name="TypeClass" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <function name="adjust_private_offset" c:identifier="g_type_class_adjust_private_offset" gs:dll-name="gobject-2.0" gs:managed-name="AdjustPrivateOffset">
        <source-position filename="gtype.h" line="1313" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <parameter name="g_class" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="gClass" direction="in">
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
          <parameter name="private_size_or_offset" transfer-ownership="none" gs:managed-name="privateSizeOrOffset" direction="in">
            <type name="gint" c:type="gint*" gs:managed-name="System.Int32" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="g_class" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="gClass" direction="in">
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
          <parameter name="private_size_or_offset" transfer-ownership="none" gs:managed-name="privateSizeOrOffset" direction="in">
            <type name="gint" c:type="gint*" gs:managed-name="System.Int32" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="peek" c:identifier="g_type_class_peek" gs:dll-name="gobject-2.0" gs:managed-name="Peek">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="5328">This function is essentially the same as g_type_class_ref(),
except that the classes reference count isn't incremented.
As a consequence, this function may return %NULL if the class
of the type passed in does not currently exist (hasn't been
referenced before).</doc>
        <source-position filename="gtype.h" line="715" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="5338">the #GTypeClass
    structure for the given type ID or %NULL if the class does not
    currently exist</doc>
          <type name="TypeClass" c:type="gpointer" gs:managed-name="TypeClass" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5330">type ID of a classed type</doc>
            <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5330">type ID of a classed type</doc>
            <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="peek_static" c:identifier="g_type_class_peek_static" version="2.4" gs:dll-name="gobject-2.0" gs:managed-name="PeekStatic">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="5363">A more efficient version of g_type_class_peek() which works only for
static types.</doc>
        <source-position filename="gtype.h" line="717" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="5370">the #GTypeClass
    structure for the given type ID or %NULL if the class does not
    currently exist or is dynamically loaded</doc>
          <type name="TypeClass" c:type="gpointer" gs:managed-name="TypeClass" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5365">type ID of a classed type</doc>
            <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5365">type ID of a classed type</doc>
            <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="ref" c:identifier="g_type_class_ref" gs:dll-name="gobject-2.0" gs:managed-name="Ref">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="5377">Increments the reference count of the class structure belonging to
@type. This function will demand-create the class if it doesn't
exist already.</doc>
        <source-position filename="gtype.h" line="713" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="5385">the #GTypeClass
    structure for the given type ID</doc>
          <type name="TypeClass" c:type="gpointer" gs:managed-name="TypeClass" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5379">type ID of a classed type</doc>
            <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="type" transfer-ownership="none" gs:managed-name="type" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5379">type ID of a classed type</doc>
            <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
          </parameter>
        </gs:managed-parameters>
      </function>
    </record>
    <record name="TypeInfo" c:type="GTypeInfo" gs:managed-name="TypeInfo">
      <doc xml:space="preserve" filename="gtype.h" line="1013">This structure is used to provide the type system with the information
required to initialize and destruct (finalize) a type's class and
its instances.

The initialized structure is passed to the g_type_register_static() function
(or is copied into the provided #GTypeInfo structure in the
g_type_plugin_complete_type_info()). The type system will perform a deep
copy of this structure, so its memory does not need to be persistent
across invocation of g_type_register_static().</doc>
      <source-position filename="gtype.h" line="1064" />
      <field name="class_size" writable="1" gs:managed-name="ClassSize">
        <doc xml:space="preserve" filename="gtype.h" line="1015">Size of the class structure (required for interface, classed and instantiatable types)</doc>
        <type name="guint16" c:type="guint16" gs:managed-name="System.UInt16" />
      </field>
      <field name="base_init" writable="1" gs:managed-name="BaseInit">
        <doc xml:space="preserve" filename="gtype.h" line="1016">Location of the base initialization function (optional)</doc>
        <type name="BaseInitFunc" c:type="GBaseInitFunc" gs:managed-name="BaseInitFunc" />
      </field>
      <field name="base_finalize" writable="1" gs:managed-name="BaseFinalize">
        <doc xml:space="preserve" filename="gtype.h" line="1017">Location of the base finalization function (optional)</doc>
        <type name="BaseFinalizeFunc" c:type="GBaseFinalizeFunc" gs:managed-name="BaseFinalizeFunc" />
      </field>
      <field name="class_init" writable="1" gs:managed-name="ClassInit">
        <doc xml:space="preserve" filename="gtype.h" line="1018">Location of the class initialization function for
 classed and instantiatable types. Location of the default vtable
 inititalization function for interface types. (optional) This function
 is used both to fill in virtual functions in the class or default vtable,
 and to do type-specific setup such as registering signals and object
 properties.</doc>
        <type name="ClassInitFunc" c:type="GClassInitFunc" gs:managed-name="ClassInitFunc" />
      </field>
      <field name="class_finalize" writable="1" gs:managed-name="ClassFinalize">
        <doc xml:space="preserve" filename="gtype.h" line="1024">Location of the class finalization function for
 classed and instantiatable types. Location of the default vtable
 finalization function for interface types. (optional)</doc>
        <type name="ClassFinalizeFunc" c:type="GClassFinalizeFunc" gs:managed-name="ClassFinalizeFunc" />
      </field>
      <field name="class_data" writable="1" gs:managed-name="ClassData">
        <doc xml:space="preserve" filename="gtype.h" line="1027">User-supplied data passed to the class init/finalize functions</doc>
        <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
      </field>
      <field name="instance_size" writable="1" gs:managed-name="InstanceSize">
        <doc xml:space="preserve" filename="gtype.h" line="1028">Size of the instance (object) structure (required for instantiatable types only)</doc>
        <type name="guint16" c:type="guint16" gs:managed-name="System.UInt16" />
      </field>
      <field name="n_preallocs" writable="1" gs:managed-name="NPreallocs">
        <doc xml:space="preserve" filename="gtype.h" line="1029">Prior to GLib 2.10, it specified the number of pre-allocated (cached) instances to reserve memory for (0 indicates no caching). Since GLib 2.10, it is ignored, since instances are allocated with the [slice allocator][glib-Memory-Slices] now.</doc>
        <type name="guint16" c:type="guint16" gs:managed-name="System.UInt16" />
      </field>
      <field name="instance_init" writable="1" gs:managed-name="InstanceInit">
        <doc xml:space="preserve" filename="gtype.h" line="1030">Location of the instance initialization function (optional, for instantiatable types only)</doc>
        <type name="InstanceInitFunc" c:type="GInstanceInitFunc" gs:managed-name="InstanceInitFunc" />
      </field>
      <field name="value_table" writable="1" gs:managed-name="ValueTable">
        <doc xml:space="preserve" filename="gtype.h" line="1031">A #GTypeValueTable function table for generic handling of GValues
 of this type (usually only useful for fundamental types)</doc>
        <type name="TypeValueTable" c:type="const GTypeValueTable*" gs:managed-name="TypeValueTable" gs:is-pointer="1" />
      </field>
    </record>
    <record name="TypeInstance" c:type="GTypeInstance" gs:managed-name="TypeInstance">
      <doc xml:space="preserve" filename="gtype.h" line="413">An opaque structure used as the base of all type instances.</doc>
      <source-position filename="gtype.h" line="422" />
      <field name="g_class" readable="0" private="1" gs:managed-name="GClass">
        <type name="TypeClass" c:type="GTypeClass*" gs:managed-name="TypeClass" gs:is-pointer="1" />
      </field>
      <method name="get_private" c:identifier="g_type_instance_get_private" gs:dll-name="gobject-2.0" gs:managed-name="GetPrivate">
        <source-position filename="gtype.h" line="1310" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="instance" transfer-ownership="none" gs:managed-name="instance" direction="in">
            <type name="TypeInstance" c:type="GTypeInstance*" gs:managed-name="TypeInstance" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="private_type" transfer-ownership="none" gs:managed-name="privateType" direction="in">
            <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="private_type" transfer-ownership="none" gs:managed-name="privateType" direction="in">
            <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
          </parameter>
        </gs:managed-parameters>
      </method>
    </record>
    <record name="TypeInterface" c:type="GTypeInterface" gs:managed-name="TypeInterface">
      <doc xml:space="preserve" filename="gtype.h" line="423">An opaque structure used as the base of all interface types.</doc>
      <source-position filename="gtype.h" line="433" />
      <field name="g_type" readable="0" private="1" gs:managed-name="GType">
        <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
      </field>
      <field name="g_instance_type" readable="0" private="1" gs:managed-name="GInstanceType">
        <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
      </field>
      <method name="peek_parent" c:identifier="g_type_interface_peek_parent" gs:dll-name="gobject-2.0" gs:managed-name="PeekParent">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="5695">Returns the corresponding #GTypeInterface structure of the parent type
of the instance type to which @g_iface belongs. This is useful when
deriving the implementation of an interface from the parent type and
then possibly overriding some methods.</doc>
        <source-position filename="gtype.h" line="726" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="5704">the
    corresponding #GTypeInterface structure of the parent type of the
    instance type to which @g_iface belongs, or %NULL if the parent
    type doesn't conform to the interface</doc>
          <type name="TypeInterface" c:type="gpointer" gs:managed-name="TypeInterface" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="g_iface" transfer-ownership="none" gs:managed-name="gIface" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5697">a #GTypeInterface structure</doc>
            <type name="TypeInterface" c:type="gpointer" gs:managed-name="TypeInterface" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <function name="add_prerequisite" c:identifier="g_type_interface_add_prerequisite" gs:dll-name="gobject-2.0" gs:managed-name="AddPrerequisite">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="5653">Adds @prerequisite_type to the list of prerequisites of @interface_type.
This means that any type implementing @interface_type must also implement
@prerequisite_type. Prerequisites can be thought of as an alternative to
interface derivation (which GType doesn't support). An interface can have
at most one instantiatable prerequisite type.</doc>
        <source-position filename="gtype.h" line="1298" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <parameter name="interface_type" transfer-ownership="none" gs:managed-name="interfaceType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5655">#GType value of an interface type</doc>
            <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
          </parameter>
          <parameter name="prerequisite_type" transfer-ownership="none" gs:managed-name="prerequisiteType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5656">#GType value of an interface or instantiatable type</doc>
            <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="interface_type" transfer-ownership="none" gs:managed-name="interfaceType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5655">#GType value of an interface type</doc>
            <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
          </parameter>
          <parameter name="prerequisite_type" transfer-ownership="none" gs:managed-name="prerequisiteType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5656">#GType value of an interface or instantiatable type</doc>
            <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="get_plugin" c:identifier="g_type_interface_get_plugin" gs:dll-name="gobject-2.0" gs:managed-name="GetPlugin">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="5666">Returns the #GTypePlugin structure for the dynamic interface
@interface_type which has been added to @instance_type, or %NULL
if @interface_type has not been added to @instance_type or does
not have a #GTypePlugin structure. See g_type_add_interface_dynamic().</doc>
        <source-position filename="gtype.h" line="2226" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="5676">the #GTypePlugin for the dynamic
    interface @interface_type of @instance_type</doc>
          <type name="TypePlugin" c:type="GTypePlugin*" gs:managed-name="TypePlugin" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="instance_type" transfer-ownership="none" gs:managed-name="instanceType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5668">#GType of an instantiatable type</doc>
            <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
          </parameter>
          <parameter name="interface_type" transfer-ownership="none" gs:managed-name="interfaceType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5669">#GType of an interface type</doc>
            <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="instance_type" transfer-ownership="none" gs:managed-name="instanceType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5668">#GType of an instantiatable type</doc>
            <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
          </parameter>
          <parameter name="interface_type" transfer-ownership="none" gs:managed-name="interfaceType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5669">#GType of an interface type</doc>
            <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="peek" c:identifier="g_type_interface_peek" gs:dll-name="gobject-2.0" gs:managed-name="Peek">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="5681">Returns the #GTypeInterface structure of an interface to which the
passed in class conforms.</doc>
        <source-position filename="gtype.h" line="723" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="5689">the #GTypeInterface
    structure of @iface_type if implemented by @instance_class, %NULL
    otherwise</doc>
          <type name="TypeInterface" c:type="gpointer" gs:managed-name="TypeInterface" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <parameter name="instance_class" transfer-ownership="none" gs:managed-name="instanceClass" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5683">a #GTypeClass structure</doc>
            <type name="TypeClass" c:type="gpointer" gs:managed-name="TypeClass" gs:is-pointer="1" />
          </parameter>
          <parameter name="iface_type" transfer-ownership="none" gs:managed-name="ifaceType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5684">an interface ID which this class conforms to</doc>
            <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="instance_class" transfer-ownership="none" gs:managed-name="instanceClass" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5683">a #GTypeClass structure</doc>
            <type name="TypeClass" c:type="gpointer" gs:managed-name="TypeClass" gs:is-pointer="1" />
          </parameter>
          <parameter name="iface_type" transfer-ownership="none" gs:managed-name="ifaceType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5684">an interface ID which this class conforms to</doc>
            <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="prerequisites" c:identifier="g_type_interface_prerequisites" version="2.2" gs:dll-name="gobject-2.0" gs:managed-name="Prerequisites">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="5711">Returns the prerequisites of an interfaces type.</doc>
        <source-position filename="gtype.h" line="1301" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="5720">a
    newly-allocated zero-terminated array of #GType containing
    the prerequisites of @interface_type</doc>
          <array length="1" zero-terminated="0" c:type="GType*" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
            <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
          </array>
        </return-value>
        <parameters>
          <parameter name="interface_type" transfer-ownership="none" gs:managed-name="interfaceType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5713">an interface type</doc>
            <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
          </parameter>
          <parameter name="n_prerequisites" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1" gs:managed-name="nPrerequisites">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5714">location to return the number
    of prerequisites, or %NULL</doc>
            <type name="guint" c:type="guint*" gs:managed-name="System.UInt32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="interface_type" transfer-ownership="none" gs:managed-name="interfaceType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5713">an interface type</doc>
            <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
          </parameter>
        </gs:managed-parameters>
      </function>
    </record>
    <interface name="TypePlugin" c:symbol-prefix="type_plugin" c:type="GTypePlugin" glib:type-name="GTypePlugin" glib:get-type="g_type_plugin_get_type" gs:managed-name="ITypePlugin">
      <doc xml:space="preserve" filename="gobject-2.0.c" line="514">The GObject type system supports dynamic loading of types.
The #GTypePlugin interface is used to handle the lifecycle
of dynamically loaded types. It goes as follows:

1. The type is initially introduced (usually upon loading the module
   the first time, or by your main application that knows what modules
   introduces what types), like this:
   |[&lt;!-- language="C" --&gt;
   new_type_id = g_type_register_dynamic (parent_type_id,
                                          "TypeName",
                                          new_type_plugin,
                                          type_flags);
   ]|
   where @new_type_plugin is an implementation of the
   #GTypePlugin interface.

2. The type's implementation is referenced, e.g. through
   g_type_class_ref() or through g_type_create_instance() (this is
   being called by g_object_new()) or through one of the above done on
   a type derived from @new_type_id.

3. This causes the type system to load the type's implementation by
   calling g_type_plugin_use() and g_type_plugin_complete_type_info()
   on @new_type_plugin.

4. At some point the type's implementation isn't required anymore,
   e.g. after g_type_class_unref() or g_type_free_instance() (called
   when the reference count of an instance drops to zero).

5. This causes the type system to throw away the information retrieved
   from g_type_plugin_complete_type_info() and then it calls
   g_type_plugin_unuse() on @new_type_plugin.

6. Things may repeat from the second step.

So basically, you need to implement a #GTypePlugin type that
carries a use_count, once use_count goes from zero to one, you need
to load the implementation to successfully handle the upcoming
g_type_plugin_complete_type_info() call. Later, maybe after
succeeding use/unuse calls, once use_count drops to zero, you can
unload the implementation again. The type system makes sure to call
g_type_plugin_use() and g_type_plugin_complete_type_info() again
when the type is needed again.

#GTypeModule is an implementation of #GTypePlugin that already
implements most of this except for the actual module loading and
unloading. It even handles multiple registered types per module.</doc>
      <method name="complete_interface_info" c:identifier="g_type_plugin_complete_interface_info" gs:dll-name="gobject-2.0" gs:managed-name="CompleteInterfaceInfo" gs:extension-method="1">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="5927">Calls the @complete_interface_info function from the
#GTypePluginClass of @plugin. There should be no need to use this
function outside of the GObject type system itself.</doc>
        <source-position filename="gtypeplugin.h" line="127" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none" gs:managed-name="plugin" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5929">the #GTypePlugin</doc>
            <type name="TypePlugin" c:type="GTypePlugin*" gs:managed-name="TypePlugin" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="instance_type" transfer-ownership="none" gs:managed-name="instanceType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5930">the #GType of an instantiable type to which the interface
 is added</doc>
            <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
          </parameter>
          <parameter name="interface_type" transfer-ownership="none" gs:managed-name="interfaceType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5932">the #GType of the interface whose info is completed</doc>
            <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
          </parameter>
          <parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5933">the #GInterfaceInfo to fill in</doc>
            <type name="InterfaceInfo" c:type="GInterfaceInfo*" gs:managed-name="InterfaceInfo" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="plugin" transfer-ownership="none" gs:managed-name="plugin" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5929">the #GTypePlugin</doc>
            <type name="TypePlugin" c:type="GTypePlugin*" gs:managed-name="TypePlugin" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="instance_type" transfer-ownership="none" gs:managed-name="instanceType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5930">the #GType of an instantiable type to which the interface
 is added</doc>
            <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
          </parameter>
          <parameter name="interface_type" transfer-ownership="none" gs:managed-name="interfaceType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5932">the #GType of the interface whose info is completed</doc>
            <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
          </parameter>
          <parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5933">the #GInterfaceInfo to fill in</doc>
            <type name="InterfaceInfo" c:type="GInterfaceInfo*" gs:managed-name="InterfaceInfo" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="complete_type_info" c:identifier="g_type_plugin_complete_type_info" gs:dll-name="gobject-2.0" gs:managed-name="CompleteTypeInfo" gs:extension-method="1">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="5941">Calls the @complete_type_info function from the #GTypePluginClass of @plugin.
There should be no need to use this function outside of the GObject
type system itself.</doc>
        <source-position filename="gtypeplugin.h" line="122" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none" gs:managed-name="plugin" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5943">a #GTypePlugin</doc>
            <type name="TypePlugin" c:type="GTypePlugin*" gs:managed-name="TypePlugin" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="g_type" transfer-ownership="none" gs:managed-name="gType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5944">the #GType whose info is completed</doc>
            <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
          </parameter>
          <parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5945">the #GTypeInfo struct to fill in</doc>
            <type name="TypeInfo" c:type="GTypeInfo*" gs:managed-name="TypeInfo" gs:is-pointer="1" />
          </parameter>
          <parameter name="value_table" transfer-ownership="none" gs:managed-name="valueTable" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5946">the #GTypeValueTable to fill in</doc>
            <type name="TypeValueTable" c:type="GTypeValueTable*" gs:managed-name="TypeValueTable" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="plugin" transfer-ownership="none" gs:managed-name="plugin" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5943">a #GTypePlugin</doc>
            <type name="TypePlugin" c:type="GTypePlugin*" gs:managed-name="TypePlugin" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="g_type" transfer-ownership="none" gs:managed-name="gType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5944">the #GType whose info is completed</doc>
            <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
          </parameter>
          <parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5945">the #GTypeInfo struct to fill in</doc>
            <type name="TypeInfo" c:type="GTypeInfo*" gs:managed-name="TypeInfo" gs:is-pointer="1" />
          </parameter>
          <parameter name="value_table" transfer-ownership="none" gs:managed-name="valueTable" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5946">the #GTypeValueTable to fill in</doc>
            <type name="TypeValueTable" c:type="GTypeValueTable*" gs:managed-name="TypeValueTable" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="unuse" c:identifier="g_type_plugin_unuse" gs:dll-name="gobject-2.0" gs:managed-name="Unuse" gs:extension-method="1">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="5954">Calls the @unuse_plugin function from the #GTypePluginClass of
@plugin.  There should be no need to use this function outside of
the GObject type system itself.</doc>
        <source-position filename="gtypeplugin.h" line="120" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none" gs:managed-name="plugin" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5956">a #GTypePlugin</doc>
            <type name="TypePlugin" c:type="GTypePlugin*" gs:managed-name="TypePlugin" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="plugin" transfer-ownership="none" gs:managed-name="plugin" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5956">a #GTypePlugin</doc>
            <type name="TypePlugin" c:type="GTypePlugin*" gs:managed-name="TypePlugin" gs:is-pointer="1" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <method name="use" c:identifier="g_type_plugin_use" gs:dll-name="gobject-2.0" gs:managed-name="Use" gs:extension-method="1">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="5964">Calls the @use_plugin function from the #GTypePluginClass of
@plugin.  There should be no need to use this function outside of
the GObject type system itself.</doc>
        <source-position filename="gtypeplugin.h" line="118" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="plugin" transfer-ownership="none" gs:managed-name="plugin" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5966">a #GTypePlugin</doc>
            <type name="TypePlugin" c:type="GTypePlugin*" gs:managed-name="TypePlugin" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters>
          <instance-parameter name="plugin" transfer-ownership="none" gs:managed-name="plugin" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="5966">a #GTypePlugin</doc>
            <type name="TypePlugin" c:type="GTypePlugin*" gs:managed-name="TypePlugin" gs:is-pointer="1" />
          </instance-parameter>
        </gs:managed-parameters>
      </method>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_type_plugin_get_type" gs:access-modifiers="private" gs:dll-name="gobject-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </interface>
    <record name="TypePluginClass" c:type="GTypePluginClass" gs:managed-name="TypePluginClass">
      <doc xml:space="preserve" filename="gtypeplugin.h" line="87">The #GTypePlugin interface is used by the type system in order to handle
the lifecycle of dynamically loaded types.</doc>
      <source-position filename="gtypeplugin.h" line="111" />
      <field name="base_iface" readable="0" private="1" gs:managed-name="BaseIface">
        <type name="TypeInterface" c:type="GTypeInterface" gs:managed-name="TypeInterface" />
      </field>
      <field name="use_plugin" writable="1" gs:managed-name="UsePlugin">
        <doc xml:space="preserve" filename="gtypeplugin.h" line="89">Increases the use count of the plugin.</doc>
        <type name="TypePluginUse" c:type="GTypePluginUse" gs:managed-name="TypePluginUse" />
      </field>
      <field name="unuse_plugin" writable="1" gs:managed-name="UnusePlugin">
        <doc xml:space="preserve" filename="gtypeplugin.h" line="90">Decreases the use count of the plugin.</doc>
        <type name="TypePluginUnuse" c:type="GTypePluginUnuse" gs:managed-name="TypePluginUnuse" />
      </field>
      <field name="complete_type_info" writable="1" gs:managed-name="CompleteTypeInfo">
        <doc xml:space="preserve" filename="gtypeplugin.h" line="91">Fills in the #GTypeInfo and
 #GTypeValueTable structs for the type. The structs are initialized
 with `memset(s, 0, sizeof (s))` before calling this function.</doc>
        <type name="TypePluginCompleteTypeInfo" c:type="GTypePluginCompleteTypeInfo" gs:managed-name="TypePluginCompleteTypeInfo" />
      </field>
      <field name="complete_interface_info" writable="1" gs:managed-name="CompleteInterfaceInfo">
        <doc xml:space="preserve" filename="gtypeplugin.h" line="94">Fills in missing parts of the #GInterfaceInfo
 for the interface. The structs is initialized with
 `memset(s, 0, sizeof (s))` before calling this function.</doc>
        <type name="TypePluginCompleteInterfaceInfo" c:type="GTypePluginCompleteInterfaceInfo" gs:managed-name="TypePluginCompleteInterfaceInfo" />
      </field>
    </record>
    <callback name="TypePluginCompleteInterfaceInfo" c:type="GTypePluginCompleteInterfaceInfo" gs:dll-name="gobject-2.0" gs:managed-name="TypePluginCompleteInterfaceInfo" gs:pinvoke-only="1">
      <doc xml:space="preserve" filename="gtypeplugin.h" line="67">The type of the @complete_interface_info function of #GTypePluginClass.</doc>
      <source-position filename="gtypeplugin.h" line="77" />
      <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
        <type name="none" c:type="void" gs:managed-name="System.Void" />
      </return-value>
      <parameters>
        <parameter name="plugin" transfer-ownership="none" gs:managed-name="plugin" direction="in">
          <doc xml:space="preserve" filename="gtypeplugin.h" line="69">the #GTypePlugin</doc>
          <type name="TypePlugin" c:type="GTypePlugin*" gs:managed-name="TypePlugin" gs:is-pointer="1" />
        </parameter>
        <parameter name="instance_type" transfer-ownership="none" gs:managed-name="instanceType" direction="in">
          <doc xml:space="preserve" filename="gtypeplugin.h" line="70">the #GType of an instantiable type to which the interface
 is added</doc>
          <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
        </parameter>
        <parameter name="interface_type" transfer-ownership="none" gs:managed-name="interfaceType" direction="in">
          <doc xml:space="preserve" filename="gtypeplugin.h" line="72">the #GType of the interface whose info is completed</doc>
          <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
        </parameter>
        <parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
          <doc xml:space="preserve" filename="gtypeplugin.h" line="73">the #GInterfaceInfo to fill in</doc>
          <type name="InterfaceInfo" c:type="GInterfaceInfo*" gs:managed-name="InterfaceInfo" gs:is-pointer="1" />
        </parameter>
      </parameters>
      <gs:managed-parameters>
        <parameter name="plugin" transfer-ownership="none" gs:managed-name="plugin" direction="in">
          <doc xml:space="preserve" filename="gtypeplugin.h" line="69">the #GTypePlugin</doc>
          <type name="TypePlugin" c:type="GTypePlugin*" gs:managed-name="TypePlugin" gs:is-pointer="1" />
        </parameter>
        <parameter name="instance_type" transfer-ownership="none" gs:managed-name="instanceType" direction="in">
          <doc xml:space="preserve" filename="gtypeplugin.h" line="70">the #GType of an instantiable type to which the interface
 is added</doc>
          <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
        </parameter>
        <parameter name="interface_type" transfer-ownership="none" gs:managed-name="interfaceType" direction="in">
          <doc xml:space="preserve" filename="gtypeplugin.h" line="72">the #GType of the interface whose info is completed</doc>
          <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
        </parameter>
        <parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
          <doc xml:space="preserve" filename="gtypeplugin.h" line="73">the #GInterfaceInfo to fill in</doc>
          <type name="InterfaceInfo" c:type="GInterfaceInfo*" gs:managed-name="InterfaceInfo" gs:is-pointer="1" />
        </parameter>
      </gs:managed-parameters>
    </callback>
    <callback name="TypePluginCompleteTypeInfo" c:type="GTypePluginCompleteTypeInfo" gs:dll-name="gobject-2.0" gs:managed-name="TypePluginCompleteTypeInfo" gs:pinvoke-only="1">
      <doc xml:space="preserve" filename="gtypeplugin.h" line="54">The type of the @complete_type_info function of #GTypePluginClass.</doc>
      <source-position filename="gtypeplugin.h" line="63" />
      <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
        <type name="none" c:type="void" gs:managed-name="System.Void" />
      </return-value>
      <parameters>
        <parameter name="plugin" transfer-ownership="none" gs:managed-name="plugin" direction="in">
          <doc xml:space="preserve" filename="gtypeplugin.h" line="56">the #GTypePlugin</doc>
          <type name="TypePlugin" c:type="GTypePlugin*" gs:managed-name="TypePlugin" gs:is-pointer="1" />
        </parameter>
        <parameter name="g_type" transfer-ownership="none" gs:managed-name="gType" direction="in">
          <doc xml:space="preserve" filename="gtypeplugin.h" line="57">the #GType whose info is completed</doc>
          <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
        </parameter>
        <parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
          <doc xml:space="preserve" filename="gtypeplugin.h" line="58">the #GTypeInfo struct to fill in</doc>
          <type name="TypeInfo" c:type="GTypeInfo*" gs:managed-name="TypeInfo" gs:is-pointer="1" />
        </parameter>
        <parameter name="value_table" transfer-ownership="none" gs:managed-name="valueTable" direction="in">
          <doc xml:space="preserve" filename="gtypeplugin.h" line="59">the #GTypeValueTable to fill in</doc>
          <type name="TypeValueTable" c:type="GTypeValueTable*" gs:managed-name="TypeValueTable" gs:is-pointer="1" />
        </parameter>
      </parameters>
      <gs:managed-parameters>
        <parameter name="plugin" transfer-ownership="none" gs:managed-name="plugin" direction="in">
          <doc xml:space="preserve" filename="gtypeplugin.h" line="56">the #GTypePlugin</doc>
          <type name="TypePlugin" c:type="GTypePlugin*" gs:managed-name="TypePlugin" gs:is-pointer="1" />
        </parameter>
        <parameter name="g_type" transfer-ownership="none" gs:managed-name="gType" direction="in">
          <doc xml:space="preserve" filename="gtypeplugin.h" line="57">the #GType whose info is completed</doc>
          <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
        </parameter>
        <parameter name="info" transfer-ownership="none" gs:managed-name="info" direction="in">
          <doc xml:space="preserve" filename="gtypeplugin.h" line="58">the #GTypeInfo struct to fill in</doc>
          <type name="TypeInfo" c:type="GTypeInfo*" gs:managed-name="TypeInfo" gs:is-pointer="1" />
        </parameter>
        <parameter name="value_table" transfer-ownership="none" gs:managed-name="valueTable" direction="in">
          <doc xml:space="preserve" filename="gtypeplugin.h" line="59">the #GTypeValueTable to fill in</doc>
          <type name="TypeValueTable" c:type="GTypeValueTable*" gs:managed-name="TypeValueTable" gs:is-pointer="1" />
        </parameter>
      </gs:managed-parameters>
    </callback>
    <callback name="TypePluginUnuse" c:type="GTypePluginUnuse" gs:dll-name="gobject-2.0" gs:managed-name="TypePluginUnuse" gs:pinvoke-only="1">
      <doc xml:space="preserve" filename="gtypeplugin.h" line="47">The type of the @unuse_plugin function of #GTypePluginClass.</doc>
      <source-position filename="gtypeplugin.h" line="53" />
      <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
        <type name="none" c:type="void" gs:managed-name="System.Void" />
      </return-value>
      <parameters>
        <parameter name="plugin" transfer-ownership="none" gs:managed-name="plugin" direction="in">
          <doc xml:space="preserve" filename="gtypeplugin.h" line="49">the #GTypePlugin whose use count should be decreased</doc>
          <type name="TypePlugin" c:type="GTypePlugin*" gs:managed-name="TypePlugin" gs:is-pointer="1" />
        </parameter>
      </parameters>
      <gs:managed-parameters>
        <parameter name="plugin" transfer-ownership="none" gs:managed-name="plugin" direction="in">
          <doc xml:space="preserve" filename="gtypeplugin.h" line="49">the #GTypePlugin whose use count should be decreased</doc>
          <type name="TypePlugin" c:type="GTypePlugin*" gs:managed-name="TypePlugin" gs:is-pointer="1" />
        </parameter>
      </gs:managed-parameters>
    </callback>
    <callback name="TypePluginUse" c:type="GTypePluginUse" gs:dll-name="gobject-2.0" gs:managed-name="TypePluginUse" gs:pinvoke-only="1">
      <doc xml:space="preserve" filename="gtypeplugin.h" line="39">The type of the @use_plugin function of #GTypePluginClass, which gets called
to increase the use count of @plugin.</doc>
      <source-position filename="gtypeplugin.h" line="46" />
      <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
        <type name="none" c:type="void" gs:managed-name="System.Void" />
      </return-value>
      <parameters>
        <parameter name="plugin" transfer-ownership="none" gs:managed-name="plugin" direction="in">
          <doc xml:space="preserve" filename="gtypeplugin.h" line="41">the #GTypePlugin whose use count should be increased</doc>
          <type name="TypePlugin" c:type="GTypePlugin*" gs:managed-name="TypePlugin" gs:is-pointer="1" />
        </parameter>
      </parameters>
      <gs:managed-parameters>
        <parameter name="plugin" transfer-ownership="none" gs:managed-name="plugin" direction="in">
          <doc xml:space="preserve" filename="gtypeplugin.h" line="41">the #GTypePlugin whose use count should be increased</doc>
          <type name="TypePlugin" c:type="GTypePlugin*" gs:managed-name="TypePlugin" gs:is-pointer="1" />
        </parameter>
      </gs:managed-parameters>
    </callback>
    <record name="TypeValueTable" c:type="GTypeValueTable" gs:managed-name="TypeValueTable">
      <doc xml:space="preserve" filename="gtype.h" line="1091">The #GTypeValueTable provides the functions required by the #GValue
implementation, to serve as a container for values of a type.</doc>
      <source-position filename="gtype.h" line="1263" />
      <field name="value_init" gs:managed-name="ValueInit">
        <type name="value_init" gs:dll-name="gobject-2.0" gs:managed-name="ValueInit" />
        <callback name="value_init" gs:dll-name="gobject-2.0" gs:managed-name="ValueInit">
          <source-position filename="gtype.h" line="1247" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" gs:managed-name="System.Void" />
          </return-value>
          <parameters>
            <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
              <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
              <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="value_free" gs:managed-name="ValueFree">
        <type name="value_free" gs:dll-name="gobject-2.0" gs:managed-name="ValueFree" />
        <callback name="value_free" gs:dll-name="gobject-2.0" gs:managed-name="ValueFree">
          <source-position filename="gtype.h" line="1248" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" gs:managed-name="System.Void" />
          </return-value>
          <parameters>
            <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
              <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
              <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="value_copy" gs:managed-name="ValueCopy">
        <type name="value_copy" gs:dll-name="gobject-2.0" gs:managed-name="ValueCopy" />
        <callback name="value_copy" gs:dll-name="gobject-2.0" gs:managed-name="ValueCopy">
          <source-position filename="gtype.h" line="1249" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="none" c:type="void" gs:managed-name="System.Void" />
          </return-value>
          <parameters>
            <parameter name="src_value" transfer-ownership="none" gs:managed-name="srcValue" direction="in">
              <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
            </parameter>
            <parameter name="dest_value" transfer-ownership="none" gs:managed-name="destValue" direction="in">
              <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="src_value" transfer-ownership="none" gs:managed-name="srcValue" direction="in">
              <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
            </parameter>
            <parameter name="dest_value" transfer-ownership="none" gs:managed-name="destValue" direction="in">
              <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="value_peek_pointer" gs:managed-name="ValuePeekPointer">
        <type name="value_peek_pointer" gs:dll-name="gobject-2.0" gs:managed-name="ValuePeekPointer" />
        <callback name="value_peek_pointer" gs:dll-name="gobject-2.0" gs:managed-name="ValuePeekPointer">
          <source-position filename="gtype.h" line="1252" />
          <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
              <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
              <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="collect_format" writable="1" gs:managed-name="CollectFormat">
        <doc xml:space="preserve" filename="gtype.h" line="1128">A string format describing how to collect the contents of
 this value bit-by-bit. Each character in the format represents
 an argument to be collected, and the characters themselves indicate
 the type of the argument. Currently supported arguments are:
 - 'i' - Integers. passed as collect_values[].v_int.
 - 'l' - Longs. passed as collect_values[].v_long.
 - 'd' - Doubles. passed as collect_values[].v_double.
 - 'p' - Pointers. passed as collect_values[].v_pointer.
 It should be noted that for variable argument list construction,
 ANSI C promotes every type smaller than an integer to an int, and
 floats to doubles. So for collection of short int or char, 'i'
 needs to be used, and for collection of floats 'd'.</doc>
        <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
      </field>
      <field name="collect_value" gs:managed-name="CollectValue">
        <type name="collect_value" gs:dll-name="gobject-2.0" gs:managed-name="CollectValue" />
        <callback name="collect_value" gs:dll-name="gobject-2.0" gs:managed-name="CollectValue">
          <source-position filename="gtype.h" line="1254" />
          <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
            <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
              <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
            </parameter>
            <parameter name="n_collect_values" transfer-ownership="none" gs:managed-name="nCollectValues" direction="in">
              <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
            </parameter>
            <parameter name="collect_values" transfer-ownership="none" gs:managed-name="collectValues" direction="in">
              <type name="TypeCValue" c:type="GTypeCValue*" gs:managed-name="TypeCValue" gs:is-pointer="1" />
            </parameter>
            <parameter name="collect_flags" transfer-ownership="none" gs:managed-name="collectFlags" direction="in">
              <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
              <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
            </parameter>
            <parameter name="n_collect_values" transfer-ownership="none" gs:managed-name="nCollectValues" direction="in">
              <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
            </parameter>
            <parameter name="collect_values" transfer-ownership="none" gs:managed-name="collectValues" direction="in">
              <type name="TypeCValue" c:type="GTypeCValue*" gs:managed-name="TypeCValue" gs:is-pointer="1" />
            </parameter>
            <parameter name="collect_flags" transfer-ownership="none" gs:managed-name="collectFlags" direction="in">
              <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
      <field name="lcopy_format" writable="1" gs:managed-name="LcopyFormat">
        <doc xml:space="preserve" filename="gtype.h" line="1204">Format description of the arguments to collect for @lcopy_value,
 analogous to @collect_format. Usually, @lcopy_format string consists
 only of 'p's to provide lcopy_value() with pointers to storage locations.</doc>
        <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
      </field>
      <field name="lcopy_value" gs:managed-name="LcopyValue">
        <type name="lcopy_value" gs:dll-name="gobject-2.0" gs:managed-name="LcopyValue" />
        <callback name="lcopy_value" gs:dll-name="gobject-2.0" gs:managed-name="LcopyValue">
          <source-position filename="gtype.h" line="1259" />
          <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
            <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </return-value>
          <parameters>
            <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
              <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
            </parameter>
            <parameter name="n_collect_values" transfer-ownership="none" gs:managed-name="nCollectValues" direction="in">
              <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
            </parameter>
            <parameter name="collect_values" transfer-ownership="none" gs:managed-name="collectValues" direction="in">
              <type name="TypeCValue" c:type="GTypeCValue*" gs:managed-name="TypeCValue" gs:is-pointer="1" />
            </parameter>
            <parameter name="collect_flags" transfer-ownership="none" gs:managed-name="collectFlags" direction="in">
              <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
            </parameter>
          </parameters>
          <gs:managed-parameters>
            <parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
              <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
            </parameter>
            <parameter name="n_collect_values" transfer-ownership="none" gs:managed-name="nCollectValues" direction="in">
              <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
            </parameter>
            <parameter name="collect_values" transfer-ownership="none" gs:managed-name="collectValues" direction="in">
              <type name="TypeCValue" c:type="GTypeCValue*" gs:managed-name="TypeCValue" gs:is-pointer="1" />
            </parameter>
            <parameter name="collect_flags" transfer-ownership="none" gs:managed-name="collectFlags" direction="in">
              <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
            </parameter>
          </gs:managed-parameters>
        </callback>
      </field>
    </record>
    <record name="Value" c:type="GValue" glib:type-name="GValue" glib:get-type="g_value_get_type" c:symbol-prefix="value" gs:managed-name="Value">
      <doc xml:space="preserve" filename="gvalue.h" line="96">An opaque structure used to hold different types of values.
The data within the structure has protected scope: it is accessible only
to functions within a #GTypeValueTable structure, or implementations of
the g_value_*() API. That is, code portions which implement new fundamental
types.
#GValue users cannot make any assumptions about how data is stored
within the 2 element @data union, and the @g_type member should
only be accessed through the G_VALUE_TYPE() macro.</doc>
      <source-position filename="gvalue.h" line="125" />
      <field name="g_type" readable="0" private="1" gs:managed-name="GType">
        <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
      </field>
      <field name="data" writable="1" gs:managed-name="Data">
        <array zero-terminated="0" fixed-size="2" gs:managed-name="GISharp.Runtime.CArray" gs:is-pointer="1">
          <type name="_Value__data__union" gs:managed-name="ValueDataUnion" />
        </array>
      </field>
      <method name="copy" c:identifier="g_value_copy" gs:dll-name="gobject-2.0" gs:managed-name="Copy">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6254">Copies the value of @src_value into @dest_value.</doc>
        <source-position filename="gvalue.h" line="133" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="src_value" transfer-ownership="none" gs:managed-name="srcValue" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6256">An initialized #GValue structure.</doc>
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="dest_value" transfer-ownership="none" gs:managed-name="destValue" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6257">An initialized #GValue structure of the same type as @src_value.</doc>
            <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="dest_value" transfer-ownership="none" gs:managed-name="destValue" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6257">An initialized #GValue structure of the same type as @src_value.</doc>
            <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="dup_object" c:identifier="g_value_dup_object" gs:dll-name="gobject-2.0" gs:managed-name="DupObject">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6276">Get the contents of a %G_TYPE_OBJECT derived #GValue, increasing
its reference count. If the contents of the #GValue are %NULL, then
%NULL will be returned.</doc>
        <source-position filename="gobject.h" line="624" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6284">object content of @value,
         should be unreferenced when no longer needed.</doc>
          <type name="Object" c:type="gpointer" gs:managed-name="Object" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6278">a valid #GValue whose type is derived from %G_TYPE_OBJECT</doc>
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="dup_string" c:identifier="g_value_dup_string" gs:dll-name="gobject-2.0" gs:managed-name="DupString">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6301">Get a copy the contents of a %G_TYPE_STRING #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="263" />
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6307">a newly allocated copy of the string content of @value</doc>
          <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6303">a valid #GValue of type %G_TYPE_STRING</doc>
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="dup_variant" c:identifier="g_value_dup_variant" version="2.26" gs:dll-name="gobject-2.0" gs:managed-name="DupVariant">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6311">Get the contents of a variant #GValue, increasing its refcount. The returned
#GVariant is never floating.</doc>
        <source-position filename="gvaluetypes.h" line="285" />
        <return-value transfer-ownership="full" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6318">variant contents of @value (may be %NULL);
   should be unreffed using g_variant_unref() when no longer needed</doc>
          <type name="GLib.Variant" c:type="GVariant*" gs:managed-name="GISharp.Lib.GLib.Variant" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6313">a valid #GValue of type %G_TYPE_VARIANT</doc>
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="fits_pointer" c:identifier="g_value_fits_pointer" gs:dll-name="gobject-2.0" gs:managed-name="FitsPointer">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6324">Determines if @value will fit inside the size of a pointer value.
This is an internal function introduced mainly for C marshallers.</doc>
        <source-position filename="gvalue.h" line="149" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6331">%TRUE if @value will fit inside a pointer value.</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6326">An initialized #GValue structure.</doc>
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_boolean" gs:dll-name="gobject-2.0" gs:managed-name="Boolean">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6335">Get the contents of a %G_TYPE_BOOLEAN #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="210" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6341">boolean contents of @value</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6337">a valid #GValue of type %G_TYPE_BOOLEAN</doc>
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_boolean" c:identifier="g_value_get_boolean" gs:dll-name="gobject-2.0" gs:managed-name="GetBoolean" gs:property-getter-for="Boolean" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6335">Get the contents of a %G_TYPE_BOOLEAN #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="210" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6341">boolean contents of @value</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6337">a valid #GValue of type %G_TYPE_BOOLEAN</doc>
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_boxed" gs:dll-name="gobject-2.0" gs:managed-name="Boxed">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6345">Get the contents of a %G_TYPE_BOXED derived #GValue.</doc>
        <source-position filename="gboxed.h" line="88" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6351">boxed contents of @value</doc>
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6347">a valid #GValue of %G_TYPE_BOXED derived type</doc>
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_boxed" c:identifier="g_value_get_boxed" gs:dll-name="gobject-2.0" gs:managed-name="GetBoxed" gs:property-getter-for="Boxed" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6345">Get the contents of a %G_TYPE_BOXED derived #GValue.</doc>
        <source-position filename="gboxed.h" line="88" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6351">boxed contents of @value</doc>
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6347">a valid #GValue of %G_TYPE_BOXED derived type</doc>
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_char" deprecated="1" deprecated-version="2.32" gs:dll-name="gobject-2.0" gs:managed-name="Char">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6355">Do not use this function; it is broken on platforms where the %char
type is unsigned, such as ARM and PowerPC.  See g_value_get_schar().

Get the contents of a %G_TYPE_CHAR #GValue.</doc>
        <doc-deprecated xml:space="preserve">This function's return type is broken, see g_value_get_schar()</doc-deprecated>
        <source-position filename="gvaluetypes.h" line="195" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6364">character contents of @value</doc>
          <type name="gchar" c:type="gchar" gs:managed-name="System.SByte" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6357">a valid #GValue of type %G_TYPE_CHAR</doc>
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_char" c:identifier="g_value_get_char" deprecated="1" deprecated-version="2.32" gs:dll-name="gobject-2.0" gs:managed-name="GetChar" gs:property-getter-for="Char" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6355">Do not use this function; it is broken on platforms where the %char
type is unsigned, such as ARM and PowerPC.  See g_value_get_schar().

Get the contents of a %G_TYPE_CHAR #GValue.</doc>
        <doc-deprecated xml:space="preserve">This function's return type is broken, see g_value_get_schar()</doc-deprecated>
        <source-position filename="gvaluetypes.h" line="195" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6364">character contents of @value</doc>
          <type name="gchar" c:type="gchar" gs:managed-name="System.SByte" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6357">a valid #GValue of type %G_TYPE_CHAR</doc>
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_double" gs:dll-name="gobject-2.0" gs:managed-name="Double">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6369">Get the contents of a %G_TYPE_DOUBLE #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="250" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6375">double contents of @value</doc>
          <type name="gdouble" c:type="gdouble" gs:managed-name="System.Double" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6371">a valid #GValue of type %G_TYPE_DOUBLE</doc>
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_double" c:identifier="g_value_get_double" gs:dll-name="gobject-2.0" gs:managed-name="GetDouble" gs:property-getter-for="Double" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6369">Get the contents of a %G_TYPE_DOUBLE #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="250" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6375">double contents of @value</doc>
          <type name="gdouble" c:type="gdouble" gs:managed-name="System.Double" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6371">a valid #GValue of type %G_TYPE_DOUBLE</doc>
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_enum" gs:dll-name="gobject-2.0" gs:managed-name="Enum">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6379">Get the contents of a %G_TYPE_ENUM #GValue.</doc>
        <source-position filename="genums.h" line="246" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6385">enum contents of @value</doc>
          <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6381">a valid #GValue whose type is derived from %G_TYPE_ENUM</doc>
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_enum" c:identifier="g_value_get_enum" gs:dll-name="gobject-2.0" gs:managed-name="GetEnum" gs:property-getter-for="Enum" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6379">Get the contents of a %G_TYPE_ENUM #GValue.</doc>
        <source-position filename="genums.h" line="246" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6385">enum contents of @value</doc>
          <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6381">a valid #GValue whose type is derived from %G_TYPE_ENUM</doc>
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_flags" gs:dll-name="gobject-2.0" gs:managed-name="Flags">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6389">Get the contents of a %G_TYPE_FLAGS #GValue.</doc>
        <source-position filename="genums.h" line="251" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6395">flags contents of @value</doc>
          <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6391">a valid #GValue whose type is derived from %G_TYPE_FLAGS</doc>
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_flags" c:identifier="g_value_get_flags" gs:dll-name="gobject-2.0" gs:managed-name="GetFlags" gs:property-getter-for="Flags" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6389">Get the contents of a %G_TYPE_FLAGS #GValue.</doc>
        <source-position filename="genums.h" line="251" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6395">flags contents of @value</doc>
          <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6391">a valid #GValue whose type is derived from %G_TYPE_FLAGS</doc>
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_float" gs:dll-name="gobject-2.0" gs:managed-name="Float">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6399">Get the contents of a %G_TYPE_FLOAT #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="245" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6405">float contents of @value</doc>
          <type name="gfloat" c:type="gfloat" gs:managed-name="System.Single" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6401">a valid #GValue of type %G_TYPE_FLOAT</doc>
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_float" c:identifier="g_value_get_float" gs:dll-name="gobject-2.0" gs:managed-name="GetFloat" gs:property-getter-for="Float" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6399">Get the contents of a %G_TYPE_FLOAT #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="245" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6405">float contents of @value</doc>
          <type name="gfloat" c:type="gfloat" gs:managed-name="System.Single" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6401">a valid #GValue of type %G_TYPE_FLOAT</doc>
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_gtype" version="2.12" gs:dll-name="gobject-2.0" gs:managed-name="Gtype">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6409">Get the contents of a %G_TYPE_GTYPE #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="275" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6416">the #GType stored in @value</doc>
          <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6411">a valid #GValue of type %G_TYPE_GTYPE</doc>
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_gtype" c:identifier="g_value_get_gtype" version="2.12" gs:dll-name="gobject-2.0" gs:managed-name="GetGtype" gs:property-getter-for="Gtype" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6409">Get the contents of a %G_TYPE_GTYPE #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="275" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6416">the #GType stored in @value</doc>
          <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6411">a valid #GValue of type %G_TYPE_GTYPE</doc>
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_int" gs:dll-name="gobject-2.0" gs:managed-name="Int">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6420">Get the contents of a %G_TYPE_INT #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="215" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6426">integer contents of @value</doc>
          <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6422">a valid #GValue of type %G_TYPE_INT</doc>
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_int" c:identifier="g_value_get_int" gs:dll-name="gobject-2.0" gs:managed-name="GetInt" gs:property-getter-for="Int" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6420">Get the contents of a %G_TYPE_INT #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="215" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6426">integer contents of @value</doc>
          <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6422">a valid #GValue of type %G_TYPE_INT</doc>
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_int64" gs:dll-name="gobject-2.0" gs:managed-name="Int64">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6430">Get the contents of a %G_TYPE_INT64 #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="235" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6436">64bit integer contents of @value</doc>
          <type name="gint64" c:type="gint64" gs:managed-name="System.Int64" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6432">a valid #GValue of type %G_TYPE_INT64</doc>
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_int64" c:identifier="g_value_get_int64" gs:dll-name="gobject-2.0" gs:managed-name="GetInt64" gs:property-getter-for="Int64" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6430">Get the contents of a %G_TYPE_INT64 #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="235" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6436">64bit integer contents of @value</doc>
          <type name="gint64" c:type="gint64" gs:managed-name="System.Int64" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6432">a valid #GValue of type %G_TYPE_INT64</doc>
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_long" gs:dll-name="gobject-2.0" gs:managed-name="Long">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6440">Get the contents of a %G_TYPE_LONG #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="225" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6446">long integer contents of @value</doc>
          <type name="glong" c:type="glong" gs:managed-name="GISharp.Runtime.CLong" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6442">a valid #GValue of type %G_TYPE_LONG</doc>
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_long" c:identifier="g_value_get_long" gs:dll-name="gobject-2.0" gs:managed-name="GetLong" gs:property-getter-for="Long" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6440">Get the contents of a %G_TYPE_LONG #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="225" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6446">long integer contents of @value</doc>
          <type name="glong" c:type="glong" gs:managed-name="GISharp.Runtime.CLong" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6442">a valid #GValue of type %G_TYPE_LONG</doc>
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_object" gs:dll-name="gobject-2.0" gs:managed-name="Object">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6450">Get the contents of a %G_TYPE_OBJECT derived #GValue.</doc>
        <source-position filename="gobject.h" line="622" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6456">object contents of @value</doc>
          <type name="Object" c:type="gpointer" gs:managed-name="Object" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6452">a valid #GValue of %G_TYPE_OBJECT derived type</doc>
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_object" c:identifier="g_value_get_object" gs:dll-name="gobject-2.0" gs:managed-name="GetObject" gs:property-getter-for="Object" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6450">Get the contents of a %G_TYPE_OBJECT derived #GValue.</doc>
        <source-position filename="gobject.h" line="622" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6456">object contents of @value</doc>
          <type name="Object" c:type="gpointer" gs:managed-name="Object" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6452">a valid #GValue of %G_TYPE_OBJECT derived type</doc>
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_param" gs:dll-name="gobject-2.0" gs:managed-name="Param">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6460">Get the contents of a %G_TYPE_PARAM #GValue.</doc>
        <source-position filename="gparam.h" line="333" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6466">#GParamSpec content of @value</doc>
          <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6462">a valid #GValue whose type is derived from %G_TYPE_PARAM</doc>
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_param" c:identifier="g_value_get_param" gs:dll-name="gobject-2.0" gs:managed-name="GetParam" gs:property-getter-for="Param" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6460">Get the contents of a %G_TYPE_PARAM #GValue.</doc>
        <source-position filename="gparam.h" line="333" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6466">#GParamSpec content of @value</doc>
          <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6462">a valid #GValue whose type is derived from %G_TYPE_PARAM</doc>
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_pointer" gs:dll-name="gobject-2.0" gs:managed-name="Pointer">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6470">Get the contents of a pointer #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="268" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6476">pointer contents of @value</doc>
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6472">a valid #GValue of %G_TYPE_POINTER</doc>
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_pointer" c:identifier="g_value_get_pointer" gs:dll-name="gobject-2.0" gs:managed-name="GetPointer" gs:property-getter-for="Pointer" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6470">Get the contents of a pointer #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="268" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6476">pointer contents of @value</doc>
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6472">a valid #GValue of %G_TYPE_POINTER</doc>
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_schar" version="2.32" gs:dll-name="gobject-2.0" gs:managed-name="Schar">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6480">Get the contents of a %G_TYPE_CHAR #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="200" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6486">signed 8 bit integer contents of @value</doc>
          <type name="gint8" c:type="gint8" gs:managed-name="System.SByte" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6482">a valid #GValue of type %G_TYPE_CHAR</doc>
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_schar" c:identifier="g_value_get_schar" version="2.32" gs:dll-name="gobject-2.0" gs:managed-name="GetSchar" gs:property-getter-for="Schar" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6480">Get the contents of a %G_TYPE_CHAR #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="200" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6486">signed 8 bit integer contents of @value</doc>
          <type name="gint8" c:type="gint8" gs:managed-name="System.SByte" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6482">a valid #GValue of type %G_TYPE_CHAR</doc>
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_string" gs:dll-name="gobject-2.0" gs:managed-name="String">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6491">Get the contents of a %G_TYPE_STRING #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="261" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6497">string content of @value</doc>
          <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6493">a valid #GValue of type %G_TYPE_STRING</doc>
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_string" c:identifier="g_value_get_string" gs:dll-name="gobject-2.0" gs:managed-name="GetString" gs:property-getter-for="String" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6491">Get the contents of a %G_TYPE_STRING #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="261" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6497">string content of @value</doc>
          <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6493">a valid #GValue of type %G_TYPE_STRING</doc>
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_uchar" gs:dll-name="gobject-2.0" gs:managed-name="Uchar">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6501">Get the contents of a %G_TYPE_UCHAR #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="205" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6507">unsigned character contents of @value</doc>
          <type name="guint8" c:type="guchar" gs:managed-name="System.Byte" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6503">a valid #GValue of type %G_TYPE_UCHAR</doc>
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_uchar" c:identifier="g_value_get_uchar" gs:dll-name="gobject-2.0" gs:managed-name="GetUchar" gs:property-getter-for="Uchar" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6501">Get the contents of a %G_TYPE_UCHAR #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="205" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6507">unsigned character contents of @value</doc>
          <type name="guint8" c:type="guchar" gs:managed-name="System.Byte" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6503">a valid #GValue of type %G_TYPE_UCHAR</doc>
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_uint" gs:dll-name="gobject-2.0" gs:managed-name="Uint">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6511">Get the contents of a %G_TYPE_UINT #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="220" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6517">unsigned integer contents of @value</doc>
          <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6513">a valid #GValue of type %G_TYPE_UINT</doc>
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_uint" c:identifier="g_value_get_uint" gs:dll-name="gobject-2.0" gs:managed-name="GetUint" gs:property-getter-for="Uint" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6511">Get the contents of a %G_TYPE_UINT #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="220" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6517">unsigned integer contents of @value</doc>
          <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6513">a valid #GValue of type %G_TYPE_UINT</doc>
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_uint64" gs:dll-name="gobject-2.0" gs:managed-name="Uint64">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6521">Get the contents of a %G_TYPE_UINT64 #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="240" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6527">unsigned 64bit integer contents of @value</doc>
          <type name="guint64" c:type="guint64" gs:managed-name="System.UInt64" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6523">a valid #GValue of type %G_TYPE_UINT64</doc>
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_uint64" c:identifier="g_value_get_uint64" gs:dll-name="gobject-2.0" gs:managed-name="GetUint64" gs:property-getter-for="Uint64" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6521">Get the contents of a %G_TYPE_UINT64 #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="240" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6527">unsigned 64bit integer contents of @value</doc>
          <type name="guint64" c:type="guint64" gs:managed-name="System.UInt64" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6523">a valid #GValue of type %G_TYPE_UINT64</doc>
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_ulong" gs:dll-name="gobject-2.0" gs:managed-name="Ulong">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6531">Get the contents of a %G_TYPE_ULONG #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="230" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6537">unsigned long integer contents of @value</doc>
          <type name="gulong" c:type="gulong" gs:managed-name="GISharp.Runtime.CULong" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6533">a valid #GValue of type %G_TYPE_ULONG</doc>
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_ulong" c:identifier="g_value_get_ulong" gs:dll-name="gobject-2.0" gs:managed-name="GetUlong" gs:property-getter-for="Ulong" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6531">Get the contents of a %G_TYPE_ULONG #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="230" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6537">unsigned long integer contents of @value</doc>
          <type name="gulong" c:type="gulong" gs:managed-name="GISharp.Runtime.CULong" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6533">a valid #GValue of type %G_TYPE_ULONG</doc>
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <gs:managed-property name="get_variant" version="2.26" gs:dll-name="gobject-2.0" gs:managed-name="Variant">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6541">Get the contents of a variant #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="283" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6547">variant contents of @value (may be %NULL)</doc>
          <type name="GLib.Variant" c:type="GVariant*" gs:managed-name="GISharp.Lib.GLib.Variant" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6543">a valid #GValue of type %G_TYPE_VARIANT</doc>
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </gs:managed-property>
      <method name="get_variant" c:identifier="g_value_get_variant" version="2.26" gs:dll-name="gobject-2.0" gs:managed-name="GetVariant" gs:property-getter-for="Variant" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6541">Get the contents of a variant #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="283" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6547">variant contents of @value (may be %NULL)</doc>
          <type name="GLib.Variant" c:type="GVariant*" gs:managed-name="GISharp.Lib.GLib.Variant" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6543">a valid #GValue of type %G_TYPE_VARIANT</doc>
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="init" c:identifier="g_value_init" gs:dll-name="gobject-2.0" gs:managed-name="Init">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6552">Initializes @value with the default value of @type.</doc>
        <source-position filename="gvalue.h" line="130" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6559">the #GValue structure that has been passed in</doc>
          <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6554">A zero-filled (uninitialized) #GValue structure.</doc>
            <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="g_type" transfer-ownership="none" gs:managed-name="gType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6555">Type the #GValue should hold values of.</doc>
            <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="g_type" transfer-ownership="none" gs:managed-name="gType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6555">Type the #GValue should hold values of.</doc>
            <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="init_from_instance" c:identifier="g_value_init_from_instance" version="2.42" gs:dll-name="gobject-2.0" gs:managed-name="InitFromInstance">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6563">Initializes and sets @value from an instantiatable type via the
value_table's collect_value() function.

Note: The @value will be initialised with the exact type of
@instance.  If you wish to set the @value's type to a different GType
(such as a parent class GType), you need to manually call
g_value_init() and g_value_set_instance().</doc>
        <source-position filename="gvalue.h" line="143" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6565">An uninitialized #GValue structure.</doc>
            <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="instance" transfer-ownership="none" gs:managed-name="instance" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6566">the instance</doc>
            <type name="TypeInstance" c:type="gpointer" gs:managed-name="TypeInstance" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="instance" transfer-ownership="none" gs:managed-name="instance" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6566">the instance</doc>
            <type name="TypeInstance" c:type="gpointer" gs:managed-name="TypeInstance" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="peek_pointer" c:identifier="g_value_peek_pointer" gs:dll-name="gobject-2.0" gs:managed-name="PeekPointer">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6580">Returns the value contents as pointer. This function asserts that
g_value_fits_pointer() returned %TRUE for the passed in value.
This is an internal function introduced mainly for C marshallers.</doc>
        <source-position filename="gvalue.h" line="151" />
        <return-value transfer-ownership="none" nullable="1" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6588">the value contents as pointer</doc>
          <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6582">An initialized #GValue structure</doc>
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="reset" c:identifier="g_value_reset" gs:dll-name="gobject-2.0" gs:managed-name="Reset">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6605">Clears the current value in @value and resets it to the default value
(as if the value had just been initialized).</doc>
        <source-position filename="gvalue.h" line="136" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="6612">the #GValue structure that has been passed in</doc>
          <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6607">An initialized #GValue structure.</doc>
            <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <method name="set_boolean" c:identifier="g_value_set_boolean" gs:dll-name="gobject-2.0" gs:managed-name="SetBoolean" gs:property-setter-for="Boolean" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6616">Set the contents of a %G_TYPE_BOOLEAN #GValue to @v_boolean.</doc>
        <source-position filename="gvaluetypes.h" line="207" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6618">a valid #GValue of type %G_TYPE_BOOLEAN</doc>
            <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="v_boolean" transfer-ownership="none" gs:managed-name="vBoolean" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6619">boolean value to be set</doc>
            <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="v_boolean" transfer-ownership="none" gs:managed-name="vBoolean" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6619">boolean value to be set</doc>
            <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_boxed" c:identifier="g_value_set_boxed" gs:dll-name="gobject-2.0" gs:managed-name="SetBoxed" gs:property-setter-for="Boxed" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6625">Set the contents of a %G_TYPE_BOXED derived #GValue to @v_boxed.</doc>
        <source-position filename="gboxed.h" line="76" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6627">a valid #GValue of %G_TYPE_BOXED derived type</doc>
            <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="v_boxed" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="vBoxed" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6628">boxed value to be set</doc>
            <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="v_boxed" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="vBoxed" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6628">boxed value to be set</doc>
            <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_boxed_take_ownership" c:identifier="g_value_set_boxed_take_ownership" deprecated="1" deprecated-version="2.4" gs:dll-name="gobject-2.0" gs:managed-name="SetBoxedTakeOwnership">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6634">This is an internal function introduced mainly for C marshallers.</doc>
        <doc-deprecated xml:space="preserve">Use g_value_take_boxed() instead.</doc-deprecated>
        <source-position filename="gboxed.h" line="85" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6636">a valid #GValue of %G_TYPE_BOXED derived type</doc>
            <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="v_boxed" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="vBoxed" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6637">duplicated unowned boxed value to be set</doc>
            <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="v_boxed" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="vBoxed" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6637">duplicated unowned boxed value to be set</doc>
            <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_char" c:identifier="g_value_set_char" deprecated="1" deprecated-version="2.32" gs:dll-name="gobject-2.0" gs:managed-name="SetChar" gs:property-setter-for="Char" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6645">Set the contents of a %G_TYPE_CHAR #GValue to @v_char.</doc>
        <doc-deprecated xml:space="preserve">This function's input type is broken, see g_value_set_schar()</doc-deprecated>
        <source-position filename="gvaluetypes.h" line="192" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6647">a valid #GValue of type %G_TYPE_CHAR</doc>
            <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="v_char" transfer-ownership="none" gs:managed-name="vChar" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6648">character value to be set</doc>
            <type name="gchar" c:type="gchar" gs:managed-name="System.SByte" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="v_char" transfer-ownership="none" gs:managed-name="vChar" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6648">character value to be set</doc>
            <type name="gchar" c:type="gchar" gs:managed-name="System.SByte" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_double" c:identifier="g_value_set_double" gs:dll-name="gobject-2.0" gs:managed-name="SetDouble" gs:property-setter-for="Double" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6656">Set the contents of a %G_TYPE_DOUBLE #GValue to @v_double.</doc>
        <source-position filename="gvaluetypes.h" line="247" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6658">a valid #GValue of type %G_TYPE_DOUBLE</doc>
            <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="v_double" transfer-ownership="none" gs:managed-name="vDouble" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6659">double value to be set</doc>
            <type name="gdouble" c:type="gdouble" gs:managed-name="System.Double" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="v_double" transfer-ownership="none" gs:managed-name="vDouble" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6659">double value to be set</doc>
            <type name="gdouble" c:type="gdouble" gs:managed-name="System.Double" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_enum" c:identifier="g_value_set_enum" gs:dll-name="gobject-2.0" gs:managed-name="SetEnum" gs:property-setter-for="Enum" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6665">Set the contents of a %G_TYPE_ENUM #GValue to @v_enum.</doc>
        <source-position filename="genums.h" line="243" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6667">a valid #GValue whose type is derived from %G_TYPE_ENUM</doc>
            <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="v_enum" transfer-ownership="none" gs:managed-name="vEnum" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6668">enum value to be set</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="v_enum" transfer-ownership="none" gs:managed-name="vEnum" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6668">enum value to be set</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_flags" c:identifier="g_value_set_flags" gs:dll-name="gobject-2.0" gs:managed-name="SetFlags" gs:property-setter-for="Flags" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6674">Set the contents of a %G_TYPE_FLAGS #GValue to @v_flags.</doc>
        <source-position filename="genums.h" line="248" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6676">a valid #GValue whose type is derived from %G_TYPE_FLAGS</doc>
            <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="v_flags" transfer-ownership="none" gs:managed-name="vFlags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6677">flags value to be set</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="v_flags" transfer-ownership="none" gs:managed-name="vFlags" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6677">flags value to be set</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_float" c:identifier="g_value_set_float" gs:dll-name="gobject-2.0" gs:managed-name="SetFloat" gs:property-setter-for="Float" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6683">Set the contents of a %G_TYPE_FLOAT #GValue to @v_float.</doc>
        <source-position filename="gvaluetypes.h" line="242" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6685">a valid #GValue of type %G_TYPE_FLOAT</doc>
            <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="v_float" transfer-ownership="none" gs:managed-name="vFloat" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6686">float value to be set</doc>
            <type name="gfloat" c:type="gfloat" gs:managed-name="System.Single" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="v_float" transfer-ownership="none" gs:managed-name="vFloat" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6686">float value to be set</doc>
            <type name="gfloat" c:type="gfloat" gs:managed-name="System.Single" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_gtype" c:identifier="g_value_set_gtype" version="2.12" gs:dll-name="gobject-2.0" gs:managed-name="SetGtype" gs:property-setter-for="Gtype" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6692">Set the contents of a %G_TYPE_GTYPE #GValue to @v_gtype.</doc>
        <source-position filename="gvaluetypes.h" line="272" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6694">a valid #GValue of type %G_TYPE_GTYPE</doc>
            <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="v_gtype" transfer-ownership="none" gs:managed-name="vGtype" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6695">#GType to be set</doc>
            <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="v_gtype" transfer-ownership="none" gs:managed-name="vGtype" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6695">#GType to be set</doc>
            <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_instance" c:identifier="g_value_set_instance" gs:dll-name="gobject-2.0" gs:managed-name="SetInstance">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6703">Sets @value from an instantiatable type via the
value_table's collect_value() function.</doc>
        <source-position filename="gvalue.h" line="140" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6705">An initialized #GValue structure.</doc>
            <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="instance" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="instance" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6706">the instance</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="instance" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="instance" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6706">the instance</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_int" c:identifier="g_value_set_int" gs:dll-name="gobject-2.0" gs:managed-name="SetInt" gs:property-setter-for="Int" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6713">Set the contents of a %G_TYPE_INT #GValue to @v_int.</doc>
        <source-position filename="gvaluetypes.h" line="212" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6715">a valid #GValue of type %G_TYPE_INT</doc>
            <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="v_int" transfer-ownership="none" gs:managed-name="vInt" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6716">integer value to be set</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="v_int" transfer-ownership="none" gs:managed-name="vInt" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6716">integer value to be set</doc>
            <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_int64" c:identifier="g_value_set_int64" gs:dll-name="gobject-2.0" gs:managed-name="SetInt64" gs:property-setter-for="Int64" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6722">Set the contents of a %G_TYPE_INT64 #GValue to @v_int64.</doc>
        <source-position filename="gvaluetypes.h" line="232" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6724">a valid #GValue of type %G_TYPE_INT64</doc>
            <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="v_int64" transfer-ownership="none" gs:managed-name="vInt64" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6725">64bit integer value to be set</doc>
            <type name="gint64" c:type="gint64" gs:managed-name="System.Int64" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="v_int64" transfer-ownership="none" gs:managed-name="vInt64" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6725">64bit integer value to be set</doc>
            <type name="gint64" c:type="gint64" gs:managed-name="System.Int64" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_interned_string" c:identifier="g_value_set_interned_string" version="2.66" gs:dll-name="gobject-2.0" gs:managed-name="SetInternedString">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6731">Set the contents of a %G_TYPE_STRING #GValue to @v_string.  The string is
assumed to be static and interned (canonical, for example from
g_intern_string()), and is thus not duplicated when setting the #GValue.</doc>
        <source-position filename="gvaluetypes.h" line="258" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6733">a valid #GValue of type %G_TYPE_STRING</doc>
            <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="v_string" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="vString" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6734">static string to be set</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="v_string" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="vString" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6734">static string to be set</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_long" c:identifier="g_value_set_long" gs:dll-name="gobject-2.0" gs:managed-name="SetLong" gs:property-setter-for="Long" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6744">Set the contents of a %G_TYPE_LONG #GValue to @v_long.</doc>
        <source-position filename="gvaluetypes.h" line="222" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6746">a valid #GValue of type %G_TYPE_LONG</doc>
            <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="v_long" transfer-ownership="none" gs:managed-name="vLong" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6747">long integer value to be set</doc>
            <type name="glong" c:type="glong" gs:managed-name="GISharp.Runtime.CLong" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="v_long" transfer-ownership="none" gs:managed-name="vLong" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6747">long integer value to be set</doc>
            <type name="glong" c:type="glong" gs:managed-name="GISharp.Runtime.CLong" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_object" c:identifier="g_value_set_object" gs:dll-name="gobject-2.0" gs:managed-name="SetObject" gs:property-setter-for="Object" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6753">Set the contents of a %G_TYPE_OBJECT derived #GValue to @v_object.

g_value_set_object() increases the reference count of @v_object
(the #GValue holds a reference to @v_object).  If you do not wish
to increase the reference count of the object (i.e. you wish to
pass your current reference to the #GValue because you no longer
need it), use g_value_take_object() instead.

It is important that your #GValue holds a reference to @v_object (either its
own, or one it has taken) to ensure that the object won't be destroyed while
the #GValue still exists).</doc>
        <source-position filename="gobject.h" line="619" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6755">a valid #GValue of %G_TYPE_OBJECT derived type</doc>
            <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="v_object" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="vObject" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6756">object value to be set</doc>
            <type name="Object" c:type="gpointer" gs:managed-name="Object" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="v_object" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="vObject" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6756">object value to be set</doc>
            <type name="Object" c:type="gpointer" gs:managed-name="Object" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_param" c:identifier="g_value_set_param" gs:dll-name="gobject-2.0" gs:managed-name="SetParam" gs:property-setter-for="Param" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6783">Set the contents of a %G_TYPE_PARAM #GValue to @param.</doc>
        <source-position filename="gparam.h" line="330" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6785">a valid #GValue of type %G_TYPE_PARAM</doc>
            <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="param" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="param" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6786">the #GParamSpec to be set</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="param" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="param" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6786">the #GParamSpec to be set</doc>
            <type name="ParamSpec" c:type="GParamSpec*" gs:managed-name="ParamSpec" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_pointer" c:identifier="g_value_set_pointer" gs:dll-name="gobject-2.0" gs:managed-name="SetPointer" gs:property-setter-for="Pointer" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6803">Set the contents of a pointer #GValue to @v_pointer.</doc>
        <source-position filename="gvaluetypes.h" line="265" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6805">a valid #GValue of %G_TYPE_POINTER</doc>
            <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="v_pointer" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="vPointer" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6806">pointer value to be set</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="v_pointer" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="vPointer" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6806">pointer value to be set</doc>
            <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_schar" c:identifier="g_value_set_schar" version="2.32" gs:dll-name="gobject-2.0" gs:managed-name="SetSchar" gs:property-setter-for="Schar" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6812">Set the contents of a %G_TYPE_CHAR #GValue to @v_char.</doc>
        <source-position filename="gvaluetypes.h" line="197" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6814">a valid #GValue of type %G_TYPE_CHAR</doc>
            <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="v_char" transfer-ownership="none" gs:managed-name="vChar" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6815">signed 8 bit integer to be set</doc>
            <type name="gint8" c:type="gint8" gs:managed-name="System.SByte" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="v_char" transfer-ownership="none" gs:managed-name="vChar" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6815">signed 8 bit integer to be set</doc>
            <type name="gint8" c:type="gint8" gs:managed-name="System.SByte" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_static_boxed" c:identifier="g_value_set_static_boxed" gs:dll-name="gobject-2.0" gs:managed-name="SetStaticBoxed">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6823">Set the contents of a %G_TYPE_BOXED derived #GValue to @v_boxed.
The boxed value is assumed to be static, and is thus not duplicated
when setting the #GValue.</doc>
        <source-position filename="gboxed.h" line="79" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6825">a valid #GValue of %G_TYPE_BOXED derived type</doc>
            <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="v_boxed" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="vBoxed" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6826">static boxed value to be set</doc>
            <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="v_boxed" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="vBoxed" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6826">static boxed value to be set</doc>
            <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_static_string" c:identifier="g_value_set_static_string" gs:dll-name="gobject-2.0" gs:managed-name="SetStaticString">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6834">Set the contents of a %G_TYPE_STRING #GValue to @v_string.
The string is assumed to be static, and is thus not duplicated
when setting the #GValue.

If the the string is a canonical string, using g_value_set_interned_string()
is more appropriate.</doc>
        <source-position filename="gvaluetypes.h" line="255" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6836">a valid #GValue of type %G_TYPE_STRING</doc>
            <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="v_string" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="vString" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6837">static string to be set</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="v_string" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="vString" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6837">static string to be set</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_string" c:identifier="g_value_set_string" gs:dll-name="gobject-2.0" gs:managed-name="SetString" gs:property-setter-for="String" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6848">Set the contents of a %G_TYPE_STRING #GValue to @v_string.</doc>
        <source-position filename="gvaluetypes.h" line="252" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6850">a valid #GValue of type %G_TYPE_STRING</doc>
            <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="v_string" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="vString" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6851">caller-owned string to be duplicated for the #GValue</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="v_string" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="vString" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6851">caller-owned string to be duplicated for the #GValue</doc>
            <type name="utf8" c:type="const gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_string_take_ownership" c:identifier="g_value_set_string_take_ownership" deprecated="1" deprecated-version="2.4" gs:dll-name="gobject-2.0" gs:managed-name="SetStringTakeOwnership">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6857">This is an internal function introduced mainly for C marshallers.</doc>
        <doc-deprecated xml:space="preserve">Use g_value_take_string() instead.</doc-deprecated>
        <source-position filename="gvaluetypes.h" line="301" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6859">a valid #GValue of type %G_TYPE_STRING</doc>
            <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="v_string" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="vString" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6860">duplicated unowned string to be set</doc>
            <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="v_string" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="vString" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6860">duplicated unowned string to be set</doc>
            <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_uchar" c:identifier="g_value_set_uchar" gs:dll-name="gobject-2.0" gs:managed-name="SetUchar" gs:property-setter-for="Uchar" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6868">Set the contents of a %G_TYPE_UCHAR #GValue to @v_uchar.</doc>
        <source-position filename="gvaluetypes.h" line="202" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6870">a valid #GValue of type %G_TYPE_UCHAR</doc>
            <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="v_uchar" transfer-ownership="none" gs:managed-name="vUchar" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6871">unsigned character value to be set</doc>
            <type name="guint8" c:type="guchar" gs:managed-name="System.Byte" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="v_uchar" transfer-ownership="none" gs:managed-name="vUchar" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6871">unsigned character value to be set</doc>
            <type name="guint8" c:type="guchar" gs:managed-name="System.Byte" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_uint" c:identifier="g_value_set_uint" gs:dll-name="gobject-2.0" gs:managed-name="SetUint" gs:property-setter-for="Uint" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6877">Set the contents of a %G_TYPE_UINT #GValue to @v_uint.</doc>
        <source-position filename="gvaluetypes.h" line="217" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6879">a valid #GValue of type %G_TYPE_UINT</doc>
            <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="v_uint" transfer-ownership="none" gs:managed-name="vUint" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6880">unsigned integer value to be set</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="v_uint" transfer-ownership="none" gs:managed-name="vUint" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6880">unsigned integer value to be set</doc>
            <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_uint64" c:identifier="g_value_set_uint64" gs:dll-name="gobject-2.0" gs:managed-name="SetUint64" gs:property-setter-for="Uint64" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6886">Set the contents of a %G_TYPE_UINT64 #GValue to @v_uint64.</doc>
        <source-position filename="gvaluetypes.h" line="237" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6888">a valid #GValue of type %G_TYPE_UINT64</doc>
            <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="v_uint64" transfer-ownership="none" gs:managed-name="vUint64" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6889">unsigned 64bit integer value to be set</doc>
            <type name="guint64" c:type="guint64" gs:managed-name="System.UInt64" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="v_uint64" transfer-ownership="none" gs:managed-name="vUint64" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6889">unsigned 64bit integer value to be set</doc>
            <type name="guint64" c:type="guint64" gs:managed-name="System.UInt64" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_ulong" c:identifier="g_value_set_ulong" gs:dll-name="gobject-2.0" gs:managed-name="SetUlong" gs:property-setter-for="Ulong" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6895">Set the contents of a %G_TYPE_ULONG #GValue to @v_ulong.</doc>
        <source-position filename="gvaluetypes.h" line="227" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6897">a valid #GValue of type %G_TYPE_ULONG</doc>
            <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="v_ulong" transfer-ownership="none" gs:managed-name="vUlong" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6898">unsigned long integer value to be set</doc>
            <type name="gulong" c:type="gulong" gs:managed-name="GISharp.Runtime.CULong" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="v_ulong" transfer-ownership="none" gs:managed-name="vUlong" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6898">unsigned long integer value to be set</doc>
            <type name="gulong" c:type="gulong" gs:managed-name="GISharp.Runtime.CULong" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="set_variant" c:identifier="g_value_set_variant" version="2.26" gs:dll-name="gobject-2.0" gs:managed-name="SetVariant" gs:property-setter-for="Variant" gs:access-modifiers="private">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6904">Set the contents of a variant #GValue to @variant.
If the variant is floating, it is consumed.</doc>
        <source-position filename="gvaluetypes.h" line="277" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6906">a valid #GValue of type %G_TYPE_VARIANT</doc>
            <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="variant" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="variant" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6907">a #GVariant, or %NULL</doc>
            <type name="GLib.Variant" c:type="GVariant*" gs:managed-name="GISharp.Lib.GLib.Variant" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="variant" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="variant" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6907">a #GVariant, or %NULL</doc>
            <type name="GLib.Variant" c:type="GVariant*" gs:managed-name="GISharp.Lib.GLib.Variant" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="take_boxed" c:identifier="g_value_take_boxed" version="2.4" gs:dll-name="gobject-2.0" gs:managed-name="TakeBoxed">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6916">Sets the contents of a %G_TYPE_BOXED derived #GValue to @v_boxed
and takes over the ownership of the caller’s reference to @v_boxed;
the caller doesn’t have to unref it any more.</doc>
        <source-position filename="gboxed.h" line="82" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6918">a valid #GValue of %G_TYPE_BOXED derived type</doc>
            <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="v_boxed" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="vBoxed" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6919">duplicated unowned boxed value to be set</doc>
            <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="v_boxed" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="vBoxed" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6919">duplicated unowned boxed value to be set</doc>
            <type name="gpointer" c:type="gconstpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="take_string" c:identifier="g_value_take_string" version="2.4" gs:dll-name="gobject-2.0" gs:managed-name="TakeString">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6959">Sets the contents of a %G_TYPE_STRING #GValue to @v_string.</doc>
        <source-position filename="gvaluetypes.h" line="298" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6961">a valid #GValue of type %G_TYPE_STRING</doc>
            <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="v_string" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="vString" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6962">string to take ownership of</doc>
            <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="v_string" transfer-ownership="none" nullable="1" allow-none="1" gs:managed-name="vString" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6962">string to take ownership of</doc>
            <type name="utf8" c:type="gchar*" gs:managed-name="GISharp.Lib.GLib.Utf8" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="take_variant" c:identifier="g_value_take_variant" version="2.26" gs:dll-name="gobject-2.0" gs:managed-name="TakeVariant">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6970">Set the contents of a variant #GValue to @variant, and takes over
the ownership of the caller's reference to @variant;
the caller doesn't have to unref it any more (i.e. the reference
count of the variant is not increased).

If @variant was floating then its floating reference is converted to
a hard reference.

If you want the #GValue to hold its own reference to @variant, use
g_value_set_variant() instead.

This is an internal function introduced mainly for C marshallers.</doc>
        <source-position filename="gvaluetypes.h" line="280" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6972">a valid #GValue of type %G_TYPE_VARIANT</doc>
            <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="variant" transfer-ownership="full" nullable="1" allow-none="1" gs:managed-name="variant" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6973">a #GVariant, or %NULL</doc>
            <type name="GLib.Variant" c:type="GVariant*" gs:managed-name="GISharp.Lib.GLib.Variant" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="variant" transfer-ownership="full" nullable="1" allow-none="1" gs:managed-name="variant" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6973">a #GVariant, or %NULL</doc>
            <type name="GLib.Variant" c:type="GVariant*" gs:managed-name="GISharp.Lib.GLib.Variant" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="transform" c:identifier="g_value_transform" gs:dll-name="gobject-2.0" gs:managed-name="Transform">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="6992">Tries to cast the contents of @src_value into a type appropriate
to store in @dest_value, e.g. to transform a %G_TYPE_INT value
into a %G_TYPE_FLOAT value. Performing transformations between
value types might incur precision lossage. Especially
transformations into strings might reveal seemingly arbitrary
results and shouldn't be relied upon for production code (such
as rcfile value or object property serialization).</doc>
        <source-position filename="gvalue.h" line="162" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="7005">Whether a transformation rule was found and could be applied.
 Upon failing transformations, @dest_value is left untouched.</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <instance-parameter name="src_value" transfer-ownership="none" gs:managed-name="srcValue" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6994">Source value.</doc>
            <type name="Value" c:type="const GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
          <parameter name="dest_value" transfer-ownership="none" gs:managed-name="destValue" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6995">Target value.</doc>
            <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="dest_value" transfer-ownership="none" gs:managed-name="destValue" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="6995">Target value.</doc>
            <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </parameter>
        </gs:managed-parameters>
      </method>
      <method name="unset" c:identifier="g_value_unset" gs:dll-name="gobject-2.0" gs:managed-name="Unset">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="7036">Clears the current value in @value (if any) and "unsets" the type,
this releases all resources associated with this GValue. An unset
value is the same as an uninitialized (zero-filled) #GValue
structure.</doc>
        <source-position filename="gvalue.h" line="138" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <type name="none" c:type="void" gs:managed-name="System.Void" />
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none" gs:managed-name="value" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="7038">An initialized #GValue structure.</doc>
            <type name="Value" c:type="GValue*" gs:managed-name="Value" gs:is-pointer="1" />
          </instance-parameter>
        </parameters>
        <gs:managed-parameters />
      </method>
      <function name="type_compatible" c:identifier="g_value_type_compatible" gs:dll-name="gobject-2.0" gs:managed-name="TypeCompatible">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="7010">Returns whether a #GValue of type @src_type can be copied into
a #GValue of type @dest_type.</doc>
        <source-position filename="gvalue.h" line="156" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="7018">%TRUE if g_value_copy() is possible with @src_type and @dest_type.</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <parameter name="src_type" transfer-ownership="none" gs:managed-name="srcType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="7012">source type to be copied.</doc>
            <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
          </parameter>
          <parameter name="dest_type" transfer-ownership="none" gs:managed-name="destType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="7013">destination type for copying.</doc>
            <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="src_type" transfer-ownership="none" gs:managed-name="srcType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="7012">source type to be copied.</doc>
            <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
          </parameter>
          <parameter name="dest_type" transfer-ownership="none" gs:managed-name="destType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="7013">destination type for copying.</doc>
            <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="type_transformable" c:identifier="g_value_type_transformable" gs:dll-name="gobject-2.0" gs:managed-name="TypeTransformable">
        <doc xml:space="preserve" filename="gobject-2.0.c" line="7022">Check whether g_value_transform() is able to transform values
of type @src_type into values of type @dest_type. Note that for
the types to be transformable, they must be compatible or a
transformation function must be registered.</doc>
        <source-position filename="gvalue.h" line="159" />
        <return-value transfer-ownership="none" gs:managed-name="ret" direction="in">
          <doc xml:space="preserve" filename="gobject-2.0.c" line="7032">%TRUE if the transformation is possible, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean" gs:managed-name="System.Boolean" />
        </return-value>
        <parameters>
          <parameter name="src_type" transfer-ownership="none" gs:managed-name="srcType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="7024">Source type.</doc>
            <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
          </parameter>
          <parameter name="dest_type" transfer-ownership="none" gs:managed-name="destType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="7025">Target type.</doc>
            <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
          </parameter>
        </parameters>
        <gs:managed-parameters>
          <parameter name="src_type" transfer-ownership="none" gs:managed-name="srcType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="7024">Source type.</doc>
            <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
          </parameter>
          <parameter name="dest_type" transfer-ownership="none" gs:managed-name="destType" direction="in">
            <doc xml:space="preserve" filename="gobject-2.0.c" line="7025">Target type.</doc>
            <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
          </parameter>
        </gs:managed-parameters>
      </function>
      <function name="get_g_type" gs:pinvoke-only="1" c:identifier="g_value_get_type" gs:access-modifiers="private" gs:dll-name="gobject-2.0" gs:managed-name="GetGType">
        <return-value transfer-ownership="full" gs:managed-name="ret" direction="in">
          <type name="GType" c:type="GType" gs:managed-name="GISharp.Lib.GObject.GType" />
        </return-value>
        <parameters />
        <gs:managed-parameters />
      </function>
    </record>
    <union name="_Value__data__union" gs:managed-name="ValueDataUnion">
      <field name="v_int" writable="1" gs:managed-name="VInt">
        <type name="gint" c:type="gint" gs:managed-name="System.Int32" />
      </field>
      <field name="v_uint" writable="1" gs:managed-name="VUint">
        <type name="guint" c:type="guint" gs:managed-name="System.UInt32" />
      </field>
      <field name="v_long" writable="1" gs:managed-name="VLong">
        <type name="glong" c:type="glong" gs:managed-name="GISharp.Runtime.CLong" />
      </field>
      <field name="v_ulong" writable="1" gs:managed-name="VUlong">
        <type name="gulong" c:type="gulong" gs:managed-name="GISharp.Runtime.CULong" />
      </field>
      <field name="v_int64" writable="1" gs:managed-name="VInt64">
        <type name="gint64" c:type="gint64" gs:managed-name="System.Int64" />
      </field>
      <field name="v_uint64" writable="1" gs:managed-name="VUint64">
        <type name="guint64" c:type="guint64" gs:managed-name="System.UInt64" />
      </field>
      <field name="v_float" writable="1" gs:managed-name="VFloat">
        <type name="gfloat" c:type="gfloat" gs:managed-name="System.Single" />
      </field>
      <field name="v_double" writable="1" gs:managed-name="VDouble">
        <type name="gdouble" c:type="gdouble" gs:managed-name="System.Double" />
      </field>
      <field name="v_pointer" writable="1" gs:managed-name="VPointer">
        <type name="gpointer" c:type="gpointer" gs:managed-name="System.IntPtr" gs:is-pointer="1" />
      </field>
    </union>
    <docsection name="enumerations_flags" gs:managed-name="EnumerationsFlags">
      <doc xml:space="preserve" filename="gobject-2.0.c" line="125">The GLib type system provides fundamental types for enumeration and
flags types. (Flags types are like enumerations, but allow their
values to be combined by bitwise or). A registered enumeration or
flags type associates a name and a nickname with each allowed
value, and the methods g_enum_get_value_by_name(),
g_enum_get_value_by_nick(), g_flags_get_value_by_name() and
g_flags_get_value_by_nick() can look up values by their name or
nickname.  When an enumeration or flags type is registered with the
GLib type system, it can be used as value type for object
properties, using g_param_spec_enum() or g_param_spec_flags().

GObject ships with a utility called [glib-mkenums][glib-mkenums],
that can construct suitable type registration functions from C enumeration
definitions.

Example of how to get a string representation of an enum value:
|[&lt;!-- language="C" --&gt;
GEnumClass *enum_class;
GEnumValue *enum_value;

enum_class = g_type_class_ref (MAMAN_TYPE_MY_ENUM);
enum_value = g_enum_get_value (enum_class, MAMAN_MY_ENUM_FOO);

g_print ("Name: %s\n", enum_value-&gt;value_name);

g_type_class_unref (enum_class);
]|</doc>
    </docsection>
    <docsection name="gboxed" gs:managed-name="Gboxed">
      <doc xml:space="preserve" filename="gobject-2.0.c" line="247">#GBoxed is a generic wrapper mechanism for arbitrary C structures. The only
thing the type system needs to know about the structures is how to copy them
(a #GBoxedCopyFunc) and how to free them (a #GBoxedFreeFunc) — beyond that
they are treated as opaque chunks of memory.

Boxed types are useful for simple value-holder structures like rectangles or
points. They can also be used for wrapping structures defined in non-#GObject
based libraries. They allow arbitrary structures to be handled in a uniform
way, allowing uniform copying (or referencing) and freeing (or unreferencing)
of them, and uniform representation of the type of the contained structure.
In turn, this allows any type which can be boxed to be set as the data in a
#GValue, which allows for polymorphic handling of a much wider range of data
types, and hence usage of such types as #GObject property values.

#GBoxed is designed so that reference counted types can be boxed. Use the
type’s ‘ref’ function as the #GBoxedCopyFunc, and its ‘unref’ function as the
#GBoxedFreeFunc. For example, for #GBytes, the #GBoxedCopyFunc is
g_bytes_ref(), and the #GBoxedFreeFunc is g_bytes_unref().</doc>
    </docsection>
    <docsection name="generic_values" gs:managed-name="GenericValues">
      <doc xml:space="preserve" filename="gobject-2.0.c" line="326">The #GValue structure is basically a variable container that consists
of a type identifier and a specific value of that type.
The type identifier within a #GValue structure always determines the
type of the associated value.
To create an undefined #GValue structure, simply create a zero-filled
#GValue structure. To initialize the #GValue, use the g_value_init()
function. A #GValue cannot be used until it is initialized.
The basic type operations (such as freeing and copying) are determined
by the #GTypeValueTable associated with the type ID stored in the #GValue.
Other #GValue operations (such as converting values between types) are
provided by this interface.

The code in the example program below demonstrates #GValue's
features.

|[&lt;!-- language="C" --&gt;
#include &lt;glib-object.h&gt;

static void
int2string (const GValue *src_value,
            GValue       *dest_value)
{
  if (g_value_get_int (src_value) == 42)
    g_value_set_static_string (dest_value, "An important number");
  else
    g_value_set_static_string (dest_value, "What's that?");
}

int
main (int   argc,
      char *argv[])
{
  // GValues must be initialized
  GValue a = G_VALUE_INIT;
  GValue b = G_VALUE_INIT;
  const gchar *message;

  // The GValue starts empty
  g_assert (!G_VALUE_HOLDS_STRING (&amp;a));

  // Put a string in it
  g_value_init (&amp;a, G_TYPE_STRING);
  g_assert (G_VALUE_HOLDS_STRING (&amp;a));
  g_value_set_static_string (&amp;a, "Hello, world!");
  g_printf ("%s\n", g_value_get_string (&amp;a));

  // Reset it to its pristine state
  g_value_unset (&amp;a);

  // It can then be reused for another type
  g_value_init (&amp;a, G_TYPE_INT);
  g_value_set_int (&amp;a, 42);

  // Attempt to transform it into a GValue of type STRING
  g_value_init (&amp;b, G_TYPE_STRING);

  // An INT is transformable to a STRING
  g_assert (g_value_type_transformable (G_TYPE_INT, G_TYPE_STRING));

  g_value_transform (&amp;a, &amp;b);
  g_printf ("%s\n", g_value_get_string (&amp;b));

  // Attempt to transform it again using a custom transform function
  g_value_register_transform_func (G_TYPE_INT, G_TYPE_STRING, int2string);
  g_value_transform (&amp;a, &amp;b);
  g_printf ("%s\n", g_value_get_string (&amp;b));
  return 0;
}
]|</doc>
    </docsection>
    <docsection name="gtype" gs:managed-name="Gtype">
      <doc xml:space="preserve" filename="gobject-2.0.c" line="433">The GType API is the foundation of the GObject system.  It provides the
facilities for registering and managing all fundamental data types,
user-defined object and interface types.

For type creation and registration purposes, all types fall into one of
two categories: static or dynamic.  Static types are never loaded or
unloaded at run-time as dynamic types may be.  Static types are created
with g_type_register_static() that gets type specific information passed
in via a #GTypeInfo structure.

Dynamic types are created with g_type_register_dynamic() which takes a
#GTypePlugin structure instead. The remaining type information (the
#GTypeInfo structure) is retrieved during runtime through #GTypePlugin
and the g_type_plugin_*() API.

These registration functions are usually called only once from a
function whose only purpose is to return the type identifier for a
specific class.  Once the type (or class or interface) is registered,
it may be instantiated, inherited, or implemented depending on exactly
what sort of type it is.

There is also a third registration function for registering fundamental
types called g_type_register_fundamental() which requires both a #GTypeInfo
structure and a #GTypeFundamentalInfo structure but it is seldom used
since most fundamental types are predefined rather than user-defined.

Type instance and class structs are limited to a total of 64 KiB,
including all parent types. Similarly, type instances' private data
(as created by G_ADD_PRIVATE()) are limited to a total of
64 KiB. If a type instance needs a large static buffer, allocate it
separately (typically by using #GArray or #GPtrArray) and put a pointer
to the buffer in the structure.

As mentioned in the [GType conventions][gtype-conventions], type names must
be at least three characters long. There is no upper length limit. The first
character must be a letter (a–z or A–Z) or an underscore (‘_’). Subsequent
characters can be letters, numbers or any of ‘-_+’.</doc>
    </docsection>
    <docsection name="objects" gs:managed-name="Objects">
      <doc xml:space="preserve" filename="gobject-2.0.c" line="570">GObject is the fundamental type providing the common attributes and
methods for all object types in GTK+, Pango and other libraries
based on GObject.  The GObject class provides methods for object
construction and destruction, property access methods, and signal
support.  Signals are described in detail [here][gobject-Signals].

For a tutorial on implementing a new GObject class, see [How to define and
implement a new GObject][howto-gobject]. For a list of naming conventions for
GObjects and their methods, see the [GType conventions][gtype-conventions].
For the high-level concepts behind GObject, read [Instantiable classed types:
Objects][gtype-instantiable-classed].

## Floating references # {#floating-ref}

**Note**: Floating references are a C convenience API and should not be
used in modern GObject code. Language bindings in particular find the
concept highly problematic, as floating references are not identifiable
through annotations, and neither are deviations from the floating reference
behavior, like types that inherit from #GInitiallyUnowned and still return
a full reference from g_object_new().

GInitiallyUnowned is derived from GObject. The only difference between
the two is that the initial reference of a GInitiallyUnowned is flagged
as a "floating" reference. This means that it is not specifically
claimed to be "owned" by any code portion. The main motivation for
providing floating references is C convenience. In particular, it
allows code to be written as:
|[&lt;!-- language="C" --&gt;
container = create_container ();
container_add_child (container, create_child());
]|
If container_add_child() calls g_object_ref_sink() on the passed-in child,
no reference of the newly created child is leaked. Without floating
references, container_add_child() can only g_object_ref() the new child,
so to implement this code without reference leaks, it would have to be
written as:
|[&lt;!-- language="C" --&gt;
Child *child;
container = create_container ();
child = create_child ();
container_add_child (container, child);
g_object_unref (child);
]|
The floating reference can be converted into an ordinary reference by
calling g_object_ref_sink(). For already sunken objects (objects that
don't have a floating reference anymore), g_object_ref_sink() is equivalent
to g_object_ref() and returns a new reference.

Since floating references are useful almost exclusively for C convenience,
language bindings that provide automated reference and memory ownership
maintenance (such as smart pointers or garbage collection) should not
expose floating references in their API. The best practice for handling
types that have initially floating references is to immediately sink those
references after g_object_new() returns, by checking if the #GType
inherits from #GInitiallyUnowned. For instance:

|[&lt;!-- language="C" --&gt;
GObject *res = g_object_new_with_properties (gtype,
                                             n_props,
                                             prop_names,
                                             prop_values);

// or: if (g_type_is_a (gtype, G_TYPE_INITIALLY_UNOWNED))
if (G_IS_INITIALLY_UNOWNED (res))
  g_object_ref_sink (res);

return res;
]|

Some object implementations may need to save an objects floating state
across certain code portions (an example is #GtkMenu), to achieve this,
the following sequence can be used:

|[&lt;!-- language="C" --&gt;
// save floating state
gboolean was_floating = g_object_is_floating (object);
g_object_ref_sink (object);
// protected code portion

...

// restore floating state
if (was_floating)
  g_object_force_floating (object);
else
  g_object_unref (object); // release previously acquired reference
]|</doc>
    </docsection>
    <docsection name="param_value_types" gs:managed-name="ParamValueTypes">
      <doc xml:space="preserve" filename="gobject-2.0.c" line="666">#GValue provides an abstract container structure which can be
copied, transformed and compared while holding a value of any
(derived) type, which is registered as a #GType with a
#GTypeValueTable in its #GTypeInfo structure.  Parameter
specifications for most value types can be created as #GParamSpec
derived instances, to implement e.g. #GObject properties which
operate on #GValue containers.

Parameter names need to start with a letter (a-z or A-Z). Subsequent
characters can be letters, numbers or a '-'.
All other characters are replaced by a '-' during construction.</doc>
    </docsection>
    <docsection name="signals" gs:managed-name="Signals">
      <doc xml:space="preserve" filename="gobject-2.0.c" line="686">The basic concept of the signal system is that of the emission
of a signal. Signals are introduced per-type and are identified
through strings. Signals introduced for a parent type are available
in derived types as well, so basically they are a per-type facility
that is inherited.

A signal emission mainly involves invocation of a certain set of
callbacks in precisely defined manner. There are two main categories
of such callbacks, per-object ones and user provided ones.
(Although signals can deal with any kind of instantiatable type, I'm
referring to those types as "object types" in the following, simply
because that is the context most users will encounter signals in.)
The per-object callbacks are most often referred to as "object method
handler" or "default (signal) handler", while user provided callbacks are
usually just called "signal handler".

The object method handler is provided at signal creation time (this most
frequently happens at the end of an object class' creation), while user
provided handlers are frequently connected and disconnected to/from a
certain signal on certain object instances.

A signal emission consists of five stages, unless prematurely stopped:

1. Invocation of the object method handler for %G_SIGNAL_RUN_FIRST signals

2. Invocation of normal user-provided signal handlers (where the @after
   flag is not set)

3. Invocation of the object method handler for %G_SIGNAL_RUN_LAST signals

4. Invocation of user provided signal handlers (where the @after flag is set)

5. Invocation of the object method handler for %G_SIGNAL_RUN_CLEANUP signals

The user-provided signal handlers are called in the order they were
connected in.

All handlers may prematurely stop a signal emission, and any number of
handlers may be connected, disconnected, blocked or unblocked during
a signal emission.

There are certain criteria for skipping user handlers in stages 2 and 4
of a signal emission.

First, user handlers may be blocked. Blocked handlers are omitted during
callback invocation, to return from the blocked state, a handler has to
get unblocked exactly the same amount of times it has been blocked before.

Second, upon emission of a %G_SIGNAL_DETAILED signal, an additional
@detail argument passed in to g_signal_emit() has to match the detail
argument of the signal handler currently subject to invocation.
Specification of no detail argument for signal handlers (omission of the
detail part of the signal specification upon connection) serves as a
wildcard and matches any detail argument passed in to emission.

While the @detail argument is typically used to pass an object property name
(as with #GObject::notify), no specific format is mandated for the detail
string, other than that it must be non-empty.

## Memory management of signal handlers # {#signal-memory-management}

If you are connecting handlers to signals and using a #GObject instance as
your signal handler user data, you should remember to pair calls to
g_signal_connect() with calls to g_signal_handler_disconnect() or
g_signal_handlers_disconnect_by_func(). While signal handlers are
automatically disconnected when the object emitting the signal is finalised,
they are not automatically disconnected when the signal handler user data is
destroyed. If this user data is a #GObject instance, using it from a
signal handler after it has been finalised is an error.

There are two strategies for managing such user data. The first is to
disconnect the signal handler (using g_signal_handler_disconnect() or
g_signal_handlers_disconnect_by_func()) when the user data (object) is
finalised; this has to be implemented manually. For non-threaded programs,
g_signal_connect_object() can be used to implement this automatically.
Currently, however, it is unsafe to use in threaded programs.

The second is to hold a strong reference on the user data until after the
signal is disconnected for other reasons. This can be implemented
automatically using g_signal_connect_data().

The first approach is recommended, as the second approach can result in
effective memory leaks of the user data if the signal handler is never
disconnected for some reason.</doc>
    </docsection>
    <docsection name="value_arrays" gs:managed-name="ValueArrays">
      <doc xml:space="preserve" filename="gobject-2.0.c" line="779">The prime purpose of a #GValueArray is for it to be used as an
object property that holds an array of values. A #GValueArray wraps
an array of #GValue elements in order for it to be used as a boxed
type through %G_TYPE_VALUE_ARRAY.

#GValueArray is deprecated in favour of #GArray since GLib 2.32. It
is possible to create a #GArray that behaves like a #GValueArray by
using the size of #GValue as the element size, and by setting
g_value_unset() as the clear function using g_array_set_clear_func(),
for instance, the following code:

|[&lt;!-- language="C" --&gt;
  GValueArray *array = g_value_array_new (10);
]|

can be replaced by:

|[&lt;!-- language="C" --&gt;
  GArray *array = g_array_sized_new (FALSE, TRUE, sizeof (GValue), 10);
  g_array_set_clear_func (array, (GDestroyNotify) g_value_unset);
]|</doc>
    </docsection>
  </namespace>
</repository>