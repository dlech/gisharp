<?xml version="1.0" encoding="utf-8"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2" xmlns="http://www.gtk.org/introspection/core/1.0" xmlns:c="http://www.gtk.org/introspection/c/1.0" xmlns:glib="http://www.gtk.org/introspection/glib/1.0" xmlns:gs="http://gisharp.org/introspection/gisharp/1.0">
  <include name="GLib" version="2.0" gs:managed-name="GLib" />
  <package name="gobject-2.0" gs:managed-name="Gobject2.0" />
  <c:include name="glib-object.h" gs:managed-name="GlibObject.h" />
  <namespace name="GObject" version="2.0" shared-library="/usr/local/opt/glib/lib/libgobject-2.0.0.dylib" c:identifier-prefixes="G" c:symbol-prefixes="g" gs:managed-name="GObject">
    <docsection name="enumerations_flags" gs:managed-name="EnumerationsFlags">
      <doc xml:space="preserve" filename="gobject-2.0.c" line="125">The GLib type system provides fundamental types for enumeration and
flags types. (Flags types are like enumerations, but allow their
values to be combined by bitwise or). A registered enumeration or
flags type associates a name and a nickname with each allowed
value, and the methods g_enum_get_value_by_name(),
g_enum_get_value_by_nick(), g_flags_get_value_by_name() and
g_flags_get_value_by_nick() can look up values by their name or
nickname.  When an enumeration or flags type is registered with the
GLib type system, it can be used as value type for object
properties, using g_param_spec_enum() or g_param_spec_flags().

GObject ships with a utility called [glib-mkenums][glib-mkenums],
that can construct suitable type registration functions from C enumeration
definitions.

Example of how to get a string representation of an enum value:
|[&lt;!-- language="C" --&gt;
GEnumClass *enum_class;
GEnumValue *enum_value;

enum_class = g_type_class_ref (MAMAN_TYPE_MY_ENUM);
enum_value = g_enum_get_value (enum_class, MAMAN_MY_ENUM_FOO);

g_print ("Name: %s\n", enum_value-&gt;value_name);

g_type_class_unref (enum_class);
]|</doc>
    </docsection>
    <docsection name="gboxed" gs:managed-name="Gboxed">
      <doc xml:space="preserve" filename="gobject-2.0.c" line="247">#GBoxed is a generic wrapper mechanism for arbitrary C structures. The only
thing the type system needs to know about the structures is how to copy them
(a #GBoxedCopyFunc) and how to free them (a #GBoxedFreeFunc) — beyond that
they are treated as opaque chunks of memory.

Boxed types are useful for simple value-holder structures like rectangles or
points. They can also be used for wrapping structures defined in non-#GObject
based libraries. They allow arbitrary structures to be handled in a uniform
way, allowing uniform copying (or referencing) and freeing (or unreferencing)
of them, and uniform representation of the type of the contained structure.
In turn, this allows any type which can be boxed to be set as the data in a
#GValue, which allows for polymorphic handling of a much wider range of data
types, and hence usage of such types as #GObject property values.

#GBoxed is designed so that reference counted types can be boxed. Use the
type’s ‘ref’ function as the #GBoxedCopyFunc, and its ‘unref’ function as the
#GBoxedFreeFunc. For example, for #GBytes, the #GBoxedCopyFunc is
g_bytes_ref(), and the #GBoxedFreeFunc is g_bytes_unref().</doc>
    </docsection>
    <docsection name="generic_values" gs:managed-name="GenericValues">
      <doc xml:space="preserve" filename="gobject-2.0.c" line="326">The #GValue structure is basically a variable container that consists
of a type identifier and a specific value of that type.
The type identifier within a #GValue structure always determines the
type of the associated value.
To create an undefined #GValue structure, simply create a zero-filled
#GValue structure. To initialize the #GValue, use the g_value_init()
function. A #GValue cannot be used until it is initialized.
The basic type operations (such as freeing and copying) are determined
by the #GTypeValueTable associated with the type ID stored in the #GValue.
Other #GValue operations (such as converting values between types) are
provided by this interface.

The code in the example program below demonstrates #GValue's
features.

|[&lt;!-- language="C" --&gt;
#include &lt;glib-object.h&gt;

static void
int2string (const GValue *src_value,
            GValue       *dest_value)
{
  if (g_value_get_int (src_value) == 42)
    g_value_set_static_string (dest_value, "An important number");
  else
    g_value_set_static_string (dest_value, "What's that?");
}

int
main (int   argc,
      char *argv[])
{
  // GValues must be initialized
  GValue a = G_VALUE_INIT;
  GValue b = G_VALUE_INIT;
  const gchar *message;

  // The GValue starts empty
  g_assert (!G_VALUE_HOLDS_STRING (&amp;a));

  // Put a string in it
  g_value_init (&amp;a, G_TYPE_STRING);
  g_assert (G_VALUE_HOLDS_STRING (&amp;a));
  g_value_set_static_string (&amp;a, "Hello, world!");
  g_printf ("%s\n", g_value_get_string (&amp;a));

  // Reset it to its pristine state
  g_value_unset (&amp;a);

  // It can then be reused for another type
  g_value_init (&amp;a, G_TYPE_INT);
  g_value_set_int (&amp;a, 42);

  // Attempt to transform it into a GValue of type STRING
  g_value_init (&amp;b, G_TYPE_STRING);

  // An INT is transformable to a STRING
  g_assert (g_value_type_transformable (G_TYPE_INT, G_TYPE_STRING));

  g_value_transform (&amp;a, &amp;b);
  g_printf ("%s\n", g_value_get_string (&amp;b));

  // Attempt to transform it again using a custom transform function
  g_value_register_transform_func (G_TYPE_INT, G_TYPE_STRING, int2string);
  g_value_transform (&amp;a, &amp;b);
  g_printf ("%s\n", g_value_get_string (&amp;b));
  return 0;
}
]|</doc>
    </docsection>
    <docsection name="gtype" gs:managed-name="Gtype">
      <doc xml:space="preserve" filename="gobject-2.0.c" line="433">The GType API is the foundation of the GObject system.  It provides the
facilities for registering and managing all fundamental data types,
user-defined object and interface types.

For type creation and registration purposes, all types fall into one of
two categories: static or dynamic.  Static types are never loaded or
unloaded at run-time as dynamic types may be.  Static types are created
with g_type_register_static() that gets type specific information passed
in via a #GTypeInfo structure.

Dynamic types are created with g_type_register_dynamic() which takes a
#GTypePlugin structure instead. The remaining type information (the
#GTypeInfo structure) is retrieved during runtime through #GTypePlugin
and the g_type_plugin_*() API.

These registration functions are usually called only once from a
function whose only purpose is to return the type identifier for a
specific class.  Once the type (or class or interface) is registered,
it may be instantiated, inherited, or implemented depending on exactly
what sort of type it is.

There is also a third registration function for registering fundamental
types called g_type_register_fundamental() which requires both a #GTypeInfo
structure and a #GTypeFundamentalInfo structure but it is seldom used
since most fundamental types are predefined rather than user-defined.

Type instance and class structs are limited to a total of 64 KiB,
including all parent types. Similarly, type instances' private data
(as created by G_ADD_PRIVATE()) are limited to a total of
64 KiB. If a type instance needs a large static buffer, allocate it
separately (typically by using #GArray or #GPtrArray) and put a pointer
to the buffer in the structure.

As mentioned in the [GType conventions][gtype-conventions], type names must
be at least three characters long. There is no upper length limit. The first
character must be a letter (a–z or A–Z) or an underscore (‘_’). Subsequent
characters can be letters, numbers or any of ‘-_+’.</doc>
    </docsection>
    <docsection name="objects" gs:managed-name="Objects">
      <doc xml:space="preserve" filename="gobject-2.0.c" line="570">GObject is the fundamental type providing the common attributes and
methods for all object types in GTK+, Pango and other libraries
based on GObject.  The GObject class provides methods for object
construction and destruction, property access methods, and signal
support.  Signals are described in detail [here][gobject-Signals].

For a tutorial on implementing a new GObject class, see [How to define and
implement a new GObject][howto-gobject]. For a list of naming conventions for
GObjects and their methods, see the [GType conventions][gtype-conventions].
For the high-level concepts behind GObject, read [Instantiable classed types:
Objects][gtype-instantiable-classed].

## Floating references # {#floating-ref}

**Note**: Floating references are a C convenience API and should not be
used in modern GObject code. Language bindings in particular find the
concept highly problematic, as floating references are not identifiable
through annotations, and neither are deviations from the floating reference
behavior, like types that inherit from #GInitiallyUnowned and still return
a full reference from g_object_new().

GInitiallyUnowned is derived from GObject. The only difference between
the two is that the initial reference of a GInitiallyUnowned is flagged
as a "floating" reference. This means that it is not specifically
claimed to be "owned" by any code portion. The main motivation for
providing floating references is C convenience. In particular, it
allows code to be written as:
|[&lt;!-- language="C" --&gt;
container = create_container ();
container_add_child (container, create_child());
]|
If container_add_child() calls g_object_ref_sink() on the passed-in child,
no reference of the newly created child is leaked. Without floating
references, container_add_child() can only g_object_ref() the new child,
so to implement this code without reference leaks, it would have to be
written as:
|[&lt;!-- language="C" --&gt;
Child *child;
container = create_container ();
child = create_child ();
container_add_child (container, child);
g_object_unref (child);
]|
The floating reference can be converted into an ordinary reference by
calling g_object_ref_sink(). For already sunken objects (objects that
don't have a floating reference anymore), g_object_ref_sink() is equivalent
to g_object_ref() and returns a new reference.

Since floating references are useful almost exclusively for C convenience,
language bindings that provide automated reference and memory ownership
maintenance (such as smart pointers or garbage collection) should not
expose floating references in their API. The best practice for handling
types that have initially floating references is to immediately sink those
references after g_object_new() returns, by checking if the #GType
inherits from #GInitiallyUnowned. For instance:

|[&lt;!-- language="C" --&gt;
GObject *res = g_object_new_with_properties (gtype,
                                             n_props,
                                             prop_names,
                                             prop_values);

// or: if (g_type_is_a (gtype, G_TYPE_INITIALLY_UNOWNED))
if (G_IS_INITIALLY_UNOWNED (res))
  g_object_ref_sink (res);

return res;
]|

Some object implementations may need to save an objects floating state
across certain code portions (an example is #GtkMenu), to achieve this,
the following sequence can be used:

|[&lt;!-- language="C" --&gt;
// save floating state
gboolean was_floating = g_object_is_floating (object);
g_object_ref_sink (object);
// protected code portion

...

// restore floating state
if (was_floating)
  g_object_force_floating (object);
else
  g_object_unref (object); // release previously acquired reference
]|</doc>
    </docsection>
    <docsection name="param_value_types" gs:managed-name="ParamValueTypes">
      <doc xml:space="preserve" filename="gobject-2.0.c" line="666">#GValue provides an abstract container structure which can be
copied, transformed and compared while holding a value of any
(derived) type, which is registered as a #GType with a
#GTypeValueTable in its #GTypeInfo structure.  Parameter
specifications for most value types can be created as #GParamSpec
derived instances, to implement e.g. #GObject properties which
operate on #GValue containers.

Parameter names need to start with a letter (a-z or A-Z). Subsequent
characters can be letters, numbers or a '-'.
All other characters are replaced by a '-' during construction.</doc>
    </docsection>
    <docsection name="signals" gs:managed-name="Signals">
      <doc xml:space="preserve" filename="gobject-2.0.c" line="686">The basic concept of the signal system is that of the emission
of a signal. Signals are introduced per-type and are identified
through strings. Signals introduced for a parent type are available
in derived types as well, so basically they are a per-type facility
that is inherited.

A signal emission mainly involves invocation of a certain set of
callbacks in precisely defined manner. There are two main categories
of such callbacks, per-object ones and user provided ones.
(Although signals can deal with any kind of instantiatable type, I'm
referring to those types as "object types" in the following, simply
because that is the context most users will encounter signals in.)
The per-object callbacks are most often referred to as "object method
handler" or "default (signal) handler", while user provided callbacks are
usually just called "signal handler".

The object method handler is provided at signal creation time (this most
frequently happens at the end of an object class' creation), while user
provided handlers are frequently connected and disconnected to/from a
certain signal on certain object instances.

A signal emission consists of five stages, unless prematurely stopped:

1. Invocation of the object method handler for %G_SIGNAL_RUN_FIRST signals

2. Invocation of normal user-provided signal handlers (where the @after
   flag is not set)

3. Invocation of the object method handler for %G_SIGNAL_RUN_LAST signals

4. Invocation of user provided signal handlers (where the @after flag is set)

5. Invocation of the object method handler for %G_SIGNAL_RUN_CLEANUP signals

The user-provided signal handlers are called in the order they were
connected in.

All handlers may prematurely stop a signal emission, and any number of
handlers may be connected, disconnected, blocked or unblocked during
a signal emission.

There are certain criteria for skipping user handlers in stages 2 and 4
of a signal emission.

First, user handlers may be blocked. Blocked handlers are omitted during
callback invocation, to return from the blocked state, a handler has to
get unblocked exactly the same amount of times it has been blocked before.

Second, upon emission of a %G_SIGNAL_DETAILED signal, an additional
@detail argument passed in to g_signal_emit() has to match the detail
argument of the signal handler currently subject to invocation.
Specification of no detail argument for signal handlers (omission of the
detail part of the signal specification upon connection) serves as a
wildcard and matches any detail argument passed in to emission.

While the @detail argument is typically used to pass an object property name
(as with #GObject::notify), no specific format is mandated for the detail
string, other than that it must be non-empty.

## Memory management of signal handlers # {#signal-memory-management}

If you are connecting handlers to signals and using a #GObject instance as
your signal handler user data, you should remember to pair calls to
g_signal_connect() with calls to g_signal_handler_disconnect() or
g_signal_handlers_disconnect_by_func(). While signal handlers are
automatically disconnected when the object emitting the signal is finalised,
they are not automatically disconnected when the signal handler user data is
destroyed. If this user data is a #GObject instance, using it from a
signal handler after it has been finalised is an error.

There are two strategies for managing such user data. The first is to
disconnect the signal handler (using g_signal_handler_disconnect() or
g_signal_handlers_disconnect_by_func()) when the user data (object) is
finalised; this has to be implemented manually. For non-threaded programs,
g_signal_connect_object() can be used to implement this automatically.
Currently, however, it is unsafe to use in threaded programs.

The second is to hold a strong reference on the user data until after the
signal is disconnected for other reasons. This can be implemented
automatically using g_signal_connect_data().

The first approach is recommended, as the second approach can result in
effective memory leaks of the user data if the signal handler is never
disconnected for some reason.</doc>
    </docsection>
    <docsection name="value_arrays" gs:managed-name="ValueArrays">
      <doc xml:space="preserve" filename="gobject-2.0.c" line="779">The prime purpose of a #GValueArray is for it to be used as an
object property that holds an array of values. A #GValueArray wraps
an array of #GValue elements in order for it to be used as a boxed
type through %G_TYPE_VALUE_ARRAY.

#GValueArray is deprecated in favour of #GArray since GLib 2.32. It
is possible to create a #GArray that behaves like a #GValueArray by
using the size of #GValue as the element size, and by setting
g_value_unset() as the clear function using g_array_set_clear_func(),
for instance, the following code:

|[&lt;!-- language="C" --&gt;
  GValueArray *array = g_value_array_new (10);
]|

can be replaced by:

|[&lt;!-- language="C" --&gt;
  GArray *array = g_array_sized_new (FALSE, TRUE, sizeof (GValue), 10);
  g_array_set_clear_func (array, (GDestroyNotify) g_value_unset);
]|</doc>
    </docsection>
  </namespace>
</repository>