// SPDX-License-Identifier: MIT
// ATTENTION: This file is automatically generated. Do not edit manually.
#nullable enable
namespace GISharp.Lib.GLib
{
    /// <include file="Utf8Extensions.xmldoc" path="declaration/member[@name='Utf8Extensions']/*" />
    public static unsafe partial class Utf8Extensions
    {
        /// <summary>
        /// Converts a string into a form that is independent of case. The
        /// result will not correspond to any particular case, but can be
        /// compared for equality or ordered with the results of calling
        /// g_utf8_casefold() on other strings.
        /// </summary>
        /// <remarks>
        /// Note that calling g_utf8_casefold() followed by g_utf8_collate() is
        /// only an approximation to the correct linguistic case insensitive
        /// ordering, though it is a fairly good one. Getting this exactly
        /// right would require a more sophisticated collation function that
        /// takes case sensitivity into account. GLib does not currently
        /// provide such a function.
        /// </remarks>
        /// <param name="str">
        /// a UTF-8 encoded string
        /// </param>
        /// <param name="len">
        /// length of @str, in bytes, or -1 if @str is nul-terminated.
        /// </param>
        /// <returns>
        /// a newly allocated string, that is a
        ///   case independent form of @str.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern System.Byte* g_utf8_casefold(
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.Byte* str,
        /* <type name="gssize" type="gssize" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr len);

        /// <summary>
        /// Compares two strings for ordering using the linguistically
        /// correct rules for the [current locale][setlocale].
        /// When sorting a large number of strings, it will be significantly
        /// faster to obtain collation keys with g_utf8_collate_key() and
        /// compare the keys with strcmp() when sorting instead of sorting
        /// the original strings.
        /// </summary>
        /// <param name="str1">
        /// a UTF-8 encoded string
        /// </param>
        /// <param name="str2">
        /// a UTF-8 encoded string
        /// </param>
        /// <returns>
        /// &lt; 0 if @str1 compares before @str2,
        ///   0 if they compare equal, &gt; 0 if @str1 compares after @str2.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gint" type="gint" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        private static extern System.Int32 g_utf8_collate(
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.Byte* str1,
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.Byte* str2);

        /// <summary>
        /// Converts a string into a collation key that can be compared
        /// with other collation keys produced by the same function using
        /// strcmp().
        /// </summary>
        /// <remarks>
        /// The results of comparing the collation keys of two strings
        /// with strcmp() will always be the same as comparing the two
        /// original keys with g_utf8_collate().
        /// 
        /// Note that this function depends on the [current locale][setlocale].
        /// </remarks>
        /// <param name="str">
        /// a UTF-8 encoded string.
        /// </param>
        /// <param name="len">
        /// length of @str, in bytes, or -1 if @str is nul-terminated.
        /// </param>
        /// <returns>
        /// a newly allocated string. This string should
        ///   be freed with g_free() when you are done with it.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern System.Byte* g_utf8_collate_key(
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.Byte* str,
        /* <type name="gssize" type="gssize" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr len);

        /// <summary>
        /// Converts a string into a collation key that can be compared
        /// with other collation keys produced by the same function using strcmp().
        /// </summary>
        /// <remarks>
        /// In order to sort filenames correctly, this function treats the dot '.'
        /// as a special case. Most dictionary orderings seem to consider it
        /// insignificant, thus producing the ordering "event.c" "eventgenerator.c"
        /// "event.h" instead of "event.c" "event.h" "eventgenerator.c". Also, we
        /// would like to treat numbers intelligently so that "file1" "file10" "file5"
        /// is sorted as "file1" "file5" "file10".
        /// 
        /// Note that this function depends on the [current locale][setlocale].
        /// </remarks>
        /// <param name="str">
        /// a UTF-8 encoded string.
        /// </param>
        /// <param name="len">
        /// length of @str, in bytes, or -1 if @str is nul-terminated.
        /// </param>
        /// <returns>
        /// a newly allocated string. This string should
        ///   be freed with g_free() when you are done with it.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.8")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern System.Byte* g_utf8_collate_key_for_filename(
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.Byte* str,
        /* <type name="gssize" type="gssize" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr len);

        /// <summary>
        /// Finds the start of the next UTF-8 character in the string after @p.
        /// </summary>
        /// <remarks>
        /// @p does not have to be at the beginning of a UTF-8 character. No check
        /// is made to see if the character found is actually valid other than
        /// it starts with an appropriate byte.
        /// 
        /// If @end is %NULL, the return value will never be %NULL: if the end of the
        /// string is reached, a pointer to the terminating nul byte is returned. If
        /// @end is non-%NULL, the return value will be %NULL if the end of the string
        /// is reached.
        /// </remarks>
        /// <param name="p">
        /// a pointer to a position within a UTF-8 encoded string
        /// </param>
        /// <param name="end">
        /// a pointer to the byte following the end of the string,
        ///     or %NULL to indicate that the string is nul-terminated
        /// </param>
        /// <returns>
        /// a pointer to the found character or %NULL if @end is
        ///    set and is reached
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 direction:in */
        private static extern System.Byte* g_utf8_find_next_char(
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.Byte* p,
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.Byte* end);

        /// <summary>
        /// Given a position @p with a UTF-8 encoded string @str, find the start
        /// of the previous UTF-8 character starting before @p. Returns %NULL if no
        /// UTF-8 characters are present in @str before @p.
        /// </summary>
        /// <remarks>
        /// @p does not have to be at the beginning of a UTF-8 character. No check
        /// is made to see if the character found is actually valid other than
        /// it starts with an appropriate byte.
        /// </remarks>
        /// <param name="str">
        /// pointer to the beginning of a UTF-8 encoded string
        /// </param>
        /// <param name="p">
        /// pointer to some position within @str
        /// </param>
        /// <returns>
        /// a pointer to the found character or %NULL.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 direction:in */
        private static extern System.Byte* g_utf8_find_prev_char(
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.Byte* str,
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.Byte* p);

        /// <summary>
        /// Converts a sequence of bytes encoded as UTF-8 to a Unicode character.
        /// </summary>
        /// <remarks>
        /// If @p does not point to a valid UTF-8 encoded character, results
        /// are undefined. If you are not sure that the bytes are complete
        /// valid Unicode characters, you should use g_utf8_get_char_validated()
        /// instead.
        /// </remarks>
        /// <param name="p">
        /// a pointer to Unicode character encoded as UTF-8
        /// </param>
        /// <returns>
        /// the resulting character
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gunichar" type="gunichar" managed-name="GISharp.Lib.GLib.Unichar" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GLib.Unichar g_utf8_get_char(
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.Byte* p);

        /// <summary>
        /// Convert a sequence of bytes encoded as UTF-8 to a Unicode character.
        /// This function checks for incomplete characters, for invalid characters
        /// such as characters that are out of the range of Unicode, and for
        /// overlong encodings of valid characters.
        /// </summary>
        /// <remarks>
        /// Note that g_utf8_get_char_validated() returns (gunichar)-2 if
        /// @max_len is positive and any of the bytes in the first UTF-8 character
        /// sequence are nul.
        /// </remarks>
        /// <param name="p">
        /// a pointer to Unicode character encoded as UTF-8
        /// </param>
        /// <param name="maxLen">
        /// the maximum number of bytes to read, or -1 if @p is nul-terminated
        /// </param>
        /// <returns>
        /// the resulting character. If @p points to a partial
        ///     sequence at the end of a string that could begin a valid
        ///     character (or if @max_len is zero), returns (gunichar)-2;
        ///     otherwise, if @p does not point to a valid UTF-8 encoded
        ///     Unicode character, returns (gunichar)-1.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gunichar" type="gunichar" managed-name="GISharp.Lib.GLib.Unichar" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Lib.GLib.Unichar g_utf8_get_char_validated(
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.Byte* p,
        /* <type name="gssize" type="gssize" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr maxLen);

        /// <summary>
        /// If the provided string is valid UTF-8, return a copy of it. If not,
        /// return a copy in which bytes that could not be interpreted as valid Unicode
        /// are replaced with the Unicode replacement character (U+FFFD).
        /// </summary>
        /// <remarks>
        /// For example, this is an appropriate function to use if you have received
        /// a string that was incorrectly declared to be UTF-8, and you need a valid
        /// UTF-8 version of it that can be logged or displayed to the user, with the
        /// assumption that it is close enough to ASCII or UTF-8 to be mostly
        /// readable as-is.
        /// </remarks>
        /// <param name="str">
        /// string to coerce into UTF-8
        /// </param>
        /// <param name="len">
        /// the maximum length of @str to use, in bytes. If @len &lt; 0,
        ///     then the string is nul-terminated.
        /// </param>
        /// <returns>
        /// a valid UTF-8 string whose content resembles @str
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.52")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern System.Byte* g_utf8_make_valid(
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.Byte* str,
        /* <type name="gssize" type="gssize" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr len);

        /// <summary>
        /// Converts a string into canonical form, standardizing
        /// such issues as whether a character with an accent
        /// is represented as a base character and combining
        /// accent or as a single precomposed character. The
        /// string has to be valid UTF-8, otherwise %NULL is
        /// returned. You should generally call g_utf8_normalize()
        /// before comparing two Unicode strings.
        /// </summary>
        /// <remarks>
        /// The normalization mode %G_NORMALIZE_DEFAULT only
        /// standardizes differences that do not affect the
        /// text content, such as the above-mentioned accent
        /// representation. %G_NORMALIZE_ALL also standardizes
        /// the "compatibility" characters in Unicode, such
        /// as SUPERSCRIPT THREE to the standard forms
        /// (in this case DIGIT THREE). Formatting information
        /// may be lost but for most text operations such
        /// characters should be considered the same.
        /// 
        /// %G_NORMALIZE_DEFAULT_COMPOSE and %G_NORMALIZE_ALL_COMPOSE
        /// are like %G_NORMALIZE_DEFAULT and %G_NORMALIZE_ALL,
        /// but returned a result with composed forms rather
        /// than a maximally decomposed form. This is often
        /// useful if you intend to convert the string to
        /// a legacy encoding or pass it to a system with
        /// less capable Unicode handling.
        /// </remarks>
        /// <param name="str">
        /// a UTF-8 encoded string.
        /// </param>
        /// <param name="len">
        /// length of @str, in bytes, or -1 if @str is nul-terminated.
        /// </param>
        /// <param name="mode">
        /// the type of normalization to perform.
        /// </param>
        /// <returns>
        /// a newly allocated string, that
        ///   is the normalized form of @str, or %NULL if @str
        ///   is not valid UTF-8.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:full nullable:1 direction:in */
        private static extern System.Byte* g_utf8_normalize(
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.Byte* str,
        /* <type name="gssize" type="gssize" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr len,
        /* <type name="NormalizeMode" type="GNormalizeMode" managed-name="NormalizeMode" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.NormalizeMode mode);

        /// <summary>
        /// Converts from an integer character offset to a pointer to a position
        /// within the string.
        /// </summary>
        /// <remarks>
        /// Since 2.10, this function allows to pass a negative @offset to
        /// step backwards. It is usually worth stepping backwards from the end
        /// instead of forwards if @offset is in the last fourth of the string,
        /// since moving forward is about 3 times faster than moving backward.
        /// 
        /// Note that this function doesn't abort when reaching the end of @str.
        /// Therefore you should be sure that @offset is within string boundaries
        /// before calling that function. Call g_utf8_strlen() when unsure.
        /// This limitation exists as this function is called frequently during
        /// text rendering and therefore has to be as fast as possible.
        /// </remarks>
        /// <param name="str">
        /// a UTF-8 encoded string
        /// </param>
        /// <param name="offset">
        /// a character offset within @str
        /// </param>
        /// <returns>
        /// the resulting pointer
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern System.Byte* g_utf8_offset_to_pointer(
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.Byte* str,
        /* <type name="glong" type="glong" managed-name="GISharp.Runtime.CLong" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.CLong offset);

        /// <summary>
        /// Converts from a pointer to position within a string to an integer
        /// character offset.
        /// </summary>
        /// <remarks>
        /// Since 2.10, this function allows @pos to be before @str, and returns
        /// a negative offset in this case.
        /// </remarks>
        /// <param name="str">
        /// a UTF-8 encoded string
        /// </param>
        /// <param name="pos">
        /// a pointer to a position within @str
        /// </param>
        /// <returns>
        /// the resulting character offset
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="glong" type="glong" managed-name="GISharp.Runtime.CLong" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.CLong g_utf8_pointer_to_offset(
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.Byte* str,
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.Byte* pos);

        /// <summary>
        /// Finds the previous UTF-8 character in the string before @p.
        /// </summary>
        /// <remarks>
        /// @p does not have to be at the beginning of a UTF-8 character. No check
        /// is made to see if the character found is actually valid other than
        /// it starts with an appropriate byte. If @p might be the first
        /// character of the string, you must use g_utf8_find_prev_char() instead.
        /// </remarks>
        /// <param name="p">
        /// a pointer to a position within a UTF-8 encoded string
        /// </param>
        /// <returns>
        /// a pointer to the found character
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern System.Byte* g_utf8_prev_char(
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.Byte* p);

        /// <summary>
        /// Finds the leftmost occurrence of the given Unicode character
        /// in a UTF-8 encoded string, while limiting the search to @len bytes.
        /// If @len is -1, allow unbounded search.
        /// </summary>
        /// <param name="p">
        /// a nul-terminated UTF-8 encoded string
        /// </param>
        /// <param name="len">
        /// the maximum length of @p
        /// </param>
        /// <param name="c">
        /// a Unicode character
        /// </param>
        /// <returns>
        /// %NULL if the string does not contain the character,
        ///     otherwise, a pointer to the start of the leftmost occurrence
        ///     of the character in the string.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 direction:in */
        private static extern System.Byte* g_utf8_strchr(
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.Byte* p,
        /* <type name="gssize" type="gssize" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr len,
        /* <type name="gunichar" type="gunichar" managed-name="GISharp.Lib.GLib.Unichar" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Unichar c);

        /// <summary>
        /// Converts all Unicode characters in the string that have a case
        /// to lowercase. The exact manner that this is done depends
        /// on the current locale, and may result in the number of
        /// characters in the string changing.
        /// </summary>
        /// <param name="str">
        /// a UTF-8 encoded string
        /// </param>
        /// <param name="len">
        /// length of @str, in bytes, or -1 if @str is nul-terminated.
        /// </param>
        /// <returns>
        /// a newly allocated string, with all characters
        ///    converted to lowercase.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern System.Byte* g_utf8_strdown(
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.Byte* str,
        /* <type name="gssize" type="gssize" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr len);

        /// <summary>
        /// Computes the length of the string in characters, not including
        /// the terminating nul character. If the @max'th byte falls in the
        /// middle of a character, the last (partial) character is not counted.
        /// </summary>
        /// <param name="p">
        /// pointer to the start of a UTF-8 encoded string
        /// </param>
        /// <param name="max">
        /// the maximum number of bytes to examine. If @max
        ///       is less than 0, then the string is assumed to be
        ///       nul-terminated. If @max is 0, @p will not be examined and
        ///       may be %NULL. If @max is greater than 0, up to @max
        ///       bytes are examined
        /// </param>
        /// <returns>
        /// the length of the string in characters
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="glong" type="glong" managed-name="GISharp.Runtime.CLong" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.CLong g_utf8_strlen(
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.Byte* p,
        /* <type name="gssize" type="gssize" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr max);

        /// <summary>
        /// Like the standard C strncpy() function, but copies a given number
        /// of characters instead of a given number of bytes. The @src string
        /// must be valid UTF-8 encoded text. (Use g_utf8_validate() on all
        /// text before trying to use UTF-8 utility functions with it.)
        /// </summary>
        /// <remarks>
        /// Note you must ensure @dest is at least 4 * @n to fit the
        /// largest possible UTF-8 characters
        /// </remarks>
        /// <param name="dest">
        /// buffer to fill with characters from @src
        /// </param>
        /// <param name="src">
        /// UTF-8 encoded string
        /// </param>
        /// <param name="n">
        /// character count
        /// </param>
        /// <returns>
        /// @dest
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        private static extern System.Byte* g_utf8_strncpy(
        /* <type name="utf8" type="gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.Byte* dest,
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.Byte* src,
        /* <type name="gsize" type="gsize" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        System.UIntPtr n);

        /// <summary>
        /// Find the rightmost occurrence of the given Unicode character
        /// in a UTF-8 encoded string, while limiting the search to @len bytes.
        /// If @len is -1, allow unbounded search.
        /// </summary>
        /// <param name="p">
        /// a nul-terminated UTF-8 encoded string
        /// </param>
        /// <param name="len">
        /// the maximum length of @p
        /// </param>
        /// <param name="c">
        /// a Unicode character
        /// </param>
        /// <returns>
        /// %NULL if the string does not contain the character,
        ///     otherwise, a pointer to the start of the rightmost occurrence
        ///     of the character in the string.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 direction:in */
        private static extern System.Byte* g_utf8_strrchr(
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.Byte* p,
        /* <type name="gssize" type="gssize" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr len,
        /* <type name="gunichar" type="gunichar" managed-name="GISharp.Lib.GLib.Unichar" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GLib.Unichar c);

        /// <summary>
        /// Reverses a UTF-8 string. @str must be valid UTF-8 encoded text.
        /// (Use g_utf8_validate() on all text before trying to use UTF-8
        /// utility functions with it.)
        /// </summary>
        /// <remarks>
        /// This function is intended for programmatic uses of reversed strings.
        /// It pays no attention to decomposed characters, combining marks, byte
        /// order marks, directional indicators (LRM, LRO, etc) and similar
        /// characters which might need special handling when reversing a string
        /// for display purposes.
        /// 
        /// Note that unlike g_strreverse(), this function returns
        /// newly-allocated memory, which should be freed with g_free() when
        /// no longer needed.
        /// </remarks>
        /// <param name="str">
        /// a UTF-8 encoded string
        /// </param>
        /// <param name="len">
        /// the maximum length of @str to use, in bytes. If @len &lt; 0,
        ///     then the string is nul-terminated.
        /// </param>
        /// <returns>
        /// a newly-allocated string which is the reverse of @str
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.2")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern System.Byte* g_utf8_strreverse(
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.Byte* str,
        /* <type name="gssize" type="gssize" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr len);

        /// <summary>
        /// Converts all Unicode characters in the string that have a case
        /// to uppercase. The exact manner that this is done depends
        /// on the current locale, and may result in the number of
        /// characters in the string increasing. (For instance, the
        /// German ess-zet will be changed to SS.)
        /// </summary>
        /// <param name="str">
        /// a UTF-8 encoded string
        /// </param>
        /// <param name="len">
        /// length of @str, in bytes, or -1 if @str is nul-terminated.
        /// </param>
        /// <returns>
        /// a newly allocated string, with all characters
        ///    converted to uppercase.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern System.Byte* g_utf8_strup(
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.Byte* str,
        /* <type name="gssize" type="gssize" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr len);

        /// <summary>
        /// Copies a substring out of a UTF-8 encoded string.
        /// The substring will contain @end_pos - @start_pos characters.
        /// </summary>
        /// <param name="str">
        /// a UTF-8 encoded string
        /// </param>
        /// <param name="startPos">
        /// a character offset within @str
        /// </param>
        /// <param name="endPos">
        /// another character offset within @str
        /// </param>
        /// <returns>
        /// a newly allocated copy of the requested
        ///     substring. Free with g_free() when no longer needed.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.30")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern System.Byte* g_utf8_substring(
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.Byte* str,
        /* <type name="glong" type="glong" managed-name="GISharp.Runtime.CLong" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.CLong startPos,
        /* <type name="glong" type="glong" managed-name="GISharp.Runtime.CLong" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.CLong endPos);
        static partial void CheckSubstringArgs(this GISharp.Lib.GLib.UnownedUtf8 str, GISharp.Runtime.CLong startPos, GISharp.Runtime.CLong endPos);

        /// <include file="Utf8Extensions.xmldoc" path="declaration/member[@name='Utf8Extensions.Substring(GISharp.Lib.GLib.UnownedUtf8,GISharp.Runtime.CLong,GISharp.Runtime.CLong)']/*" />
        [GISharp.Runtime.SinceAttribute("2.30")]
        public static GISharp.Lib.GLib.Utf8 Substring(this GISharp.Lib.GLib.UnownedUtf8 str, GISharp.Runtime.CLong startPos, GISharp.Runtime.CLong endPos)
        {
            CheckSubstringArgs(str, startPos, endPos);
            var str_ = (System.Byte*)str.UnsafeHandle;
            var startPos_ = (GISharp.Runtime.CLong)startPos;
            var endPos_ = (GISharp.Runtime.CLong)endPos;
            var ret_ = g_utf8_substring(str_,startPos_,endPos_);
            var ret = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Utf8>((System.IntPtr)ret_, GISharp.Runtime.Transfer.Full)!;
            return ret;
        }

        /// <summary>
        /// Convert a string from UTF-8 to a 32-bit fixed width
        /// representation as UCS-4. A trailing 0 character will be added to the
        /// string after the converted text.
        /// </summary>
        /// <param name="str">
        /// a UTF-8 encoded string
        /// </param>
        /// <param name="len">
        /// the maximum length of @str to use, in bytes. If @len &lt; 0,
        ///     then the string is nul-terminated.
        /// </param>
        /// <param name="itemsRead">
        /// location to store number of
        ///    bytes read, or %NULL.
        ///     If %NULL, then %G_CONVERT_ERROR_PARTIAL_INPUT will be
        ///     returned in case @str contains a trailing partial
        ///     character. If an error occurs then the index of the
        ///     invalid input is stored here.
        /// </param>
        /// <param name="itemsWritten">
        /// location to store number
        ///     of characters written or %NULL. The value here stored does not include
        ///     the trailing 0 character.
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// a pointer to a newly allocated UCS-4 string.
        ///     This value must be freed with g_free(). If an error occurs,
        ///     %NULL will be returned and @error set.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gunichar" type="gunichar*" managed-name="GISharp.Lib.GLib.Unichar" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GLib.Unichar* g_utf8_to_ucs4(
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.Byte* str,
        /* <type name="glong" type="glong" managed-name="GISharp.Runtime.CLong" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.CLong len,
        /* <type name="glong" type="glong*" managed-name="GISharp.Runtime.CLong" /> */
        /* direction:out caller-allocates:1 transfer-ownership:none optional:1 allow-none:1 */
        GISharp.Runtime.CLong* itemsRead,
        /* <type name="glong" type="glong*" managed-name="GISharp.Runtime.CLong" /> */
        /* direction:out caller-allocates:1 transfer-ownership:none optional:1 allow-none:1 */
        GISharp.Runtime.CLong* itemsWritten,
        /* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Convert a string from UTF-8 to a 32-bit fixed width
        /// representation as UCS-4, assuming valid UTF-8 input.
        /// This function is roughly twice as fast as g_utf8_to_ucs4()
        /// but does no error checking on the input. A trailing 0 character
        /// will be added to the string after the converted text.
        /// </summary>
        /// <param name="str">
        /// a UTF-8 encoded string
        /// </param>
        /// <param name="len">
        /// the maximum length of @str to use, in bytes. If @len &lt; 0,
        ///     then the string is nul-terminated.
        /// </param>
        /// <param name="itemsWritten">
        /// location to store the
        ///     number of characters in the result, or %NULL.
        /// </param>
        /// <returns>
        /// a pointer to a newly allocated UCS-4 string.
        ///     This value must be freed with g_free().
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gunichar" type="gunichar*" managed-name="GISharp.Lib.GLib.Unichar" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern GISharp.Lib.GLib.Unichar* g_utf8_to_ucs4_fast(
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.Byte* str,
        /* <type name="glong" type="glong" managed-name="GISharp.Runtime.CLong" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.CLong len,
        /* <type name="glong" type="glong*" managed-name="GISharp.Runtime.CLong" /> */
        /* direction:out caller-allocates:1 transfer-ownership:none optional:1 allow-none:1 */
        GISharp.Runtime.CLong* itemsWritten);

        /// <summary>
        /// Convert a string from UTF-8 to UTF-16. A 0 character will be
        /// added to the result after the converted text.
        /// </summary>
        /// <param name="str">
        /// a UTF-8 encoded string
        /// </param>
        /// <param name="len">
        /// the maximum length (number of bytes) of @str to use.
        ///     If @len &lt; 0, then the string is nul-terminated.
        /// </param>
        /// <param name="itemsRead">
        /// location to store number of
        ///     bytes read, or %NULL. If %NULL, then %G_CONVERT_ERROR_PARTIAL_INPUT will
        ///     be returned in case @str contains a trailing partial character. If
        ///     an error occurs then the index of the invalid input is stored here.
        /// </param>
        /// <param name="itemsWritten">
        /// location to store number
        ///     of #gunichar2 written, or %NULL. The value stored here does not include
        ///     the trailing 0.
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// a pointer to a newly allocated UTF-16 string.
        ///     This value must be freed with g_free(). If an error occurs,
        ///     %NULL will be returned and @error set.
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="guint16" type="gunichar2*" managed-name="System.UInt16" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        private static extern System.UInt16* g_utf8_to_utf16(
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.Byte* str,
        /* <type name="glong" type="glong" managed-name="GISharp.Runtime.CLong" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.CLong len,
        /* <type name="glong" type="glong*" managed-name="GISharp.Runtime.CLong" /> */
        /* direction:out caller-allocates:1 transfer-ownership:none optional:1 allow-none:1 */
        GISharp.Runtime.CLong* itemsRead,
        /* <type name="glong" type="glong*" managed-name="GISharp.Runtime.CLong" /> */
        /* direction:out caller-allocates:1 transfer-ownership:none optional:1 allow-none:1 */
        GISharp.Runtime.CLong* itemsWritten,
        /* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        GISharp.Lib.GLib.Error.UnmanagedStruct** error);

        /// <summary>
        /// Validates UTF-8 encoded text. @str is the text to validate;
        /// if @str is nul-terminated, then @max_len can be -1, otherwise
        /// @max_len should be the number of bytes to validate.
        /// If @end is non-%NULL, then the end of the valid range
        /// will be stored there (i.e. the start of the first invalid
        /// character if some bytes were invalid, or the end of the text
        /// being validated otherwise).
        /// </summary>
        /// <remarks>
        /// Note that g_utf8_validate() returns %FALSE if @max_len is
        /// positive and any of the @max_len bytes are nul.
        /// 
        /// Returns %TRUE if all of @str was valid. Many GLib and GTK+
        /// routines require valid UTF-8 as input; so data read from a file
        /// or the network should be checked with g_utf8_validate() before
        /// doing anything else with it.
        /// </remarks>
        /// <param name="str">
        /// a pointer to character data
        /// </param>
        /// <param name="maxLen">
        /// max bytes to validate, or -1 to go until NUL
        /// </param>
        /// <param name="end">
        /// return location for end of valid data
        /// </param>
        /// <returns>
        /// %TRUE if the text was valid UTF-8
        /// </returns>
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_utf8_validate(
        /* <array length="1" zero-terminated="0" type="const gchar*" managed-name="GISharp.Runtime.CArray" is-pointer="1">
*   <type name="guint8" managed-name="System.Byte" />
* </array> */
        /* transfer-ownership:none direction:in */
        System.Byte* str,
        /* <type name="gssize" type="gssize" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr maxLen,
        /* <type name="utf8" type="const gchar**" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* direction:out caller-allocates:0 transfer-ownership:none optional:1 allow-none:1 */
        System.Byte** end);

        /// <summary>
        /// Validates UTF-8 encoded text.
        /// </summary>
        /// <remarks>
        /// As with g_utf8_validate(), but @max_len must be set, and hence this function
        /// will always return %FALSE if any of the bytes of @str are nul.
        /// </remarks>
        /// <param name="str">
        /// a pointer to character data
        /// </param>
        /// <param name="maxLen">
        /// max bytes to validate
        /// </param>
        /// <param name="end">
        /// return location for end of valid data
        /// </param>
        /// <returns>
        /// %TRUE if the text was valid UTF-8
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.60")]
        [System.Runtime.InteropServices.DllImportAttribute("glib-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        private static extern GISharp.Runtime.Boolean g_utf8_validate_len(
        /* <array length="1" zero-terminated="0" type="const gchar*" managed-name="GISharp.Runtime.CArray" is-pointer="1">
*   <type name="guint8" managed-name="System.Byte" />
* </array> */
        /* transfer-ownership:none direction:in */
        System.Byte* str,
        /* <type name="gsize" type="gsize" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        System.UIntPtr maxLen,
        /* <type name="utf8" type="const gchar**" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* direction:out caller-allocates:0 transfer-ownership:none optional:1 allow-none:1 */
        System.Byte** end);
    }
}