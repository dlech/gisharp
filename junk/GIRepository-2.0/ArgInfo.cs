// SPDX-License-Identifier: MIT
// Copyright (c) 2015-2020 David Lechner <david@lechnology.com>

// This file was originally generated by the Gtk# (gapi3) code generator.
// It is now maintained by hand.

using System;
using System.Linq;
using System.Runtime.InteropServices;
using GISharp.Runtime;

namespace GISharp.Lib.GIRepository
{
    /// <summary>
    /// Struct representing an argument.
    /// </summary>
    /// <remarks>
    /// <see cref="ArgInfo"/> represents an argument. An argument is always part
    /// of a <see cref="CallbackInfo"/>.
    /// </remarks>
    public sealed class ArgInfo : BaseInfo
    {
        [DllImport("libgirepository-1.0", CallingConvention = CallingConvention.Cdecl)]
        static extern int g_arg_info_get_closure(IntPtr raw);

        /// <summary>
        /// Obtain the index of the user data argument. This is only valid for
        /// arguments which are callbacks.
        /// </summary>
        /// <value>Index of the user data argument or -1 if there is none.</value>
        public int ClosureIndex {
            get {
                return g_arg_info_get_closure(UnsafeHandle);
            }
        }

        readonly Lazy<ArgInfo?> _Closure;
        public ArgInfo? Closure => _Closure.Value;

        [DllImport("libgirepository-1.0", CallingConvention = CallingConvention.Cdecl)]
        static extern int g_arg_info_get_destroy(IntPtr raw);

        /// <summary>
        /// Obtains the index of the <see cref="GLib.UnmanagedDestroyNotify"/>
        /// argument. This is only valid for arguments which are callbacks.
        /// </summary>
        /// <value>Index of the <see cref="GLib.UnmanagedDestroyNotify"/> argument
        /// or -1 if there is none.</value>
        public int DestroyIndex {
            get {
                return g_arg_info_get_destroy(UnsafeHandle);
            }
        }

        readonly Lazy<ArgInfo?> _Destroy;
        public ArgInfo? Destroy => _Destroy.Value;

        readonly Lazy<ArgInfo?> _ArrayLength;
        public ArgInfo? ArrayLength => _ArrayLength.Value;

        [DllImport("libgirepository-1.0", CallingConvention = CallingConvention.Cdecl)]
        static extern Direction g_arg_info_get_direction(IntPtr raw);

        public Direction Direction {
            get {
                return g_arg_info_get_direction(UnsafeHandle);
            }
        }

        [DllImport("libgirepository-1.0", CallingConvention = CallingConvention.Cdecl)]
        static extern Transfer g_arg_info_get_ownership_transfer(IntPtr raw);

        public Transfer OwnershipTransfer {
            get {
                return g_arg_info_get_ownership_transfer(UnsafeHandle);
            }
        }

        [DllImport("libgirepository-1.0", CallingConvention = CallingConvention.Cdecl)]
        static extern ScopeType g_arg_info_get_scope(IntPtr raw);

        public ScopeType Scope {
            get {
                return g_arg_info_get_scope(UnsafeHandle);
            }
        }

        [DllImport("libgirepository-1.0", CallingConvention = CallingConvention.Cdecl)]
        static extern IntPtr g_arg_info_get_type(IntPtr raw);

        public TypeInfo TypeInfo {
            get {
                IntPtr raw_ret = g_arg_info_get_type(UnsafeHandle);
                return GetInstance<TypeInfo>(raw_ret);
            }
        }

        [DllImport("libgirepository-1.0", CallingConvention = CallingConvention.Cdecl)]
        static extern Runtime.Boolean g_arg_info_is_caller_allocates(IntPtr raw);

        public bool IsCallerAllocates {
            get {
                var ret_ = g_arg_info_is_caller_allocates(UnsafeHandle);
                var ret = ret_.IsTrue();
                return ret;
            }
        }

        [DllImport("libgirepository-1.0", CallingConvention = CallingConvention.Cdecl)]
        static extern Runtime.Boolean g_arg_info_is_optional(IntPtr raw);

        public bool IsOptional {
            get {
                var ret_ = g_arg_info_is_optional(UnsafeHandle);
                var ret = ret_.IsTrue();
                return ret;
            }
        }

        [DllImport("libgirepository-1.0", CallingConvention = CallingConvention.Cdecl)]
        static extern Runtime.Boolean g_arg_info_is_return_value(IntPtr raw);

        public bool IsReturnValue {
            get {
                var ret_ = g_arg_info_is_return_value(UnsafeHandle);
                var ret = ret_.IsTrue();
                return ret;
            }
        }

        [DllImport("libgirepository-1.0", CallingConvention = CallingConvention.Cdecl)]
        static extern Runtime.Boolean g_arg_info_is_skip(IntPtr raw);

        public bool IsSkip {
            get {
                var ret_ = g_arg_info_is_skip(UnsafeHandle);
                var ret = ret_.IsTrue();
                return ret;
            }
        }

        [DllImport("libgirepository-1.0", CallingConvention = CallingConvention.Cdecl)]
        static extern void g_arg_info_load_type(IntPtr raw, IntPtr type);

        void LoadType(TypeInfo type)
        {
            g_arg_info_load_type(UnsafeHandle, type is null ? IntPtr.Zero : type.UnsafeHandle);
        }

        [DllImport("libgirepository-1.0", CallingConvention = CallingConvention.Cdecl)]
        static extern Runtime.Boolean g_arg_info_may_be_null(IntPtr raw);

        public bool MayBeNull {
            get {
                var ret_ = g_arg_info_may_be_null(UnsafeHandle);
                var ret = ret_.IsTrue();
                return ret;
            }
        }

        readonly Lazy<int> _Index;
        public int Index { get { return _Index.Value; } }

        readonly Lazy<int> _InIndex;
        public int InIndex { get { return _InIndex.Value; } }

        readonly Lazy<int> _OutIndex;
        public int OutIndex { get { return _OutIndex.Value; } }


        public ArgInfo(IntPtr raw) : base(raw)
        {
            var callable = (CallableInfo)Container!;
            _Closure = new(() =>
                callable.Args.ElementAtOrDefault(ClosureIndex));
            _Destroy = new(() =>
                callable.Args.ElementAtOrDefault(DestroyIndex));
            _ArrayLength = new(() =>
                callable.Args.ElementAtOrDefault(TypeInfo.ArrayLengthIndex));
            _Index = new(() => callable.Args.IndexOf(this));
            _InIndex = new(() => callable.InArgs.IndexOf(this));
            _OutIndex = new(() => callable.OutArgs.IndexOf(this));
        }
    }
}
