<declaration>

<member name='ActionAdded'>
<summary>
Signals that a new action was just added to the group.
This signal is emitted after the action has been added
and is now visible.
</summary>
</member>

<member name='ActionEnabledChanged'>
<summary>
Signals that the enabled status of the named action has changed.
</summary>
</member>

<member name='ActionRemoved'>
<summary>
Signals that an action is just about to be removed from the group.
This signal is emitted before the action is removed, so the action
is still visible and can be queried from the signal handler.
</summary>
</member>

<member name='ActionStateChanged'>
<summary>
Signals that the state of the named action has changed.
</summary>
</member>

<member name='DoActionAdded(GISharp.Lib.GLib.UnownedUtf8)'>
<summary>
Emits the <see cref="IActionGroup"/>::action-added signal on this instance.
</summary>
<remarks>
This function should only be called by <see cref="IActionGroup"/> implementations.
</remarks>
<param name="actionName">
the name of an action in the group
</param>
</member>

<member name='DoActionEnabledChanged(GISharp.Lib.GLib.UnownedUtf8,System.Boolean)'>
<summary>
Emits the <see cref="IActionGroup"/>::action-enabled-changed signal on this instance.
</summary>
<remarks>
This function should only be called by <see cref="IActionGroup"/> implementations.
</remarks>
<param name="actionName">
the name of an action in the group
</param>
<param name="enabled">
whether or not the action is now enabled
</param>
</member>

<member name='DoActionRemoved(GISharp.Lib.GLib.UnownedUtf8)'>
<summary>
Emits the <see cref="IActionGroup"/>::action-removed signal on this instance.
</summary>
<remarks>
This function should only be called by <see cref="IActionGroup"/> implementations.
</remarks>
<param name="actionName">
the name of an action in the group
</param>
</member>

<member name='DoActionStateChanged(GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.GLib.Variant)'>
<summary>
Emits the <see cref="IActionGroup"/>::action-state-changed signal on this instance.
</summary>
<remarks>
This function should only be called by <see cref="IActionGroup"/> implementations.
</remarks>
<param name="actionName">
the name of an action in the group
</param>
<param name="state">
the new state of the named action
</param>
</member>

<member name='DoActivateAction(GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.GLib.Variant?)'>
<summary>
Activate the named action within this instance.
</summary>
<remarks>
If the action is expecting a parameter, then the correct type of
parameter must be given as this instance.  If the action is expecting no
parameters then this instance must be <c>null</c>.  See
<see cref="M:ActionGroup.GetActionParameterType(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.Utf8)"/>.
</remarks>
<param name="actionName">
the name of the action to activate
</param>
<param name="parameter">
parameters to the activation
</param>
</member>

<member name='DoChangeActionState(GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.GLib.Variant)'>
<summary>
Request for the state of the named action within this instance to be
changed to this instance.
</summary>
<remarks>
The action must be stateful and this instance must be of the correct type.
See <see cref="M:ActionGroup.GetActionStateType(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.Utf8)"/>.

This call merely requests a change.  The action may refuse to change
its state or may change its state to something other than this instance.
See <see cref="M:ActionGroup.GetActionStateHint(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.Utf8)"/>.

If the this instance GVariant is floating, it is consumed.
</remarks>
<param name="actionName">
the name of the action to request the change on
</param>
<param name="value">
the new state
</param>
</member>

<member name='DoGetActionEnabled(GISharp.Lib.GLib.UnownedUtf8)'>
<summary>
Checks if the named action within this instance is currently enabled.
</summary>
<remarks>
An action must be enabled in order to be activated or in order to
have its state changed from outside callers.
</remarks>
<param name="actionName">
the name of the action to query
</param>
<returns>
whether or not the action is currently enabled
</returns>
</member>

<member name='DoGetActionParameterType(GISharp.Lib.GLib.UnownedUtf8)'>
<summary>
Queries the type of the parameter that must be given when activating
the named action within this instance.
</summary>
<remarks>
When activating the action using <see cref="M:ActionGroup.ActivateAction(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.Utf8,GISharp.Lib.GLib.Variant)"/>,
the <see cref="GLib.Variant"/> given to that function must be of the type returned
by this function.

In the case that this function returns <c>null</c>, you must not give any
<see cref="GLib.Variant"/>, but <c>null</c> instead.

The parameter type of a particular action will never change but it is
possible for an action to be removed and for a new action to be added
with the same name but a different parameter type.
</remarks>
<param name="actionName">
the name of the action to query
</param>
<returns>
the parameter type
</returns>
</member>

<member name='DoGetActionState(GISharp.Lib.GLib.UnownedUtf8)'>
<summary>
Queries the current state of the named action within this instance.
</summary>
<remarks>
If the action is not stateful then <c>null</c> will be returned.  If the
action is stateful then the type of the return value is the type
given by <see cref="M:ActionGroup.GetActionStateType(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.Utf8)"/>.

The return value (if non-<c>null</c>) should be freed with
g_variant_unref() when it is no longer required.
</remarks>
<param name="actionName">
the name of the action to query
</param>
<returns>
the current state of the action
</returns>
</member>

<member name='DoGetActionStateHint(GISharp.Lib.GLib.UnownedUtf8)'>
<summary>
Requests a hint about the valid range of values for the state of the
named action within this instance.
</summary>
<remarks>
If <c>null</c> is returned it either means that the action is not stateful
or that there is no hint about the valid range of values for the
state of the action.

If a <see cref="GLib.Variant"/> array is returned then each item in the array is a
possible value for the state.  If a <see cref="GLib.Variant"/> pair (ie: two-tuple) is
returned then the tuple specifies the inclusive lower and upper bound
of valid values for the state.

In any case, the information is merely a hint.  It may be possible to
have a state value outside of the hinted range and setting a value
within the range may fail.

The return value (if non-<c>null</c>) should be freed with
g_variant_unref() when it is no longer required.
</remarks>
<param name="actionName">
the name of the action to query
</param>
<returns>
the state range hint
</returns>
</member>

<member name='DoGetActionStateType(GISharp.Lib.GLib.UnownedUtf8)'>
<summary>
Queries the type of the state of the named action within
this instance.
</summary>
<remarks>
If the action is stateful then this function returns the
<see cref="GLib.VariantType"/> of the state.  All calls to
<see cref="M:ActionGroup.ChangeActionState(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.Utf8,GISharp.Lib.GLib.Variant)"/> must give a <see cref="GLib.Variant"/> of this
type and <see cref="M:ActionGroup.GetActionState(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.Utf8)"/> will return a <see cref="GLib.Variant"/>
of the same type.

If the action is not stateful then this function will return <c>null</c>.
In that case, <see cref="M:ActionGroup.GetActionState(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.Utf8)"/> will return <c>null</c>
and you must not call <see cref="M:ActionGroup.ChangeActionState(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.Utf8,GISharp.Lib.GLib.Variant)"/>.

The state type of a particular action will never change but it is
possible for an action to be removed and for a new action to be added
with the same name but a different state type.
</remarks>
<param name="actionName">
the name of the action to query
</param>
<returns>
the state type, if the action is stateful
</returns>
</member>

<member name='DoHasAction(GISharp.Lib.GLib.UnownedUtf8)'>
<summary>
Checks if the named action exists within this instance.
</summary>
<param name="actionName">
the name of the action to check for
</param>
<returns>
whether the named action exists
</returns>
</member>

<member name='DoListActions()'>
<summary>
Lists the actions contained within this instance.
</summary>
<remarks>
The caller is responsible for freeing the list with g_strfreev() when
it is no longer required.
</remarks>
<returns>
a <c>null</c>-terminated array of the names of the
actions in the group
</returns>
</member>

<member name='IActionGroup'>
<summary>
<see cref="IActionGroup"/> represents a group of actions. Actions can be used to
expose functionality in a structured way, either from one part of a
program to another, or to the outside world. Action groups are often
used together with a #GMenuModel that provides additional
representation data for displaying the actions to the user, e.g. in
a menu.
</summary>
<remarks>
The main way to interact with the actions in a GActionGroup is to
activate them with <see cref="M:ActionGroup.ActivateAction(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.Utf8,GISharp.Lib.GLib.Variant)"/>. Activating an
action may require a <see cref="GLib.Variant"/> parameter. The required type of the
parameter can be inquired with <see cref="M:ActionGroup.GetActionParameterType(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.Utf8)"/>.
Actions may be disabled, see <see cref="M:ActionGroup.GetActionEnabled(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.Utf8)"/>.
Activating a disabled action has no effect.

Actions may optionally have a state in the form of a <see cref="GLib.Variant"/>. The
current state of an action can be inquired with
<see cref="M:ActionGroup.GetActionState(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.Utf8)"/>. Activating a stateful action may
change its state, but it is also possible to set the state by calling
<see cref="M:ActionGroup.ChangeActionState(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.Utf8,GISharp.Lib.GLib.Variant)"/>.

As typical example, consider a text editing application which has an
option to change the current font to 'bold'. A good way to represent
this would be a stateful action, with a boolean state. Activating the
action would toggle the state.

Each action in the group has a unique name (which is a string).  All
method calls, except <see cref="M:ActionGroup.ListActions(GISharp.Lib.Gio.IActionGroup)"/> take the name of
an action as an argument.

The <see cref="IActionGroup"/> API is meant to be the 'public' API to the action
group.  The calls here are exactly the interaction that 'external
forces' (eg: UI, incoming D-Bus messages, etc.) are supposed to have
with actions.  'Internal' APIs (ie: ones meant only to be accessed by
the action group implementation) are found on subclasses.  This is
why you will find - for example - <see cref="M:ActionGroup.GetActionEnabled(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.Utf8)"/>
but not an equivalent set() call.

Signals are emitted on the action group in response to state changes
on individual actions.

Implementations of <see cref="IActionGroup"/> should provide implementations for
the virtual functions <see cref="M:ActionGroup.ListActions(GISharp.Lib.Gio.IActionGroup)"/> and
<see cref="M:ActionGroup.TryQueryAction(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.Utf8,System.Boolean,GISharp.Lib.GLib.VariantType,GISharp.Lib.GLib.VariantType,GISharp.Lib.GLib.Variant,GISharp.Lib.GLib.Variant)"/>.  The other virtual functions should
not be implemented - their "wrappers" are actually implemented with
calls to <see cref="M:ActionGroup.TryQueryAction(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.Utf8,System.Boolean,GISharp.Lib.GLib.VariantType,GISharp.Lib.GLib.VariantType,GISharp.Lib.GLib.Variant,GISharp.Lib.GLib.Variant)"/>.
</remarks>
</member>

<member name='ActionName'>
<summary>
the name of the action in this action group
</summary>
</member>

<member name='ActionAddedEventArgs'>
<summary>
Signals that a new action was just added to the group.
This signal is emitted after the action has been added
and is now visible.
</summary>
</member>

<member name='ActionName'>
<summary>
the name of the action in this action group
</summary>
</member>

<member name='Enabled'>
<summary>
whether the action is enabled or not
</summary>
</member>

<member name='ActionEnabledChangedEventArgs'>
<summary>
Signals that the enabled status of the named action has changed.
</summary>
</member>

<member name='ActionName'>
<summary>
the name of the action in this action group
</summary>
</member>

<member name='ActionRemovedEventArgs'>
<summary>
Signals that an action is just about to be removed from the group.
This signal is emitted before the action is removed, so the action
is still visible and can be queried from the signal handler.
</summary>
</member>

<member name='ActionName'>
<summary>
the name of the action in this action group
</summary>
</member>

<member name='Value'>
<summary>
the new value of the state
</summary>
</member>

<member name='ActionStateChangedEventArgs'>
<summary>
Signals that the state of the named action has changed.
</summary>
</member>

<member name='ActionAdded(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.UnownedUtf8)'>
<summary>
Emits the <see cref="IActionGroup"/>::action-added signal on this instance.
</summary>
<remarks>
This function should only be called by <see cref="IActionGroup"/> implementations.
</remarks>
<param name="actionGroup">
a <see cref="IActionGroup"/>
</param>
<param name="actionName">
the name of an action in the group
</param>
</member>

<member name='ActionAdded(GISharp.Lib.Gio.IActionGroup,System.String)'>
<summary>
Emits the <see cref="IActionGroup"/>::action-added signal on this instance.
</summary>
<remarks>
This function should only be called by <see cref="IActionGroup"/> implementations.
</remarks>
<param name="actionGroup">
a <see cref="IActionGroup"/>
</param>
<param name="actionName">
the name of an action in the group
</param>
</member>

<member name='ActionEnabledChanged(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.UnownedUtf8,System.Boolean)'>
<summary>
Emits the <see cref="IActionGroup"/>::action-enabled-changed signal on this instance.
</summary>
<remarks>
This function should only be called by <see cref="IActionGroup"/> implementations.
</remarks>
<param name="actionGroup">
a <see cref="IActionGroup"/>
</param>
<param name="actionName">
the name of an action in the group
</param>
<param name="enabled">
whether or not the action is now enabled
</param>
</member>

<member name='ActionEnabledChanged(GISharp.Lib.Gio.IActionGroup,System.String,System.Boolean)'>
<summary>
Emits the <see cref="IActionGroup"/>::action-enabled-changed signal on this instance.
</summary>
<remarks>
This function should only be called by <see cref="IActionGroup"/> implementations.
</remarks>
<param name="actionGroup">
a <see cref="IActionGroup"/>
</param>
<param name="actionName">
the name of an action in the group
</param>
<param name="enabled">
whether or not the action is now enabled
</param>
</member>

<member name='ActionRemoved(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.UnownedUtf8)'>
<summary>
Emits the <see cref="IActionGroup"/>::action-removed signal on this instance.
</summary>
<remarks>
This function should only be called by <see cref="IActionGroup"/> implementations.
</remarks>
<param name="actionGroup">
a <see cref="IActionGroup"/>
</param>
<param name="actionName">
the name of an action in the group
</param>
</member>

<member name='ActionRemoved(GISharp.Lib.Gio.IActionGroup,System.String)'>
<summary>
Emits the <see cref="IActionGroup"/>::action-removed signal on this instance.
</summary>
<remarks>
This function should only be called by <see cref="IActionGroup"/> implementations.
</remarks>
<param name="actionGroup">
a <see cref="IActionGroup"/>
</param>
<param name="actionName">
the name of an action in the group
</param>
</member>

<member name='ActionStateChanged(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.GLib.Variant)'>
<summary>
Emits the <see cref="IActionGroup"/>::action-state-changed signal on this instance.
</summary>
<remarks>
This function should only be called by <see cref="IActionGroup"/> implementations.
</remarks>
<param name="actionGroup">
a <see cref="IActionGroup"/>
</param>
<param name="actionName">
the name of an action in the group
</param>
<param name="state">
the new state of the named action
</param>
</member>

<member name='ActionStateChanged(GISharp.Lib.Gio.IActionGroup,System.String,GISharp.Lib.GLib.Variant)'>
<summary>
Emits the <see cref="IActionGroup"/>::action-state-changed signal on this instance.
</summary>
<remarks>
This function should only be called by <see cref="IActionGroup"/> implementations.
</remarks>
<param name="actionGroup">
a <see cref="IActionGroup"/>
</param>
<param name="actionName">
the name of an action in the group
</param>
<param name="state">
the new state of the named action
</param>
</member>

<member name='ActivateAction(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.GLib.Variant?)'>
<summary>
Activate the named action within this instance.
</summary>
<remarks>
If the action is expecting a parameter, then the correct type of
parameter must be given as this instance.  If the action is expecting no
parameters then this instance must be <c>null</c>.  See
<see cref="M:ActionGroup.GetActionParameterType(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.Utf8)"/>.
</remarks>
<param name="actionGroup">
a <see cref="IActionGroup"/>
</param>
<param name="actionName">
the name of the action to activate
</param>
<param name="parameter">
parameters to the activation
</param>
</member>

<member name='ActivateAction(GISharp.Lib.Gio.IActionGroup,System.String,GISharp.Lib.GLib.Variant?)'>
<summary>
Activate the named action within this instance.
</summary>
<remarks>
If the action is expecting a parameter, then the correct type of
parameter must be given as this instance.  If the action is expecting no
parameters then this instance must be <c>null</c>.  See
<see cref="M:ActionGroup.GetActionParameterType(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.Utf8)"/>.
</remarks>
<param name="actionGroup">
a <see cref="IActionGroup"/>
</param>
<param name="actionName">
the name of the action to activate
</param>
<param name="parameter">
parameters to the activation
</param>
</member>

<member name='ChangeActionState(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.UnownedUtf8,GISharp.Lib.GLib.Variant)'>
<summary>
Request for the state of the named action within this instance to be
changed to this instance.
</summary>
<remarks>
The action must be stateful and this instance must be of the correct type.
See <see cref="M:ActionGroup.GetActionStateType(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.Utf8)"/>.

This call merely requests a change.  The action may refuse to change
its state or may change its state to something other than this instance.
See <see cref="M:ActionGroup.GetActionStateHint(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.Utf8)"/>.

If the this instance GVariant is floating, it is consumed.
</remarks>
<param name="actionGroup">
a <see cref="IActionGroup"/>
</param>
<param name="actionName">
the name of the action to request the change on
</param>
<param name="value">
the new state
</param>
</member>

<member name='ChangeActionState(GISharp.Lib.Gio.IActionGroup,System.String,GISharp.Lib.GLib.Variant)'>
<summary>
Request for the state of the named action within this instance to be
changed to this instance.
</summary>
<remarks>
The action must be stateful and this instance must be of the correct type.
See <see cref="M:ActionGroup.GetActionStateType(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.Utf8)"/>.

This call merely requests a change.  The action may refuse to change
its state or may change its state to something other than this instance.
See <see cref="M:ActionGroup.GetActionStateHint(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.Utf8)"/>.

If the this instance GVariant is floating, it is consumed.
</remarks>
<param name="actionGroup">
a <see cref="IActionGroup"/>
</param>
<param name="actionName">
the name of the action to request the change on
</param>
<param name="value">
the new state
</param>
</member>

<member name='GetActionEnabled(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.UnownedUtf8)'>
<summary>
Checks if the named action within this instance is currently enabled.
</summary>
<remarks>
An action must be enabled in order to be activated or in order to
have its state changed from outside callers.
</remarks>
<param name="actionGroup">
a <see cref="IActionGroup"/>
</param>
<param name="actionName">
the name of the action to query
</param>
<returns>
whether or not the action is currently enabled
</returns>
</member>

<member name='GetActionEnabled(GISharp.Lib.Gio.IActionGroup,System.String)'>
<summary>
Checks if the named action within this instance is currently enabled.
</summary>
<remarks>
An action must be enabled in order to be activated or in order to
have its state changed from outside callers.
</remarks>
<param name="actionGroup">
a <see cref="IActionGroup"/>
</param>
<param name="actionName">
the name of the action to query
</param>
<returns>
whether or not the action is currently enabled
</returns>
</member>

<member name='GetActionParameterType(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.UnownedUtf8)'>
<summary>
Queries the type of the parameter that must be given when activating
the named action within this instance.
</summary>
<remarks>
When activating the action using <see cref="M:ActionGroup.ActivateAction(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.Utf8,GISharp.Lib.GLib.Variant)"/>,
the <see cref="GLib.Variant"/> given to that function must be of the type returned
by this function.

In the case that this function returns <c>null</c>, you must not give any
<see cref="GLib.Variant"/>, but <c>null</c> instead.

The parameter type of a particular action will never change but it is
possible for an action to be removed and for a new action to be added
with the same name but a different parameter type.
</remarks>
<param name="actionGroup">
a <see cref="IActionGroup"/>
</param>
<param name="actionName">
the name of the action to query
</param>
<returns>
the parameter type
</returns>
</member>

<member name='GetActionParameterType(GISharp.Lib.Gio.IActionGroup,System.String)'>
<summary>
Queries the type of the parameter that must be given when activating
the named action within this instance.
</summary>
<remarks>
When activating the action using <see cref="M:ActionGroup.ActivateAction(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.Utf8,GISharp.Lib.GLib.Variant)"/>,
the <see cref="GLib.Variant"/> given to that function must be of the type returned
by this function.

In the case that this function returns <c>null</c>, you must not give any
<see cref="GLib.Variant"/>, but <c>null</c> instead.

The parameter type of a particular action will never change but it is
possible for an action to be removed and for a new action to be added
with the same name but a different parameter type.
</remarks>
<param name="actionGroup">
a <see cref="IActionGroup"/>
</param>
<param name="actionName">
the name of the action to query
</param>
<returns>
the parameter type
</returns>
</member>

<member name='GetActionState(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.UnownedUtf8)'>
<summary>
Queries the current state of the named action within this instance.
</summary>
<remarks>
If the action is not stateful then <c>null</c> will be returned.  If the
action is stateful then the type of the return value is the type
given by <see cref="M:ActionGroup.GetActionStateType(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.Utf8)"/>.

The return value (if non-<c>null</c>) should be freed with
g_variant_unref() when it is no longer required.
</remarks>
<param name="actionGroup">
a <see cref="IActionGroup"/>
</param>
<param name="actionName">
the name of the action to query
</param>
<returns>
the current state of the action
</returns>
</member>

<member name='GetActionState(GISharp.Lib.Gio.IActionGroup,System.String)'>
<summary>
Queries the current state of the named action within this instance.
</summary>
<remarks>
If the action is not stateful then <c>null</c> will be returned.  If the
action is stateful then the type of the return value is the type
given by <see cref="M:ActionGroup.GetActionStateType(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.Utf8)"/>.

The return value (if non-<c>null</c>) should be freed with
g_variant_unref() when it is no longer required.
</remarks>
<param name="actionGroup">
a <see cref="IActionGroup"/>
</param>
<param name="actionName">
the name of the action to query
</param>
<returns>
the current state of the action
</returns>
</member>

<member name='GetActionStateHint(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.UnownedUtf8)'>
<summary>
Requests a hint about the valid range of values for the state of the
named action within this instance.
</summary>
<remarks>
If <c>null</c> is returned it either means that the action is not stateful
or that there is no hint about the valid range of values for the
state of the action.

If a <see cref="GLib.Variant"/> array is returned then each item in the array is a
possible value for the state.  If a <see cref="GLib.Variant"/> pair (ie: two-tuple) is
returned then the tuple specifies the inclusive lower and upper bound
of valid values for the state.

In any case, the information is merely a hint.  It may be possible to
have a state value outside of the hinted range and setting a value
within the range may fail.

The return value (if non-<c>null</c>) should be freed with
g_variant_unref() when it is no longer required.
</remarks>
<param name="actionGroup">
a <see cref="IActionGroup"/>
</param>
<param name="actionName">
the name of the action to query
</param>
<returns>
the state range hint
</returns>
</member>

<member name='GetActionStateHint(GISharp.Lib.Gio.IActionGroup,System.String)'>
<summary>
Requests a hint about the valid range of values for the state of the
named action within this instance.
</summary>
<remarks>
If <c>null</c> is returned it either means that the action is not stateful
or that there is no hint about the valid range of values for the
state of the action.

If a <see cref="GLib.Variant"/> array is returned then each item in the array is a
possible value for the state.  If a <see cref="GLib.Variant"/> pair (ie: two-tuple) is
returned then the tuple specifies the inclusive lower and upper bound
of valid values for the state.

In any case, the information is merely a hint.  It may be possible to
have a state value outside of the hinted range and setting a value
within the range may fail.

The return value (if non-<c>null</c>) should be freed with
g_variant_unref() when it is no longer required.
</remarks>
<param name="actionGroup">
a <see cref="IActionGroup"/>
</param>
<param name="actionName">
the name of the action to query
</param>
<returns>
the state range hint
</returns>
</member>

<member name='GetActionStateType(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.UnownedUtf8)'>
<summary>
Queries the type of the state of the named action within
this instance.
</summary>
<remarks>
If the action is stateful then this function returns the
<see cref="GLib.VariantType"/> of the state.  All calls to
<see cref="M:ActionGroup.ChangeActionState(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.Utf8,GISharp.Lib.GLib.Variant)"/> must give a <see cref="GLib.Variant"/> of this
type and <see cref="M:ActionGroup.GetActionState(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.Utf8)"/> will return a <see cref="GLib.Variant"/>
of the same type.

If the action is not stateful then this function will return <c>null</c>.
In that case, <see cref="M:ActionGroup.GetActionState(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.Utf8)"/> will return <c>null</c>
and you must not call <see cref="M:ActionGroup.ChangeActionState(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.Utf8,GISharp.Lib.GLib.Variant)"/>.

The state type of a particular action will never change but it is
possible for an action to be removed and for a new action to be added
with the same name but a different state type.
</remarks>
<param name="actionGroup">
a <see cref="IActionGroup"/>
</param>
<param name="actionName">
the name of the action to query
</param>
<returns>
the state type, if the action is stateful
</returns>
</member>

<member name='GetActionStateType(GISharp.Lib.Gio.IActionGroup,System.String)'>
<summary>
Queries the type of the state of the named action within
this instance.
</summary>
<remarks>
If the action is stateful then this function returns the
<see cref="GLib.VariantType"/> of the state.  All calls to
<see cref="M:ActionGroup.ChangeActionState(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.Utf8,GISharp.Lib.GLib.Variant)"/> must give a <see cref="GLib.Variant"/> of this
type and <see cref="M:ActionGroup.GetActionState(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.Utf8)"/> will return a <see cref="GLib.Variant"/>
of the same type.

If the action is not stateful then this function will return <c>null</c>.
In that case, <see cref="M:ActionGroup.GetActionState(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.Utf8)"/> will return <c>null</c>
and you must not call <see cref="M:ActionGroup.ChangeActionState(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.Utf8,GISharp.Lib.GLib.Variant)"/>.

The state type of a particular action will never change but it is
possible for an action to be removed and for a new action to be added
with the same name but a different state type.
</remarks>
<param name="actionGroup">
a <see cref="IActionGroup"/>
</param>
<param name="actionName">
the name of the action to query
</param>
<returns>
the state type, if the action is stateful
</returns>
</member>

<member name='HasAction(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.UnownedUtf8)'>
<summary>
Checks if the named action exists within this instance.
</summary>
<param name="actionGroup">
a <see cref="IActionGroup"/>
</param>
<param name="actionName">
the name of the action to check for
</param>
<returns>
whether the named action exists
</returns>
</member>

<member name='HasAction(GISharp.Lib.Gio.IActionGroup,System.String)'>
<summary>
Checks if the named action exists within this instance.
</summary>
<param name="actionGroup">
a <see cref="IActionGroup"/>
</param>
<param name="actionName">
the name of the action to check for
</param>
<returns>
whether the named action exists
</returns>
</member>

<member name='ListActions(GISharp.Lib.Gio.IActionGroup)'>
<summary>
Lists the actions contained within this instance.
</summary>
<remarks>
The caller is responsible for freeing the list with g_strfreev() when
it is no longer required.
</remarks>
<param name="actionGroup">
a <see cref="IActionGroup"/>
</param>
<returns>
a <c>null</c>-terminated array of the names of the
actions in the group
</returns>
</member>

<member name='TryQueryAction(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.UnownedUtf8,System.Boolean,GISharp.Lib.GLib.VariantType,GISharp.Lib.GLib.VariantType,GISharp.Lib.GLib.Variant,GISharp.Lib.GLib.Variant)'>
<summary>
Queries all aspects of the named action within an this instance.
</summary>
<remarks>
This function acquires the information available from
<see cref="M:ActionGroup.HasAction(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.Utf8)"/>, <see cref="M:ActionGroup.GetActionEnabled(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.Utf8)"/>,
<see cref="M:ActionGroup.GetActionParameterType(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.Utf8)"/>,
<see cref="M:ActionGroup.GetActionStateType(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.Utf8)"/>,
<see cref="M:ActionGroup.GetActionStateHint(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.Utf8)"/> and
<see cref="M:ActionGroup.GetActionState(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.Utf8)"/> with a single function call.

This provides two main benefits.

The first is the improvement in efficiency that comes with not having
to perform repeated lookups of the action in order to discover
different things about it.  The second is that implementing
<see cref="IActionGroup"/> can now be done by only overriding this one virtual
function.

The interface provides a default implementation of this function that
calls the individual functions, as required, to fetch the
information.  The interface also provides default implementations of
those functions that call this function.  All implementations,
therefore, must override either this function or all of the others.

If the action exists, <c>true</c> is returned and any of the requested
fields (as indicated by having a non-<c>null</c> reference passed in) are
filled.  If the action doesn't exist, <c>false</c> is returned and the
fields may or may not have been modified.
</remarks>
<param name="actionGroup">
a <see cref="IActionGroup"/>
</param>
<param name="actionName">
the name of an action in the group
</param>
<param name="enabled">
if the action is presently enabled
</param>
<param name="parameterType">
the parameter type, or <c>null</c> if none needed
</param>
<param name="stateType">
the state type, or <c>null</c> if stateless
</param>
<param name="stateHint">
the state hint, or <c>null</c> if none
</param>
<param name="state">
the current state, or <c>null</c> if stateless
</param>
<returns>
<c>true</c> if the action exists, else <c>false</c>
</returns>
</member>

<member name='TryQueryAction(GISharp.Lib.Gio.IActionGroup,System.String,System.Boolean,GISharp.Lib.GLib.VariantType,GISharp.Lib.GLib.VariantType,GISharp.Lib.GLib.Variant,GISharp.Lib.GLib.Variant)'>
<summary>
Queries all aspects of the named action within an this instance.
</summary>
<remarks>
This function acquires the information available from
<see cref="M:ActionGroup.HasAction(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.Utf8)"/>, <see cref="M:ActionGroup.GetActionEnabled(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.Utf8)"/>,
<see cref="M:ActionGroup.GetActionParameterType(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.Utf8)"/>,
<see cref="M:ActionGroup.GetActionStateType(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.Utf8)"/>,
<see cref="M:ActionGroup.GetActionStateHint(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.Utf8)"/> and
<see cref="M:ActionGroup.GetActionState(GISharp.Lib.Gio.IActionGroup,GISharp.Lib.GLib.Utf8)"/> with a single function call.

This provides two main benefits.

The first is the improvement in efficiency that comes with not having
to perform repeated lookups of the action in order to discover
different things about it.  The second is that implementing
<see cref="IActionGroup"/> can now be done by only overriding this one virtual
function.

The interface provides a default implementation of this function that
calls the individual functions, as required, to fetch the
information.  The interface also provides default implementations of
those functions that call this function.  All implementations,
therefore, must override either this function or all of the others.

If the action exists, <c>true</c> is returned and any of the requested
fields (as indicated by having a non-<c>null</c> reference passed in) are
filled.  If the action doesn't exist, <c>false</c> is returned and the
fields may or may not have been modified.
</remarks>
<param name="actionGroup">
a <see cref="IActionGroup"/>
</param>
<param name="actionName">
the name of an action in the group
</param>
<param name="enabled">
if the action is presently enabled
</param>
<param name="parameterType">
the parameter type, or <c>null</c> if none needed
</param>
<param name="stateType">
the state type, or <c>null</c> if stateless
</param>
<param name="stateHint">
the state hint, or <c>null</c> if none
</param>
<param name="state">
the current state, or <c>null</c> if stateless
</param>
<returns>
<c>true</c> if the action exists, else <c>false</c>
</returns>
</member>

</declaration>
