// ATTENTION: This file is automatically generated. Do not edit by manually.
namespace GISharp.Lib.Gio
{
    /// <summary>
    /// GIOStream represents an object that has both read and write streams.
    /// Generally the two streams act as separate input and output streams,
    /// but they share some common resources and state. For instance, for
    /// seekable streams, both streams may use the same position.
    /// </summary>
    /// <remarks>
    /// Examples of <see cref="IOStream"/> objects are #GSocketConnection, which represents
    /// a two-way network connection; and <see cref="FileIOStream"/>, which represents a
    /// file handle opened in read-write mode.
    /// 
    /// To do the actual reading and writing you need to get the substreams
    /// with <see cref="IOStream.GetInputStream"/> and <see cref="IOStream.GetOutputStream"/>.
    /// 
    /// The <see cref="IOStream"/> object owns the input and the output streams, not the other
    /// way around, so keeping the substreams alive will not keep the <see cref="IOStream"/>
    /// object alive. If the <see cref="IOStream"/> object is freed it will be closed, thus
    /// closing the substreams, so even if the substreams stay alive they will
    /// always return <see cref="IOErrorEnum.Closed"/> for all operations.
    /// 
    /// To close a stream use <see cref="IOStream.Close"/> which will close the common
    /// stream object and also the individual substreams. You can also close
    /// the substreams themselves. In most cases this only marks the
    /// substream as closed, so further I/O on it fails but common state in the
    /// <see cref="IOStream"/> may still be open. However, some streams may support
    /// "half-closed" states where one direction of the stream is actually shut down.
    /// 
    /// Operations on <see cref="IOStream"/>s cannot be started while another operation on the
    /// <see cref="IOStream"/> or its substreams is in progress. Specifically, an application can
    /// read from the <see cref="InputStream"/> and write to the <see cref="OutputStream"/> simultaneously
    /// (either in separate threads, or as asynchronous operations in the same
    /// thread), but an application cannot start any <see cref="IOStream"/> operation while there
    /// is a <see cref="IOStream"/>, <see cref="InputStream"/> or <see cref="OutputStream"/> operation in progress, and
    /// an application canâ€™t start any <see cref="InputStream"/> or <see cref="OutputStream"/> operation
    /// while there is a <see cref="IOStream"/> operation in progress.
    /// 
    /// This is a product of individual stream operations being associated with a
    /// given #GMainContext (the thread-default context at the time the operation was
    /// started), rather than entire streams being associated with a single
    /// #GMainContext.
    /// 
    /// GIO may run operations on <see cref="IOStream"/>s from other (worker) threads, and this
    /// may be exposed to application code in the behaviour of wrapper streams, such
    /// as #GBufferedInputStream or #GTlsConnection. With such wrapper APIs,
    /// application code may only run operations on the base (wrapped) stream when
    /// the wrapper stream is idle. Note that the semantics of such operations may
    /// not be well-defined due to the state the wrapper stream leaves the base
    /// stream in (though they are guaranteed not to crash).
    /// </remarks>
    [GISharp.Runtime.GTypeAttribute("GIOStream", IsProxyForUnmanagedType = true)]
    [GISharp.Runtime.GTypeStructAttribute(typeof(IOStreamClass))]
    public abstract partial class IOStream : GISharp.Lib.GObject.Object
    {
        static readonly GISharp.Lib.GObject.GType _GType = g_io_stream_get_type();

        unsafe protected new struct Struct
        {
#pragma warning disable CS0649
            public GISharp.Lib.GObject.Object.Struct ParentInstance;
            public System.IntPtr Priv;
#pragma warning restore CS0649
        }

        [GISharp.Runtime.GPropertyAttribute("closed")]
        public System.Boolean IsClosed_ { get => (System.Boolean)GetProperty("closed"); }
        [GISharp.Runtime.GPropertyAttribute("input-stream")]
        public GISharp.Lib.Gio.InputStream InputStream_ { get => (GISharp.Lib.Gio.InputStream)GetProperty("input-stream"); }
        [GISharp.Runtime.GPropertyAttribute("output-stream")]
        public GISharp.Lib.Gio.OutputStream OutputStream_ { get => (GISharp.Lib.Gio.OutputStream)GetProperty("output-stream"); }

        /// <summary>
        /// Gets the input stream for this object. This is used
        /// for reading.
        /// </summary>
        [GISharp.Runtime.SinceAttribute("2.22")]
        public GISharp.Lib.Gio.InputStream InputStream { get => GetInputStream(); }

        /// <summary>
        /// Gets the output stream for this object. This is used for
        /// writing.
        /// </summary>
        [GISharp.Runtime.SinceAttribute("2.22")]
        public GISharp.Lib.Gio.OutputStream OutputStream { get => GetOutputStream(); }

        /// <summary>
        /// Checks if a stream is closed.
        /// </summary>
        [GISharp.Runtime.SinceAttribute("2.22")]
        public System.Boolean IsClosed { get => GetIsClosed(); }

        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        protected IOStream(System.IntPtr handle, GISharp.Runtime.Transfer ownership) : base(handle, ownership)
        {
        }

        /// <summary>
        /// Finishes an asynchronous io stream splice operation.
        /// </summary>
        /// <param name="result">
        /// a #GAsyncResult.
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// %TRUE on success, %FALSE otherwise.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.28")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:out */
        static extern unsafe System.Boolean g_io_stream_splice_finish(
        /* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr result,
        /* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        System.IntPtr* error);

        static unsafe void SpliceFinish(System.IntPtr sourceObject_, System.IntPtr result_, System.IntPtr userData_)
        {
            try
            {
                var userData = (System.Runtime.InteropServices.GCHandle)userData_;
                var completionSource = (System.Threading.Tasks.TaskCompletionSource<System.Object>)userData.Target;
                userData.Free();
                var error_ = System.IntPtr.Zero;
                g_io_stream_splice_finish(result_, &error_);
                if (error_ != System.IntPtr.Zero)
                {
                    var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>(error_, GISharp.Runtime.Transfer.Full);
                    completionSource.SetException(new GISharp.Runtime.GErrorException(error));
                    return;
                }
                completionSource.SetResult(null);
            }
            catch (System.Exception ex)
            {
                GISharp.Lib.GLib.Log.LogUnhandledException(ex);
            }
        }

        static readonly GISharp.Lib.Gio.UnmanagedAsyncReadyCallback spliceAsyncCallbackDelegate = SpliceFinish;

        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="GType" type="GType" managed-name="GISharp.Lib.GObject.GType" /> */
        /* transfer-ownership:full direction:out */
        static extern unsafe GISharp.Lib.GObject.GType g_io_stream_get_type();

        /// <summary>
        /// Clears the pending flag on @stream.
        /// </summary>
        /// <param name="stream">
        /// a #GIOStream
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.22")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe void g_io_stream_clear_pending(
        /* <type name="IOStream" type="GIOStream*" managed-name="IOStream" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr stream);

        /// <summary>
        /// Clears the pending flag on <paramref name="stream"/>.
        /// </summary>
        [GISharp.Runtime.SinceAttribute("2.22")]
        public unsafe void ClearPending()
        {
            var stream_ = Handle;
            g_io_stream_clear_pending(stream_);
        }

        /// <summary>
        /// Closes the stream, releasing resources related to it. This will also
        /// close the individual input and output streams, if they are not already
        /// closed.
        /// </summary>
        /// <remarks>
        /// Once the stream is closed, all other operations will return
        /// %G_IO_ERROR_CLOSED. Closing a stream multiple times will not
        /// return an error.
        /// 
        /// Closing a stream will automatically flush any outstanding buffers
        /// in the stream.
        /// 
        /// Streams will be automatically closed when the last reference
        /// is dropped, but you might want to call this function to make sure
        /// resources are released as early as possible.
        /// 
        /// Some streams might keep the backing store of the stream (e.g. a file
        /// descriptor) open after the stream is closed. See the documentation for
        /// the individual stream for details.
        /// 
        /// On failure the first error that happened will be reported, but the
        /// close operation will finish as much as possible. A stream that failed
        /// to close will still return %G_IO_ERROR_CLOSED for all operations.
        /// Still, it is important to check and report the error to the user,
        /// otherwise there might be a loss of data as all data might not be written.
        /// 
        /// If @cancellable is not NULL, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.
        /// Cancelling a close will still leave the stream closed, but some streams
        /// can use a faster close that doesn't block to e.g. check errors.
        /// 
        /// The default implementation of this method just calls close on the
        /// individual input/output streams.
        /// </remarks>
        /// <param name="stream">
        /// a #GIOStream
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object, %NULL to ignore
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// %TRUE on success, %FALSE on failure
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.22")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:out */
        static extern unsafe System.Boolean g_io_stream_close(
        /* <type name="IOStream" type="GIOStream*" managed-name="IOStream" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr stream,
        /* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr cancellable,
        /* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        System.IntPtr* error);

        /// <summary>
        /// Closes the stream, releasing resources related to it. This will also
        /// close the individual input and output streams, if they are not already
        /// closed.
        /// </summary>
        /// <remarks>
        /// Once the stream is closed, all other operations will return
        /// <see cref="IOErrorEnum.Closed"/>. Closing a stream multiple times will not
        /// return an error.
        /// 
        /// Closing a stream will automatically flush any outstanding buffers
        /// in the stream.
        /// 
        /// Streams will be automatically closed when the last reference
        /// is dropped, but you might want to call this function to make sure
        /// resources are released as early as possible.
        /// 
        /// Some streams might keep the backing store of the stream (e.g. a file
        /// descriptor) open after the stream is closed. See the documentation for
        /// the individual stream for details.
        /// 
        /// On failure the first error that happened will be reported, but the
        /// close operation will finish as much as possible. A stream that failed
        /// to close will still return <see cref="IOErrorEnum.Closed"/> for all operations.
        /// Still, it is important to check and report the error to the user,
        /// otherwise there might be a loss of data as all data might not be written.
        /// 
        /// If <paramref name="cancellable"/> is not NULL, then the operation can be cancelled by
        /// triggering the cancellable object from another thread. If the operation
        /// was cancelled, the error <see cref="IOErrorEnum.Cancelled"/> will be returned.
        /// Cancelling a close will still leave the stream closed, but some streams
        /// can use a faster close that doesn't block to e.g. check errors.
        /// 
        /// The default implementation of this method just calls close on the
        /// individual input/output streams.
        /// </remarks>
        /// <param name="cancellable">
        /// optional <see cref="Cancellable"/> object, <c>null</c> to ignore
        /// </param>
        /// <exception name="GISharp.Runtime.GErrorException">
        /// On error
        /// </exception>
        [GISharp.Runtime.SinceAttribute("2.22")]
        public unsafe void Close(GISharp.Lib.Gio.Cancellable cancellable = null)
        {
            var stream_ = Handle;
            var cancellable_ = cancellable?.Handle ?? System.IntPtr.Zero;
            var error_ = System.IntPtr.Zero;
            g_io_stream_close(stream_, cancellable_, &error_);
            if (error_ != System.IntPtr.Zero)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>(error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Runtime.GErrorException(error);
            }
        }

        /// <summary>
        /// Requests an asynchronous close of the stream, releasing resources
        /// related to it. When the operation is finished @callback will be
        /// called. You can then call g_io_stream_close_finish() to get
        /// the result of the operation.
        /// </summary>
        /// <remarks>
        /// For behaviour details see g_io_stream_close().
        /// 
        /// The asynchronous methods have a default fallback that uses threads
        /// to implement asynchronicity, so they are optional for inheriting
        /// classes. However, if you override one you must override all.
        /// </remarks>
        /// <param name="stream">
        /// a #GIOStream
        /// </param>
        /// <param name="ioPriority">
        /// the io priority of the request
        /// </param>
        /// <param name="cancellable">
        /// optional cancellable object
        /// </param>
        /// <param name="callback">
        /// callback to call when the request is satisfied
        /// </param>
        /// <param name="userData">
        /// the data to pass to callback function
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.22")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Threading.Tasks.Task" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe void g_io_stream_close_async(
        /* <type name="IOStream" type="GIOStream*" managed-name="IOStream" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr stream,
        /* <type name="gint" type="int" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        System.Int32 ioPriority,
        /* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr cancellable,
        /* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="UnmanagedAsyncReadyCallback" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:3 direction:in */
        GISharp.Lib.Gio.UnmanagedAsyncReadyCallback callback,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr userData);

        /// <summary>
        /// Requests an asynchronous close of the stream, releasing resources
        /// related to it. When the operation is finished <paramref name="callback"/> will be
        /// called. You can then call <see cref="IOStream.CloseFinish"/> to get
        /// the result of the operation.
        /// </summary>
        /// <remarks>
        /// For behaviour details see <see cref="IOStream.Close"/>.
        /// 
        /// The asynchronous methods have a default fallback that uses threads
        /// to implement asynchronicity, so they are optional for inheriting
        /// classes. However, if you override one you must override all.
        /// </remarks>
        /// <param name="ioPriority">
        /// the io priority of the request
        /// </param>
        /// <param name="cancellable">
        /// optional cancellable object
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.22")]
        public unsafe System.Threading.Tasks.Task CloseAsync(System.Int32 ioPriority = GISharp.Lib.GLib.Priority.Default, GISharp.Lib.Gio.Cancellable cancellable = null)
        {
            var stream_ = Handle;
            var ioPriority_ = (System.Int32)ioPriority;
            var cancellable_ = cancellable?.Handle ?? System.IntPtr.Zero;
            var completionSource = new System.Threading.Tasks.TaskCompletionSource<System.Object>();
            var callback_ = closeAsyncCallbackDelegate;
            var userData_ = (System.IntPtr)System.Runtime.InteropServices.GCHandle.Alloc(completionSource);
            g_io_stream_close_async(stream_, ioPriority_, cancellable_, callback_, userData_);
            return completionSource.Task;
        }

        /// <summary>
        /// Closes a stream.
        /// </summary>
        /// <param name="stream">
        /// a #GIOStream
        /// </param>
        /// <param name="result">
        /// a #GAsyncResult
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// %TRUE if stream was successfully closed, %FALSE otherwise.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.22")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:out */
        static extern unsafe System.Boolean g_io_stream_close_finish(
        /* <type name="IOStream" type="GIOStream*" managed-name="IOStream" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr stream,
        /* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr result,
        /* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        System.IntPtr* error);

        static unsafe void CloseFinish(System.IntPtr stream_, System.IntPtr result_, System.IntPtr userData_)
        {
            try
            {
                var userData = (System.Runtime.InteropServices.GCHandle)userData_;
                var completionSource = (System.Threading.Tasks.TaskCompletionSource<System.Object>)userData.Target;
                userData.Free();
                var error_ = System.IntPtr.Zero;
                g_io_stream_close_finish(stream_, result_, &error_);
                if (error_ != System.IntPtr.Zero)
                {
                    var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>(error_, GISharp.Runtime.Transfer.Full);
                    completionSource.SetException(new GISharp.Runtime.GErrorException(error));
                    return;
                }
                completionSource.SetResult(null);
            }
            catch (System.Exception ex)
            {
                GISharp.Lib.GLib.Log.LogUnhandledException(ex);
            }
        }

        static readonly GISharp.Lib.Gio.UnmanagedAsyncReadyCallback closeAsyncCallbackDelegate = CloseFinish;

        /// <summary>
        /// Gets the input stream for this object. This is used
        /// for reading.
        /// </summary>
        /// <param name="stream">
        /// a #GIOStream
        /// </param>
        /// <returns>
        /// a #GInputStream, owned by the #GIOStream.
        /// Do not free.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.22")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="InputStream" type="GInputStream*" managed-name="InputStream" is-pointer="1" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe System.IntPtr g_io_stream_get_input_stream(
        /* <type name="IOStream" type="GIOStream*" managed-name="IOStream" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr stream);

        /// <summary>
        /// Gets the input stream for this object. This is used
        /// for reading.
        /// </summary>
        /// <returns>
        /// a <see cref="InputStream"/>, owned by the <see cref="IOStream"/>.
        /// Do not free.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.22")]
        private unsafe GISharp.Lib.Gio.InputStream GetInputStream()
        {
            var stream_ = Handle;
            var ret_ = g_io_stream_get_input_stream(stream_);
            var ret = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.InputStream>(ret_, GISharp.Runtime.Transfer.None);
            return ret;
        }

        /// <summary>
        /// Gets the output stream for this object. This is used for
        /// writing.
        /// </summary>
        /// <param name="stream">
        /// a #GIOStream
        /// </param>
        /// <returns>
        /// a #GOutputStream, owned by the #GIOStream.
        /// Do not free.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.22")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="OutputStream" type="GOutputStream*" managed-name="OutputStream" is-pointer="1" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe System.IntPtr g_io_stream_get_output_stream(
        /* <type name="IOStream" type="GIOStream*" managed-name="IOStream" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr stream);

        /// <summary>
        /// Gets the output stream for this object. This is used for
        /// writing.
        /// </summary>
        /// <returns>
        /// a <see cref="OutputStream"/>, owned by the <see cref="IOStream"/>.
        /// Do not free.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.22")]
        private unsafe GISharp.Lib.Gio.OutputStream GetOutputStream()
        {
            var stream_ = Handle;
            var ret_ = g_io_stream_get_output_stream(stream_);
            var ret = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.OutputStream>(ret_, GISharp.Runtime.Transfer.None);
            return ret;
        }

        /// <summary>
        /// Checks if a stream has pending actions.
        /// </summary>
        /// <param name="stream">
        /// a #GIOStream
        /// </param>
        /// <returns>
        /// %TRUE if @stream has pending actions.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.22")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe System.Boolean g_io_stream_has_pending(
        /* <type name="IOStream" type="GIOStream*" managed-name="IOStream" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr stream);

        /// <summary>
        /// Checks if a stream has pending actions.
        /// </summary>
        /// <returns>
        /// <c>true</c> if <paramref name="stream"/> has pending actions.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.22")]
        public unsafe System.Boolean HasPending()
        {
            var stream_ = Handle;
            var ret_ = g_io_stream_has_pending(stream_);
            var ret = (System.Boolean)ret_;
            return ret;
        }

        /// <summary>
        /// Checks if a stream is closed.
        /// </summary>
        /// <param name="stream">
        /// a #GIOStream
        /// </param>
        /// <returns>
        /// %TRUE if the stream is closed.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.22")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe System.Boolean g_io_stream_is_closed(
        /* <type name="IOStream" type="GIOStream*" managed-name="IOStream" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr stream);

        /// <summary>
        /// Checks if a stream is closed.
        /// </summary>
        /// <returns>
        /// <c>true</c> if the stream is closed.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.22")]
        private unsafe System.Boolean GetIsClosed()
        {
            var stream_ = Handle;
            var ret_ = g_io_stream_is_closed(stream_);
            var ret = (System.Boolean)ret_;
            return ret;
        }

        /// <summary>
        /// Sets @stream to have actions pending. If the pending flag is
        /// already set or @stream is closed, it will return %FALSE and set
        /// @error.
        /// </summary>
        /// <param name="stream">
        /// a #GIOStream
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// %TRUE if pending was previously unset and is now set.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.22")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:out */
        static extern unsafe System.Boolean g_io_stream_set_pending(
        /* <type name="IOStream" type="GIOStream*" managed-name="IOStream" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr stream,
        /* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        System.IntPtr* error);

        /// <summary>
        /// Sets <paramref name="stream"/> to have actions pending. If the pending flag is
        /// already set or <paramref name="stream"/> is closed, it will return <c>false</c> and set
        /// <paramref name="error"/>.
        /// </summary>
        /// <exception name="GISharp.Runtime.GErrorException">
        /// On error
        /// </exception>
        [GISharp.Runtime.SinceAttribute("2.22")]
        public unsafe void SetPending()
        {
            var stream_ = Handle;
            var error_ = System.IntPtr.Zero;
            g_io_stream_set_pending(stream_, &error_);
            if (error_ != System.IntPtr.Zero)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>(error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Runtime.GErrorException(error);
            }
        }

        /// <summary>
        /// Asyncronously splice the output stream of @stream1 to the input stream of
        /// @stream2, and splice the output stream of @stream2 to the input stream of
        /// @stream1.
        /// </summary>
        /// <remarks>
        /// When the operation is finished @callback will be called.
        /// You can then call g_io_stream_splice_finish() to get the
        /// result of the operation.
        /// </remarks>
        /// <param name="stream1">
        /// a #GIOStream.
        /// </param>
        /// <param name="stream2">
        /// a #GIOStream.
        /// </param>
        /// <param name="flags">
        /// a set of #GIOStreamSpliceFlags.
        /// </param>
        /// <param name="ioPriority">
        /// the io priority of the request.
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object, %NULL to ignore.
        /// </param>
        /// <param name="callback">
        /// a #GAsyncReadyCallback.
        /// </param>
        /// <param name="userData">
        /// user data passed to @callback.
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.28")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Threading.Tasks.Task" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe void g_io_stream_splice_async(
        /* <type name="IOStream" type="GIOStream*" managed-name="IOStream" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr stream1,
        /* <type name="IOStream" type="GIOStream*" managed-name="IOStream" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr stream2,
        /* <type name="IOStreamSpliceFlags" type="GIOStreamSpliceFlags" managed-name="IOStreamSpliceFlags" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.Gio.IOStreamSpliceFlags flags,
        /* <type name="gint" type="int" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        System.Int32 ioPriority,
        /* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr cancellable,
        /* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="UnmanagedAsyncReadyCallback" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:5 direction:in */
        GISharp.Lib.Gio.UnmanagedAsyncReadyCallback callback,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr userData);

        /// <summary>
        /// Asyncronously splice the output stream of <paramref name="stream1"/> to the input stream of
        /// <paramref name="stream2"/>, and splice the output stream of <paramref name="stream2"/> to the input stream of
        /// <paramref name="stream1"/>.
        /// </summary>
        /// <remarks>
        /// When the operation is finished <paramref name="callback"/> will be called.
        /// You can then call <see cref="IOStream.SpliceFinish"/> to get the
        /// result of the operation.
        /// </remarks>
        /// <param name="stream2">
        /// a <see cref="IOStream"/>.
        /// </param>
        /// <param name="flags">
        /// a set of <see cref="IOStreamSpliceFlags"/>.
        /// </param>
        /// <param name="ioPriority">
        /// the io priority of the request.
        /// </param>
        /// <param name="cancellable">
        /// optional <see cref="Cancellable"/> object, <c>null</c> to ignore.
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.28")]
        public unsafe System.Threading.Tasks.Task SpliceAsync(GISharp.Lib.Gio.IOStream stream2, GISharp.Lib.Gio.IOStreamSpliceFlags flags, System.Int32 ioPriority = GISharp.Lib.GLib.Priority.Default, GISharp.Lib.Gio.Cancellable cancellable = null)
        {
            var stream1_ = Handle;
            var stream2_ = stream2?.Handle ?? throw new System.ArgumentNullException(nameof(stream2));
            var flags_ = (GISharp.Lib.Gio.IOStreamSpliceFlags)flags;
            var ioPriority_ = (System.Int32)ioPriority;
            var cancellable_ = cancellable?.Handle ?? System.IntPtr.Zero;
            var completionSource = new System.Threading.Tasks.TaskCompletionSource<System.Object>();
            var callback_ = spliceAsyncCallbackDelegate;
            var userData_ = (System.IntPtr)System.Runtime.InteropServices.GCHandle.Alloc(completionSource);
            g_io_stream_splice_async(stream1_, stream2_, flags_, ioPriority_, cancellable_, callback_, userData_);
            return completionSource.Task;
        }

        /// <summary>
        /// Requests an asynchronous close of the stream, releasing resources
        /// related to it. When the operation is finished <paramref name="callback"/> will be
        /// called. You can then call <see cref="IOStream.CloseFinish"/> to get
        /// the result of the operation.
        /// </summary>
        /// <remarks>
        /// For behaviour details see <see cref="IOStream.Close"/>.
        /// 
        /// The asynchronous methods have a default fallback that uses threads
        /// to implement asynchronicity, so they are optional for inheriting
        /// classes. However, if you override one you must override all.
        /// </remarks>
        /// <param name="ioPriority">
        /// the io priority of the request
        /// </param>
        /// <param name="callback">
        /// callback to call when the request is satisfied
        /// </param>
        /// <param name="cancellable">
        /// optional cancellable object
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.22")]
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(IOStreamClass.UnmanagedCloseAsync))]
        protected virtual unsafe void DoCloseAsync(System.Int32 ioPriority, GISharp.Lib.Gio.AsyncReadyCallback callback, GISharp.Lib.Gio.Cancellable cancellable = null)
        {
            var stream_ = Handle;
            var ioPriority_ = (System.Int32)ioPriority;
            var (callback_, _, userData_) = callback == null ? (default(GISharp.Lib.Gio.UnmanagedAsyncReadyCallback), default(GISharp.Lib.GLib.UnmanagedDestroyNotify), default(System.IntPtr)) : GISharp.Lib.Gio.AsyncReadyCallbackFactory.Create(callback, GISharp.Runtime.CallbackScope.Async);
            var cancellable_ = cancellable?.Handle ?? System.IntPtr.Zero;
            GISharp.Lib.GObject.TypeClass.GetUnmanagedVirtualMethod<IOStreamClass.UnmanagedCloseAsync>(_GType)(stream_, ioPriority_, cancellable_, callback_, userData_);
        }

        /// <summary>
        /// Closes a stream.
        /// </summary>
        /// <param name="result">
        /// a <see cref="IAsyncResult"/>
        /// </param>
        /// <returns>
        /// <c>true</c> if stream was successfully closed, <c>false</c> otherwise.
        /// </returns>
        /// <exception name="GISharp.Runtime.GErrorException">
        /// On error
        /// </exception>
        [GISharp.Runtime.SinceAttribute("2.22")]
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(IOStreamClass.UnmanagedCloseFinish))]
        protected virtual unsafe void DoCloseFinish(GISharp.Lib.Gio.IAsyncResult result)
        {
            var stream_ = Handle;
            var result_ = result?.Handle ?? throw new System.ArgumentNullException(nameof(result));
            var error_ = System.IntPtr.Zero;
            GISharp.Lib.GObject.TypeClass.GetUnmanagedVirtualMethod<IOStreamClass.UnmanagedCloseFinish>(_GType)(stream_, result_, &error_);
            if (error_ != System.IntPtr.Zero)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>(error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Runtime.GErrorException(error);
            }
        }

        /// <exception name="GISharp.Runtime.GErrorException">
        /// On error
        /// </exception>
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(IOStreamClass.UnmanagedCloseFn))]
        protected virtual unsafe void DoCloseFn(GISharp.Lib.Gio.Cancellable cancellable = null)
        {
            var stream_ = Handle;
            var cancellable_ = cancellable?.Handle ?? System.IntPtr.Zero;
            var error_ = System.IntPtr.Zero;
            GISharp.Lib.GObject.TypeClass.GetUnmanagedVirtualMethod<IOStreamClass.UnmanagedCloseFn>(_GType)(stream_, cancellable_, &error_);
            if (error_ != System.IntPtr.Zero)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>(error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Runtime.GErrorException(error);
            }
        }

        /// <summary>
        /// Gets the input stream for this object. This is used
        /// for reading.
        /// </summary>
        /// <returns>
        /// a <see cref="InputStream"/>, owned by the <see cref="IOStream"/>.
        /// Do not free.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.22")]
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(IOStreamClass.UnmanagedGetInputStream))]
        protected virtual unsafe GISharp.Lib.Gio.InputStream DoGetInputStream()
        {
            var stream_ = Handle;
            var ret_ = GISharp.Lib.GObject.TypeClass.GetUnmanagedVirtualMethod<IOStreamClass.UnmanagedGetInputStream>(_GType)(stream_);
            var ret = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.InputStream>(ret_, GISharp.Runtime.Transfer.None);
            return ret;
        }

        /// <summary>
        /// Gets the output stream for this object. This is used for
        /// writing.
        /// </summary>
        /// <returns>
        /// a <see cref="OutputStream"/>, owned by the <see cref="IOStream"/>.
        /// Do not free.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.22")]
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(IOStreamClass.UnmanagedGetOutputStream))]
        protected virtual unsafe GISharp.Lib.Gio.OutputStream DoGetOutputStream()
        {
            var stream_ = Handle;
            var ret_ = GISharp.Lib.GObject.TypeClass.GetUnmanagedVirtualMethod<IOStreamClass.UnmanagedGetOutputStream>(_GType)(stream_);
            var ret = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.OutputStream>(ret_, GISharp.Runtime.Transfer.None);
            return ret;
        }
    }
}