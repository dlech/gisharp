// ATTENTION: This file is automatically generated. Do not edit manually.
#nullable enable
namespace GISharp.Lib.Gio
{
    /// <include file="Task.xmldoc" path="declaration/member[@name='Task']/*" />
    [GISharp.Runtime.GTypeAttribute("GTask", IsProxyForUnmanagedType = true)]
    [GISharp.Runtime.GTypeStructAttribute(typeof(TaskClass))]
    public partial class Task : GISharp.Lib.GObject.Object, GISharp.Lib.Gio.IAsyncResult
    {
        static readonly GISharp.Lib.GObject.GType _GType = g_task_get_type();

        /// <include file="Task.xmldoc" path="declaration/member[@name='Completed_']/*" />
        [GISharp.Runtime.SinceAttribute("2.44")]
        [GISharp.Runtime.GPropertyAttribute("completed")]
        public System.Boolean Completed_ { get => (System.Boolean)GetProperty("completed")!; }

        /// <include file="Task.xmldoc" path="declaration/member[@name='Cancellable']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        public GISharp.Lib.Gio.Cancellable Cancellable { get => GetCancellable(); }

        /// <include file="Task.xmldoc" path="declaration/member[@name='CheckCancellable']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        public System.Boolean CheckCancellable { get => GetCheckCancellable(); set => SetCheckCancellable(value); }

        /// <include file="Task.xmldoc" path="declaration/member[@name='Completed']/*" />
        [GISharp.Runtime.SinceAttribute("2.44")]
        public System.Boolean Completed { get => GetCompleted(); }

        /// <include file="Task.xmldoc" path="declaration/member[@name='Context']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        public GISharp.Lib.GLib.MainContext Context { get => GetContext(); }

        /// <include file="Task.xmldoc" path="declaration/member[@name='Priority']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        public System.Int32 Priority { get => GetPriority(); set => SetPriority(value); }

        /// <include file="Task.xmldoc" path="declaration/member[@name='ReturnOnCancel']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        public System.Boolean ReturnOnCancel { get => GetReturnOnCancel(); }

        /// <include file="Task.xmldoc" path="declaration/member[@name='SourceObject']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        public GISharp.Lib.GObject.Object? SourceObject { get => GetSourceObject(); }

        /// <include file="Task.xmldoc" path="declaration/member[@name='SourceTag']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        public System.IntPtr SourceTag { get => GetSourceTag(); set => SetSourceTag(value); }

        /// <include file="Task.xmldoc" path="declaration/member[@name='TaskData']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        public System.IntPtr TaskData { get => GetTaskData(); }

        /// <summary>
        /// For internal runtime use only.
        /// </summary>
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        public Task(System.IntPtr handle, GISharp.Runtime.Transfer ownership) : base(handle, ownership)
        {
        }

        /// <summary>
        /// Creates a #GTask acting on @source_object, which will eventually be
        /// used to invoke @callback in the current
        /// [thread-default main context][g-main-context-push-thread-default].
        /// </summary>
        /// <remarks>
        /// Call this in the "start" method of your asynchronous method, and
        /// pass the #GTask around throughout the asynchronous operation. You
        /// can use g_task_set_task_data() to attach task-specific data to the
        /// object, which you can retrieve later via g_task_get_task_data().
        /// 
        /// By default, if @cancellable is cancelled, then the return value of
        /// the task will always be %G_IO_ERROR_CANCELLED, even if the task had
        /// already completed before the cancellation. This allows for
        /// simplified handling in cases where cancellation may imply that
        /// other objects that the task depends on have been destroyed. If you
        /// do not want this behavior, you can use
        /// g_task_set_check_cancellable() to change it.
        /// </remarks>
        /// <param name="sourceObject">
        /// the #GObject that owns
        ///   this task, or %NULL.
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object, %NULL to ignore.
        /// </param>
        /// <param name="callback">
        /// a #GAsyncReadyCallback.
        /// </param>
        /// <param name="callbackData">
        /// user data passed to @callback.
        /// </param>
        /// <returns>
        /// a #GTask.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Task" type="GTask*" managed-name="Task" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        static extern unsafe System.IntPtr g_task_new(
        /* <type name="GObject.Object" type="gpointer" managed-name="GISharp.Lib.GObject.Object" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr sourceObject,
        /* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr cancellable,
        /* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="UnmanagedAsyncReadyCallback" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:3 direction:in */
        System.IntPtr callback,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr callbackData);

        /// <include file="Task.xmldoc" path="declaration/member[@name='New(GISharp.Lib.GObject.Object?,GISharp.Lib.Gio.AsyncReadyCallback?,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        static unsafe System.IntPtr New(GISharp.Lib.GObject.Object? sourceObject, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null)
        {
            var sourceObject_ = sourceObject?.Handle ?? System.IntPtr.Zero;
            var (callback_, _, callbackData_) = GISharp.Lib.Gio.AsyncReadyCallbackMarshal.ToPointer(callback, GISharp.Runtime.CallbackScope.Async);
            var cancellable_ = cancellable?.Handle ?? System.IntPtr.Zero;
            var ret_ = g_task_new(sourceObject_,cancellable_,callback_,callbackData_);
            return ret_;
        }

        /// <include file="Task.xmldoc" path="declaration/member[@name='Task(GISharp.Lib.GObject.Object?,GISharp.Lib.Gio.AsyncReadyCallback?,GISharp.Lib.Gio.Cancellable?)']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        public Task(GISharp.Lib.GObject.Object? sourceObject, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null) : this(New(sourceObject, callback, cancellable), GISharp.Runtime.Transfer.Full)
        {
        }

        /// <summary>
        /// Checks that @result is a #GTask, and that @source_object is its
        /// source object (or that @source_object is %NULL and @result has no
        /// source object). This can be used in g_return_if_fail() checks.
        /// </summary>
        /// <param name="result">
        /// A #GAsyncResult
        /// </param>
        /// <param name="sourceObject">
        /// the source object
        ///   expected to be associated with the task
        /// </param>
        /// <returns>
        /// %TRUE if @result and @source_object are valid, %FALSE
        /// if not
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe GISharp.Runtime.Boolean g_task_is_valid(
        /* <type name="AsyncResult" type="gpointer" managed-name="AsyncResult" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr result,
        /* <type name="GObject.Object" type="gpointer" managed-name="GISharp.Lib.GObject.Object" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr sourceObject);

        /// <include file="Task.xmldoc" path="declaration/member[@name='IsValid(GISharp.Lib.Gio.IAsyncResult,GISharp.Lib.GObject.Object?)']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        public static unsafe System.Boolean IsValid(GISharp.Lib.Gio.IAsyncResult result, GISharp.Lib.GObject.Object? sourceObject)
        {
            var result_ = result.Handle;
            var sourceObject_ = sourceObject?.Handle ?? System.IntPtr.Zero;
            var ret_ = g_task_is_valid(result_,sourceObject_);
            var ret = (System.Boolean)ret_;
            return ret;
        }

        /// <summary>
        /// Creates a #GTask and then immediately calls g_task_return_error()
        /// on it. Use this in the wrapper function of an asynchronous method
        /// when you want to avoid even calling the virtual method. You can
        /// then use g_async_result_is_tagged() in the finish method wrapper to
        /// check if the result there is tagged as having been created by the
        /// wrapper method, and deal with it appropriately if so.
        /// </summary>
        /// <remarks>
        /// See also g_task_report_new_error().
        /// </remarks>
        /// <param name="sourceObject">
        /// the #GObject that owns
        ///   this task, or %NULL.
        /// </param>
        /// <param name="callback">
        /// a #GAsyncReadyCallback.
        /// </param>
        /// <param name="callbackData">
        /// user data passed to @callback.
        /// </param>
        /// <param name="sourceTag">
        /// an opaque pointer indicating the source of this task
        /// </param>
        /// <param name="error">
        /// error to report
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe void g_task_report_error(
        /* <type name="GObject.Object" type="gpointer" managed-name="GISharp.Lib.GObject.Object" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr sourceObject,
        /* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="UnmanagedAsyncReadyCallback" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:2 direction:in */
        System.IntPtr callback,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr callbackData,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr sourceTag,
        /* <type name="GLib.Error" type="GError*" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        System.IntPtr error);

        /// <include file="Task.xmldoc" path="declaration/member[@name='ReportError(GISharp.Lib.GObject.Object?,GISharp.Lib.Gio.AsyncReadyCallback?,System.IntPtr,GISharp.Lib.GLib.Error)']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        public static unsafe void ReportError(GISharp.Lib.GObject.Object? sourceObject, GISharp.Lib.Gio.AsyncReadyCallback? callback, System.IntPtr sourceTag, GISharp.Lib.GLib.Error error)
        {
            var sourceObject_ = sourceObject?.Handle ?? System.IntPtr.Zero;
            var (callback_, _, callbackData_) = GISharp.Lib.Gio.AsyncReadyCallbackMarshal.ToPointer(callback, GISharp.Runtime.CallbackScope.Async);
            var sourceTag_ = (System.IntPtr)sourceTag;
            var error_ = error.Take();
            g_task_report_error(sourceObject_, callback_, callbackData_, sourceTag_, error_);
        }

        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="GType" type="GType" managed-name="GISharp.Lib.GObject.GType" /> */
        /* transfer-ownership:full direction:out */
        static extern unsafe GISharp.Lib.GObject.GType g_task_get_type();

        /// <summary>
        /// Gets @task's #GCancellable
        /// </summary>
        /// <param name="task">
        /// a #GTask
        /// </param>
        /// <returns>
        /// @task's #GCancellable
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe System.IntPtr g_task_get_cancellable(
        /* <type name="Task" type="GTask*" managed-name="Task" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr task);

        /// <include file="Task.xmldoc" path="declaration/member[@name='GetCancellable()']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        private unsafe GISharp.Lib.Gio.Cancellable GetCancellable()
        {
            var task_ = Handle;
            var ret_ = g_task_get_cancellable(task_);
            var ret = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(ret_, GISharp.Runtime.Transfer.None)!;
            return ret;
        }

        /// <summary>
        /// Gets @task's check-cancellable flag. See
        /// g_task_set_check_cancellable() for more details.
        /// </summary>
        /// <param name="task">
        /// the #GTask
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe GISharp.Runtime.Boolean g_task_get_check_cancellable(
        /* <type name="Task" type="GTask*" managed-name="Task" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr task);

        /// <include file="Task.xmldoc" path="declaration/member[@name='GetCheckCancellable()']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        private unsafe System.Boolean GetCheckCancellable()
        {
            var task_ = Handle;
            var ret_ = g_task_get_check_cancellable(task_);
            var ret = (System.Boolean)ret_;
            return ret;
        }

        /// <summary>
        /// Gets the value of #GTask:completed. This changes from %FALSE to %TRUE after
        /// the taskâ€™s callback is invoked, and will return %FALSE if called from inside
        /// the callback.
        /// </summary>
        /// <param name="task">
        /// a #GTask.
        /// </param>
        /// <returns>
        /// %TRUE if the task has completed, %FALSE otherwise.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.44")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe GISharp.Runtime.Boolean g_task_get_completed(
        /* <type name="Task" type="GTask*" managed-name="Task" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr task);

        /// <include file="Task.xmldoc" path="declaration/member[@name='GetCompleted()']/*" />
        [GISharp.Runtime.SinceAttribute("2.44")]
        private unsafe System.Boolean GetCompleted()
        {
            var task_ = Handle;
            var ret_ = g_task_get_completed(task_);
            var ret = (System.Boolean)ret_;
            return ret;
        }

        /// <summary>
        /// Gets the #GMainContext that @task will return its result in (that
        /// is, the context that was the
        /// [thread-default main context][g-main-context-push-thread-default]
        /// at the point when @task was created).
        /// </summary>
        /// <remarks>
        /// This will always return a non-%NULL value, even if the task's
        /// context is the default #GMainContext.
        /// </remarks>
        /// <param name="task">
        /// a #GTask
        /// </param>
        /// <returns>
        /// @task's #GMainContext
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="GLib.MainContext" type="GMainContext*" managed-name="GISharp.Lib.GLib.MainContext" is-pointer="1" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe System.IntPtr g_task_get_context(
        /* <type name="Task" type="GTask*" managed-name="Task" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr task);

        /// <include file="Task.xmldoc" path="declaration/member[@name='GetContext()']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        private unsafe GISharp.Lib.GLib.MainContext GetContext()
        {
            var task_ = Handle;
            var ret_ = g_task_get_context(task_);
            var ret = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.MainContext>(ret_, GISharp.Runtime.Transfer.None)!;
            return ret;
        }

        /// <summary>
        /// Gets @task's priority
        /// </summary>
        /// <param name="task">
        /// a #GTask
        /// </param>
        /// <returns>
        /// @task's priority
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gint" type="gint" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe System.Int32 g_task_get_priority(
        /* <type name="Task" type="GTask*" managed-name="Task" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr task);

        /// <include file="Task.xmldoc" path="declaration/member[@name='GetPriority()']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        private unsafe System.Int32 GetPriority()
        {
            var task_ = Handle;
            var ret_ = g_task_get_priority(task_);
            var ret = (System.Int32)ret_;
            return ret;
        }

        /// <summary>
        /// Gets @task's return-on-cancel flag. See
        /// g_task_set_return_on_cancel() for more details.
        /// </summary>
        /// <param name="task">
        /// the #GTask
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe GISharp.Runtime.Boolean g_task_get_return_on_cancel(
        /* <type name="Task" type="GTask*" managed-name="Task" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr task);

        /// <include file="Task.xmldoc" path="declaration/member[@name='GetReturnOnCancel()']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        private unsafe System.Boolean GetReturnOnCancel()
        {
            var task_ = Handle;
            var ret_ = g_task_get_return_on_cancel(task_);
            var ret = (System.Boolean)ret_;
            return ret;
        }

        /// <summary>
        /// Gets the source object from @task. Like
        /// g_async_result_get_source_object(), but does not ref the object.
        /// </summary>
        /// <param name="task">
        /// a #GTask
        /// </param>
        /// <returns>
        /// @task's source object, or %NULL
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="GObject.Object" type="gpointer" managed-name="GISharp.Lib.GObject.Object" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 direction:out */
        static extern unsafe System.IntPtr g_task_get_source_object(
        /* <type name="Task" type="GTask*" managed-name="Task" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr task);

        /// <include file="Task.xmldoc" path="declaration/member[@name='GetSourceObject()']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        private unsafe GISharp.Lib.GObject.Object? GetSourceObject()
        {
            var task_ = Handle;
            var ret_ = g_task_get_source_object(task_);
            var ret = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GObject.Object>(ret_, GISharp.Runtime.Transfer.None);
            return ret;
        }

        /// <summary>
        /// Gets @task's source tag. See g_task_set_source_tag().
        /// </summary>
        /// <param name="task">
        /// a #GTask
        /// </param>
        /// <returns>
        /// @task's source tag
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 direction:out */
        static extern unsafe System.IntPtr g_task_get_source_tag(
        /* <type name="Task" type="GTask*" managed-name="Task" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr task);

        /// <include file="Task.xmldoc" path="declaration/member[@name='GetSourceTag()']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        private unsafe System.IntPtr GetSourceTag()
        {
            var task_ = Handle;
            var ret_ = g_task_get_source_tag(task_);
            var ret = (System.IntPtr)ret_;
            return ret;
        }

        /// <summary>
        /// Gets @task's `task_data`.
        /// </summary>
        /// <param name="task">
        /// a #GTask
        /// </param>
        /// <returns>
        /// @task's `task_data`.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 direction:out */
        static extern unsafe System.IntPtr g_task_get_task_data(
        /* <type name="Task" type="GTask*" managed-name="Task" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr task);

        /// <include file="Task.xmldoc" path="declaration/member[@name='GetTaskData()']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        private unsafe System.IntPtr GetTaskData()
        {
            var task_ = Handle;
            var ret_ = g_task_get_task_data(task_);
            var ret = (System.IntPtr)ret_;
            return ret;
        }

        /// <summary>
        /// Tests if @task resulted in an error.
        /// </summary>
        /// <param name="task">
        /// a #GTask.
        /// </param>
        /// <returns>
        /// %TRUE if the task resulted in an error, %FALSE otherwise.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe GISharp.Runtime.Boolean g_task_had_error(
        /* <type name="Task" type="GTask*" managed-name="Task" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr task);

        /// <include file="Task.xmldoc" path="declaration/member[@name='HadError()']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        public unsafe System.Boolean HadError()
        {
            var task_ = Handle;
            var ret_ = g_task_had_error(task_);
            var ret = (System.Boolean)ret_;
            return ret;
        }

        /// <summary>
        /// Gets the result of @task as a #gboolean.
        /// </summary>
        /// <remarks>
        /// If the task resulted in an error, or was cancelled, then this will
        /// instead return %FALSE and set @error.
        /// 
        /// Since this method transfers ownership of the return value (or
        /// error) to the caller, you may only call it once.
        /// </remarks>
        /// <param name="task">
        /// a #GTask.
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// the task result, or %FALSE on error
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:out */
        static extern unsafe GISharp.Runtime.Boolean g_task_propagate_boolean(
        /* <type name="Task" type="GTask*" managed-name="Task" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr task,
        /* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        ref System.IntPtr error);

        /// <include file="Task.xmldoc" path="declaration/member[@name='PropagateBoolean()']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        public unsafe void PropagateBoolean()
        {
            var task_ = Handle;
            var error_ = System.IntPtr.Zero;
            g_task_propagate_boolean(task_,ref error_);
            if (error_ != System.IntPtr.Zero)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>(error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Runtime.GErrorException(error);
            }
        }

        /// <summary>
        /// Gets the result of @task as an integer (#gssize).
        /// </summary>
        /// <remarks>
        /// If the task resulted in an error, or was cancelled, then this will
        /// instead return -1 and set @error.
        /// 
        /// Since this method transfers ownership of the return value (or
        /// error) to the caller, you may only call it once.
        /// </remarks>
        /// <param name="task">
        /// a #GTask.
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// the task result, or -1 on error
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gssize" type="gssize" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe System.IntPtr g_task_propagate_int(
        /* <type name="Task" type="GTask*" managed-name="Task" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr task,
        /* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        ref System.IntPtr error);

        /// <include file="Task.xmldoc" path="declaration/member[@name='PropagateInt()']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        public unsafe System.Int32 PropagateInt()
        {
            var task_ = Handle;
            var error_ = System.IntPtr.Zero;
            var ret_ = g_task_propagate_int(task_,ref error_);
            if (error_ != System.IntPtr.Zero)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>(error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Runtime.GErrorException(error);
            }

            var ret = (System.Int32)ret_;
            return ret;
        }

        /// <summary>
        /// Gets the result of @task as a pointer, and transfers ownership
        /// of that value to the caller.
        /// </summary>
        /// <remarks>
        /// If the task resulted in an error, or was cancelled, then this will
        /// instead return %NULL and set @error.
        /// 
        /// Since this method transfers ownership of the return value (or
        /// error) to the caller, you may only call it once.
        /// </remarks>
        /// <param name="task">
        /// a #GTask
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// the task result, or %NULL on error
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:full nullable:1 direction:out */
        static extern unsafe System.IntPtr g_task_propagate_pointer(
        /* <type name="Task" type="GTask*" managed-name="Task" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr task,
        /* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        ref System.IntPtr error);

        /// <include file="Task.xmldoc" path="declaration/member[@name='PropagatePointer()']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        public unsafe System.IntPtr PropagatePointer()
        {
            var task_ = Handle;
            var error_ = System.IntPtr.Zero;
            var ret_ = g_task_propagate_pointer(task_,ref error_);
            if (error_ != System.IntPtr.Zero)
            {
                var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>(error_, GISharp.Runtime.Transfer.Full);
                throw new GISharp.Runtime.GErrorException(error);
            }

            var ret = (System.IntPtr)ret_;
            return ret;
        }

        /// <summary>
        /// Sets @task's result to @result and completes the task (see
        /// g_task_return_pointer() for more discussion of exactly what this
        /// means).
        /// </summary>
        /// <param name="task">
        /// a #GTask.
        /// </param>
        /// <param name="result">
        /// the #gboolean result of a task function.
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe void g_task_return_boolean(
        /* <type name="Task" type="GTask*" managed-name="Task" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr task,
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.Boolean result);

        /// <include file="Task.xmldoc" path="declaration/member[@name='ReturnBoolean(System.Boolean)']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        public unsafe void ReturnBoolean(System.Boolean result)
        {
            var task_ = Handle;
            var result_ = (GISharp.Runtime.Boolean)result;
            g_task_return_boolean(task_, result_);
        }

        /// <summary>
        /// Sets @task's result to @error (which @task assumes ownership of)
        /// and completes the task (see g_task_return_pointer() for more
        /// discussion of exactly what this means).
        /// </summary>
        /// <remarks>
        /// Note that since the task takes ownership of @error, and since the
        /// task may be completed before returning from g_task_return_error(),
        /// you cannot assume that @error is still valid after calling this.
        /// Call g_error_copy() on the error if you need to keep a local copy
        /// as well.
        /// 
        /// See also g_task_return_new_error().
        /// </remarks>
        /// <param name="task">
        /// a #GTask.
        /// </param>
        /// <param name="error">
        /// the #GError result of a task function.
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe void g_task_return_error(
        /* <type name="Task" type="GTask*" managed-name="Task" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr task,
        /* <type name="GLib.Error" type="GError*" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
        /* transfer-ownership:full direction:in */
        System.IntPtr error);

        /// <include file="Task.xmldoc" path="declaration/member[@name='ReturnError(GISharp.Lib.GLib.Error)']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        public unsafe void ReturnError(GISharp.Lib.GLib.Error error)
        {
            var task_ = Handle;
            var error_ = error.Take();
            g_task_return_error(task_, error_);
        }

        /// <summary>
        /// Checks if @task's #GCancellable has been cancelled, and if so, sets
        /// @task's error accordingly and completes the task (see
        /// g_task_return_pointer() for more discussion of exactly what this
        /// means).
        /// </summary>
        /// <param name="task">
        /// a #GTask
        /// </param>
        /// <returns>
        /// %TRUE if @task has been cancelled, %FALSE if not
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe GISharp.Runtime.Boolean g_task_return_error_if_cancelled(
        /* <type name="Task" type="GTask*" managed-name="Task" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr task);

        /// <include file="Task.xmldoc" path="declaration/member[@name='ReturnErrorIfCancelled()']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        public unsafe System.Boolean ReturnErrorIfCancelled()
        {
            var task_ = Handle;
            var ret_ = g_task_return_error_if_cancelled(task_);
            var ret = (System.Boolean)ret_;
            return ret;
        }

        /// <summary>
        /// Sets @task's result to @result and completes the task (see
        /// g_task_return_pointer() for more discussion of exactly what this
        /// means).
        /// </summary>
        /// <param name="task">
        /// a #GTask.
        /// </param>
        /// <param name="result">
        /// the integer (#gssize) result of a task function.
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe void g_task_return_int(
        /* <type name="Task" type="GTask*" managed-name="Task" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr task,
        /* <type name="gssize" type="gssize" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr result);

        /// <include file="Task.xmldoc" path="declaration/member[@name='ReturnInt(System.Int32)']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        public unsafe void ReturnInt(System.Int32 result)
        {
            var task_ = Handle;
            var result_ = (System.IntPtr)result;
            g_task_return_int(task_, result_);
        }

        /// <summary>
        /// Sets @task's result to @result and completes the task. If @result
        /// is not %NULL, then @result_destroy will be used to free @result if
        /// the caller does not take ownership of it with
        /// g_task_propagate_pointer().
        /// </summary>
        /// <remarks>
        /// "Completes the task" means that for an ordinary asynchronous task
        /// it will either invoke the task's callback, or else queue that
        /// callback to be invoked in the proper #GMainContext, or in the next
        /// iteration of the current #GMainContext. For a task run via
        /// g_task_run_in_thread() or g_task_run_in_thread_sync(), calling this
        /// method will save @result to be returned to the caller later, but
        /// the task will not actually be completed until the #GTaskThreadFunc
        /// exits.
        /// 
        /// Note that since the task may be completed before returning from
        /// g_task_return_pointer(), you cannot assume that @result is still
        /// valid after calling this, unless you are still holding another
        /// reference on it.
        /// </remarks>
        /// <param name="task">
        /// a #GTask
        /// </param>
        /// <param name="result">
        /// the pointer result of a task
        ///     function
        /// </param>
        /// <param name="resultDestroy">
        /// a #GDestroyNotify function.
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe void g_task_return_pointer(
        /* <type name="Task" type="GTask*" managed-name="Task" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr task,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:full nullable:1 allow-none:1 direction:in */
        System.IntPtr result,
        /* <type name="GLib.DestroyNotify" type="GDestroyNotify" managed-name="GISharp.Lib.GLib.UnmanagedDestroyNotify" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:async direction:in */
        System.IntPtr resultDestroy);

        /// <summary>
        /// Sets or clears @task's check-cancellable flag. If this is %TRUE
        /// (the default), then g_task_propagate_pointer(), etc, and
        /// g_task_had_error() will check the task's #GCancellable first, and
        /// if it has been cancelled, then they will consider the task to have
        /// returned an "Operation was cancelled" error
        /// (%G_IO_ERROR_CANCELLED), regardless of any other error or return
        /// value the task may have had.
        /// </summary>
        /// <remarks>
        /// If @check_cancellable is %FALSE, then the #GTask will not check the
        /// cancellable itself, and it is up to @task's owner to do this (eg,
        /// via g_task_return_error_if_cancelled()).
        /// 
        /// If you are using g_task_set_return_on_cancel() as well, then
        /// you must leave check-cancellable set %TRUE.
        /// </remarks>
        /// <param name="task">
        /// the #GTask
        /// </param>
        /// <param name="checkCancellable">
        /// whether #GTask will check the state of
        ///   its #GCancellable for you.
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe void g_task_set_check_cancellable(
        /* <type name="Task" type="GTask*" managed-name="Task" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr task,
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.Boolean checkCancellable);

        /// <include file="Task.xmldoc" path="declaration/member[@name='SetCheckCancellable(System.Boolean)']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        private unsafe void SetCheckCancellable(System.Boolean checkCancellable)
        {
            var task_ = Handle;
            var checkCancellable_ = (GISharp.Runtime.Boolean)checkCancellable;
            g_task_set_check_cancellable(task_, checkCancellable_);
        }

        /// <summary>
        /// Sets @task's priority. If you do not call this, it will default to
        /// %G_PRIORITY_DEFAULT.
        /// </summary>
        /// <remarks>
        /// This will affect the priority of #GSources created with
        /// g_task_attach_source() and the scheduling of tasks run in threads,
        /// and can also be explicitly retrieved later via
        /// g_task_get_priority().
        /// </remarks>
        /// <param name="task">
        /// the #GTask
        /// </param>
        /// <param name="priority">
        /// the [priority][io-priority] of the request
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe void g_task_set_priority(
        /* <type name="Task" type="GTask*" managed-name="Task" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr task,
        /* <type name="gint" type="gint" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        System.Int32 priority);

        /// <include file="Task.xmldoc" path="declaration/member[@name='SetPriority(System.Int32)']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        private unsafe void SetPriority(System.Int32 priority)
        {
            var task_ = Handle;
            var priority_ = (System.Int32)priority;
            g_task_set_priority(task_, priority_);
        }

        /// <summary>
        /// Sets or clears @task's return-on-cancel flag. This is only
        /// meaningful for tasks run via g_task_run_in_thread() or
        /// g_task_run_in_thread_sync().
        /// </summary>
        /// <remarks>
        /// If @return_on_cancel is %TRUE, then cancelling @task's
        /// #GCancellable will immediately cause it to return, as though the
        /// task's #GTaskThreadFunc had called
        /// g_task_return_error_if_cancelled() and then returned.
        /// 
        /// This allows you to create a cancellable wrapper around an
        /// uninterruptable function. The #GTaskThreadFunc just needs to be
        /// careful that it does not modify any externally-visible state after
        /// it has been cancelled. To do that, the thread should call
        /// g_task_set_return_on_cancel() again to (atomically) set
        /// return-on-cancel %FALSE before making externally-visible changes;
        /// if the task gets cancelled before the return-on-cancel flag could
        /// be changed, g_task_set_return_on_cancel() will indicate this by
        /// returning %FALSE.
        /// 
        /// You can disable and re-enable this flag multiple times if you wish.
        /// If the task's #GCancellable is cancelled while return-on-cancel is
        /// %FALSE, then calling g_task_set_return_on_cancel() to set it %TRUE
        /// again will cause the task to be cancelled at that point.
        /// 
        /// If the task's #GCancellable is already cancelled before you call
        /// g_task_run_in_thread()/g_task_run_in_thread_sync(), then the
        /// #GTaskThreadFunc will still be run (for consistency), but the task
        /// will also be completed right away.
        /// </remarks>
        /// <param name="task">
        /// the #GTask
        /// </param>
        /// <param name="returnOnCancel">
        /// whether the task returns automatically when
        ///   it is cancelled.
        /// </param>
        /// <returns>
        /// %TRUE if @task's return-on-cancel flag was changed to
        ///   match @return_on_cancel. %FALSE if @task has already been
        ///   cancelled.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe GISharp.Runtime.Boolean g_task_set_return_on_cancel(
        /* <type name="Task" type="GTask*" managed-name="Task" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr task,
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Runtime.Boolean returnOnCancel);

        /// <include file="Task.xmldoc" path="declaration/member[@name='SetReturnOnCancel(System.Boolean)']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        public unsafe System.Boolean SetReturnOnCancel(System.Boolean returnOnCancel)
        {
            var task_ = Handle;
            var returnOnCancel_ = (GISharp.Runtime.Boolean)returnOnCancel;
            var ret_ = g_task_set_return_on_cancel(task_,returnOnCancel_);
            var ret = (System.Boolean)ret_;
            return ret;
        }

        /// <summary>
        /// Sets @task's source tag. You can use this to tag a task return
        /// value with a particular pointer (usually a pointer to the function
        /// doing the tagging) and then later check it using
        /// g_task_get_source_tag() (or g_async_result_is_tagged()) in the
        /// task's "finish" function, to figure out if the response came from a
        /// particular place.
        /// </summary>
        /// <param name="task">
        /// the #GTask
        /// </param>
        /// <param name="sourceTag">
        /// an opaque pointer indicating the source of this task
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe void g_task_set_source_tag(
        /* <type name="Task" type="GTask*" managed-name="Task" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr task,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr sourceTag);

        /// <include file="Task.xmldoc" path="declaration/member[@name='SetSourceTag(System.IntPtr)']/*" />
        [GISharp.Runtime.SinceAttribute("2.36")]
        private unsafe void SetSourceTag(System.IntPtr sourceTag)
        {
            var task_ = Handle;
            var sourceTag_ = (System.IntPtr)sourceTag;
            g_task_set_source_tag(task_, sourceTag_);
        }

        /// <summary>
        /// Sets @task's task data (freeing the existing task data, if any).
        /// </summary>
        /// <param name="task">
        /// the #GTask
        /// </param>
        /// <param name="taskData">
        /// task-specific data
        /// </param>
        /// <param name="taskDataDestroy">
        /// #GDestroyNotify for @task_data
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.36")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe void g_task_set_task_data(
        /* <type name="Task" type="GTask*" managed-name="Task" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr task,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr taskData,
        /* <type name="GLib.DestroyNotify" type="GDestroyNotify" managed-name="GISharp.Lib.GLib.UnmanagedDestroyNotify" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:async direction:in */
        System.IntPtr taskDataDestroy);

        GISharp.Lib.GObject.Object? GISharp.Lib.Gio.IAsyncResult.DoGetSourceObject()
        {
            throw new System.NotImplementedException();
        }

        System.IntPtr GISharp.Lib.Gio.IAsyncResult.DoGetUserData()
        {
            throw new System.NotImplementedException();
        }

        System.Boolean GISharp.Lib.Gio.IAsyncResult.DoIsTagged(System.IntPtr sourceTag)
        {
            throw new System.NotImplementedException();
        }
    }
}