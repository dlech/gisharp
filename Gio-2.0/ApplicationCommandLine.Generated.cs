// ATTENTION: This file is automatically generated. Do not edit by manually.
namespace GISharp.Lib.Gio
{
    /// <summary>
    /// <see cref="ApplicationCommandLine"/> represents a command-line invocation of
    /// an application.  It is created by #GApplication and emitted
    /// in the #GApplication::command-line signal and virtual function.
    /// </summary>
    /// <remarks>
    /// The class contains the list of arguments that the program was invoked
    /// with.  It is also possible to query if the commandline invocation was
    /// local (ie: the current process is running in direct response to the
    /// invocation) or remote (ie: some other process forwarded the
    /// commandline to this process).
    /// 
    /// The GApplicationCommandLine object can provide the <paramref name="argc"/> and <paramref name="argv"/>
    /// parameters for use with the #GOptionContext command-line parsing API,
    /// with the <see cref="ApplicationCommandLine.GetArguments"/> function. See
    /// [gapplication-example-cmdline3.c][gapplication-example-cmdline3]
    /// for an example.
    /// 
    /// The exit status of the originally-invoked process may be set and
    /// messages can be printed to stdout or stderr of that process.  The
    /// lifecycle of the originally-invoked process is tied to the lifecycle
    /// of this object (ie: the process exits when the last reference is
    /// dropped).
    /// 
    /// The main use for <see cref="ApplicationCommandLine"/> (and the
    /// #GApplication::command-line signal) is 'Emacs server' like use cases:
    /// You can set the `EDITOR` environment variable to have e.g. git use
    /// your favourite editor to edit commit messages, and if you already
    /// have an instance of the editor running, the editing will happen
    /// in the running instance, instead of opening a new one. An important
    /// aspect of this use case is that the process that gets started by git
    /// does not return until the editing is done.
    /// 
    /// Normally, the commandline is completely handled in the
    /// #GApplication::command-line handler. The launching instance exits
    /// once the signal handler in the primary instance has returned, and
    /// the return value of the signal handler becomes the exit status
    /// of the launching instance.
    /// |[&lt;!-- language="C" --&gt;
    /// static int
    /// command_line (GApplication            *application,
    ///               GApplicationCommandLine *cmdline)
    /// {
    ///   gchar **argv;
    ///   gint argc;
    ///   gint i;
    /// 
    ///   argv = g_application_command_line_get_arguments (cmdline, &amp;argc);
    /// 
    ///   g_application_command_line_print (cmdline,
    ///                                     "This text is written back\n"
    ///                                     "to stdout of the caller\n");
    /// 
    ///   for (i = 0; i &lt; argc; i++)
    ///     g_print ("argument %d: %s\n", i, argv[i]);
    /// 
    ///   g_strfreev (argv);
    /// 
    ///   return 0;
    /// }
    /// ]|
    /// The complete example can be found here:
    /// [gapplication-example-cmdline.c](https://git.gnome.org/browse/glib/tree/gio/tests/gapplication-example-cmdline.c)
    /// 
    /// In more complicated cases, the handling of the comandline can be
    /// split between the launcher and the primary instance.
    /// |[&lt;!-- language="C" --&gt;
    /// static gboolean
    ///  test_local_cmdline (GApplication   *application,
    ///                      gchar        ***arguments,
    ///                      gint           *exit_status)
    /// {
    ///   gint i, j;
    ///   gchar **argv;
    /// 
    ///   argv = *arguments;
    /// 
    ///   i = 1;
    ///   while (argv[i])
    ///     {
    ///       if (g_str_has_prefix (argv[i], "--local-"))
    ///         {
    ///           g_print ("handling argument %s locally\n", argv[i]);
    ///           g_free (argv[i]);
    ///           for (j = i; argv[j]; j++)
    ///             argv[j] = argv[j + 1];
    ///         }
    ///       else
    ///         {
    ///           g_print ("not handling argument %s locally\n", argv[i]);
    ///           i++;
    ///         }
    ///     }
    /// 
    ///   *exit_status = 0;
    /// 
    ///   return FALSE;
    /// }
    /// 
    /// static void
    /// test_application_class_init (TestApplicationClass *class)
    /// {
    ///   G_APPLICATION_CLASS (class)-&gt;local_command_line = test_local_cmdline;
    /// 
    ///   ...
    /// }
    /// ]|
    /// In this example of split commandline handling, options that start
    /// with `--local-` are handled locally, all other options are passed
    /// to the #GApplication::command-line handler which runs in the primary
    /// instance.
    /// 
    /// The complete example can be found here:
    /// [gapplication-example-cmdline2.c](https://git.gnome.org/browse/glib/tree/gio/tests/gapplication-example-cmdline2.c)
    /// 
    /// If handling the commandline requires a lot of work, it may
    /// be better to defer it.
    /// |[&lt;!-- language="C" --&gt;
    /// static gboolean
    /// my_cmdline_handler (gpointer data)
    /// {
    ///   GApplicationCommandLine *cmdline = data;
    /// 
    ///   // do the heavy lifting in an idle
    /// 
    ///   g_application_command_line_set_exit_status (cmdline, 0);
    ///   g_object_unref (cmdline); // this releases the application
    /// 
    ///   return G_SOURCE_REMOVE;
    /// }
    /// 
    /// static int
    /// command_line (GApplication            *application,
    ///               GApplicationCommandLine *cmdline)
    /// {
    ///   // keep the application running until we are done with this commandline
    ///   g_application_hold (application);
    /// 
    ///   g_object_set_data_full (G_OBJECT (cmdline),
    ///                           "application", application,
    ///                           (GDestroyNotify)g_application_release);
    /// 
    ///   g_object_ref (cmdline);
    ///   g_idle_add (my_cmdline_handler, cmdline);
    /// 
    ///   return 0;
    /// }
    /// ]|
    /// In this example the commandline is not completely handled before
    /// the #GApplication::command-line handler returns. Instead, we keep
    /// a reference to the <see cref="ApplicationCommandLine"/> object and handle it
    /// later (in this example, in an idle). Note that it is necessary to
    /// hold the application until you are done with the commandline.
    /// 
    /// The complete example can be found here:
    /// [gapplication-example-cmdline3.c](https://git.gnome.org/browse/glib/tree/gio/tests/gapplication-example-cmdline3.c)
    /// </remarks>
    [GISharp.Runtime.GTypeAttribute("GApplicationCommandLine", IsProxyForUnmanagedType = true)]
    [GISharp.Runtime.GTypeStructAttribute(typeof(ApplicationCommandLineClass))]
    public partial class ApplicationCommandLine : GISharp.Lib.GObject.Object
    {
        static readonly GISharp.Lib.GObject.GType _GType = g_application_command_line_get_type();

        unsafe protected new struct Struct
        {
#pragma warning disable CS0649
            public GISharp.Lib.GObject.Object.Struct ParentInstance;
            public System.IntPtr Priv;
#pragma warning restore CS0649
        }

        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [GISharp.Runtime.GPropertyAttribute("arguments", Construct = GISharp.Runtime.GPropertyConstruct.Only)]
        public GISharp.Lib.GLib.Variant Arguments_ { set => SetProperty("arguments", value); }
        [GISharp.Runtime.GPropertyAttribute("is-remote")]
        public System.Boolean IsRemote_ { get => (System.Boolean)GetProperty("is-remote"); }
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [GISharp.Runtime.GPropertyAttribute("options", Construct = GISharp.Runtime.GPropertyConstruct.Only)]
        public GISharp.Lib.GLib.Variant Options_ { set => SetProperty("options", value); }
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [GISharp.Runtime.GPropertyAttribute("platform-data", Construct = GISharp.Runtime.GPropertyConstruct.Only)]
        public GISharp.Lib.GLib.Variant PlatformData_ { set => SetProperty("platform-data", value); }

        /// <summary>
        /// Gets the list of arguments that was passed on the command line.
        /// </summary>
        /// <remarks>
        /// The strings in the array may contain non-UTF-8 data on UNIX (such as
        /// filenames or arguments given in the system locale) but are always in
        /// UTF-8 on Windows.
        /// 
        /// If you wish to use the return value with #GOptionContext, you must
        /// use g_option_context_parse_strv().
        /// 
        /// The return value is <c>null</c>-terminated and should be freed using
        /// g_strfreev().
        /// </remarks>
        [GISharp.Runtime.SinceAttribute("2.28")]
        public GISharp.Runtime.IArray<GISharp.Lib.GLib.Filename> Arguments { get => GetArguments(); }

        /// <summary>
        /// Gets the working directory of the command line invocation.
        /// The string may contain non-utf8 data.
        /// </summary>
        /// <remarks>
        /// It is possible that the remote application did not send a working
        /// directory, so this may be <c>null</c>.
        /// 
        /// The return value should not be modified or freed and is valid for as
        /// long as <paramref name="cmdline"/> exists.
        /// </remarks>
        [GISharp.Runtime.SinceAttribute("2.28")]
        public GISharp.Lib.GLib.Filename Cwd { get => GetCwd(); }

        /// <summary>
        /// Gets the contents of the 'environ' variable of the command line
        /// invocation, as would be returned by g_get_environ(), ie as a
        /// <c>null</c>-terminated list of strings in the form 'NAME=VALUE'.
        /// The strings may contain non-utf8 data.
        /// </summary>
        /// <remarks>
        /// The remote application usually does not send an environment.  Use
        /// <see cref="ApplicationFlags.SendEnvironment"/> to affect that.  Even with this flag
        /// set it is possible that the environment is still not available (due
        /// to invocation messages from other applications).
        /// 
        /// The return value should not be modified or freed and is valid for as
        /// long as <paramref name="cmdline"/> exists.
        /// 
        /// See <see cref="ApplicationCommandLine.GetEnvironmentVariable"/> if you are only interested
        /// in the value of a single environment variable.
        /// </remarks>
        [GISharp.Runtime.SinceAttribute("2.28")]
        public GISharp.Runtime.FilenameArray Environment { get => GetEnvironment(); }

        /// <summary>
        /// Gets the exit status of <paramref name="cmdline"/>.  See
        /// <see cref="ApplicationCommandLine.SetExitStatus"/> for more information.
        /// </summary>
        [GISharp.Runtime.SinceAttribute("2.28")]
        public System.Int32 ExitStatus { get => GetExitStatus(); set => SetExitStatus(value); }

        /// <summary>
        /// Determines if <paramref name="cmdline"/> represents a remote invocation.
        /// </summary>
        [GISharp.Runtime.SinceAttribute("2.28")]
        public System.Boolean IsRemote { get => GetIsRemote(); }

        /// <summary>
        /// Gets the options there were passed to g_application_command_line().
        /// </summary>
        /// <remarks>
        /// If you did not override local_command_line() then these are the same
        /// options that were parsed according to the #GOptionEntrys added to the
        /// application with g_application_add_main_option_entries() and possibly
        /// modified from your GApplication::handle-local-options handler.
        /// 
        /// If no options were sent then an empty dictionary is returned so that
        /// you don't need to check for <c>null</c>.
        /// </remarks>
        [GISharp.Runtime.SinceAttribute("2.40")]
        public GISharp.Lib.GLib.VariantDict Options { get => GetOptions(); }

        /// <summary>
        /// Gets the platform data associated with the invocation of <paramref name="cmdline"/>.
        /// </summary>
        /// <remarks>
        /// This is a #GVariant dictionary containing information about the
        /// context in which the invocation occurred.  It typically contains
        /// information like the current working directory and the startup
        /// notification ID.
        /// 
        /// For local invocation, it will be <c>null</c>.
        /// </remarks>
        [GISharp.Runtime.SinceAttribute("2.28")]
        public GISharp.Lib.GLib.Variant PlatformData { get => GetPlatformData(); }

        /// <summary>
        /// Gets the stdin of the invoking process.
        /// </summary>
        /// <remarks>
        /// The <see cref="InputStream"/> can be used to read data passed to the standard
        /// input of the invoking process.
        /// This doesn't work on all platforms.  Presently, it is only available
        /// on UNIX when using a DBus daemon capable of passing file descriptors.
        /// If stdin is not available then <c>null</c> will be returned.  In the
        /// future, support may be expanded to other platforms.
        /// 
        /// You must only call this function once per commandline invocation.
        /// </remarks>
        [GISharp.Runtime.SinceAttribute("2.34")]
        public GISharp.Lib.Gio.InputStream Stdin { get => GetStdin(); }

        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        public ApplicationCommandLine(System.IntPtr handle, GISharp.Runtime.Transfer ownership) : base(handle, ownership)
        {
        }

        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="GType" type="GType" managed-name="GISharp.Lib.GObject.GType" /> */
        /* transfer-ownership:full direction:out */
        static extern unsafe GISharp.Lib.GObject.GType g_application_command_line_get_type();

        /// <summary>
        /// Gets the list of arguments that was passed on the command line.
        /// </summary>
        /// <remarks>
        /// The strings in the array may contain non-UTF-8 data on UNIX (such as
        /// filenames or arguments given in the system locale) but are always in
        /// UTF-8 on Windows.
        /// 
        /// If you wish to use the return value with #GOptionContext, you must
        /// use g_option_context_parse_strv().
        /// 
        /// The return value is %NULL-terminated and should be freed using
        /// g_strfreev().
        /// </remarks>
        /// <param name="cmdline">
        /// a #GApplicationCommandLine
        /// </param>
        /// <param name="argc">
        /// the length of the arguments array, or %NULL
        /// </param>
        /// <returns>
        /// 
        ///      the string array containing the arguments (the argv)
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.28")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <array length="0" zero-terminated="0" type="gchar**" managed-name="GISharp.Runtime.IArray`1[T]" is-pointer="1">
*   <type name="filename" managed-name="GISharp.Lib.GLib.Filename" />
* </array> */
        /* transfer-ownership:full direction:out */
        static extern unsafe System.IntPtr g_application_command_line_get_arguments(
        /* <type name="ApplicationCommandLine" type="GApplicationCommandLine*" managed-name="ApplicationCommandLine" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr cmdline,
        /* <type name="gint" type="int*" managed-name="System.Int32" is-pointer="1" /> */
        /* direction:out caller-allocates:0 transfer-ownership:full optional:1 allow-none:1 */
        System.Int32* argc);

        /// <summary>
        /// Gets the list of arguments that was passed on the command line.
        /// </summary>
        /// <remarks>
        /// The strings in the array may contain non-UTF-8 data on UNIX (such as
        /// filenames or arguments given in the system locale) but are always in
        /// UTF-8 on Windows.
        /// 
        /// If you wish to use the return value with #GOptionContext, you must
        /// use g_option_context_parse_strv().
        /// 
        /// The return value is <c>null</c>-terminated and should be freed using
        /// g_strfreev().
        /// </remarks>
        /// <returns>
        /// 
        ///      the string array containing the arguments (the argv)
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.28")]
        private unsafe GISharp.Runtime.IArray<GISharp.Lib.GLib.Filename> GetArguments()
        {
            var cmdline_ = Handle;
            System.Int32 argc_;
            var ret_ = g_application_command_line_get_arguments(cmdline_,&argc_);
            var ret = GISharp.Runtime.CPtrArray.GetInstance<GISharp.Lib.GLib.Filename>(ret_, (int)argc_, GISharp.Runtime.Transfer.Full);
            return ret;
        }

        /// <summary>
        /// Gets the working directory of the command line invocation.
        /// The string may contain non-utf8 data.
        /// </summary>
        /// <remarks>
        /// It is possible that the remote application did not send a working
        /// directory, so this may be %NULL.
        /// 
        /// The return value should not be modified or freed and is valid for as
        /// long as @cmdline exists.
        /// </remarks>
        /// <param name="cmdline">
        /// a #GApplicationCommandLine
        /// </param>
        /// <returns>
        /// the current directory, or %NULL
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.28")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="filename" type="const gchar*" managed-name="GISharp.Lib.GLib.Filename" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 direction:out */
        static extern unsafe System.IntPtr g_application_command_line_get_cwd(
        /* <type name="ApplicationCommandLine" type="GApplicationCommandLine*" managed-name="ApplicationCommandLine" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr cmdline);

        /// <summary>
        /// Gets the working directory of the command line invocation.
        /// The string may contain non-utf8 data.
        /// </summary>
        /// <remarks>
        /// It is possible that the remote application did not send a working
        /// directory, so this may be <c>null</c>.
        /// 
        /// The return value should not be modified or freed and is valid for as
        /// long as <paramref name="cmdline"/> exists.
        /// </remarks>
        /// <returns>
        /// the current directory, or <c>null</c>
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.28")]
        private unsafe GISharp.Lib.GLib.Filename GetCwd()
        {
            var cmdline_ = Handle;
            var ret_ = g_application_command_line_get_cwd(cmdline_);
            var ret = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Filename>(ret_, GISharp.Runtime.Transfer.None);
            return ret;
        }

        /// <summary>
        /// Gets the contents of the 'environ' variable of the command line
        /// invocation, as would be returned by g_get_environ(), ie as a
        /// %NULL-terminated list of strings in the form 'NAME=VALUE'.
        /// The strings may contain non-utf8 data.
        /// </summary>
        /// <remarks>
        /// The remote application usually does not send an environment.  Use
        /// %G_APPLICATION_SEND_ENVIRONMENT to affect that.  Even with this flag
        /// set it is possible that the environment is still not available (due
        /// to invocation messages from other applications).
        /// 
        /// The return value should not be modified or freed and is valid for as
        /// long as @cmdline exists.
        /// 
        /// See g_application_command_line_getenv() if you are only interested
        /// in the value of a single environment variable.
        /// </remarks>
        /// <param name="cmdline">
        /// a #GApplicationCommandLine
        /// </param>
        /// <returns>
        /// 
        ///     the environment strings, or %NULL if they were not sent
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.28")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <array type="gchar**" zero-terminated="1" managed-name="GISharp.Runtime.FilenameArray" is-pointer="1">
*   <type name="filename" managed-name="GISharp.Lib.GLib.Filename" />
* </array> */
        /* transfer-ownership:none direction:out */
        static extern unsafe System.IntPtr g_application_command_line_get_environ(
        /* <type name="ApplicationCommandLine" type="GApplicationCommandLine*" managed-name="ApplicationCommandLine" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr cmdline);

        /// <summary>
        /// Gets the contents of the 'environ' variable of the command line
        /// invocation, as would be returned by g_get_environ(), ie as a
        /// <c>null</c>-terminated list of strings in the form 'NAME=VALUE'.
        /// The strings may contain non-utf8 data.
        /// </summary>
        /// <remarks>
        /// The remote application usually does not send an environment.  Use
        /// <see cref="ApplicationFlags.SendEnvironment"/> to affect that.  Even with this flag
        /// set it is possible that the environment is still not available (due
        /// to invocation messages from other applications).
        /// 
        /// The return value should not be modified or freed and is valid for as
        /// long as <paramref name="cmdline"/> exists.
        /// 
        /// See <see cref="ApplicationCommandLine.GetEnvironmentVariable"/> if you are only interested
        /// in the value of a single environment variable.
        /// </remarks>
        /// <returns>
        /// 
        ///     the environment strings, or <c>null</c> if they were not sent
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.28")]
        private unsafe GISharp.Runtime.FilenameArray GetEnvironment()
        {
            var cmdline_ = Handle;
            var ret_ = g_application_command_line_get_environ(cmdline_);
            var ret = GISharp.Runtime.Opaque.GetInstance<GISharp.Runtime.FilenameArray>(ret_, GISharp.Runtime.Transfer.None);
            return ret;
        }

        /// <summary>
        /// Gets the exit status of @cmdline.  See
        /// g_application_command_line_set_exit_status() for more information.
        /// </summary>
        /// <param name="cmdline">
        /// a #GApplicationCommandLine
        /// </param>
        /// <returns>
        /// the exit status
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.28")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gint" type="int" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe System.Int32 g_application_command_line_get_exit_status(
        /* <type name="ApplicationCommandLine" type="GApplicationCommandLine*" managed-name="ApplicationCommandLine" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr cmdline);

        /// <summary>
        /// Gets the exit status of <paramref name="cmdline"/>.  See
        /// <see cref="ApplicationCommandLine.SetExitStatus"/> for more information.
        /// </summary>
        /// <returns>
        /// the exit status
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.28")]
        private unsafe System.Int32 GetExitStatus()
        {
            var cmdline_ = Handle;
            var ret_ = g_application_command_line_get_exit_status(cmdline_);
            var ret = (System.Int32)ret_;
            return ret;
        }

        /// <summary>
        /// Determines if @cmdline represents a remote invocation.
        /// </summary>
        /// <param name="cmdline">
        /// a #GApplicationCommandLine
        /// </param>
        /// <returns>
        /// %TRUE if the invocation was remote
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.28")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe System.Boolean g_application_command_line_get_is_remote(
        /* <type name="ApplicationCommandLine" type="GApplicationCommandLine*" managed-name="ApplicationCommandLine" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr cmdline);

        /// <summary>
        /// Determines if <paramref name="cmdline"/> represents a remote invocation.
        /// </summary>
        /// <returns>
        /// <c>true</c> if the invocation was remote
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.28")]
        private unsafe System.Boolean GetIsRemote()
        {
            var cmdline_ = Handle;
            var ret_ = g_application_command_line_get_is_remote(cmdline_);
            var ret = (System.Boolean)ret_;
            return ret;
        }

        /// <summary>
        /// Gets the options there were passed to g_application_command_line().
        /// </summary>
        /// <remarks>
        /// If you did not override local_command_line() then these are the same
        /// options that were parsed according to the #GOptionEntrys added to the
        /// application with g_application_add_main_option_entries() and possibly
        /// modified from your GApplication::handle-local-options handler.
        /// 
        /// If no options were sent then an empty dictionary is returned so that
        /// you don't need to check for %NULL.
        /// </remarks>
        /// <param name="cmdline">
        /// a #GApplicationCommandLine
        /// </param>
        /// <returns>
        /// a #GVariantDict with the options
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.40")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="GLib.VariantDict" type="GVariantDict*" managed-name="GISharp.Lib.GLib.VariantDict" is-pointer="1" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe System.IntPtr g_application_command_line_get_options_dict(
        /* <type name="ApplicationCommandLine" type="GApplicationCommandLine*" managed-name="ApplicationCommandLine" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr cmdline);

        /// <summary>
        /// Gets the options there were passed to g_application_command_line().
        /// </summary>
        /// <remarks>
        /// If you did not override local_command_line() then these are the same
        /// options that were parsed according to the #GOptionEntrys added to the
        /// application with g_application_add_main_option_entries() and possibly
        /// modified from your GApplication::handle-local-options handler.
        /// 
        /// If no options were sent then an empty dictionary is returned so that
        /// you don't need to check for <c>null</c>.
        /// </remarks>
        /// <returns>
        /// a #GVariantDict with the options
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.40")]
        private unsafe GISharp.Lib.GLib.VariantDict GetOptions()
        {
            var cmdline_ = Handle;
            var ret_ = g_application_command_line_get_options_dict(cmdline_);
            var ret = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.VariantDict>(ret_, GISharp.Runtime.Transfer.None);
            return ret;
        }

        /// <summary>
        /// Gets the platform data associated with the invocation of @cmdline.
        /// </summary>
        /// <remarks>
        /// This is a #GVariant dictionary containing information about the
        /// context in which the invocation occurred.  It typically contains
        /// information like the current working directory and the startup
        /// notification ID.
        /// 
        /// For local invocation, it will be %NULL.
        /// </remarks>
        /// <param name="cmdline">
        /// #GApplicationCommandLine
        /// </param>
        /// <returns>
        /// the platform data, or %NULL
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.28")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="GLib.Variant" type="GVariant*" managed-name="GISharp.Lib.GLib.Variant" is-pointer="1" /> */
        /* transfer-ownership:full nullable:1 direction:out */
        static extern unsafe System.IntPtr g_application_command_line_get_platform_data(
        /* <type name="ApplicationCommandLine" type="GApplicationCommandLine*" managed-name="ApplicationCommandLine" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr cmdline);

        /// <summary>
        /// Gets the platform data associated with the invocation of <paramref name="cmdline"/>.
        /// </summary>
        /// <remarks>
        /// This is a #GVariant dictionary containing information about the
        /// context in which the invocation occurred.  It typically contains
        /// information like the current working directory and the startup
        /// notification ID.
        /// 
        /// For local invocation, it will be <c>null</c>.
        /// </remarks>
        /// <returns>
        /// the platform data, or <c>null</c>
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.28")]
        private unsafe GISharp.Lib.GLib.Variant GetPlatformData()
        {
            var cmdline_ = Handle;
            var ret_ = g_application_command_line_get_platform_data(cmdline_);
            var ret = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Variant>(ret_, GISharp.Runtime.Transfer.Full);
            return ret;
        }

        /// <summary>
        /// Gets the stdin of the invoking process.
        /// </summary>
        /// <remarks>
        /// The #GInputStream can be used to read data passed to the standard
        /// input of the invoking process.
        /// This doesn't work on all platforms.  Presently, it is only available
        /// on UNIX when using a DBus daemon capable of passing file descriptors.
        /// If stdin is not available then %NULL will be returned.  In the
        /// future, support may be expanded to other platforms.
        /// 
        /// You must only call this function once per commandline invocation.
        /// </remarks>
        /// <param name="cmdline">
        /// a #GApplicationCommandLine
        /// </param>
        /// <returns>
        /// a #GInputStream for stdin
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.34")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="InputStream" type="GInputStream*" managed-name="InputStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        static extern unsafe System.IntPtr g_application_command_line_get_stdin(
        /* <type name="ApplicationCommandLine" type="GApplicationCommandLine*" managed-name="ApplicationCommandLine" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr cmdline);

        /// <summary>
        /// Gets the stdin of the invoking process.
        /// </summary>
        /// <remarks>
        /// The <see cref="InputStream"/> can be used to read data passed to the standard
        /// input of the invoking process.
        /// This doesn't work on all platforms.  Presently, it is only available
        /// on UNIX when using a DBus daemon capable of passing file descriptors.
        /// If stdin is not available then <c>null</c> will be returned.  In the
        /// future, support may be expanded to other platforms.
        /// 
        /// You must only call this function once per commandline invocation.
        /// </remarks>
        /// <returns>
        /// a <see cref="InputStream"/> for stdin
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.34")]
        private unsafe GISharp.Lib.Gio.InputStream GetStdin()
        {
            var cmdline_ = Handle;
            var ret_ = g_application_command_line_get_stdin(cmdline_);
            var ret = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.InputStream>(ret_, GISharp.Runtime.Transfer.Full);
            return ret;
        }

        /// <summary>
        /// Gets the value of a particular environment variable of the command
        /// line invocation, as would be returned by g_getenv().  The strings may
        /// contain non-utf8 data.
        /// </summary>
        /// <remarks>
        /// The remote application usually does not send an environment.  Use
        /// %G_APPLICATION_SEND_ENVIRONMENT to affect that.  Even with this flag
        /// set it is possible that the environment is still not available (due
        /// to invocation messages from other applications).
        /// 
        /// The return value should not be modified or freed and is valid for as
        /// long as @cmdline exists.
        /// </remarks>
        /// <param name="cmdline">
        /// a #GApplicationCommandLine
        /// </param>
        /// <param name="name">
        /// the environment variable to get
        /// </param>
        /// <returns>
        /// the value of the variable, or %NULL if unset or unsent
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.28")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="const gchar*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe System.IntPtr g_application_command_line_getenv(
        /* <type name="ApplicationCommandLine" type="GApplicationCommandLine*" managed-name="ApplicationCommandLine" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr cmdline,
        /* <type name="filename" type="const gchar*" managed-name="GISharp.Lib.GLib.Filename" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr name);

        /// <summary>
        /// Gets the value of a particular environment variable of the command
        /// line invocation, as would be returned by g_getenv().  The strings may
        /// contain non-utf8 data.
        /// </summary>
        /// <remarks>
        /// The remote application usually does not send an environment.  Use
        /// <see cref="ApplicationFlags.SendEnvironment"/> to affect that.  Even with this flag
        /// set it is possible that the environment is still not available (due
        /// to invocation messages from other applications).
        /// 
        /// The return value should not be modified or freed and is valid for as
        /// long as <paramref name="cmdline"/> exists.
        /// </remarks>
        /// <param name="name">
        /// the environment variable to get
        /// </param>
        /// <returns>
        /// the value of the variable, or <c>null</c> if unset or unsent
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.28")]
        public unsafe GISharp.Lib.GLib.Utf8 GetEnvironmentVariable(GISharp.Lib.GLib.Filename name)
        {
            var cmdline_ = Handle;
            var name_ = name?.Handle ?? throw new System.ArgumentNullException(nameof(name));
            var ret_ = g_application_command_line_getenv(cmdline_,name_);
            var ret = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Utf8>(ret_, GISharp.Runtime.Transfer.None);
            return ret;
        }

        /// <summary>
        /// Sets the exit status that will be used when the invoking process
        /// exits.
        /// </summary>
        /// <remarks>
        /// The return value of the #GApplication::command-line signal is
        /// passed to this function when the handler returns.  This is the usual
        /// way of setting the exit status.
        /// 
        /// In the event that you want the remote invocation to continue running
        /// and want to decide on the exit status in the future, you can use this
        /// call.  For the case of a remote invocation, the remote process will
        /// typically exit when the last reference is dropped on @cmdline.  The
        /// exit status of the remote process will be equal to the last value
        /// that was set with this function.
        /// 
        /// In the case that the commandline invocation is local, the situation
        /// is slightly more complicated.  If the commandline invocation results
        /// in the mainloop running (ie: because the use-count of the application
        /// increased to a non-zero value) then the application is considered to
        /// have been 'successful' in a certain sense, and the exit status is
        /// always zero.  If the application use count is zero, though, the exit
        /// status of the local #GApplicationCommandLine is used.
        /// </remarks>
        /// <param name="cmdline">
        /// a #GApplicationCommandLine
        /// </param>
        /// <param name="exitStatus">
        /// the exit status
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.28")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe void g_application_command_line_set_exit_status(
        /* <type name="ApplicationCommandLine" type="GApplicationCommandLine*" managed-name="ApplicationCommandLine" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr cmdline,
        /* <type name="gint" type="int" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        System.Int32 exitStatus);

        /// <summary>
        /// Sets the exit status that will be used when the invoking process
        /// exits.
        /// </summary>
        /// <remarks>
        /// The return value of the #GApplication::command-line signal is
        /// passed to this function when the handler returns.  This is the usual
        /// way of setting the exit status.
        /// 
        /// In the event that you want the remote invocation to continue running
        /// and want to decide on the exit status in the future, you can use this
        /// call.  For the case of a remote invocation, the remote process will
        /// typically exit when the last reference is dropped on <paramref name="cmdline"/>.  The
        /// exit status of the remote process will be equal to the last value
        /// that was set with this function.
        /// 
        /// In the case that the commandline invocation is local, the situation
        /// is slightly more complicated.  If the commandline invocation results
        /// in the mainloop running (ie: because the use-count of the application
        /// increased to a non-zero value) then the application is considered to
        /// have been 'successful' in a certain sense, and the exit status is
        /// always zero.  If the application use count is zero, though, the exit
        /// status of the local <see cref="ApplicationCommandLine"/> is used.
        /// </remarks>
        /// <param name="exitStatus">
        /// the exit status
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.28")]
        private unsafe void SetExitStatus(System.Int32 exitStatus)
        {
            var cmdline_ = Handle;
            var exitStatus_ = (System.Int32)exitStatus;
            g_application_command_line_set_exit_status(cmdline_, exitStatus_);
        }

        /// <summary>
        /// Gets the stdin of the invoking process.
        /// </summary>
        /// <remarks>
        /// The <see cref="InputStream"/> can be used to read data passed to the standard
        /// input of the invoking process.
        /// This doesn't work on all platforms.  Presently, it is only available
        /// on UNIX when using a DBus daemon capable of passing file descriptors.
        /// If stdin is not available then <c>null</c> will be returned.  In the
        /// future, support may be expanded to other platforms.
        /// 
        /// You must only call this function once per commandline invocation.
        /// </remarks>
        /// <returns>
        /// a <see cref="InputStream"/> for stdin
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.34")]
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(ApplicationCommandLineClass.UnmanagedGetStdin))]
        protected virtual unsafe GISharp.Lib.Gio.InputStream DoGetStdin()
        {
            var cmdline_ = Handle;
            var ret_ = GISharp.Lib.GObject.TypeClass.GetUnmanagedVirtualMethod<ApplicationCommandLineClass.UnmanagedGetStdin>(_GType)(cmdline_);
            var ret = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.InputStream>(ret_, GISharp.Runtime.Transfer.Full);
            return ret;
        }

        [GISharp.Runtime.GVirtualMethodAttribute(typeof(ApplicationCommandLineClass.UnmanagedPrintLiteral))]
        protected virtual unsafe void DoPrintLiteral(GISharp.Lib.GLib.Utf8 message)
        {
            var cmdline_ = Handle;
            var message_ = message?.Handle ?? throw new System.ArgumentNullException(nameof(message));
            GISharp.Lib.GObject.TypeClass.GetUnmanagedVirtualMethod<ApplicationCommandLineClass.UnmanagedPrintLiteral>(_GType)(cmdline_, message_);
        }

        [GISharp.Runtime.GVirtualMethodAttribute(typeof(ApplicationCommandLineClass.UnmanagedPrinterrLiteral))]
        protected virtual unsafe void DoPrinterrLiteral(GISharp.Lib.GLib.Utf8 message)
        {
            var cmdline_ = Handle;
            var message_ = message?.Handle ?? throw new System.ArgumentNullException(nameof(message));
            GISharp.Lib.GObject.TypeClass.GetUnmanagedVirtualMethod<ApplicationCommandLineClass.UnmanagedPrinterrLiteral>(_GType)(cmdline_, message_);
        }
    }
}