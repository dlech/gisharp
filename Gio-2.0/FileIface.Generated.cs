// ATTENTION: This file is automatically generated. Do not edit by manually.
namespace GISharp.Lib.Gio
{
    /// <summary>
    /// An interface for writing VFS file handles.
    /// </summary>
    public sealed class FileIface : GISharp.Lib.GObject.TypeInterface
    {
        unsafe new struct Struct
        {
#pragma warning disable CS0649
            /// <summary>
            /// The parent interface.
            /// </summary>
            public GISharp.Lib.GObject.TypeInterface.Struct GIface;
            public System.IntPtr Dup;
            public System.IntPtr Hash;
            public System.IntPtr Equal;
            public System.IntPtr IsNative;
            public System.IntPtr HasUriScheme;
            public System.IntPtr GetUriScheme;
            public System.IntPtr GetBasename;
            public System.IntPtr GetPath;
            public System.IntPtr GetUri;
            public System.IntPtr GetParseName;
            public System.IntPtr GetParent;
            public System.IntPtr PrefixMatches;
            public System.IntPtr GetRelativePath;
            public System.IntPtr ResolveRelativePath;
            public System.IntPtr GetChildForDisplayName;
            public System.IntPtr EnumerateChildren;
            public System.IntPtr EnumerateChildrenAsync;
            public System.IntPtr EnumerateChildrenFinish;
            public System.IntPtr QueryInfo;
            public System.IntPtr QueryInfoAsync;
            public System.IntPtr QueryInfoFinish;
            public System.IntPtr QueryFilesystemInfo;
            public System.IntPtr QueryFilesystemInfoAsync;
            public System.IntPtr QueryFilesystemInfoFinish;
            public System.IntPtr FindEnclosingMount;
            public System.IntPtr FindEnclosingMountAsync;
            public System.IntPtr FindEnclosingMountFinish;
            public System.IntPtr SetDisplayName;
            public System.IntPtr SetDisplayNameAsync;
            public System.IntPtr SetDisplayNameFinish;
            public System.IntPtr QuerySettableAttributes;
            public System.IntPtr QuerySettableAttributesAsync;
            public System.IntPtr QuerySettableAttributesFinish;
            public System.IntPtr QueryWritableNamespaces;
            public System.IntPtr QueryWritableNamespacesAsync;
            public System.IntPtr QueryWritableNamespacesFinish;
            public System.IntPtr SetAttribute;
            public System.IntPtr SetAttributesFromInfo;
            public System.IntPtr SetAttributesAsync;
            public System.IntPtr SetAttributesFinish;
            public System.IntPtr ReadFn;
            public System.IntPtr ReadAsync;
            public System.IntPtr ReadFinish;
            public System.IntPtr AppendTo;
            public System.IntPtr AppendToAsync;
            public System.IntPtr AppendToFinish;
            public System.IntPtr Create;
            public System.IntPtr CreateAsync;
            public System.IntPtr CreateFinish;
            public System.IntPtr Replace;
            public System.IntPtr ReplaceAsync;
            public System.IntPtr ReplaceFinish;
            public System.IntPtr DeleteFile;
            public System.IntPtr DeleteFileAsync;
            public System.IntPtr DeleteFileFinish;
            public System.IntPtr Trash;
            public System.IntPtr TrashAsync;
            public System.IntPtr TrashFinish;
            public System.IntPtr MakeDirectory;
            public System.IntPtr MakeDirectoryAsync;
            public System.IntPtr MakeDirectoryFinish;
            public System.IntPtr MakeSymbolicLink;
            public System.IntPtr MakeSymbolicLinkAsync;
            public System.IntPtr MakeSymbolicLinkFinish;
            public System.IntPtr Copy;
            public System.IntPtr CopyAsync;
            public System.IntPtr CopyFinish;
            public System.IntPtr Move;
            public System.IntPtr MoveAsync;
            public System.IntPtr MoveFinish;
            public System.IntPtr MountMountable;
            public System.IntPtr MountMountableFinish;
            public System.IntPtr UnmountMountable;
            public System.IntPtr UnmountMountableFinish;
            public System.IntPtr EjectMountable;
            public System.IntPtr EjectMountableFinish;
            public System.IntPtr MountEnclosingVolume;
            public System.IntPtr MountEnclosingVolumeFinish;
            public System.IntPtr MonitorDir;
            public System.IntPtr MonitorFile;
            public System.IntPtr OpenReadwrite;
            public System.IntPtr OpenReadwriteAsync;
            public System.IntPtr OpenReadwriteFinish;
            public System.IntPtr CreateReadwrite;
            public System.IntPtr CreateReadwriteAsync;
            public System.IntPtr CreateReadwriteFinish;
            public System.IntPtr ReplaceReadwrite;
            public System.IntPtr ReplaceReadwriteAsync;
            public System.IntPtr ReplaceReadwriteFinish;
            public System.IntPtr StartMountable;
            public System.IntPtr StartMountableFinish;
            public System.IntPtr StopMountable;
            public System.IntPtr StopMountableFinish;

            /// <summary>
            /// a boolean that indicates whether the <see cref="IFile"/> implementation supports thread-default contexts. Since 2.22.
            /// </summary>
            public System.Boolean SupportsThreadContexts;
            public System.IntPtr UnmountMountableWithOperation;
            public System.IntPtr UnmountMountableWithOperationFinish;
            public System.IntPtr EjectMountableWithOperation;
            public System.IntPtr EjectMountableWithOperationFinish;
            public System.IntPtr PollMountable;
            public System.IntPtr PollMountableFinish;
            public System.IntPtr MeasureDiskUsage;
            public System.IntPtr MeasureDiskUsageAsync;
            public System.IntPtr MeasureDiskUsageFinish;
#pragma warning restore CS0649
        }

        static FileIface()
        {
            System.Int32 dupOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.Dup));
            RegisterVirtualMethod(dupOffset, DupFactory.Create);
            System.Int32 hashOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.Hash));
            RegisterVirtualMethod(hashOffset, HashFactory.Create);
            System.Int32 equalOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.Equal));
            RegisterVirtualMethod(equalOffset, EqualFactory.Create);
            System.Int32 isNativeOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.IsNative));
            RegisterVirtualMethod(isNativeOffset, IsNativeFactory.Create);
            System.Int32 hasUriSchemeOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.HasUriScheme));
            RegisterVirtualMethod(hasUriSchemeOffset, HasUriSchemeFactory.Create);
            System.Int32 getUriSchemeOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.GetUriScheme));
            RegisterVirtualMethod(getUriSchemeOffset, GetUriSchemeFactory.Create);
            System.Int32 getBasenameOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.GetBasename));
            RegisterVirtualMethod(getBasenameOffset, GetBasenameFactory.Create);
            System.Int32 getPathOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.GetPath));
            RegisterVirtualMethod(getPathOffset, GetPathFactory.Create);
            System.Int32 getUriOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.GetUri));
            RegisterVirtualMethod(getUriOffset, GetUriFactory.Create);
            System.Int32 getParseNameOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.GetParseName));
            RegisterVirtualMethod(getParseNameOffset, GetParseNameFactory.Create);
            System.Int32 getParentOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.GetParent));
            RegisterVirtualMethod(getParentOffset, GetParentFactory.Create);
            System.Int32 prefixMatchesOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.PrefixMatches));
            RegisterVirtualMethod(prefixMatchesOffset, PrefixMatchesFactory.Create);
            System.Int32 getRelativePathOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.GetRelativePath));
            RegisterVirtualMethod(getRelativePathOffset, GetRelativePathFactory.Create);
            System.Int32 resolveRelativePathOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.ResolveRelativePath));
            RegisterVirtualMethod(resolveRelativePathOffset, ResolveRelativePathFactory.Create);
            System.Int32 getChildForDisplayNameOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.GetChildForDisplayName));
            RegisterVirtualMethod(getChildForDisplayNameOffset, GetChildForDisplayNameFactory.Create);
            System.Int32 enumerateChildrenAsyncOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.EnumerateChildrenAsync));
            RegisterVirtualMethod(enumerateChildrenAsyncOffset, EnumerateChildrenAsyncFactory.Create);
            System.Int32 queryInfoOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.QueryInfo));
            RegisterVirtualMethod(queryInfoOffset, QueryInfoFactory.Create);
            System.Int32 queryInfoAsyncOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.QueryInfoAsync));
            RegisterVirtualMethod(queryInfoAsyncOffset, QueryInfoAsyncFactory.Create);
            System.Int32 queryInfoFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.QueryInfoFinish));
            RegisterVirtualMethod(queryInfoFinishOffset, QueryInfoFinishFactory.Create);
            System.Int32 queryFilesystemInfoOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.QueryFilesystemInfo));
            RegisterVirtualMethod(queryFilesystemInfoOffset, QueryFilesystemInfoFactory.Create);
            System.Int32 queryFilesystemInfoAsyncOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.QueryFilesystemInfoAsync));
            RegisterVirtualMethod(queryFilesystemInfoAsyncOffset, QueryFilesystemInfoAsyncFactory.Create);
            System.Int32 queryFilesystemInfoFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.QueryFilesystemInfoFinish));
            RegisterVirtualMethod(queryFilesystemInfoFinishOffset, QueryFilesystemInfoFinishFactory.Create);
            System.Int32 findEnclosingMountAsyncOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.FindEnclosingMountAsync));
            RegisterVirtualMethod(findEnclosingMountAsyncOffset, FindEnclosingMountAsyncFactory.Create);
            System.Int32 setDisplayNameOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.SetDisplayName));
            RegisterVirtualMethod(setDisplayNameOffset, SetDisplayNameFactory.Create);
            System.Int32 setDisplayNameAsyncOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.SetDisplayNameAsync));
            RegisterVirtualMethod(setDisplayNameAsyncOffset, SetDisplayNameAsyncFactory.Create);
            System.Int32 setDisplayNameFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.SetDisplayNameFinish));
            RegisterVirtualMethod(setDisplayNameFinishOffset, SetDisplayNameFinishFactory.Create);
            System.Int32 querySettableAttributesOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.QuerySettableAttributes));
            RegisterVirtualMethod(querySettableAttributesOffset, QuerySettableAttributesFactory.Create);
            System.Int32 queryWritableNamespacesOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.QueryWritableNamespaces));
            RegisterVirtualMethod(queryWritableNamespacesOffset, QueryWritableNamespacesFactory.Create);
            System.Int32 setAttributeOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.SetAttribute));
            RegisterVirtualMethod(setAttributeOffset, SetAttributeFactory.Create);
            System.Int32 setAttributesFromInfoOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.SetAttributesFromInfo));
            RegisterVirtualMethod(setAttributesFromInfoOffset, SetAttributesFromInfoFactory.Create);
            System.Int32 setAttributesAsyncOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.SetAttributesAsync));
            RegisterVirtualMethod(setAttributesAsyncOffset, SetAttributesAsyncFactory.Create);
            System.Int32 setAttributesFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.SetAttributesFinish));
            RegisterVirtualMethod(setAttributesFinishOffset, SetAttributesFinishFactory.Create);
            System.Int32 readFnOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.ReadFn));
            RegisterVirtualMethod(readFnOffset, ReadFnFactory.Create);
            System.Int32 readAsyncOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.ReadAsync));
            RegisterVirtualMethod(readAsyncOffset, ReadAsyncFactory.Create);
            System.Int32 readFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.ReadFinish));
            RegisterVirtualMethod(readFinishOffset, ReadFinishFactory.Create);
            System.Int32 appendToOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.AppendTo));
            RegisterVirtualMethod(appendToOffset, AppendToFactory.Create);
            System.Int32 appendToAsyncOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.AppendToAsync));
            RegisterVirtualMethod(appendToAsyncOffset, AppendToAsyncFactory.Create);
            System.Int32 appendToFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.AppendToFinish));
            RegisterVirtualMethod(appendToFinishOffset, AppendToFinishFactory.Create);
            System.Int32 createOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.Create));
            RegisterVirtualMethod(createOffset, CreateFactory.Create);
            System.Int32 createAsyncOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.CreateAsync));
            RegisterVirtualMethod(createAsyncOffset, CreateAsyncFactory.Create);
            System.Int32 createFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.CreateFinish));
            RegisterVirtualMethod(createFinishOffset, CreateFinishFactory.Create);
            System.Int32 replaceOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.Replace));
            RegisterVirtualMethod(replaceOffset, ReplaceFactory.Create);
            System.Int32 replaceAsyncOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.ReplaceAsync));
            RegisterVirtualMethod(replaceAsyncOffset, ReplaceAsyncFactory.Create);
            System.Int32 replaceFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.ReplaceFinish));
            RegisterVirtualMethod(replaceFinishOffset, ReplaceFinishFactory.Create);
            System.Int32 deleteFileOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.DeleteFile));
            RegisterVirtualMethod(deleteFileOffset, DeleteFileFactory.Create);
            System.Int32 deleteFileAsyncOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.DeleteFileAsync));
            RegisterVirtualMethod(deleteFileAsyncOffset, DeleteFileAsyncFactory.Create);
            System.Int32 deleteFileFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.DeleteFileFinish));
            RegisterVirtualMethod(deleteFileFinishOffset, DeleteFileFinishFactory.Create);
            System.Int32 trashOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.Trash));
            RegisterVirtualMethod(trashOffset, TrashFactory.Create);
            System.Int32 trashAsyncOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.TrashAsync));
            RegisterVirtualMethod(trashAsyncOffset, TrashAsyncFactory.Create);
            System.Int32 trashFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.TrashFinish));
            RegisterVirtualMethod(trashFinishOffset, TrashFinishFactory.Create);
            System.Int32 makeDirectoryOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.MakeDirectory));
            RegisterVirtualMethod(makeDirectoryOffset, MakeDirectoryFactory.Create);
            System.Int32 makeDirectoryAsyncOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.MakeDirectoryAsync));
            RegisterVirtualMethod(makeDirectoryAsyncOffset, MakeDirectoryAsyncFactory.Create);
            System.Int32 makeDirectoryFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.MakeDirectoryFinish));
            RegisterVirtualMethod(makeDirectoryFinishOffset, MakeDirectoryFinishFactory.Create);
            System.Int32 makeSymbolicLinkOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.MakeSymbolicLink));
            RegisterVirtualMethod(makeSymbolicLinkOffset, MakeSymbolicLinkFactory.Create);
            System.Int32 copyOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.Copy));
            RegisterVirtualMethod(copyOffset, CopyFactory.Create);
            System.Int32 copyAsyncOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.CopyAsync));
            RegisterVirtualMethod(copyAsyncOffset, CopyAsyncFactory.Create);
            System.Int32 copyFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.CopyFinish));
            RegisterVirtualMethod(copyFinishOffset, CopyFinishFactory.Create);
            System.Int32 moveOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.Move));
            RegisterVirtualMethod(moveOffset, MoveFactory.Create);
            System.Int32 mountMountableFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.MountMountableFinish));
            RegisterVirtualMethod(mountMountableFinishOffset, MountMountableFinishFactory.Create);
            System.Int32 unmountMountableFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.UnmountMountableFinish));
            RegisterVirtualMethod(unmountMountableFinishOffset, UnmountMountableFinishFactory.Create);
            System.Int32 ejectMountableFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.EjectMountableFinish));
            RegisterVirtualMethod(ejectMountableFinishOffset, EjectMountableFinishFactory.Create);
            System.Int32 mountEnclosingVolumeFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.MountEnclosingVolumeFinish));
            RegisterVirtualMethod(mountEnclosingVolumeFinishOffset, MountEnclosingVolumeFinishFactory.Create);
            System.Int32 openReadwriteOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.OpenReadwrite));
            RegisterVirtualMethod(openReadwriteOffset, OpenReadwriteFactory.Create);
            System.Int32 openReadwriteAsyncOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.OpenReadwriteAsync));
            RegisterVirtualMethod(openReadwriteAsyncOffset, OpenReadwriteAsyncFactory.Create);
            System.Int32 openReadwriteFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.OpenReadwriteFinish));
            RegisterVirtualMethod(openReadwriteFinishOffset, OpenReadwriteFinishFactory.Create);
            System.Int32 createReadwriteOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.CreateReadwrite));
            RegisterVirtualMethod(createReadwriteOffset, CreateReadwriteFactory.Create);
            System.Int32 createReadwriteAsyncOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.CreateReadwriteAsync));
            RegisterVirtualMethod(createReadwriteAsyncOffset, CreateReadwriteAsyncFactory.Create);
            System.Int32 createReadwriteFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.CreateReadwriteFinish));
            RegisterVirtualMethod(createReadwriteFinishOffset, CreateReadwriteFinishFactory.Create);
            System.Int32 replaceReadwriteOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.ReplaceReadwrite));
            RegisterVirtualMethod(replaceReadwriteOffset, ReplaceReadwriteFactory.Create);
            System.Int32 replaceReadwriteAsyncOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.ReplaceReadwriteAsync));
            RegisterVirtualMethod(replaceReadwriteAsyncOffset, ReplaceReadwriteAsyncFactory.Create);
            System.Int32 replaceReadwriteFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.ReplaceReadwriteFinish));
            RegisterVirtualMethod(replaceReadwriteFinishOffset, ReplaceReadwriteFinishFactory.Create);
            System.Int32 startMountableFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.StartMountableFinish));
            RegisterVirtualMethod(startMountableFinishOffset, StartMountableFinishFactory.Create);
            System.Int32 stopMountableFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.StopMountableFinish));
            RegisterVirtualMethod(stopMountableFinishOffset, StopMountableFinishFactory.Create);
            System.Int32 unmountMountableWithOperationFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.UnmountMountableWithOperationFinish));
            RegisterVirtualMethod(unmountMountableWithOperationFinishOffset, UnmountMountableWithOperationFinishFactory.Create);
            System.Int32 ejectMountableWithOperationFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.EjectMountableWithOperationFinish));
            RegisterVirtualMethod(ejectMountableWithOperationFinishOffset, EjectMountableWithOperationFinishFactory.Create);
            System.Int32 pollMountableOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.PollMountable));
            RegisterVirtualMethod(pollMountableOffset, PollMountableFactory.Create);
            System.Int32 pollMountableFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.PollMountableFinish));
            RegisterVirtualMethod(pollMountableFinishOffset, PollMountableFinishFactory.Create);
            System.Int32 measureDiskUsageFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.MeasureDiskUsageFinish));
            RegisterVirtualMethod(measureDiskUsageFinishOffset, MeasureDiskUsageFinishFactory.Create);
        }

        public delegate GISharp.Lib.Gio.IFile Dup();

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedDup(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file);

        /// <summary>
        /// Factory for creating <see cref="Dup"/> methods.
        /// </summary>
        public static class DupFactory
        {
            public static unsafe UnmanagedDup Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedDup(System.IntPtr file_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var doDup = (Dup)methodInfo.CreateDelegate(typeof(Dup), file);
                        var ret = doDup();
                        var ret_ = ret?.Take() ?? throw new System.ArgumentNullException(nameof(ret));
                        return ret_;
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedDup;
            }
        }

        public delegate System.UInt32 Hash();

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:out */
        public unsafe delegate System.UInt32 UnmanagedHash(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file);

        /// <summary>
        /// Factory for creating <see cref="Hash"/> methods.
        /// </summary>
        public static class HashFactory
        {
            public static unsafe UnmanagedHash Create(System.Reflection.MethodInfo methodInfo)
            {
                System.UInt32 unmanagedHash(System.IntPtr file_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var doHash = (Hash)methodInfo.CreateDelegate(typeof(Hash), file);
                        var ret = doHash();
                        var ret_ = (System.UInt32)ret;
                        return ret_;
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.UInt32);
                }

                return unmanagedHash;
            }
        }

        public delegate System.Boolean Equal(GISharp.Lib.Gio.IFile file2);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:out */
        public unsafe delegate System.Boolean UnmanagedEqual(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file1,
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file2);

        /// <summary>
        /// Factory for creating <see cref="Equal"/> methods.
        /// </summary>
        public static class EqualFactory
        {
            public static unsafe UnmanagedEqual Create(System.Reflection.MethodInfo methodInfo)
            {
                System.Boolean unmanagedEqual(System.IntPtr file1_, System.IntPtr file2_)
                {
                    try
                    {
                        var file1 = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file1_, GISharp.Runtime.Transfer.None);
                        var file2 = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file2_, GISharp.Runtime.Transfer.None);
                        var doEqual = (Equal)methodInfo.CreateDelegate(typeof(Equal), file1);
                        var ret = doEqual(file2);
                        var ret_ = (System.Boolean)ret;
                        return ret_;
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.Boolean);
                }

                return unmanagedEqual;
            }
        }

        public delegate System.Boolean IsNative();

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:out */
        public unsafe delegate System.Boolean UnmanagedIsNative(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file);

        /// <summary>
        /// Factory for creating <see cref="IsNative"/> methods.
        /// </summary>
        public static class IsNativeFactory
        {
            public static unsafe UnmanagedIsNative Create(System.Reflection.MethodInfo methodInfo)
            {
                System.Boolean unmanagedIsNative(System.IntPtr file_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var doIsNative = (IsNative)methodInfo.CreateDelegate(typeof(IsNative), file);
                        var ret = doIsNative();
                        var ret_ = (System.Boolean)ret;
                        return ret_;
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.Boolean);
                }

                return unmanagedIsNative;
            }
        }

        public delegate System.Boolean HasUriScheme(GISharp.Lib.GLib.UnownedUtf8 uriScheme);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:out */
        public unsafe delegate System.Boolean UnmanagedHasUriScheme(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr uriScheme);

        /// <summary>
        /// Factory for creating <see cref="HasUriScheme"/> methods.
        /// </summary>
        public static class HasUriSchemeFactory
        {
            public static unsafe UnmanagedHasUriScheme Create(System.Reflection.MethodInfo methodInfo)
            {
                System.Boolean unmanagedHasUriScheme(System.IntPtr file_, System.IntPtr uriScheme_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var uriScheme = new GISharp.Lib.GLib.UnownedUtf8(uriScheme_, -1);
                        var doHasUriScheme = (HasUriScheme)methodInfo.CreateDelegate(typeof(HasUriScheme), file);
                        var ret = doHasUriScheme(uriScheme);
                        var ret_ = (System.Boolean)ret;
                        return ret_;
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.Boolean);
                }

                return unmanagedHasUriScheme;
            }
        }

        public delegate GISharp.Lib.GLib.Utf8 GetUriScheme();

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedGetUriScheme(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file);

        /// <summary>
        /// Factory for creating <see cref="GetUriScheme"/> methods.
        /// </summary>
        public static class GetUriSchemeFactory
        {
            public static unsafe UnmanagedGetUriScheme Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedGetUriScheme(System.IntPtr file_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var doGetUriScheme = (GetUriScheme)methodInfo.CreateDelegate(typeof(GetUriScheme), file);
                        var ret = doGetUriScheme();
                        var ret_ = ret?.Take() ?? throw new System.ArgumentNullException(nameof(ret));
                        return ret_;
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedGetUriScheme;
            }
        }

        public delegate GISharp.Lib.GLib.Utf8 GetBasename();

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedGetBasename(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file);

        /// <summary>
        /// Factory for creating <see cref="GetBasename"/> methods.
        /// </summary>
        public static class GetBasenameFactory
        {
            public static unsafe UnmanagedGetBasename Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedGetBasename(System.IntPtr file_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var doGetBasename = (GetBasename)methodInfo.CreateDelegate(typeof(GetBasename), file);
                        var ret = doGetBasename();
                        var ret_ = ret?.Take() ?? throw new System.ArgumentNullException(nameof(ret));
                        return ret_;
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedGetBasename;
            }
        }

        public delegate GISharp.Lib.GLib.Utf8 GetPath();

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedGetPath(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file);

        /// <summary>
        /// Factory for creating <see cref="GetPath"/> methods.
        /// </summary>
        public static class GetPathFactory
        {
            public static unsafe UnmanagedGetPath Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedGetPath(System.IntPtr file_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var doGetPath = (GetPath)methodInfo.CreateDelegate(typeof(GetPath), file);
                        var ret = doGetPath();
                        var ret_ = ret?.Take() ?? throw new System.ArgumentNullException(nameof(ret));
                        return ret_;
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedGetPath;
            }
        }

        public delegate GISharp.Lib.GLib.Utf8 GetUri();

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedGetUri(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file);

        /// <summary>
        /// Factory for creating <see cref="GetUri"/> methods.
        /// </summary>
        public static class GetUriFactory
        {
            public static unsafe UnmanagedGetUri Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedGetUri(System.IntPtr file_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var doGetUri = (GetUri)methodInfo.CreateDelegate(typeof(GetUri), file);
                        var ret = doGetUri();
                        var ret_ = ret?.Take() ?? throw new System.ArgumentNullException(nameof(ret));
                        return ret_;
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedGetUri;
            }
        }

        public delegate GISharp.Lib.GLib.Utf8 GetParseName();

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedGetParseName(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file);

        /// <summary>
        /// Factory for creating <see cref="GetParseName"/> methods.
        /// </summary>
        public static class GetParseNameFactory
        {
            public static unsafe UnmanagedGetParseName Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedGetParseName(System.IntPtr file_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var doGetParseName = (GetParseName)methodInfo.CreateDelegate(typeof(GetParseName), file);
                        var ret = doGetParseName();
                        var ret_ = ret?.Take() ?? throw new System.ArgumentNullException(nameof(ret));
                        return ret_;
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedGetParseName;
            }
        }

        public delegate GISharp.Lib.Gio.IFile GetParent();

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
        /* transfer-ownership:full nullable:1 direction:out */
        public unsafe delegate System.IntPtr UnmanagedGetParent(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file);

        /// <summary>
        /// Factory for creating <see cref="GetParent"/> methods.
        /// </summary>
        public static class GetParentFactory
        {
            public static unsafe UnmanagedGetParent Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedGetParent(System.IntPtr file_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var doGetParent = (GetParent)methodInfo.CreateDelegate(typeof(GetParent), file);
                        var ret = doGetParent();
                        var ret_ = ret?.Take() ?? System.IntPtr.Zero;
                        return ret_;
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedGetParent;
            }
        }

        public delegate System.Boolean PrefixMatches(GISharp.Lib.Gio.IFile file);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:out */
        public unsafe delegate System.Boolean UnmanagedPrefixMatches(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr prefix,
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file);

        /// <summary>
        /// Factory for creating <see cref="PrefixMatches"/> methods.
        /// </summary>
        public static class PrefixMatchesFactory
        {
            public static unsafe UnmanagedPrefixMatches Create(System.Reflection.MethodInfo methodInfo)
            {
                System.Boolean unmanagedPrefixMatches(System.IntPtr prefix_, System.IntPtr file_)
                {
                    try
                    {
                        var prefix = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(prefix_, GISharp.Runtime.Transfer.None);
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var doPrefixMatches = (PrefixMatches)methodInfo.CreateDelegate(typeof(PrefixMatches), prefix);
                        var ret = doPrefixMatches(file);
                        var ret_ = (System.Boolean)ret;
                        return ret_;
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.Boolean);
                }

                return unmanagedPrefixMatches;
            }
        }

        public delegate GISharp.Lib.GLib.Utf8 GetRelativePath(GISharp.Lib.Gio.IFile descendant);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedGetRelativePath(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr parent,
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr descendant);

        /// <summary>
        /// Factory for creating <see cref="GetRelativePath"/> methods.
        /// </summary>
        public static class GetRelativePathFactory
        {
            public static unsafe UnmanagedGetRelativePath Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedGetRelativePath(System.IntPtr parent_, System.IntPtr descendant_)
                {
                    try
                    {
                        var parent = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(parent_, GISharp.Runtime.Transfer.None);
                        var descendant = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(descendant_, GISharp.Runtime.Transfer.None);
                        var doGetRelativePath = (GetRelativePath)methodInfo.CreateDelegate(typeof(GetRelativePath), parent);
                        var ret = doGetRelativePath(descendant);
                        var ret_ = ret?.Take() ?? throw new System.ArgumentNullException(nameof(ret));
                        return ret_;
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedGetRelativePath;
            }
        }

        public delegate GISharp.Lib.Gio.IFile ResolveRelativePath(GISharp.Lib.GLib.Filename relativePath);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedResolveRelativePath(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="filename" type="const char*" managed-name="GISharp.Lib.GLib.Filename" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr relativePath);

        /// <summary>
        /// Factory for creating <see cref="ResolveRelativePath"/> methods.
        /// </summary>
        public static class ResolveRelativePathFactory
        {
            public static unsafe UnmanagedResolveRelativePath Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedResolveRelativePath(System.IntPtr file_, System.IntPtr relativePath_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var relativePath = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Filename>(relativePath_, GISharp.Runtime.Transfer.None);
                        var doResolveRelativePath = (ResolveRelativePath)methodInfo.CreateDelegate(typeof(ResolveRelativePath), file);
                        var ret = doResolveRelativePath(relativePath);
                        var ret_ = ret?.Take() ?? throw new System.ArgumentNullException(nameof(ret));
                        return ret_;
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedResolveRelativePath;
            }
        }

        public delegate GISharp.Lib.Gio.IFile GetChildForDisplayName(GISharp.Lib.GLib.UnownedUtf8 displayName);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedGetChildForDisplayName(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr displayName,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
System.IntPtr* error);

        /// <summary>
        /// Factory for creating <see cref="GetChildForDisplayName"/> methods.
        /// </summary>
        public static class GetChildForDisplayNameFactory
        {
            public static unsafe UnmanagedGetChildForDisplayName Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedGetChildForDisplayName(System.IntPtr file_, System.IntPtr displayName_, System.IntPtr* error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var displayName = new GISharp.Lib.GLib.UnownedUtf8(displayName_, -1);
                        var doGetChildForDisplayName = (GetChildForDisplayName)methodInfo.CreateDelegate(typeof(GetChildForDisplayName), file);
                        var ret = doGetChildForDisplayName(displayName);
                        var ret_ = ret?.Take() ?? throw new System.ArgumentNullException(nameof(ret));
                        return ret_;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedGetChildForDisplayName;
            }
        }

        public delegate void EnumerateChildrenAsync(GISharp.Lib.GLib.UnownedUtf8 attributes, GISharp.Lib.Gio.FileQueryInfoFlags flags, System.Int32 ioPriority, GISharp.Lib.Gio.AsyncReadyCallback callback, GISharp.Lib.Gio.Cancellable cancellable = null);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        public unsafe delegate void UnmanagedEnumerateChildrenAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr attributes,
/* <type name="FileQueryInfoFlags" type="GFileQueryInfoFlags" managed-name="FileQueryInfoFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileQueryInfoFlags flags,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
System.Int32 ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="UnmanagedAsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:6 direction:in */
GISharp.Lib.Gio.UnmanagedAsyncReadyCallback callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:6 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Factory for creating <see cref="EnumerateChildrenAsync"/> methods.
        /// </summary>
        public static class EnumerateChildrenAsyncFactory
        {
            public static unsafe UnmanagedEnumerateChildrenAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedEnumerateChildrenAsync(System.IntPtr file_, System.IntPtr attributes_, GISharp.Lib.Gio.FileQueryInfoFlags flags_, System.Int32 ioPriority_, System.IntPtr cancellable_, GISharp.Lib.Gio.UnmanagedAsyncReadyCallback callback_, System.IntPtr userData_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var attributes = new GISharp.Lib.GLib.UnownedUtf8(attributes_, -1);
                        var flags = (GISharp.Lib.Gio.FileQueryInfoFlags)flags_;
                        var ioPriority = (System.Int32)ioPriority_;
                        var callback = GISharp.Lib.Gio.AsyncReadyCallbackFactory.Create(callback_, userData_);
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doEnumerateChildrenAsync = (EnumerateChildrenAsync)methodInfo.CreateDelegate(typeof(EnumerateChildrenAsync), file);
                        doEnumerateChildrenAsync(attributes, flags, ioPriority, callback, cancellable);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }
                }

                return unmanagedEnumerateChildrenAsync;
            }
        }

        public delegate GISharp.Lib.Gio.FileInfo QueryInfo(GISharp.Lib.GLib.UnownedUtf8 attributes, GISharp.Lib.Gio.FileQueryInfoFlags flags, GISharp.Lib.Gio.Cancellable cancellable = null);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileInfo" type="GFileInfo*" managed-name="FileInfo" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedQueryInfo(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr attributes,
/* <type name="FileQueryInfoFlags" type="GFileQueryInfoFlags" managed-name="FileQueryInfoFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileQueryInfoFlags flags,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
System.IntPtr* error);

        /// <summary>
        /// Factory for creating <see cref="QueryInfo"/> methods.
        /// </summary>
        public static class QueryInfoFactory
        {
            public static unsafe UnmanagedQueryInfo Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedQueryInfo(System.IntPtr file_, System.IntPtr attributes_, GISharp.Lib.Gio.FileQueryInfoFlags flags_, System.IntPtr cancellable_, System.IntPtr* error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var attributes = new GISharp.Lib.GLib.UnownedUtf8(attributes_, -1);
                        var flags = (GISharp.Lib.Gio.FileQueryInfoFlags)flags_;
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doQueryInfo = (QueryInfo)methodInfo.CreateDelegate(typeof(QueryInfo), file);
                        var ret = doQueryInfo(attributes, flags, cancellable);
                        var ret_ = ret?.Take() ?? throw new System.ArgumentNullException(nameof(ret));
                        return ret_;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedQueryInfo;
            }
        }

        public delegate void QueryInfoAsync(GISharp.Lib.GLib.UnownedUtf8 attributes, GISharp.Lib.Gio.FileQueryInfoFlags flags, System.Int32 ioPriority, GISharp.Lib.Gio.AsyncReadyCallback callback, GISharp.Lib.Gio.Cancellable cancellable = null);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        public unsafe delegate void UnmanagedQueryInfoAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr attributes,
/* <type name="FileQueryInfoFlags" type="GFileQueryInfoFlags" managed-name="FileQueryInfoFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileQueryInfoFlags flags,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
System.Int32 ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="UnmanagedAsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:6 direction:in */
GISharp.Lib.Gio.UnmanagedAsyncReadyCallback callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:6 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Factory for creating <see cref="QueryInfoAsync"/> methods.
        /// </summary>
        public static class QueryInfoAsyncFactory
        {
            public static unsafe UnmanagedQueryInfoAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedQueryInfoAsync(System.IntPtr file_, System.IntPtr attributes_, GISharp.Lib.Gio.FileQueryInfoFlags flags_, System.Int32 ioPriority_, System.IntPtr cancellable_, GISharp.Lib.Gio.UnmanagedAsyncReadyCallback callback_, System.IntPtr userData_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var attributes = new GISharp.Lib.GLib.UnownedUtf8(attributes_, -1);
                        var flags = (GISharp.Lib.Gio.FileQueryInfoFlags)flags_;
                        var ioPriority = (System.Int32)ioPriority_;
                        var callback = GISharp.Lib.Gio.AsyncReadyCallbackFactory.Create(callback_, userData_);
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doQueryInfoAsync = (QueryInfoAsync)methodInfo.CreateDelegate(typeof(QueryInfoAsync), file);
                        doQueryInfoAsync(attributes, flags, ioPriority, callback, cancellable);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }
                }

                return unmanagedQueryInfoAsync;
            }
        }

        public delegate GISharp.Lib.Gio.FileInfo QueryInfoFinish(GISharp.Lib.Gio.IAsyncResult res);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileInfo" type="GFileInfo*" managed-name="FileInfo" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedQueryInfoFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr res,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
System.IntPtr* error);

        /// <summary>
        /// Factory for creating <see cref="QueryInfoFinish"/> methods.
        /// </summary>
        public static class QueryInfoFinishFactory
        {
            public static unsafe UnmanagedQueryInfoFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedQueryInfoFinish(System.IntPtr file_, System.IntPtr res_, System.IntPtr* error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var res = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance(res_, GISharp.Runtime.Transfer.None);
                        var doQueryInfoFinish = (QueryInfoFinish)methodInfo.CreateDelegate(typeof(QueryInfoFinish), file);
                        var ret = doQueryInfoFinish(res);
                        var ret_ = ret?.Take() ?? throw new System.ArgumentNullException(nameof(ret));
                        return ret_;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedQueryInfoFinish;
            }
        }

        public delegate GISharp.Lib.Gio.FileInfo QueryFilesystemInfo(GISharp.Lib.GLib.UnownedUtf8 attributes, GISharp.Lib.Gio.Cancellable cancellable = null);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileInfo" type="GFileInfo*" managed-name="FileInfo" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedQueryFilesystemInfo(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr attributes,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
System.IntPtr* error);

        /// <summary>
        /// Factory for creating <see cref="QueryFilesystemInfo"/> methods.
        /// </summary>
        public static class QueryFilesystemInfoFactory
        {
            public static unsafe UnmanagedQueryFilesystemInfo Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedQueryFilesystemInfo(System.IntPtr file_, System.IntPtr attributes_, System.IntPtr cancellable_, System.IntPtr* error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var attributes = new GISharp.Lib.GLib.UnownedUtf8(attributes_, -1);
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doQueryFilesystemInfo = (QueryFilesystemInfo)methodInfo.CreateDelegate(typeof(QueryFilesystemInfo), file);
                        var ret = doQueryFilesystemInfo(attributes, cancellable);
                        var ret_ = ret?.Take() ?? throw new System.ArgumentNullException(nameof(ret));
                        return ret_;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedQueryFilesystemInfo;
            }
        }

        public delegate void QueryFilesystemInfoAsync(GISharp.Lib.GLib.UnownedUtf8 attributes, System.Int32 ioPriority, GISharp.Lib.Gio.AsyncReadyCallback callback, GISharp.Lib.Gio.Cancellable cancellable = null);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        public unsafe delegate void UnmanagedQueryFilesystemInfoAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr attributes,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
System.Int32 ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="UnmanagedAsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:5 direction:in */
GISharp.Lib.Gio.UnmanagedAsyncReadyCallback callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:5 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Factory for creating <see cref="QueryFilesystemInfoAsync"/> methods.
        /// </summary>
        public static class QueryFilesystemInfoAsyncFactory
        {
            public static unsafe UnmanagedQueryFilesystemInfoAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedQueryFilesystemInfoAsync(System.IntPtr file_, System.IntPtr attributes_, System.Int32 ioPriority_, System.IntPtr cancellable_, GISharp.Lib.Gio.UnmanagedAsyncReadyCallback callback_, System.IntPtr userData_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var attributes = new GISharp.Lib.GLib.UnownedUtf8(attributes_, -1);
                        var ioPriority = (System.Int32)ioPriority_;
                        var callback = GISharp.Lib.Gio.AsyncReadyCallbackFactory.Create(callback_, userData_);
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doQueryFilesystemInfoAsync = (QueryFilesystemInfoAsync)methodInfo.CreateDelegate(typeof(QueryFilesystemInfoAsync), file);
                        doQueryFilesystemInfoAsync(attributes, ioPriority, callback, cancellable);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }
                }

                return unmanagedQueryFilesystemInfoAsync;
            }
        }

        public delegate GISharp.Lib.Gio.FileInfo QueryFilesystemInfoFinish(GISharp.Lib.Gio.IAsyncResult res);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileInfo" type="GFileInfo*" managed-name="FileInfo" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedQueryFilesystemInfoFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr res,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
System.IntPtr* error);

        /// <summary>
        /// Factory for creating <see cref="QueryFilesystemInfoFinish"/> methods.
        /// </summary>
        public static class QueryFilesystemInfoFinishFactory
        {
            public static unsafe UnmanagedQueryFilesystemInfoFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedQueryFilesystemInfoFinish(System.IntPtr file_, System.IntPtr res_, System.IntPtr* error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var res = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance(res_, GISharp.Runtime.Transfer.None);
                        var doQueryFilesystemInfoFinish = (QueryFilesystemInfoFinish)methodInfo.CreateDelegate(typeof(QueryFilesystemInfoFinish), file);
                        var ret = doQueryFilesystemInfoFinish(res);
                        var ret_ = ret?.Take() ?? throw new System.ArgumentNullException(nameof(ret));
                        return ret_;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedQueryFilesystemInfoFinish;
            }
        }

        public delegate void FindEnclosingMountAsync(System.Int32 ioPriority, GISharp.Lib.Gio.AsyncReadyCallback callback, GISharp.Lib.Gio.Cancellable cancellable = null);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        public unsafe delegate void UnmanagedFindEnclosingMountAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
System.Int32 ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="UnmanagedAsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:4 direction:in */
GISharp.Lib.Gio.UnmanagedAsyncReadyCallback callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:4 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Factory for creating <see cref="FindEnclosingMountAsync"/> methods.
        /// </summary>
        public static class FindEnclosingMountAsyncFactory
        {
            public static unsafe UnmanagedFindEnclosingMountAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedFindEnclosingMountAsync(System.IntPtr file_, System.Int32 ioPriority_, System.IntPtr cancellable_, GISharp.Lib.Gio.UnmanagedAsyncReadyCallback callback_, System.IntPtr userData_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var ioPriority = (System.Int32)ioPriority_;
                        var callback = GISharp.Lib.Gio.AsyncReadyCallbackFactory.Create(callback_, userData_);
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doFindEnclosingMountAsync = (FindEnclosingMountAsync)methodInfo.CreateDelegate(typeof(FindEnclosingMountAsync), file);
                        doFindEnclosingMountAsync(ioPriority, callback, cancellable);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }
                }

                return unmanagedFindEnclosingMountAsync;
            }
        }

        public delegate GISharp.Lib.Gio.IFile SetDisplayName(GISharp.Lib.GLib.UnownedUtf8 displayName, GISharp.Lib.Gio.Cancellable cancellable = null);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedSetDisplayName(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr displayName,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
System.IntPtr* error);

        /// <summary>
        /// Factory for creating <see cref="SetDisplayName"/> methods.
        /// </summary>
        public static class SetDisplayNameFactory
        {
            public static unsafe UnmanagedSetDisplayName Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedSetDisplayName(System.IntPtr file_, System.IntPtr displayName_, System.IntPtr cancellable_, System.IntPtr* error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var displayName = new GISharp.Lib.GLib.UnownedUtf8(displayName_, -1);
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doSetDisplayName = (SetDisplayName)methodInfo.CreateDelegate(typeof(SetDisplayName), file);
                        var ret = doSetDisplayName(displayName, cancellable);
                        var ret_ = ret?.Take() ?? throw new System.ArgumentNullException(nameof(ret));
                        return ret_;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedSetDisplayName;
            }
        }

        public delegate void SetDisplayNameAsync(GISharp.Lib.GLib.UnownedUtf8 displayName, System.Int32 ioPriority, GISharp.Lib.Gio.AsyncReadyCallback callback, GISharp.Lib.Gio.Cancellable cancellable = null);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        public unsafe delegate void UnmanagedSetDisplayNameAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr displayName,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
System.Int32 ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="UnmanagedAsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:5 direction:in */
GISharp.Lib.Gio.UnmanagedAsyncReadyCallback callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:5 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Factory for creating <see cref="SetDisplayNameAsync"/> methods.
        /// </summary>
        public static class SetDisplayNameAsyncFactory
        {
            public static unsafe UnmanagedSetDisplayNameAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedSetDisplayNameAsync(System.IntPtr file_, System.IntPtr displayName_, System.Int32 ioPriority_, System.IntPtr cancellable_, GISharp.Lib.Gio.UnmanagedAsyncReadyCallback callback_, System.IntPtr userData_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var displayName = new GISharp.Lib.GLib.UnownedUtf8(displayName_, -1);
                        var ioPriority = (System.Int32)ioPriority_;
                        var callback = GISharp.Lib.Gio.AsyncReadyCallbackFactory.Create(callback_, userData_);
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doSetDisplayNameAsync = (SetDisplayNameAsync)methodInfo.CreateDelegate(typeof(SetDisplayNameAsync), file);
                        doSetDisplayNameAsync(displayName, ioPriority, callback, cancellable);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }
                }

                return unmanagedSetDisplayNameAsync;
            }
        }

        public delegate GISharp.Lib.Gio.IFile SetDisplayNameFinish(GISharp.Lib.Gio.IAsyncResult res);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedSetDisplayNameFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr res,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
System.IntPtr* error);

        /// <summary>
        /// Factory for creating <see cref="SetDisplayNameFinish"/> methods.
        /// </summary>
        public static class SetDisplayNameFinishFactory
        {
            public static unsafe UnmanagedSetDisplayNameFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedSetDisplayNameFinish(System.IntPtr file_, System.IntPtr res_, System.IntPtr* error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var res = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance(res_, GISharp.Runtime.Transfer.None);
                        var doSetDisplayNameFinish = (SetDisplayNameFinish)methodInfo.CreateDelegate(typeof(SetDisplayNameFinish), file);
                        var ret = doSetDisplayNameFinish(res);
                        var ret_ = ret?.Take() ?? throw new System.ArgumentNullException(nameof(ret));
                        return ret_;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedSetDisplayNameFinish;
            }
        }

        public delegate GISharp.Lib.Gio.FileAttributeInfoList QuerySettableAttributes(GISharp.Lib.Gio.Cancellable cancellable = null);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileAttributeInfoList" type="GFileAttributeInfoList*" managed-name="FileAttributeInfoList" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedQuerySettableAttributes(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
System.IntPtr* error);

        /// <summary>
        /// Factory for creating <see cref="QuerySettableAttributes"/> methods.
        /// </summary>
        public static class QuerySettableAttributesFactory
        {
            public static unsafe UnmanagedQuerySettableAttributes Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedQuerySettableAttributes(System.IntPtr file_, System.IntPtr cancellable_, System.IntPtr* error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doQuerySettableAttributes = (QuerySettableAttributes)methodInfo.CreateDelegate(typeof(QuerySettableAttributes), file);
                        var ret = doQuerySettableAttributes(cancellable);
                        var ret_ = ret?.Take() ?? throw new System.ArgumentNullException(nameof(ret));
                        return ret_;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedQuerySettableAttributes;
            }
        }

        public delegate GISharp.Lib.Gio.FileAttributeInfoList QueryWritableNamespaces(GISharp.Lib.Gio.Cancellable cancellable = null);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileAttributeInfoList" type="GFileAttributeInfoList*" managed-name="FileAttributeInfoList" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedQueryWritableNamespaces(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
System.IntPtr* error);

        /// <summary>
        /// Factory for creating <see cref="QueryWritableNamespaces"/> methods.
        /// </summary>
        public static class QueryWritableNamespacesFactory
        {
            public static unsafe UnmanagedQueryWritableNamespaces Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedQueryWritableNamespaces(System.IntPtr file_, System.IntPtr cancellable_, System.IntPtr* error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doQueryWritableNamespaces = (QueryWritableNamespaces)methodInfo.CreateDelegate(typeof(QueryWritableNamespaces), file);
                        var ret = doQueryWritableNamespaces(cancellable);
                        var ret_ = ret?.Take() ?? throw new System.ArgumentNullException(nameof(ret));
                        return ret_;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedQueryWritableNamespaces;
            }
        }

        public delegate void SetAttribute(GISharp.Lib.GLib.UnownedUtf8 attribute, GISharp.Lib.Gio.FileAttributeType type, System.IntPtr valueP, GISharp.Lib.Gio.FileQueryInfoFlags flags, GISharp.Lib.Gio.Cancellable cancellable = null);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:out */
        public unsafe delegate System.Boolean UnmanagedSetAttribute(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr attribute,
/* <type name="FileAttributeType" type="GFileAttributeType" managed-name="FileAttributeType" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileAttributeType type,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr valueP,
/* <type name="FileQueryInfoFlags" type="GFileQueryInfoFlags" managed-name="FileQueryInfoFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileQueryInfoFlags flags,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
System.IntPtr* error);

        /// <summary>
        /// Factory for creating <see cref="SetAttribute"/> methods.
        /// </summary>
        public static class SetAttributeFactory
        {
            public static unsafe UnmanagedSetAttribute Create(System.Reflection.MethodInfo methodInfo)
            {
                System.Boolean unmanagedSetAttribute(System.IntPtr file_, System.IntPtr attribute_, GISharp.Lib.Gio.FileAttributeType type_, System.IntPtr valueP_, GISharp.Lib.Gio.FileQueryInfoFlags flags_, System.IntPtr cancellable_, System.IntPtr* error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var attribute = new GISharp.Lib.GLib.UnownedUtf8(attribute_, -1);
                        var type = (GISharp.Lib.Gio.FileAttributeType)type_;
                        var valueP = (System.IntPtr)valueP_;
                        var flags = (GISharp.Lib.Gio.FileQueryInfoFlags)flags_;
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doSetAttribute = (SetAttribute)methodInfo.CreateDelegate(typeof(SetAttribute), file);
                        doSetAttribute(attribute, type, valueP, flags, cancellable);
                        return true;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.Boolean);
                }

                return unmanagedSetAttribute;
            }
        }

        public delegate void SetAttributesFromInfo(GISharp.Lib.Gio.FileInfo info, GISharp.Lib.Gio.FileQueryInfoFlags flags, GISharp.Lib.Gio.Cancellable cancellable = null);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:out */
        public unsafe delegate System.Boolean UnmanagedSetAttributesFromInfo(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="FileInfo" type="GFileInfo*" managed-name="FileInfo" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr info,
/* <type name="FileQueryInfoFlags" type="GFileQueryInfoFlags" managed-name="FileQueryInfoFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileQueryInfoFlags flags,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
System.IntPtr* error);

        /// <summary>
        /// Factory for creating <see cref="SetAttributesFromInfo"/> methods.
        /// </summary>
        public static class SetAttributesFromInfoFactory
        {
            public static unsafe UnmanagedSetAttributesFromInfo Create(System.Reflection.MethodInfo methodInfo)
            {
                System.Boolean unmanagedSetAttributesFromInfo(System.IntPtr file_, System.IntPtr info_, GISharp.Lib.Gio.FileQueryInfoFlags flags_, System.IntPtr cancellable_, System.IntPtr* error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var info = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.FileInfo>(info_, GISharp.Runtime.Transfer.None);
                        var flags = (GISharp.Lib.Gio.FileQueryInfoFlags)flags_;
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doSetAttributesFromInfo = (SetAttributesFromInfo)methodInfo.CreateDelegate(typeof(SetAttributesFromInfo), file);
                        doSetAttributesFromInfo(info, flags, cancellable);
                        return true;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.Boolean);
                }

                return unmanagedSetAttributesFromInfo;
            }
        }

        public delegate void SetAttributesAsync(GISharp.Lib.Gio.FileInfo info, GISharp.Lib.Gio.FileQueryInfoFlags flags, System.Int32 ioPriority, GISharp.Lib.Gio.AsyncReadyCallback callback, GISharp.Lib.Gio.Cancellable cancellable = null);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        public unsafe delegate void UnmanagedSetAttributesAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="FileInfo" type="GFileInfo*" managed-name="FileInfo" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr info,
/* <type name="FileQueryInfoFlags" type="GFileQueryInfoFlags" managed-name="FileQueryInfoFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileQueryInfoFlags flags,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
System.Int32 ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="UnmanagedAsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:6 direction:in */
GISharp.Lib.Gio.UnmanagedAsyncReadyCallback callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:6 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Factory for creating <see cref="SetAttributesAsync"/> methods.
        /// </summary>
        public static class SetAttributesAsyncFactory
        {
            public static unsafe UnmanagedSetAttributesAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedSetAttributesAsync(System.IntPtr file_, System.IntPtr info_, GISharp.Lib.Gio.FileQueryInfoFlags flags_, System.Int32 ioPriority_, System.IntPtr cancellable_, GISharp.Lib.Gio.UnmanagedAsyncReadyCallback callback_, System.IntPtr userData_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var info = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.FileInfo>(info_, GISharp.Runtime.Transfer.None);
                        var flags = (GISharp.Lib.Gio.FileQueryInfoFlags)flags_;
                        var ioPriority = (System.Int32)ioPriority_;
                        var callback = GISharp.Lib.Gio.AsyncReadyCallbackFactory.Create(callback_, userData_);
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doSetAttributesAsync = (SetAttributesAsync)methodInfo.CreateDelegate(typeof(SetAttributesAsync), file);
                        doSetAttributesAsync(info, flags, ioPriority, callback, cancellable);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }
                }

                return unmanagedSetAttributesAsync;
            }
        }

        public delegate void SetAttributesFinish(GISharp.Lib.Gio.IAsyncResult result, out GISharp.Lib.Gio.FileInfo info);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:out */
        public unsafe delegate System.Boolean UnmanagedSetAttributesFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr result,
/* <type name="FileInfo" type="GFileInfo**" managed-name="FileInfo" is-pointer="1" /> */
/* direction:out caller-allocates:0 transfer-ownership:full */
System.IntPtr* info,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
System.IntPtr* error);

        /// <summary>
        /// Factory for creating <see cref="SetAttributesFinish"/> methods.
        /// </summary>
        public static class SetAttributesFinishFactory
        {
            public static unsafe UnmanagedSetAttributesFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                System.Boolean unmanagedSetAttributesFinish(System.IntPtr file_, System.IntPtr result_, System.IntPtr* info_, System.IntPtr* error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance(result_, GISharp.Runtime.Transfer.None);
                        var doSetAttributesFinish = (SetAttributesFinish)methodInfo.CreateDelegate(typeof(SetAttributesFinish), file);
                        doSetAttributesFinish(result,out var info);
                        *info_ = info?.Take() ?? throw new System.ArgumentNullException(nameof(info));
                        return true;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.Boolean);
                }

                return unmanagedSetAttributesFinish;
            }
        }

        public delegate GISharp.Lib.Gio.FileInputStream ReadFn(GISharp.Lib.Gio.Cancellable cancellable = null);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileInputStream" type="GFileInputStream*" managed-name="FileInputStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedReadFn(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
System.IntPtr* error);

        /// <summary>
        /// Factory for creating <see cref="ReadFn"/> methods.
        /// </summary>
        public static class ReadFnFactory
        {
            public static unsafe UnmanagedReadFn Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedReadFn(System.IntPtr file_, System.IntPtr cancellable_, System.IntPtr* error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doReadFn = (ReadFn)methodInfo.CreateDelegate(typeof(ReadFn), file);
                        var ret = doReadFn(cancellable);
                        var ret_ = ret?.Take() ?? throw new System.ArgumentNullException(nameof(ret));
                        return ret_;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedReadFn;
            }
        }

        public delegate void ReadAsync(System.Int32 ioPriority, GISharp.Lib.Gio.AsyncReadyCallback callback, GISharp.Lib.Gio.Cancellable cancellable = null);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        public unsafe delegate void UnmanagedReadAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
System.Int32 ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="UnmanagedAsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:4 direction:in */
GISharp.Lib.Gio.UnmanagedAsyncReadyCallback callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:4 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Factory for creating <see cref="ReadAsync"/> methods.
        /// </summary>
        public static class ReadAsyncFactory
        {
            public static unsafe UnmanagedReadAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedReadAsync(System.IntPtr file_, System.Int32 ioPriority_, System.IntPtr cancellable_, GISharp.Lib.Gio.UnmanagedAsyncReadyCallback callback_, System.IntPtr userData_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var ioPriority = (System.Int32)ioPriority_;
                        var callback = GISharp.Lib.Gio.AsyncReadyCallbackFactory.Create(callback_, userData_);
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doReadAsync = (ReadAsync)methodInfo.CreateDelegate(typeof(ReadAsync), file);
                        doReadAsync(ioPriority, callback, cancellable);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }
                }

                return unmanagedReadAsync;
            }
        }

        public delegate GISharp.Lib.Gio.FileInputStream ReadFinish(GISharp.Lib.Gio.IAsyncResult res);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileInputStream" type="GFileInputStream*" managed-name="FileInputStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedReadFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr res,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
System.IntPtr* error);

        /// <summary>
        /// Factory for creating <see cref="ReadFinish"/> methods.
        /// </summary>
        public static class ReadFinishFactory
        {
            public static unsafe UnmanagedReadFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedReadFinish(System.IntPtr file_, System.IntPtr res_, System.IntPtr* error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var res = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance(res_, GISharp.Runtime.Transfer.None);
                        var doReadFinish = (ReadFinish)methodInfo.CreateDelegate(typeof(ReadFinish), file);
                        var ret = doReadFinish(res);
                        var ret_ = ret?.Take() ?? throw new System.ArgumentNullException(nameof(ret));
                        return ret_;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedReadFinish;
            }
        }

        public delegate GISharp.Lib.Gio.FileOutputStream AppendTo(GISharp.Lib.Gio.FileCreateFlags flags, GISharp.Lib.Gio.Cancellable cancellable = null);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileOutputStream" type="GFileOutputStream*" managed-name="FileOutputStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedAppendTo(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="FileCreateFlags" type="GFileCreateFlags" managed-name="FileCreateFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileCreateFlags flags,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
System.IntPtr* error);

        /// <summary>
        /// Factory for creating <see cref="AppendTo"/> methods.
        /// </summary>
        public static class AppendToFactory
        {
            public static unsafe UnmanagedAppendTo Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedAppendTo(System.IntPtr file_, GISharp.Lib.Gio.FileCreateFlags flags_, System.IntPtr cancellable_, System.IntPtr* error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var flags = (GISharp.Lib.Gio.FileCreateFlags)flags_;
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doAppendTo = (AppendTo)methodInfo.CreateDelegate(typeof(AppendTo), file);
                        var ret = doAppendTo(flags, cancellable);
                        var ret_ = ret?.Take() ?? throw new System.ArgumentNullException(nameof(ret));
                        return ret_;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedAppendTo;
            }
        }

        public delegate void AppendToAsync(GISharp.Lib.Gio.FileCreateFlags flags, System.Int32 ioPriority, GISharp.Lib.Gio.AsyncReadyCallback callback, GISharp.Lib.Gio.Cancellable cancellable = null);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        public unsafe delegate void UnmanagedAppendToAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="FileCreateFlags" type="GFileCreateFlags" managed-name="FileCreateFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileCreateFlags flags,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
System.Int32 ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="UnmanagedAsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:5 direction:in */
GISharp.Lib.Gio.UnmanagedAsyncReadyCallback callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:5 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Factory for creating <see cref="AppendToAsync"/> methods.
        /// </summary>
        public static class AppendToAsyncFactory
        {
            public static unsafe UnmanagedAppendToAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedAppendToAsync(System.IntPtr file_, GISharp.Lib.Gio.FileCreateFlags flags_, System.Int32 ioPriority_, System.IntPtr cancellable_, GISharp.Lib.Gio.UnmanagedAsyncReadyCallback callback_, System.IntPtr userData_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var flags = (GISharp.Lib.Gio.FileCreateFlags)flags_;
                        var ioPriority = (System.Int32)ioPriority_;
                        var callback = GISharp.Lib.Gio.AsyncReadyCallbackFactory.Create(callback_, userData_);
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doAppendToAsync = (AppendToAsync)methodInfo.CreateDelegate(typeof(AppendToAsync), file);
                        doAppendToAsync(flags, ioPriority, callback, cancellable);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }
                }

                return unmanagedAppendToAsync;
            }
        }

        public delegate GISharp.Lib.Gio.FileOutputStream AppendToFinish(GISharp.Lib.Gio.IAsyncResult res);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileOutputStream" type="GFileOutputStream*" managed-name="FileOutputStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedAppendToFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr res,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
System.IntPtr* error);

        /// <summary>
        /// Factory for creating <see cref="AppendToFinish"/> methods.
        /// </summary>
        public static class AppendToFinishFactory
        {
            public static unsafe UnmanagedAppendToFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedAppendToFinish(System.IntPtr file_, System.IntPtr res_, System.IntPtr* error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var res = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance(res_, GISharp.Runtime.Transfer.None);
                        var doAppendToFinish = (AppendToFinish)methodInfo.CreateDelegate(typeof(AppendToFinish), file);
                        var ret = doAppendToFinish(res);
                        var ret_ = ret?.Take() ?? throw new System.ArgumentNullException(nameof(ret));
                        return ret_;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedAppendToFinish;
            }
        }

        public delegate GISharp.Lib.Gio.FileOutputStream Create(GISharp.Lib.Gio.FileCreateFlags flags, GISharp.Lib.Gio.Cancellable cancellable = null);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileOutputStream" type="GFileOutputStream*" managed-name="FileOutputStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedCreate(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="FileCreateFlags" type="GFileCreateFlags" managed-name="FileCreateFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileCreateFlags flags,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
System.IntPtr* error);

        /// <summary>
        /// Factory for creating <see cref="Create"/> methods.
        /// </summary>
        public static class CreateFactory
        {
            public static unsafe UnmanagedCreate Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedCreate(System.IntPtr file_, GISharp.Lib.Gio.FileCreateFlags flags_, System.IntPtr cancellable_, System.IntPtr* error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var flags = (GISharp.Lib.Gio.FileCreateFlags)flags_;
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doCreate = (Create)methodInfo.CreateDelegate(typeof(Create), file);
                        var ret = doCreate(flags, cancellable);
                        var ret_ = ret?.Take() ?? throw new System.ArgumentNullException(nameof(ret));
                        return ret_;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedCreate;
            }
        }

        public delegate void CreateAsync(GISharp.Lib.Gio.FileCreateFlags flags, System.Int32 ioPriority, GISharp.Lib.Gio.AsyncReadyCallback callback, GISharp.Lib.Gio.Cancellable cancellable = null);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        public unsafe delegate void UnmanagedCreateAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="FileCreateFlags" type="GFileCreateFlags" managed-name="FileCreateFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileCreateFlags flags,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
System.Int32 ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="UnmanagedAsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:5 direction:in */
GISharp.Lib.Gio.UnmanagedAsyncReadyCallback callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:5 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Factory for creating <see cref="CreateAsync"/> methods.
        /// </summary>
        public static class CreateAsyncFactory
        {
            public static unsafe UnmanagedCreateAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedCreateAsync(System.IntPtr file_, GISharp.Lib.Gio.FileCreateFlags flags_, System.Int32 ioPriority_, System.IntPtr cancellable_, GISharp.Lib.Gio.UnmanagedAsyncReadyCallback callback_, System.IntPtr userData_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var flags = (GISharp.Lib.Gio.FileCreateFlags)flags_;
                        var ioPriority = (System.Int32)ioPriority_;
                        var callback = GISharp.Lib.Gio.AsyncReadyCallbackFactory.Create(callback_, userData_);
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doCreateAsync = (CreateAsync)methodInfo.CreateDelegate(typeof(CreateAsync), file);
                        doCreateAsync(flags, ioPriority, callback, cancellable);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }
                }

                return unmanagedCreateAsync;
            }
        }

        public delegate GISharp.Lib.Gio.FileOutputStream CreateFinish(GISharp.Lib.Gio.IAsyncResult res);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileOutputStream" type="GFileOutputStream*" managed-name="FileOutputStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedCreateFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr res,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
System.IntPtr* error);

        /// <summary>
        /// Factory for creating <see cref="CreateFinish"/> methods.
        /// </summary>
        public static class CreateFinishFactory
        {
            public static unsafe UnmanagedCreateFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedCreateFinish(System.IntPtr file_, System.IntPtr res_, System.IntPtr* error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var res = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance(res_, GISharp.Runtime.Transfer.None);
                        var doCreateFinish = (CreateFinish)methodInfo.CreateDelegate(typeof(CreateFinish), file);
                        var ret = doCreateFinish(res);
                        var ret_ = ret?.Take() ?? throw new System.ArgumentNullException(nameof(ret));
                        return ret_;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedCreateFinish;
            }
        }

        public delegate GISharp.Lib.Gio.FileOutputStream Replace(GISharp.Lib.GLib.UnownedUtf8 etag, System.Boolean makeBackup, GISharp.Lib.Gio.FileCreateFlags flags, GISharp.Lib.Gio.Cancellable cancellable = null);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileOutputStream" type="GFileOutputStream*" managed-name="FileOutputStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedReplace(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr etag,
/* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
/* transfer-ownership:none direction:in */
System.Boolean makeBackup,
/* <type name="FileCreateFlags" type="GFileCreateFlags" managed-name="FileCreateFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileCreateFlags flags,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
System.IntPtr* error);

        /// <summary>
        /// Factory for creating <see cref="Replace"/> methods.
        /// </summary>
        public static class ReplaceFactory
        {
            public static unsafe UnmanagedReplace Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedReplace(System.IntPtr file_, System.IntPtr etag_, System.Boolean makeBackup_, GISharp.Lib.Gio.FileCreateFlags flags_, System.IntPtr cancellable_, System.IntPtr* error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var etag = new GISharp.Lib.GLib.UnownedUtf8(etag_, -1);
                        var makeBackup = (System.Boolean)makeBackup_;
                        var flags = (GISharp.Lib.Gio.FileCreateFlags)flags_;
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doReplace = (Replace)methodInfo.CreateDelegate(typeof(Replace), file);
                        var ret = doReplace(etag, makeBackup, flags, cancellable);
                        var ret_ = ret?.Take() ?? throw new System.ArgumentNullException(nameof(ret));
                        return ret_;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedReplace;
            }
        }

        public delegate void ReplaceAsync(GISharp.Lib.GLib.UnownedUtf8 etag, System.Boolean makeBackup, GISharp.Lib.Gio.FileCreateFlags flags, System.Int32 ioPriority, GISharp.Lib.Gio.AsyncReadyCallback callback, GISharp.Lib.Gio.Cancellable cancellable = null);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        public unsafe delegate void UnmanagedReplaceAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr etag,
/* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
/* transfer-ownership:none direction:in */
System.Boolean makeBackup,
/* <type name="FileCreateFlags" type="GFileCreateFlags" managed-name="FileCreateFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileCreateFlags flags,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
System.Int32 ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="UnmanagedAsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:7 direction:in */
GISharp.Lib.Gio.UnmanagedAsyncReadyCallback callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:7 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Factory for creating <see cref="ReplaceAsync"/> methods.
        /// </summary>
        public static class ReplaceAsyncFactory
        {
            public static unsafe UnmanagedReplaceAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedReplaceAsync(System.IntPtr file_, System.IntPtr etag_, System.Boolean makeBackup_, GISharp.Lib.Gio.FileCreateFlags flags_, System.Int32 ioPriority_, System.IntPtr cancellable_, GISharp.Lib.Gio.UnmanagedAsyncReadyCallback callback_, System.IntPtr userData_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var etag = new GISharp.Lib.GLib.UnownedUtf8(etag_, -1);
                        var makeBackup = (System.Boolean)makeBackup_;
                        var flags = (GISharp.Lib.Gio.FileCreateFlags)flags_;
                        var ioPriority = (System.Int32)ioPriority_;
                        var callback = GISharp.Lib.Gio.AsyncReadyCallbackFactory.Create(callback_, userData_);
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doReplaceAsync = (ReplaceAsync)methodInfo.CreateDelegate(typeof(ReplaceAsync), file);
                        doReplaceAsync(etag, makeBackup, flags, ioPriority, callback, cancellable);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }
                }

                return unmanagedReplaceAsync;
            }
        }

        public delegate GISharp.Lib.Gio.FileOutputStream ReplaceFinish(GISharp.Lib.Gio.IAsyncResult res);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileOutputStream" type="GFileOutputStream*" managed-name="FileOutputStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedReplaceFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr res,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
System.IntPtr* error);

        /// <summary>
        /// Factory for creating <see cref="ReplaceFinish"/> methods.
        /// </summary>
        public static class ReplaceFinishFactory
        {
            public static unsafe UnmanagedReplaceFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedReplaceFinish(System.IntPtr file_, System.IntPtr res_, System.IntPtr* error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var res = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance(res_, GISharp.Runtime.Transfer.None);
                        var doReplaceFinish = (ReplaceFinish)methodInfo.CreateDelegate(typeof(ReplaceFinish), file);
                        var ret = doReplaceFinish(res);
                        var ret_ = ret?.Take() ?? throw new System.ArgumentNullException(nameof(ret));
                        return ret_;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedReplaceFinish;
            }
        }

        public delegate void DeleteFile(GISharp.Lib.Gio.Cancellable cancellable = null);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:out */
        public unsafe delegate System.Boolean UnmanagedDeleteFile(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
System.IntPtr* error);

        /// <summary>
        /// Factory for creating <see cref="DeleteFile"/> methods.
        /// </summary>
        public static class DeleteFileFactory
        {
            public static unsafe UnmanagedDeleteFile Create(System.Reflection.MethodInfo methodInfo)
            {
                System.Boolean unmanagedDeleteFile(System.IntPtr file_, System.IntPtr cancellable_, System.IntPtr* error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doDeleteFile = (DeleteFile)methodInfo.CreateDelegate(typeof(DeleteFile), file);
                        doDeleteFile(cancellable);
                        return true;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.Boolean);
                }

                return unmanagedDeleteFile;
            }
        }

        public delegate void DeleteFileAsync(System.Int32 ioPriority, GISharp.Lib.Gio.AsyncReadyCallback callback, GISharp.Lib.Gio.Cancellable cancellable = null);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        public unsafe delegate void UnmanagedDeleteFileAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
System.Int32 ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="UnmanagedAsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:4 direction:in */
GISharp.Lib.Gio.UnmanagedAsyncReadyCallback callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:4 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Factory for creating <see cref="DeleteFileAsync"/> methods.
        /// </summary>
        public static class DeleteFileAsyncFactory
        {
            public static unsafe UnmanagedDeleteFileAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedDeleteFileAsync(System.IntPtr file_, System.Int32 ioPriority_, System.IntPtr cancellable_, GISharp.Lib.Gio.UnmanagedAsyncReadyCallback callback_, System.IntPtr userData_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var ioPriority = (System.Int32)ioPriority_;
                        var callback = GISharp.Lib.Gio.AsyncReadyCallbackFactory.Create(callback_, userData_);
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doDeleteFileAsync = (DeleteFileAsync)methodInfo.CreateDelegate(typeof(DeleteFileAsync), file);
                        doDeleteFileAsync(ioPriority, callback, cancellable);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }
                }

                return unmanagedDeleteFileAsync;
            }
        }

        public delegate void DeleteFileFinish(GISharp.Lib.Gio.IAsyncResult result);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:out */
        public unsafe delegate System.Boolean UnmanagedDeleteFileFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr result,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
System.IntPtr* error);

        /// <summary>
        /// Factory for creating <see cref="DeleteFileFinish"/> methods.
        /// </summary>
        public static class DeleteFileFinishFactory
        {
            public static unsafe UnmanagedDeleteFileFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                System.Boolean unmanagedDeleteFileFinish(System.IntPtr file_, System.IntPtr result_, System.IntPtr* error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance(result_, GISharp.Runtime.Transfer.None);
                        var doDeleteFileFinish = (DeleteFileFinish)methodInfo.CreateDelegate(typeof(DeleteFileFinish), file);
                        doDeleteFileFinish(result);
                        return true;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.Boolean);
                }

                return unmanagedDeleteFileFinish;
            }
        }

        public delegate void Trash(GISharp.Lib.Gio.Cancellable cancellable = null);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:out */
        public unsafe delegate System.Boolean UnmanagedTrash(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
System.IntPtr* error);

        /// <summary>
        /// Factory for creating <see cref="Trash"/> methods.
        /// </summary>
        public static class TrashFactory
        {
            public static unsafe UnmanagedTrash Create(System.Reflection.MethodInfo methodInfo)
            {
                System.Boolean unmanagedTrash(System.IntPtr file_, System.IntPtr cancellable_, System.IntPtr* error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doTrash = (Trash)methodInfo.CreateDelegate(typeof(Trash), file);
                        doTrash(cancellable);
                        return true;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.Boolean);
                }

                return unmanagedTrash;
            }
        }

        public delegate void TrashAsync(System.Int32 ioPriority, GISharp.Lib.Gio.AsyncReadyCallback callback, GISharp.Lib.Gio.Cancellable cancellable = null);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        public unsafe delegate void UnmanagedTrashAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
System.Int32 ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="UnmanagedAsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:4 direction:in */
GISharp.Lib.Gio.UnmanagedAsyncReadyCallback callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:4 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Factory for creating <see cref="TrashAsync"/> methods.
        /// </summary>
        public static class TrashAsyncFactory
        {
            public static unsafe UnmanagedTrashAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedTrashAsync(System.IntPtr file_, System.Int32 ioPriority_, System.IntPtr cancellable_, GISharp.Lib.Gio.UnmanagedAsyncReadyCallback callback_, System.IntPtr userData_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var ioPriority = (System.Int32)ioPriority_;
                        var callback = GISharp.Lib.Gio.AsyncReadyCallbackFactory.Create(callback_, userData_);
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doTrashAsync = (TrashAsync)methodInfo.CreateDelegate(typeof(TrashAsync), file);
                        doTrashAsync(ioPriority, callback, cancellable);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }
                }

                return unmanagedTrashAsync;
            }
        }

        public delegate void TrashFinish(GISharp.Lib.Gio.IAsyncResult result);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:out */
        public unsafe delegate System.Boolean UnmanagedTrashFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr result,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
System.IntPtr* error);

        /// <summary>
        /// Factory for creating <see cref="TrashFinish"/> methods.
        /// </summary>
        public static class TrashFinishFactory
        {
            public static unsafe UnmanagedTrashFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                System.Boolean unmanagedTrashFinish(System.IntPtr file_, System.IntPtr result_, System.IntPtr* error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance(result_, GISharp.Runtime.Transfer.None);
                        var doTrashFinish = (TrashFinish)methodInfo.CreateDelegate(typeof(TrashFinish), file);
                        doTrashFinish(result);
                        return true;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.Boolean);
                }

                return unmanagedTrashFinish;
            }
        }

        public delegate void MakeDirectory(GISharp.Lib.Gio.Cancellable cancellable = null);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:out */
        public unsafe delegate System.Boolean UnmanagedMakeDirectory(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
System.IntPtr* error);

        /// <summary>
        /// Factory for creating <see cref="MakeDirectory"/> methods.
        /// </summary>
        public static class MakeDirectoryFactory
        {
            public static unsafe UnmanagedMakeDirectory Create(System.Reflection.MethodInfo methodInfo)
            {
                System.Boolean unmanagedMakeDirectory(System.IntPtr file_, System.IntPtr cancellable_, System.IntPtr* error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doMakeDirectory = (MakeDirectory)methodInfo.CreateDelegate(typeof(MakeDirectory), file);
                        doMakeDirectory(cancellable);
                        return true;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.Boolean);
                }

                return unmanagedMakeDirectory;
            }
        }

        public delegate void MakeDirectoryAsync(System.Int32 ioPriority, GISharp.Lib.Gio.AsyncReadyCallback callback, GISharp.Lib.Gio.Cancellable cancellable = null);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        public unsafe delegate void UnmanagedMakeDirectoryAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
System.Int32 ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="UnmanagedAsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:4 direction:in */
GISharp.Lib.Gio.UnmanagedAsyncReadyCallback callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:4 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Factory for creating <see cref="MakeDirectoryAsync"/> methods.
        /// </summary>
        public static class MakeDirectoryAsyncFactory
        {
            public static unsafe UnmanagedMakeDirectoryAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedMakeDirectoryAsync(System.IntPtr file_, System.Int32 ioPriority_, System.IntPtr cancellable_, GISharp.Lib.Gio.UnmanagedAsyncReadyCallback callback_, System.IntPtr userData_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var ioPriority = (System.Int32)ioPriority_;
                        var callback = GISharp.Lib.Gio.AsyncReadyCallbackFactory.Create(callback_, userData_);
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doMakeDirectoryAsync = (MakeDirectoryAsync)methodInfo.CreateDelegate(typeof(MakeDirectoryAsync), file);
                        doMakeDirectoryAsync(ioPriority, callback, cancellable);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }
                }

                return unmanagedMakeDirectoryAsync;
            }
        }

        public delegate void MakeDirectoryFinish(GISharp.Lib.Gio.IAsyncResult result);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:out */
        public unsafe delegate System.Boolean UnmanagedMakeDirectoryFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr result,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
System.IntPtr* error);

        /// <summary>
        /// Factory for creating <see cref="MakeDirectoryFinish"/> methods.
        /// </summary>
        public static class MakeDirectoryFinishFactory
        {
            public static unsafe UnmanagedMakeDirectoryFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                System.Boolean unmanagedMakeDirectoryFinish(System.IntPtr file_, System.IntPtr result_, System.IntPtr* error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance(result_, GISharp.Runtime.Transfer.None);
                        var doMakeDirectoryFinish = (MakeDirectoryFinish)methodInfo.CreateDelegate(typeof(MakeDirectoryFinish), file);
                        doMakeDirectoryFinish(result);
                        return true;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.Boolean);
                }

                return unmanagedMakeDirectoryFinish;
            }
        }

        public delegate void MakeSymbolicLink(GISharp.Lib.GLib.Filename symlinkValue, GISharp.Lib.Gio.Cancellable cancellable = null);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:out */
        public unsafe delegate System.Boolean UnmanagedMakeSymbolicLink(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="filename" type="const char*" managed-name="GISharp.Lib.GLib.Filename" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr symlinkValue,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
System.IntPtr* error);

        /// <summary>
        /// Factory for creating <see cref="MakeSymbolicLink"/> methods.
        /// </summary>
        public static class MakeSymbolicLinkFactory
        {
            public static unsafe UnmanagedMakeSymbolicLink Create(System.Reflection.MethodInfo methodInfo)
            {
                System.Boolean unmanagedMakeSymbolicLink(System.IntPtr file_, System.IntPtr symlinkValue_, System.IntPtr cancellable_, System.IntPtr* error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var symlinkValue = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Filename>(symlinkValue_, GISharp.Runtime.Transfer.None);
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doMakeSymbolicLink = (MakeSymbolicLink)methodInfo.CreateDelegate(typeof(MakeSymbolicLink), file);
                        doMakeSymbolicLink(symlinkValue, cancellable);
                        return true;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.Boolean);
                }

                return unmanagedMakeSymbolicLink;
            }
        }

        public delegate void Copy(GISharp.Lib.Gio.IFile destination, GISharp.Lib.Gio.FileCopyFlags flags, GISharp.Lib.Gio.FileProgressCallback progressCallback, GISharp.Lib.Gio.Cancellable cancellable = null);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:out */
        public unsafe delegate System.Boolean UnmanagedCopy(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr source,
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr destination,
/* <type name="FileCopyFlags" type="GFileCopyFlags" managed-name="FileCopyFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileCopyFlags flags,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="FileProgressCallback" type="GFileProgressCallback" managed-name="UnmanagedFileProgressCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:call closure:5 direction:in */
GISharp.Lib.Gio.UnmanagedFileProgressCallback progressCallback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr progressCallbackData,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
System.IntPtr* error);

        /// <summary>
        /// Factory for creating <see cref="Copy"/> methods.
        /// </summary>
        public static class CopyFactory
        {
            public static unsafe UnmanagedCopy Create(System.Reflection.MethodInfo methodInfo)
            {
                System.Boolean unmanagedCopy(System.IntPtr source_, System.IntPtr destination_, GISharp.Lib.Gio.FileCopyFlags flags_, System.IntPtr cancellable_, GISharp.Lib.Gio.UnmanagedFileProgressCallback progressCallback_, System.IntPtr progressCallbackData_, System.IntPtr* error_)
                {
                    try
                    {
                        var source = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(source_, GISharp.Runtime.Transfer.None);
                        var destination = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(destination_, GISharp.Runtime.Transfer.None);
                        var flags = (GISharp.Lib.Gio.FileCopyFlags)flags_;
                        var progressCallback = GISharp.Lib.Gio.FileProgressCallbackFactory.Create(progressCallback_, progressCallbackData_);
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doCopy = (Copy)methodInfo.CreateDelegate(typeof(Copy), source);
                        doCopy(destination, flags, progressCallback, cancellable);
                        return true;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.Boolean);
                }

                return unmanagedCopy;
            }
        }

        public delegate void CopyAsync(GISharp.Lib.Gio.IFile destination, GISharp.Lib.Gio.FileCopyFlags flags, System.Int32 ioPriority, GISharp.Lib.Gio.FileProgressCallback progressCallback, GISharp.Lib.Gio.AsyncReadyCallback callback, GISharp.Lib.Gio.Cancellable cancellable = null);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        public unsafe delegate void UnmanagedCopyAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr source,
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr destination,
/* <type name="FileCopyFlags" type="GFileCopyFlags" managed-name="FileCopyFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileCopyFlags flags,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
System.Int32 ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="FileProgressCallback" type="GFileProgressCallback" managed-name="UnmanagedFileProgressCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:notified closure:6 direction:in */
GISharp.Lib.Gio.UnmanagedFileProgressCallback progressCallback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:5 direction:in */
System.IntPtr progressCallbackData,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="UnmanagedAsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:8 direction:in */
GISharp.Lib.Gio.UnmanagedAsyncReadyCallback callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:7 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Factory for creating <see cref="CopyAsync"/> methods.
        /// </summary>
        public static class CopyAsyncFactory
        {
            public static unsafe UnmanagedCopyAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedCopyAsync(System.IntPtr source_, System.IntPtr destination_, GISharp.Lib.Gio.FileCopyFlags flags_, System.Int32 ioPriority_, System.IntPtr cancellable_, GISharp.Lib.Gio.UnmanagedFileProgressCallback progressCallback_, System.IntPtr progressCallbackData_, GISharp.Lib.Gio.UnmanagedAsyncReadyCallback callback_, System.IntPtr userData_)
                {
                    try
                    {
                        var source = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(source_, GISharp.Runtime.Transfer.None);
                        var destination = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(destination_, GISharp.Runtime.Transfer.None);
                        var flags = (GISharp.Lib.Gio.FileCopyFlags)flags_;
                        var ioPriority = (System.Int32)ioPriority_;
                        var progressCallback = GISharp.Lib.Gio.FileProgressCallbackFactory.Create(progressCallback_, progressCallbackData_);
                        var callback = GISharp.Lib.Gio.AsyncReadyCallbackFactory.Create(callback_, userData_);
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doCopyAsync = (CopyAsync)methodInfo.CreateDelegate(typeof(CopyAsync), source);
                        doCopyAsync(destination, flags, ioPriority, progressCallback, callback, cancellable);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }
                }

                return unmanagedCopyAsync;
            }
        }

        public delegate void CopyFinish(GISharp.Lib.Gio.IAsyncResult res);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:out */
        public unsafe delegate System.Boolean UnmanagedCopyFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr res,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
System.IntPtr* error);

        /// <summary>
        /// Factory for creating <see cref="CopyFinish"/> methods.
        /// </summary>
        public static class CopyFinishFactory
        {
            public static unsafe UnmanagedCopyFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                System.Boolean unmanagedCopyFinish(System.IntPtr file_, System.IntPtr res_, System.IntPtr* error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var res = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance(res_, GISharp.Runtime.Transfer.None);
                        var doCopyFinish = (CopyFinish)methodInfo.CreateDelegate(typeof(CopyFinish), file);
                        doCopyFinish(res);
                        return true;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.Boolean);
                }

                return unmanagedCopyFinish;
            }
        }

        public delegate void Move(GISharp.Lib.Gio.IFile destination, GISharp.Lib.Gio.FileCopyFlags flags, GISharp.Lib.Gio.FileProgressCallback progressCallback, GISharp.Lib.Gio.Cancellable cancellable = null);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:out */
        public unsafe delegate System.Boolean UnmanagedMove(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr source,
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr destination,
/* <type name="FileCopyFlags" type="GFileCopyFlags" managed-name="FileCopyFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileCopyFlags flags,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="FileProgressCallback" type="GFileProgressCallback" managed-name="UnmanagedFileProgressCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:call closure:5 direction:in */
GISharp.Lib.Gio.UnmanagedFileProgressCallback progressCallback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr progressCallbackData,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
System.IntPtr* error);

        /// <summary>
        /// Factory for creating <see cref="Move"/> methods.
        /// </summary>
        public static class MoveFactory
        {
            public static unsafe UnmanagedMove Create(System.Reflection.MethodInfo methodInfo)
            {
                System.Boolean unmanagedMove(System.IntPtr source_, System.IntPtr destination_, GISharp.Lib.Gio.FileCopyFlags flags_, System.IntPtr cancellable_, GISharp.Lib.Gio.UnmanagedFileProgressCallback progressCallback_, System.IntPtr progressCallbackData_, System.IntPtr* error_)
                {
                    try
                    {
                        var source = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(source_, GISharp.Runtime.Transfer.None);
                        var destination = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(destination_, GISharp.Runtime.Transfer.None);
                        var flags = (GISharp.Lib.Gio.FileCopyFlags)flags_;
                        var progressCallback = GISharp.Lib.Gio.FileProgressCallbackFactory.Create(progressCallback_, progressCallbackData_);
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doMove = (Move)methodInfo.CreateDelegate(typeof(Move), source);
                        doMove(destination, flags, progressCallback, cancellable);
                        return true;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.Boolean);
                }

                return unmanagedMove;
            }
        }

        public delegate GISharp.Lib.Gio.IFile MountMountableFinish(GISharp.Lib.Gio.IAsyncResult result);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedMountMountableFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr result,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
System.IntPtr* error);

        /// <summary>
        /// Factory for creating <see cref="MountMountableFinish"/> methods.
        /// </summary>
        public static class MountMountableFinishFactory
        {
            public static unsafe UnmanagedMountMountableFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedMountMountableFinish(System.IntPtr file_, System.IntPtr result_, System.IntPtr* error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance(result_, GISharp.Runtime.Transfer.None);
                        var doMountMountableFinish = (MountMountableFinish)methodInfo.CreateDelegate(typeof(MountMountableFinish), file);
                        var ret = doMountMountableFinish(result);
                        var ret_ = ret?.Take() ?? throw new System.ArgumentNullException(nameof(ret));
                        return ret_;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedMountMountableFinish;
            }
        }

        public delegate void UnmountMountableFinish(GISharp.Lib.Gio.IAsyncResult result);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:out */
        public unsafe delegate System.Boolean UnmanagedUnmountMountableFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr result,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
System.IntPtr* error);

        /// <summary>
        /// Factory for creating <see cref="UnmountMountableFinish"/> methods.
        /// </summary>
        public static class UnmountMountableFinishFactory
        {
            public static unsafe UnmanagedUnmountMountableFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                System.Boolean unmanagedUnmountMountableFinish(System.IntPtr file_, System.IntPtr result_, System.IntPtr* error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance(result_, GISharp.Runtime.Transfer.None);
                        var doUnmountMountableFinish = (UnmountMountableFinish)methodInfo.CreateDelegate(typeof(UnmountMountableFinish), file);
                        doUnmountMountableFinish(result);
                        return true;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.Boolean);
                }

                return unmanagedUnmountMountableFinish;
            }
        }

        public delegate void EjectMountableFinish(GISharp.Lib.Gio.IAsyncResult result);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:out */
        public unsafe delegate System.Boolean UnmanagedEjectMountableFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr result,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
System.IntPtr* error);

        /// <summary>
        /// Factory for creating <see cref="EjectMountableFinish"/> methods.
        /// </summary>
        public static class EjectMountableFinishFactory
        {
            public static unsafe UnmanagedEjectMountableFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                System.Boolean unmanagedEjectMountableFinish(System.IntPtr file_, System.IntPtr result_, System.IntPtr* error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance(result_, GISharp.Runtime.Transfer.None);
                        var doEjectMountableFinish = (EjectMountableFinish)methodInfo.CreateDelegate(typeof(EjectMountableFinish), file);
                        doEjectMountableFinish(result);
                        return true;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.Boolean);
                }

                return unmanagedEjectMountableFinish;
            }
        }

        public delegate void MountEnclosingVolumeFinish(GISharp.Lib.Gio.IAsyncResult result);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:out */
        public unsafe delegate System.Boolean UnmanagedMountEnclosingVolumeFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr location,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr result,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
System.IntPtr* error);

        /// <summary>
        /// Factory for creating <see cref="MountEnclosingVolumeFinish"/> methods.
        /// </summary>
        public static class MountEnclosingVolumeFinishFactory
        {
            public static unsafe UnmanagedMountEnclosingVolumeFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                System.Boolean unmanagedMountEnclosingVolumeFinish(System.IntPtr location_, System.IntPtr result_, System.IntPtr* error_)
                {
                    try
                    {
                        var location = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(location_, GISharp.Runtime.Transfer.None);
                        var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance(result_, GISharp.Runtime.Transfer.None);
                        var doMountEnclosingVolumeFinish = (MountEnclosingVolumeFinish)methodInfo.CreateDelegate(typeof(MountEnclosingVolumeFinish), location);
                        doMountEnclosingVolumeFinish(result);
                        return true;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.Boolean);
                }

                return unmanagedMountEnclosingVolumeFinish;
            }
        }

        public delegate GISharp.Lib.Gio.FileIOStream OpenReadwrite(GISharp.Lib.Gio.Cancellable cancellable = null);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileIOStream" type="GFileIOStream*" managed-name="FileIOStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedOpenReadwrite(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
System.IntPtr* error);

        /// <summary>
        /// Factory for creating <see cref="OpenReadwrite"/> methods.
        /// </summary>
        public static class OpenReadwriteFactory
        {
            public static unsafe UnmanagedOpenReadwrite Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedOpenReadwrite(System.IntPtr file_, System.IntPtr cancellable_, System.IntPtr* error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doOpenReadwrite = (OpenReadwrite)methodInfo.CreateDelegate(typeof(OpenReadwrite), file);
                        var ret = doOpenReadwrite(cancellable);
                        var ret_ = ret?.Take() ?? throw new System.ArgumentNullException(nameof(ret));
                        return ret_;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedOpenReadwrite;
            }
        }

        public delegate void OpenReadwriteAsync(System.Int32 ioPriority, GISharp.Lib.Gio.AsyncReadyCallback callback, GISharp.Lib.Gio.Cancellable cancellable = null);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        public unsafe delegate void UnmanagedOpenReadwriteAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
System.Int32 ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="UnmanagedAsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:4 direction:in */
GISharp.Lib.Gio.UnmanagedAsyncReadyCallback callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:4 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Factory for creating <see cref="OpenReadwriteAsync"/> methods.
        /// </summary>
        public static class OpenReadwriteAsyncFactory
        {
            public static unsafe UnmanagedOpenReadwriteAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedOpenReadwriteAsync(System.IntPtr file_, System.Int32 ioPriority_, System.IntPtr cancellable_, GISharp.Lib.Gio.UnmanagedAsyncReadyCallback callback_, System.IntPtr userData_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var ioPriority = (System.Int32)ioPriority_;
                        var callback = GISharp.Lib.Gio.AsyncReadyCallbackFactory.Create(callback_, userData_);
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doOpenReadwriteAsync = (OpenReadwriteAsync)methodInfo.CreateDelegate(typeof(OpenReadwriteAsync), file);
                        doOpenReadwriteAsync(ioPriority, callback, cancellable);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }
                }

                return unmanagedOpenReadwriteAsync;
            }
        }

        public delegate GISharp.Lib.Gio.FileIOStream OpenReadwriteFinish(GISharp.Lib.Gio.IAsyncResult res);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileIOStream" type="GFileIOStream*" managed-name="FileIOStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedOpenReadwriteFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr res,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
System.IntPtr* error);

        /// <summary>
        /// Factory for creating <see cref="OpenReadwriteFinish"/> methods.
        /// </summary>
        public static class OpenReadwriteFinishFactory
        {
            public static unsafe UnmanagedOpenReadwriteFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedOpenReadwriteFinish(System.IntPtr file_, System.IntPtr res_, System.IntPtr* error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var res = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance(res_, GISharp.Runtime.Transfer.None);
                        var doOpenReadwriteFinish = (OpenReadwriteFinish)methodInfo.CreateDelegate(typeof(OpenReadwriteFinish), file);
                        var ret = doOpenReadwriteFinish(res);
                        var ret_ = ret?.Take() ?? throw new System.ArgumentNullException(nameof(ret));
                        return ret_;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedOpenReadwriteFinish;
            }
        }

        public delegate GISharp.Lib.Gio.FileIOStream CreateReadwrite(GISharp.Lib.Gio.FileCreateFlags flags, GISharp.Lib.Gio.Cancellable cancellable = null);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileIOStream" type="GFileIOStream*" managed-name="FileIOStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedCreateReadwrite(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="FileCreateFlags" type="GFileCreateFlags" managed-name="FileCreateFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileCreateFlags flags,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
System.IntPtr* error);

        /// <summary>
        /// Factory for creating <see cref="CreateReadwrite"/> methods.
        /// </summary>
        public static class CreateReadwriteFactory
        {
            public static unsafe UnmanagedCreateReadwrite Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedCreateReadwrite(System.IntPtr file_, GISharp.Lib.Gio.FileCreateFlags flags_, System.IntPtr cancellable_, System.IntPtr* error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var flags = (GISharp.Lib.Gio.FileCreateFlags)flags_;
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doCreateReadwrite = (CreateReadwrite)methodInfo.CreateDelegate(typeof(CreateReadwrite), file);
                        var ret = doCreateReadwrite(flags, cancellable);
                        var ret_ = ret?.Take() ?? throw new System.ArgumentNullException(nameof(ret));
                        return ret_;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedCreateReadwrite;
            }
        }

        public delegate void CreateReadwriteAsync(GISharp.Lib.Gio.FileCreateFlags flags, System.Int32 ioPriority, GISharp.Lib.Gio.AsyncReadyCallback callback, GISharp.Lib.Gio.Cancellable cancellable = null);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        public unsafe delegate void UnmanagedCreateReadwriteAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="FileCreateFlags" type="GFileCreateFlags" managed-name="FileCreateFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileCreateFlags flags,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
System.Int32 ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="UnmanagedAsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:5 direction:in */
GISharp.Lib.Gio.UnmanagedAsyncReadyCallback callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:5 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Factory for creating <see cref="CreateReadwriteAsync"/> methods.
        /// </summary>
        public static class CreateReadwriteAsyncFactory
        {
            public static unsafe UnmanagedCreateReadwriteAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedCreateReadwriteAsync(System.IntPtr file_, GISharp.Lib.Gio.FileCreateFlags flags_, System.Int32 ioPriority_, System.IntPtr cancellable_, GISharp.Lib.Gio.UnmanagedAsyncReadyCallback callback_, System.IntPtr userData_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var flags = (GISharp.Lib.Gio.FileCreateFlags)flags_;
                        var ioPriority = (System.Int32)ioPriority_;
                        var callback = GISharp.Lib.Gio.AsyncReadyCallbackFactory.Create(callback_, userData_);
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doCreateReadwriteAsync = (CreateReadwriteAsync)methodInfo.CreateDelegate(typeof(CreateReadwriteAsync), file);
                        doCreateReadwriteAsync(flags, ioPriority, callback, cancellable);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }
                }

                return unmanagedCreateReadwriteAsync;
            }
        }

        public delegate GISharp.Lib.Gio.FileIOStream CreateReadwriteFinish(GISharp.Lib.Gio.IAsyncResult res);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileIOStream" type="GFileIOStream*" managed-name="FileIOStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedCreateReadwriteFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr res,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
System.IntPtr* error);

        /// <summary>
        /// Factory for creating <see cref="CreateReadwriteFinish"/> methods.
        /// </summary>
        public static class CreateReadwriteFinishFactory
        {
            public static unsafe UnmanagedCreateReadwriteFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedCreateReadwriteFinish(System.IntPtr file_, System.IntPtr res_, System.IntPtr* error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var res = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance(res_, GISharp.Runtime.Transfer.None);
                        var doCreateReadwriteFinish = (CreateReadwriteFinish)methodInfo.CreateDelegate(typeof(CreateReadwriteFinish), file);
                        var ret = doCreateReadwriteFinish(res);
                        var ret_ = ret?.Take() ?? throw new System.ArgumentNullException(nameof(ret));
                        return ret_;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedCreateReadwriteFinish;
            }
        }

        public delegate GISharp.Lib.Gio.FileIOStream ReplaceReadwrite(GISharp.Lib.GLib.UnownedUtf8 etag, System.Boolean makeBackup, GISharp.Lib.Gio.FileCreateFlags flags, GISharp.Lib.Gio.Cancellable cancellable = null);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileIOStream" type="GFileIOStream*" managed-name="FileIOStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedReplaceReadwrite(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr etag,
/* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
/* transfer-ownership:none direction:in */
System.Boolean makeBackup,
/* <type name="FileCreateFlags" type="GFileCreateFlags" managed-name="FileCreateFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileCreateFlags flags,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
System.IntPtr* error);

        /// <summary>
        /// Factory for creating <see cref="ReplaceReadwrite"/> methods.
        /// </summary>
        public static class ReplaceReadwriteFactory
        {
            public static unsafe UnmanagedReplaceReadwrite Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedReplaceReadwrite(System.IntPtr file_, System.IntPtr etag_, System.Boolean makeBackup_, GISharp.Lib.Gio.FileCreateFlags flags_, System.IntPtr cancellable_, System.IntPtr* error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var etag = new GISharp.Lib.GLib.UnownedUtf8(etag_, -1);
                        var makeBackup = (System.Boolean)makeBackup_;
                        var flags = (GISharp.Lib.Gio.FileCreateFlags)flags_;
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doReplaceReadwrite = (ReplaceReadwrite)methodInfo.CreateDelegate(typeof(ReplaceReadwrite), file);
                        var ret = doReplaceReadwrite(etag, makeBackup, flags, cancellable);
                        var ret_ = ret?.Take() ?? throw new System.ArgumentNullException(nameof(ret));
                        return ret_;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedReplaceReadwrite;
            }
        }

        public delegate void ReplaceReadwriteAsync(GISharp.Lib.GLib.UnownedUtf8 etag, System.Boolean makeBackup, GISharp.Lib.Gio.FileCreateFlags flags, System.Int32 ioPriority, GISharp.Lib.Gio.AsyncReadyCallback callback, GISharp.Lib.Gio.Cancellable cancellable = null);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        public unsafe delegate void UnmanagedReplaceReadwriteAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr etag,
/* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
/* transfer-ownership:none direction:in */
System.Boolean makeBackup,
/* <type name="FileCreateFlags" type="GFileCreateFlags" managed-name="FileCreateFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileCreateFlags flags,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
System.Int32 ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="UnmanagedAsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:7 direction:in */
GISharp.Lib.Gio.UnmanagedAsyncReadyCallback callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:7 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Factory for creating <see cref="ReplaceReadwriteAsync"/> methods.
        /// </summary>
        public static class ReplaceReadwriteAsyncFactory
        {
            public static unsafe UnmanagedReplaceReadwriteAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedReplaceReadwriteAsync(System.IntPtr file_, System.IntPtr etag_, System.Boolean makeBackup_, GISharp.Lib.Gio.FileCreateFlags flags_, System.Int32 ioPriority_, System.IntPtr cancellable_, GISharp.Lib.Gio.UnmanagedAsyncReadyCallback callback_, System.IntPtr userData_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var etag = new GISharp.Lib.GLib.UnownedUtf8(etag_, -1);
                        var makeBackup = (System.Boolean)makeBackup_;
                        var flags = (GISharp.Lib.Gio.FileCreateFlags)flags_;
                        var ioPriority = (System.Int32)ioPriority_;
                        var callback = GISharp.Lib.Gio.AsyncReadyCallbackFactory.Create(callback_, userData_);
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doReplaceReadwriteAsync = (ReplaceReadwriteAsync)methodInfo.CreateDelegate(typeof(ReplaceReadwriteAsync), file);
                        doReplaceReadwriteAsync(etag, makeBackup, flags, ioPriority, callback, cancellable);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }
                }

                return unmanagedReplaceReadwriteAsync;
            }
        }

        public delegate GISharp.Lib.Gio.FileIOStream ReplaceReadwriteFinish(GISharp.Lib.Gio.IAsyncResult res);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileIOStream" type="GFileIOStream*" managed-name="FileIOStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedReplaceReadwriteFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr res,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
System.IntPtr* error);

        /// <summary>
        /// Factory for creating <see cref="ReplaceReadwriteFinish"/> methods.
        /// </summary>
        public static class ReplaceReadwriteFinishFactory
        {
            public static unsafe UnmanagedReplaceReadwriteFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedReplaceReadwriteFinish(System.IntPtr file_, System.IntPtr res_, System.IntPtr* error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var res = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance(res_, GISharp.Runtime.Transfer.None);
                        var doReplaceReadwriteFinish = (ReplaceReadwriteFinish)methodInfo.CreateDelegate(typeof(ReplaceReadwriteFinish), file);
                        var ret = doReplaceReadwriteFinish(res);
                        var ret_ = ret?.Take() ?? throw new System.ArgumentNullException(nameof(ret));
                        return ret_;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedReplaceReadwriteFinish;
            }
        }

        public delegate void StartMountableFinish(GISharp.Lib.Gio.IAsyncResult result);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:out */
        public unsafe delegate System.Boolean UnmanagedStartMountableFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr result,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
System.IntPtr* error);

        /// <summary>
        /// Factory for creating <see cref="StartMountableFinish"/> methods.
        /// </summary>
        public static class StartMountableFinishFactory
        {
            public static unsafe UnmanagedStartMountableFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                System.Boolean unmanagedStartMountableFinish(System.IntPtr file_, System.IntPtr result_, System.IntPtr* error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance(result_, GISharp.Runtime.Transfer.None);
                        var doStartMountableFinish = (StartMountableFinish)methodInfo.CreateDelegate(typeof(StartMountableFinish), file);
                        doStartMountableFinish(result);
                        return true;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.Boolean);
                }

                return unmanagedStartMountableFinish;
            }
        }

        public delegate void StopMountableFinish(GISharp.Lib.Gio.IAsyncResult result);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:out */
        public unsafe delegate System.Boolean UnmanagedStopMountableFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr result,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
System.IntPtr* error);

        /// <summary>
        /// Factory for creating <see cref="StopMountableFinish"/> methods.
        /// </summary>
        public static class StopMountableFinishFactory
        {
            public static unsafe UnmanagedStopMountableFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                System.Boolean unmanagedStopMountableFinish(System.IntPtr file_, System.IntPtr result_, System.IntPtr* error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance(result_, GISharp.Runtime.Transfer.None);
                        var doStopMountableFinish = (StopMountableFinish)methodInfo.CreateDelegate(typeof(StopMountableFinish), file);
                        doStopMountableFinish(result);
                        return true;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.Boolean);
                }

                return unmanagedStopMountableFinish;
            }
        }

        public delegate void UnmountMountableWithOperationFinish(GISharp.Lib.Gio.IAsyncResult result);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:out */
        public unsafe delegate System.Boolean UnmanagedUnmountMountableWithOperationFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr result,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
System.IntPtr* error);

        /// <summary>
        /// Factory for creating <see cref="UnmountMountableWithOperationFinish"/> methods.
        /// </summary>
        public static class UnmountMountableWithOperationFinishFactory
        {
            public static unsafe UnmanagedUnmountMountableWithOperationFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                System.Boolean unmanagedUnmountMountableWithOperationFinish(System.IntPtr file_, System.IntPtr result_, System.IntPtr* error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance(result_, GISharp.Runtime.Transfer.None);
                        var doUnmountMountableWithOperationFinish = (UnmountMountableWithOperationFinish)methodInfo.CreateDelegate(typeof(UnmountMountableWithOperationFinish), file);
                        doUnmountMountableWithOperationFinish(result);
                        return true;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.Boolean);
                }

                return unmanagedUnmountMountableWithOperationFinish;
            }
        }

        public delegate void EjectMountableWithOperationFinish(GISharp.Lib.Gio.IAsyncResult result);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:out */
        public unsafe delegate System.Boolean UnmanagedEjectMountableWithOperationFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr result,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
System.IntPtr* error);

        /// <summary>
        /// Factory for creating <see cref="EjectMountableWithOperationFinish"/> methods.
        /// </summary>
        public static class EjectMountableWithOperationFinishFactory
        {
            public static unsafe UnmanagedEjectMountableWithOperationFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                System.Boolean unmanagedEjectMountableWithOperationFinish(System.IntPtr file_, System.IntPtr result_, System.IntPtr* error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance(result_, GISharp.Runtime.Transfer.None);
                        var doEjectMountableWithOperationFinish = (EjectMountableWithOperationFinish)methodInfo.CreateDelegate(typeof(EjectMountableWithOperationFinish), file);
                        doEjectMountableWithOperationFinish(result);
                        return true;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.Boolean);
                }

                return unmanagedEjectMountableWithOperationFinish;
            }
        }

        public delegate void PollMountable(GISharp.Lib.Gio.AsyncReadyCallback callback, GISharp.Lib.Gio.Cancellable cancellable = null);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        public unsafe delegate void UnmanagedPollMountable(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="UnmanagedAsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:3 direction:in */
GISharp.Lib.Gio.UnmanagedAsyncReadyCallback callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:3 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Factory for creating <see cref="PollMountable"/> methods.
        /// </summary>
        public static class PollMountableFactory
        {
            public static unsafe UnmanagedPollMountable Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedPollMountable(System.IntPtr file_, System.IntPtr cancellable_, GISharp.Lib.Gio.UnmanagedAsyncReadyCallback callback_, System.IntPtr userData_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var callback = GISharp.Lib.Gio.AsyncReadyCallbackFactory.Create(callback_, userData_);
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doPollMountable = (PollMountable)methodInfo.CreateDelegate(typeof(PollMountable), file);
                        doPollMountable(callback, cancellable);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }
                }

                return unmanagedPollMountable;
            }
        }

        public delegate void PollMountableFinish(GISharp.Lib.Gio.IAsyncResult result);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:out */
        public unsafe delegate System.Boolean UnmanagedPollMountableFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr result,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
System.IntPtr* error);

        /// <summary>
        /// Factory for creating <see cref="PollMountableFinish"/> methods.
        /// </summary>
        public static class PollMountableFinishFactory
        {
            public static unsafe UnmanagedPollMountableFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                System.Boolean unmanagedPollMountableFinish(System.IntPtr file_, System.IntPtr result_, System.IntPtr* error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance(result_, GISharp.Runtime.Transfer.None);
                        var doPollMountableFinish = (PollMountableFinish)methodInfo.CreateDelegate(typeof(PollMountableFinish), file);
                        doPollMountableFinish(result);
                        return true;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.Boolean);
                }

                return unmanagedPollMountableFinish;
            }
        }

        public delegate void MeasureDiskUsageFinish(GISharp.Lib.Gio.IAsyncResult result, out System.UInt64 diskUsage, out System.UInt64 numDirs, out System.UInt64 numFiles);

        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:out */
        public unsafe delegate System.Boolean UnmanagedMeasureDiskUsageFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr result,
/* <type name="guint64" type="guint64*" managed-name="System.UInt64" is-pointer="1" /> */
/* direction:out caller-allocates:0 transfer-ownership:full optional:1 allow-none:1 */
System.UInt64* diskUsage,
/* <type name="guint64" type="guint64*" managed-name="System.UInt64" is-pointer="1" /> */
/* direction:out caller-allocates:0 transfer-ownership:full optional:1 allow-none:1 */
System.UInt64* numDirs,
/* <type name="guint64" type="guint64*" managed-name="System.UInt64" is-pointer="1" /> */
/* direction:out caller-allocates:0 transfer-ownership:full optional:1 allow-none:1 */
System.UInt64* numFiles,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
System.IntPtr* error);

        /// <summary>
        /// Factory for creating <see cref="MeasureDiskUsageFinish"/> methods.
        /// </summary>
        public static class MeasureDiskUsageFinishFactory
        {
            public static unsafe UnmanagedMeasureDiskUsageFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                System.Boolean unmanagedMeasureDiskUsageFinish(System.IntPtr file_, System.IntPtr result_, System.UInt64* diskUsage_, System.UInt64* numDirs_, System.UInt64* numFiles_, System.IntPtr* error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None);
                        var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance(result_, GISharp.Runtime.Transfer.None);
                        var doMeasureDiskUsageFinish = (MeasureDiskUsageFinish)methodInfo.CreateDelegate(typeof(MeasureDiskUsageFinish), file);
                        doMeasureDiskUsageFinish(result,out var diskUsage,out var numDirs,out var numFiles);
                        *diskUsage_ = (System.UInt64)diskUsage;
                        *numDirs_ = (System.UInt64)numDirs;
                        *numFiles_ = (System.UInt64)numFiles;
                        return true;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.Boolean);
                }

                return unmanagedMeasureDiskUsageFinish;
            }
        }

        public FileIface(System.IntPtr handle, GISharp.Runtime.Transfer ownership) : base(handle, ownership)
        {
        }
    }
}