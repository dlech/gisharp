// ATTENTION: This file is automatically generated. Do not edit manually.
#nullable enable
namespace GISharp.Lib.Gio
{
    /// <include file="FileIface.xmldoc" path="declaration/member[@name='FileIface']/*" />
    public sealed class FileIface : GISharp.Lib.GObject.TypeInterface
    {
        /// <summary>
        /// Unmanaged data structure
        /// </summary>
        unsafe new struct Struct
        {
#pragma warning disable CS0649
            /// <include file="FileIface.xmldoc" path="declaration/member[@name='GIface']/*" />
            public GISharp.Lib.GObject.TypeInterface.Struct GIface;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='Dup']/*" />
            public System.IntPtr Dup;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='Hash']/*" />
            public System.IntPtr Hash;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='Equal']/*" />
            public System.IntPtr Equal;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='IsNative']/*" />
            public System.IntPtr IsNative;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='HasUriScheme']/*" />
            public System.IntPtr HasUriScheme;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='GetUriScheme']/*" />
            public System.IntPtr GetUriScheme;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='GetBasename']/*" />
            public System.IntPtr GetBasename;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='GetPath']/*" />
            public System.IntPtr GetPath;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='GetUri']/*" />
            public System.IntPtr GetUri;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='GetParseName']/*" />
            public System.IntPtr GetParseName;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='GetParent']/*" />
            public System.IntPtr GetParent;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='PrefixMatches']/*" />
            public System.IntPtr PrefixMatches;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='GetRelativePath']/*" />
            public System.IntPtr GetRelativePath;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='ResolveRelativePath']/*" />
            public System.IntPtr ResolveRelativePath;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='GetChildForDisplayName']/*" />
            public System.IntPtr GetChildForDisplayName;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='EnumerateChildren']/*" />
            public System.IntPtr EnumerateChildren;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='EnumerateChildrenAsync']/*" />
            public System.IntPtr EnumerateChildrenAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='EnumerateChildrenFinish']/*" />
            public System.IntPtr EnumerateChildrenFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='QueryInfo']/*" />
            public System.IntPtr QueryInfo;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='QueryInfoAsync']/*" />
            public System.IntPtr QueryInfoAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='QueryInfoFinish']/*" />
            public System.IntPtr QueryInfoFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='QueryFilesystemInfo']/*" />
            public System.IntPtr QueryFilesystemInfo;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='QueryFilesystemInfoAsync']/*" />
            public System.IntPtr QueryFilesystemInfoAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='QueryFilesystemInfoFinish']/*" />
            public System.IntPtr QueryFilesystemInfoFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='FindEnclosingMount']/*" />
            public System.IntPtr FindEnclosingMount;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='FindEnclosingMountAsync']/*" />
            public System.IntPtr FindEnclosingMountAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='FindEnclosingMountFinish']/*" />
            public System.IntPtr FindEnclosingMountFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='SetDisplayName']/*" />
            public System.IntPtr SetDisplayName;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='SetDisplayNameAsync']/*" />
            public System.IntPtr SetDisplayNameAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='SetDisplayNameFinish']/*" />
            public System.IntPtr SetDisplayNameFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='QuerySettableAttributes']/*" />
            public System.IntPtr QuerySettableAttributes;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='QuerySettableAttributesAsync']/*" />
            public System.IntPtr QuerySettableAttributesAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='QuerySettableAttributesFinish']/*" />
            public System.IntPtr QuerySettableAttributesFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='QueryWritableNamespaces']/*" />
            public System.IntPtr QueryWritableNamespaces;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='QueryWritableNamespacesAsync']/*" />
            public System.IntPtr QueryWritableNamespacesAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='QueryWritableNamespacesFinish']/*" />
            public System.IntPtr QueryWritableNamespacesFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='SetAttribute']/*" />
            public System.IntPtr SetAttribute;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='SetAttributesFromInfo']/*" />
            public System.IntPtr SetAttributesFromInfo;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='SetAttributesAsync']/*" />
            public System.IntPtr SetAttributesAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='SetAttributesFinish']/*" />
            public System.IntPtr SetAttributesFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='ReadFn']/*" />
            public System.IntPtr ReadFn;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='ReadAsync']/*" />
            public System.IntPtr ReadAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='ReadFinish']/*" />
            public System.IntPtr ReadFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='AppendTo']/*" />
            public System.IntPtr AppendTo;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='AppendToAsync']/*" />
            public System.IntPtr AppendToAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='AppendToFinish']/*" />
            public System.IntPtr AppendToFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='Create']/*" />
            public System.IntPtr Create;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='CreateAsync']/*" />
            public System.IntPtr CreateAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='CreateFinish']/*" />
            public System.IntPtr CreateFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='Replace']/*" />
            public System.IntPtr Replace;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='ReplaceAsync']/*" />
            public System.IntPtr ReplaceAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='ReplaceFinish']/*" />
            public System.IntPtr ReplaceFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='DeleteFile']/*" />
            public System.IntPtr DeleteFile;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='DeleteFileAsync']/*" />
            public System.IntPtr DeleteFileAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='DeleteFileFinish']/*" />
            public System.IntPtr DeleteFileFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='Trash']/*" />
            public System.IntPtr Trash;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='TrashAsync']/*" />
            public System.IntPtr TrashAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='TrashFinish']/*" />
            public System.IntPtr TrashFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='MakeDirectory']/*" />
            public System.IntPtr MakeDirectory;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='MakeDirectoryAsync']/*" />
            public System.IntPtr MakeDirectoryAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='MakeDirectoryFinish']/*" />
            public System.IntPtr MakeDirectoryFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='MakeSymbolicLink']/*" />
            public System.IntPtr MakeSymbolicLink;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='MakeSymbolicLinkAsync']/*" />
            public System.IntPtr MakeSymbolicLinkAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='MakeSymbolicLinkFinish']/*" />
            public System.IntPtr MakeSymbolicLinkFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='Copy']/*" />
            public System.IntPtr Copy;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='CopyAsync']/*" />
            public System.IntPtr CopyAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='CopyFinish']/*" />
            public System.IntPtr CopyFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='Move']/*" />
            public System.IntPtr Move;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='MoveAsync']/*" />
            public System.IntPtr MoveAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='MoveFinish']/*" />
            public System.IntPtr MoveFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='MountMountable']/*" />
            public System.IntPtr MountMountable;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='MountMountableFinish']/*" />
            public System.IntPtr MountMountableFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmountMountable']/*" />
            public System.IntPtr UnmountMountable;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmountMountableFinish']/*" />
            public System.IntPtr UnmountMountableFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='EjectMountable']/*" />
            public System.IntPtr EjectMountable;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='EjectMountableFinish']/*" />
            public System.IntPtr EjectMountableFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='MountEnclosingVolume']/*" />
            public System.IntPtr MountEnclosingVolume;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='MountEnclosingVolumeFinish']/*" />
            public System.IntPtr MountEnclosingVolumeFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='MonitorDir']/*" />
            public System.IntPtr MonitorDir;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='MonitorFile']/*" />
            public System.IntPtr MonitorFile;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='OpenReadwrite']/*" />
            public System.IntPtr OpenReadwrite;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='OpenReadwriteAsync']/*" />
            public System.IntPtr OpenReadwriteAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='OpenReadwriteFinish']/*" />
            public System.IntPtr OpenReadwriteFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='CreateReadwrite']/*" />
            public System.IntPtr CreateReadwrite;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='CreateReadwriteAsync']/*" />
            public System.IntPtr CreateReadwriteAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='CreateReadwriteFinish']/*" />
            public System.IntPtr CreateReadwriteFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='ReplaceReadwrite']/*" />
            public System.IntPtr ReplaceReadwrite;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='ReplaceReadwriteAsync']/*" />
            public System.IntPtr ReplaceReadwriteAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='ReplaceReadwriteFinish']/*" />
            public System.IntPtr ReplaceReadwriteFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='StartMountable']/*" />
            public System.IntPtr StartMountable;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='StartMountableFinish']/*" />
            public System.IntPtr StartMountableFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='StopMountable']/*" />
            public System.IntPtr StopMountable;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='StopMountableFinish']/*" />
            public System.IntPtr StopMountableFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='SupportsThreadContexts']/*" />
            public GISharp.Runtime.Boolean SupportsThreadContexts;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmountMountableWithOperation']/*" />
            public System.IntPtr UnmountMountableWithOperation;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmountMountableWithOperationFinish']/*" />
            public System.IntPtr UnmountMountableWithOperationFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='EjectMountableWithOperation']/*" />
            public System.IntPtr EjectMountableWithOperation;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='EjectMountableWithOperationFinish']/*" />
            public System.IntPtr EjectMountableWithOperationFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='PollMountable']/*" />
            public System.IntPtr PollMountable;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='PollMountableFinish']/*" />
            public System.IntPtr PollMountableFinish;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='MeasureDiskUsage']/*" />
            public System.IntPtr MeasureDiskUsage;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='MeasureDiskUsageAsync']/*" />
            public System.IntPtr MeasureDiskUsageAsync;

            /// <include file="FileIface.xmldoc" path="declaration/member[@name='MeasureDiskUsageFinish']/*" />
            public System.IntPtr MeasureDiskUsageFinish;
#pragma warning restore CS0649
        }

        static FileIface()
        {
            System.Int32 dupOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.Dup));
            RegisterVirtualMethod(dupOffset, DupMarshal.Create);
            System.Int32 hashOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.Hash));
            RegisterVirtualMethod(hashOffset, HashMarshal.Create);
            System.Int32 equalOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.Equal));
            RegisterVirtualMethod(equalOffset, EqualMarshal.Create);
            System.Int32 isNativeOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.IsNative));
            RegisterVirtualMethod(isNativeOffset, IsNativeMarshal.Create);
            System.Int32 hasUriSchemeOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.HasUriScheme));
            RegisterVirtualMethod(hasUriSchemeOffset, HasUriSchemeMarshal.Create);
            System.Int32 getUriSchemeOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.GetUriScheme));
            RegisterVirtualMethod(getUriSchemeOffset, GetUriSchemeMarshal.Create);
            System.Int32 getBasenameOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.GetBasename));
            RegisterVirtualMethod(getBasenameOffset, GetBasenameMarshal.Create);
            System.Int32 getPathOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.GetPath));
            RegisterVirtualMethod(getPathOffset, GetPathMarshal.Create);
            System.Int32 getUriOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.GetUri));
            RegisterVirtualMethod(getUriOffset, GetUriMarshal.Create);
            System.Int32 getParseNameOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.GetParseName));
            RegisterVirtualMethod(getParseNameOffset, GetParseNameMarshal.Create);
            System.Int32 getParentOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.GetParent));
            RegisterVirtualMethod(getParentOffset, GetParentMarshal.Create);
            System.Int32 prefixMatchesOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.PrefixMatches));
            RegisterVirtualMethod(prefixMatchesOffset, PrefixMatchesMarshal.Create);
            System.Int32 getRelativePathOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.GetRelativePath));
            RegisterVirtualMethod(getRelativePathOffset, GetRelativePathMarshal.Create);
            System.Int32 resolveRelativePathOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.ResolveRelativePath));
            RegisterVirtualMethod(resolveRelativePathOffset, ResolveRelativePathMarshal.Create);
            System.Int32 getChildForDisplayNameOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.GetChildForDisplayName));
            RegisterVirtualMethod(getChildForDisplayNameOffset, GetChildForDisplayNameMarshal.Create);
            System.Int32 enumerateChildrenAsyncOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.EnumerateChildrenAsync));
            RegisterVirtualMethod(enumerateChildrenAsyncOffset, EnumerateChildrenAsyncMarshal.Create);
            System.Int32 queryInfoOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.QueryInfo));
            RegisterVirtualMethod(queryInfoOffset, QueryInfoMarshal.Create);
            System.Int32 queryInfoAsyncOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.QueryInfoAsync));
            RegisterVirtualMethod(queryInfoAsyncOffset, QueryInfoAsyncMarshal.Create);
            System.Int32 queryInfoFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.QueryInfoFinish));
            RegisterVirtualMethod(queryInfoFinishOffset, QueryInfoFinishMarshal.Create);
            System.Int32 queryFilesystemInfoOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.QueryFilesystemInfo));
            RegisterVirtualMethod(queryFilesystemInfoOffset, QueryFilesystemInfoMarshal.Create);
            System.Int32 queryFilesystemInfoAsyncOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.QueryFilesystemInfoAsync));
            RegisterVirtualMethod(queryFilesystemInfoAsyncOffset, QueryFilesystemInfoAsyncMarshal.Create);
            System.Int32 queryFilesystemInfoFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.QueryFilesystemInfoFinish));
            RegisterVirtualMethod(queryFilesystemInfoFinishOffset, QueryFilesystemInfoFinishMarshal.Create);
            System.Int32 findEnclosingMountAsyncOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.FindEnclosingMountAsync));
            RegisterVirtualMethod(findEnclosingMountAsyncOffset, FindEnclosingMountAsyncMarshal.Create);
            System.Int32 setDisplayNameOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.SetDisplayName));
            RegisterVirtualMethod(setDisplayNameOffset, SetDisplayNameMarshal.Create);
            System.Int32 setDisplayNameAsyncOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.SetDisplayNameAsync));
            RegisterVirtualMethod(setDisplayNameAsyncOffset, SetDisplayNameAsyncMarshal.Create);
            System.Int32 setDisplayNameFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.SetDisplayNameFinish));
            RegisterVirtualMethod(setDisplayNameFinishOffset, SetDisplayNameFinishMarshal.Create);
            System.Int32 querySettableAttributesOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.QuerySettableAttributes));
            RegisterVirtualMethod(querySettableAttributesOffset, QuerySettableAttributesMarshal.Create);
            System.Int32 queryWritableNamespacesOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.QueryWritableNamespaces));
            RegisterVirtualMethod(queryWritableNamespacesOffset, QueryWritableNamespacesMarshal.Create);
            System.Int32 setAttributeOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.SetAttribute));
            RegisterVirtualMethod(setAttributeOffset, SetAttributeMarshal.Create);
            System.Int32 setAttributesFromInfoOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.SetAttributesFromInfo));
            RegisterVirtualMethod(setAttributesFromInfoOffset, SetAttributesFromInfoMarshal.Create);
            System.Int32 setAttributesAsyncOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.SetAttributesAsync));
            RegisterVirtualMethod(setAttributesAsyncOffset, SetAttributesAsyncMarshal.Create);
            System.Int32 setAttributesFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.SetAttributesFinish));
            RegisterVirtualMethod(setAttributesFinishOffset, SetAttributesFinishMarshal.Create);
            System.Int32 readFnOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.ReadFn));
            RegisterVirtualMethod(readFnOffset, ReadFnMarshal.Create);
            System.Int32 readAsyncOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.ReadAsync));
            RegisterVirtualMethod(readAsyncOffset, ReadAsyncMarshal.Create);
            System.Int32 readFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.ReadFinish));
            RegisterVirtualMethod(readFinishOffset, ReadFinishMarshal.Create);
            System.Int32 appendToOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.AppendTo));
            RegisterVirtualMethod(appendToOffset, AppendToMarshal.Create);
            System.Int32 appendToAsyncOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.AppendToAsync));
            RegisterVirtualMethod(appendToAsyncOffset, AppendToAsyncMarshal.Create);
            System.Int32 appendToFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.AppendToFinish));
            RegisterVirtualMethod(appendToFinishOffset, AppendToFinishMarshal.Create);
            System.Int32 createOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.Create));
            RegisterVirtualMethod(createOffset, CreateMarshal.Create);
            System.Int32 createAsyncOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.CreateAsync));
            RegisterVirtualMethod(createAsyncOffset, CreateAsyncMarshal.Create);
            System.Int32 createFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.CreateFinish));
            RegisterVirtualMethod(createFinishOffset, CreateFinishMarshal.Create);
            System.Int32 replaceOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.Replace));
            RegisterVirtualMethod(replaceOffset, ReplaceMarshal.Create);
            System.Int32 replaceAsyncOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.ReplaceAsync));
            RegisterVirtualMethod(replaceAsyncOffset, ReplaceAsyncMarshal.Create);
            System.Int32 replaceFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.ReplaceFinish));
            RegisterVirtualMethod(replaceFinishOffset, ReplaceFinishMarshal.Create);
            System.Int32 deleteFileOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.DeleteFile));
            RegisterVirtualMethod(deleteFileOffset, DeleteFileMarshal.Create);
            System.Int32 deleteFileAsyncOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.DeleteFileAsync));
            RegisterVirtualMethod(deleteFileAsyncOffset, DeleteFileAsyncMarshal.Create);
            System.Int32 deleteFileFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.DeleteFileFinish));
            RegisterVirtualMethod(deleteFileFinishOffset, DeleteFileFinishMarshal.Create);
            System.Int32 trashOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.Trash));
            RegisterVirtualMethod(trashOffset, TrashMarshal.Create);
            System.Int32 trashAsyncOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.TrashAsync));
            RegisterVirtualMethod(trashAsyncOffset, TrashAsyncMarshal.Create);
            System.Int32 trashFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.TrashFinish));
            RegisterVirtualMethod(trashFinishOffset, TrashFinishMarshal.Create);
            System.Int32 makeDirectoryOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.MakeDirectory));
            RegisterVirtualMethod(makeDirectoryOffset, MakeDirectoryMarshal.Create);
            System.Int32 makeDirectoryAsyncOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.MakeDirectoryAsync));
            RegisterVirtualMethod(makeDirectoryAsyncOffset, MakeDirectoryAsyncMarshal.Create);
            System.Int32 makeDirectoryFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.MakeDirectoryFinish));
            RegisterVirtualMethod(makeDirectoryFinishOffset, MakeDirectoryFinishMarshal.Create);
            System.Int32 makeSymbolicLinkOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.MakeSymbolicLink));
            RegisterVirtualMethod(makeSymbolicLinkOffset, MakeSymbolicLinkMarshal.Create);
            System.Int32 copyOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.Copy));
            RegisterVirtualMethod(copyOffset, CopyMarshal.Create);
            System.Int32 copyAsyncOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.CopyAsync));
            RegisterVirtualMethod(copyAsyncOffset, CopyAsyncMarshal.Create);
            System.Int32 copyFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.CopyFinish));
            RegisterVirtualMethod(copyFinishOffset, CopyFinishMarshal.Create);
            System.Int32 moveOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.Move));
            RegisterVirtualMethod(moveOffset, MoveMarshal.Create);
            System.Int32 mountMountableFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.MountMountableFinish));
            RegisterVirtualMethod(mountMountableFinishOffset, MountMountableFinishMarshal.Create);
            System.Int32 unmountMountableFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.UnmountMountableFinish));
            RegisterVirtualMethod(unmountMountableFinishOffset, UnmountMountableFinishMarshal.Create);
            System.Int32 ejectMountableFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.EjectMountableFinish));
            RegisterVirtualMethod(ejectMountableFinishOffset, EjectMountableFinishMarshal.Create);
            System.Int32 mountEnclosingVolumeFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.MountEnclosingVolumeFinish));
            RegisterVirtualMethod(mountEnclosingVolumeFinishOffset, MountEnclosingVolumeFinishMarshal.Create);
            System.Int32 openReadwriteOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.OpenReadwrite));
            RegisterVirtualMethod(openReadwriteOffset, OpenReadwriteMarshal.Create);
            System.Int32 openReadwriteAsyncOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.OpenReadwriteAsync));
            RegisterVirtualMethod(openReadwriteAsyncOffset, OpenReadwriteAsyncMarshal.Create);
            System.Int32 openReadwriteFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.OpenReadwriteFinish));
            RegisterVirtualMethod(openReadwriteFinishOffset, OpenReadwriteFinishMarshal.Create);
            System.Int32 createReadwriteOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.CreateReadwrite));
            RegisterVirtualMethod(createReadwriteOffset, CreateReadwriteMarshal.Create);
            System.Int32 createReadwriteAsyncOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.CreateReadwriteAsync));
            RegisterVirtualMethod(createReadwriteAsyncOffset, CreateReadwriteAsyncMarshal.Create);
            System.Int32 createReadwriteFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.CreateReadwriteFinish));
            RegisterVirtualMethod(createReadwriteFinishOffset, CreateReadwriteFinishMarshal.Create);
            System.Int32 replaceReadwriteOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.ReplaceReadwrite));
            RegisterVirtualMethod(replaceReadwriteOffset, ReplaceReadwriteMarshal.Create);
            System.Int32 replaceReadwriteAsyncOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.ReplaceReadwriteAsync));
            RegisterVirtualMethod(replaceReadwriteAsyncOffset, ReplaceReadwriteAsyncMarshal.Create);
            System.Int32 replaceReadwriteFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.ReplaceReadwriteFinish));
            RegisterVirtualMethod(replaceReadwriteFinishOffset, ReplaceReadwriteFinishMarshal.Create);
            System.Int32 startMountableFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.StartMountableFinish));
            RegisterVirtualMethod(startMountableFinishOffset, StartMountableFinishMarshal.Create);
            System.Int32 stopMountableFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.StopMountableFinish));
            RegisterVirtualMethod(stopMountableFinishOffset, StopMountableFinishMarshal.Create);
            System.Int32 unmountMountableWithOperationFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.UnmountMountableWithOperationFinish));
            RegisterVirtualMethod(unmountMountableWithOperationFinishOffset, UnmountMountableWithOperationFinishMarshal.Create);
            System.Int32 ejectMountableWithOperationFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.EjectMountableWithOperationFinish));
            RegisterVirtualMethod(ejectMountableWithOperationFinishOffset, EjectMountableWithOperationFinishMarshal.Create);
            System.Int32 pollMountableOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.PollMountable));
            RegisterVirtualMethod(pollMountableOffset, PollMountableMarshal.Create);
            System.Int32 pollMountableFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.PollMountableFinish));
            RegisterVirtualMethod(pollMountableFinishOffset, PollMountableFinishMarshal.Create);
            System.Int32 measureDiskUsageFinishOffset = (System.Int32)System.Runtime.InteropServices.Marshal.OffsetOf<Struct>(nameof(Struct.MeasureDiskUsageFinish));
            RegisterVirtualMethod(measureDiskUsageFinishOffset, MeasureDiskUsageFinishMarshal.Create);
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='Dup']/*" />
        public delegate GISharp.Lib.Gio.IFile Dup();

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedDup(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file);

        /// <summary>
        /// Class for marshalling <see cref="Dup"/> methods.
        /// </summary>
        public static class DupMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedDup Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedDup(System.IntPtr file_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var doDup = (Dup)methodInfo.CreateDelegate(typeof(Dup), file);
                        var ret = doDup();
                        var ret_ = ret.Take();
                        return ret_;
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedDup;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='Hash']/*" />
        public delegate System.UInt32 Hash();

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:out */
        public unsafe delegate System.UInt32 UnmanagedHash(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file);

        /// <summary>
        /// Class for marshalling <see cref="Hash"/> methods.
        /// </summary>
        public static class HashMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedHash Create(System.Reflection.MethodInfo methodInfo)
            {
                System.UInt32 unmanagedHash(System.IntPtr file_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var doHash = (Hash)methodInfo.CreateDelegate(typeof(Hash), file);
                        var ret = doHash();
                        var ret_ = (System.UInt32)ret;
                        return ret_;
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.UInt32);
                }

                return unmanagedHash;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='Equal']/*" />
        public delegate System.Boolean Equal(GISharp.Lib.Gio.IFile file2);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:out */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedEqual(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file1,
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file2);

        /// <summary>
        /// Class for marshalling <see cref="Equal"/> methods.
        /// </summary>
        public static class EqualMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedEqual Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedEqual(System.IntPtr file1_, System.IntPtr file2_)
                {
                    try
                    {
                        var file1 = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file1_, GISharp.Runtime.Transfer.None)!;
                        var file2 = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file2_, GISharp.Runtime.Transfer.None)!;
                        var doEqual = (Equal)methodInfo.CreateDelegate(typeof(Equal), file1);
                        var ret = doEqual(file2);
                        var ret_ = (GISharp.Runtime.Boolean)ret;
                        return ret_;
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(GISharp.Runtime.Boolean);
                }

                return unmanagedEqual;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='IsNative']/*" />
        public delegate System.Boolean IsNative();

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:out */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedIsNative(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file);

        /// <summary>
        /// Class for marshalling <see cref="IsNative"/> methods.
        /// </summary>
        public static class IsNativeMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedIsNative Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedIsNative(System.IntPtr file_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var doIsNative = (IsNative)methodInfo.CreateDelegate(typeof(IsNative), file);
                        var ret = doIsNative();
                        var ret_ = (GISharp.Runtime.Boolean)ret;
                        return ret_;
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(GISharp.Runtime.Boolean);
                }

                return unmanagedIsNative;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='HasUriScheme']/*" />
        public delegate System.Boolean HasUriScheme(GISharp.Lib.GLib.UnownedUtf8 uriScheme);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:out */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedHasUriScheme(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr uriScheme);

        /// <summary>
        /// Class for marshalling <see cref="HasUriScheme"/> methods.
        /// </summary>
        public static class HasUriSchemeMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedHasUriScheme Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedHasUriScheme(System.IntPtr file_, System.IntPtr uriScheme_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var uriScheme = new GISharp.Lib.GLib.UnownedUtf8(uriScheme_, -1);
                        var doHasUriScheme = (HasUriScheme)methodInfo.CreateDelegate(typeof(HasUriScheme), file);
                        var ret = doHasUriScheme(uriScheme);
                        var ret_ = (GISharp.Runtime.Boolean)ret;
                        return ret_;
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(GISharp.Runtime.Boolean);
                }

                return unmanagedHasUriScheme;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='GetUriScheme']/*" />
        public delegate GISharp.Lib.GLib.Utf8 GetUriScheme();

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedGetUriScheme(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file);

        /// <summary>
        /// Class for marshalling <see cref="GetUriScheme"/> methods.
        /// </summary>
        public static class GetUriSchemeMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedGetUriScheme Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedGetUriScheme(System.IntPtr file_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var doGetUriScheme = (GetUriScheme)methodInfo.CreateDelegate(typeof(GetUriScheme), file);
                        var ret = doGetUriScheme();
                        var ret_ = ret.Take();
                        return ret_;
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedGetUriScheme;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='GetBasename']/*" />
        public delegate GISharp.Lib.GLib.Utf8 GetBasename();

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedGetBasename(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file);

        /// <summary>
        /// Class for marshalling <see cref="GetBasename"/> methods.
        /// </summary>
        public static class GetBasenameMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedGetBasename Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedGetBasename(System.IntPtr file_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var doGetBasename = (GetBasename)methodInfo.CreateDelegate(typeof(GetBasename), file);
                        var ret = doGetBasename();
                        var ret_ = ret.Take();
                        return ret_;
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedGetBasename;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='GetPath']/*" />
        public delegate GISharp.Lib.GLib.Utf8 GetPath();

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedGetPath(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file);

        /// <summary>
        /// Class for marshalling <see cref="GetPath"/> methods.
        /// </summary>
        public static class GetPathMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedGetPath Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedGetPath(System.IntPtr file_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var doGetPath = (GetPath)methodInfo.CreateDelegate(typeof(GetPath), file);
                        var ret = doGetPath();
                        var ret_ = ret.Take();
                        return ret_;
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedGetPath;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='GetUri']/*" />
        public delegate GISharp.Lib.GLib.Utf8 GetUri();

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedGetUri(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file);

        /// <summary>
        /// Class for marshalling <see cref="GetUri"/> methods.
        /// </summary>
        public static class GetUriMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedGetUri Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedGetUri(System.IntPtr file_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var doGetUri = (GetUri)methodInfo.CreateDelegate(typeof(GetUri), file);
                        var ret = doGetUri();
                        var ret_ = ret.Take();
                        return ret_;
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedGetUri;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='GetParseName']/*" />
        public delegate GISharp.Lib.GLib.Utf8 GetParseName();

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedGetParseName(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file);

        /// <summary>
        /// Class for marshalling <see cref="GetParseName"/> methods.
        /// </summary>
        public static class GetParseNameMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedGetParseName Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedGetParseName(System.IntPtr file_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var doGetParseName = (GetParseName)methodInfo.CreateDelegate(typeof(GetParseName), file);
                        var ret = doGetParseName();
                        var ret_ = ret.Take();
                        return ret_;
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedGetParseName;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='GetParent']/*" />
        public delegate GISharp.Lib.Gio.IFile? GetParent();

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
        /* transfer-ownership:full nullable:1 direction:out */
        public unsafe delegate System.IntPtr UnmanagedGetParent(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file);

        /// <summary>
        /// Class for marshalling <see cref="GetParent"/> methods.
        /// </summary>
        public static class GetParentMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedGetParent Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedGetParent(System.IntPtr file_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var doGetParent = (GetParent)methodInfo.CreateDelegate(typeof(GetParent), file);
                        var ret = doGetParent();
                        var ret_ = ret?.Take() ?? System.IntPtr.Zero;
                        return ret_;
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedGetParent;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='PrefixMatches']/*" />
        public delegate System.Boolean PrefixMatches(GISharp.Lib.Gio.IFile file);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none direction:out */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedPrefixMatches(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr prefix,
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file);

        /// <summary>
        /// Class for marshalling <see cref="PrefixMatches"/> methods.
        /// </summary>
        public static class PrefixMatchesMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedPrefixMatches Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedPrefixMatches(System.IntPtr prefix_, System.IntPtr file_)
                {
                    try
                    {
                        var prefix = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(prefix_, GISharp.Runtime.Transfer.None)!;
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var doPrefixMatches = (PrefixMatches)methodInfo.CreateDelegate(typeof(PrefixMatches), prefix);
                        var ret = doPrefixMatches(file);
                        var ret_ = (GISharp.Runtime.Boolean)ret;
                        return ret_;
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(GISharp.Runtime.Boolean);
                }

                return unmanagedPrefixMatches;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='GetRelativePath']/*" />
        public delegate GISharp.Lib.GLib.Utf8 GetRelativePath(GISharp.Lib.Gio.IFile descendant);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="utf8" type="char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedGetRelativePath(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr parent,
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr descendant);

        /// <summary>
        /// Class for marshalling <see cref="GetRelativePath"/> methods.
        /// </summary>
        public static class GetRelativePathMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedGetRelativePath Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedGetRelativePath(System.IntPtr parent_, System.IntPtr descendant_)
                {
                    try
                    {
                        var parent = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(parent_, GISharp.Runtime.Transfer.None)!;
                        var descendant = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(descendant_, GISharp.Runtime.Transfer.None)!;
                        var doGetRelativePath = (GetRelativePath)methodInfo.CreateDelegate(typeof(GetRelativePath), parent);
                        var ret = doGetRelativePath(descendant);
                        var ret_ = ret.Take();
                        return ret_;
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedGetRelativePath;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='ResolveRelativePath']/*" />
        public delegate GISharp.Lib.Gio.IFile ResolveRelativePath(GISharp.Lib.GLib.Filename relativePath);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedResolveRelativePath(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="filename" type="const char*" managed-name="GISharp.Lib.GLib.Filename" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr relativePath);

        /// <summary>
        /// Class for marshalling <see cref="ResolveRelativePath"/> methods.
        /// </summary>
        public static class ResolveRelativePathMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedResolveRelativePath Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedResolveRelativePath(System.IntPtr file_, System.IntPtr relativePath_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var relativePath = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Filename>(relativePath_, GISharp.Runtime.Transfer.None)!;
                        var doResolveRelativePath = (ResolveRelativePath)methodInfo.CreateDelegate(typeof(ResolveRelativePath), file);
                        var ret = doResolveRelativePath(relativePath);
                        var ret_ = ret.Take();
                        return ret_;
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedResolveRelativePath;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='GetChildForDisplayName']/*" />
        public delegate GISharp.Lib.Gio.IFile GetChildForDisplayName(GISharp.Lib.GLib.UnownedUtf8 displayName);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedGetChildForDisplayName(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr displayName,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
ref System.IntPtr error);

        /// <summary>
        /// Class for marshalling <see cref="GetChildForDisplayName"/> methods.
        /// </summary>
        public static class GetChildForDisplayNameMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedGetChildForDisplayName Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedGetChildForDisplayName(System.IntPtr file_, System.IntPtr displayName_, ref System.IntPtr error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var displayName = new GISharp.Lib.GLib.UnownedUtf8(displayName_, -1);
                        var doGetChildForDisplayName = (GetChildForDisplayName)methodInfo.CreateDelegate(typeof(GetChildForDisplayName), file);
                        var ret = doGetChildForDisplayName(displayName);
                        var ret_ = ret.Take();
                        return ret_;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(ref error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedGetChildForDisplayName;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='EnumerateChildrenAsync']/*" />
        public delegate void EnumerateChildrenAsync(GISharp.Lib.GLib.UnownedUtf8 attributes, GISharp.Lib.Gio.FileQueryInfoFlags flags, System.Int32 ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        public unsafe delegate void UnmanagedEnumerateChildrenAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr attributes,
/* <type name="FileQueryInfoFlags" type="GFileQueryInfoFlags" managed-name="FileQueryInfoFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileQueryInfoFlags flags,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
System.Int32 ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="UnmanagedAsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:6 direction:in */
System.IntPtr callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:6 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Class for marshalling <see cref="EnumerateChildrenAsync"/> methods.
        /// </summary>
        public static class EnumerateChildrenAsyncMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedEnumerateChildrenAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedEnumerateChildrenAsync(System.IntPtr file_, System.IntPtr attributes_, GISharp.Lib.Gio.FileQueryInfoFlags flags_, System.Int32 ioPriority_, System.IntPtr cancellable_, System.IntPtr callback_, System.IntPtr userData_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var attributes = new GISharp.Lib.GLib.UnownedUtf8(attributes_, -1);
                        var flags = (GISharp.Lib.Gio.FileQueryInfoFlags)flags_;
                        var ioPriority = (System.Int32)ioPriority_;
                        var callback = callback_ == null ? default(GISharp.Lib.Gio.AsyncReadyCallback) : GISharp.Lib.Gio.AsyncReadyCallbackMarshal.FromPointer(callback_, userData_);
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doEnumerateChildrenAsync = (EnumerateChildrenAsync)methodInfo.CreateDelegate(typeof(EnumerateChildrenAsync), file);
                        doEnumerateChildrenAsync(attributes, flags, ioPriority, callback, cancellable);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }
                }

                return unmanagedEnumerateChildrenAsync;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='QueryInfo']/*" />
        public delegate GISharp.Lib.Gio.FileInfo QueryInfo(GISharp.Lib.GLib.UnownedUtf8 attributes, GISharp.Lib.Gio.FileQueryInfoFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileInfo" type="GFileInfo*" managed-name="FileInfo" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedQueryInfo(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr attributes,
/* <type name="FileQueryInfoFlags" type="GFileQueryInfoFlags" managed-name="FileQueryInfoFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileQueryInfoFlags flags,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
ref System.IntPtr error);

        /// <summary>
        /// Class for marshalling <see cref="QueryInfo"/> methods.
        /// </summary>
        public static class QueryInfoMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedQueryInfo Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedQueryInfo(System.IntPtr file_, System.IntPtr attributes_, GISharp.Lib.Gio.FileQueryInfoFlags flags_, System.IntPtr cancellable_, ref System.IntPtr error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var attributes = new GISharp.Lib.GLib.UnownedUtf8(attributes_, -1);
                        var flags = (GISharp.Lib.Gio.FileQueryInfoFlags)flags_;
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doQueryInfo = (QueryInfo)methodInfo.CreateDelegate(typeof(QueryInfo), file);
                        var ret = doQueryInfo(attributes, flags, cancellable);
                        var ret_ = ret.Take();
                        return ret_;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(ref error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedQueryInfo;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='QueryInfoAsync']/*" />
        public delegate void QueryInfoAsync(GISharp.Lib.GLib.UnownedUtf8 attributes, GISharp.Lib.Gio.FileQueryInfoFlags flags, System.Int32 ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        public unsafe delegate void UnmanagedQueryInfoAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr attributes,
/* <type name="FileQueryInfoFlags" type="GFileQueryInfoFlags" managed-name="FileQueryInfoFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileQueryInfoFlags flags,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
System.Int32 ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="UnmanagedAsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:6 direction:in */
System.IntPtr callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:6 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Class for marshalling <see cref="QueryInfoAsync"/> methods.
        /// </summary>
        public static class QueryInfoAsyncMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedQueryInfoAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedQueryInfoAsync(System.IntPtr file_, System.IntPtr attributes_, GISharp.Lib.Gio.FileQueryInfoFlags flags_, System.Int32 ioPriority_, System.IntPtr cancellable_, System.IntPtr callback_, System.IntPtr userData_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var attributes = new GISharp.Lib.GLib.UnownedUtf8(attributes_, -1);
                        var flags = (GISharp.Lib.Gio.FileQueryInfoFlags)flags_;
                        var ioPriority = (System.Int32)ioPriority_;
                        var callback = callback_ == null ? default(GISharp.Lib.Gio.AsyncReadyCallback) : GISharp.Lib.Gio.AsyncReadyCallbackMarshal.FromPointer(callback_, userData_);
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doQueryInfoAsync = (QueryInfoAsync)methodInfo.CreateDelegate(typeof(QueryInfoAsync), file);
                        doQueryInfoAsync(attributes, flags, ioPriority, callback, cancellable);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }
                }

                return unmanagedQueryInfoAsync;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='QueryInfoFinish']/*" />
        public delegate GISharp.Lib.Gio.FileInfo QueryInfoFinish(GISharp.Lib.Gio.IAsyncResult res);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileInfo" type="GFileInfo*" managed-name="FileInfo" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedQueryInfoFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr res,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
ref System.IntPtr error);

        /// <summary>
        /// Class for marshalling <see cref="QueryInfoFinish"/> methods.
        /// </summary>
        public static class QueryInfoFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedQueryInfoFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedQueryInfoFinish(System.IntPtr file_, System.IntPtr res_, ref System.IntPtr error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var res = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance(res_, GISharp.Runtime.Transfer.None)!;
                        var doQueryInfoFinish = (QueryInfoFinish)methodInfo.CreateDelegate(typeof(QueryInfoFinish), file);
                        var ret = doQueryInfoFinish(res);
                        var ret_ = ret.Take();
                        return ret_;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(ref error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedQueryInfoFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='QueryFilesystemInfo']/*" />
        public delegate GISharp.Lib.Gio.FileInfo QueryFilesystemInfo(GISharp.Lib.GLib.UnownedUtf8 attributes, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileInfo" type="GFileInfo*" managed-name="FileInfo" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedQueryFilesystemInfo(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr attributes,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
ref System.IntPtr error);

        /// <summary>
        /// Class for marshalling <see cref="QueryFilesystemInfo"/> methods.
        /// </summary>
        public static class QueryFilesystemInfoMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedQueryFilesystemInfo Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedQueryFilesystemInfo(System.IntPtr file_, System.IntPtr attributes_, System.IntPtr cancellable_, ref System.IntPtr error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var attributes = new GISharp.Lib.GLib.UnownedUtf8(attributes_, -1);
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doQueryFilesystemInfo = (QueryFilesystemInfo)methodInfo.CreateDelegate(typeof(QueryFilesystemInfo), file);
                        var ret = doQueryFilesystemInfo(attributes, cancellable);
                        var ret_ = ret.Take();
                        return ret_;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(ref error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedQueryFilesystemInfo;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='QueryFilesystemInfoAsync']/*" />
        public delegate void QueryFilesystemInfoAsync(GISharp.Lib.GLib.UnownedUtf8 attributes, System.Int32 ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        public unsafe delegate void UnmanagedQueryFilesystemInfoAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr attributes,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
System.Int32 ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="UnmanagedAsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:5 direction:in */
System.IntPtr callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:5 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Class for marshalling <see cref="QueryFilesystemInfoAsync"/> methods.
        /// </summary>
        public static class QueryFilesystemInfoAsyncMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedQueryFilesystemInfoAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedQueryFilesystemInfoAsync(System.IntPtr file_, System.IntPtr attributes_, System.Int32 ioPriority_, System.IntPtr cancellable_, System.IntPtr callback_, System.IntPtr userData_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var attributes = new GISharp.Lib.GLib.UnownedUtf8(attributes_, -1);
                        var ioPriority = (System.Int32)ioPriority_;
                        var callback = callback_ == null ? default(GISharp.Lib.Gio.AsyncReadyCallback) : GISharp.Lib.Gio.AsyncReadyCallbackMarshal.FromPointer(callback_, userData_);
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doQueryFilesystemInfoAsync = (QueryFilesystemInfoAsync)methodInfo.CreateDelegate(typeof(QueryFilesystemInfoAsync), file);
                        doQueryFilesystemInfoAsync(attributes, ioPriority, callback, cancellable);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }
                }

                return unmanagedQueryFilesystemInfoAsync;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='QueryFilesystemInfoFinish']/*" />
        public delegate GISharp.Lib.Gio.FileInfo QueryFilesystemInfoFinish(GISharp.Lib.Gio.IAsyncResult res);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileInfo" type="GFileInfo*" managed-name="FileInfo" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedQueryFilesystemInfoFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr res,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
ref System.IntPtr error);

        /// <summary>
        /// Class for marshalling <see cref="QueryFilesystemInfoFinish"/> methods.
        /// </summary>
        public static class QueryFilesystemInfoFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedQueryFilesystemInfoFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedQueryFilesystemInfoFinish(System.IntPtr file_, System.IntPtr res_, ref System.IntPtr error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var res = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance(res_, GISharp.Runtime.Transfer.None)!;
                        var doQueryFilesystemInfoFinish = (QueryFilesystemInfoFinish)methodInfo.CreateDelegate(typeof(QueryFilesystemInfoFinish), file);
                        var ret = doQueryFilesystemInfoFinish(res);
                        var ret_ = ret.Take();
                        return ret_;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(ref error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedQueryFilesystemInfoFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='FindEnclosingMountAsync']/*" />
        public delegate void FindEnclosingMountAsync(System.Int32 ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        public unsafe delegate void UnmanagedFindEnclosingMountAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
System.Int32 ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="UnmanagedAsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:4 direction:in */
System.IntPtr callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:4 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Class for marshalling <see cref="FindEnclosingMountAsync"/> methods.
        /// </summary>
        public static class FindEnclosingMountAsyncMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedFindEnclosingMountAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedFindEnclosingMountAsync(System.IntPtr file_, System.Int32 ioPriority_, System.IntPtr cancellable_, System.IntPtr callback_, System.IntPtr userData_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var ioPriority = (System.Int32)ioPriority_;
                        var callback = callback_ == null ? default(GISharp.Lib.Gio.AsyncReadyCallback) : GISharp.Lib.Gio.AsyncReadyCallbackMarshal.FromPointer(callback_, userData_);
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doFindEnclosingMountAsync = (FindEnclosingMountAsync)methodInfo.CreateDelegate(typeof(FindEnclosingMountAsync), file);
                        doFindEnclosingMountAsync(ioPriority, callback, cancellable);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }
                }

                return unmanagedFindEnclosingMountAsync;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='SetDisplayName']/*" />
        public delegate GISharp.Lib.Gio.IFile SetDisplayName(GISharp.Lib.GLib.UnownedUtf8 displayName, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedSetDisplayName(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr displayName,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
ref System.IntPtr error);

        /// <summary>
        /// Class for marshalling <see cref="SetDisplayName"/> methods.
        /// </summary>
        public static class SetDisplayNameMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedSetDisplayName Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedSetDisplayName(System.IntPtr file_, System.IntPtr displayName_, System.IntPtr cancellable_, ref System.IntPtr error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var displayName = new GISharp.Lib.GLib.UnownedUtf8(displayName_, -1);
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doSetDisplayName = (SetDisplayName)methodInfo.CreateDelegate(typeof(SetDisplayName), file);
                        var ret = doSetDisplayName(displayName, cancellable);
                        var ret_ = ret.Take();
                        return ret_;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(ref error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedSetDisplayName;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='SetDisplayNameAsync']/*" />
        public delegate void SetDisplayNameAsync(GISharp.Lib.GLib.UnownedUtf8 displayName, System.Int32 ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        public unsafe delegate void UnmanagedSetDisplayNameAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr displayName,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
System.Int32 ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="UnmanagedAsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:5 direction:in */
System.IntPtr callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:5 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Class for marshalling <see cref="SetDisplayNameAsync"/> methods.
        /// </summary>
        public static class SetDisplayNameAsyncMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedSetDisplayNameAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedSetDisplayNameAsync(System.IntPtr file_, System.IntPtr displayName_, System.Int32 ioPriority_, System.IntPtr cancellable_, System.IntPtr callback_, System.IntPtr userData_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var displayName = new GISharp.Lib.GLib.UnownedUtf8(displayName_, -1);
                        var ioPriority = (System.Int32)ioPriority_;
                        var callback = callback_ == null ? default(GISharp.Lib.Gio.AsyncReadyCallback) : GISharp.Lib.Gio.AsyncReadyCallbackMarshal.FromPointer(callback_, userData_);
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doSetDisplayNameAsync = (SetDisplayNameAsync)methodInfo.CreateDelegate(typeof(SetDisplayNameAsync), file);
                        doSetDisplayNameAsync(displayName, ioPriority, callback, cancellable);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }
                }

                return unmanagedSetDisplayNameAsync;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='SetDisplayNameFinish']/*" />
        public delegate GISharp.Lib.Gio.IFile SetDisplayNameFinish(GISharp.Lib.Gio.IAsyncResult res);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedSetDisplayNameFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr res,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
ref System.IntPtr error);

        /// <summary>
        /// Class for marshalling <see cref="SetDisplayNameFinish"/> methods.
        /// </summary>
        public static class SetDisplayNameFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedSetDisplayNameFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedSetDisplayNameFinish(System.IntPtr file_, System.IntPtr res_, ref System.IntPtr error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var res = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance(res_, GISharp.Runtime.Transfer.None)!;
                        var doSetDisplayNameFinish = (SetDisplayNameFinish)methodInfo.CreateDelegate(typeof(SetDisplayNameFinish), file);
                        var ret = doSetDisplayNameFinish(res);
                        var ret_ = ret.Take();
                        return ret_;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(ref error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedSetDisplayNameFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='QuerySettableAttributes']/*" />
        public delegate GISharp.Lib.Gio.FileAttributeInfoList QuerySettableAttributes(GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileAttributeInfoList" type="GFileAttributeInfoList*" managed-name="FileAttributeInfoList" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedQuerySettableAttributes(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
ref System.IntPtr error);

        /// <summary>
        /// Class for marshalling <see cref="QuerySettableAttributes"/> methods.
        /// </summary>
        public static class QuerySettableAttributesMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedQuerySettableAttributes Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedQuerySettableAttributes(System.IntPtr file_, System.IntPtr cancellable_, ref System.IntPtr error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doQuerySettableAttributes = (QuerySettableAttributes)methodInfo.CreateDelegate(typeof(QuerySettableAttributes), file);
                        var ret = doQuerySettableAttributes(cancellable);
                        var ret_ = ret.Take();
                        return ret_;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(ref error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedQuerySettableAttributes;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='QueryWritableNamespaces']/*" />
        public delegate GISharp.Lib.Gio.FileAttributeInfoList QueryWritableNamespaces(GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileAttributeInfoList" type="GFileAttributeInfoList*" managed-name="FileAttributeInfoList" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedQueryWritableNamespaces(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
ref System.IntPtr error);

        /// <summary>
        /// Class for marshalling <see cref="QueryWritableNamespaces"/> methods.
        /// </summary>
        public static class QueryWritableNamespacesMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedQueryWritableNamespaces Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedQueryWritableNamespaces(System.IntPtr file_, System.IntPtr cancellable_, ref System.IntPtr error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doQueryWritableNamespaces = (QueryWritableNamespaces)methodInfo.CreateDelegate(typeof(QueryWritableNamespaces), file);
                        var ret = doQueryWritableNamespaces(cancellable);
                        var ret_ = ret.Take();
                        return ret_;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(ref error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedQueryWritableNamespaces;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='SetAttribute']/*" />
        public delegate void SetAttribute(GISharp.Lib.GLib.UnownedUtf8 attribute, GISharp.Lib.Gio.FileAttributeType type, System.IntPtr valueP, GISharp.Lib.Gio.FileQueryInfoFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:out */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedSetAttribute(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr attribute,
/* <type name="FileAttributeType" type="GFileAttributeType" managed-name="FileAttributeType" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileAttributeType type,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr valueP,
/* <type name="FileQueryInfoFlags" type="GFileQueryInfoFlags" managed-name="FileQueryInfoFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileQueryInfoFlags flags,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
ref System.IntPtr error);

        /// <summary>
        /// Class for marshalling <see cref="SetAttribute"/> methods.
        /// </summary>
        public static class SetAttributeMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedSetAttribute Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedSetAttribute(System.IntPtr file_, System.IntPtr attribute_, GISharp.Lib.Gio.FileAttributeType type_, System.IntPtr valueP_, GISharp.Lib.Gio.FileQueryInfoFlags flags_, System.IntPtr cancellable_, ref System.IntPtr error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var attribute = new GISharp.Lib.GLib.UnownedUtf8(attribute_, -1);
                        var type = (GISharp.Lib.Gio.FileAttributeType)type_;
                        var valueP = (System.IntPtr)valueP_;
                        var flags = (GISharp.Lib.Gio.FileQueryInfoFlags)flags_;
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doSetAttribute = (SetAttribute)methodInfo.CreateDelegate(typeof(SetAttribute), file);
                        doSetAttribute(attribute, type, valueP, flags, cancellable);
                        return true;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(ref error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(GISharp.Runtime.Boolean);
                }

                return unmanagedSetAttribute;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='SetAttributesFromInfo']/*" />
        public delegate void SetAttributesFromInfo(GISharp.Lib.Gio.FileInfo info, GISharp.Lib.Gio.FileQueryInfoFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:out */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedSetAttributesFromInfo(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="FileInfo" type="GFileInfo*" managed-name="FileInfo" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr info,
/* <type name="FileQueryInfoFlags" type="GFileQueryInfoFlags" managed-name="FileQueryInfoFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileQueryInfoFlags flags,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
ref System.IntPtr error);

        /// <summary>
        /// Class for marshalling <see cref="SetAttributesFromInfo"/> methods.
        /// </summary>
        public static class SetAttributesFromInfoMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedSetAttributesFromInfo Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedSetAttributesFromInfo(System.IntPtr file_, System.IntPtr info_, GISharp.Lib.Gio.FileQueryInfoFlags flags_, System.IntPtr cancellable_, ref System.IntPtr error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var info = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.FileInfo>(info_, GISharp.Runtime.Transfer.None)!;
                        var flags = (GISharp.Lib.Gio.FileQueryInfoFlags)flags_;
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doSetAttributesFromInfo = (SetAttributesFromInfo)methodInfo.CreateDelegate(typeof(SetAttributesFromInfo), file);
                        doSetAttributesFromInfo(info, flags, cancellable);
                        return true;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(ref error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(GISharp.Runtime.Boolean);
                }

                return unmanagedSetAttributesFromInfo;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='SetAttributesAsync']/*" />
        public delegate void SetAttributesAsync(GISharp.Lib.Gio.FileInfo info, GISharp.Lib.Gio.FileQueryInfoFlags flags, System.Int32 ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        public unsafe delegate void UnmanagedSetAttributesAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="FileInfo" type="GFileInfo*" managed-name="FileInfo" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr info,
/* <type name="FileQueryInfoFlags" type="GFileQueryInfoFlags" managed-name="FileQueryInfoFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileQueryInfoFlags flags,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
System.Int32 ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="UnmanagedAsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:6 direction:in */
System.IntPtr callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:6 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Class for marshalling <see cref="SetAttributesAsync"/> methods.
        /// </summary>
        public static class SetAttributesAsyncMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedSetAttributesAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedSetAttributesAsync(System.IntPtr file_, System.IntPtr info_, GISharp.Lib.Gio.FileQueryInfoFlags flags_, System.Int32 ioPriority_, System.IntPtr cancellable_, System.IntPtr callback_, System.IntPtr userData_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var info = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.FileInfo>(info_, GISharp.Runtime.Transfer.None)!;
                        var flags = (GISharp.Lib.Gio.FileQueryInfoFlags)flags_;
                        var ioPriority = (System.Int32)ioPriority_;
                        var callback = callback_ == null ? default(GISharp.Lib.Gio.AsyncReadyCallback) : GISharp.Lib.Gio.AsyncReadyCallbackMarshal.FromPointer(callback_, userData_);
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doSetAttributesAsync = (SetAttributesAsync)methodInfo.CreateDelegate(typeof(SetAttributesAsync), file);
                        doSetAttributesAsync(info, flags, ioPriority, callback, cancellable);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }
                }

                return unmanagedSetAttributesAsync;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='SetAttributesFinish']/*" />
        public delegate void SetAttributesFinish(GISharp.Lib.Gio.IAsyncResult result, out GISharp.Lib.Gio.FileInfo info);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:out */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedSetAttributesFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr result,
/* <type name="FileInfo" type="GFileInfo**" managed-name="FileInfo" is-pointer="1" /> */
/* direction:out caller-allocates:0 transfer-ownership:full */
out System.IntPtr info,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
ref System.IntPtr error);

        /// <summary>
        /// Class for marshalling <see cref="SetAttributesFinish"/> methods.
        /// </summary>
        public static class SetAttributesFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedSetAttributesFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedSetAttributesFinish(System.IntPtr file_, System.IntPtr result_, out System.IntPtr info_, ref System.IntPtr error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance(result_, GISharp.Runtime.Transfer.None)!;
                        var doSetAttributesFinish = (SetAttributesFinish)methodInfo.CreateDelegate(typeof(SetAttributesFinish), file);
                        doSetAttributesFinish(result,out var info);
                        info_ = info.Take();
                        return true;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(ref error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    info_ = default(System.IntPtr);
                    return default(GISharp.Runtime.Boolean);
                }

                return unmanagedSetAttributesFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='ReadFn']/*" />
        public delegate GISharp.Lib.Gio.FileInputStream ReadFn(GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileInputStream" type="GFileInputStream*" managed-name="FileInputStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedReadFn(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
ref System.IntPtr error);

        /// <summary>
        /// Class for marshalling <see cref="ReadFn"/> methods.
        /// </summary>
        public static class ReadFnMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedReadFn Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedReadFn(System.IntPtr file_, System.IntPtr cancellable_, ref System.IntPtr error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doReadFn = (ReadFn)methodInfo.CreateDelegate(typeof(ReadFn), file);
                        var ret = doReadFn(cancellable);
                        var ret_ = ret.Take();
                        return ret_;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(ref error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedReadFn;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='ReadAsync']/*" />
        public delegate void ReadAsync(System.Int32 ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        public unsafe delegate void UnmanagedReadAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
System.Int32 ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="UnmanagedAsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:4 direction:in */
System.IntPtr callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:4 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Class for marshalling <see cref="ReadAsync"/> methods.
        /// </summary>
        public static class ReadAsyncMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedReadAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedReadAsync(System.IntPtr file_, System.Int32 ioPriority_, System.IntPtr cancellable_, System.IntPtr callback_, System.IntPtr userData_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var ioPriority = (System.Int32)ioPriority_;
                        var callback = callback_ == null ? default(GISharp.Lib.Gio.AsyncReadyCallback) : GISharp.Lib.Gio.AsyncReadyCallbackMarshal.FromPointer(callback_, userData_);
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doReadAsync = (ReadAsync)methodInfo.CreateDelegate(typeof(ReadAsync), file);
                        doReadAsync(ioPriority, callback, cancellable);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }
                }

                return unmanagedReadAsync;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='ReadFinish']/*" />
        public delegate GISharp.Lib.Gio.FileInputStream ReadFinish(GISharp.Lib.Gio.IAsyncResult res);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileInputStream" type="GFileInputStream*" managed-name="FileInputStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedReadFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr res,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
ref System.IntPtr error);

        /// <summary>
        /// Class for marshalling <see cref="ReadFinish"/> methods.
        /// </summary>
        public static class ReadFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedReadFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedReadFinish(System.IntPtr file_, System.IntPtr res_, ref System.IntPtr error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var res = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance(res_, GISharp.Runtime.Transfer.None)!;
                        var doReadFinish = (ReadFinish)methodInfo.CreateDelegate(typeof(ReadFinish), file);
                        var ret = doReadFinish(res);
                        var ret_ = ret.Take();
                        return ret_;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(ref error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedReadFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='AppendTo']/*" />
        public delegate GISharp.Lib.Gio.FileOutputStream AppendTo(GISharp.Lib.Gio.FileCreateFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileOutputStream" type="GFileOutputStream*" managed-name="FileOutputStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedAppendTo(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="FileCreateFlags" type="GFileCreateFlags" managed-name="FileCreateFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileCreateFlags flags,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
ref System.IntPtr error);

        /// <summary>
        /// Class for marshalling <see cref="AppendTo"/> methods.
        /// </summary>
        public static class AppendToMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedAppendTo Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedAppendTo(System.IntPtr file_, GISharp.Lib.Gio.FileCreateFlags flags_, System.IntPtr cancellable_, ref System.IntPtr error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var flags = (GISharp.Lib.Gio.FileCreateFlags)flags_;
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doAppendTo = (AppendTo)methodInfo.CreateDelegate(typeof(AppendTo), file);
                        var ret = doAppendTo(flags, cancellable);
                        var ret_ = ret.Take();
                        return ret_;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(ref error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedAppendTo;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='AppendToAsync']/*" />
        public delegate void AppendToAsync(GISharp.Lib.Gio.FileCreateFlags flags, System.Int32 ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        public unsafe delegate void UnmanagedAppendToAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="FileCreateFlags" type="GFileCreateFlags" managed-name="FileCreateFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileCreateFlags flags,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
System.Int32 ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="UnmanagedAsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:5 direction:in */
System.IntPtr callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:5 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Class for marshalling <see cref="AppendToAsync"/> methods.
        /// </summary>
        public static class AppendToAsyncMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedAppendToAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedAppendToAsync(System.IntPtr file_, GISharp.Lib.Gio.FileCreateFlags flags_, System.Int32 ioPriority_, System.IntPtr cancellable_, System.IntPtr callback_, System.IntPtr userData_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var flags = (GISharp.Lib.Gio.FileCreateFlags)flags_;
                        var ioPriority = (System.Int32)ioPriority_;
                        var callback = callback_ == null ? default(GISharp.Lib.Gio.AsyncReadyCallback) : GISharp.Lib.Gio.AsyncReadyCallbackMarshal.FromPointer(callback_, userData_);
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doAppendToAsync = (AppendToAsync)methodInfo.CreateDelegate(typeof(AppendToAsync), file);
                        doAppendToAsync(flags, ioPriority, callback, cancellable);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }
                }

                return unmanagedAppendToAsync;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='AppendToFinish']/*" />
        public delegate GISharp.Lib.Gio.FileOutputStream AppendToFinish(GISharp.Lib.Gio.IAsyncResult res);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileOutputStream" type="GFileOutputStream*" managed-name="FileOutputStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedAppendToFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr res,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
ref System.IntPtr error);

        /// <summary>
        /// Class for marshalling <see cref="AppendToFinish"/> methods.
        /// </summary>
        public static class AppendToFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedAppendToFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedAppendToFinish(System.IntPtr file_, System.IntPtr res_, ref System.IntPtr error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var res = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance(res_, GISharp.Runtime.Transfer.None)!;
                        var doAppendToFinish = (AppendToFinish)methodInfo.CreateDelegate(typeof(AppendToFinish), file);
                        var ret = doAppendToFinish(res);
                        var ret_ = ret.Take();
                        return ret_;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(ref error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedAppendToFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='Create']/*" />
        public delegate GISharp.Lib.Gio.FileOutputStream Create(GISharp.Lib.Gio.FileCreateFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileOutputStream" type="GFileOutputStream*" managed-name="FileOutputStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedCreate(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="FileCreateFlags" type="GFileCreateFlags" managed-name="FileCreateFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileCreateFlags flags,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
ref System.IntPtr error);

        /// <summary>
        /// Class for marshalling <see cref="Create"/> methods.
        /// </summary>
        public static class CreateMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedCreate Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedCreate(System.IntPtr file_, GISharp.Lib.Gio.FileCreateFlags flags_, System.IntPtr cancellable_, ref System.IntPtr error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var flags = (GISharp.Lib.Gio.FileCreateFlags)flags_;
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doCreate = (Create)methodInfo.CreateDelegate(typeof(Create), file);
                        var ret = doCreate(flags, cancellable);
                        var ret_ = ret.Take();
                        return ret_;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(ref error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedCreate;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='CreateAsync']/*" />
        public delegate void CreateAsync(GISharp.Lib.Gio.FileCreateFlags flags, System.Int32 ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        public unsafe delegate void UnmanagedCreateAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="FileCreateFlags" type="GFileCreateFlags" managed-name="FileCreateFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileCreateFlags flags,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
System.Int32 ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="UnmanagedAsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:5 direction:in */
System.IntPtr callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:5 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Class for marshalling <see cref="CreateAsync"/> methods.
        /// </summary>
        public static class CreateAsyncMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedCreateAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedCreateAsync(System.IntPtr file_, GISharp.Lib.Gio.FileCreateFlags flags_, System.Int32 ioPriority_, System.IntPtr cancellable_, System.IntPtr callback_, System.IntPtr userData_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var flags = (GISharp.Lib.Gio.FileCreateFlags)flags_;
                        var ioPriority = (System.Int32)ioPriority_;
                        var callback = callback_ == null ? default(GISharp.Lib.Gio.AsyncReadyCallback) : GISharp.Lib.Gio.AsyncReadyCallbackMarshal.FromPointer(callback_, userData_);
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doCreateAsync = (CreateAsync)methodInfo.CreateDelegate(typeof(CreateAsync), file);
                        doCreateAsync(flags, ioPriority, callback, cancellable);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }
                }

                return unmanagedCreateAsync;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='CreateFinish']/*" />
        public delegate GISharp.Lib.Gio.FileOutputStream CreateFinish(GISharp.Lib.Gio.IAsyncResult res);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileOutputStream" type="GFileOutputStream*" managed-name="FileOutputStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedCreateFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr res,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
ref System.IntPtr error);

        /// <summary>
        /// Class for marshalling <see cref="CreateFinish"/> methods.
        /// </summary>
        public static class CreateFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedCreateFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedCreateFinish(System.IntPtr file_, System.IntPtr res_, ref System.IntPtr error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var res = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance(res_, GISharp.Runtime.Transfer.None)!;
                        var doCreateFinish = (CreateFinish)methodInfo.CreateDelegate(typeof(CreateFinish), file);
                        var ret = doCreateFinish(res);
                        var ret_ = ret.Take();
                        return ret_;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(ref error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedCreateFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='Replace']/*" />
        public delegate GISharp.Lib.Gio.FileOutputStream Replace(GISharp.Lib.GLib.NullableUnownedUtf8 etag, System.Boolean makeBackup, GISharp.Lib.Gio.FileCreateFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileOutputStream" type="GFileOutputStream*" managed-name="FileOutputStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedReplace(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr etag,
/* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
/* transfer-ownership:none direction:in */
GISharp.Runtime.Boolean makeBackup,
/* <type name="FileCreateFlags" type="GFileCreateFlags" managed-name="FileCreateFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileCreateFlags flags,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
ref System.IntPtr error);

        /// <summary>
        /// Class for marshalling <see cref="Replace"/> methods.
        /// </summary>
        public static class ReplaceMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedReplace Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedReplace(System.IntPtr file_, System.IntPtr etag_, GISharp.Runtime.Boolean makeBackup_, GISharp.Lib.Gio.FileCreateFlags flags_, System.IntPtr cancellable_, ref System.IntPtr error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var etag = new GISharp.Lib.GLib.NullableUnownedUtf8(etag_, -1);
                        var makeBackup = (System.Boolean)makeBackup_;
                        var flags = (GISharp.Lib.Gio.FileCreateFlags)flags_;
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doReplace = (Replace)methodInfo.CreateDelegate(typeof(Replace), file);
                        var ret = doReplace(etag, makeBackup, flags, cancellable);
                        var ret_ = ret.Take();
                        return ret_;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(ref error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedReplace;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='ReplaceAsync']/*" />
        public delegate void ReplaceAsync(GISharp.Lib.GLib.NullableUnownedUtf8 etag, System.Boolean makeBackup, GISharp.Lib.Gio.FileCreateFlags flags, System.Int32 ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        public unsafe delegate void UnmanagedReplaceAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr etag,
/* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
/* transfer-ownership:none direction:in */
GISharp.Runtime.Boolean makeBackup,
/* <type name="FileCreateFlags" type="GFileCreateFlags" managed-name="FileCreateFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileCreateFlags flags,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
System.Int32 ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="UnmanagedAsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:7 direction:in */
System.IntPtr callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:7 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Class for marshalling <see cref="ReplaceAsync"/> methods.
        /// </summary>
        public static class ReplaceAsyncMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedReplaceAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedReplaceAsync(System.IntPtr file_, System.IntPtr etag_, GISharp.Runtime.Boolean makeBackup_, GISharp.Lib.Gio.FileCreateFlags flags_, System.Int32 ioPriority_, System.IntPtr cancellable_, System.IntPtr callback_, System.IntPtr userData_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var etag = new GISharp.Lib.GLib.NullableUnownedUtf8(etag_, -1);
                        var makeBackup = (System.Boolean)makeBackup_;
                        var flags = (GISharp.Lib.Gio.FileCreateFlags)flags_;
                        var ioPriority = (System.Int32)ioPriority_;
                        var callback = callback_ == null ? default(GISharp.Lib.Gio.AsyncReadyCallback) : GISharp.Lib.Gio.AsyncReadyCallbackMarshal.FromPointer(callback_, userData_);
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doReplaceAsync = (ReplaceAsync)methodInfo.CreateDelegate(typeof(ReplaceAsync), file);
                        doReplaceAsync(etag, makeBackup, flags, ioPriority, callback, cancellable);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }
                }

                return unmanagedReplaceAsync;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='ReplaceFinish']/*" />
        public delegate GISharp.Lib.Gio.FileOutputStream ReplaceFinish(GISharp.Lib.Gio.IAsyncResult res);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileOutputStream" type="GFileOutputStream*" managed-name="FileOutputStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedReplaceFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr res,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
ref System.IntPtr error);

        /// <summary>
        /// Class for marshalling <see cref="ReplaceFinish"/> methods.
        /// </summary>
        public static class ReplaceFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedReplaceFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedReplaceFinish(System.IntPtr file_, System.IntPtr res_, ref System.IntPtr error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var res = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance(res_, GISharp.Runtime.Transfer.None)!;
                        var doReplaceFinish = (ReplaceFinish)methodInfo.CreateDelegate(typeof(ReplaceFinish), file);
                        var ret = doReplaceFinish(res);
                        var ret_ = ret.Take();
                        return ret_;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(ref error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedReplaceFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='DeleteFile']/*" />
        public delegate void DeleteFile(GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:out */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedDeleteFile(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
ref System.IntPtr error);

        /// <summary>
        /// Class for marshalling <see cref="DeleteFile"/> methods.
        /// </summary>
        public static class DeleteFileMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedDeleteFile Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedDeleteFile(System.IntPtr file_, System.IntPtr cancellable_, ref System.IntPtr error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doDeleteFile = (DeleteFile)methodInfo.CreateDelegate(typeof(DeleteFile), file);
                        doDeleteFile(cancellable);
                        return true;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(ref error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(GISharp.Runtime.Boolean);
                }

                return unmanagedDeleteFile;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='DeleteFileAsync']/*" />
        public delegate void DeleteFileAsync(System.Int32 ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        public unsafe delegate void UnmanagedDeleteFileAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
System.Int32 ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="UnmanagedAsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:4 direction:in */
System.IntPtr callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:4 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Class for marshalling <see cref="DeleteFileAsync"/> methods.
        /// </summary>
        public static class DeleteFileAsyncMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedDeleteFileAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedDeleteFileAsync(System.IntPtr file_, System.Int32 ioPriority_, System.IntPtr cancellable_, System.IntPtr callback_, System.IntPtr userData_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var ioPriority = (System.Int32)ioPriority_;
                        var callback = callback_ == null ? default(GISharp.Lib.Gio.AsyncReadyCallback) : GISharp.Lib.Gio.AsyncReadyCallbackMarshal.FromPointer(callback_, userData_);
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doDeleteFileAsync = (DeleteFileAsync)methodInfo.CreateDelegate(typeof(DeleteFileAsync), file);
                        doDeleteFileAsync(ioPriority, callback, cancellable);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }
                }

                return unmanagedDeleteFileAsync;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='DeleteFileFinish']/*" />
        public delegate void DeleteFileFinish(GISharp.Lib.Gio.IAsyncResult result);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:out */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedDeleteFileFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr result,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
ref System.IntPtr error);

        /// <summary>
        /// Class for marshalling <see cref="DeleteFileFinish"/> methods.
        /// </summary>
        public static class DeleteFileFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedDeleteFileFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedDeleteFileFinish(System.IntPtr file_, System.IntPtr result_, ref System.IntPtr error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance(result_, GISharp.Runtime.Transfer.None)!;
                        var doDeleteFileFinish = (DeleteFileFinish)methodInfo.CreateDelegate(typeof(DeleteFileFinish), file);
                        doDeleteFileFinish(result);
                        return true;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(ref error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(GISharp.Runtime.Boolean);
                }

                return unmanagedDeleteFileFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='Trash']/*" />
        public delegate void Trash(GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:out */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedTrash(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
ref System.IntPtr error);

        /// <summary>
        /// Class for marshalling <see cref="Trash"/> methods.
        /// </summary>
        public static class TrashMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedTrash Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedTrash(System.IntPtr file_, System.IntPtr cancellable_, ref System.IntPtr error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doTrash = (Trash)methodInfo.CreateDelegate(typeof(Trash), file);
                        doTrash(cancellable);
                        return true;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(ref error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(GISharp.Runtime.Boolean);
                }

                return unmanagedTrash;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='TrashAsync']/*" />
        public delegate void TrashAsync(System.Int32 ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        public unsafe delegate void UnmanagedTrashAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
System.Int32 ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="UnmanagedAsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:4 direction:in */
System.IntPtr callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:4 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Class for marshalling <see cref="TrashAsync"/> methods.
        /// </summary>
        public static class TrashAsyncMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedTrashAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedTrashAsync(System.IntPtr file_, System.Int32 ioPriority_, System.IntPtr cancellable_, System.IntPtr callback_, System.IntPtr userData_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var ioPriority = (System.Int32)ioPriority_;
                        var callback = callback_ == null ? default(GISharp.Lib.Gio.AsyncReadyCallback) : GISharp.Lib.Gio.AsyncReadyCallbackMarshal.FromPointer(callback_, userData_);
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doTrashAsync = (TrashAsync)methodInfo.CreateDelegate(typeof(TrashAsync), file);
                        doTrashAsync(ioPriority, callback, cancellable);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }
                }

                return unmanagedTrashAsync;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='TrashFinish']/*" />
        public delegate void TrashFinish(GISharp.Lib.Gio.IAsyncResult result);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:out */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedTrashFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr result,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
ref System.IntPtr error);

        /// <summary>
        /// Class for marshalling <see cref="TrashFinish"/> methods.
        /// </summary>
        public static class TrashFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedTrashFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedTrashFinish(System.IntPtr file_, System.IntPtr result_, ref System.IntPtr error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance(result_, GISharp.Runtime.Transfer.None)!;
                        var doTrashFinish = (TrashFinish)methodInfo.CreateDelegate(typeof(TrashFinish), file);
                        doTrashFinish(result);
                        return true;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(ref error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(GISharp.Runtime.Boolean);
                }

                return unmanagedTrashFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='MakeDirectory']/*" />
        public delegate void MakeDirectory(GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:out */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedMakeDirectory(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
ref System.IntPtr error);

        /// <summary>
        /// Class for marshalling <see cref="MakeDirectory"/> methods.
        /// </summary>
        public static class MakeDirectoryMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedMakeDirectory Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedMakeDirectory(System.IntPtr file_, System.IntPtr cancellable_, ref System.IntPtr error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doMakeDirectory = (MakeDirectory)methodInfo.CreateDelegate(typeof(MakeDirectory), file);
                        doMakeDirectory(cancellable);
                        return true;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(ref error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(GISharp.Runtime.Boolean);
                }

                return unmanagedMakeDirectory;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='MakeDirectoryAsync']/*" />
        public delegate void MakeDirectoryAsync(System.Int32 ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        public unsafe delegate void UnmanagedMakeDirectoryAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
System.Int32 ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="UnmanagedAsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:4 direction:in */
System.IntPtr callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:4 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Class for marshalling <see cref="MakeDirectoryAsync"/> methods.
        /// </summary>
        public static class MakeDirectoryAsyncMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedMakeDirectoryAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedMakeDirectoryAsync(System.IntPtr file_, System.Int32 ioPriority_, System.IntPtr cancellable_, System.IntPtr callback_, System.IntPtr userData_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var ioPriority = (System.Int32)ioPriority_;
                        var callback = callback_ == null ? default(GISharp.Lib.Gio.AsyncReadyCallback) : GISharp.Lib.Gio.AsyncReadyCallbackMarshal.FromPointer(callback_, userData_);
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doMakeDirectoryAsync = (MakeDirectoryAsync)methodInfo.CreateDelegate(typeof(MakeDirectoryAsync), file);
                        doMakeDirectoryAsync(ioPriority, callback, cancellable);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }
                }

                return unmanagedMakeDirectoryAsync;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='MakeDirectoryFinish']/*" />
        public delegate void MakeDirectoryFinish(GISharp.Lib.Gio.IAsyncResult result);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:out */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedMakeDirectoryFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr result,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
ref System.IntPtr error);

        /// <summary>
        /// Class for marshalling <see cref="MakeDirectoryFinish"/> methods.
        /// </summary>
        public static class MakeDirectoryFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedMakeDirectoryFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedMakeDirectoryFinish(System.IntPtr file_, System.IntPtr result_, ref System.IntPtr error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance(result_, GISharp.Runtime.Transfer.None)!;
                        var doMakeDirectoryFinish = (MakeDirectoryFinish)methodInfo.CreateDelegate(typeof(MakeDirectoryFinish), file);
                        doMakeDirectoryFinish(result);
                        return true;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(ref error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(GISharp.Runtime.Boolean);
                }

                return unmanagedMakeDirectoryFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='MakeSymbolicLink']/*" />
        public delegate void MakeSymbolicLink(GISharp.Lib.GLib.Filename symlinkValue, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:out */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedMakeSymbolicLink(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="filename" type="const char*" managed-name="GISharp.Lib.GLib.Filename" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr symlinkValue,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
ref System.IntPtr error);

        /// <summary>
        /// Class for marshalling <see cref="MakeSymbolicLink"/> methods.
        /// </summary>
        public static class MakeSymbolicLinkMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedMakeSymbolicLink Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedMakeSymbolicLink(System.IntPtr file_, System.IntPtr symlinkValue_, System.IntPtr cancellable_, ref System.IntPtr error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var symlinkValue = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Filename>(symlinkValue_, GISharp.Runtime.Transfer.None)!;
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doMakeSymbolicLink = (MakeSymbolicLink)methodInfo.CreateDelegate(typeof(MakeSymbolicLink), file);
                        doMakeSymbolicLink(symlinkValue, cancellable);
                        return true;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(ref error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(GISharp.Runtime.Boolean);
                }

                return unmanagedMakeSymbolicLink;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='Copy']/*" />
        public delegate void Copy(GISharp.Lib.Gio.IFile destination, GISharp.Lib.Gio.FileCopyFlags flags, GISharp.Lib.Gio.FileProgressCallback? progressCallback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:out */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedCopy(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr source,
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr destination,
/* <type name="FileCopyFlags" type="GFileCopyFlags" managed-name="FileCopyFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileCopyFlags flags,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="FileProgressCallback" type="GFileProgressCallback" managed-name="UnmanagedFileProgressCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:call closure:5 direction:in */
System.IntPtr progressCallback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr progressCallbackData,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
ref System.IntPtr error);

        /// <summary>
        /// Class for marshalling <see cref="Copy"/> methods.
        /// </summary>
        public static class CopyMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedCopy Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedCopy(System.IntPtr source_, System.IntPtr destination_, GISharp.Lib.Gio.FileCopyFlags flags_, System.IntPtr cancellable_, System.IntPtr progressCallback_, System.IntPtr progressCallbackData_, ref System.IntPtr error_)
                {
                    try
                    {
                        var source = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(source_, GISharp.Runtime.Transfer.None)!;
                        var destination = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(destination_, GISharp.Runtime.Transfer.None)!;
                        var flags = (GISharp.Lib.Gio.FileCopyFlags)flags_;
                        var progressCallback = progressCallback_ == null ? default(GISharp.Lib.Gio.FileProgressCallback) : GISharp.Lib.Gio.FileProgressCallbackMarshal.FromPointer(progressCallback_, progressCallbackData_);
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doCopy = (Copy)methodInfo.CreateDelegate(typeof(Copy), source);
                        doCopy(destination, flags, progressCallback, cancellable);
                        return true;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(ref error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(GISharp.Runtime.Boolean);
                }

                return unmanagedCopy;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='CopyAsync']/*" />
        public delegate void CopyAsync(GISharp.Lib.Gio.IFile destination, GISharp.Lib.Gio.FileCopyFlags flags, System.Int32 ioPriority, GISharp.Lib.Gio.FileProgressCallback? progressCallback, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        public unsafe delegate void UnmanagedCopyAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr source,
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr destination,
/* <type name="FileCopyFlags" type="GFileCopyFlags" managed-name="FileCopyFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileCopyFlags flags,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
System.Int32 ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="FileProgressCallback" type="GFileProgressCallback" managed-name="UnmanagedFileProgressCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:notified closure:6 direction:in */
System.IntPtr progressCallback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:5 direction:in */
System.IntPtr progressCallbackData,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="UnmanagedAsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:8 direction:in */
System.IntPtr callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:7 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Class for marshalling <see cref="CopyAsync"/> methods.
        /// </summary>
        public static class CopyAsyncMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedCopyAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedCopyAsync(System.IntPtr source_, System.IntPtr destination_, GISharp.Lib.Gio.FileCopyFlags flags_, System.Int32 ioPriority_, System.IntPtr cancellable_, System.IntPtr progressCallback_, System.IntPtr progressCallbackData_, System.IntPtr callback_, System.IntPtr userData_)
                {
                    try
                    {
                        var source = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(source_, GISharp.Runtime.Transfer.None)!;
                        var destination = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(destination_, GISharp.Runtime.Transfer.None)!;
                        var flags = (GISharp.Lib.Gio.FileCopyFlags)flags_;
                        var ioPriority = (System.Int32)ioPriority_;
                        var progressCallback = progressCallback_ == null ? default(GISharp.Lib.Gio.FileProgressCallback) : GISharp.Lib.Gio.FileProgressCallbackMarshal.FromPointer(progressCallback_, progressCallbackData_);
                        var callback = callback_ == null ? default(GISharp.Lib.Gio.AsyncReadyCallback) : GISharp.Lib.Gio.AsyncReadyCallbackMarshal.FromPointer(callback_, userData_);
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doCopyAsync = (CopyAsync)methodInfo.CreateDelegate(typeof(CopyAsync), source);
                        doCopyAsync(destination, flags, ioPriority, progressCallback, callback, cancellable);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }
                }

                return unmanagedCopyAsync;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='CopyFinish']/*" />
        public delegate void CopyFinish(GISharp.Lib.Gio.IAsyncResult res);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:out */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedCopyFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr res,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
ref System.IntPtr error);

        /// <summary>
        /// Class for marshalling <see cref="CopyFinish"/> methods.
        /// </summary>
        public static class CopyFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedCopyFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedCopyFinish(System.IntPtr file_, System.IntPtr res_, ref System.IntPtr error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var res = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance(res_, GISharp.Runtime.Transfer.None)!;
                        var doCopyFinish = (CopyFinish)methodInfo.CreateDelegate(typeof(CopyFinish), file);
                        doCopyFinish(res);
                        return true;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(ref error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(GISharp.Runtime.Boolean);
                }

                return unmanagedCopyFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='Move']/*" />
        public delegate void Move(GISharp.Lib.Gio.IFile destination, GISharp.Lib.Gio.FileCopyFlags flags, GISharp.Lib.Gio.FileProgressCallback? progressCallback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:out */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedMove(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr source,
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr destination,
/* <type name="FileCopyFlags" type="GFileCopyFlags" managed-name="FileCopyFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileCopyFlags flags,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="FileProgressCallback" type="GFileProgressCallback" managed-name="UnmanagedFileProgressCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:call closure:5 direction:in */
System.IntPtr progressCallback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr progressCallbackData,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
ref System.IntPtr error);

        /// <summary>
        /// Class for marshalling <see cref="Move"/> methods.
        /// </summary>
        public static class MoveMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedMove Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedMove(System.IntPtr source_, System.IntPtr destination_, GISharp.Lib.Gio.FileCopyFlags flags_, System.IntPtr cancellable_, System.IntPtr progressCallback_, System.IntPtr progressCallbackData_, ref System.IntPtr error_)
                {
                    try
                    {
                        var source = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(source_, GISharp.Runtime.Transfer.None)!;
                        var destination = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(destination_, GISharp.Runtime.Transfer.None)!;
                        var flags = (GISharp.Lib.Gio.FileCopyFlags)flags_;
                        var progressCallback = progressCallback_ == null ? default(GISharp.Lib.Gio.FileProgressCallback) : GISharp.Lib.Gio.FileProgressCallbackMarshal.FromPointer(progressCallback_, progressCallbackData_);
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doMove = (Move)methodInfo.CreateDelegate(typeof(Move), source);
                        doMove(destination, flags, progressCallback, cancellable);
                        return true;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(ref error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(GISharp.Runtime.Boolean);
                }

                return unmanagedMove;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='MountMountableFinish']/*" />
        public delegate GISharp.Lib.Gio.IFile MountMountableFinish(GISharp.Lib.Gio.IAsyncResult result);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedMountMountableFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr result,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
ref System.IntPtr error);

        /// <summary>
        /// Class for marshalling <see cref="MountMountableFinish"/> methods.
        /// </summary>
        public static class MountMountableFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedMountMountableFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedMountMountableFinish(System.IntPtr file_, System.IntPtr result_, ref System.IntPtr error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance(result_, GISharp.Runtime.Transfer.None)!;
                        var doMountMountableFinish = (MountMountableFinish)methodInfo.CreateDelegate(typeof(MountMountableFinish), file);
                        var ret = doMountMountableFinish(result);
                        var ret_ = ret.Take();
                        return ret_;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(ref error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedMountMountableFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmountMountableFinish']/*" />
        public delegate void UnmountMountableFinish(GISharp.Lib.Gio.IAsyncResult result);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:out */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedUnmountMountableFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr result,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
ref System.IntPtr error);

        /// <summary>
        /// Class for marshalling <see cref="UnmountMountableFinish"/> methods.
        /// </summary>
        public static class UnmountMountableFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedUnmountMountableFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedUnmountMountableFinish(System.IntPtr file_, System.IntPtr result_, ref System.IntPtr error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance(result_, GISharp.Runtime.Transfer.None)!;
                        var doUnmountMountableFinish = (UnmountMountableFinish)methodInfo.CreateDelegate(typeof(UnmountMountableFinish), file);
                        doUnmountMountableFinish(result);
                        return true;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(ref error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(GISharp.Runtime.Boolean);
                }

                return unmanagedUnmountMountableFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='EjectMountableFinish']/*" />
        public delegate void EjectMountableFinish(GISharp.Lib.Gio.IAsyncResult result);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:out */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedEjectMountableFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr result,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
ref System.IntPtr error);

        /// <summary>
        /// Class for marshalling <see cref="EjectMountableFinish"/> methods.
        /// </summary>
        public static class EjectMountableFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedEjectMountableFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedEjectMountableFinish(System.IntPtr file_, System.IntPtr result_, ref System.IntPtr error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance(result_, GISharp.Runtime.Transfer.None)!;
                        var doEjectMountableFinish = (EjectMountableFinish)methodInfo.CreateDelegate(typeof(EjectMountableFinish), file);
                        doEjectMountableFinish(result);
                        return true;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(ref error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(GISharp.Runtime.Boolean);
                }

                return unmanagedEjectMountableFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='MountEnclosingVolumeFinish']/*" />
        public delegate void MountEnclosingVolumeFinish(GISharp.Lib.Gio.IAsyncResult result);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:out */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedMountEnclosingVolumeFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr location,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr result,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
ref System.IntPtr error);

        /// <summary>
        /// Class for marshalling <see cref="MountEnclosingVolumeFinish"/> methods.
        /// </summary>
        public static class MountEnclosingVolumeFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedMountEnclosingVolumeFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedMountEnclosingVolumeFinish(System.IntPtr location_, System.IntPtr result_, ref System.IntPtr error_)
                {
                    try
                    {
                        var location = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(location_, GISharp.Runtime.Transfer.None)!;
                        var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance(result_, GISharp.Runtime.Transfer.None)!;
                        var doMountEnclosingVolumeFinish = (MountEnclosingVolumeFinish)methodInfo.CreateDelegate(typeof(MountEnclosingVolumeFinish), location);
                        doMountEnclosingVolumeFinish(result);
                        return true;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(ref error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(GISharp.Runtime.Boolean);
                }

                return unmanagedMountEnclosingVolumeFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='OpenReadwrite']/*" />
        public delegate GISharp.Lib.Gio.FileIOStream OpenReadwrite(GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileIOStream" type="GFileIOStream*" managed-name="FileIOStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedOpenReadwrite(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
ref System.IntPtr error);

        /// <summary>
        /// Class for marshalling <see cref="OpenReadwrite"/> methods.
        /// </summary>
        public static class OpenReadwriteMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedOpenReadwrite Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedOpenReadwrite(System.IntPtr file_, System.IntPtr cancellable_, ref System.IntPtr error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doOpenReadwrite = (OpenReadwrite)methodInfo.CreateDelegate(typeof(OpenReadwrite), file);
                        var ret = doOpenReadwrite(cancellable);
                        var ret_ = ret.Take();
                        return ret_;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(ref error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedOpenReadwrite;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='OpenReadwriteAsync']/*" />
        public delegate void OpenReadwriteAsync(System.Int32 ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        public unsafe delegate void UnmanagedOpenReadwriteAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
System.Int32 ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="UnmanagedAsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:4 direction:in */
System.IntPtr callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:4 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Class for marshalling <see cref="OpenReadwriteAsync"/> methods.
        /// </summary>
        public static class OpenReadwriteAsyncMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedOpenReadwriteAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedOpenReadwriteAsync(System.IntPtr file_, System.Int32 ioPriority_, System.IntPtr cancellable_, System.IntPtr callback_, System.IntPtr userData_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var ioPriority = (System.Int32)ioPriority_;
                        var callback = callback_ == null ? default(GISharp.Lib.Gio.AsyncReadyCallback) : GISharp.Lib.Gio.AsyncReadyCallbackMarshal.FromPointer(callback_, userData_);
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doOpenReadwriteAsync = (OpenReadwriteAsync)methodInfo.CreateDelegate(typeof(OpenReadwriteAsync), file);
                        doOpenReadwriteAsync(ioPriority, callback, cancellable);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }
                }

                return unmanagedOpenReadwriteAsync;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='OpenReadwriteFinish']/*" />
        public delegate GISharp.Lib.Gio.FileIOStream OpenReadwriteFinish(GISharp.Lib.Gio.IAsyncResult res);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileIOStream" type="GFileIOStream*" managed-name="FileIOStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedOpenReadwriteFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr res,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
ref System.IntPtr error);

        /// <summary>
        /// Class for marshalling <see cref="OpenReadwriteFinish"/> methods.
        /// </summary>
        public static class OpenReadwriteFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedOpenReadwriteFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedOpenReadwriteFinish(System.IntPtr file_, System.IntPtr res_, ref System.IntPtr error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var res = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance(res_, GISharp.Runtime.Transfer.None)!;
                        var doOpenReadwriteFinish = (OpenReadwriteFinish)methodInfo.CreateDelegate(typeof(OpenReadwriteFinish), file);
                        var ret = doOpenReadwriteFinish(res);
                        var ret_ = ret.Take();
                        return ret_;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(ref error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedOpenReadwriteFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='CreateReadwrite']/*" />
        public delegate GISharp.Lib.Gio.FileIOStream CreateReadwrite(GISharp.Lib.Gio.FileCreateFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileIOStream" type="GFileIOStream*" managed-name="FileIOStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedCreateReadwrite(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="FileCreateFlags" type="GFileCreateFlags" managed-name="FileCreateFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileCreateFlags flags,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
ref System.IntPtr error);

        /// <summary>
        /// Class for marshalling <see cref="CreateReadwrite"/> methods.
        /// </summary>
        public static class CreateReadwriteMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedCreateReadwrite Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedCreateReadwrite(System.IntPtr file_, GISharp.Lib.Gio.FileCreateFlags flags_, System.IntPtr cancellable_, ref System.IntPtr error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var flags = (GISharp.Lib.Gio.FileCreateFlags)flags_;
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doCreateReadwrite = (CreateReadwrite)methodInfo.CreateDelegate(typeof(CreateReadwrite), file);
                        var ret = doCreateReadwrite(flags, cancellable);
                        var ret_ = ret.Take();
                        return ret_;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(ref error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedCreateReadwrite;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='CreateReadwriteAsync']/*" />
        public delegate void CreateReadwriteAsync(GISharp.Lib.Gio.FileCreateFlags flags, System.Int32 ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        public unsafe delegate void UnmanagedCreateReadwriteAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="FileCreateFlags" type="GFileCreateFlags" managed-name="FileCreateFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileCreateFlags flags,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
System.Int32 ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="UnmanagedAsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:5 direction:in */
System.IntPtr callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:5 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Class for marshalling <see cref="CreateReadwriteAsync"/> methods.
        /// </summary>
        public static class CreateReadwriteAsyncMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedCreateReadwriteAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedCreateReadwriteAsync(System.IntPtr file_, GISharp.Lib.Gio.FileCreateFlags flags_, System.Int32 ioPriority_, System.IntPtr cancellable_, System.IntPtr callback_, System.IntPtr userData_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var flags = (GISharp.Lib.Gio.FileCreateFlags)flags_;
                        var ioPriority = (System.Int32)ioPriority_;
                        var callback = callback_ == null ? default(GISharp.Lib.Gio.AsyncReadyCallback) : GISharp.Lib.Gio.AsyncReadyCallbackMarshal.FromPointer(callback_, userData_);
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doCreateReadwriteAsync = (CreateReadwriteAsync)methodInfo.CreateDelegate(typeof(CreateReadwriteAsync), file);
                        doCreateReadwriteAsync(flags, ioPriority, callback, cancellable);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }
                }

                return unmanagedCreateReadwriteAsync;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='CreateReadwriteFinish']/*" />
        public delegate GISharp.Lib.Gio.FileIOStream CreateReadwriteFinish(GISharp.Lib.Gio.IAsyncResult res);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileIOStream" type="GFileIOStream*" managed-name="FileIOStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedCreateReadwriteFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr res,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
ref System.IntPtr error);

        /// <summary>
        /// Class for marshalling <see cref="CreateReadwriteFinish"/> methods.
        /// </summary>
        public static class CreateReadwriteFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedCreateReadwriteFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedCreateReadwriteFinish(System.IntPtr file_, System.IntPtr res_, ref System.IntPtr error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var res = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance(res_, GISharp.Runtime.Transfer.None)!;
                        var doCreateReadwriteFinish = (CreateReadwriteFinish)methodInfo.CreateDelegate(typeof(CreateReadwriteFinish), file);
                        var ret = doCreateReadwriteFinish(res);
                        var ret_ = ret.Take();
                        return ret_;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(ref error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedCreateReadwriteFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='ReplaceReadwrite']/*" />
        public delegate GISharp.Lib.Gio.FileIOStream ReplaceReadwrite(GISharp.Lib.GLib.NullableUnownedUtf8 etag, System.Boolean makeBackup, GISharp.Lib.Gio.FileCreateFlags flags, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileIOStream" type="GFileIOStream*" managed-name="FileIOStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedReplaceReadwrite(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr etag,
/* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
/* transfer-ownership:none direction:in */
GISharp.Runtime.Boolean makeBackup,
/* <type name="FileCreateFlags" type="GFileCreateFlags" managed-name="FileCreateFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileCreateFlags flags,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
ref System.IntPtr error);

        /// <summary>
        /// Class for marshalling <see cref="ReplaceReadwrite"/> methods.
        /// </summary>
        public static class ReplaceReadwriteMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedReplaceReadwrite Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedReplaceReadwrite(System.IntPtr file_, System.IntPtr etag_, GISharp.Runtime.Boolean makeBackup_, GISharp.Lib.Gio.FileCreateFlags flags_, System.IntPtr cancellable_, ref System.IntPtr error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var etag = new GISharp.Lib.GLib.NullableUnownedUtf8(etag_, -1);
                        var makeBackup = (System.Boolean)makeBackup_;
                        var flags = (GISharp.Lib.Gio.FileCreateFlags)flags_;
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doReplaceReadwrite = (ReplaceReadwrite)methodInfo.CreateDelegate(typeof(ReplaceReadwrite), file);
                        var ret = doReplaceReadwrite(etag, makeBackup, flags, cancellable);
                        var ret_ = ret.Take();
                        return ret_;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(ref error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedReplaceReadwrite;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='ReplaceReadwriteAsync']/*" />
        public delegate void ReplaceReadwriteAsync(GISharp.Lib.GLib.NullableUnownedUtf8 etag, System.Boolean makeBackup, GISharp.Lib.Gio.FileCreateFlags flags, System.Int32 ioPriority, GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        public unsafe delegate void UnmanagedReplaceReadwriteAsync(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="utf8" type="const char*" managed-name="GISharp.Lib.GLib.Utf8" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr etag,
/* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
/* transfer-ownership:none direction:in */
GISharp.Runtime.Boolean makeBackup,
/* <type name="FileCreateFlags" type="GFileCreateFlags" managed-name="FileCreateFlags" /> */
/* transfer-ownership:none direction:in */
GISharp.Lib.Gio.FileCreateFlags flags,
/* <type name="gint" type="int" managed-name="System.Int32" /> */
/* transfer-ownership:none direction:in */
System.Int32 ioPriority,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="UnmanagedAsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:7 direction:in */
System.IntPtr callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:7 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Class for marshalling <see cref="ReplaceReadwriteAsync"/> methods.
        /// </summary>
        public static class ReplaceReadwriteAsyncMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedReplaceReadwriteAsync Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedReplaceReadwriteAsync(System.IntPtr file_, System.IntPtr etag_, GISharp.Runtime.Boolean makeBackup_, GISharp.Lib.Gio.FileCreateFlags flags_, System.Int32 ioPriority_, System.IntPtr cancellable_, System.IntPtr callback_, System.IntPtr userData_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var etag = new GISharp.Lib.GLib.NullableUnownedUtf8(etag_, -1);
                        var makeBackup = (System.Boolean)makeBackup_;
                        var flags = (GISharp.Lib.Gio.FileCreateFlags)flags_;
                        var ioPriority = (System.Int32)ioPriority_;
                        var callback = callback_ == null ? default(GISharp.Lib.Gio.AsyncReadyCallback) : GISharp.Lib.Gio.AsyncReadyCallbackMarshal.FromPointer(callback_, userData_);
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doReplaceReadwriteAsync = (ReplaceReadwriteAsync)methodInfo.CreateDelegate(typeof(ReplaceReadwriteAsync), file);
                        doReplaceReadwriteAsync(etag, makeBackup, flags, ioPriority, callback, cancellable);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }
                }

                return unmanagedReplaceReadwriteAsync;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='ReplaceReadwriteFinish']/*" />
        public delegate GISharp.Lib.Gio.FileIOStream ReplaceReadwriteFinish(GISharp.Lib.Gio.IAsyncResult res);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="FileIOStream" type="GFileIOStream*" managed-name="FileIOStream" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        public unsafe delegate System.IntPtr UnmanagedReplaceReadwriteFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr res,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
ref System.IntPtr error);

        /// <summary>
        /// Class for marshalling <see cref="ReplaceReadwriteFinish"/> methods.
        /// </summary>
        public static class ReplaceReadwriteFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedReplaceReadwriteFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                System.IntPtr unmanagedReplaceReadwriteFinish(System.IntPtr file_, System.IntPtr res_, ref System.IntPtr error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var res = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance(res_, GISharp.Runtime.Transfer.None)!;
                        var doReplaceReadwriteFinish = (ReplaceReadwriteFinish)methodInfo.CreateDelegate(typeof(ReplaceReadwriteFinish), file);
                        var ret = doReplaceReadwriteFinish(res);
                        var ret_ = ret.Take();
                        return ret_;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(ref error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(System.IntPtr);
                }

                return unmanagedReplaceReadwriteFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='StartMountableFinish']/*" />
        public delegate void StartMountableFinish(GISharp.Lib.Gio.IAsyncResult result);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:out */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedStartMountableFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr result,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
ref System.IntPtr error);

        /// <summary>
        /// Class for marshalling <see cref="StartMountableFinish"/> methods.
        /// </summary>
        public static class StartMountableFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedStartMountableFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedStartMountableFinish(System.IntPtr file_, System.IntPtr result_, ref System.IntPtr error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance(result_, GISharp.Runtime.Transfer.None)!;
                        var doStartMountableFinish = (StartMountableFinish)methodInfo.CreateDelegate(typeof(StartMountableFinish), file);
                        doStartMountableFinish(result);
                        return true;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(ref error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(GISharp.Runtime.Boolean);
                }

                return unmanagedStartMountableFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='StopMountableFinish']/*" />
        public delegate void StopMountableFinish(GISharp.Lib.Gio.IAsyncResult result);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:out */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedStopMountableFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr result,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
ref System.IntPtr error);

        /// <summary>
        /// Class for marshalling <see cref="StopMountableFinish"/> methods.
        /// </summary>
        public static class StopMountableFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedStopMountableFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedStopMountableFinish(System.IntPtr file_, System.IntPtr result_, ref System.IntPtr error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance(result_, GISharp.Runtime.Transfer.None)!;
                        var doStopMountableFinish = (StopMountableFinish)methodInfo.CreateDelegate(typeof(StopMountableFinish), file);
                        doStopMountableFinish(result);
                        return true;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(ref error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(GISharp.Runtime.Boolean);
                }

                return unmanagedStopMountableFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='UnmountMountableWithOperationFinish']/*" />
        public delegate void UnmountMountableWithOperationFinish(GISharp.Lib.Gio.IAsyncResult result);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:out */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedUnmountMountableWithOperationFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr result,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
ref System.IntPtr error);

        /// <summary>
        /// Class for marshalling <see cref="UnmountMountableWithOperationFinish"/> methods.
        /// </summary>
        public static class UnmountMountableWithOperationFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedUnmountMountableWithOperationFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedUnmountMountableWithOperationFinish(System.IntPtr file_, System.IntPtr result_, ref System.IntPtr error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance(result_, GISharp.Runtime.Transfer.None)!;
                        var doUnmountMountableWithOperationFinish = (UnmountMountableWithOperationFinish)methodInfo.CreateDelegate(typeof(UnmountMountableWithOperationFinish), file);
                        doUnmountMountableWithOperationFinish(result);
                        return true;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(ref error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(GISharp.Runtime.Boolean);
                }

                return unmanagedUnmountMountableWithOperationFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='EjectMountableWithOperationFinish']/*" />
        public delegate void EjectMountableWithOperationFinish(GISharp.Lib.Gio.IAsyncResult result);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:out */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedEjectMountableWithOperationFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr result,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
ref System.IntPtr error);

        /// <summary>
        /// Class for marshalling <see cref="EjectMountableWithOperationFinish"/> methods.
        /// </summary>
        public static class EjectMountableWithOperationFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedEjectMountableWithOperationFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedEjectMountableWithOperationFinish(System.IntPtr file_, System.IntPtr result_, ref System.IntPtr error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance(result_, GISharp.Runtime.Transfer.None)!;
                        var doEjectMountableWithOperationFinish = (EjectMountableWithOperationFinish)methodInfo.CreateDelegate(typeof(EjectMountableWithOperationFinish), file);
                        doEjectMountableWithOperationFinish(result);
                        return true;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(ref error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(GISharp.Runtime.Boolean);
                }

                return unmanagedEjectMountableWithOperationFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='PollMountable']/*" />
        public delegate void PollMountable(GISharp.Lib.Gio.AsyncReadyCallback? callback, GISharp.Lib.Gio.Cancellable? cancellable = null);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Void" /> */
        /* transfer-ownership:none direction:out */
        public unsafe delegate void UnmanagedPollMountable(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 direction:in */
System.IntPtr cancellable,
/* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="UnmanagedAsyncReadyCallback" /> */
/* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:3 direction:in */
System.IntPtr callback,
/* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
/* transfer-ownership:none nullable:1 allow-none:1 closure:3 direction:in */
System.IntPtr userData);

        /// <summary>
        /// Class for marshalling <see cref="PollMountable"/> methods.
        /// </summary>
        public static class PollMountableMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedPollMountable Create(System.Reflection.MethodInfo methodInfo)
            {
                void unmanagedPollMountable(System.IntPtr file_, System.IntPtr cancellable_, System.IntPtr callback_, System.IntPtr userData_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var callback = callback_ == null ? default(GISharp.Lib.Gio.AsyncReadyCallback) : GISharp.Lib.Gio.AsyncReadyCallbackMarshal.FromPointer(callback_, userData_);
                        var cancellable = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.Gio.Cancellable>(cancellable_, GISharp.Runtime.Transfer.None);
                        var doPollMountable = (PollMountable)methodInfo.CreateDelegate(typeof(PollMountable), file);
                        doPollMountable(callback, cancellable);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }
                }

                return unmanagedPollMountable;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='PollMountableFinish']/*" />
        public delegate void PollMountableFinish(GISharp.Lib.Gio.IAsyncResult result);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:out */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedPollMountableFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr result,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
ref System.IntPtr error);

        /// <summary>
        /// Class for marshalling <see cref="PollMountableFinish"/> methods.
        /// </summary>
        public static class PollMountableFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedPollMountableFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedPollMountableFinish(System.IntPtr file_, System.IntPtr result_, ref System.IntPtr error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance(result_, GISharp.Runtime.Transfer.None)!;
                        var doPollMountableFinish = (PollMountableFinish)methodInfo.CreateDelegate(typeof(PollMountableFinish), file);
                        doPollMountableFinish(result);
                        return true;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(ref error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    return default(GISharp.Runtime.Boolean);
                }

                return unmanagedPollMountableFinish;
            }
        }

        /// <include file="FileIface.xmldoc" path="declaration/member[@name='MeasureDiskUsageFinish']/*" />
        public delegate void MeasureDiskUsageFinish(GISharp.Lib.Gio.IAsyncResult result, out System.UInt64 diskUsage, out System.UInt64 numDirs, out System.UInt64 numFiles);

        /// <summary>
        /// Unmanaged callback
        /// </summary>
        [System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:out */
        public unsafe delegate GISharp.Runtime.Boolean UnmanagedMeasureDiskUsageFinish(
/* <type name="File" type="GFile*" managed-name="File" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr file,
/* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
/* transfer-ownership:none direction:in */
System.IntPtr result,
/* <type name="guint64" type="guint64*" managed-name="System.UInt64" is-pointer="1" /> */
/* direction:out caller-allocates:0 transfer-ownership:full optional:1 allow-none:1 */
out System.UInt64 diskUsage,
/* <type name="guint64" type="guint64*" managed-name="System.UInt64" is-pointer="1" /> */
/* direction:out caller-allocates:0 transfer-ownership:full optional:1 allow-none:1 */
out System.UInt64 numDirs,
/* <type name="guint64" type="guint64*" managed-name="System.UInt64" is-pointer="1" /> */
/* direction:out caller-allocates:0 transfer-ownership:full optional:1 allow-none:1 */
out System.UInt64 numFiles,
/* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
/* direction:inout transfer-ownership:full */
ref System.IntPtr error);

        /// <summary>
        /// Class for marshalling <see cref="MeasureDiskUsageFinish"/> methods.
        /// </summary>
        public static class MeasureDiskUsageFinishMarshal
        {
            /// <summary>
            /// Creates an unmanaged delegate from a managed delegate.
            /// </summary>
            public static unsafe UnmanagedMeasureDiskUsageFinish Create(System.Reflection.MethodInfo methodInfo)
            {
                GISharp.Runtime.Boolean unmanagedMeasureDiskUsageFinish(System.IntPtr file_, System.IntPtr result_, out System.UInt64 diskUsage_, out System.UInt64 numDirs_, out System.UInt64 numFiles_, ref System.IntPtr error_)
                {
                    try
                    {
                        var file = (GISharp.Lib.Gio.IFile)GISharp.Lib.GObject.Object.GetInstance(file_, GISharp.Runtime.Transfer.None)!;
                        var result = (GISharp.Lib.Gio.IAsyncResult)GISharp.Lib.GObject.Object.GetInstance(result_, GISharp.Runtime.Transfer.None)!;
                        var doMeasureDiskUsageFinish = (MeasureDiskUsageFinish)methodInfo.CreateDelegate(typeof(MeasureDiskUsageFinish), file);
                        doMeasureDiskUsageFinish(result,out var diskUsage,out var numDirs,out var numFiles);
                        diskUsage_ = diskUsage;
                        numDirs_ = numDirs;
                        numFiles_ = numFiles;
                        return true;
                    }
                    catch (GISharp.Runtime.GErrorException ex)
                    {
                        GISharp.Runtime.GMarshal.PropagateError(ref error_, ex.Error);
                    }
                    catch (System.Exception ex)
                    {
                        GISharp.Lib.GLib.Log.LogUnhandledException(ex);
                    }

                    diskUsage_ = default(System.UInt64);
                    numDirs_ = default(System.UInt64);
                    numFiles_ = default(System.UInt64);
                    return default(GISharp.Runtime.Boolean);
                }

                return unmanagedMeasureDiskUsageFinish;
            }
        }

        /// <summary>
        /// For internal runtime use only.
        /// </summary>
        public FileIface(System.IntPtr handle, GISharp.Runtime.Transfer ownership) : base(handle, ownership)
        {
        }
    }
}