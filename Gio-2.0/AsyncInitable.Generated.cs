// ATTENTION: This file is automatically generated. Do not edit by manually.
namespace GISharp.Lib.Gio
{
    /// <summary>
    /// This is the asynchronous version of <see cref="IInitable"/>; it behaves the same
    /// in all ways except that initialization is asynchronous. For more details
    /// see the descriptions on <see cref="IInitable"/>.
    /// </summary>
    /// <remarks>
    /// A class may implement both the <see cref="IInitable"/> and <see cref="IAsyncInitable"/> interfaces.
    /// 
    /// Users of objects implementing this are not intended to use the interface
    /// method directly; instead it will be used automatically in various ways.
    /// For C applications you generally just call g_async_initable_new_async()
    /// directly, or indirectly via a foo_thing_new_async() wrapper. This will call
    /// <see cref="AsyncInitable.InitAsync"/> under the cover, calling back with <c>null</c> and
    /// a set %GError on failure.
    /// 
    /// A typical implementation might look something like this:
    /// 
    /// |[&lt;!-- language="C" --&gt;
    /// enum {
    ///    NOT_INITIALIZED,
    ///    INITIALIZING,
    ///    INITIALIZED
    /// };
    /// 
    /// static void
    /// _foo_ready_cb (Foo *self)
    /// {
    ///   GList *l;
    /// 
    ///   self-&gt;priv-&gt;state = INITIALIZED;
    /// 
    ///   for (l = self-&gt;priv-&gt;init_results; l != NULL; l = l-&gt;next)
    ///     {
    ///       GTask *task = l-&gt;data;
    /// 
    ///       if (self-&gt;priv-&gt;success)
    ///         g_task_return_boolean (task, TRUE);
    ///       else
    ///         g_task_return_new_error (task, ...);
    ///       g_object_unref (task);
    ///     }
    /// 
    ///   g_list_free (self-&gt;priv-&gt;init_results);
    ///   self-&gt;priv-&gt;init_results = NULL;
    /// }
    /// 
    /// static void
    /// foo_init_async (GAsyncInitable       *initable,
    ///                 int                   io_priority,
    ///                 GCancellable         *cancellable,
    ///                 GAsyncReadyCallback   callback,
    ///                 gpointer              user_data)
    /// {
    ///   Foo *self = FOO (initable);
    ///   GTask *task;
    /// 
    ///   task = g_task_new (initable, cancellable, callback, user_data);
    /// 
    ///   switch (self-&gt;priv-&gt;state)
    ///     {
    ///       case NOT_INITIALIZED:
    ///         _foo_get_ready (self);
    ///         self-&gt;priv-&gt;init_results = g_list_append (self-&gt;priv-&gt;init_results,
    ///                                                   task);
    ///         self-&gt;priv-&gt;state = INITIALIZING;
    ///         break;
    ///       case INITIALIZING:
    ///         self-&gt;priv-&gt;init_results = g_list_append (self-&gt;priv-&gt;init_results,
    ///                                                   task);
    ///         break;
    ///       case INITIALIZED:
    ///         if (!self-&gt;priv-&gt;success)
    ///           g_task_return_new_error (task, ...);
    ///         else
    ///           g_task_return_boolean (task, TRUE);
    ///         g_object_unref (task);
    ///         break;
    ///     }
    /// }
    /// 
    /// static gboolean
    /// foo_init_finish (GAsyncInitable       *initable,
    ///                  GAsyncResult         *result,
    ///                  GError              **error)
    /// {
    ///   g_return_val_if_fail (g_task_is_valid (result, initable), FALSE);
    /// 
    ///   return g_task_propagate_boolean (G_TASK (result), error);
    /// }
    /// 
    /// static void
    /// foo_async_initable_iface_init (gpointer g_iface,
    ///                                gpointer data)
    /// {
    ///   GAsyncInitableIface *iface = g_iface;
    /// 
    ///   iface-&gt;init_async = foo_init_async;
    ///   iface-&gt;init_finish = foo_init_finish;
    /// }
    /// ]|
    /// </remarks>
    [GISharp.Runtime.SinceAttribute("2.22")]
    [GISharp.Runtime.GTypeAttribute("GAsyncInitable", IsProxyForUnmanagedType = true)]
    [GISharp.Runtime.GTypeStructAttribute(typeof(AsyncInitableIface))]
    public partial interface IAsyncInitable : GISharp.Runtime.GInterface<GISharp.Lib.GObject.Object>
    {
        /// <summary>
        /// Starts asynchronous initialization of the object implementing the
        /// interface. This must be done before any real use of the object after
        /// initial construction. If the object also implements <see cref="IInitable"/> you can
        /// optionally call <see cref="Initable.Init"/> instead.
        /// </summary>
        /// <remarks>
        /// This method is intended for language bindings. If writing in C,
        /// g_async_initable_new_async() should typically be used instead.
        /// 
        /// When the initialization is finished, <paramref name="callback"/> will be called. You can
        /// then call <see cref="AsyncInitable.InitFinish"/> to get the result of the
        /// initialization.
        /// 
        /// Implementations may also support cancellation. If <paramref name="cancellable"/> is not
        /// <c>null</c>, then initialization can be cancelled by triggering the cancellable
        /// object from another thread. If the operation was cancelled, the error
        /// <see cref="IOErrorEnum.Cancelled"/> will be returned. If <paramref name="cancellable"/> is not <c>null</c>, and
        /// the object doesn't support cancellable initialization, the error
        /// <see cref="IOErrorEnum.NotSupported"/> will be returned.
        /// 
        /// As with <see cref="IInitable"/>, if the object is not initialized, or initialization
        /// returns with an error, then all operations on the object except
        /// g_object_ref() and g_object_unref() are considered to be invalid, and
        /// have undefined behaviour. They will often fail with g_critical() or
        /// g_warning(), but this must not be relied on.
        /// 
        /// Callers should not assume that a class which implements <see cref="IAsyncInitable"/> can
        /// be initialized multiple times; for more information, see <see cref="Initable.Init"/>.
        /// If a class explicitly supports being initialized multiple times,
        /// implementation requires yielding all subsequent calls to init_async() on the
        /// results of the first call.
        /// 
        /// For classes that also support the <see cref="IInitable"/> interface, the default
        /// implementation of this method will run the <see cref="Initable.Init"/> function
        /// in a thread, so if you want to support asynchronous initialization via
        /// threads, just implement the <see cref="IAsyncInitable"/> interface without overriding
        /// any interface methods.
        /// </remarks>
        /// <param name="ioPriority">
        /// the [I/O priority][io-priority] of the operation
        /// </param>
        /// <param name="callback">
        /// a <see cref="AsyncReadyCallback"/> to call when the request is satisfied
        /// </param>
        /// <param name="cancellable">
        /// optional <see cref="Cancellable"/> object, <c>null</c> to ignore.
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.22")]
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(AsyncInitableIface.UnmanagedInitAsync))]
        void DoInitAsync(System.Int32 ioPriority, GISharp.Lib.Gio.AsyncReadyCallback callback, GISharp.Lib.Gio.Cancellable cancellable = null);

        /// <summary>
        /// Finishes asynchronous initialization and returns the result.
        /// See <see cref="AsyncInitable.InitAsync"/>.
        /// </summary>
        /// <param name="res">
        /// a <see cref="IAsyncResult"/>.
        /// </param>
        /// <returns>
        /// <c>true</c> if successful. If an error has occurred, this function
        /// will return <c>false</c> and set <paramref name="error"/> appropriately if present.
        /// </returns>
        /// <exception name="GISharp.Runtime.GErrorException">
        /// On error
        /// </exception>
        [GISharp.Runtime.SinceAttribute("2.22")]
        [GISharp.Runtime.GVirtualMethodAttribute(typeof(AsyncInitableIface.UnmanagedInitFinish))]
        void DoInitFinish(GISharp.Lib.Gio.IAsyncResult res);
    }

    public static partial class AsyncInitable
    {
        static readonly GISharp.Lib.GObject.GType _GType = g_async_initable_get_type();

        /// <summary>
        /// Helper function for constructing #GAsyncInitable object. This is
        /// similar to g_object_newv() but also initializes the object asynchronously.
        /// </summary>
        /// <remarks>
        /// When the initialization is finished, @callback will be called. You can
        /// then call g_async_initable_new_finish() to get the new object and check
        /// for any errors.
        /// </remarks>
        /// <param name="objectType">
        /// a #GType supporting #GAsyncInitable.
        /// </param>
        /// <param name="nParameters">
        /// the number of parameters in @parameters
        /// </param>
        /// <param name="parameters">
        /// the parameters to use to construct the object
        /// </param>
        /// <param name="ioPriority">
        /// the [I/O priority][io-priority] of the operation
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object, %NULL to ignore.
        /// </param>
        /// <param name="callback">
        /// a #GAsyncReadyCallback to call when the initialization is
        ///     finished
        /// </param>
        /// <param name="userData">
        /// the data to pass to callback function
        /// </param>
        [System.ObsoleteAttribute("Use g_object_new_with_properties() and\ng_async_initable_init_async() instead. See #GParameter for more information.")]
        [GISharp.Runtime.DeprecatedSinceAttribute("2.54")]
        [GISharp.Runtime.SinceAttribute("2.22")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Threading.Tasks.Task">
*   <type name="GObject.Object" type="GObject*" managed-name="GISharp.Lib.GObject.Object" is-pointer="1" />
* </type> */
        /* transfer-ownership:none direction:out */
        static extern unsafe void g_async_initable_newv_async(
        /* <type name="GType" type="GType" managed-name="GISharp.Lib.GObject.GType" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.GType objectType,
        /* <type name="guint" type="guint" managed-name="System.UInt32" /> */
        /* transfer-ownership:none direction:in */
        System.UInt32 nParameters,
        /* <type name="GObject.Parameter" type="GParameter*" managed-name="GISharp.Lib.GObject.Parameter" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        GISharp.Lib.GObject.Parameter* parameters,
        /* <type name="gint" type="int" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        System.Int32 ioPriority,
        /* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr cancellable,
        /* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="UnmanagedAsyncReadyCallback" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:6 direction:in */
        GISharp.Lib.Gio.UnmanagedAsyncReadyCallback callback,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr userData);

        /// <summary>
        /// Helper function for constructing <see cref="IAsyncInitable"/> object. This is
        /// similar to g_object_newv() but also initializes the object asynchronously.
        /// </summary>
        /// <remarks>
        /// When the initialization is finished, <paramref name="callback"/> will be called. You can
        /// then call <see cref="AsyncInitable.NewFinish"/> to get the new object and check
        /// for any errors.
        /// </remarks>
        /// <param name="objectType">
        /// a #GType supporting <see cref="IAsyncInitable"/>.
        /// </param>
        /// <param name="nParameters">
        /// the number of parameters in <paramref name="parameters"/>
        /// </param>
        /// <param name="parameters">
        /// the parameters to use to construct the object
        /// </param>
        /// <param name="ioPriority">
        /// the [I/O priority][io-priority] of the operation
        /// </param>
        /// <param name="cancellable">
        /// optional <see cref="Cancellable"/> object, <c>null</c> to ignore.
        /// </param>
        [System.ObsoleteAttribute("Use g_object_new_with_properties() and\ng_async_initable_init_async() instead. See #GParameter for more information.")]
        [GISharp.Runtime.DeprecatedSinceAttribute("2.54")]
        [GISharp.Runtime.SinceAttribute("2.22")]
        public static unsafe System.Threading.Tasks.Task<GISharp.Lib.GObject.Object> NewAsync(GISharp.Lib.GObject.GType objectType, System.UInt32 nParameters, GISharp.Lib.GObject.Parameter parameters, System.Int32 ioPriority, GISharp.Lib.Gio.Cancellable cancellable = null)
        {
            var objectType_ = (GISharp.Lib.GObject.GType)objectType;
            var nParameters_ = (System.UInt32)nParameters;
            var parameters_ = (GISharp.Lib.GObject.Parameter)parameters;
            var ioPriority_ = (System.Int32)ioPriority;
            var cancellable_ = cancellable?.Handle ?? System.IntPtr.Zero;
            var completionSource = new System.Threading.Tasks.TaskCompletionSource<GISharp.Lib.GObject.Object>();
            var callback_ = newAsyncCallbackDelegate;
            var userData_ = (System.IntPtr)System.Runtime.InteropServices.GCHandle.Alloc(completionSource);
            g_async_initable_newv_async(objectType_, nParameters_, &parameters_, ioPriority_, cancellable_, callback_, userData_);
            return completionSource.Task;
        }

        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="GType" type="GType" managed-name="GISharp.Lib.GObject.GType" /> */
        /* transfer-ownership:full direction:out */
        static extern unsafe GISharp.Lib.GObject.GType g_async_initable_get_type();

        /// <summary>
        /// Starts asynchronous initialization of the object implementing the
        /// interface. This must be done before any real use of the object after
        /// initial construction. If the object also implements #GInitable you can
        /// optionally call g_initable_init() instead.
        /// </summary>
        /// <remarks>
        /// This method is intended for language bindings. If writing in C,
        /// g_async_initable_new_async() should typically be used instead.
        /// 
        /// When the initialization is finished, @callback will be called. You can
        /// then call g_async_initable_init_finish() to get the result of the
        /// initialization.
        /// 
        /// Implementations may also support cancellation. If @cancellable is not
        /// %NULL, then initialization can be cancelled by triggering the cancellable
        /// object from another thread. If the operation was cancelled, the error
        /// %G_IO_ERROR_CANCELLED will be returned. If @cancellable is not %NULL, and
        /// the object doesn't support cancellable initialization, the error
        /// %G_IO_ERROR_NOT_SUPPORTED will be returned.
        /// 
        /// As with #GInitable, if the object is not initialized, or initialization
        /// returns with an error, then all operations on the object except
        /// g_object_ref() and g_object_unref() are considered to be invalid, and
        /// have undefined behaviour. They will often fail with g_critical() or
        /// g_warning(), but this must not be relied on.
        /// 
        /// Callers should not assume that a class which implements #GAsyncInitable can
        /// be initialized multiple times; for more information, see g_initable_init().
        /// If a class explicitly supports being initialized multiple times,
        /// implementation requires yielding all subsequent calls to init_async() on the
        /// results of the first call.
        /// 
        /// For classes that also support the #GInitable interface, the default
        /// implementation of this method will run the g_initable_init() function
        /// in a thread, so if you want to support asynchronous initialization via
        /// threads, just implement the #GAsyncInitable interface without overriding
        /// any interface methods.
        /// </remarks>
        /// <param name="initable">
        /// a #GAsyncInitable.
        /// </param>
        /// <param name="ioPriority">
        /// the [I/O priority][io-priority] of the operation
        /// </param>
        /// <param name="cancellable">
        /// optional #GCancellable object, %NULL to ignore.
        /// </param>
        /// <param name="callback">
        /// a #GAsyncReadyCallback to call when the request is satisfied
        /// </param>
        /// <param name="userData">
        /// the data to pass to callback function
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.22")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="none" type="void" managed-name="System.Threading.Tasks.Task" /> */
        /* transfer-ownership:none direction:out */
        static extern unsafe void g_async_initable_init_async(
        /* <type name="AsyncInitable" type="GAsyncInitable*" managed-name="AsyncInitable" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr initable,
        /* <type name="gint" type="int" managed-name="System.Int32" /> */
        /* transfer-ownership:none direction:in */
        System.Int32 ioPriority,
        /* <type name="Cancellable" type="GCancellable*" managed-name="Cancellable" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr cancellable,
        /* <type name="AsyncReadyCallback" type="GAsyncReadyCallback" managed-name="UnmanagedAsyncReadyCallback" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 scope:async closure:3 direction:in */
        GISharp.Lib.Gio.UnmanagedAsyncReadyCallback callback,
        /* <type name="gpointer" type="gpointer" managed-name="System.IntPtr" is-pointer="1" /> */
        /* transfer-ownership:none nullable:1 allow-none:1 direction:in */
        System.IntPtr userData);

        /// <summary>
        /// Starts asynchronous initialization of the object implementing the
        /// interface. This must be done before any real use of the object after
        /// initial construction. If the object also implements <see cref="IInitable"/> you can
        /// optionally call <see cref="Initable.Init"/> instead.
        /// </summary>
        /// <remarks>
        /// This method is intended for language bindings. If writing in C,
        /// g_async_initable_new_async() should typically be used instead.
        /// 
        /// When the initialization is finished, <paramref name="callback"/> will be called. You can
        /// then call <see cref="AsyncInitable.InitFinish"/> to get the result of the
        /// initialization.
        /// 
        /// Implementations may also support cancellation. If <paramref name="cancellable"/> is not
        /// <c>null</c>, then initialization can be cancelled by triggering the cancellable
        /// object from another thread. If the operation was cancelled, the error
        /// <see cref="IOErrorEnum.Cancelled"/> will be returned. If <paramref name="cancellable"/> is not <c>null</c>, and
        /// the object doesn't support cancellable initialization, the error
        /// <see cref="IOErrorEnum.NotSupported"/> will be returned.
        /// 
        /// As with <see cref="IInitable"/>, if the object is not initialized, or initialization
        /// returns with an error, then all operations on the object except
        /// g_object_ref() and g_object_unref() are considered to be invalid, and
        /// have undefined behaviour. They will often fail with g_critical() or
        /// g_warning(), but this must not be relied on.
        /// 
        /// Callers should not assume that a class which implements <see cref="IAsyncInitable"/> can
        /// be initialized multiple times; for more information, see <see cref="Initable.Init"/>.
        /// If a class explicitly supports being initialized multiple times,
        /// implementation requires yielding all subsequent calls to init_async() on the
        /// results of the first call.
        /// 
        /// For classes that also support the <see cref="IInitable"/> interface, the default
        /// implementation of this method will run the <see cref="Initable.Init"/> function
        /// in a thread, so if you want to support asynchronous initialization via
        /// threads, just implement the <see cref="IAsyncInitable"/> interface without overriding
        /// any interface methods.
        /// </remarks>
        /// <param name="initable">
        /// a <see cref="IAsyncInitable"/>.
        /// </param>
        /// <param name="ioPriority">
        /// the [I/O priority][io-priority] of the operation
        /// </param>
        /// <param name="cancellable">
        /// optional <see cref="Cancellable"/> object, <c>null</c> to ignore.
        /// </param>
        [GISharp.Runtime.SinceAttribute("2.22")]
        public unsafe static System.Threading.Tasks.Task InitAsync(this GISharp.Lib.Gio.IAsyncInitable initable, System.Int32 ioPriority, GISharp.Lib.Gio.Cancellable cancellable = null)
        {
            var initable_ = initable?.Handle ?? throw new System.ArgumentNullException(nameof(initable));
            var ioPriority_ = (System.Int32)ioPriority;
            var cancellable_ = cancellable?.Handle ?? System.IntPtr.Zero;
            var completionSource = new System.Threading.Tasks.TaskCompletionSource<System.Object>();
            var callback_ = initAsyncCallbackDelegate;
            var userData_ = (System.IntPtr)System.Runtime.InteropServices.GCHandle.Alloc(completionSource);
            g_async_initable_init_async(initable_, ioPriority_, cancellable_, callback_, userData_);
            return completionSource.Task;
        }

        /// <summary>
        /// Finishes asynchronous initialization and returns the result.
        /// See g_async_initable_init_async().
        /// </summary>
        /// <param name="initable">
        /// a #GAsyncInitable.
        /// </param>
        /// <param name="res">
        /// a #GAsyncResult.
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// %TRUE if successful. If an error has occurred, this function
        /// will return %FALSE and set @error appropriately if present.
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.22")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="gboolean" type="gboolean" managed-name="System.Boolean" /> */
        /* transfer-ownership:none skip:1 direction:out */
        static extern unsafe System.Boolean g_async_initable_init_finish(
        /* <type name="AsyncInitable" type="GAsyncInitable*" managed-name="AsyncInitable" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr initable,
        /* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr res,
        /* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        System.IntPtr* error);

        static unsafe void InitFinish(System.IntPtr initable_, System.IntPtr res_, System.IntPtr userData_)
        {
            try
            {
                var userData = (System.Runtime.InteropServices.GCHandle)userData_;
                var completionSource = (System.Threading.Tasks.TaskCompletionSource<System.Object>)userData.Target;
                userData.Free();
                var error_ = System.IntPtr.Zero;
                g_async_initable_init_finish(initable_, res_, &error_);
                if (error_ != System.IntPtr.Zero)
                {
                    var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>(error_, GISharp.Runtime.Transfer.Full);
                    completionSource.SetException(new GISharp.Runtime.GErrorException(error));
                    return;
                }
                completionSource.SetResult(null);
            }
            catch (System.Exception ex)
            {
                GISharp.Lib.GLib.Log.LogUnhandledException(ex);
            }
        }

        static readonly GISharp.Lib.Gio.UnmanagedAsyncReadyCallback initAsyncCallbackDelegate = InitFinish;

        /// <summary>
        /// Finishes the async construction for the various g_async_initable_new
        /// calls, returning the created object or %NULL on error.
        /// </summary>
        /// <param name="initable">
        /// the #GAsyncInitable from the callback
        /// </param>
        /// <param name="res">
        /// the #GAsyncResult from the callback
        /// </param>
        /// <param name="error">
        /// return location for a #GError
        /// </param>
        /// <returns>
        /// a newly created #GObject,
        ///      or %NULL on error. Free with g_object_unref().
        /// </returns>
        [GISharp.Runtime.SinceAttribute("2.22")]
        [System.Runtime.InteropServices.DllImportAttribute("gio-2.0", CallingConvention = System.Runtime.InteropServices.CallingConvention.Cdecl)]
        /* <type name="GObject.Object" type="GObject*" managed-name="GISharp.Lib.GObject.Object" is-pointer="1" /> */
        /* transfer-ownership:full direction:out */
        static extern unsafe System.IntPtr g_async_initable_new_finish(
        /* <type name="AsyncInitable" type="GAsyncInitable*" managed-name="AsyncInitable" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr initable,
        /* <type name="AsyncResult" type="GAsyncResult*" managed-name="AsyncResult" is-pointer="1" /> */
        /* transfer-ownership:none direction:in */
        System.IntPtr res,
        /* <type name="GLib.Error" type="GError**" managed-name="GISharp.Lib.GLib.Error" is-pointer="1" /> */
        /* direction:inout transfer-ownership:full */
        System.IntPtr* error);

        static unsafe void NewFinish(System.IntPtr initable_, System.IntPtr res_, System.IntPtr userData_)
        {
            try
            {
                var userData = (System.Runtime.InteropServices.GCHandle)userData_;
                var completionSource = (System.Threading.Tasks.TaskCompletionSource<GISharp.Lib.GObject.Object>)userData.Target;
                userData.Free();
                var error_ = System.IntPtr.Zero;
                var ret_ = g_async_initable_new_finish(initable_,res_,&error_);
                if (error_ != System.IntPtr.Zero)
                {
                    var error = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GLib.Error>(error_, GISharp.Runtime.Transfer.Full);
                    completionSource.SetException(new GISharp.Runtime.GErrorException(error));
                    return;
                }
                var ret = GISharp.Runtime.Opaque.GetInstance<GISharp.Lib.GObject.Object>(ret_, GISharp.Runtime.Transfer.Full);
                completionSource.SetResult((ret));
            }
            catch (System.Exception ex)
            {
                GISharp.Lib.GLib.Log.LogUnhandledException(ex);
            }
        }

        static readonly GISharp.Lib.Gio.UnmanagedAsyncReadyCallback newAsyncCallbackDelegate = NewFinish;
    }
}