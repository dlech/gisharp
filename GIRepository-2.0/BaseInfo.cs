// This file was originally generated by the Gtk# (gapi3) code generator.
// It is now maintained by hand.

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Text;
using GISharp.Runtime;

namespace GISharp.Lib.GIRepository
{
    /// <summary>
    /// GIBaseInfo is the common base struct of all other *Info classes.
    /// </summary>
    [DebuggerDisplay ("{Namespace}.{Name}")]
    public abstract class BaseInfo : IEquatable<BaseInfo>, IDisposable
    {
        public IntPtr Handle { get; private set; }

        internal static T MarshalPtr<T> (IntPtr raw, bool owned = true) where T : BaseInfo
        {
            if (raw == IntPtr.Zero) {
                throw new ArgumentException("Null pointer", nameof(raw));
            }
            if (!owned) {
                g_base_info_ref (raw);
            }
            Type type = typeof(BaseInfo);
            switch ((InfoType)g_base_info_get_type (raw)) {
            case InfoType.Arg:
                type = typeof(ArgInfo);
                break;
            case InfoType.Boxed:
                // TODO: could be struct or union
                type = typeof(StructInfo);
                break;
            case InfoType.Callback:
                type = typeof(CallbackInfo);
                break;
            case InfoType.Constant:
                type = typeof(ConstantInfo);
                break;
            case InfoType.Enum:
            case InfoType.Flags:
                type = typeof(EnumInfo);
                break;
            case InfoType.Field:
                type = typeof(FieldInfo);
                break;
            case InfoType.Function:
                type = typeof(FunctionInfo);
                break;
            case InfoType.Interface:
                type = typeof(InterfaceInfo);
                break;
            case InfoType.Object:
                type = typeof(ObjectInfo);
                break;
            case InfoType.Property:
                type = typeof(PropertyInfo);
                break;
            case InfoType.Signal:
                type = typeof(SignalInfo);
                break;
            case InfoType.Struct:
                type = typeof(StructInfo);
                break;
            case InfoType.Type:
                type = typeof(TypeInfo);
                break;
            case InfoType.Union:
                type = typeof(UnionInfo);
                break;
            case InfoType.Unresolved:
                type = typeof(UnresolvedInfo);
                break;
            case InfoType.Value:
                type = typeof(ValueInfo);
                break;
            case InfoType.VFunc:
                type = typeof(VFuncInfo);
                break;
            }
            return (T)Activator.CreateInstance (type, new object[] { raw });
        }

        /// <summary>
        /// Gets all attributes associated with this node.
        /// </summary>
        /// <value>The attributes.</value>
        public IEnumerable<KeyValuePair<string, string>> Attributes {
            get {
                AttributeIter iter = AttributeIter.Zero;
                string key, value;
                while (IterateAttributes (ref iter, out key, out value)) {
                    yield return new KeyValuePair<string, string> (key, value);
                }
            }
        }

        [DllImport ("libgirepository-1.0", CallingConvention = CallingConvention.Cdecl)]
        static extern bool g_base_info_equal (IntPtr raw, IntPtr info2);

        #region IEquatable implementation

        public bool Equals(BaseInfo other)
        {
            return g_base_info_equal(Handle, other.Handle);
        }

        #endregion

        public override bool Equals(object obj)
        {
            if (obj is BaseInfo info) {
                return Equals(info);
            }
            return base.Equals(obj);
        }

        public override int GetHashCode ()
        {
            return Handle.GetHashCode ();
        }

        public static bool operator ==(BaseInfo? info1, BaseInfo? info2)
        {
            return object.Equals(info1, info2);
        }

        public static bool operator !=(BaseInfo? info1, BaseInfo? info2)
        {
            return !object.Equals(info1, info2);
        }

        [DllImport ("libgirepository-1.0", CallingConvention = CallingConvention.Cdecl)]
        static extern IntPtr g_base_info_get_attribute (IntPtr raw, IntPtr name);

        /// <summary>
        /// Retrieve an arbitrary attribute associated with this node.
        /// </summary>
        /// <returns>The attribute or <c>null</c> if no such attribute exists.</returns>
        /// <param name="name">Name.</param>
        public string? GetAttribute(string name)
        {
            IntPtr native_name = GMarshal.StringToUtf8Ptr (name);
            IntPtr raw_ret = g_base_info_get_attribute (Handle, native_name);
            var ret = GMarshal.Utf8PtrToString(raw_ret);
            GMarshal.Free (native_name);
            return ret;
        }

        [DllImport ("libgirepository-1.0", CallingConvention = CallingConvention.Cdecl)]
        static extern IntPtr g_base_info_get_container (IntPtr raw);

        /// <summary>
        /// Gets the container.
        /// </summary>
        /// <value>The container or <c>null</c>.</value>
        /// <remarks>
        /// The container is the parent <see cref="BaseInfo"/>. For instance, the
        /// parent of a <see cref="FunctionInfo"/> is an <see cref="ObjectInfo"/>
        /// or <see cref="InterfaceInfo"/>.
        /// </remarks>
        public BaseInfo Container {
            get {
                IntPtr raw_ret = g_base_info_get_container (Handle);
                BaseInfo ret = MarshalPtr<BaseInfo> (raw_ret, false);
                return ret;
            }
        }

        [DllImport ("libgirepository-1.0", CallingConvention = CallingConvention.Cdecl)]
        static extern IntPtr g_base_info_get_name (IntPtr raw);

        Lazy<string?> _Name;
        /// <summary>
        /// Gets the name.
        /// </summary>
        /// <value>The name or <c>null</c>.</value>
        /// <remarks>
        /// What the name represents depends on the <see cref="InfoType"/> of the
        /// info . For instance for <see cref="FunctionInfo"/> it is the name of
        /// the function.
        /// </remarks>
        public string? Name => _Name.Value;

        [DllImport ("libgirepository-1.0", CallingConvention = CallingConvention.Cdecl)]
        static extern IntPtr g_base_info_get_namespace (IntPtr raw);

        Lazy<string> _Namespace;
        /// <summary>
        /// Gets the namespace.
        /// </summary>
        /// <value>The namespace.</value>
        public string Namespace { get { return _Namespace.Value; } }

        [DllImport ("libgirepository-1.0", CallingConvention = CallingConvention.Cdecl)]
        static extern int g_base_info_get_type (IntPtr raw);

        /// <summary>
        /// Gets the info type of the BaseInfo.
        /// </summary>
        /// <value>The info type.</value>
        public InfoType InfoType {
            get {
                int raw_ret = g_base_info_get_type (Handle);
                var ret = (InfoType)raw_ret;
                return ret;
            }
        }

        [DllImport ("libgirepository-1.0", CallingConvention = CallingConvention.Cdecl)]
        static extern bool g_base_info_is_deprecated (IntPtr raw);

        /// <summary>
        /// Gets a value indicating whether this instance is deprecated or not.
        /// </summary>
        /// <value><c>true</c> if this instance is deprecated; otherwise, <c>false</c>.</value>
        public bool IsDeprecated {
            get {
                bool raw_ret = g_base_info_is_deprecated (Handle);
                bool ret = raw_ret;
                return ret;
            }
        }

        [DllImport ("libgirepository-1.0", CallingConvention = CallingConvention.Cdecl)]
        static extern bool g_base_info_iterate_attributes (IntPtr raw, ref AttributeIter iterator, out IntPtr name, out IntPtr value);

        bool IterateAttributes (ref AttributeIter iterator, out string name, out string value)
        {
            IntPtr native_name;
            IntPtr native_value;
            bool ret = g_base_info_iterate_attributes (Handle, ref iterator, out native_name, out native_value);
            name = GMarshal.Utf8PtrToString(native_name)!;
            value = GMarshal.Utf8PtrToString(native_value)!;
            return ret;
        }

        protected BaseInfo (IntPtr raw)
        {
            Handle = raw;
            _Namespace = new Lazy<string> (() => {
                var ret = g_base_info_get_namespace (Handle);
                return GMarshal.Utf8PtrToString(ret)!;
            });
            _Name = new Lazy<string?>(() => {
                // calling g_base_info_get_name on a TypeInfo will cause a crash.
                var typeInfo = this as TypeInfo;
                if (typeInfo != null) {
                    return null;
                }
                var ret = g_base_info_get_name (Handle);
                return GMarshal.Utf8PtrToString (ret);
            });
        }

        [DllImport ("libgirepository-1.0", CallingConvention = CallingConvention.Cdecl)]
        static extern IntPtr g_base_info_ref (IntPtr raw);

        [DllImport ("libgirepository-1.0", CallingConvention = CallingConvention.Cdecl)]
        static extern void g_base_info_unref (IntPtr raw);

        ~BaseInfo ()
        {
            Dispose (false);
        }

        #region IDisposable implementation

        public void Dispose ()
        {
            Dispose (true);
        }

        #endregion

        protected virtual void Dispose (bool disposing)
        {
            if (Handle != IntPtr.Zero) {
                var oldHandle = Handle;
                Handle = IntPtr.Zero;
                g_base_info_unref (oldHandle);
            }
        }

        public override string ToString ()
        {
            var builder = new StringBuilder ();
            var current = this;
            while (current != null) {
                if (current.Name != null) {
                    builder.Insert (0, current.Name);
                    builder.Insert (0, ".");
                }
                builder.Insert (0, current.InfoType);
                builder.Insert (0, ".");
                current = current.Container;
            }
            return string.Format ("{0}{1}", Namespace, builder);
        }
    }
}
