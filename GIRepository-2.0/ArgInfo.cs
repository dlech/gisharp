// This file was originally generated by the Gtk# (gapi3) code generator.
// It is now maintained by hand.

using System;
using System.Linq;
using System.Runtime.InteropServices;

namespace GISharp.Lib.GIRepository
{
    /// <summary>
    /// Struct representing an argument.
    /// </summary>
    /// <remarks>
    /// <see cref="ArgInfo"/> represents an argument. An argument is always part
    /// of a <see cref="CallbackInfo"/>.
    /// </remarks>
    public sealed class ArgInfo : BaseInfo
    {
        [DllImport ("libgirepository-1.0", CallingConvention = CallingConvention.Cdecl)]
        static extern int g_arg_info_get_closure (IntPtr raw);

        /// <summary>
        /// Obtain the index of the user data argument. This is only valid for
        /// arguments which are callbacks.
        /// </summary>
        /// <value>Index of the user data argument or -1 if there is none.</value>
        public int ClosureIndex {
            get {
                return g_arg_info_get_closure (Handle);
            }
        }

        readonly Lazy<ArgInfo> _Closure;
        public ArgInfo Closure { get { return _Closure.Value; } }

        [DllImport ("libgirepository-1.0", CallingConvention = CallingConvention.Cdecl)]
        static extern int g_arg_info_get_destroy (IntPtr raw);

        /// <summary>
        /// Obtains the index of the <see cref="GLib.UnmanagedDestroyNotify"/>
        /// argument. This is only valid for arguments which are callbacks.
        /// </summary>
        /// <value>Index of the <see cref="GLib.UnmanagedDestroyNotify"/> argument
        /// or -1 if there is none.</value>
        public int DestroyIndex {
            get {
                return g_arg_info_get_destroy (Handle);
            }
        }

        readonly Lazy<ArgInfo> _Destroy;
        public ArgInfo Destroy { get { return _Destroy.Value; } }

        readonly Lazy<ArgInfo> _ArrayLength;
        public ArgInfo ArrayLength { get { return _ArrayLength.Value; } }

        [DllImport ("libgirepository-1.0", CallingConvention = CallingConvention.Cdecl)]
        static extern Direction g_arg_info_get_direction (IntPtr raw);

        public Direction Direction {
            get {
                return g_arg_info_get_direction (Handle);
            }
        }

        [DllImport ("libgirepository-1.0", CallingConvention = CallingConvention.Cdecl)]
        static extern Transfer g_arg_info_get_ownership_transfer (IntPtr raw);

        public Transfer OwnershipTransfer {
            get {
                return g_arg_info_get_ownership_transfer (Handle);
            }
        }

        [DllImport ("libgirepository-1.0", CallingConvention = CallingConvention.Cdecl)]
        static extern ScopeType g_arg_info_get_scope (IntPtr raw);

        public ScopeType Scope {
            get {
                return g_arg_info_get_scope (Handle);
            }
        }

        [DllImport ("libgirepository-1.0", CallingConvention = CallingConvention.Cdecl)]
        static extern IntPtr g_arg_info_get_type (IntPtr raw);

        public TypeInfo TypeInfo {
            get {
                IntPtr raw_ret = g_arg_info_get_type (Handle);
                return MarshalPtr<TypeInfo> (raw_ret);
            }
        }

        [DllImport ("libgirepository-1.0", CallingConvention = CallingConvention.Cdecl)]
        static extern bool g_arg_info_is_caller_allocates (IntPtr raw);

        public bool IsCallerAllocates {
            get {
                return g_arg_info_is_caller_allocates (Handle);
            }
        }

        [DllImport ("libgirepository-1.0", CallingConvention = CallingConvention.Cdecl)]
        static extern bool g_arg_info_is_optional (IntPtr raw);

        public bool IsOptional {
            get {
                return g_arg_info_is_optional (Handle);
            }
        }

        [DllImport ("libgirepository-1.0", CallingConvention = CallingConvention.Cdecl)]
        static extern bool g_arg_info_is_return_value (IntPtr raw);

        public bool IsReturnValue {
            get {
                return g_arg_info_is_return_value (Handle);
            }
        }

        [DllImport ("libgirepository-1.0", CallingConvention = CallingConvention.Cdecl)]
        static extern bool g_arg_info_is_skip (IntPtr raw);

        public bool IsSkip {
            get {
                return g_arg_info_is_skip (Handle);
            }
        }

        [DllImport ("libgirepository-1.0", CallingConvention = CallingConvention.Cdecl)]
        static extern void g_arg_info_load_type (IntPtr raw, IntPtr type);

        void LoadType (TypeInfo type)
        {
            g_arg_info_load_type (Handle, type == null ? IntPtr.Zero : type.Handle);
        }

        [DllImport ("libgirepository-1.0", CallingConvention = CallingConvention.Cdecl)]
        static extern bool g_arg_info_may_be_null (IntPtr raw);

        public bool MayBeNull {
            get {
                return g_arg_info_may_be_null (Handle);
            }
        }

        readonly Lazy<int> _Index;
        public int Index { get { return _Index.Value; } }

        readonly Lazy<int> _InIndex;
        public int InIndex { get { return _InIndex.Value; } }

        readonly Lazy<int> _OutIndex;
        public int OutIndex { get { return _OutIndex.Value; } }


        public ArgInfo (IntPtr raw) : base (raw)
        {
            var callable = (CallableInfo)Container;
            _Closure = new Lazy<ArgInfo> (() =>
                callable.Args.ElementAtOrDefault (ClosureIndex));
            _Destroy = new Lazy<ArgInfo> (() =>
                callable.Args.ElementAtOrDefault (DestroyIndex));
            _ArrayLength = new Lazy<ArgInfo> (() =>
                callable.Args.ElementAtOrDefault (TypeInfo.ArrayLengthIndex));
            _Index = new Lazy<int> (() => callable.Args.IndexOf (this));
            _InIndex = new Lazy<int> (() => callable.InArgs.IndexOf (this));
            _OutIndex = new Lazy<int> (() => callable.OutArgs.IndexOf (this));
        }
    }
}
